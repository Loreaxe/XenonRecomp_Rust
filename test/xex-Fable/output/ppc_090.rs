pub fn sub_829FC880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FC880 size=80
    let mut pc: u32 = 0x829FC880;
    'dispatch: loop {
        match pc {
            0x829FC880 => {
    //   block [0x829FC880..0x829FC8B0)
	// 829FC880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FC888: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC88C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 829FC890: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FC894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FC898: 419A001C  beq cr6, 0x829fc8b4
	if ctx.cr[6].eq {
	pc = 0x829FC8B4; continue 'dispatch;
	}
	// 829FC89C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC8A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FC8A4: 419A000C  beq cr6, 0x829fc8b0
	if ctx.cr[6].eq {
	pc = 0x829FC8B0; continue 'dispatch;
	}
	// 829FC8A8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 829FC8AC: 4800000C  b 0x829fc8b8
	pc = 0x829FC8B8; continue 'dispatch;
            }
            0x829FC8B0 => {
    //   block [0x829FC8B0..0x829FC8B4)
	// 829FC8B0: 4B797589  bl 0x82193e38
	ctx.lr = 0x829FC8B4;
	sub_82193E38(ctx, base);
	pc = 0x829FC8B4; continue 'dispatch;
            }
            0x829FC8B4 => {
    //   block [0x829FC8B4..0x829FC8B8)
	// 829FC8B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829FC8B8; continue 'dispatch;
            }
            0x829FC8B8 => {
    //   block [0x829FC8B8..0x829FC8D0)
	// 829FC8B8: 388000C6  li r4, 0xc6
	ctx.r[4].s64 = 198;
	// 829FC8BC: 4B9902BD  bl 0x8238cb78
	ctx.lr = 0x829FC8C0;
	sub_8238CB78(ctx, base);
	// 829FC8C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FC8C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FC8C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FC8CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FC8D0 size=308
    let mut pc: u32 = 0x829FC8D0;
    'dispatch: loop {
        match pc {
            0x829FC8D0 => {
    //   block [0x829FC8D0..0x829FC914)
	// 829FC8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC8D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FC8D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FC8DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FC8E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC8E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC8E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FC8EC: 48206355  bl 0x82c02c40
	ctx.lr = 0x829FC8F0;
	sub_82C02C40(ctx, base);
	// 829FC8F0: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 829FC8F4: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 829FC8F8: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 829FC8FC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 829FC900: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC904: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 829FC908: 419A000C  beq cr6, 0x829fc914
	if ctx.cr[6].eq {
	pc = 0x829FC914; continue 'dispatch;
	}
	// 829FC90C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829FC910: 99610098  stb r11, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	pc = 0x829FC914; continue 'dispatch;
            }
            0x829FC914 => {
    //   block [0x829FC914..0x829FC94C)
	// 829FC914: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FC918: 4826C371  bl 0x82c68c88
	ctx.lr = 0x829FC91C;
	sub_82C68C88(ctx, base);
	// 829FC91C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FC920: 482065E9  bl 0x82c02f08
	ctx.lr = 0x829FC924;
	sub_82C02F08(ctx, base);
	// 829FC924: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 829FC928: 4B822931  bl 0x8221f258
	ctx.lr = 0x829FC92C;
	sub_8221F258(ctx, base);
	// 829FC92C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC930: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FC934: 419A004C  beq cr6, 0x829fc980
	if ctx.cr[6].eq {
	pc = 0x829FC980; continue 'dispatch;
	}
	// 829FC938: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829FC93C: 4B82291D  bl 0x8221f258
	ctx.lr = 0x829FC940;
	sub_8221F258(ctx, base);
	// 829FC940: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC944: 419A0008  beq cr6, 0x829fc94c
	if ctx.cr[6].eq {
	pc = 0x829FC94C; continue 'dispatch;
	}
	// 829FC948: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x829FC94C; continue 'dispatch;
            }
            0x829FC94C => {
    //   block [0x829FC94C..0x829FC958)
	// 829FC94C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC950: 41820008  beq 0x829fc958
	if ctx.cr[0].eq {
	pc = 0x829FC958; continue 'dispatch;
	}
	// 829FC954: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x829FC958; continue 'dispatch;
            }
            0x829FC958 => {
    //   block [0x829FC958..0x829FC980)
	// 829FC958: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 829FC95C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 829FC960: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FC964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC968: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829FC96C: 3BCA6D9C  addi r30, r10, 0x6d9c
	ctx.r[30].s64 = ctx.r[10].s64 + 28060;
	// 829FC970: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829FC974: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 829FC978: 906A6D9C  stw r3, 0x6d9c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28060 as u32), ctx.r[3].u32 ) };
	// 829FC97C: 48000014  b 0x829fc990
	pc = 0x829FC990; continue 'dispatch;
            }
            0x829FC980 => {
    //   block [0x829FC980..0x829FC990)
	// 829FC980: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829FC984: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FC988: 3BCB6D9C  addi r30, r11, 0x6d9c
	ctx.r[30].s64 = ctx.r[11].s64 + 28060;
	// 829FC98C: 906B6D9C  stw r3, 0x6d9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28060 as u32), ctx.r[3].u32 ) };
	pc = 0x829FC990; continue 'dispatch;
            }
            0x829FC990 => {
    //   block [0x829FC990..0x829FCA04)
	// 829FC990: 48000079  bl 0x829fca08
	ctx.lr = 0x829FC994;
	sub_829FCA08(ctx, base);
	// 829FC994: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FC998: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC99C: C02B9534  lfs f1, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FC9A0: 48000D71  bl 0x829fd710
	ctx.lr = 0x829FC9A4;
	sub_829FD710(ctx, base);
	// 829FC9A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC9A8: 4819A4D1  bl 0x82b96e78
	ctx.lr = 0x829FC9AC;
	sub_82B96E78(ctx, base);
	// 829FC9AC: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829FC9B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC9B4: 388A2078  addi r4, r10, 0x2078
	ctx.r[4].s64 = ctx.r[10].s64 + 8312;
	// 829FC9B8: 482061E1  bl 0x82c02b98
	ctx.lr = 0x829FC9BC;
	sub_82C02B98(ctx, base);
	// 829FC9BC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 829FC9C0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829FC9C4: 38A98CD8  addi r5, r9, -0x7328
	ctx.r[5].s64 = ctx.r[9].s64 + -29480;
	// 829FC9C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FC9CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FC9D0: 48206209  bl 0x82c02bd8
	ctx.lr = 0x829FC9D4;
	sub_82C02BD8(ctx, base);
	// 829FC9D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FC9D8: 4B818401  bl 0x82214dd8
	ctx.lr = 0x829FC9DC;
	sub_82214DD8(ctx, base);
	// 829FC9DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC9E0: 4819A499  bl 0x82b96e78
	ctx.lr = 0x829FC9E4;
	sub_82B96E78(ctx, base);
	// 829FC9E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FC9E8: 482062C9  bl 0x82c02cb0
	ctx.lr = 0x829FC9EC;
	sub_82C02CB0(ctx, base);
	// 829FC9EC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829FC9F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FC9F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FC9F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FC9FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FCA08 size=468
    let mut pc: u32 = 0x829FCA08;
    'dispatch: loop {
        match pc {
            0x829FCA08 => {
    //   block [0x829FCA08..0x829FCA3C)
	// 829FCA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCA0C: 482AC9F5  bl 0x82ca9400
	ctx.lr = 0x829FCA10;
	sub_82CA93D0(ctx, base);
	// 829FCA10: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829FCA14: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCA18: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829FCA1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FCA20: 83EB6D9C  lwz r31, 0x6d9c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28060 as u32) ) } as u64;
	// 829FCA24: 4B822835  bl 0x8221f258
	ctx.lr = 0x829FCA28;
	sub_8221F258(ctx, base);
	// 829FCA28: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829FCA2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCA30: 419A000C  beq cr6, 0x829fca3c
	if ctx.cr[6].eq {
	pc = 0x829FCA3C; continue 'dispatch;
	}
	// 829FCA34: 4819A445  bl 0x82b96e78
	ctx.lr = 0x829FCA38;
	sub_82B96E78(ctx, base);
	// 829FCA38: 48000008  b 0x829fca40
	pc = 0x829FCA40; continue 'dispatch;
            }
            0x829FCA3C => {
    //   block [0x829FCA3C..0x829FCA40)
	// 829FCA3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x829FCA40; continue 'dispatch;
            }
            0x829FCA40 => {
    //   block [0x829FCA40..0x829FCA5C)
	// 829FCA40: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 829FCA44: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829FCA48: 4B822811  bl 0x8221f258
	ctx.lr = 0x829FCA4C;
	sub_8221F258(ctx, base);
	// 829FCA4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCA50: 419A000C  beq cr6, 0x829fca5c
	if ctx.cr[6].eq {
	pc = 0x829FCA5C; continue 'dispatch;
	}
	// 829FCA54: 48002095  bl 0x829feae8
	ctx.lr = 0x829FCA58;
	sub_829FEAE8(ctx, base);
	// 829FCA58: 48000008  b 0x829fca60
	pc = 0x829FCA60; continue 'dispatch;
            }
            0x829FCA5C => {
    //   block [0x829FCA5C..0x829FCA60)
	// 829FCA5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x829FCA60; continue 'dispatch;
            }
            0x829FCA60 => {
    //   block [0x829FCA60..0x829FCBDC)
	// 829FCA60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FCA64: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 829FCA68: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829FCA6C: 3BAB9490  addi r29, r11, -0x6b70
	ctx.r[29].s64 = ctx.r[11].s64 + -27504;
	// 829FCA70: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 829FCA74: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 829FCA78: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829FCA7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FCA80: C3FDFFF4  lfs f31, -0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FCA84: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCBE0 size=96
    let mut pc: u32 = 0x829FCBE0;
    'dispatch: loop {
        match pc {
            0x829FCBE0 => {
    //   block [0x829FCBE0..0x829FCC2C)
	// 829FCBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCBE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FCBE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FCBEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCBF0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FCBF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCBF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCBFC: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FCC00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCC04: 4B803B6D  bl 0x82200770
	ctx.lr = 0x829FCC08;
	sub_82200770(ctx, base);
	// 829FCC08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCC0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FCC10: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FCC14: 48205F35  bl 0x82c02b48
	ctx.lr = 0x829FCC18;
	sub_82C02B48(ctx, base);
	// 829FCC18: 89210054  lbz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCC1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FCC20: 419A000C  beq cr6, 0x829fcc2c
	if ctx.cr[6].eq {
	pc = 0x829FCC2C; continue 'dispatch;
	}
	// 829FCC24: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FCC28: 488BCD2D  bl 0x832b9954
	ctx.lr = 0x829FCC2C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FCC2C; continue 'dispatch;
            }
            0x829FCC2C => {
    //   block [0x829FCC2C..0x829FCC40)
	// 829FCC2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FCC30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FCC34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FCC38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCC3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCC40 size=96
    let mut pc: u32 = 0x829FCC40;
    'dispatch: loop {
        match pc {
            0x829FCC40 => {
    //   block [0x829FCC40..0x829FCC8C)
	// 829FCC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FCC48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FCC4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCC50: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FCC54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCC58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCC5C: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FCC60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCC64: 4B803B0D  bl 0x82200770
	ctx.lr = 0x829FCC68;
	sub_82200770(ctx, base);
	// 829FCC68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829FCC6C: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 829FCC70: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FCC74: 48205ED5  bl 0x82c02b48
	ctx.lr = 0x829FCC78;
	sub_82C02B48(ctx, base);
	// 829FCC78: 89210054  lbz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCC7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FCC80: 419A000C  beq cr6, 0x829fcc8c
	if ctx.cr[6].eq {
	pc = 0x829FCC8C; continue 'dispatch;
	}
	// 829FCC84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FCC88: 488BCCCD  bl 0x832b9954
	ctx.lr = 0x829FCC8C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FCC8C; continue 'dispatch;
            }
            0x829FCC8C => {
    //   block [0x829FCC8C..0x829FCCA0)
	// 829FCC8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FCC90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FCC94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FCC98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCC9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCCA0 size=176
    let mut pc: u32 = 0x829FCCA0;
    'dispatch: loop {
        match pc {
            0x829FCCA0 => {
    //   block [0x829FCCA0..0x829FCCEC)
	// 829FCCA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCCA4: 482AC769  bl 0x82ca940c
	ctx.lr = 0x829FCCA8;
	sub_82CA93D0(ctx, base);
	// 829FCCA8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCCAC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FCCB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FCCB4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FCCB8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829FCCBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCCC0: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FCCC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCCC8: 4B803AA9  bl 0x82200770
	ctx.lr = 0x829FCCCC;
	sub_82200770(ctx, base);
	// 829FCCCC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FCCD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FCCD4: 409A0024  bne cr6, 0x829fccf8
	if !ctx.cr[6].eq {
	pc = 0x829FCCF8; continue 'dispatch;
	}
	// 829FCCD8: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCCDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FCCE0: 419A000C  beq cr6, 0x829fccec
	if ctx.cr[6].eq {
	pc = 0x829FCCEC; continue 'dispatch;
	}
	// 829FCCE4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FCCE8: 488BCC6D  bl 0x832b9954
	ctx.lr = 0x829FCCEC;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FCCEC; continue 'dispatch;
            }
            0x829FCCEC => {
    //   block [0x829FCCEC..0x829FCCF8)
	// 829FCCEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FCCF0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829FCCF4: 482AC768  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FCCF8 => {
    //   block [0x829FCCF8..0x829FCD18)
	// 829FCCF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FCCFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FCD00: 4B86A4A9  bl 0x822671a8
	ctx.lr = 0x829FCD04;
	sub_822671A8(ctx, base);
	// 829FCD04: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FCD08: 2F1F0006  cmpwi cr6, r31, 6
	ctx.cr[6].compare_i32(ctx.r[31].s32, 6, &mut ctx.xer);
	// 829FCD0C: 4198000C  blt cr6, 0x829fcd18
	if ctx.cr[6].lt {
	pc = 0x829FCD18; continue 'dispatch;
	}
	// 829FCD10: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829FCD14: 48000014  b 0x829fcd28
	pc = 0x829FCD28; continue 'dispatch;
            }
            0x829FCD18 => {
    //   block [0x829FCD18..0x829FCD28)
	// 829FCD18: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829FCD1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FCD20: 48001FF1  bl 0x829fed10
	ctx.lr = 0x829FCD24;
	sub_829FED10(ctx, base);
	// 829FCD24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x829FCD28; continue 'dispatch;
            }
            0x829FCD28 => {
    //   block [0x829FCD28..0x829FCD44)
	// 829FCD28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FCD2C: 4B88CD1D  bl 0x82289a48
	ctx.lr = 0x829FCD30;
	sub_82289A48(ctx, base);
	// 829FCD30: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCD34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FCD38: 419A000C  beq cr6, 0x829fcd44
	if ctx.cr[6].eq {
	pc = 0x829FCD44; continue 'dispatch;
	}
	// 829FCD3C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FCD40: 488BCC15  bl 0x832b9954
	ctx.lr = 0x829FCD44;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FCD44; continue 'dispatch;
            }
            0x829FCD44 => {
    //   block [0x829FCD44..0x829FCD50)
	// 829FCD44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FCD48: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829FCD4C: 482AC710  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCD50 size=160
    let mut pc: u32 = 0x829FCD50;
    'dispatch: loop {
        match pc {
            0x829FCD50 => {
    //   block [0x829FCD50..0x829FCDD4)
	// 829FCD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCD54: 482AC6B9  bl 0x82ca940c
	ctx.lr = 0x829FCD58;
	sub_82CA93D0(ctx, base);
	// 829FCD58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCD5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FCD60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCD64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FCD68: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829FCD6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCD70: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FCD74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCD78: 4B8039F9  bl 0x82200770
	ctx.lr = 0x829FCD7C;
	sub_82200770(ctx, base);
	// 829FCD7C: 83FF0010  lwz r31, 0x10(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FCD80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FCD84: 419A0050  beq cr6, 0x829fcdd4
	if ctx.cr[6].eq {
	pc = 0x829FCDD4; continue 'dispatch;
	}
	// 829FCD88: 2F1E0006  cmpwi cr6, r30, 6
	ctx.cr[6].compare_i32(ctx.r[30].s32, 6, &mut ctx.xer);
	// 829FCD8C: 40980048  bge cr6, 0x829fcdd4
	if !ctx.cr[6].lt {
	pc = 0x829FCDD4; continue 'dispatch;
	}
	// 829FCD90: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FCD94: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 829FCD98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCD9C: 419A0038  beq cr6, 0x829fcdd4
	if ctx.cr[6].eq {
	pc = 0x829FCDD4; continue 'dispatch;
	}
	// 829FCDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCDA4: 38A007D0  li r5, 0x7d0
	ctx.r[5].s64 = 2000;
	// 829FCDA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FCDAC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FCDB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FCDB4: 4E800421  bctrl
	ctx.lr = 0x829FCDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FCDB8: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FCDBC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829FCDC0: 409A0014  bne cr6, 0x829fcdd4
	if !ctx.cr[6].eq {
	pc = 0x829FCDD4; continue 'dispatch;
	}
	// 829FCDC4: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 829FCDC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FCDCC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829FCDD0: 4B8A5DB9  bl 0x822a2b88
	ctx.lr = 0x829FCDD4;
	sub_822A2B88(ctx, base);
            }
            0x829FCDD4 => {
    //   block [0x829FCDD4..0x829FCDE8)
	// 829FCDD4: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCDD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FCDDC: 419A000C  beq cr6, 0x829fcde8
	if ctx.cr[6].eq {
	pc = 0x829FCDE8; continue 'dispatch;
	}
	// 829FCDE0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FCDE4: 488BCB71  bl 0x832b9954
	ctx.lr = 0x829FCDE8;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FCDE8; continue 'dispatch;
            }
            0x829FCDE8 => {
    //   block [0x829FCDE8..0x829FCDF0)
	// 829FCDE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FCDEC: 482AC670  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCDF0 size=156
    let mut pc: u32 = 0x829FCDF0;
    'dispatch: loop {
        match pc {
            0x829FCDF0 => {
    //   block [0x829FCDF0..0x829FCE34)
	// 829FCDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCDF4: 482AC615  bl 0x82ca9408
	ctx.lr = 0x829FCDF8;
	sub_82CA93D0(ctx, base);
	// 829FCDF8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829FCDFC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCE00: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FCE04: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FCE08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCE0C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829FCE10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCE14: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FCE18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCE1C: 4B803955  bl 0x82200770
	ctx.lr = 0x829FCE20;
	sub_82200770(ctx, base);
	// 829FCE20: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FCE24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FCE28: 419A0044  beq cr6, 0x829fce6c
	if ctx.cr[6].eq {
	pc = 0x829FCE6C; continue 'dispatch;
	}
	// 829FCE2C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829FCE30: 3BC00006  li r30, 6
	ctx.r[30].s64 = 6;
	pc = 0x829FCE34; continue 'dispatch;
            }
            0x829FCE34 => {
    //   block [0x829FCE34..0x829FCE58)
	// 829FCE34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCE38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCE3C: 419A001C  beq cr6, 0x829fce58
	if ctx.cr[6].eq {
	pc = 0x829FCE58; continue 'dispatch;
	}
	// 829FCE40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCE44: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829FCE48: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FCE4C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 829FCE50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FCE54: 4E800421  bctrl
	ctx.lr = 0x829FCE58;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FCE58 => {
    //   block [0x829FCE58..0x829FCE6C)
	// 829FCE58: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829FCE5C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 829FCE60: 4082FFD4  bne 0x829fce34
	if !ctx.cr[0].eq {
	pc = 0x829FCE34; continue 'dispatch;
	}
	// 829FCE64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FCE68: 4B8A5D21  bl 0x822a2b88
	ctx.lr = 0x829FCE6C;
	sub_822A2B88(ctx, base);
	pc = 0x829FCE6C; continue 'dispatch;
            }
            0x829FCE6C => {
    //   block [0x829FCE6C..0x829FCE80)
	// 829FCE6C: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCE70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FCE74: 419A000C  beq cr6, 0x829fce80
	if ctx.cr[6].eq {
	pc = 0x829FCE80; continue 'dispatch;
	}
	// 829FCE78: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FCE7C: 488BCAD9  bl 0x832b9954
	ctx.lr = 0x829FCE80;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FCE80; continue 'dispatch;
            }
            0x829FCE80 => {
    //   block [0x829FCE80..0x829FCE8C)
	// 829FCE80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FCE84: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829FCE88: 482AC5D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCE90 size=144
    let mut pc: u32 = 0x829FCE90;
    'dispatch: loop {
        match pc {
            0x829FCE90 => {
    //   block [0x829FCE90..0x829FCED8)
	// 829FCE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCE94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FCE98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FCE9C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCEA0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FCEA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCEA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCEAC: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FCEB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCEB4: 4B8038BD  bl 0x82200770
	ctx.lr = 0x829FCEB8;
	sub_82200770(ctx, base);
	// 829FCEB8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FCEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FCEC0: 409A0030  bne cr6, 0x829fcef0
	if !ctx.cr[6].eq {
	pc = 0x829FCEF0; continue 'dispatch;
	}
	// 829FCEC4: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCEC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FCECC: 419A000C  beq cr6, 0x829fced8
	if ctx.cr[6].eq {
	pc = 0x829FCED8; continue 'dispatch;
	}
	// 829FCED0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FCED4: 488BCA81  bl 0x832b9954
	ctx.lr = 0x829FCED8;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FCED8; continue 'dispatch;
            }
            0x829FCED8 => {
    //   block [0x829FCED8..0x829FCEF0)
	// 829FCED8: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 829FCEDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FCEE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FCEE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FCEE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCEEC: 4E800020  blr
	return;
            }
            0x829FCEF0 => {
    //   block [0x829FCEF0..0x829FCF08)
	// 829FCEF0: 89210054  lbz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCEF4: 83EB0018  lwz r31, 0x18(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FCEF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FCEFC: 419A000C  beq cr6, 0x829fcf08
	if ctx.cr[6].eq {
	pc = 0x829FCF08; continue 'dispatch;
	}
	// 829FCF00: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FCF04: 488BCA51  bl 0x832b9954
	ctx.lr = 0x829FCF08;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FCF08; continue 'dispatch;
            }
            0x829FCF08 => {
    //   block [0x829FCF08..0x829FCF20)
	// 829FCF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FCF0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FCF10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FCF14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FCF18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCF1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCF20 size=244
    let mut pc: u32 = 0x829FCF20;
    'dispatch: loop {
        match pc {
            0x829FCF20 => {
    //   block [0x829FCF20..0x829FCF70)
	// 829FCF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCF24: 482AC4E9  bl 0x82ca940c
	ctx.lr = 0x829FCF28;
	sub_82CA93D0(ctx, base);
	// 829FCF28: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCF2C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FCF30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCF34: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829FCF38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCF3C: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FCF40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FCF44: 4B80382D  bl 0x82200770
	ctx.lr = 0x829FCF48;
	sub_82200770(ctx, base);
	// 829FCF48: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FCF4C: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 829FCF50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCF54: 419A001C  beq cr6, 0x829fcf70
	if ctx.cr[6].eq {
	pc = 0x829FCF70; continue 'dispatch;
	}
	// 829FCF58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCF5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FCF60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FCF64: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 829FCF68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FCF6C: 4E800421  bctrl
	ctx.lr = 0x829FCF70;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FCF70 => {
    //   block [0x829FCF70..0x829FCFE4)
	// 829FCF70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FCF74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FCF78: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 829FCF7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCF80: 4B82FF51  bl 0x8222ced0
	ctx.lr = 0x829FCF84;
	sub_8222CED0(ctx, base);
	// 829FCF84: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FCF88: 83FF0014  lwz r31, 0x14(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 829FCF8C: 4B7D8F7D  bl 0x821d5f08
	ctx.lr = 0x829FCF90;
	sub_821D5F08(ctx, base);
	// 829FCF90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FCF94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FCF98: 4B868289  bl 0x82265220
	ctx.lr = 0x829FCF9C;
	sub_82265220(ctx, base);
	// 829FCF9C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829FCFA0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829FCFA4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829FCFA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FCFAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FCFB0: 4B7E3F99  bl 0x821e0f48
	ctx.lr = 0x829FCFB4;
	sub_821E0F48(ctx, base);
	// 829FCFB4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FCFB8: 4B88CA91  bl 0x82289a48
	ctx.lr = 0x829FCFBC;
	sub_82289A48(ctx, base);
	// 829FCFBC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829FCFC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FCFC4: 48214D05  bl 0x82c11cc8
	ctx.lr = 0x829FCFC8;
	sub_82C11CC8(ctx, base);
	// 829FCFC8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FCFCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCFD0: 419A0014  beq cr6, 0x829fcfe4
	if ctx.cr[6].eq {
	pc = 0x829FCFE4; continue 'dispatch;
	}
	// 829FCFD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCFD8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FCFDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FCFE0: 4E800421  bctrl
	ctx.lr = 0x829FCFE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FCFE4 => {
    //   block [0x829FCFE4..0x829FD00C)
	// 829FCFE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FCFE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCFEC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FCFF0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829FCFF4: 4B817DE5  bl 0x82214dd8
	ctx.lr = 0x829FCFF8;
	sub_82214DD8(ctx, base);
	// 829FCFF8: 89410064  lbz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FCFFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FD000: 419A000C  beq cr6, 0x829fd00c
	if ctx.cr[6].eq {
	pc = 0x829FD00C; continue 'dispatch;
	}
	// 829FD004: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FD008: 488BC94D  bl 0x832b9954
	ctx.lr = 0x829FD00C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD00C; continue 'dispatch;
            }
            0x829FD00C => {
    //   block [0x829FD00C..0x829FD014)
	// 829FD00C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829FD010: 482AC44C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FD018 size=336
    let mut pc: u32 = 0x829FD018;
    'dispatch: loop {
        match pc {
            0x829FD018 => {
    //   block [0x829FD018..0x829FD168)
	// 829FD018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD01C: 482AC3ED  bl 0x82ca9408
	ctx.lr = 0x829FD020;
	sub_82CA93D0(ctx, base);
	// 829FD020: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD168 size=316
    let mut pc: u32 = 0x829FD168;
    'dispatch: loop {
        match pc {
            0x829FD168 => {
    //   block [0x829FD168..0x829FD1A0)
	// 829FD168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD16C: 482AC29D  bl 0x82ca9408
	ctx.lr = 0x829FD170;
	sub_82CA93D0(ctx, base);
	// 829FD170: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD174: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD178: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FD17C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829FD180: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD184: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD188: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD18C: 4B8035E5  bl 0x82200770
	ctx.lr = 0x829FD190;
	sub_82200770(ctx, base);
	// 829FD190: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FD194: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 829FD198: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829FD19C: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FD1A0; continue 'dispatch;
            }
            0x829FD1A0 => {
    //   block [0x829FD1A0..0x829FD1A4)
	// 829FD1A0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x829FD1A4; continue 'dispatch;
            }
            0x829FD1A4 => {
    //   block [0x829FD1A4..0x829FD1B8)
	// 829FD1A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FD1A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FD1AC: 419A000C  beq cr6, 0x829fd1b8
	if ctx.cr[6].eq {
	pc = 0x829FD1B8; continue 'dispatch;
	}
	// 829FD1B0: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FD1B4: 419A0008  beq cr6, 0x829fd1bc
	if ctx.cr[6].eq {
	pc = 0x829FD1BC; continue 'dispatch;
	}
	pc = 0x829FD1B8; continue 'dispatch;
            }
            0x829FD1B8 => {
    //   block [0x829FD1B8..0x829FD1BC)
	// 829FD1B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FD1BC; continue 'dispatch;
            }
            0x829FD1BC => {
    //   block [0x829FD1BC..0x829FD1D0)
	// 829FD1BC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FD1C0: 419A00C8  beq cr6, 0x829fd288
	if ctx.cr[6].eq {
	pc = 0x829FD288; continue 'dispatch;
	}
	// 829FD1C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FD1C8: 409A0008  bne cr6, 0x829fd1d0
	if !ctx.cr[6].eq {
	pc = 0x829FD1D0; continue 'dispatch;
	}
	// 829FD1CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FD1D0; continue 'dispatch;
            }
            0x829FD1D0 => {
    //   block [0x829FD1D0..0x829FD1E0)
	// 829FD1D0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FD1D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FD1D8: 409A0008  bne cr6, 0x829fd1e0
	if !ctx.cr[6].eq {
	pc = 0x829FD1E0; continue 'dispatch;
	}
	// 829FD1DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FD1E0; continue 'dispatch;
            }
            0x829FD1E0 => {
    //   block [0x829FD1E0..0x829FD20C)
	// 829FD1E0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FD1E4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829FD1E8: 409A008C  bne cr6, 0x829fd274
	if !ctx.cr[6].eq {
	pc = 0x829FD274; continue 'dispatch;
	}
	// 829FD1EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829FD1F0: 419A001C  beq cr6, 0x829fd20c
	if ctx.cr[6].eq {
	pc = 0x829FD20C; continue 'dispatch;
	}
	// 829FD1F4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD1F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FD1FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FD200: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD204: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FD208: 4E800421  bctrl
	ctx.lr = 0x829FD20C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FD20C => {
    //   block [0x829FD20C..0x829FD224)
	// 829FD20C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FD210: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FD214: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829FD218: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829FD21C: 409A0008  bne cr6, 0x829fd224
	if !ctx.cr[6].eq {
	pc = 0x829FD224; continue 'dispatch;
	}
	// 829FD220: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FD224; continue 'dispatch;
            }
            0x829FD224 => {
    //   block [0x829FD224..0x829FD260)
	// 829FD224: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD228: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FD22C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829FD230: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FD234: 419A002C  beq cr6, 0x829fd260
	if ctx.cr[6].eq {
	pc = 0x829FD260; continue 'dispatch;
	}
	// 829FD238: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FD23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD240: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FD244: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD248: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FD24C: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 829FD250: 4B81EAE9  bl 0x8221bd38
	ctx.lr = 0x829FD254;
	sub_8221BD38(ctx, base);
	// 829FD254: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FD258: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 829FD25C: 90FE0008  stw r7, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	pc = 0x829FD260; continue 'dispatch;
            }
            0x829FD260 => {
    //   block [0x829FD260..0x829FD274)
	// 829FD260: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FD264: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829FD268: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FD26C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FD270: 4BFFFF34  b 0x829fd1a4
	pc = 0x829FD1A4; continue 'dispatch;
            }
            0x829FD274 => {
    //   block [0x829FD274..0x829FD280)
	// 829FD274: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FD278: 409A0008  bne cr6, 0x829fd280
	if !ctx.cr[6].eq {
	pc = 0x829FD280; continue 'dispatch;
	}
	// 829FD27C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FD280; continue 'dispatch;
            }
            0x829FD280 => {
    //   block [0x829FD280..0x829FD288)
	// 829FD280: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD284: 4BFFFF1C  b 0x829fd1a0
	pc = 0x829FD1A0; continue 'dispatch;
            }
            0x829FD288 => {
    //   block [0x829FD288..0x829FD29C)
	// 829FD288: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FD28C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FD290: 419A000C  beq cr6, 0x829fd29c
	if ctx.cr[6].eq {
	pc = 0x829FD29C; continue 'dispatch;
	}
	// 829FD294: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FD298: 488BC6BD  bl 0x832b9954
	ctx.lr = 0x829FD29C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD29C; continue 'dispatch;
            }
            0x829FD29C => {
    //   block [0x829FD29C..0x829FD2A4)
	// 829FD29C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FD2A0: 482AC1B8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD2A8 size=208
    let mut pc: u32 = 0x829FD2A8;
    'dispatch: loop {
        match pc {
            0x829FD2A8 => {
    //   block [0x829FD2A8..0x829FD2F0)
	// 829FD2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD2AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD2B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FD2B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD2B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD2BC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD2C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FD2C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FD2C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD2CC: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD2D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD2D4: 4B80349D  bl 0x82200770
	ctx.lr = 0x829FD2D8;
	sub_82200770(ctx, base);
	// 829FD2D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD2DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FD2E0: 409A0010  bne cr6, 0x829fd2f0
	if !ctx.cr[6].eq {
	pc = 0x829FD2F0; continue 'dispatch;
	}
	// 829FD2E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829FD2E8: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 829FD2EC: 48000008  b 0x829fd2f4
	pc = 0x829FD2F4; continue 'dispatch;
            }
            0x829FD2F0 => {
    //   block [0x829FD2F0..0x829FD2F4)
	// 829FD2F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FD2F4; continue 'dispatch;
            }
            0x829FD2F4 => {
    //   block [0x829FD2F4..0x829FD318)
	// 829FD2F4: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FD2F8: 48206379  bl 0x82c03670
	ctx.lr = 0x829FD2FC;
	sub_82C03670(ctx, base);
	// 829FD2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD300: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FD304: 409A0044  bne cr6, 0x829fd348
	if !ctx.cr[6].eq {
	pc = 0x829FD348; continue 'dispatch;
	}
	// 829FD308: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829FD30C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829FD310: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 829FD314: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	pc = 0x829FD318; continue 'dispatch;
            }
            0x829FD318 => {
    //   block [0x829FD318..0x829FD348)
	// 829FD318: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FD31C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FD320: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FD324: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FD328: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FD32C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FD330: 4082FFE8  bne 0x829fd318
	if !ctx.cr[0].eq {
	pc = 0x829FD318; continue 'dispatch;
	}
	// 829FD334: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FD338: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FD33C: 4820575D  bl 0x82c02a98
	ctx.lr = 0x829FD340;
	sub_82C02A98(ctx, base);
	// 829FD340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD344: 4B817A95  bl 0x82214dd8
	ctx.lr = 0x829FD348;
	sub_82214DD8(ctx, base);
	pc = 0x829FD348; continue 'dispatch;
            }
            0x829FD348 => {
    //   block [0x829FD348..0x829FD35C)
	// 829FD348: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FD34C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FD350: 419A000C  beq cr6, 0x829fd35c
	if ctx.cr[6].eq {
	pc = 0x829FD35C; continue 'dispatch;
	}
	// 829FD354: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FD358: 488BC5FD  bl 0x832b9954
	ctx.lr = 0x829FD35C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD35C; continue 'dispatch;
            }
            0x829FD35C => {
    //   block [0x829FD35C..0x829FD378)
	// 829FD35C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD360: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FD364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD36C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FD370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD378 size=128
    let mut pc: u32 = 0x829FD378;
    'dispatch: loop {
        match pc {
            0x829FD378 => {
    //   block [0x829FD378..0x829FD3C0)
	// 829FD378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD37C: 482AC08D  bl 0x82ca9408
	ctx.lr = 0x829FD380;
	sub_82CA93D0(ctx, base);
	// 829FD380: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD384: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD38C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829FD390: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829FD394: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD398: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD39C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD3A0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829FD3A4: 4B8033CD  bl 0x82200770
	ctx.lr = 0x829FD3A8;
	sub_82200770(ctx, base);
	// 829FD3A8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD3AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FD3B0: 409A0010  bne cr6, 0x829fd3c0
	if !ctx.cr[6].eq {
	pc = 0x829FD3C0; continue 'dispatch;
	}
	// 829FD3B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829FD3B8: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 829FD3BC: 48000008  b 0x829fd3c4
	pc = 0x829FD3C4; continue 'dispatch;
            }
            0x829FD3C0 => {
    //   block [0x829FD3C0..0x829FD3C4)
	// 829FD3C0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FD3C4; continue 'dispatch;
            }
            0x829FD3C4 => {
    //   block [0x829FD3C4..0x829FD3EC)
	// 829FD3C4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829FD3C8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FD3CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829FD3D0: 482056D9  bl 0x82c02aa8
	ctx.lr = 0x829FD3D4;
	sub_82C02AA8(ctx, base);
	// 829FD3D4: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FD3D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD3DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FD3E0: 419A000C  beq cr6, 0x829fd3ec
	if ctx.cr[6].eq {
	pc = 0x829FD3EC; continue 'dispatch;
	}
	// 829FD3E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FD3E8: 488BC56D  bl 0x832b9954
	ctx.lr = 0x829FD3EC;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD3EC; continue 'dispatch;
            }
            0x829FD3EC => {
    //   block [0x829FD3EC..0x829FD3F8)
	// 829FD3EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD3F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FD3F4: 482AC064  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD3F8 size=108
    let mut pc: u32 = 0x829FD3F8;
    'dispatch: loop {
        match pc {
            0x829FD3F8 => {
    //   block [0x829FD3F8..0x829FD44C)
	// 829FD3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FD404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD40C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD414: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FD418: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD41C: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD424: 4B80334D  bl 0x82200770
	ctx.lr = 0x829FD428;
	sub_82200770(ctx, base);
	// 829FD428: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD42C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FD430: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FD434: 482056B5  bl 0x82c02ae8
	ctx.lr = 0x829FD438;
	sub_82C02AE8(ctx, base);
	// 829FD438: 89210054  lbz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FD43C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FD440: 419A000C  beq cr6, 0x829fd44c
	if ctx.cr[6].eq {
	pc = 0x829FD44C; continue 'dispatch;
	}
	// 829FD444: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FD448: 488BC50D  bl 0x832b9954
	ctx.lr = 0x829FD44C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD44C; continue 'dispatch;
            }
            0x829FD44C => {
    //   block [0x829FD44C..0x829FD464)
	// 829FD44C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FD450: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD454: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD458: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FD45C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FD468 size=132
    let mut pc: u32 = 0x829FD468;
    'dispatch: loop {
        match pc {
            0x829FD468 => {
    //   block [0x829FD468..0x829FD4EC)
	// 829FD468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD470: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FD474: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD478: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD4F0 size=104
    let mut pc: u32 = 0x829FD4F0;
    'dispatch: loop {
        match pc {
            0x829FD4F0 => {
    //   block [0x829FD4F0..0x829FD540)
	// 829FD4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD4F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD4F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FD4FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD504: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD50C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FD510: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD514: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD51C: 4B803255  bl 0x82200770
	ctx.lr = 0x829FD520;
	sub_82200770(ctx, base);
	// 829FD520: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FD524: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FD528: 48205631  bl 0x82c02b58
	ctx.lr = 0x829FD52C;
	sub_82C02B58(ctx, base);
	// 829FD52C: 89210054  lbz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FD530: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FD534: 419A000C  beq cr6, 0x829fd540
	if ctx.cr[6].eq {
	pc = 0x829FD540; continue 'dispatch;
	}
	// 829FD538: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FD53C: 488BC419  bl 0x832b9954
	ctx.lr = 0x829FD540;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD540; continue 'dispatch;
            }
            0x829FD540 => {
    //   block [0x829FD540..0x829FD558)
	// 829FD540: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FD544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD54C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FD550: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD558 size=132
    let mut pc: u32 = 0x829FD558;
    'dispatch: loop {
        match pc {
            0x829FD558 => {
    //   block [0x829FD558..0x829FD5C0)
	// 829FD558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FD564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD568: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD56C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD574: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829FD578: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD57C: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD580: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD584: 4B8031ED  bl 0x82200770
	ctx.lr = 0x829FD588;
	sub_82200770(ctx, base);
	// 829FD588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD58C: 481998ED  bl 0x82b96e78
	ctx.lr = 0x829FD590;
	sub_82B96E78(ctx, base);
	// 829FD590: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829FD594: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829FD598: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FD59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD5A0: 48205639  bl 0x82c02bd8
	ctx.lr = 0x829FD5A4;
	sub_82C02BD8(ctx, base);
	// 829FD5A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD5A8: 481998D1  bl 0x82b96e78
	ctx.lr = 0x829FD5AC;
	sub_82B96E78(ctx, base);
	// 829FD5AC: 8921005C  lbz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FD5B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FD5B4: 419A000C  beq cr6, 0x829fd5c0
	if ctx.cr[6].eq {
	pc = 0x829FD5C0; continue 'dispatch;
	}
	// 829FD5B8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FD5BC: 488BC399  bl 0x832b9954
	ctx.lr = 0x829FD5C0;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD5C0; continue 'dispatch;
            }
            0x829FD5C0 => {
    //   block [0x829FD5C0..0x829FD5DC)
	// 829FD5C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD5C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FD5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD5D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FD5D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD5D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FD5E0 size=152
    let mut pc: u32 = 0x829FD5E0;
    'dispatch: loop {
        match pc {
            0x829FD5E0 => {
    //   block [0x829FD5E0..0x829FD63C)
	// 829FD5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD5E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD5E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD5EC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 829FD5F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD5F4: 39640014  addi r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 + 20;
	// 829FD5F8: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 829FD5FC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FD600: 7C0B1C2E  lfsx f0, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD604: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 829FD608: 419A0058  beq cr6, 0x829fd660
	if ctx.cr[6].eq {
	pc = 0x829FD660; continue 'dispatch;
	}
	// 829FD60C: 7C2B1D2E  stfsx f1, r11, r3
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 829FD610: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FD614: C0030050  lfs f0, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD618: C1A30054  lfs f13, 0x54(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FD61C: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829FD620: 396BB480  addi r11, r11, -0x4b80
	ctx.r[11].s64 = ctx.r[11].s64 + -19328;
	// 829FD624: C00B01D0  lfs f0, 0x1d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD628: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD62C: 41980010  blt cr6, 0x829fd63c
	if ctx.cr[6].lt {
	pc = 0x829FD63C; continue 'dispatch;
	}
	// 829FD630: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD634: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD638: 40990008  ble cr6, 0x829fd640
	if !ctx.cr[6].gt {
	pc = 0x829FD640; continue 'dispatch;
	}
	pc = 0x829FD63C; continue 'dispatch;
            }
            0x829FD63C => {
    //   block [0x829FD63C..0x829FD640)
	// 829FD63C: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x829FD640; continue 'dispatch;
            }
            0x829FD640 => {
    //   block [0x829FD640..0x829FD660)
	// 829FD640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD644: 48199835  bl 0x82b96e78
	ctx.lr = 0x829FD648;
	sub_82B96E78(ctx, base);
	// 829FD648: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829FD64C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD650: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FD654: 4820552D  bl 0x82c02b80
	ctx.lr = 0x829FD658;
	sub_82C02B80(ctx, base);
	// 829FD658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD65C: 4819981D  bl 0x82b96e78
	ctx.lr = 0x829FD660;
	sub_82B96E78(ctx, base);
	pc = 0x829FD660; continue 'dispatch;
            }
            0x829FD660 => {
    //   block [0x829FD660..0x829FD678)
	// 829FD660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FD664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD66C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FD670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FD678 size=152
    let mut pc: u32 = 0x829FD678;
    'dispatch: loop {
        match pc {
            0x829FD678 => {
    //   block [0x829FD678..0x829FD6C0)
	// 829FD678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD67C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD680: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 829FD684: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD688: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD68C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FD690: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD694: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD698: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD69C: 4B8030D5  bl 0x82200770
	ctx.lr = 0x829FD6A0;
	sub_82200770(ctx, base);
	// 829FD6A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FD6A4: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 829FD6A8: C00BFFF4  lfs f0, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD6AC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD6B0: 41980010  blt cr6, 0x829fd6c0
	if ctx.cr[6].lt {
	pc = 0x829FD6C0; continue 'dispatch;
	}
	// 829FD6B4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD6B8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD6BC: 40990008  ble cr6, 0x829fd6c4
	if !ctx.cr[6].gt {
	pc = 0x829FD6C4; continue 'dispatch;
	}
	pc = 0x829FD6C0; continue 'dispatch;
            }
            0x829FD6C0 => {
    //   block [0x829FD6C0..0x829FD6C4)
	// 829FD6C0: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x829FD6C4; continue 'dispatch;
            }
            0x829FD6C4 => {
    //   block [0x829FD6C4..0x829FD6FC)
	// 829FD6C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD6C8: 481997B1  bl 0x82b96e78
	ctx.lr = 0x829FD6CC;
	sub_82B96E78(ctx, base);
	// 829FD6CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FD6D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FD6D4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FD6D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD6DC: 48205495  bl 0x82c02b70
	ctx.lr = 0x829FD6E0;
	sub_82C02B70(ctx, base);
	// 829FD6E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD6E4: 48199795  bl 0x82b96e78
	ctx.lr = 0x829FD6E8;
	sub_82B96E78(ctx, base);
	// 829FD6E8: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FD6EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FD6F0: 419A000C  beq cr6, 0x829fd6fc
	if ctx.cr[6].eq {
	pc = 0x829FD6FC; continue 'dispatch;
	}
	// 829FD6F4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FD6F8: 488BC25D  bl 0x832b9954
	ctx.lr = 0x829FD6FC;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD6FC; continue 'dispatch;
            }
            0x829FD6FC => {
    //   block [0x829FD6FC..0x829FD710)
	// 829FD6FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FD700: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD704: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD708: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD70C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FD710 size=140
    let mut pc: u32 = 0x829FD710;
    'dispatch: loop {
        match pc {
            0x829FD710 => {
    //   block [0x829FD710..0x829FD760)
	// 829FD710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD718: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD71C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 829FD720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD724: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD728: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FD72C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD730: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD734: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD73C: 4B803035  bl 0x82200770
	ctx.lr = 0x829FD740;
	sub_82200770(ctx, base);
	// 829FD740: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FD744: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 829FD748: C00BFFF4  lfs f0, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD74C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD750: 41980010  blt cr6, 0x829fd760
	if ctx.cr[6].lt {
	pc = 0x829FD760; continue 'dispatch;
	}
	// 829FD754: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD758: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD75C: 40990008  ble cr6, 0x829fd764
	if !ctx.cr[6].gt {
	pc = 0x829FD764; continue 'dispatch;
	}
	pc = 0x829FD760; continue 'dispatch;
            }
            0x829FD760 => {
    //   block [0x829FD760..0x829FD764)
	// 829FD760: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x829FD764; continue 'dispatch;
            }
            0x829FD764 => {
    //   block [0x829FD764..0x829FD784)
	// 829FD764: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829FD768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD76C: 48000035  bl 0x829fd7a0
	ctx.lr = 0x829FD770;
	sub_829FD7A0(ctx, base);
	// 829FD770: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FD774: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FD778: 419A000C  beq cr6, 0x829fd784
	if ctx.cr[6].eq {
	pc = 0x829FD784; continue 'dispatch;
	}
	// 829FD77C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FD780: 488BC1D5  bl 0x832b9954
	ctx.lr = 0x829FD784;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD784; continue 'dispatch;
            }
            0x829FD784 => {
    //   block [0x829FD784..0x829FD79C)
	// 829FD784: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FD788: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD78C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD790: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FD794: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FD7A0 size=232
    let mut pc: u32 = 0x829FD7A0;
    'dispatch: loop {
        match pc {
            0x829FD7A0 => {
    //   block [0x829FD7A0..0x829FD868)
	// 829FD7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD7A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FD7AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD7B0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 829FD7B4: 482B0525  bl 0x82cadcd8
	ctx.lr = 0x829FD7B8;
	sub_82CADCA0(ctx, base);
	// 829FD7B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD7BC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD7C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD7C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD7C8: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD7CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD7D0: 4B802FA1  bl 0x82200770
	ctx.lr = 0x829FD7D4;
	sub_82200770(ctx, base);
	// 829FD7D4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FD7D8: C1BF0058  lfs f13, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FD7DC: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829FD7E0: 3BCA92D8  addi r30, r10, -0x6d28
	ctx.r[30].s64 = ctx.r[10].s64 + -27944;
	// 829FD7E4: C3AA92D8  lfs f29, -0x6d28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27944 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829FD7E8: CBE99610  lfd f31, -0x69f0(r9)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27120 as u32) ) };
	// 829FD7EC: C3DE01B8  lfs f30, 0x1b8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(440 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829FD7F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FD7F4: ED9E6828  fsubs f12, f30, f13
	ctx.f[12].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 829FD7F8: C01E2184  lfs f0, 0x2184(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD7FC: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829FD800: EC4B0772  fmuls f2, f11, f29
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[29].f64) as f32) as f64);
	// 829FD804: 4B800CA5  bl 0x821fe4a8
	ctx.lr = 0x829FD808;
	sub_821FE4A8(ctx, base);
	// 829FD808: C15F005C  lfs f10, 0x5c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829FD80C: FF800818  frsp f28, f1
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829FD810: ED3E5028  fsubs f9, f30, f10
	ctx.f[9].f64 = (((ctx.f[30].f64 - ctx.f[10].f64) as f32) as f64);
	// 829FD814: C01E2184  lfs f0, 0x2184(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD818: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FD81C: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 829FD820: EC480772  fmuls f2, f8, f29
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[29].f64) as f32) as f64);
	// 829FD824: 4B800C85  bl 0x821fe4a8
	ctx.lr = 0x829FD828;
	sub_821FE4A8(ctx, base);
	// 829FD828: FCE00818  frsp f7, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829FD82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD830: EFE70732  fmuls f31, f7, f28
	ctx.f[31].f64 = (((ctx.f[7].f64 * ctx.f[28].f64) as f32) as f64);
	// 829FD834: 48199645  bl 0x82b96e78
	ctx.lr = 0x829FD838;
	sub_82B96E78(ctx, base);
	// 829FD838: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FD83C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FD840: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829FD844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD848: 48205329  bl 0x82c02b70
	ctx.lr = 0x829FD84C;
	sub_82C02B70(ctx, base);
	// 829FD84C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD850: 48199629  bl 0x82b96e78
	ctx.lr = 0x829FD854;
	sub_82B96E78(ctx, base);
	// 829FD854: 88E1005C  lbz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FD858: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829FD85C: 419A000C  beq cr6, 0x829fd868
	if ctx.cr[6].eq {
	pc = 0x829FD868; continue 'dispatch;
	}
	// 829FD860: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FD864: 488BC0F1  bl 0x832b9954
	ctx.lr = 0x829FD868;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD868; continue 'dispatch;
            }
            0x829FD868 => {
    //   block [0x829FD868..0x829FD888)
	// 829FD868: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829FD86C: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 829FD870: 482B04B5  bl 0x82cadd24
	ctx.lr = 0x829FD874;
	sub_82CADCEC(ctx, base);
	// 829FD874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD87C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FD880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FD888 size=152
    let mut pc: u32 = 0x829FD888;
    'dispatch: loop {
        match pc {
            0x829FD888 => {
    //   block [0x829FD888..0x829FD8D0)
	// 829FD888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD890: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 829FD894: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD898: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD89C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FD8A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD8A4: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD8A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD8AC: 4B802EC5  bl 0x82200770
	ctx.lr = 0x829FD8B0;
	sub_82200770(ctx, base);
	// 829FD8B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FD8B4: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 829FD8B8: C00BFFF4  lfs f0, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD8BC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD8C0: 41980010  blt cr6, 0x829fd8d0
	if ctx.cr[6].lt {
	pc = 0x829FD8D0; continue 'dispatch;
	}
	// 829FD8C4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD8C8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD8CC: 40990008  ble cr6, 0x829fd8d4
	if !ctx.cr[6].gt {
	pc = 0x829FD8D4; continue 'dispatch;
	}
	pc = 0x829FD8D0; continue 'dispatch;
            }
            0x829FD8D0 => {
    //   block [0x829FD8D0..0x829FD8D4)
	// 829FD8D0: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x829FD8D4; continue 'dispatch;
            }
            0x829FD8D4 => {
    //   block [0x829FD8D4..0x829FD90C)
	// 829FD8D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD8D8: 481995A1  bl 0x82b96e78
	ctx.lr = 0x829FD8DC;
	sub_82B96E78(ctx, base);
	// 829FD8DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FD8E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FD8E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FD8E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD8EC: 48205285  bl 0x82c02b70
	ctx.lr = 0x829FD8F0;
	sub_82C02B70(ctx, base);
	// 829FD8F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD8F4: 48199585  bl 0x82b96e78
	ctx.lr = 0x829FD8F8;
	sub_82B96E78(ctx, base);
	// 829FD8F8: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FD8FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FD900: 419A000C  beq cr6, 0x829fd90c
	if ctx.cr[6].eq {
	pc = 0x829FD90C; continue 'dispatch;
	}
	// 829FD904: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FD908: 488BC04D  bl 0x832b9954
	ctx.lr = 0x829FD90C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD90C; continue 'dispatch;
            }
            0x829FD90C => {
    //   block [0x829FD90C..0x829FD920)
	// 829FD90C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FD910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD918: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD91C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD920 size=212
    let mut pc: u32 = 0x829FD920;
    'dispatch: loop {
        match pc {
            0x829FD920 => {
    //   block [0x829FD920..0x829FD984)
	// 829FD920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD92C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD930: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FD934: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FD938: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FD93C: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FD940: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FD944: 4B802E2D  bl 0x82200770
	ctx.lr = 0x829FD948;
	sub_82200770(ctx, base);
	// 829FD948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD94C: 4819952D  bl 0x82b96e78
	ctx.lr = 0x829FD950;
	sub_82B96E78(ctx, base);
	// 829FD950: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 829FD954: 41980050  blt cr6, 0x829fd9a4
	if ctx.cr[6].lt {
	pc = 0x829FD9A4; continue 'dispatch;
	}
	// 829FD958: 419A002C  beq cr6, 0x829fd984
	if ctx.cr[6].eq {
	pc = 0x829FD984; continue 'dispatch;
	}
	// 829FD95C: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 829FD960: 40980064  bge cr6, 0x829fd9c4
	if !ctx.cr[6].lt {
	pc = 0x829FD9C4; continue 'dispatch;
	}
	// 829FD964: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FD968: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FD96C: 38AB20B0  addi r5, r11, 0x20b0
	ctx.r[5].s64 = ctx.r[11].s64 + 8368;
	// 829FD970: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FD974: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FD978: 48205261  bl 0x82c02bd8
	ctx.lr = 0x829FD97C;
	sub_82C02BD8(ctx, base);
	// 829FD97C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FD980: 48000040  b 0x829fd9c0
	pc = 0x829FD9C0; continue 'dispatch;
            }
            0x829FD984 => {
    //   block [0x829FD984..0x829FD9A4)
	// 829FD984: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FD988: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FD98C: 38AB209C  addi r5, r11, 0x209c
	ctx.r[5].s64 = ctx.r[11].s64 + 8348;
	// 829FD990: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FD994: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD998: 48205241  bl 0x82c02bd8
	ctx.lr = 0x829FD99C;
	sub_82C02BD8(ctx, base);
	// 829FD99C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD9A0: 48000020  b 0x829fd9c0
	pc = 0x829FD9C0; continue 'dispatch;
            }
            0x829FD9A4 => {
    //   block [0x829FD9A4..0x829FD9C0)
	// 829FD9A4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FD9A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FD9AC: 38AB208C  addi r5, r11, 0x208c
	ctx.r[5].s64 = ctx.r[11].s64 + 8332;
	// 829FD9B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FD9B4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FD9B8: 48205221  bl 0x82c02bd8
	ctx.lr = 0x829FD9BC;
	sub_82C02BD8(ctx, base);
	// 829FD9BC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	pc = 0x829FD9C0; continue 'dispatch;
            }
            0x829FD9C0 => {
    //   block [0x829FD9C0..0x829FD9C4)
	// 829FD9C0: 4B817419  bl 0x82214dd8
	ctx.lr = 0x829FD9C4;
	sub_82214DD8(ctx, base);
	pc = 0x829FD9C4; continue 'dispatch;
            }
            0x829FD9C4 => {
    //   block [0x829FD9C4..0x829FD9E0)
	// 829FD9C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FD9C8: 481994B1  bl 0x82b96e78
	ctx.lr = 0x829FD9CC;
	sub_82B96E78(ctx, base);
	// 829FD9CC: 89410064  lbz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FD9D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FD9D4: 419A000C  beq cr6, 0x829fd9e0
	if ctx.cr[6].eq {
	pc = 0x829FD9E0; continue 'dispatch;
	}
	// 829FD9D8: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FD9DC: 488BBF79  bl 0x832b9954
	ctx.lr = 0x829FD9E0;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FD9E0; continue 'dispatch;
            }
            0x829FD9E0 => {
    //   block [0x829FD9E0..0x829FD9F4)
	// 829FD9E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FD9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD9EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD9F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD9F8 size=252
    let mut pc: u32 = 0x829FD9F8;
    'dispatch: loop {
        match pc {
            0x829FD9F8 => {
    //   block [0x829FD9F8..0x829FDADC)
	// 829FD9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD9FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDA00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDA04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDA08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDA0C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FDA10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FDA14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FDA18: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FDA1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FDA20: 4B802D51  bl 0x82200770
	ctx.lr = 0x829FDA24;
	sub_82200770(ctx, base);
	// 829FDA24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDA28: 48199451  bl 0x82b96e78
	ctx.lr = 0x829FDA2C;
	sub_82B96E78(ctx, base);
	// 829FDA2C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829FDA30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FDA34: 38AA20C8  addi r5, r10, 0x20c8
	ctx.r[5].s64 = ctx.r[10].s64 + 8392;
	// 829FDA38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FDA3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FDA40: 48205199  bl 0x82c02bd8
	ctx.lr = 0x829FDA44;
	sub_82C02BD8(ctx, base);
	// 829FDA44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FDA48: 4B817391  bl 0x82214dd8
	ctx.lr = 0x829FDA4C;
	sub_82214DD8(ctx, base);
	// 829FDA4C: 482AC785  bl 0x82caa1d0
	ctx.lr = 0x829FDA50;
	sub_82CAA1D0(ctx, base);
	// 829FDA50: 3D20CCCC  lis r9, -0x3334
	ctx.r[9].s64 = -859045888;
	// 829FDA54: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 829FDA58: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FDA5C: 6127CCCD  ori r7, r9, 0xcccd
	ctx.r[7].u64 = ctx.r[9].u64 | 52429;
	// 829FDA60: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 829FDA64: 7CA83816  mulhwu r5, r8, r7
	ctx.r[5].u64 = ((ctx.r[8].u32 as u64 * ctx.r[7].u32 as u64) >> 32);
	// 829FDA68: 54ABF0BE  srwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FDA6C: 3926B434  addi r9, r6, -0x4bcc
	ctx.r[9].s64 = ctx.r[6].s64 + -19404;
	// 829FDA70: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829FDA74: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829FDA78: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829FDA7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FDA80: 7D644050  subf r11, r4, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 829FDA84: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FDA88: 7FEB4A14  add r31, r11, r9
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 829FDA8C: 7C8B482E  lwzx r4, r11, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 829FDA90: 48205019  bl 0x82c02aa8
	ctx.lr = 0x829FDA94;
	sub_82C02AA8(ctx, base);
	// 829FDA94: 907E0060  stw r3, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 829FDA98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FDA9C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDAA0: 48204F89  bl 0x82c02a28
	ctx.lr = 0x829FDAA4;
	sub_82C02A28(ctx, base);
	// 829FDAA4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829FDAA8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829FDAAC: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FDAB0: 48001261  bl 0x829fed10
	ctx.lr = 0x829FDAB4;
	sub_829FED10(ctx, base);
	// 829FDAB4: 907E0064  stw r3, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 829FDAB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FDABC: 4B88BF8D  bl 0x82289a48
	ctx.lr = 0x829FDAC0;
	sub_82289A48(ctx, base);
	// 829FDAC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDAC4: 481993B5  bl 0x82b96e78
	ctx.lr = 0x829FDAC8;
	sub_82B96E78(ctx, base);
	// 829FDAC8: 8921005C  lbz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FDACC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FDAD0: 419A000C  beq cr6, 0x829fdadc
	if ctx.cr[6].eq {
	pc = 0x829FDADC; continue 'dispatch;
	}
	// 829FDAD4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FDAD8: 488BBE7D  bl 0x832b9954
	ctx.lr = 0x829FDADC;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FDADC; continue 'dispatch;
            }
            0x829FDADC => {
    //   block [0x829FDADC..0x829FDAF4)
	// 829FDADC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829FDAE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDAE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDAE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDAEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDAF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDAF8 size=184
    let mut pc: u32 = 0x829FDAF8;
    'dispatch: loop {
        match pc {
            0x829FDAF8 => {
    //   block [0x829FDAF8..0x829FDB68)
	// 829FDAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDAFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDB00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDB04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDB08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDB0C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FDB10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FDB14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FDB18: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FDB1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDB20: 4B802C51  bl 0x82200770
	ctx.lr = 0x829FDB24;
	sub_82200770(ctx, base);
	// 829FDB24: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FDB28: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FDB2C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FDB30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FDB34: 419A0034  beq cr6, 0x829fdb68
	if ctx.cr[6].eq {
	pc = 0x829FDB68; continue 'dispatch;
	}
	// 829FDB38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDB3C: 38A003E8  li r5, 0x3e8
	ctx.r[5].s64 = 1000;
	// 829FDB40: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FDB44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDB48: 4E800421  bctrl
	ctx.lr = 0x829FDB4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDB4C: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FDB50: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 829FDB54: 409A0014  bne cr6, 0x829fdb68
	if !ctx.cr[6].eq {
	pc = 0x829FDB68; continue 'dispatch;
	}
	// 829FDB58: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 829FDB5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FDB60: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829FDB64: 4B8A5025  bl 0x822a2b88
	ctx.lr = 0x829FDB68;
	sub_822A2B88(ctx, base);
            }
            0x829FDB68 => {
    //   block [0x829FDB68..0x829FDB98)
	// 829FDB68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829FDB6C: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FDB70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FDB74: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FDB78: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 829FDB7C: 48204F6D  bl 0x82c02ae8
	ctx.lr = 0x829FDB80;
	sub_82C02AE8(ctx, base);
	// 829FDB80: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FDB84: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829FDB88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FDB8C: 419A000C  beq cr6, 0x829fdb98
	if ctx.cr[6].eq {
	pc = 0x829FDB98; continue 'dispatch;
	}
	// 829FDB90: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FDB94: 488BBDC1  bl 0x832b9954
	ctx.lr = 0x829FDB98;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FDB98; continue 'dispatch;
            }
            0x829FDB98 => {
    //   block [0x829FDB98..0x829FDBB0)
	// 829FDB98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FDB9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDBA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDBA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDBA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDBAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDBB0 size=252
    let mut pc: u32 = 0x829FDBB0;
    'dispatch: loop {
        match pc {
            0x829FDBB0 => {
    //   block [0x829FDBB0..0x829FDBF4)
	// 829FDBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDBB4: 482AB855  bl 0x82ca9408
	ctx.lr = 0x829FDBB8;
	sub_82CA93D0(ctx, base);
	// 829FDBB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDBBC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FDBC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FDBC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FDBC8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829FDBCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FDBD0: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FDBD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDBD8: 4B802B99  bl 0x82200770
	ctx.lr = 0x829FDBDC;
	sub_82200770(ctx, base);
	// 829FDBDC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FDBE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FDBE4: 409A0010  bne cr6, 0x829fdbf4
	if !ctx.cr[6].eq {
	pc = 0x829FDBF4; continue 'dispatch;
	}
	// 829FDBE8: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FDBEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FDBF0: 480000A8  b 0x829fdc98
	pc = 0x829FDC98; continue 'dispatch;
            }
            0x829FDBF4 => {
    //   block [0x829FDBF4..0x829FDC54)
	// 829FDBF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDBF8: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829FDBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDC00: 3B8A20D4  addi r28, r10, 0x20d4
	ctx.r[28].s64 = ctx.r[10].s64 + 8404;
	// 829FDC04: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FDC08: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDC0C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 829FDC10: 4E800421  bctrl
	ctx.lr = 0x829FDC14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDC14: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDC18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FDC1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDC20: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDC24: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FDC28: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 829FDC2C: 4E800421  bctrl
	ctx.lr = 0x829FDC30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDC30: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FDC34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FDC38: 419A001C  beq cr6, 0x829fdc54
	if ctx.cr[6].eq {
	pc = 0x829FDC54; continue 'dispatch;
	}
	// 829FDC3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDC40: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829FDC44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FDC48: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 829FDC4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDC50: 4E800421  bctrl
	ctx.lr = 0x829FDC54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FDC54 => {
    //   block [0x829FDC54..0x829FDC7C)
	// 829FDC54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDC58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDC5C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FDC60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDC64: 4E800421  bctrl
	ctx.lr = 0x829FDC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDC68: 57A9063E  clrlwi r9, r29, 0x18
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 829FDC6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FDC70: 409A000C  bne cr6, 0x829fdc7c
	if !ctx.cr[6].eq {
	pc = 0x829FDC7C; continue 'dispatch;
	}
	// 829FDC74: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 829FDC78: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
            }
            0x829FDC7C => {
    //   block [0x829FDC7C..0x829FDC98)
	// 829FDC7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDC80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDC84: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FDC88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDC8C: 4E800421  bctrl
	ctx.lr = 0x829FDC90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDC90: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FDC94: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
            }
            0x829FDC98 => {
    //   block [0x829FDC98..0x829FDCA4)
	// 829FDC98: 419A000C  beq cr6, 0x829fdca4
	if ctx.cr[6].eq {
	pc = 0x829FDCA4; continue 'dispatch;
	}
	// 829FDC9C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FDCA0: 488BBCB5  bl 0x832b9954
	ctx.lr = 0x829FDCA4;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FDCA4; continue 'dispatch;
            }
            0x829FDCA4 => {
    //   block [0x829FDCA4..0x829FDCAC)
	// 829FDCA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FDCA8: 482AB7B0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDCB0 size=80
    let mut pc: u32 = 0x829FDCB0;
    'dispatch: loop {
        match pc {
            0x829FDCB0 => {
    //   block [0x829FDCB0..0x829FDCE8)
	// 829FDCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDCB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDCB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDCBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDCC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDCC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FDCC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FDCCC: 48000035  bl 0x829fdd00
	ctx.lr = 0x829FDCD0;
	sub_829FDD00(ctx, base);
	// 829FDCD0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829FDCD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDCD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FDCDC: 419A000C  beq cr6, 0x829fdce8
	if ctx.cr[6].eq {
	pc = 0x829FDCE8; continue 'dispatch;
	}
	// 829FDCE0: 4B81E059  bl 0x8221bd38
	ctx.lr = 0x829FDCE4;
	sub_8221BD38(ctx, base);
	// 829FDCE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829FDCE8; continue 'dispatch;
            }
            0x829FDCE8 => {
    //   block [0x829FDCE8..0x829FDD00)
	// 829FDCE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FDCEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDCF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDCF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDCF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDCFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDD00 size=200
    let mut pc: u32 = 0x829FDD00;
    'dispatch: loop {
        match pc {
            0x829FDD00 => {
    //   block [0x829FDD00..0x829FDD48)
	// 829FDD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDD04: 482AB705  bl 0x82ca9408
	ctx.lr = 0x829FDD08;
	sub_82CA93D0(ctx, base);
	// 829FDD08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDD0C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FDD10: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FDD14: 3BBC0030  addi r29, r28, 0x30
	ctx.r[29].s64 = ctx.r[28].s64 + 48;
	// 829FDD18: 394B20E4  addi r10, r11, 0x20e4
	ctx.r[10].s64 = ctx.r[11].s64 + 8420;
	// 829FDD1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FDD20: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FDD24: 48000695  bl 0x829fe3b8
	ctx.lr = 0x829FDD28;
	sub_829FE3B8(ctx, base);
	// 829FDD28: 807C002C  lwz r3, 0x2c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 829FDD2C: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 829FDD30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FDD34: 419A0014  beq cr6, 0x829fdd48
	if ctx.cr[6].eq {
	pc = 0x829FDD48; continue 'dispatch;
	}
	// 829FDD38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDD3C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDD40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDD44: 4E800421  bctrl
	ctx.lr = 0x829FDD48;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FDD48 => {
    //   block [0x829FDD48..0x829FDD84)
	// 829FDD48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829FDD4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FDD50: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829FDD54: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FDD58: 48000661  bl 0x829fe3b8
	ctx.lr = 0x829FDD5C;
	sub_829FE3B8(ctx, base);
	// 829FDD5C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDD60: 4B81DFD9  bl 0x8221bd38
	ctx.lr = 0x829FDD64;
	sub_8221BD38(ctx, base);
	// 829FDD64: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829FDD68: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDD6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FDD70: 419A0014  beq cr6, 0x829fdd84
	if ctx.cr[6].eq {
	pc = 0x829FDD84; continue 'dispatch;
	}
	// 829FDD74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDD78: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDD7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDD80: 4E800421  bctrl
	ctx.lr = 0x829FDD84;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FDD84 => {
    //   block [0x829FDD84..0x829FDDAC)
	// 829FDD84: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829FDD88: 3BBC0020  addi r29, r28, 0x20
	ctx.r[29].s64 = ctx.r[28].s64 + 32;
	// 829FDD8C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FDD90: 807C0024  lwz r3, 0x24(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 829FDD94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FDD98: 419A0014  beq cr6, 0x829fddac
	if ctx.cr[6].eq {
	pc = 0x829FDDAC; continue 'dispatch;
	}
	// 829FDD9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDDA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDDA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDDA8: 4E800421  bctrl
	ctx.lr = 0x829FDDAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FDDAC => {
    //   block [0x829FDDAC..0x829FDDC8)
	// 829FDDAC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FDDB0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829FDDB4: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FDDB8: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 829FDDBC: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FDDC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FDDC4: 482AB694  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDDC8 size=292
    let mut pc: u32 = 0x829FDDC8;
    'dispatch: loop {
        match pc {
            0x829FDDC8 => {
    //   block [0x829FDDC8..0x829FDDFC)
	// 829FDDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDDCC: 482AB641  bl 0x82ca940c
	ctx.lr = 0x829FDDD0;
	sub_82CA93D0(ctx, base);
	// 829FDDD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDDD4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FDDD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FDDDC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829FDDE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FDDE4: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FDDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDDEC: 4B802985  bl 0x82200770
	ctx.lr = 0x829FDDF0;
	sub_82200770(ctx, base);
	// 829FDDF0: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 829FDDF4: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 829FDDF8: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FDDFC; continue 'dispatch;
            }
            0x829FDDFC => {
    //   block [0x829FDDFC..0x829FDE0C)
	// 829FDDFC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDE00: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FDE04: 419A0008  beq cr6, 0x829fde0c
	if ctx.cr[6].eq {
	pc = 0x829FDE0C; continue 'dispatch;
	}
	// 829FDE08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FDE0C; continue 'dispatch;
            }
            0x829FDE0C => {
    //   block [0x829FDE0C..0x829FDE24)
	// 829FDE0C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FDE10: 419A00BC  beq cr6, 0x829fdecc
	if ctx.cr[6].eq {
	pc = 0x829FDECC; continue 'dispatch;
	}
	// 829FDE14: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDE18: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FDE1C: 409A0008  bne cr6, 0x829fde24
	if !ctx.cr[6].eq {
	pc = 0x829FDE24; continue 'dispatch;
	}
	// 829FDE20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FDE24; continue 'dispatch;
            }
            0x829FDE24 => {
    //   block [0x829FDE24..0x829FDE54)
	// 829FDE24: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FDE28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDE2C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FDE30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDE34: 4E800421  bctrl
	ctx.lr = 0x829FDE38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDE38: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FDE3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FDE40: 419A0054  beq cr6, 0x829fde94
	if ctx.cr[6].eq {
	pc = 0x829FDE94; continue 'dispatch;
	}
	// 829FDE44: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDE48: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FDE4C: 409A0008  bne cr6, 0x829fde54
	if !ctx.cr[6].eq {
	pc = 0x829FDE54; continue 'dispatch;
	}
	// 829FDE50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x829FDE54 => {
    //   block [0x829FDE54..0x829FDE6C)
	// 829FDE54: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FDE58: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDE5C: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829FDE60: 409A000C  bne cr6, 0x829fde6c
	if !ctx.cr[6].eq {
	pc = 0x829FDE6C; continue 'dispatch;
	}
	// 829FDE64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FDE68: 48000020  b 0x829fde88
	pc = 0x829FDE88; continue 'dispatch;
            }
            0x829FDE6C => {
    //   block [0x829FDE6C..0x829FDE84)
	// 829FDE6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FDE70: 419A0014  beq cr6, 0x829fde84
	if ctx.cr[6].eq {
	pc = 0x829FDE84; continue 'dispatch;
	}
	// 829FDE74: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FDE78: 419A000C  beq cr6, 0x829fde84
	if ctx.cr[6].eq {
	pc = 0x829FDE84; continue 'dispatch;
	}
	// 829FDE7C: 4B86F915  bl 0x8226d790
	ctx.lr = 0x829FDE80;
	sub_8226D790(ctx, base);
	// 829FDE80: 48000008  b 0x829fde88
	pc = 0x829FDE88; continue 'dispatch;
            }
            0x829FDE84 => {
    //   block [0x829FDE84..0x829FDE88)
	// 829FDE84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829FDE88; continue 'dispatch;
            }
            0x829FDE88 => {
    //   block [0x829FDE88..0x829FDE94)
	// 829FDE88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FDE8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FDE90: 409A001C  bne cr6, 0x829fdeac
	if !ctx.cr[6].eq {
	pc = 0x829FDEAC; continue 'dispatch;
	}
	pc = 0x829FDE94; continue 'dispatch;
            }
            0x829FDE94 => {
    //   block [0x829FDE94..0x829FDEA4)
	// 829FDE94: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDE98: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FDE9C: 409A0008  bne cr6, 0x829fdea4
	if !ctx.cr[6].eq {
	pc = 0x829FDEA4; continue 'dispatch;
	}
	// 829FDEA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FDEA4; continue 'dispatch;
            }
            0x829FDEA4 => {
    //   block [0x829FDEA4..0x829FDEAC)
	// 829FDEA4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDEA8: 4BFFFF54  b 0x829fddfc
	pc = 0x829FDDFC; continue 'dispatch;
            }
            0x829FDEAC => {
    //   block [0x829FDEAC..0x829FDEC0)
	// 829FDEAC: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FDEB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FDEB4: 419A000C  beq cr6, 0x829fdec0
	if ctx.cr[6].eq {
	pc = 0x829FDEC0; continue 'dispatch;
	}
	// 829FDEB8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FDEBC: 488BBA99  bl 0x832b9954
	ctx.lr = 0x829FDEC0;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FDEC0; continue 'dispatch;
            }
            0x829FDEC0 => {
    //   block [0x829FDEC0..0x829FDECC)
	// 829FDEC0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FDEC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FDEC8: 482AB594  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FDECC => {
    //   block [0x829FDECC..0x829FDEE0)
	// 829FDECC: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FDED0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FDED4: 419A000C  beq cr6, 0x829fdee0
	if ctx.cr[6].eq {
	pc = 0x829FDEE0; continue 'dispatch;
	}
	// 829FDED8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FDEDC: 488BBA79  bl 0x832b9954
	ctx.lr = 0x829FDEE0;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FDEE0; continue 'dispatch;
            }
            0x829FDEE0 => {
    //   block [0x829FDEE0..0x829FDEEC)
	// 829FDEE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FDEE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FDEE8: 482AB574  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDEF0 size=316
    let mut pc: u32 = 0x829FDEF0;
    'dispatch: loop {
        match pc {
            0x829FDEF0 => {
    //   block [0x829FDEF0..0x829FDF30)
	// 829FDEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDEF4: 482AB50D  bl 0x82ca9400
	ctx.lr = 0x829FDEF8;
	sub_82CA93D0(ctx, base);
	// 829FDEF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDEFC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FDF00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FDF04: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829FDF08: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 829FDF0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FDF10: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FDF14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FDF18: 4B802859  bl 0x82200770
	ctx.lr = 0x829FDF1C;
	sub_82200770(ctx, base);
	// 829FDF1C: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 829FDF20: 3BBF0030  addi r29, r31, 0x30
	ctx.r[29].s64 = ctx.r[31].s64 + 48;
	// 829FDF24: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829FDF28: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829FDF2C: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FDF30; continue 'dispatch;
            }
            0x829FDF30 => {
    //   block [0x829FDF30..0x829FDF34)
	// 829FDF30: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x829FDF34; continue 'dispatch;
            }
            0x829FDF34 => {
    //   block [0x829FDF34..0x829FDF48)
	// 829FDF34: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDF38: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829FDF3C: 419A000C  beq cr6, 0x829fdf48
	if ctx.cr[6].eq {
	pc = 0x829FDF48; continue 'dispatch;
	}
	// 829FDF40: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829FDF44: 419A0008  beq cr6, 0x829fdf4c
	if ctx.cr[6].eq {
	pc = 0x829FDF4C; continue 'dispatch;
	}
	pc = 0x829FDF48; continue 'dispatch;
            }
            0x829FDF48 => {
    //   block [0x829FDF48..0x829FDF4C)
	// 829FDF48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FDF4C; continue 'dispatch;
            }
            0x829FDF4C => {
    //   block [0x829FDF4C..0x829FDF60)
	// 829FDF4C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FDF50: 419A00C0  beq cr6, 0x829fe010
	if ctx.cr[6].eq {
	pc = 0x829FE010; continue 'dispatch;
	}
	// 829FDF54: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829FDF58: 409A0008  bne cr6, 0x829fdf60
	if !ctx.cr[6].eq {
	pc = 0x829FDF60; continue 'dispatch;
	}
	// 829FDF5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FDF60; continue 'dispatch;
            }
            0x829FDF60 => {
    //   block [0x829FDF60..0x829FDF70)
	// 829FDF60: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FDF64: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FDF68: 409A0008  bne cr6, 0x829fdf70
	if !ctx.cr[6].eq {
	pc = 0x829FDF70; continue 'dispatch;
	}
	// 829FDF6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FDF70; continue 'dispatch;
            }
            0x829FDF70 => {
    //   block [0x829FDF70..0x829FDF88)
	// 829FDF70: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FDF74: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDF78: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829FDF7C: 409A000C  bne cr6, 0x829fdf88
	if !ctx.cr[6].eq {
	pc = 0x829FDF88; continue 'dispatch;
	}
	// 829FDF80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FDF84: 48000020  b 0x829fdfa4
	pc = 0x829FDFA4; continue 'dispatch;
            }
            0x829FDF88 => {
    //   block [0x829FDF88..0x829FDFA0)
	// 829FDF88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FDF8C: 419A0014  beq cr6, 0x829fdfa0
	if ctx.cr[6].eq {
	pc = 0x829FDFA0; continue 'dispatch;
	}
	// 829FDF90: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FDF94: 419A000C  beq cr6, 0x829fdfa0
	if ctx.cr[6].eq {
	pc = 0x829FDFA0; continue 'dispatch;
	}
	// 829FDF98: 4B86F7F9  bl 0x8226d790
	ctx.lr = 0x829FDF9C;
	sub_8226D790(ctx, base);
	// 829FDF9C: 48000008  b 0x829fdfa4
	pc = 0x829FDFA4; continue 'dispatch;
            }
            0x829FDFA0 => {
    //   block [0x829FDFA0..0x829FDFA4)
	// 829FDFA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829FDFA4; continue 'dispatch;
            }
            0x829FDFA4 => {
    //   block [0x829FDFA4..0x829FDFBC)
	// 829FDFA4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FDFA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FDFAC: 419A0050  beq cr6, 0x829fdffc
	if ctx.cr[6].eq {
	pc = 0x829FDFFC; continue 'dispatch;
	}
	// 829FDFB0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FDFB4: 409A0008  bne cr6, 0x829fdfbc
	if !ctx.cr[6].eq {
	pc = 0x829FDFBC; continue 'dispatch;
	}
	// 829FDFB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FDFBC; continue 'dispatch;
            }
            0x829FDFBC => {
    //   block [0x829FDFBC..0x829FDFFC)
	// 829FDFBC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FDFC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FDFC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829FDFC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDFCC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 829FDFD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FDFD4: 4E800421  bctrl
	ctx.lr = 0x829FDFD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDFD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FDFDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FDFE0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FDFE4: 4B86270D  bl 0x822606f0
	ctx.lr = 0x829FDFE8;
	sub_822606F0(ctx, base);
	// 829FDFE8: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829FDFEC: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 829FDFF0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FDFF4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FDFF8: 4BFFFF3C  b 0x829fdf34
	pc = 0x829FDF34; continue 'dispatch;
            }
            0x829FDFFC => {
    //   block [0x829FDFFC..0x829FE008)
	// 829FDFFC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FE000: 409A0008  bne cr6, 0x829fe008
	if !ctx.cr[6].eq {
	pc = 0x829FE008; continue 'dispatch;
	}
	// 829FE004: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE008; continue 'dispatch;
            }
            0x829FE008 => {
    //   block [0x829FE008..0x829FE010)
	// 829FE008: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE00C: 4BFFFF24  b 0x829fdf30
	pc = 0x829FDF30; continue 'dispatch;
            }
            0x829FE010 => {
    //   block [0x829FE010..0x829FE024)
	// 829FE010: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FE014: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FE018: 419A000C  beq cr6, 0x829fe024
	if ctx.cr[6].eq {
	pc = 0x829FE024; continue 'dispatch;
	}
	// 829FE01C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FE020: 488BB935  bl 0x832b9954
	ctx.lr = 0x829FE024;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FE024; continue 'dispatch;
            }
            0x829FE024 => {
    //   block [0x829FE024..0x829FE02C)
	// 829FE024: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829FE028: 482AB428  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE030 size=292
    let mut pc: u32 = 0x829FE030;
    'dispatch: loop {
        match pc {
            0x829FE030 => {
    //   block [0x829FE030..0x829FE064)
	// 829FE030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE034: 482AB3D5  bl 0x82ca9408
	ctx.lr = 0x829FE038;
	sub_82CA93D0(ctx, base);
	// 829FE038: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE03C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FE040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE044: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829FE048: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FE04C: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FE050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE054: 4B80271D  bl 0x82200770
	ctx.lr = 0x829FE058;
	sub_82200770(ctx, base);
	// 829FE058: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 829FE05C: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 829FE060: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FE064; continue 'dispatch;
            }
            0x829FE064 => {
    //   block [0x829FE064..0x829FE074)
	// 829FE064: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE068: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FE06C: 419A0008  beq cr6, 0x829fe074
	if ctx.cr[6].eq {
	pc = 0x829FE074; continue 'dispatch;
	}
	// 829FE070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE074; continue 'dispatch;
            }
            0x829FE074 => {
    //   block [0x829FE074..0x829FE08C)
	// 829FE074: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE078: 419A00C0  beq cr6, 0x829fe138
	if ctx.cr[6].eq {
	pc = 0x829FE138; continue 'dispatch;
	}
	// 829FE07C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE080: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE084: 409A0008  bne cr6, 0x829fe08c
	if !ctx.cr[6].eq {
	pc = 0x829FE08C; continue 'dispatch;
	}
	// 829FE088: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE08C; continue 'dispatch;
            }
            0x829FE08C => {
    //   block [0x829FE08C..0x829FE0BC)
	// 829FE08C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FE090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE094: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FE098: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE09C: 4E800421  bctrl
	ctx.lr = 0x829FE0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE0A0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FE0A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FE0A8: 419A0078  beq cr6, 0x829fe120
	if ctx.cr[6].eq {
	pc = 0x829FE120; continue 'dispatch;
	}
	// 829FE0AC: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE0B0: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829FE0B4: 409A0008  bne cr6, 0x829fe0bc
	if !ctx.cr[6].eq {
	pc = 0x829FE0BC; continue 'dispatch;
	}
	// 829FE0B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x829FE0BC => {
    //   block [0x829FE0BC..0x829FE0D4)
	// 829FE0BC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FE0C0: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE0C4: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829FE0C8: 409A000C  bne cr6, 0x829fe0d4
	if !ctx.cr[6].eq {
	pc = 0x829FE0D4; continue 'dispatch;
	}
	// 829FE0CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FE0D0: 48000020  b 0x829fe0f0
	pc = 0x829FE0F0; continue 'dispatch;
            }
            0x829FE0D4 => {
    //   block [0x829FE0D4..0x829FE0EC)
	// 829FE0D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE0D8: 419A0014  beq cr6, 0x829fe0ec
	if ctx.cr[6].eq {
	pc = 0x829FE0EC; continue 'dispatch;
	}
	// 829FE0DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FE0E0: 419A000C  beq cr6, 0x829fe0ec
	if ctx.cr[6].eq {
	pc = 0x829FE0EC; continue 'dispatch;
	}
	// 829FE0E4: 4B86F6AD  bl 0x8226d790
	ctx.lr = 0x829FE0E8;
	sub_8226D790(ctx, base);
	// 829FE0E8: 48000008  b 0x829fe0f0
	pc = 0x829FE0F0; continue 'dispatch;
            }
            0x829FE0EC => {
    //   block [0x829FE0EC..0x829FE0F0)
	// 829FE0EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829FE0F0; continue 'dispatch;
            }
            0x829FE0F0 => {
    //   block [0x829FE0F0..0x829FE108)
	// 829FE0F0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FE0F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE0F8: 419A0028  beq cr6, 0x829fe120
	if ctx.cr[6].eq {
	pc = 0x829FE120; continue 'dispatch;
	}
	// 829FE0FC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829FE100: 409A0008  bne cr6, 0x829fe108
	if !ctx.cr[6].eq {
	pc = 0x829FE108; continue 'dispatch;
	}
	// 829FE104: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE108; continue 'dispatch;
            }
            0x829FE108 => {
    //   block [0x829FE108..0x829FE120)
	// 829FE108: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FE10C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FE110: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE114: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FE118: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE11C: 4E800421  bctrl
	ctx.lr = 0x829FE120;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FE120 => {
    //   block [0x829FE120..0x829FE130)
	// 829FE120: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE124: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE128: 409A0008  bne cr6, 0x829fe130
	if !ctx.cr[6].eq {
	pc = 0x829FE130; continue 'dispatch;
	}
	// 829FE12C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE130; continue 'dispatch;
            }
            0x829FE130 => {
    //   block [0x829FE130..0x829FE138)
	// 829FE130: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE134: 4BFFFF30  b 0x829fe064
	pc = 0x829FE064; continue 'dispatch;
            }
            0x829FE138 => {
    //   block [0x829FE138..0x829FE14C)
	// 829FE138: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FE13C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FE140: 419A000C  beq cr6, 0x829fe14c
	if ctx.cr[6].eq {
	pc = 0x829FE14C; continue 'dispatch;
	}
	// 829FE144: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE148: 488BB80D  bl 0x832b9954
	ctx.lr = 0x829FE14C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FE14C; continue 'dispatch;
            }
            0x829FE14C => {
    //   block [0x829FE14C..0x829FE154)
	// 829FE14C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FE150: 482AB308  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE158 size=292
    let mut pc: u32 = 0x829FE158;
    'dispatch: loop {
        match pc {
            0x829FE158 => {
    //   block [0x829FE158..0x829FE18C)
	// 829FE158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE15C: 482AB2AD  bl 0x82ca9408
	ctx.lr = 0x829FE160;
	sub_82CA93D0(ctx, base);
	// 829FE160: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE164: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FE168: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE16C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829FE170: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FE174: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FE178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE17C: 4B8025F5  bl 0x82200770
	ctx.lr = 0x829FE180;
	sub_82200770(ctx, base);
	// 829FE180: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 829FE184: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 829FE188: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FE18C; continue 'dispatch;
            }
            0x829FE18C => {
    //   block [0x829FE18C..0x829FE19C)
	// 829FE18C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE190: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FE194: 419A0008  beq cr6, 0x829fe19c
	if ctx.cr[6].eq {
	pc = 0x829FE19C; continue 'dispatch;
	}
	// 829FE198: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE19C; continue 'dispatch;
            }
            0x829FE19C => {
    //   block [0x829FE19C..0x829FE1B4)
	// 829FE19C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE1A0: 419A00C0  beq cr6, 0x829fe260
	if ctx.cr[6].eq {
	pc = 0x829FE260; continue 'dispatch;
	}
	// 829FE1A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE1A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE1AC: 409A0008  bne cr6, 0x829fe1b4
	if !ctx.cr[6].eq {
	pc = 0x829FE1B4; continue 'dispatch;
	}
	// 829FE1B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE1B4; continue 'dispatch;
            }
            0x829FE1B4 => {
    //   block [0x829FE1B4..0x829FE1E4)
	// 829FE1B4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FE1B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE1BC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FE1C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE1C4: 4E800421  bctrl
	ctx.lr = 0x829FE1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE1C8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FE1CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FE1D0: 419A0078  beq cr6, 0x829fe248
	if ctx.cr[6].eq {
	pc = 0x829FE248; continue 'dispatch;
	}
	// 829FE1D4: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE1D8: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829FE1DC: 409A0008  bne cr6, 0x829fe1e4
	if !ctx.cr[6].eq {
	pc = 0x829FE1E4; continue 'dispatch;
	}
	// 829FE1E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x829FE1E4 => {
    //   block [0x829FE1E4..0x829FE1FC)
	// 829FE1E4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FE1E8: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE1EC: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829FE1F0: 409A000C  bne cr6, 0x829fe1fc
	if !ctx.cr[6].eq {
	pc = 0x829FE1FC; continue 'dispatch;
	}
	// 829FE1F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FE1F8: 48000020  b 0x829fe218
	pc = 0x829FE218; continue 'dispatch;
            }
            0x829FE1FC => {
    //   block [0x829FE1FC..0x829FE214)
	// 829FE1FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE200: 419A0014  beq cr6, 0x829fe214
	if ctx.cr[6].eq {
	pc = 0x829FE214; continue 'dispatch;
	}
	// 829FE204: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FE208: 419A000C  beq cr6, 0x829fe214
	if ctx.cr[6].eq {
	pc = 0x829FE214; continue 'dispatch;
	}
	// 829FE20C: 4B86F585  bl 0x8226d790
	ctx.lr = 0x829FE210;
	sub_8226D790(ctx, base);
	// 829FE210: 48000008  b 0x829fe218
	pc = 0x829FE218; continue 'dispatch;
            }
            0x829FE214 => {
    //   block [0x829FE214..0x829FE218)
	// 829FE214: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829FE218; continue 'dispatch;
            }
            0x829FE218 => {
    //   block [0x829FE218..0x829FE230)
	// 829FE218: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FE21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE220: 419A0028  beq cr6, 0x829fe248
	if ctx.cr[6].eq {
	pc = 0x829FE248; continue 'dispatch;
	}
	// 829FE224: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829FE228: 409A0008  bne cr6, 0x829fe230
	if !ctx.cr[6].eq {
	pc = 0x829FE230; continue 'dispatch;
	}
	// 829FE22C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE230; continue 'dispatch;
            }
            0x829FE230 => {
    //   block [0x829FE230..0x829FE248)
	// 829FE230: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FE234: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FE238: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE23C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829FE240: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE244: 4E800421  bctrl
	ctx.lr = 0x829FE248;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FE248 => {
    //   block [0x829FE248..0x829FE258)
	// 829FE248: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE24C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE250: 409A0008  bne cr6, 0x829fe258
	if !ctx.cr[6].eq {
	pc = 0x829FE258; continue 'dispatch;
	}
	// 829FE254: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE258; continue 'dispatch;
            }
            0x829FE258 => {
    //   block [0x829FE258..0x829FE260)
	// 829FE258: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE25C: 4BFFFF30  b 0x829fe18c
	pc = 0x829FE18C; continue 'dispatch;
            }
            0x829FE260 => {
    //   block [0x829FE260..0x829FE274)
	// 829FE260: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FE264: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FE268: 419A000C  beq cr6, 0x829fe274
	if ctx.cr[6].eq {
	pc = 0x829FE274; continue 'dispatch;
	}
	// 829FE26C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE270: 488BB6E5  bl 0x832b9954
	ctx.lr = 0x829FE274;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FE274; continue 'dispatch;
            }
            0x829FE274 => {
    //   block [0x829FE274..0x829FE27C)
	// 829FE274: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FE278: 482AB1E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE280 size=312
    let mut pc: u32 = 0x829FE280;
    'dispatch: loop {
        match pc {
            0x829FE280 => {
    //   block [0x829FE280..0x829FE2C0)
	// 829FE280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE284: 482AB181  bl 0x82ca9404
	ctx.lr = 0x829FE288;
	sub_82CA93D0(ctx, base);
	// 829FE288: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829FE28C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE290: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FE294: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FE298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE29C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829FE2A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FE2A4: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 829FE2A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE2AC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 829FE2B0: 4B8024C1  bl 0x82200770
	ctx.lr = 0x829FE2B4;
	sub_82200770(ctx, base);
	// 829FE2B4: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 829FE2B8: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 829FE2BC: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FE2C0; continue 'dispatch;
            }
            0x829FE2C0 => {
    //   block [0x829FE2C0..0x829FE2D0)
	// 829FE2C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE2C4: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FE2C8: 419A0008  beq cr6, 0x829fe2d0
	if ctx.cr[6].eq {
	pc = 0x829FE2D0; continue 'dispatch;
	}
	// 829FE2CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE2D0; continue 'dispatch;
            }
            0x829FE2D0 => {
    //   block [0x829FE2D0..0x829FE2E8)
	// 829FE2D0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE2D4: 419A00C4  beq cr6, 0x829fe398
	if ctx.cr[6].eq {
	pc = 0x829FE398; continue 'dispatch;
	}
	// 829FE2D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE2DC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE2E0: 409A0008  bne cr6, 0x829fe2e8
	if !ctx.cr[6].eq {
	pc = 0x829FE2E8; continue 'dispatch;
	}
	// 829FE2E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE2E8; continue 'dispatch;
            }
            0x829FE2E8 => {
    //   block [0x829FE2E8..0x829FE318)
	// 829FE2E8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FE2EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE2F0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FE2F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE2F8: 4E800421  bctrl
	ctx.lr = 0x829FE2FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE2FC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FE300: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FE304: 419A007C  beq cr6, 0x829fe380
	if ctx.cr[6].eq {
	pc = 0x829FE380; continue 'dispatch;
	}
	// 829FE308: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE30C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829FE310: 409A0008  bne cr6, 0x829fe318
	if !ctx.cr[6].eq {
	pc = 0x829FE318; continue 'dispatch;
	}
	// 829FE314: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x829FE318 => {
    //   block [0x829FE318..0x829FE330)
	// 829FE318: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FE31C: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE320: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829FE324: 409A000C  bne cr6, 0x829fe330
	if !ctx.cr[6].eq {
	pc = 0x829FE330; continue 'dispatch;
	}
	// 829FE328: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FE32C: 48000020  b 0x829fe34c
	pc = 0x829FE34C; continue 'dispatch;
            }
            0x829FE330 => {
    //   block [0x829FE330..0x829FE348)
	// 829FE330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE334: 419A0014  beq cr6, 0x829fe348
	if ctx.cr[6].eq {
	pc = 0x829FE348; continue 'dispatch;
	}
	// 829FE338: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FE33C: 419A000C  beq cr6, 0x829fe348
	if ctx.cr[6].eq {
	pc = 0x829FE348; continue 'dispatch;
	}
	// 829FE340: 4B86F451  bl 0x8226d790
	ctx.lr = 0x829FE344;
	sub_8226D790(ctx, base);
	// 829FE344: 48000008  b 0x829fe34c
	pc = 0x829FE34C; continue 'dispatch;
            }
            0x829FE348 => {
    //   block [0x829FE348..0x829FE34C)
	// 829FE348: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829FE34C; continue 'dispatch;
            }
            0x829FE34C => {
    //   block [0x829FE34C..0x829FE364)
	// 829FE34C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FE350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE354: 419A002C  beq cr6, 0x829fe380
	if ctx.cr[6].eq {
	pc = 0x829FE380; continue 'dispatch;
	}
	// 829FE358: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829FE35C: 409A0008  bne cr6, 0x829fe364
	if !ctx.cr[6].eq {
	pc = 0x829FE364; continue 'dispatch;
	}
	// 829FE360: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE364; continue 'dispatch;
            }
            0x829FE364 => {
    //   block [0x829FE364..0x829FE380)
	// 829FE364: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FE368: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829FE36C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FE370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE374: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FE378: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE37C: 4E800421  bctrl
	ctx.lr = 0x829FE380;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FE380 => {
    //   block [0x829FE380..0x829FE390)
	// 829FE380: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE384: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE388: 409A0008  bne cr6, 0x829fe390
	if !ctx.cr[6].eq {
	pc = 0x829FE390; continue 'dispatch;
	}
	// 829FE38C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FE390; continue 'dispatch;
            }
            0x829FE390 => {
    //   block [0x829FE390..0x829FE398)
	// 829FE390: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE394: 4BFFFF2C  b 0x829fe2c0
	pc = 0x829FE2C0; continue 'dispatch;
            }
            0x829FE398 => {
    //   block [0x829FE398..0x829FE3AC)
	// 829FE398: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FE39C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FE3A0: 419A000C  beq cr6, 0x829fe3ac
	if ctx.cr[6].eq {
	pc = 0x829FE3AC; continue 'dispatch;
	}
	// 829FE3A4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE3A8: 488BB5AD  bl 0x832b9954
	ctx.lr = 0x829FE3AC;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x829FE3AC; continue 'dispatch;
            }
            0x829FE3AC => {
    //   block [0x829FE3AC..0x829FE3B8)
	// 829FE3AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FE3B0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829FE3B4: 482AB0A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE3B8 size=184
    let mut pc: u32 = 0x829FE3B8;
    'dispatch: loop {
        match pc {
            0x829FE3B8 => {
    //   block [0x829FE3B8..0x829FE3F8)
	// 829FE3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE3BC: 482AB045  bl 0x82ca9400
	ctx.lr = 0x829FE3C0;
	sub_82CA93D0(ctx, base);
	// 829FE3C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE3C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829FE3C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829FE3CC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE3D0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE3D4: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FE3D8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE3DC: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829FE3E0: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE3E4: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829FE3E8: 93BB0008  stw r29, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 829FE3EC: 419A007C  beq cr6, 0x829fe468
	if ctx.cr[6].eq {
	pc = 0x829FE468; continue 'dispatch;
	}
	// 829FE3F0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829FE3F4: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	pc = 0x829FE3F8; continue 'dispatch;
            }
            0x829FE3F8 => {
    //   block [0x829FE3F8..0x829FE40C)
	// 829FE3F8: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829FE3FC: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE400: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 829FE404: 4B7C8365  bl 0x821c6768
	ctx.lr = 0x829FE408;
	sub_821C6768(ctx, base);
	// 829FE408: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x829FE40C; continue 'dispatch;
            }
            0x829FE40C => {
    //   block [0x829FE40C..0x829FE448)
	// 829FE40C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829FE410: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FE414: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829FE418: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829FE41C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FE420: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FE424: 4082FFE8  bne 0x829fe40c
	if !ctx.cr[0].eq {
	pc = 0x829FE40C; continue 'dispatch;
	}
	// 829FE428: 93BE0010  stw r29, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 829FE42C: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FE430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE434: 419A0014  beq cr6, 0x829fe448
	if ctx.cr[6].eq {
	pc = 0x829FE448; continue 'dispatch;
	}
	// 829FE438: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE43C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE440: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE444: 4E800421  bctrl
	ctx.lr = 0x829FE448;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FE448 => {
    //   block [0x829FE448..0x829FE468)
	// 829FE448: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 829FE44C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE450: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829FE454: 4B81D8E5  bl 0x8221bd38
	ctx.lr = 0x829FE458;
	sub_8221BD38(ctx, base);
	// 829FE458: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE45C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 829FE460: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FE464: 409AFF94  bne cr6, 0x829fe3f8
	if !ctx.cr[6].eq {
	pc = 0x829FE3F8; continue 'dispatch;
	}
	pc = 0x829FE468; continue 'dispatch;
            }
            0x829FE468 => {
    //   block [0x829FE468..0x829FE470)
	// 829FE468: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FE46C: 482AAFE4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE470 size=224
    let mut pc: u32 = 0x829FE470;
    'dispatch: loop {
        match pc {
            0x829FE470 => {
    //   block [0x829FE470..0x829FE510)
	// 829FE470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE474: 482AAF99  bl 0x82ca940c
	ctx.lr = 0x829FE478;
	sub_82CA93D0(ctx, base);
	// 829FE478: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE47C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE480: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FE484: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829FE488: 394B2344  addi r10, r11, 0x2344
	ctx.r[10].s64 = ctx.r[11].s64 + 9028;
	// 829FE48C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FE490: 4B7D7A79  bl 0x821d5f08
	ctx.lr = 0x829FE494;
	sub_821D5F08(ctx, base);
	// 829FE494: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829FE498: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 829FE49C: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 829FE4A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE4A4: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 829FE4A8: 3BBF0048  addi r29, r31, 0x48
	ctx.r[29].s64 = ctx.r[31].s64 + 72;
	// 829FE4AC: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829FE4B0: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 829FE4B4: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 829FE4B8: 913F005C  stw r9, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 829FE4BC: 9BDF0060  stb r30, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 829FE4C0: 481989B9  bl 0x82b96e78
	ctx.lr = 0x829FE4C4;
	sub_82B96E78(ctx, base);
	// 829FE4C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FE4C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FE4CC: 482049DD  bl 0x82c02ea8
	ctx.lr = 0x829FE4D0;
	sub_82C02EA8(ctx, base);
	// 829FE4D0: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FE4D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FE4D8: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE4DC: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE4E0: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 829FE4E4: 4E800421  bctrl
	ctx.lr = 0x829FE4E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE4E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FE4EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FE4F0: 482137D9  bl 0x82c11cc8
	ctx.lr = 0x829FE4F4;
	sub_82C11CC8(ctx, base);
	// 829FE4F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FE4F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE4FC: 419A0014  beq cr6, 0x829fe510
	if ctx.cr[6].eq {
	pc = 0x829FE510; continue 'dispatch;
	}
	// 829FE500: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE504: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE508: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE50C: 4E800421  bctrl
	ctx.lr = 0x829FE510;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FE510 => {
    //   block [0x829FE510..0x829FE534)
	// 829FE510: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FE514: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 829FE518: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE51C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829FE520: 419A0014  beq cr6, 0x829fe534
	if ctx.cr[6].eq {
	pc = 0x829FE534; continue 'dispatch;
	}
	// 829FE524: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE528: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE52C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE530: 4E800421  bctrl
	ctx.lr = 0x829FE534;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FE534 => {
    //   block [0x829FE534..0x829FE550)
	// 829FE534: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 829FE538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE53C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 829FE540: 48198939  bl 0x82b96e78
	ctx.lr = 0x829FE544;
	sub_82B96E78(ctx, base);
	// 829FE544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE548: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FE54C: 482AAF10  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE550 size=200
    let mut pc: u32 = 0x829FE550;
    'dispatch: loop {
        match pc {
            0x829FE550 => {
    //   block [0x829FE550..0x829FE598)
	// 829FE550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE554: 482AAEB1  bl 0x82ca9404
	ctx.lr = 0x829FE558;
	sub_82CA93D0(ctx, base);
	// 829FE558: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE55C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE560: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829FE564: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 829FE568: 3BBF0050  addi r29, r31, 0x50
	ctx.r[29].s64 = ctx.r[31].s64 + 80;
	// 829FE56C: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE570: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE574: 419A0024  beq cr6, 0x829fe598
	if ctx.cr[6].eq {
	pc = 0x829FE598; continue 'dispatch;
	}
	// 829FE578: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE57C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FE580: 388007D0  li r4, 0x7d0
	ctx.r[4].s64 = 2000;
	// 829FE584: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 829FE588: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE58C: 4E800421  bctrl
	ctx.lr = 0x829FE590;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE590: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FE594: 48207965  bl 0x82c05ef8
	ctx.lr = 0x829FE598;
	sub_82C05EF8(ctx, base);
            }
            0x829FE598 => {
    //   block [0x829FE598..0x829FE5E4)
	// 829FE598: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 829FE59C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FE5A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE5A4: 4B7D6D45  bl 0x821d52e8
	ctx.lr = 0x829FE5A8;
	sub_821D52E8(ctx, base);
	// 829FE5A8: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 829FE5AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE5B0: 409A0034  bne cr6, 0x829fe5e4
	if !ctx.cr[6].eq {
	pc = 0x829FE5E4; continue 'dispatch;
	}
	// 829FE5B4: 809F0048  lwz r4, 0x48(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 829FE5B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829FE5BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE5C0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE5C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE5C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE5CC: 4E800421  bctrl
	ctx.lr = 0x829FE5D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE5D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FE5D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FE5D8: 482136F1  bl 0x82c11cc8
	ctx.lr = 0x829FE5DC;
	sub_82C11CC8(ctx, base);
	// 829FE5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE5E0: 48207919  bl 0x82c05ef8
	ctx.lr = 0x829FE5E4;
	sub_82C05EF8(ctx, base);
            }
            0x829FE5E4 => {
    //   block [0x829FE5E4..0x829FE610)
	// 829FE5E4: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FE5E8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 829FE5EC: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 829FE5F0: 993F0060  stb r9, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[9].u8 ) };
	// 829FE5F4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 829FE5F8: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FE5FC: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 829FE600: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 829FE604: 4198000C  blt cr6, 0x829fe610
	if ctx.cr[6].lt {
	pc = 0x829FE610; continue 'dispatch;
	}
	// 829FE608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FE60C: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	pc = 0x829FE610; continue 'dispatch;
            }
            0x829FE610 => {
    //   block [0x829FE610..0x829FE618)
	// 829FE610: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FE614: 482AAE40  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE618 size=132
    let mut pc: u32 = 0x829FE618;
    'dispatch: loop {
        match pc {
            0x829FE618 => {
    //   block [0x829FE618..0x829FE64C)
	// 829FE618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE61C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FE620: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FE624: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FE628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE62C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 829FE630: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FE634: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 829FE638: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 829FE63C: 419A0010  beq cr6, 0x829fe64c
	if ctx.cr[6].eq {
	pc = 0x829FE64C; continue 'dispatch;
	}
	// 829FE640: 815E0058  lwz r10, 0x58(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 829FE644: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829FE648: 409A003C  bne cr6, 0x829fe684
	if !ctx.cr[6].eq {
	pc = 0x829FE684; continue 'dispatch;
	}
	pc = 0x829FE64C; continue 'dispatch;
            }
            0x829FE64C => {
    //   block [0x829FE64C..0x829FE678)
	// 829FE64C: 807E0050  lwz r3, 0x50(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE650: 3BFE0050  addi r31, r30, 0x50
	ctx.r[31].s64 = ctx.r[30].s64 + 80;
	// 829FE654: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE658: 419A0020  beq cr6, 0x829fe678
	if ctx.cr[6].eq {
	pc = 0x829FE678; continue 'dispatch;
	}
	// 829FE65C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE660: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FE664: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 829FE668: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE66C: 4E800421  bctrl
	ctx.lr = 0x829FE670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE674: 48207885  bl 0x82c05ef8
	ctx.lr = 0x829FE678;
	sub_82C05EF8(ctx, base);
            }
            0x829FE678 => {
    //   block [0x829FE678..0x829FE684)
	// 829FE678: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FE67C: 917E0058  stw r11, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829FE680: 997E0060  stb r11, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	pc = 0x829FE684; continue 'dispatch;
            }
            0x829FE684 => {
    //   block [0x829FE684..0x829FE69C)
	// 829FE684: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FE688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FE68C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FE690: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FE694: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FE698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FE6A0 size=44
    let mut pc: u32 = 0x829FE6A0;
    'dispatch: loop {
        match pc {
            0x829FE6A0 => {
    //   block [0x829FE6A0..0x829FE6CC)
	// 829FE6A0: 89630060  lbz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FE6A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE6A8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 829FE6AC: 80630050  lwz r3, 0x50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE6B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE6B4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 829FE6B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE6BC: 388007D0  li r4, 0x7d0
	ctx.r[4].s64 = 2000;
	// 829FE6C0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FE6C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE6C8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE6D0 size=156
    let mut pc: u32 = 0x829FE6D0;
    'dispatch: loop {
        match pc {
            0x829FE6D0 => {
    //   block [0x829FE6D0..0x829FE728)
	// 829FE6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE6D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FE6D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FE6DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE6E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FE6E4: 894B0060  lbz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FE6E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FE6EC: 419A006C  beq cr6, 0x829fe758
	if ctx.cr[6].eq {
	pc = 0x829FE758; continue 'dispatch;
	}
	// 829FE6F0: 806B0050  lwz r3, 0x50(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE6F4: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 829FE6F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE6FC: 419A002C  beq cr6, 0x829fe728
	if ctx.cr[6].eq {
	pc = 0x829FE728; continue 'dispatch;
	}
	// 829FE700: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE704: 388007D0  li r4, 0x7d0
	ctx.r[4].s64 = 2000;
	// 829FE708: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829FE70C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE710: 4E800421  bctrl
	ctx.lr = 0x829FE714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE714: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FE718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FE71C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FE720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FE724: 4E800020  blr
	return;
            }
            0x829FE728 => {
    //   block [0x829FE728..0x829FE758)
	// 829FE728: 808B0048  lwz r4, 0x48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829FE72C: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 829FE730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE734: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE738: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE73C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE740: 4E800421  bctrl
	ctx.lr = 0x829FE744;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE744: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FE748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE74C: 4821357D  bl 0x82c11cc8
	ctx.lr = 0x829FE750;
	sub_82C11CC8(ctx, base);
	// 829FE750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE754: 482077A5  bl 0x82c05ef8
	ctx.lr = 0x829FE758;
	sub_82C05EF8(ctx, base);
            }
            0x829FE758 => {
    //   block [0x829FE758..0x829FE76C)
	// 829FE758: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FE75C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FE760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FE764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FE768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FE770 size=40
    let mut pc: u32 = 0x829FE770;
    'dispatch: loop {
        match pc {
            0x829FE770 => {
    //   block [0x829FE770..0x829FE798)
	// 829FE770: 89630060  lbz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FE774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE778: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 829FE77C: 80630050  lwz r3, 0x50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE784: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 829FE788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE78C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FE790: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE794: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE7A0 size=616
    let mut pc: u32 = 0x829FE7A0;
    'dispatch: loop {
        match pc {
            0x829FE7A0 => {
    //   block [0x829FE7A0..0x829FE820)
	// 829FE7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE7A4: 482AAC65  bl 0x82ca9408
	ctx.lr = 0x829FE7A8;
	sub_82CA93D0(ctx, base);
	// 829FE7A8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE7AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 829FE7B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE7B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FE7B8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829FE7BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FE7C0: 388BE244  addi r4, r11, -0x1dbc
	ctx.r[4].s64 = ctx.r[11].s64 + -7612;
	// 829FE7C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE7C8: 4B82E709  bl 0x8222ced0
	ctx.lr = 0x829FE7CC;
	sub_8222CED0(ctx, base);
	// 829FE7CC: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 829FE7D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FE7D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE7D8: 4801E671  bl 0x82a1ce48
	ctx.lr = 0x829FE7DC;
	sub_82A1CE48(ctx, base);
	// 829FE7DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE7E0: 4B8165F9  bl 0x82214dd8
	ctx.lr = 0x829FE7E4;
	sub_82214DD8(ctx, base);
	// 829FE7E4: 895F0060  lbz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FE7E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FE7EC: 419A0214  beq cr6, 0x829fea00
	if ctx.cr[6].eq {
	pc = 0x829FEA00; continue 'dispatch;
	}
	// 829FE7F0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FE7F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FE7F8: 388B20E8  addi r4, r11, 0x20e8
	ctx.r[4].s64 = ctx.r[11].s64 + 8424;
	// 829FE7FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE800: 4B82E6D1  bl 0x8222ced0
	ctx.lr = 0x829FE804;
	sub_8222CED0(ctx, base);
	// 829FE804: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829FE808: 3B8BFFDF  addi r28, r11, -0x21
	ctx.r[28].s64 = ctx.r[11].s64 + -33;
	// 829FE80C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FE810: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FE814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE818: 419A0008  beq cr6, 0x829fe820
	if ctx.cr[6].eq {
	pc = 0x829FE820; continue 'dispatch;
	}
	// 829FE81C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FE820; continue 'dispatch;
            }
            0x829FE820 => {
    //   block [0x829FE820..0x829FE85C)
	// 829FE820: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 829FE824: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE828: 4B991861  bl 0x82390088
	ctx.lr = 0x829FE82C;
	sub_82390088(ctx, base);
	// 829FE82C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE830: 4B8165A9  bl 0x82214dd8
	ctx.lr = 0x829FE834;
	sub_82214DD8(ctx, base);
	// 829FE834: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FE838: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FE83C: 388B20FC  addi r4, r11, 0x20fc
	ctx.r[4].s64 = ctx.r[11].s64 + 8444;
	// 829FE840: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE844: 4B82E68D  bl 0x8222ced0
	ctx.lr = 0x829FE848;
	sub_8222CED0(ctx, base);
	// 829FE848: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FE84C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FE850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE854: 419A0008  beq cr6, 0x829fe85c
	if ctx.cr[6].eq {
	pc = 0x829FE85C; continue 'dispatch;
	}
	// 829FE858: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FE85C; continue 'dispatch;
            }
            0x829FE85C => {
    //   block [0x829FE85C..0x829FE8B0)
	// 829FE85C: 38BF005C  addi r5, r31, 0x5c
	ctx.r[5].s64 = ctx.r[31].s64 + 92;
	// 829FE860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE864: 4B991825  bl 0x82390088
	ctx.lr = 0x829FE868;
	sub_82390088(ctx, base);
	// 829FE868: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE86C: 4B81656D  bl 0x82214dd8
	ctx.lr = 0x829FE870;
	sub_82214DD8(ctx, base);
	// 829FE870: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 829FE874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE878: 419A00B0  beq cr6, 0x829fe928
	if ctx.cr[6].eq {
	pc = 0x829FE928; continue 'dispatch;
	}
	// 829FE87C: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 829FE880: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FE884: 4B7F19BD  bl 0x821f0240
	ctx.lr = 0x829FE888;
	sub_821F0240(ctx, base);
	// 829FE888: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE88C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FE890: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE894: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829FE898: 419A0018  beq cr6, 0x829fe8b0
	if ctx.cr[6].eq {
	pc = 0x829FE8B0; continue 'dispatch;
	}
	// 829FE89C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE8A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE8A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FE8A8: 4E800421  bctrl
	ctx.lr = 0x829FE8AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE8AC: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
            }
            0x829FE8B0 => {
    //   block [0x829FE8B0..0x829FE904)
	// 829FE8B0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 829FE8B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FE8B8: 388B886C  addi r4, r11, -0x7794
	ctx.r[4].s64 = ctx.r[11].s64 + -30612;
	// 829FE8BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE8C0: 4B82E611  bl 0x8222ced0
	ctx.lr = 0x829FE8C4;
	sub_8222CED0(ctx, base);
	// 829FE8C4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 829FE8C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FE8CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE8D0: 4801E619  bl 0x82a1cee8
	ctx.lr = 0x829FE8D4;
	sub_82A1CEE8(ctx, base);
	// 829FE8D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE8D8: 4B816501  bl 0x82214dd8
	ctx.lr = 0x829FE8DC;
	sub_82214DD8(ctx, base);
	// 829FE8DC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 829FE8E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FE8E4: 388A4340  addi r4, r10, 0x4340
	ctx.r[4].s64 = ctx.r[10].s64 + 17216;
	// 829FE8E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE8EC: 4B82E5E5  bl 0x8222ced0
	ctx.lr = 0x829FE8F0;
	sub_8222CED0(ctx, base);
	// 829FE8F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FE8F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FE8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE8FC: 419A0008  beq cr6, 0x829fe904
	if ctx.cr[6].eq {
	pc = 0x829FE904; continue 'dispatch;
	}
	// 829FE900: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FE904; continue 'dispatch;
            }
            0x829FE904 => {
    //   block [0x829FE904..0x829FE928)
	// 829FE904: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829FE908: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE90C: 4B99177D  bl 0x82390088
	ctx.lr = 0x829FE910;
	sub_82390088(ctx, base);
	// 829FE910: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE914: 4B8164C5  bl 0x82214dd8
	ctx.lr = 0x829FE918;
	sub_82214DD8(ctx, base);
	// 829FE918: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FE91C: 4B8164BD  bl 0x82214dd8
	ctx.lr = 0x829FE920;
	sub_82214DD8(ctx, base);
	// 829FE920: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829FE924: 482AAB34  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FE928 => {
    //   block [0x829FE928..0x829FE938)
	// 829FE928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FE92C: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829FE930: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829FE934: 38E87088  addi r7, r8, 0x7088
	ctx.r[7].s64 = ctx.r[8].s64 + 28808;
	pc = 0x829FE938; continue 'dispatch;
            }
            0x829FE938 => {
    //   block [0x829FE938..0x829FE9AC)
	// 829FE938: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FE93C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FE940: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FE944: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FE948: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FE94C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FE950: 4082FFE8  bne 0x829fe938
	if !ctx.cr[0].eq {
	pc = 0x829FE938; continue 'dispatch;
	}
	// 829FE954: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829FE958: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 829FE95C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FE960: 3886886C  addi r4, r6, -0x7794
	ctx.r[4].s64 = ctx.r[6].s64 + -30612;
	// 829FE964: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FE968: 4B82E569  bl 0x8222ced0
	ctx.lr = 0x829FE96C;
	sub_8222CED0(ctx, base);
	// 829FE96C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FE970: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FE974: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FE978: 4801E571  bl 0x82a1cee8
	ctx.lr = 0x829FE97C;
	sub_82A1CEE8(ctx, base);
	// 829FE97C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FE980: 4B816459  bl 0x82214dd8
	ctx.lr = 0x829FE984;
	sub_82214DD8(ctx, base);
	// 829FE984: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 829FE988: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FE98C: 38844340  addi r4, r4, 0x4340
	ctx.r[4].s64 = ctx.r[4].s64 + 17216;
	// 829FE990: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FE994: 4B82E53D  bl 0x8222ced0
	ctx.lr = 0x829FE998;
	sub_8222CED0(ctx, base);
	// 829FE998: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FE99C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FE9A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE9A4: 419A0008  beq cr6, 0x829fe9ac
	if ctx.cr[6].eq {
	pc = 0x829FE9AC; continue 'dispatch;
	}
	// 829FE9A8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829FE9AC; continue 'dispatch;
            }
            0x829FE9AC => {
    //   block [0x829FE9AC..0x829FEA00)
	// 829FE9AC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829FE9B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE9B4: 4B9916D5  bl 0x82390088
	ctx.lr = 0x829FE9B8;
	sub_82390088(ctx, base);
	// 829FE9B8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FE9BC: 4B81641D  bl 0x82214dd8
	ctx.lr = 0x829FE9C0;
	sub_82214DD8(ctx, base);
	// 829FE9C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FE9C4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 829FE9C8: 4B7D7541  bl 0x821d5f08
	ctx.lr = 0x829FE9CC;
	sub_821D5F08(ctx, base);
	// 829FE9CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FE9D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE9D4: 4B7D6915  bl 0x821d52e8
	ctx.lr = 0x829FE9D8;
	sub_821D52E8(ctx, base);
	// 829FE9D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FE9DC: 4B88B06D  bl 0x82289a48
	ctx.lr = 0x829FE9E0;
	sub_82289A48(ctx, base);
	// 829FE9E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE9E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FE9E8: 4B866839  bl 0x82265220
	ctx.lr = 0x829FE9EC;
	sub_82265220(ctx, base);
	// 829FE9EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE9F0: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FE9F4: 48203F65  bl 0x82c02958
	ctx.lr = 0x829FE9F8;
	sub_82C02958(ctx, base);
	// 829FE9F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE9FC: 4B8163DD  bl 0x82214dd8
	ctx.lr = 0x829FEA00;
	sub_82214DD8(ctx, base);
	pc = 0x829FEA00; continue 'dispatch;
            }
            0x829FEA00 => {
    //   block [0x829FEA00..0x829FEA08)
	// 829FEA00: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829FEA04: 482AAA54  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FEA08 size=20
    let mut pc: u32 = 0x829FEA08;
    'dispatch: loop {
        match pc {
            0x829FEA08 => {
    //   block [0x829FEA08..0x829FEA1C)
	// 829FEA08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FEA0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FEA10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FEA14: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 829FEA18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FEA20 size=72
    let mut pc: u32 = 0x829FEA20;
    'dispatch: loop {
        match pc {
            0x829FEA20 => {
    //   block [0x829FEA20..0x829FEA54)
	// 829FEA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FEA28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FEA2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEA30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FEA34: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FEA38: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 829FEA3C: 392B210C  addi r9, r11, 0x210c
	ctx.r[9].s64 = ctx.r[11].s64 + 8460;
	// 829FEA40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FEA44: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FEA48: 419A000C  beq cr6, 0x829fea54
	if ctx.cr[6].eq {
	pc = 0x829FEA54; continue 'dispatch;
	}
	// 829FEA4C: 4B81D2ED  bl 0x8221bd38
	ctx.lr = 0x829FEA50;
	sub_8221BD38(ctx, base);
	// 829FEA50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829FEA54; continue 'dispatch;
            }
            0x829FEA54 => {
    //   block [0x829FEA54..0x829FEA68)
	// 829FEA54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FEA58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FEA5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FEA60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FEA64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FEA68 size=124
    let mut pc: u32 = 0x829FEA68;
    'dispatch: loop {
        match pc {
            0x829FEA68 => {
    //   block [0x829FEA68..0x829FEAA8)
	// 829FEA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FEA70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FEA74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FEA78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEA7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FEA80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FEA84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FEA88: 394B23D8  addi r10, r11, 0x23d8
	ctx.r[10].s64 = ctx.r[11].s64 + 9176;
	// 829FEA8C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FEA90: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FEA94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FEA98: 419A0010  beq cr6, 0x829feaa8
	if ctx.cr[6].eq {
	pc = 0x829FEAA8; continue 'dispatch;
	}
	// 829FEA9C: 482C3D15  bl 0x82cc27b0
	ctx.lr = 0x829FEAA0;
	sub_82CC27B0(ctx, base);
	// 829FEAA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FEAA4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x829FEAA8; continue 'dispatch;
            }
            0x829FEAA8 => {
    //   block [0x829FEAA8..0x829FEACC)
	// 829FEAA8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FEAAC: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829FEAB0: 392B210C  addi r9, r11, 0x210c
	ctx.r[9].s64 = ctx.r[11].s64 + 8460;
	// 829FEAB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FEAB8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FEABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FEAC0: 419A000C  beq cr6, 0x829feacc
	if ctx.cr[6].eq {
	pc = 0x829FEACC; continue 'dispatch;
	}
	// 829FEAC4: 4B81D275  bl 0x8221bd38
	ctx.lr = 0x829FEAC8;
	sub_8221BD38(ctx, base);
	// 829FEAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829FEACC; continue 'dispatch;
            }
            0x829FEACC => {
    //   block [0x829FEACC..0x829FEAE4)
	// 829FEACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FEAD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FEAD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FEAD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FEADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FEAE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FEAE8 size=548
    let mut pc: u32 = 0x829FEAE8;
    'dispatch: loop {
        match pc {
            0x829FEAE8 => {
    //   block [0x829FEAE8..0x829FEB10)
	// 829FEAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEAEC: 482AA91D  bl 0x82ca9408
	ctx.lr = 0x829FEAF0;
	sub_82CA93D0(ctx, base);
	// 829FEAF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEAF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FEAF8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829FEAFC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829FEB00: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 829FEB04: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 829FEB08: 915E0018  stw r10, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 829FEB0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x829FEB10; continue 'dispatch;
            }
            0x829FEB10 => {
    //   block [0x829FEB10..0x829FEB4C)
	// 829FEB10: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FEB14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FEB18: 4200FFF8  bdnz 0x829feb10
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FEB10; continue 'dispatch;
	}
	// 829FEB1C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 829FEB20: 4B8207A1  bl 0x8221f2c0
	ctx.lr = 0x829FEB24;
	sub_8221F2C0(ctx, base);
	// 829FEB24: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 829FEB28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FEB2C: 409A0154  bne cr6, 0x829fec80
	if !ctx.cr[6].eq {
	pc = 0x829FEC80; continue 'dispatch;
	}
	// 829FEB30: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 829FEB34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FEB38: 419A0014  beq cr6, 0x829feb4c
	if ctx.cr[6].eq {
	pc = 0x829FEB4C; continue 'dispatch;
	}
	// 829FEB3C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FEB40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FEB44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FEB48: 4E800421  bctrl
	ctx.lr = 0x829FEB4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FEB4C => {
    //   block [0x829FEB4C..0x829FEB54)
	// 829FEB4C: 482C385D  bl 0x82cc23a8
	ctx.lr = 0x829FEB50;
	sub_82CC23A8(ctx, base);
	// 829FEB50: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x829FEB54; continue 'dispatch;
            }
            0x829FEB54 => {
    //   block [0x829FEB54..0x829FEB88)
	// 829FEB54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FEB58: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829FEB5C: 4B820765  bl 0x8221f2c0
	ctx.lr = 0x829FEB60;
	sub_8221F2C0(ctx, base);
	// 829FEB60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FEB64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FEB68: 409A0130  bne cr6, 0x829fec98
	if !ctx.cr[6].eq {
	pc = 0x829FEC98; continue 'dispatch;
	}
	// 829FEB6C: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 829FEB70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FEB74: 419A0014  beq cr6, 0x829feb88
	if ctx.cr[6].eq {
	pc = 0x829FEB88; continue 'dispatch;
	}
	// 829FEB78: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FEB7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FEB80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FEB84: 4E800421  bctrl
	ctx.lr = 0x829FEB88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FEB88 => {
    //   block [0x829FEB88..0x829FEB90)
	// 829FEB88: 482C3821  bl 0x82cc23a8
	ctx.lr = 0x829FEB8C;
	sub_82CC23A8(ctx, base);
	// 829FEB8C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x829FEB90; continue 'dispatch;
            }
            0x829FEB90 => {
    //   block [0x829FEB90..0x829FEBC0)
	// 829FEB90: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829FEB94: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 829FEB98: 4B820729  bl 0x8221f2c0
	ctx.lr = 0x829FEB9C;
	sub_8221F2C0(ctx, base);
	// 829FEB9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FEBA0: 409A013C  bne cr6, 0x829fecdc
	if !ctx.cr[6].eq {
	pc = 0x829FECDC; continue 'dispatch;
	}
	// 829FEBA4: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 829FEBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FEBAC: 419A0014  beq cr6, 0x829febc0
	if ctx.cr[6].eq {
	pc = 0x829FEBC0; continue 'dispatch;
	}
	// 829FEBB0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FEBB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FEBB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FEBBC: 4E800421  bctrl
	ctx.lr = 0x829FEBC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FEBC0 => {
    //   block [0x829FEBC0..0x829FEBC8)
	// 829FEBC0: 482C37E9  bl 0x82cc23a8
	ctx.lr = 0x829FEBC4;
	sub_82CC23A8(ctx, base);
	// 829FEBC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x829FEBC8; continue 'dispatch;
            }
            0x829FEBC8 => {
    //   block [0x829FEBC8..0x829FEBF8)
	// 829FEBC8: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 829FEBCC: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 829FEBD0: 4B8206F1  bl 0x8221f2c0
	ctx.lr = 0x829FEBD4;
	sub_8221F2C0(ctx, base);
	// 829FEBD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FEBD8: 409A010C  bne cr6, 0x829fece4
	if !ctx.cr[6].eq {
	pc = 0x829FECE4; continue 'dispatch;
	}
	// 829FEBDC: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 829FEBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FEBE4: 419A0014  beq cr6, 0x829febf8
	if ctx.cr[6].eq {
	pc = 0x829FEBF8; continue 'dispatch;
	}
	// 829FEBE8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FEBEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FEBF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FEBF4: 4E800421  bctrl
	ctx.lr = 0x829FEBF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FEBF8 => {
    //   block [0x829FEBF8..0x829FEC00)
	// 829FEBF8: 482C37B1  bl 0x82cc23a8
	ctx.lr = 0x829FEBFC;
	sub_82CC23A8(ctx, base);
	// 829FEBFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x829FEC00; continue 'dispatch;
            }
            0x829FEC00 => {
    //   block [0x829FEC00..0x829FEC30)
	// 829FEC00: 907E000C  stw r3, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 829FEC04: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 829FEC08: 4B8206B9  bl 0x8221f2c0
	ctx.lr = 0x829FEC0C;
	sub_8221F2C0(ctx, base);
	// 829FEC0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FEC10: 409A00DC  bne cr6, 0x829fecec
	if !ctx.cr[6].eq {
	pc = 0x829FECEC; continue 'dispatch;
	}
	// 829FEC14: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 829FEC18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FEC1C: 419A0014  beq cr6, 0x829fec30
	if ctx.cr[6].eq {
	pc = 0x829FEC30; continue 'dispatch;
	}
	// 829FEC20: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FEC24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FEC28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FEC2C: 4E800421  bctrl
	ctx.lr = 0x829FEC30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FEC30 => {
    //   block [0x829FEC30..0x829FEC38)
	// 829FEC30: 482C3779  bl 0x82cc23a8
	ctx.lr = 0x829FEC34;
	sub_82CC23A8(ctx, base);
	// 829FEC34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x829FEC38; continue 'dispatch;
            }
            0x829FEC38 => {
    //   block [0x829FEC38..0x829FEC68)
	// 829FEC38: 907E0010  stw r3, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 829FEC3C: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 829FEC40: 4B820681  bl 0x8221f2c0
	ctx.lr = 0x829FEC44;
	sub_8221F2C0(ctx, base);
	// 829FEC44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FEC48: 409A00AC  bne cr6, 0x829fecf4
	if !ctx.cr[6].eq {
	pc = 0x829FECF4; continue 'dispatch;
	}
	// 829FEC4C: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 829FEC50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FEC54: 419A0014  beq cr6, 0x829fec68
	if ctx.cr[6].eq {
	pc = 0x829FEC68; continue 'dispatch;
	}
	// 829FEC58: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FEC5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FEC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FEC64: 4E800421  bctrl
	ctx.lr = 0x829FEC68;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FEC68 => {
    //   block [0x829FEC68..0x829FEC80)
	// 829FEC68: 482C3741  bl 0x82cc23a8
	ctx.lr = 0x829FEC6C;
	sub_82CC23A8(ctx, base);
	// 829FEC6C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829FEC70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FEC74: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 829FEC78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FEC7C: 482AA7DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FEC80 => {
    //   block [0x829FEC80..0x829FEC98)
	// 829FEC80: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FEC84: 9B830004  stb r28, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u8 ) };
	// 829FEC88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FEC8C: 392A23B4  addi r9, r10, 0x23b4
	ctx.r[9].s64 = ctx.r[10].s64 + 9140;
	// 829FEC90: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FEC94: 4BFFFEC0  b 0x829feb54
	pc = 0x829FEB54; continue 'dispatch;
            }
            0x829FEC98 => {
    //   block [0x829FEC98..0x829FECDC)
	// 829FEC98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FEC9C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 829FECA0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FECA4: 9B9F0008  stb r28, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u8 ) };
	// 829FECA8: 392B23D8  addi r9, r11, 0x23d8
	ctx.r[9].s64 = ctx.r[11].s64 + 9176;
	// 829FECAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FECB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FECB4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FECB8: 482FE789  bl 0x82cfd440
	ctx.lr = 0x829FECBC;
	sub_82CFD440(ctx, base);
	// 829FECBC: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FECC0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 829FECC4: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 829FECC8: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 829FECCC: 98DF0008  stb r6, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u8 ) };
	// 829FECD0: 482C4149  bl 0x82cc2e18
	ctx.lr = 0x829FECD4;
	sub_82CC2E18(ctx, base);
	// 829FECD4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 829FECD8: 4BFFFEB8  b 0x829feb90
	pc = 0x829FEB90; continue 'dispatch;
            }
            0x829FECDC => {
    //   block [0x829FECDC..0x829FECE4)
	// 829FECDC: 4BFFF795  bl 0x829fe470
	ctx.lr = 0x829FECE0;
	sub_829FE470(ctx, base);
	// 829FECE0: 4BFFFEE8  b 0x829febc8
	pc = 0x829FEBC8; continue 'dispatch;
            }
            0x829FECE4 => {
    //   block [0x829FECE4..0x829FECEC)
	// 829FECE4: 4BFFF78D  bl 0x829fe470
	ctx.lr = 0x829FECE8;
	sub_829FE470(ctx, base);
	// 829FECE8: 4BFFFF18  b 0x829fec00
	pc = 0x829FEC00; continue 'dispatch;
            }
            0x829FECEC => {
    //   block [0x829FECEC..0x829FECF4)
	// 829FECEC: 4BFFF785  bl 0x829fe470
	ctx.lr = 0x829FECF0;
	sub_829FE470(ctx, base);
	// 829FECF0: 4BFFFF48  b 0x829fec38
	pc = 0x829FEC38; continue 'dispatch;
            }
            0x829FECF4 => {
    //   block [0x829FECF4..0x829FED0C)
	// 829FECF4: 4BFFF77D  bl 0x829fe470
	ctx.lr = 0x829FECF8;
	sub_829FE470(ctx, base);
	// 829FECF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FECFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FED00: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 829FED04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FED08: 482AA750  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FED10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FED10 size=188
    let mut pc: u32 = 0x829FED10;
    'dispatch: loop {
        match pc {
            0x829FED10 => {
    //   block [0x829FED10..0x829FED44)
	// 829FED10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FED14: 482AA6F5  bl 0x82ca9408
	ctx.lr = 0x829FED18;
	sub_82CA93D0(ctx, base);
	// 829FED18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FED1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829FED20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FED24: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FED28: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829FED2C: 7FEBF02E  lwzx r31, r11, r30
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 829FED30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FED34: 409A0010  bne cr6, 0x829fed44
	if !ctx.cr[6].eq {
	pc = 0x829FED44; continue 'dispatch;
	}
	// 829FED38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FED3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FED40: 482AA718  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FED44 => {
    //   block [0x829FED44..0x829FED78)
	// 829FED44: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FED48: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FED4C: 40980054  bge cr6, 0x829feda0
	if !ctx.cr[6].lt {
	pc = 0x829FEDA0; continue 'dispatch;
	}
	// 829FED50: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 829FED54: 40980024  bge cr6, 0x829fed78
	if !ctx.cr[6].lt {
	pc = 0x829FED78; continue 'dispatch;
	}
	// 829FED58: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FED5C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 829FED60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FED64: 419A0014  beq cr6, 0x829fed78
	if ctx.cr[6].eq {
	pc = 0x829FED78; continue 'dispatch;
	}
	// 829FED68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FED6C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829FED70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FED74: 4E800421  bctrl
	ctx.lr = 0x829FED78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FED78 => {
    //   block [0x829FED78..0x829FEDA0)
	// 829FED78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FED7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FED80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FED84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FED88: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FED8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FED90: 4E800421  bctrl
	ctx.lr = 0x829FED94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FED94: 93BE0018  stw r29, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 829FED98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FED9C: 482AA6BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FEDA0 => {
    //   block [0x829FEDA0..0x829FEDBC)
	// 829FEDA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FEDA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FEDA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FEDAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829FEDB0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FEDB4: 41990008  bgt cr6, 0x829fedbc
	if ctx.cr[6].gt {
	pc = 0x829FEDBC; continue 'dispatch;
	}
	// 829FEDB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x829FEDBC; continue 'dispatch;
            }
            0x829FEDBC => {
    //   block [0x829FEDBC..0x829FEDCC)
	// 829FEDBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FEDC0: 4E800421  bctrl
	ctx.lr = 0x829FEDC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FEDC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FEDC8: 482AA690  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FEDD0 size=500
    let mut pc: u32 = 0x829FEDD0;
    'dispatch: loop {
        match pc {
            0x829FEDD0 => {
    //   block [0x829FEDD0..0x829FEE24)
	// 829FEDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEDD4: 482AA635  bl 0x82ca9408
	ctx.lr = 0x829FEDD8;
	sub_82CA93D0(ctx, base);
	// 829FEDD8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 829FEDDC: 482AEEF5  bl 0x82cadcd0
	ctx.lr = 0x829FEDE0;
	sub_82CADCA0(ctx, base);
	// 829FEDE0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEDE4: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 829FEDE8: C00100CC  lfs f0, 0xcc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FEDEC: C38100C8  lfs f28, 0xc8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829FEDF0: ED9C0732  fmuls f12, f28, f28
	ctx.f[12].f64 = (((ctx.f[28].f64 * ctx.f[28].f64) as f32) as f64);
	// 829FEDF4: ED60603A  fmadds f11, f0, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 829FEDF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FEDFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FEE00: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FEE04: EF60582C  fsqrts f27, f11
	ctx.f[27].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 829FEE08: FF1B6800  fcmpu cr6, f27, f13
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[13].f64);
	// 829FEE0C: 40980018  bge cr6, 0x829fee24
	if !ctx.cr[6].lt {
	pc = 0x829FEE24; continue 'dispatch;
	}
	// 829FEE10: F89F0000  std r4, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 829FEE14: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829FEE18: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 829FEE1C: 482AEF01  bl 0x82cadd1c
	ctx.lr = 0x829FEE20;
	sub_82CADCEC(ctx, base);
	// 829FEE20: 482AA638  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FEE24 => {
    //   block [0x829FEE24..0x829FEFC4)
	// 829FEE24: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 829FEE28: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 829FEE2C: 3BBE92D4  addi r29, r30, -0x6d2c
	ctx.r[29].s64 = ctx.r[30].s64 + -27948;
	// 829FEE30: 3B8B0E68  addi r28, r11, 0xe68
	ctx.r[28].s64 = ctx.r[11].s64 + 3688;
	// 829FEE34: C3FD01B0  lfs f31, 0x1b0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FEE38: EC1C07FA  fmadds f0, f28, f31, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 829FEE3C: C3BD42F4  lfs f29, 0x42f4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(17140 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829FEE40: C3DD01BC  lfs f30, 0x1bc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(444 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829FEE44: EDA0D824  fdivs f13, f0, f27
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[27].f64) as f32) as f64;
	// 829FEE48: ED8DE828  fsubs f12, f13, f29
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[29].f64) as f32) as f64);
	// 829FEE4C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 829FEE50: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829FEE54: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 829FEE58: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 829FEE5C: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 829FEE60: 7D7C3C2E  lfsx f11, r28, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829FEE64: FD4BEB6E  fsel f10, f11, f13, f29
	ctx.f[10].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[29].f64 };
	// 829FEE68: ED2AF028  fsubs f9, f10, f30
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[30].f64) as f32) as f64);
	// 829FEE6C: FF09F800  fcmpu cr6, f9, f31
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[31].f64);
	// 829FEE70: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829FEE74: 54C5DF7A  rlwinm r5, r6, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 829FEE78: 54C4F77A  rlwinm r4, r6, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 829FEE7C: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 829FEE80: 7D1C1C2E  lfsx f8, r28, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 829FEE84: FC2857AE  fsel f1, f8, f30, f10
	ctx.f[1].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[10].f64 };
	// 829FEE88: 4B861AB9  bl 0x82260940
	ctx.lr = 0x829FEE8C;
	sub_82260940(ctx, base);
	// 829FEE8C: FCE00818  frsp f7, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829FEE90: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 829FEE94: C1BD21AC  lfs f13, 0x21ac(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8620 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FEE98: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 829FEE9C: C00B0E8C  lfs f0, 0xe8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FEEA0: C19D9044  lfs f12, -0x6fbc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FEEA4: EF470032  fmuls f26, f7, f0
	ctx.f[26].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 829FEEA8: ECDA0372  fmuls f6, f26, f13
	ctx.f[6].f64 = (((ctx.f[26].f64 * ctx.f[13].f64) as f32) as f64);
	// 829FEEAC: EC260332  fmuls f1, f6, f12
	ctx.f[1].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 829FEEB0: 4B83B0E1  bl 0x82239f90
	ctx.lr = 0x829FEEB4;
	sub_82239F90(ctx, base);
	// 829FEEB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FEEB8: C01D9044  lfs f0, -0x6fbc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FEEBC: FCA00818  frsp f5, f1
	ctx.f[5].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829FEEC0: EC3A0032  fmuls f1, f26, f0
	ctx.f[1].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 829FEEC4: C80A0DE8  lfd f0, 0xde8(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3560 as u32) ) };
	// 829FEEC8: EC80002C  fsqrts f4, f0
	ctx.f[4].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 829FEECC: EC64F028  fsubs f3, f4, f30
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[30].f64) as f32) as f64);
	// 829FEED0: EC430172  fmuls f2, f3, f5
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[5].f64) as f32) as f64);
	// 829FEED4: EC02F17A  fmadds f0, f2, f5, f30
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[5].f64 + ctx.f[30].f64) as f32) as f64);
	// 829FEED8: EF6006F2  fmuls f27, f0, f27
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 829FEEDC: 4B83AFD5  bl 0x82239eb0
	ctx.lr = 0x829FEEE0;
	sub_82239EB0(ctx, base);
	// 829FEEE0: FF1CF800  fcmpu cr6, f28, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[31].f64);
	// 829FEEE4: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829FEEE8: 5528DF7A  rlwinm r8, r9, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 829FEEEC: C01E92D4  lfs f0, -0x6d2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FEEF0: 5527F77A  rlwinm r7, r9, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 829FEEF4: C1BD9044  lfs f13, -0x6fbc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FEEF8: FF800818  frsp f28, f1
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829FEEFC: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 829FEF00: 7D9C342E  lfsx f12, r28, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FEF04: FD6C07EE  fsel f11, f12, f31, f0
	ctx.f[11].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[0].f64 };
	// 829FEF08: ED4BD02A  fadds f10, f11, f26
	ctx.f[10].f64 = ((ctx.f[11].f64 + ctx.f[26].f64) as f32) as f64;
	// 829FEF0C: EC2A0372  fmuls f1, f10, f13
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 829FEF10: 4B83B081  bl 0x82239f90
	ctx.lr = 0x829FEF14;
	sub_82239F90(ctx, base);
	// 829FEF14: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829FEF18: ED1C06F2  fmuls f8, f28, f27
	ctx.f[8].f64 = (((ctx.f[28].f64 * ctx.f[27].f64) as f32) as f64);
	// 829FEF1C: ECE906F2  fmuls f7, f9, f27
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[27].f64) as f32) as f64);
	// 829FEF20: ECC8E828  fsubs f6, f8, f29
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[29].f64) as f32) as f64);
	// 829FEF24: ECA7E828  fsubs f5, f7, f29
	ctx.f[5].f64 = (((ctx.f[7].f64 - ctx.f[29].f64) as f32) as f64);
	// 829FEF28: FF05F800  fcmpu cr6, f5, f31
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[31].f64);
	// 829FEF2C: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829FEF30: 54A4DF7A  rlwinm r4, r5, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 829FEF34: 54A3F77A  rlwinm r3, r5, 0x1e, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 829FEF38: 7C8B1B78  or r11, r4, r3
	ctx.r[11].u64 = ctx.r[4].u64 | ctx.r[3].u64;
	// 829FEF3C: 7C9C5C2E  lfsx f4, r28, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 829FEF40: FC64E9EE  fsel f3, f4, f7, f29
	ctx.f[3].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[7].f64 } else { ctx.f[29].f64 };
	// 829FEF44: EC43F028  fsubs f2, f3, f30
	ctx.f[2].f64 = (((ctx.f[3].f64 - ctx.f[30].f64) as f32) as f64);
	// 829FEF48: FF02F800  fcmpu cr6, f2, f31
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[31].f64);
	// 829FEF4C: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829FEF50: FF06F800  fcmpu cr6, f6, f31
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[31].f64);
	// 829FEF54: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829FEF58: 5548DF7A  rlwinm r8, r10, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 829FEF5C: 5547F77A  rlwinm r7, r10, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 829FEF60: 5526DF7A  rlwinm r6, r9, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 829FEF64: 5525F77A  rlwinm r5, r9, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 829FEF68: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 829FEF6C: 7D0B3B78  or r11, r8, r7
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 829FEF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FEF74: 7C3C242E  lfsx f1, r28, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FEF78: FC01EA2E  fsel f0, f1, f8, f29
	ctx.f[0].f64 = if ctx.f[1].f64 >= 0.0 { ctx.f[8].f64 } else { ctx.f[29].f64 };
	// 829FEF7C: 7DBC5C2E  lfsx f13, r28, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FEF80: FD8D1FAE  fsel f12, f13, f30, f3
	ctx.f[12].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[3].f64 };
	// 829FEF84: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829FEF88: ED60F028  fsubs f11, f0, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 829FEF8C: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 829FEF90: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829FEF94: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 829FEF98: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 829FEF9C: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 829FEFA0: 7D5C3C2E  lfsx f10, r28, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829FEFA4: FD2A07AE  fsel f9, f10, f30, f0
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[0].f64 };
	// 829FEFA8: D1210054  stfs f9, 0x54(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829FEFAC: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FEFB0: F8DF0000  std r6, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 829FEFB4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829FEFB8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 829FEFBC: 482AED61  bl 0x82cadd1c
	ctx.lr = 0x829FEFC0;
	sub_82CADCEC(ctx, base);
	// 829FEFC0: 482AA498  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FEFC8 size=112
    let mut pc: u32 = 0x829FEFC8;
    'dispatch: loop {
        match pc {
            0x829FEFC8 => {
    //   block [0x829FEFC8..0x829FEFEC)
	// 829FEFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEFCC: 482AA43D  bl 0x82ca9408
	ctx.lr = 0x829FEFD0;
	sub_82CA93D0(ctx, base);
	// 829FEFD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEFD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FEFD8: 3BDC0024  addi r30, r28, 0x24
	ctx.r[30].s64 = ctx.r[28].s64 + 36;
	// 829FEFDC: 807C0028  lwz r3, 0x28(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 829FEFE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FEFE4: 419A0008  beq cr6, 0x829fefec
	if ctx.cr[6].eq {
	pc = 0x829FEFEC; continue 'dispatch;
	}
	// 829FEFE8: 4B81CD51  bl 0x8221bd38
	ctx.lr = 0x829FEFEC;
	sub_8221BD38(ctx, base);
	pc = 0x829FEFEC; continue 'dispatch;
            }
            0x829FEFEC => {
    //   block [0x829FEFEC..0x829FF010)
	// 829FEFEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829FEFF0: 3BBC0014  addi r29, r28, 0x14
	ctx.r[29].s64 = ctx.r[28].s64 + 20;
	// 829FEFF4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829FEFF8: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 829FEFFC: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FF000: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FF004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FF008: 419A0008  beq cr6, 0x829ff010
	if ctx.cr[6].eq {
	pc = 0x829FF010; continue 'dispatch;
	}
	// 829FF00C: 4B81CD2D  bl 0x8221bd38
	ctx.lr = 0x829FF010;
	sub_8221BD38(ctx, base);
	pc = 0x829FF010; continue 'dispatch;
            }
            0x829FF010 => {
    //   block [0x829FF010..0x829FF038)
	// 829FF010: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829FF014: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 829FF018: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 829FF01C: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FF020: 4B9DD809  bl 0x823dc828
	ctx.lr = 0x829FF024;
	sub_823DC828(ctx, base);
	// 829FF024: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FF028: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 829FF02C: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FF030: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FF034: 482AA424  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF038 size=88
    let mut pc: u32 = 0x829FF038;
    'dispatch: loop {
        match pc {
            0x829FF038 => {
    //   block [0x829FF038..0x829FF05C)
	// 829FF038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF03C: 482AA3D1  bl 0x82ca940c
	ctx.lr = 0x829FF040;
	sub_82CA93D0(ctx, base);
	// 829FF040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF044: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FF048: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829FF04C: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF050: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF054: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FF058: 419A002C  beq cr6, 0x829ff084
	if ctx.cr[6].eq {
	pc = 0x829FF084; continue 'dispatch;
	}
	pc = 0x829FF05C; continue 'dispatch;
            }
            0x829FF05C => {
    //   block [0x829FF05C..0x829FF084)
	// 829FF05C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF060: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FF064: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF068: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FF06C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FF070: 4E800421  bctrl
	ctx.lr = 0x829FF074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FF074: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF078: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829FF07C: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829FF080: 409AFFDC  bne cr6, 0x829ff05c
	if !ctx.cr[6].eq {
	pc = 0x829FF05C; continue 'dispatch;
	}
            }
            0x829FF084 => {
    //   block [0x829FF084..0x829FF090)
	// 829FF084: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FF088: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FF08C: 482AA3D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FF090 size=120
    let mut pc: u32 = 0x829FF090;
    'dispatch: loop {
        match pc {
            0x829FF090 => {
    //   block [0x829FF090..0x829FF0D0)
	// 829FF090: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 829FF094: 38830024  addi r4, r3, 0x24
	ctx.r[4].s64 = ctx.r[3].s64 + 36;
	// 829FF098: 8103002C  lwz r8, 0x2c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 829FF09C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829FF0A0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 829FF0A4: 38E00048  li r7, 0x48
	ctx.r[7].s64 = 72;
	// 829FF0A8: 7D684050  subf r11, r8, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[8].s64;
	// 829FF0AC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 829FF0B0: 7D6B3BD6  divw r11, r11, r7
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[7].s32;
	// 829FF0B4: 7F084040  cmplw cr6, r8, r8
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829FF0B8: 55671838  slwi r7, r11, 3
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 829FF0BC: 7CCB3A14  add r6, r11, r7
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 829FF0C0: 54CB1838  slwi r11, r6, 3
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FF0C4: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829FF0C8: 419A0038  beq cr6, 0x829ff100
	if ctx.cr[6].eq {
	pc = 0x829FF100; continue 'dispatch;
	}
	// 829FF0CC: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	pc = 0x829FF0D0; continue 'dispatch;
            }
            0x829FF0D0 => {
    //   block [0x829FF0D0..0x829FF0E0)
	// 829FF0D0: 7D464A14  add r10, r6, r9
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 829FF0D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 829FF0D8: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 829FF0DC: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x829FF0E0; continue 'dispatch;
            }
            0x829FF0E0 => {
    //   block [0x829FF0E0..0x829FF100)
	// 829FF0E0: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829FF0E4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF0E8: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 829FF0EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF0F0: 4200FFF0  bdnz 0x829ff0e0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF0E0; continue 'dispatch;
	}
	// 829FF0F4: 39290048  addi r9, r9, 0x48
	ctx.r[9].s64 = ctx.r[9].s64 + 72;
	// 829FF0F8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829FF0FC: 409AFFD4  bne cr6, 0x829ff0d0
	if !ctx.cr[6].eq {
	pc = 0x829FF0D0; continue 'dispatch;
	}
	pc = 0x829FF100; continue 'dispatch;
            }
            0x829FF100 => {
    //   block [0x829FF100..0x829FF108)
	// 829FF100: 90A40008  stw r5, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 829FF104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF108 size=344
    let mut pc: u32 = 0x829FF108;
    'dispatch: loop {
        match pc {
            0x829FF108 => {
    //   block [0x829FF108..0x829FF138)
	// 829FF108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FF110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FF114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FF118: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF11C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FF120: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FF124: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF128: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF12C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF130: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829FF134: 419A0020  beq cr6, 0x829ff154
	if ctx.cr[6].eq {
	pc = 0x829FF154; continue 'dispatch;
	}
	pc = 0x829FF138; continue 'dispatch;
            }
            0x829FF138 => {
    //   block [0x829FF138..0x829FF154)
	// 829FF138: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF13C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF140: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 829FF144: 419A0044  beq cr6, 0x829ff188
	if ctx.cr[6].eq {
	pc = 0x829FF188; continue 'dispatch;
	}
	// 829FF148: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF14C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829FF150: 409AFFE8  bne cr6, 0x829ff138
	if !ctx.cr[6].eq {
	pc = 0x829FF138; continue 'dispatch;
	}
	pc = 0x829FF154; continue 'dispatch;
            }
            0x829FF154 => {
    //   block [0x829FF154..0x829FF188)
	// 829FF154: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829FF158: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829FF15C: 4B8200FD  bl 0x8221f258
	ctx.lr = 0x829FF160;
	sub_8221F258(ctx, base);
	// 829FF160: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FF164: 419A0040  beq cr6, 0x829ff1a4
	if ctx.cr[6].eq {
	pc = 0x829FF1A4; continue 'dispatch;
	}
	// 829FF168: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 829FF16C: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 829FF170: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FF174: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 829FF178: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 829FF17C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FF180: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829FF184: 48000024  b 0x829ff1a8
	pc = 0x829FF1A8; continue 'dispatch;
            }
            0x829FF188 => {
    //   block [0x829FF188..0x829FF1A4)
	// 829FF188: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF18C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FF190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FF194: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF198: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FF19C: 4E800421  bctrl
	ctx.lr = 0x829FF1A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FF1A0: 480000A8  b 0x829ff248
	pc = 0x829FF248; continue 'dispatch;
            }
            0x829FF1A4 => {
    //   block [0x829FF1A4..0x829FF1A8)
	// 829FF1A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x829FF1A8; continue 'dispatch;
            }
            0x829FF1A8 => {
    //   block [0x829FF1A8..0x829FF1C4)
	// 829FF1A8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF1AC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829FF1B0: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 829FF1B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FF1B8: 409A000C  bne cr6, 0x829ff1c4
	if !ctx.cr[6].eq {
	pc = 0x829FF1C4; continue 'dispatch;
	}
	// 829FF1BC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829FF1C0: 48000010  b 0x829ff1d0
	pc = 0x829FF1D0; continue 'dispatch;
            }
            0x829FF1C4 => {
    //   block [0x829FF1C4..0x829FF1D0)
	// 829FF1C4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF1C8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829FF1CC: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x829FF1D0; continue 'dispatch;
            }
            0x829FF1D0 => {
    //   block [0x829FF1D0..0x829FF1FC)
	// 829FF1D0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF1D4: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829FF1D8: 7D471E70  srawi r7, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 829FF1DC: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829FF1E0: 40980044  bge cr6, 0x829ff224
	if !ctx.cr[6].lt {
	pc = 0x829FF224; continue 'dispatch;
	}
	// 829FF1E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FF1E8: 419A0030  beq cr6, 0x829ff218
	if ctx.cr[6].eq {
	pc = 0x829FF218; continue 'dispatch;
	}
	// 829FF1EC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FF1F0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829FF1F4: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 829FF1F8: 419A0020  beq cr6, 0x829ff218
	if ctx.cr[6].eq {
	pc = 0x829FF218; continue 'dispatch;
	}
	pc = 0x829FF1FC; continue 'dispatch;
            }
            0x829FF1FC => {
    //   block [0x829FF1FC..0x829FF218)
	// 829FF1FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FF200: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FF204: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FF208: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FF20C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FF210: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FF214: 4082FFE8  bne 0x829ff1fc
	if !ctx.cr[0].eq {
	pc = 0x829FF1FC; continue 'dispatch;
	}
	pc = 0x829FF218; continue 'dispatch;
            }
            0x829FF218 => {
    //   block [0x829FF218..0x829FF224)
	// 829FF218: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF21C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829FF220: 48000020  b 0x829ff240
	pc = 0x829FF240; continue 'dispatch;
            }
            0x829FF224 => {
    //   block [0x829FF224..0x829FF240)
	// 829FF224: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829FF228: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FF22C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829FF230: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829FF234: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 829FF238: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829FF23C: 4816A605  bl 0x82b69840
	ctx.lr = 0x829FF240;
	sub_82B69840(ctx, base);
	pc = 0x829FF240; continue 'dispatch;
            }
            0x829FF240 => {
    //   block [0x829FF240..0x829FF248)
	// 829FF240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF244: 4B7B88D5  bl 0x821b7b18
	ctx.lr = 0x829FF248;
	sub_821B7B18(ctx, base);
	pc = 0x829FF248; continue 'dispatch;
            }
            0x829FF248 => {
    //   block [0x829FF248..0x829FF260)
	// 829FF248: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FF24C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FF250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FF254: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FF258: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FF25C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF260 size=208
    let mut pc: u32 = 0x829FF260;
    'dispatch: loop {
        match pc {
            0x829FF260 => {
    //   block [0x829FF260..0x829FF2AC)
	// 829FF260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF264: 482AA1A9  bl 0x82ca940c
	ctx.lr = 0x829FF268;
	sub_82CA93D0(ctx, base);
	// 829FF268: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF26C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FF270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF274: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829FF278: 4B81F7B1  bl 0x8221ea28
	ctx.lr = 0x829FF27C;
	sub_8221EA28(ctx, base);
	// 829FF27C: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FF280: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 829FF284: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 829FF288: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 829FF28C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF290: C80A70A0  lfd f0, 0x70a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28832 as u32) ) };
	// 829FF294: C9A970A8  lfd f13, 0x70a8(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(28840 as u32) ) };
	// 829FF298: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 829FF29C: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF2A0: FC2A6824  fdiv f1, f10, f13
	ctx.f[1].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 829FF2A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FF2A8: 419A0080  beq cr6, 0x829ff328
	if ctx.cr[6].eq {
	pc = 0x829FF328; continue 'dispatch;
	}
	pc = 0x829FF2AC; continue 'dispatch;
            }
            0x829FF2AC => {
    //   block [0x829FF2AC..0x829FF2D0)
	// 829FF2AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF2B0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF2B4: 7F0AE800  cmpw cr6, r10, r29
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[29].s32, &mut ctx.xer);
	// 829FF2B8: 419A0018  beq cr6, 0x829ff2d0
	if ctx.cr[6].eq {
	pc = 0x829FF2D0; continue 'dispatch;
	}
	// 829FF2BC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829FF2C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FF2C4: 409AFFE8  bne cr6, 0x829ff2ac
	if !ctx.cr[6].eq {
	pc = 0x829FF2AC; continue 'dispatch;
	}
	// 829FF2C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FF2CC: 482AA190  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FF2D0 => {
    //   block [0x829FF2D0..0x829FF308)
	// 829FF2D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF2D4: 389E0024  addi r4, r30, 0x24
	ctx.r[4].s64 = ctx.r[30].s64 + 36;
	// 829FF2D8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829FF2DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FF2E0: 4E800421  bctrl
	ctx.lr = 0x829FF2E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FF2E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829FF2E8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 829FF2EC: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF2F0: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 829FF2F4: 4816B785  bl 0x82b6aa78
	ctx.lr = 0x829FF2F8;
	sub_82B6AA78(ctx, base);
	// 829FF2F8: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF2FC: 3BFEFFF8  addi r31, r30, -8
	ctx.r[31].s64 = ctx.r[30].s64 + -8;
	// 829FF300: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FF304: 419A0018  beq cr6, 0x829ff31c
	if ctx.cr[6].eq {
	pc = 0x829FF31C; continue 'dispatch;
	}
            }
            0x829FF308 => {
    //   block [0x829FF308..0x829FF31C)
	// 829FF308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF30C: 4B7B880D  bl 0x821b7b18
	ctx.lr = 0x829FF310;
	sub_821B7B18(ctx, base);
	// 829FF310: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829FF314: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FF318: 409AFFF0  bne cr6, 0x829ff308
	if !ctx.cr[6].eq {
	pc = 0x829FF308; continue 'dispatch;
	}
	pc = 0x829FF31C; continue 'dispatch;
            }
            0x829FF31C => {
    //   block [0x829FF31C..0x829FF328)
	// 829FF31C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF320: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 829FF324: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x829FF328; continue 'dispatch;
            }
            0x829FF328 => {
    //   block [0x829FF328..0x829FF330)
	// 829FF328: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FF32C: 482AA130  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF330 size=104
    let mut pc: u32 = 0x829FF330;
    'dispatch: loop {
        match pc {
            0x829FF330 => {
    //   block [0x829FF330..0x829FF350)
	// 829FF330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF334: 482AA0D9  bl 0x82ca940c
	ctx.lr = 0x829FF338;
	sub_82CA93D0(ctx, base);
	// 829FF338: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF33C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FF340: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF344: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF348: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FF34C: 419A0034  beq cr6, 0x829ff380
	if ctx.cr[6].eq {
	pc = 0x829FF380; continue 'dispatch;
	}
	pc = 0x829FF350; continue 'dispatch;
            }
            0x829FF350 => {
    //   block [0x829FF350..0x829FF380)
	// 829FF350: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FF358: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF35C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF360: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FF364: 4E800421  bctrl
	ctx.lr = 0x829FF368;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FF368: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 829FF36C: 419A0020  beq cr6, 0x829ff38c
	if ctx.cr[6].eq {
	pc = 0x829FF38C; continue 'dispatch;
	}
	// 829FF370: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF374: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829FF378: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FF37C: 409AFFD4  bne cr6, 0x829ff350
	if !ctx.cr[6].eq {
	pc = 0x829FF350; continue 'dispatch;
	}
            }
            0x829FF380 => {
    //   block [0x829FF380..0x829FF38C)
	// 829FF380: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FF384: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FF388: 482AA0D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FF38C => {
    //   block [0x829FF38C..0x829FF398)
	// 829FF38C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FF390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FF394: 482AA0C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF398 size=180
    let mut pc: u32 = 0x829FF398;
    'dispatch: loop {
        match pc {
            0x829FF398 => {
    //   block [0x829FF398..0x829FF3C0)
	// 829FF398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FF3A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF3A4: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF3A8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 829FF3AC: 38E00048  li r7, 0x48
	ctx.r[7].s64 = 72;
	// 829FF3B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FF3B4: 409A000C  bne cr6, 0x829ff3c0
	if !ctx.cr[6].eq {
	pc = 0x829FF3C0; continue 'dispatch;
	}
	// 829FF3B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829FF3BC: 48000010  b 0x829ff3cc
	pc = 0x829FF3CC; continue 'dispatch;
            }
            0x829FF3C0 => {
    //   block [0x829FF3C0..0x829FF3CC)
	// 829FF3C0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF3C4: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829FF3C8: 7D083BD6  divw r8, r8, r7
	ctx.r[8].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	pc = 0x829FF3CC; continue 'dispatch;
            }
            0x829FF3CC => {
    //   block [0x829FF3CC..0x829FF3F4)
	// 829FF3CC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF3D0: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829FF3D4: 7CE93BD6  divw r7, r9, r7
	ctx.r[7].s32 = ctx.r[9].s32 / ctx.r[7].s32;
	// 829FF3D8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829FF3DC: 40980044  bge cr6, 0x829ff420
	if !ctx.cr[6].lt {
	pc = 0x829FF420; continue 'dispatch;
	}
	// 829FF3E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FF3E4: 419A0024  beq cr6, 0x829ff408
	if ctx.cr[6].eq {
	pc = 0x829FF408; continue 'dispatch;
	}
	// 829FF3E8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 829FF3EC: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 829FF3F0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x829FF3F4; continue 'dispatch;
            }
            0x829FF3F4 => {
    //   block [0x829FF3F4..0x829FF408)
	// 829FF3F4: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 829FF3F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF3FC: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 829FF400: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 829FF404: 4200FFF0  bdnz 0x829ff3f4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF3F4; continue 'dispatch;
	}
	pc = 0x829FF408; continue 'dispatch;
            }
            0x829FF408 => {
    //   block [0x829FF408..0x829FF420)
	// 829FF408: 396B0048  addi r11, r11, 0x48
	ctx.r[11].s64 = ctx.r[11].s64 + 72;
	// 829FF40C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829FF410: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FF414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FF418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FF41C: 4E800020  blr
	return;
            }
            0x829FF420 => {
    //   block [0x829FF420..0x829FF44C)
	// 829FF420: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829FF424: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FF428: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 829FF42C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829FF430: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 829FF434: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FF438: 48000019  bl 0x829ff450
	ctx.lr = 0x829FF43C;
	sub_829FF450(ctx, base);
	// 829FF43C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FF440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FF444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FF448: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF450 size=976
    let mut pc: u32 = 0x829FF450;
    'dispatch: loop {
        match pc {
            0x829FF450 => {
    //   block [0x829FF450..0x829FF474)
	// 829FF450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF454: 482A9FB5  bl 0x82ca9408
	ctx.lr = 0x829FF458;
	sub_82CA93D0(ctx, base);
	// 829FF458: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF45C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FF460: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 829FF464: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829FF468: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829FF46C: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 829FF470: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x829FF474; continue 'dispatch;
            }
            0x829FF474 => {
    //   block [0x829FF474..0x829FF4A0)
	// 829FF474: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829FF478: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF47C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 829FF480: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF484: 4200FFF0  bdnz 0x829ff474
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF474; continue 'dispatch;
	}
	// 829FF488: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF48C: 3BE00048  li r31, 0x48
	ctx.r[31].s64 = 72;
	// 829FF490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FF494: 409A000C  bne cr6, 0x829ff4a0
	if !ctx.cr[6].eq {
	pc = 0x829FF4A0; continue 'dispatch;
	}
	// 829FF498: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829FF49C: 48000010  b 0x829ff4ac
	pc = 0x829FF4AC; continue 'dispatch;
            }
            0x829FF4A0 => {
    //   block [0x829FF4A0..0x829FF4AC)
	// 829FF4A0: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FF4A4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829FF4A8: 7D29FBD6  divw r9, r9, r31
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[31].s32;
	pc = 0x829FF4AC; continue 'dispatch;
            }
            0x829FF4AC => {
    //   block [0x829FF4AC..0x829FF4D8)
	// 829FF4AC: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF4B0: 3D40038E  lis r10, 0x38e
	ctx.r[10].s64 = 59637760;
	// 829FF4B4: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 829FF4B8: 614A38E3  ori r10, r10, 0x38e3
	ctx.r[10].u64 = ctx.r[10].u64 | 14563;
	// 829FF4BC: 7D68FBD6  divw r11, r8, r31
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[31].s32;
	// 829FF4C0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829FF4C4: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 829FF4C8: 40980010  bge cr6, 0x829ff4d8
	if !ctx.cr[6].lt {
	pc = 0x829FF4D8; continue 'dispatch;
	}
	// 829FF4CC: 48047FFD  bl 0x82a474c8
	ctx.lr = 0x829FF4D0;
	sub_82A474C8(ctx, base);
	// 829FF4D0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829FF4D4: 482A9F84  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FF4D8 => {
    //   block [0x829FF4D8..0x829FF4FC)
	// 829FF4D8: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 829FF4DC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829FF4E0: 40980160  bge cr6, 0x829ff640
	if !ctx.cr[6].lt {
	pc = 0x829FF640; continue 'dispatch;
	}
	// 829FF4E4: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FF4E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829FF4EC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829FF4F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829FF4F4: 41980008  blt cr6, 0x829ff4fc
	if ctx.cr[6].lt {
	pc = 0x829FF4FC; continue 'dispatch;
	}
	// 829FF4F8: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x829FF4FC; continue 'dispatch;
            }
            0x829FF4FC => {
    //   block [0x829FF4FC..0x829FF508)
	// 829FF4FC: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829FF500: 40980008  bge cr6, 0x829ff508
	if !ctx.cr[6].lt {
	pc = 0x829FF508; continue 'dispatch;
	}
	// 829FF504: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x829FF508; continue 'dispatch;
            }
            0x829FF508 => {
    //   block [0x829FF508..0x829FF52C)
	// 829FF508: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FF50C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FF510: 48000311  bl 0x829ff820
	ctx.lr = 0x829FF514;
	sub_829FF820(ctx, base);
	// 829FF514: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF518: 80C100DC  lwz r6, 0xdc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 829FF51C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FF520: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829FF524: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 829FF528: 419A0040  beq cr6, 0x829ff568
	if ctx.cr[6].eq {
	pc = 0x829FF568; continue 'dispatch;
	}
	pc = 0x829FF52C; continue 'dispatch;
            }
            0x829FF52C => {
    //   block [0x829FF52C..0x829FF544)
	// 829FF52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FF530: 419A0028  beq cr6, 0x829ff558
	if ctx.cr[6].eq {
	pc = 0x829FF558; continue 'dispatch;
	}
	// 829FF534: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 829FF538: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 829FF53C: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 829FF540: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x829FF544; continue 'dispatch;
            }
            0x829FF544 => {
    //   block [0x829FF544..0x829FF558)
	// 829FF544: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 829FF548: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF54C: F8E90000  std r7, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 829FF550: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 829FF554: 4200FFF0  bdnz 0x829ff544
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF544; continue 'dispatch;
	}
	pc = 0x829FF558; continue 'dispatch;
            }
            0x829FF558 => {
    //   block [0x829FF558..0x829FF568)
	// 829FF558: 39080048  addi r8, r8, 0x48
	ctx.r[8].s64 = ctx.r[8].s64 + 72;
	// 829FF55C: 396B0048  addi r11, r11, 0x48
	ctx.r[11].s64 = ctx.r[11].s64 + 72;
	// 829FF560: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829FF564: 409AFFC8  bne cr6, 0x829ff52c
	if !ctx.cr[6].eq {
	pc = 0x829FF52C; continue 'dispatch;
	}
	pc = 0x829FF568; continue 'dispatch;
            }
            0x829FF568 => {
    //   block [0x829FF568..0x829FF580)
	// 829FF568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FF56C: 419A0028  beq cr6, 0x829ff594
	if ctx.cr[6].eq {
	pc = 0x829FF594; continue 'dispatch;
	}
	// 829FF570: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829FF574: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 829FF578: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 829FF57C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x829FF580; continue 'dispatch;
            }
            0x829FF580 => {
    //   block [0x829FF580..0x829FF594)
	// 829FF580: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 829FF584: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF588: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 829FF58C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 829FF590: 4200FFF0  bdnz 0x829ff580
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF580; continue 'dispatch;
	}
	pc = 0x829FF594; continue 'dispatch;
            }
            0x829FF594 => {
    //   block [0x829FF594..0x829FF5B0)
	// 829FF594: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF598: 392B0048  addi r9, r11, 0x48
	ctx.r[9].s64 = ctx.r[11].s64 + 72;
	// 829FF59C: 7F062840  cmplw cr6, r6, r5
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[5].u32, &mut ctx.xer);
	// 829FF5A0: 419A004C  beq cr6, 0x829ff5ec
	if ctx.cr[6].eq {
	pc = 0x829FF5EC; continue 'dispatch;
	}
	// 829FF5A4: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 829FF5A8: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 829FF5AC: 390BFFB8  addi r8, r11, -0x48
	ctx.r[8].s64 = ctx.r[11].s64 + -72;
	pc = 0x829FF5B0; continue 'dispatch;
            }
            0x829FF5B0 => {
    //   block [0x829FF5B0..0x829FF5C8)
	// 829FF5B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FF5B4: 419A0028  beq cr6, 0x829ff5dc
	if ctx.cr[6].eq {
	pc = 0x829FF5DC; continue 'dispatch;
	}
	// 829FF5B8: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 829FF5BC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 829FF5C0: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 829FF5C4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x829FF5C8; continue 'dispatch;
            }
            0x829FF5C8 => {
    //   block [0x829FF5C8..0x829FF5DC)
	// 829FF5C8: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829FF5CC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF5D0: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 829FF5D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF5D8: 4200FFF0  bdnz 0x829ff5c8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF5C8; continue 'dispatch;
	}
	pc = 0x829FF5DC; continue 'dispatch;
            }
            0x829FF5DC => {
    //   block [0x829FF5DC..0x829FF5EC)
	// 829FF5DC: 39080048  addi r8, r8, 0x48
	ctx.r[8].s64 = ctx.r[8].s64 + 72;
	// 829FF5E0: 39290048  addi r9, r9, 0x48
	ctx.r[9].s64 = ctx.r[9].s64 + 72;
	// 829FF5E4: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 829FF5E8: 409AFFC8  bne cr6, 0x829ff5b0
	if !ctx.cr[6].eq {
	pc = 0x829FF5B0; continue 'dispatch;
	}
	pc = 0x829FF5EC; continue 'dispatch;
            }
            0x829FF5EC => {
    //   block [0x829FF5EC..0x829FF60C)
	// 829FF5EC: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF5F0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF5F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FF5F8: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 829FF5FC: 7D6AFBD6  divw r11, r10, r31
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[31].s32;
	// 829FF600: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 829FF604: 419A0008  beq cr6, 0x829ff60c
	if ctx.cr[6].eq {
	pc = 0x829FF60C; continue 'dispatch;
	}
	// 829FF608: 4B81C731  bl 0x8221bd38
	ctx.lr = 0x829FF60C;
	sub_8221BD38(ctx, base);
	pc = 0x829FF60C; continue 'dispatch;
            }
            0x829FF60C => {
    //   block [0x829FF60C..0x829FF640)
	// 829FF60C: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FF610: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829FF614: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829FF618: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 829FF61C: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 829FF620: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FF624: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829FF628: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 829FF62C: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 829FF630: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 829FF634: 911C000C  stw r8, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 829FF638: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829FF63C: 482A9E1C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FF640 => {
    //   block [0x829FF640..0x829FF664)
	// 829FF640: 808100DC  lwz r4, 0xdc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 829FF644: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 829FF648: 7D4BFBD6  divw r10, r11, r31
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[31].s32;
	// 829FF64C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829FF650: 409800F4  bge cr6, 0x829ff744
	if !ctx.cr[6].lt {
	pc = 0x829FF744; continue 'dispatch;
	}
	// 829FF654: 39040048  addi r8, r4, 0x48
	ctx.r[8].s64 = ctx.r[4].s64 + 72;
	// 829FF658: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 829FF65C: 419A0044  beq cr6, 0x829ff6a0
	if ctx.cr[6].eq {
	pc = 0x829FF6A0; continue 'dispatch;
	}
	// 829FF660: 38E8FFB8  addi r7, r8, -0x48
	ctx.r[7].s64 = ctx.r[8].s64 + -72;
	pc = 0x829FF664; continue 'dispatch;
            }
            0x829FF664 => {
    //   block [0x829FF664..0x829FF67C)
	// 829FF664: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829FF668: 419A0028  beq cr6, 0x829ff690
	if ctx.cr[6].eq {
	pc = 0x829FF690; continue 'dispatch;
	}
	// 829FF66C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 829FF670: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 829FF674: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 829FF678: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x829FF67C; continue 'dispatch;
            }
            0x829FF67C => {
    //   block [0x829FF67C..0x829FF690)
	// 829FF67C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829FF680: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF684: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 829FF688: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF68C: 4200FFF0  bdnz 0x829ff67c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF67C; continue 'dispatch;
	}
	pc = 0x829FF690; continue 'dispatch;
            }
            0x829FF690 => {
    //   block [0x829FF690..0x829FF6A0)
	// 829FF690: 38E70048  addi r7, r7, 0x48
	ctx.r[7].s64 = ctx.r[7].s64 + 72;
	// 829FF694: 39080048  addi r8, r8, 0x48
	ctx.r[8].s64 = ctx.r[8].s64 + 72;
	// 829FF698: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 829FF69C: 409AFFC8  bne cr6, 0x829ff664
	if !ctx.cr[6].eq {
	pc = 0x829FF664; continue 'dispatch;
	}
	pc = 0x829FF6A0; continue 'dispatch;
            }
            0x829FF6A0 => {
    //   block [0x829FF6A0..0x829FF6B8)
	// 829FF6A0: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF6A4: 7D644050  subf r11, r4, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 829FF6A8: 7D4BFBD6  divw r10, r11, r31
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[31].s32;
	// 829FF6AC: 20EA0001  subfic r7, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[7].s64 = (1 as i64) - ctx.r[10].s64;
	// 829FF6B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829FF6B4: 419A003C  beq cr6, 0x829ff6f0
	if ctx.cr[6].eq {
	pc = 0x829FF6F0; continue 'dispatch;
	}
	pc = 0x829FF6B8; continue 'dispatch;
            }
            0x829FF6B8 => {
    //   block [0x829FF6B8..0x829FF6D0)
	// 829FF6B8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829FF6BC: 419A0028  beq cr6, 0x829ff6e4
	if ctx.cr[6].eq {
	pc = 0x829FF6E4; continue 'dispatch;
	}
	// 829FF6C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829FF6C4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 829FF6C8: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 829FF6CC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x829FF6D0; continue 'dispatch;
            }
            0x829FF6D0 => {
    //   block [0x829FF6D0..0x829FF6E4)
	// 829FF6D0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829FF6D4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF6D8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 829FF6DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF6E0: 4200FFF0  bdnz 0x829ff6d0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF6D0; continue 'dispatch;
	}
	pc = 0x829FF6E4; continue 'dispatch;
            }
            0x829FF6E4 => {
    //   block [0x829FF6E4..0x829FF6F0)
	// 829FF6E4: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 829FF6E8: 39080048  addi r8, r8, 0x48
	ctx.r[8].s64 = ctx.r[8].s64 + 72;
	// 829FF6EC: 4082FFCC  bne 0x829ff6b8
	if !ctx.cr[0].eq {
	pc = 0x829FF6B8; continue 'dispatch;
	}
	pc = 0x829FF6F0; continue 'dispatch;
            }
            0x829FF6F0 => {
    //   block [0x829FF6F0..0x829FF70C)
	// 829FF6F0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF6F4: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 829FF6F8: 396B0048  addi r11, r11, 0x48
	ctx.r[11].s64 = ctx.r[11].s64 + 72;
	// 829FF6FC: 38EBFFB8  addi r7, r11, -0x48
	ctx.r[7].s64 = ctx.r[11].s64 + -72;
	// 829FF700: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829FF704: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 829FF708: 419A0110  beq cr6, 0x829ff818
	if ctx.cr[6].eq {
	pc = 0x829FF818; continue 'dispatch;
	}
	pc = 0x829FF70C; continue 'dispatch;
            }
            0x829FF70C => {
    //   block [0x829FF70C..0x829FF71C)
	// 829FF70C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829FF710: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 829FF714: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 829FF718: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x829FF71C; continue 'dispatch;
            }
            0x829FF71C => {
    //   block [0x829FF71C..0x829FF744)
	// 829FF71C: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829FF720: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF724: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 829FF728: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF72C: 4200FFF0  bdnz 0x829ff71c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF71C; continue 'dispatch;
	}
	// 829FF730: 39290048  addi r9, r9, 0x48
	ctx.r[9].s64 = ctx.r[9].s64 + 72;
	// 829FF734: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 829FF738: 409AFFD4  bne cr6, 0x829ff70c
	if !ctx.cr[6].eq {
	pc = 0x829FF70C; continue 'dispatch;
	}
	// 829FF73C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829FF740: 482A9D18  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FF744 => {
    //   block [0x829FF744..0x829FF758)
	// 829FF744: 3965FFB8  addi r11, r5, -0x48
	ctx.r[11].s64 = ctx.r[5].s64 + -72;
	// 829FF748: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 829FF74C: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 829FF750: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 829FF754: 419A0040  beq cr6, 0x829ff794
	if ctx.cr[6].eq {
	pc = 0x829FF794; continue 'dispatch;
	}
	pc = 0x829FF758; continue 'dispatch;
            }
            0x829FF758 => {
    //   block [0x829FF758..0x829FF770)
	// 829FF758: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829FF75C: 419A0028  beq cr6, 0x829ff784
	if ctx.cr[6].eq {
	pc = 0x829FF784; continue 'dispatch;
	}
	// 829FF760: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 829FF764: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 829FF768: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 829FF76C: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x829FF770; continue 'dispatch;
            }
            0x829FF770 => {
    //   block [0x829FF770..0x829FF784)
	// 829FF770: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 829FF774: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF778: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 829FF77C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 829FF780: 4200FFF0  bdnz 0x829ff770
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF770; continue 'dispatch;
	}
	pc = 0x829FF784; continue 'dispatch;
            }
            0x829FF784 => {
    //   block [0x829FF784..0x829FF794)
	// 829FF784: 38E70048  addi r7, r7, 0x48
	ctx.r[7].s64 = ctx.r[7].s64 + 72;
	// 829FF788: 39080048  addi r8, r8, 0x48
	ctx.r[8].s64 = ctx.r[8].s64 + 72;
	// 829FF78C: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 829FF790: 409AFFC8  bne cr6, 0x829ff758
	if !ctx.cr[6].eq {
	pc = 0x829FF758; continue 'dispatch;
	}
	pc = 0x829FF794; continue 'dispatch;
            }
            0x829FF794 => {
    //   block [0x829FF794..0x829FF7A4)
	// 829FF794: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 829FF798: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FF79C: 419A003C  beq cr6, 0x829ff7d8
	if ctx.cr[6].eq {
	pc = 0x829FF7D8; continue 'dispatch;
	}
	// 829FF7A0: 390B0048  addi r8, r11, 0x48
	ctx.r[8].s64 = ctx.r[11].s64 + 72;
	pc = 0x829FF7A4; continue 'dispatch;
            }
            0x829FF7A4 => {
    //   block [0x829FF7A4..0x829FF7BC)
	// 829FF7A4: 396BFFB8  addi r11, r11, -0x48
	ctx.r[11].s64 = ctx.r[11].s64 + -72;
	// 829FF7A8: 3908FFB8  addi r8, r8, -0x48
	ctx.r[8].s64 = ctx.r[8].s64 + -72;
	// 829FF7AC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 829FF7B0: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 829FF7B4: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 829FF7B8: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x829FF7BC; continue 'dispatch;
            }
            0x829FF7BC => {
    //   block [0x829FF7BC..0x829FF7D8)
	// 829FF7BC: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 829FF7C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF7C4: F8E90000  std r7, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 829FF7C8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 829FF7CC: 4200FFF0  bdnz 0x829ff7bc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF7BC; continue 'dispatch;
	}
	// 829FF7D0: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829FF7D4: 409AFFD0  bne cr6, 0x829ff7a4
	if !ctx.cr[6].eq {
	pc = 0x829FF7A4; continue 'dispatch;
	}
	pc = 0x829FF7D8; continue 'dispatch;
            }
            0x829FF7D8 => {
    //   block [0x829FF7D8..0x829FF7E8)
	// 829FF7D8: 38E40048  addi r7, r4, 0x48
	ctx.r[7].s64 = ctx.r[4].s64 + 72;
	// 829FF7DC: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 829FF7E0: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 829FF7E4: 419A0034  beq cr6, 0x829ff818
	if ctx.cr[6].eq {
	pc = 0x829FF818; continue 'dispatch;
	}
	pc = 0x829FF7E8; continue 'dispatch;
            }
            0x829FF7E8 => {
    //   block [0x829FF7E8..0x829FF7F8)
	// 829FF7E8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829FF7EC: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 829FF7F0: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 829FF7F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x829FF7F8; continue 'dispatch;
            }
            0x829FF7F8 => {
    //   block [0x829FF7F8..0x829FF818)
	// 829FF7F8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829FF7FC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829FF800: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 829FF804: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FF808: 4200FFF0  bdnz 0x829ff7f8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FF7F8; continue 'dispatch;
	}
	// 829FF80C: 39080048  addi r8, r8, 0x48
	ctx.r[8].s64 = ctx.r[8].s64 + 72;
	// 829FF810: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 829FF814: 409AFFD4  bne cr6, 0x829ff7e8
	if !ctx.cr[6].eq {
	pc = 0x829FF7E8; continue 'dispatch;
	}
	pc = 0x829FF818; continue 'dispatch;
            }
            0x829FF818 => {
    //   block [0x829FF818..0x829FF820)
	// 829FF818: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829FF81C: 482A9C3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF820 size=124
    let mut pc: u32 = 0x829FF820;
    'dispatch: loop {
        match pc {
            0x829FF820 => {
    //   block [0x829FF820..0x829FF878)
	// 829FF820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FF828: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FF82C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF830: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FF834: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FF838: 419A0040  beq cr6, 0x829ff878
	if ctx.cr[6].eq {
	pc = 0x829FF878; continue 'dispatch;
	}
	// 829FF83C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 829FF840: 0CDF0000  twi 6, r31, 0
	// 829FF844: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 829FF848: 2B0A0048  cmplwi cr6, r10, 0x48
	ctx.cr[6].compare_u32(ctx.r[10].u32, 72 as u32, &mut ctx.xer);
	// 829FF84C: 4098002C  bge cr6, 0x829ff878
	if !ctx.cr[6].lt {
	pc = 0x829FF878; continue 'dispatch;
	}
	// 829FF850: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF854: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829FF858: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 829FF85C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829FF860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF864: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 829FF868: 4B8F25B9  bl 0x822f1e20
	ctx.lr = 0x829FF86C;
	sub_822F1E20(ctx, base);
	// 829FF86C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829FF870: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 829FF874: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x829FF878; continue 'dispatch;
            }
            0x829FF878 => {
    //   block [0x829FF878..0x829FF89C)
	// 829FF878: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FF87C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 829FF880: 55631838  slwi r3, r11, 3
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 829FF884: 4B81F9D5  bl 0x8221f258
	ctx.lr = 0x829FF888;
	sub_8221F258(ctx, base);
	// 829FF888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FF88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FF890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FF894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FF898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF8A0 size=220
    let mut pc: u32 = 0x829FF8A0;
    'dispatch: loop {
        match pc {
            0x829FF8A0 => {
    //   block [0x829FF8A0..0x829FF8C4)
	// 829FF8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF8A4: 482A9B65  bl 0x82ca9408
	ctx.lr = 0x829FF8A8;
	sub_82CA93D0(ctx, base);
	// 829FF8A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF8AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FF8B0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF8B4: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FF8B8: 4199000C  bgt cr6, 0x829ff8c4
	if ctx.cr[6].gt {
	pc = 0x829FF8C4; continue 'dispatch;
	}
	// 829FF8BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829FF8C0: 409A00B4  bne cr6, 0x829ff974
	if !ctx.cr[6].eq {
	pc = 0x829FF974; continue 'dispatch;
	}
	pc = 0x829FF8C4; continue 'dispatch;
            }
            0x829FF8C4 => {
    //   block [0x829FF8C4..0x829FF8F4)
	// 829FF8C4: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 829FF8C8: 549C103A  slwi r28, r4, 2
	ctx.r[28].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 829FF8CC: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF8D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FF8D4: 4B81F985  bl 0x8221f258
	ctx.lr = 0x829FF8D8;
	sub_8221F258(ctx, base);
	// 829FF8D8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829FF8DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FF8E0: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 829FF8E4: 482AA0CD  bl 0x82ca99b0
	ctx.lr = 0x829FF8E8;
	sub_82CA99B0(ctx, base);
	// 829FF8E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829FF8EC: 419A0078  beq cr6, 0x829ff964
	if ctx.cr[6].eq {
	pc = 0x829FF964; continue 'dispatch;
	}
	// 829FF8F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	pc = 0x829FF8F4; continue 'dispatch;
            }
            0x829FF8F4 => {
    //   block [0x829FF8F4..0x829FF924)
	// 829FF8F4: 80C50000  lwz r6, 0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF8F8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 829FF8FC: 419A005C  beq cr6, 0x829ff958
	if ctx.cr[6].eq {
	pc = 0x829FF958; continue 'dispatch;
	}
	// 829FF900: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF904: 80E60000  lwz r7, 0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF908: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829FF90C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF910: 7D2A3838  and r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & ctx.r[7].u64;
	// 829FF914: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FF918: 7C8B402E  lwzx r4, r11, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 829FF91C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FF920: 419A0030  beq cr6, 0x829ff950
	if ctx.cr[6].eq {
	pc = 0x829FF950; continue 'dispatch;
	}
	pc = 0x829FF924; continue 'dispatch;
            }
            0x829FF924 => {
    //   block [0x829FF924..0x829FF950)
	// 829FF924: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 829FF928: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF92C: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 829FF930: 419A0020  beq cr6, 0x829ff950
	if ctx.cr[6].eq {
	pc = 0x829FF950; continue 'dispatch;
	}
	// 829FF934: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 829FF938: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF93C: 7D6A4838  and r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 829FF940: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FF944: 7C6B202E  lwzx r3, r11, r4
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 829FF948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FF94C: 409AFFD8  bne cr6, 0x829ff924
	if !ctx.cr[6].eq {
	pc = 0x829FF924; continue 'dispatch;
	}
	pc = 0x829FF950; continue 'dispatch;
            }
            0x829FF950 => {
    //   block [0x829FF950..0x829FF958)
	// 829FF950: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FF954: 7CCB412E  stwx r6, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[6].u32) };
	pc = 0x829FF958; continue 'dispatch;
            }
            0x829FF958 => {
    //   block [0x829FF958..0x829FF964)
	// 829FF958: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829FF95C: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 829FF960: 4082FF94  bne 0x829ff8f4
	if !ctx.cr[0].eq {
	pc = 0x829FF8F4; continue 'dispatch;
	}
	pc = 0x829FF964; continue 'dispatch;
            }
            0x829FF964 => {
    //   block [0x829FF964..0x829FF974)
	// 829FF964: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FF968: 419A000C  beq cr6, 0x829ff974
	if ctx.cr[6].eq {
	pc = 0x829FF974; continue 'dispatch;
	}
	// 829FF96C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FF970: 4B81C3C9  bl 0x8221bd38
	ctx.lr = 0x829FF974;
	sub_8221BD38(ctx, base);
	pc = 0x829FF974; continue 'dispatch;
            }
            0x829FF974 => {
    //   block [0x829FF974..0x829FF97C)
	// 829FF974: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FF978: 482A9AE0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FF980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FF980 size=256
    let mut pc: u32 = 0x829FF980;
    'dispatch: loop {
        match pc {
            0x829FF980 => {
    //   block [0x829FF980..0x829FF9CC)
	// 829FF980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FF984: 482A9A75  bl 0x82ca93f8
	ctx.lr = 0x829FF988;
	sub_82CA93D0(ctx, base);
	// 829FF988: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FF98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FF990: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 829FF994: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829FF998: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FF99C: 83D90000  lwz r30, 0(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF9A0: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 829FF9A4: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829FF9A8: 7D685396  divwu r11, r8, r10
	ctx.r[11].u32 = ctx.r[8].u32 / ctx.r[10].u32;
	// 829FF9AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FF9B0: 4099001C  ble cr6, 0x829ff9cc
	if !ctx.cr[6].gt {
	pc = 0x829FF9CC; continue 'dispatch;
	}
	// 829FF9B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829FF9B8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 829FF9BC: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829FF9C0: 2109001F  subfic r8, r9, 0x1f
	ctx.xer.ca = ctx.r[9].u32 <= 31 as u32;
	ctx.r[8].s64 = (31 as i64) - ctx.r[9].s64;
	// 829FF9C4: 7D5C4030  slw r28, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[28].u64 = 0;
	} else {
		ctx.r[28].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 829FF9C8: 48000008  b 0x829ff9d0
	pc = 0x829FF9D0; continue 'dispatch;
            }
            0x829FF9CC => {
    //   block [0x829FF9CC..0x829FF9D0)
	// 829FF9CC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x829FF9D0; continue 'dispatch;
            }
            0x829FF9D0 => {
    //   block [0x829FF9D0..0x829FFA20)
	// 829FF9D0: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FF9D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829FF9D8: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 829FF9DC: 40990078  ble cr6, 0x829ffa54
	if !ctx.cr[6].gt {
	pc = 0x829FFA54; continue 'dispatch;
	}
	// 829FF9E0: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FF9E4: 57981838  slwi r24, r28, 3
	ctx.r[24].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 829FF9E8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829FF9EC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 829FF9F0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829FF9F4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 829FF9F8: 4B81F861  bl 0x8221f258
	ctx.lr = 0x829FF9FC;
	sub_8221F258(ctx, base);
	// 829FF9FC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 829FFA00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FFA04: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 829FFA08: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 829FFA0C: 482A9FA5  bl 0x82ca99b0
	ctx.lr = 0x829FFA10;
	sub_82CA99B0(ctx, base);
	// 829FFA10: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 829FFA14: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 829FFA18: 419A002C  beq cr6, 0x829ffa44
	if ctx.cr[6].eq {
	pc = 0x829FFA44; continue 'dispatch;
	}
	// 829FFA1C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	pc = 0x829FFA20; continue 'dispatch;
            }
            0x829FFA20 => {
    //   block [0x829FFA20..0x829FFA38)
	// 829FFA20: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFA24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FFA28: 419A0010  beq cr6, 0x829ffa38
	if ctx.cr[6].eq {
	pc = 0x829FFA38; continue 'dispatch;
	}
	// 829FFA2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFA30: E89C0000  ld r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 829FFA34: 4800004D  bl 0x829ffa80
	ctx.lr = 0x829FFA38;
	sub_829FFA80(ctx, base);
	pc = 0x829FFA38; continue 'dispatch;
            }
            0x829FFA38 => {
    //   block [0x829FFA38..0x829FFA44)
	// 829FFA38: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 829FFA3C: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 829FFA40: 4082FFE0  bne 0x829ffa20
	if !ctx.cr[0].eq {
	pc = 0x829FFA20; continue 'dispatch;
	}
	pc = 0x829FFA44; continue 'dispatch;
            }
            0x829FFA44 => {
    //   block [0x829FFA44..0x829FFA54)
	// 829FFA44: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 829FFA48: 419A000C  beq cr6, 0x829ffa54
	if ctx.cr[6].eq {
	pc = 0x829FFA54; continue 'dispatch;
	}
	// 829FFA4C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829FFA50: 4B81C2E9  bl 0x8221bd38
	ctx.lr = 0x829FFA54;
	sub_8221BD38(ctx, base);
	pc = 0x829FFA54; continue 'dispatch;
            }
            0x829FFA54 => {
    //   block [0x829FFA54..0x829FFA5C)
	// 829FFA54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829FFA58: 419A0020  beq cr6, 0x829ffa78
	if ctx.cr[6].eq {
	pc = 0x829FFA78; continue 'dispatch;
	}
	pc = 0x829FFA5C; continue 'dispatch;
            }
            0x829FFA5C => {
    //   block [0x829FFA5C..0x829FFA78)
	// 829FFA5C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFA64: 7C9D582A  ldx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	// 829FFA68: 48000019  bl 0x829ffa80
	ctx.lr = 0x829FFA6C;
	sub_829FFA80(ctx, base);
	// 829FFA6C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829FFA70: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829FFA74: 4082FFE8  bne 0x829ffa5c
	if !ctx.cr[0].eq {
	pc = 0x829FFA5C; continue 'dispatch;
	}
	pc = 0x829FFA78; continue 'dispatch;
            }
            0x829FFA78 => {
    //   block [0x829FFA78..0x829FFA80)
	// 829FFA78: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829FFA7C: 482A99CC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FFA80 size=112
    let mut pc: u32 = 0x829FFA80;
    'dispatch: loop {
        match pc {
            0x829FFA80 => {
    //   block [0x829FFA80..0x829FFAA8)
	// 829FFA80: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFA84: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 829FFA88: 3968FFFF  addi r11, r8, -1
	ctx.r[11].s64 = ctx.r[8].s64 + -1;
	// 829FFA8C: 80E10018  lwz r7, 0x18(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FFA90: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFA94: 7D6B3838  and r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[7].u64;
	// 829FFA98: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829FFA9C: 7CC9502E  lwzx r6, r9, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829FFAA0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 829FFAA4: 419A0034  beq cr6, 0x829ffad8
	if ctx.cr[6].eq {
	pc = 0x829FFAD8; continue 'dispatch;
	}
	pc = 0x829FFAA8; continue 'dispatch;
            }
            0x829FFAA8 => {
    //   block [0x829FFAA8..0x829FFAC4)
	// 829FFAA8: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829FFAAC: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 829FFAB0: 419A0028  beq cr6, 0x829ffad8
	if ctx.cr[6].eq {
	pc = 0x829FFAD8; continue 'dispatch;
	}
	// 829FFAB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FFAB8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829FFABC: 409A0008  bne cr6, 0x829ffac4
	if !ctx.cr[6].eq {
	pc = 0x829FFAC4; continue 'dispatch;
	}
	// 829FFAC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829FFAC4; continue 'dispatch;
            }
            0x829FFAC4 => {
    //   block [0x829FFAC4..0x829FFAD8)
	// 829FFAC4: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFAC8: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829FFACC: 7CAA302E  lwzx r5, r10, r6
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 829FFAD0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 829FFAD4: 409AFFD4  bne cr6, 0x829ffaa8
	if !ctx.cr[6].eq {
	pc = 0x829FFAA8; continue 'dispatch;
	}
	pc = 0x829FFAD8; continue 'dispatch;
            }
            0x829FFAD8 => {
    //   block [0x829FFAD8..0x829FFAF0)
	// 829FFAD8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FFADC: 7C8B492A  stdx r4, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[4].u64) };
	// 829FFAE0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FFAE4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 829FFAE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829FFAEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FFAF0 size=264
    let mut pc: u32 = 0x829FFAF0;
    'dispatch: loop {
        match pc {
            0x829FFAF0 => {
    //   block [0x829FFAF0..0x829FFB20)
	// 829FFAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFAF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FFAF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FFAFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FFB00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFB04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FFB08: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFB0C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFB10: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FFB14: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFB18: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 829FFB1C: EBE10050  ld r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	pc = 0x829FFB20; continue 'dispatch;
            }
            0x829FFB20 => {
    //   block [0x829FFB20..0x829FFB38)
	// 829FFB20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFB24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FFB28: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFB2C: 419A000C  beq cr6, 0x829ffb38
	if ctx.cr[6].eq {
	pc = 0x829FFB38; continue 'dispatch;
	}
	// 829FFB30: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FFB34: 419A0008  beq cr6, 0x829ffb3c
	if ctx.cr[6].eq {
	pc = 0x829FFB3C; continue 'dispatch;
	}
	pc = 0x829FFB38; continue 'dispatch;
            }
            0x829FFB38 => {
    //   block [0x829FFB38..0x829FFB3C)
	// 829FFB38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFB3C; continue 'dispatch;
            }
            0x829FFB3C => {
    //   block [0x829FFB3C..0x829FFB50)
	// 829FFB3C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829FFB40: 419A0064  beq cr6, 0x829ffba4
	if ctx.cr[6].eq {
	pc = 0x829FFBA4; continue 'dispatch;
	}
	// 829FFB44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FFB48: 409A0008  bne cr6, 0x829ffb50
	if !ctx.cr[6].eq {
	pc = 0x829FFB50; continue 'dispatch;
	}
	// 829FFB4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFB50; continue 'dispatch;
            }
            0x829FFB50 => {
    //   block [0x829FFB50..0x829FFB60)
	// 829FFB50: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFB54: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FFB58: 409A0008  bne cr6, 0x829ffb60
	if !ctx.cr[6].eq {
	pc = 0x829FFB60; continue 'dispatch;
	}
	// 829FFB5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFB60; continue 'dispatch;
            }
            0x829FFB60 => {
    //   block [0x829FFB60..0x829FFB78)
	// 829FFB60: 80680008  lwz r3, 8(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FFB64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFB68: 419A0018  beq cr6, 0x829ffb80
	if ctx.cr[6].eq {
	pc = 0x829FFB80; continue 'dispatch;
	}
	// 829FFB6C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FFB70: 409A0008  bne cr6, 0x829ffb78
	if !ctx.cr[6].eq {
	pc = 0x829FFB78; continue 'dispatch;
	}
	// 829FFB74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFB78; continue 'dispatch;
            }
            0x829FFB78 => {
    //   block [0x829FFB78..0x829FFB80)
	// 829FFB78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FFB7C: 4800007D  bl 0x829ffbf8
	ctx.lr = 0x829FFB80;
	sub_829FFBF8(ctx, base);
	pc = 0x829FFB80; continue 'dispatch;
            }
            0x829FFB80 => {
    //   block [0x829FFB80..0x829FFBA4)
	// 829FFB80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829FFB84: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFB88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FFB8C: 4B7DA35D  bl 0x821d9ee8
	ctx.lr = 0x829FFB90;
	sub_821D9EE8(ctx, base);
	// 829FFB90: EBE30000  ld r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829FFB94: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 829FFB98: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FFB9C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FFBA0: 4BFFFF80  b 0x829ffb20
	pc = 0x829FFB20; continue 'dispatch;
            }
            0x829FFBA4 => {
    //   block [0x829FFBA4..0x829FFBC0)
	// 829FFBA4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFBA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FFBAC: 419A002C  beq cr6, 0x829ffbd8
	if ctx.cr[6].eq {
	pc = 0x829FFBD8; continue 'dispatch;
	}
	// 829FFBB0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FFBB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFBB8: 419A0008  beq cr6, 0x829ffbc0
	if ctx.cr[6].eq {
	pc = 0x829FFBC0; continue 'dispatch;
	}
	// 829FFBBC: 4B81C17D  bl 0x8221bd38
	ctx.lr = 0x829FFBC0;
	sub_8221BD38(ctx, base);
	pc = 0x829FFBC0; continue 'dispatch;
            }
            0x829FFBC0 => {
    //   block [0x829FFBC0..0x829FFBD8)
	// 829FFBC0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 829FFBC4: 48001945  bl 0x82a01508
	ctx.lr = 0x829FFBC8;
	sub_82A01508(ctx, base);
	// 829FFBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFBCC: 4BC3AABD  bl 0x8263a688
	ctx.lr = 0x829FFBD0;
	sub_8263A688(ctx, base);
	// 829FFBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFBD4: 4B81C165  bl 0x8221bd38
	ctx.lr = 0x829FFBD8;
	sub_8221BD38(ctx, base);
	pc = 0x829FFBD8; continue 'dispatch;
            }
            0x829FFBD8 => {
    //   block [0x829FFBD8..0x829FFBF8)
	// 829FFBD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FFBDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FFBE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FFBE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FFBE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FFBEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FFBF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FFBF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FFBF8 size=152
    let mut pc: u32 = 0x829FFBF8;
    'dispatch: loop {
        match pc {
            0x829FFBF8 => {
    //   block [0x829FFBF8..0x829FFC48)
	// 829FFBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFBFC: 482A980D  bl 0x82ca9408
	ctx.lr = 0x829FFC00;
	sub_82CA93D0(ctx, base);
	// 829FFC00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFC04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FFC08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829FFC0C: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFC10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FFC14: 419A0064  beq cr6, 0x829ffc78
	if ctx.cr[6].eq {
	pc = 0x829FFC78; continue 'dispatch;
	}
	// 829FFC18: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 829FFC1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FFC20: 419A0028  beq cr6, 0x829ffc48
	if ctx.cr[6].eq {
	pc = 0x829FFC48; continue 'dispatch;
	}
	// 829FFC24: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FFC28: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829FFC2C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 829FFC30: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 829FFC34: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 829FFC38: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 829FFC3C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 829FFC40: 4B81C0F9  bl 0x8221bd38
	ctx.lr = 0x829FFC44;
	sub_8221BD38(ctx, base);
	// 829FFC44: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	pc = 0x829FFC48; continue 'dispatch;
            }
            0x829FFC48 => {
    //   block [0x829FFC48..0x829FFC60)
	// 829FFC48: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 829FFC4C: 3BBF0024  addi r29, r31, 0x24
	ctx.r[29].s64 = ctx.r[31].s64 + 36;
	// 829FFC50: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 829FFC54: 4198000C  blt cr6, 0x829ffc60
	if ctx.cr[6].lt {
	pc = 0x829FFC60; continue 'dispatch;
	}
	// 829FFC58: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFC5C: 4B81C0DD  bl 0x8221bd38
	ctx.lr = 0x829FFC60;
	sub_8221BD38(ctx, base);
	pc = 0x829FFC60; continue 'dispatch;
            }
            0x829FFC60 => {
    //   block [0x829FFC60..0x829FFC78)
	// 829FFC60: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 829FFC64: 93DD0014  stw r30, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 829FFC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFC6C: 917D0018  stw r11, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829FFC70: 9BDD0004  stb r30, 4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 829FFC74: 4B81C0C5  bl 0x8221bd38
	ctx.lr = 0x829FFC78;
	sub_8221BD38(ctx, base);
	pc = 0x829FFC78; continue 'dispatch;
            }
            0x829FFC78 => {
    //   block [0x829FFC78..0x829FFC90)
	// 829FFC78: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FFC7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FFC80: 4B81C0B9  bl 0x8221bd38
	ctx.lr = 0x829FFC84;
	sub_8221BD38(ctx, base);
	// 829FFC84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FFC88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FFC8C: 482A97CC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FFC90 size=216
    let mut pc: u32 = 0x829FFC90;
    'dispatch: loop {
        match pc {
            0x829FFC90 => {
    //   block [0x829FFC90..0x829FFCD8)
	// 829FFC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFC94: 482A9779  bl 0x82ca940c
	ctx.lr = 0x829FFC98;
	sub_82CA93D0(ctx, base);
	// 829FFC98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFC9C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 829FFCA0: 4B81F5B9  bl 0x8221f258
	ctx.lr = 0x829FFCA4;
	sub_8221F258(ctx, base);
	// 829FFCA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FFCA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FFCAC: 419A00A8  beq cr6, 0x829ffd54
	if ctx.cr[6].eq {
	pc = 0x829FFD54; continue 'dispatch;
	}
	// 829FFCB0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829FFCB4: 4B81F5A5  bl 0x8221f258
	ctx.lr = 0x829FFCB8;
	sub_8221F258(ctx, base);
	// 829FFCB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FFCBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FFCC0: 419A0078  beq cr6, 0x829ffd38
	if ctx.cr[6].eq {
	pc = 0x829FFD38; continue 'dispatch;
	}
	// 829FFCC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829FFCC8: 4B81F591  bl 0x8221f258
	ctx.lr = 0x829FFCCC;
	sub_8221F258(ctx, base);
	// 829FFCCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFCD0: 419A0008  beq cr6, 0x829ffcd8
	if ctx.cr[6].eq {
	pc = 0x829FFCD8; continue 'dispatch;
	}
	// 829FFCD4: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x829FFCD8; continue 'dispatch;
            }
            0x829FFCD8 => {
    //   block [0x829FFCD8..0x829FFCE4)
	// 829FFCD8: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FFCDC: 41820008  beq 0x829ffce4
	if ctx.cr[0].eq {
	pc = 0x829FFCE4; continue 'dispatch;
	}
	// 829FFCE0: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x829FFCE4; continue 'dispatch;
            }
            0x829FFCE4 => {
    //   block [0x829FFCE4..0x829FFD38)
	// 829FFCE4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829FFCE8: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 829FFCEC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 829FFCF0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 829FFCF4: 48001795  bl 0x82a01488
	ctx.lr = 0x829FFCF8;
	sub_82A01488(ctx, base);
	// 829FFCF8: 3C600020  lis r3, 0x20
	ctx.r[3].s64 = 2097152;
	// 829FFCFC: 4B81F55D  bl 0x8221f258
	ctx.lr = 0x829FFD00;
	sub_8221F258(ctx, base);
	// 829FFD00: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 829FFD04: 3CA00020  lis r5, 0x20
	ctx.r[5].s64 = 2097152;
	// 829FFD08: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 829FFD0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FFD10: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 829FFD14: 482A9C9D  bl 0x82ca99b0
	ctx.lr = 0x829FFD18;
	sub_82CA99B0(ctx, base);
	// 829FFD18: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 829FFD1C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 829FFD20: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 829FFD24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FFD28: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FFD2C: 93AA6DA0  stw r29, 0x6da0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28064 as u32), ctx.r[29].u32 ) };
	// 829FFD30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FFD34: 482A9728  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FFD38 => {
    //   block [0x829FFD38..0x829FFD54)
	// 829FFD38: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 829FFD3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FFD40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FFD44: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FFD48: 93AA6DA0  stw r29, 0x6da0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28064 as u32), ctx.r[29].u32 ) };
	// 829FFD4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FFD50: 482A970C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FFD54 => {
    //   block [0x829FFD54..0x829FFD68)
	// 829FFD54: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829FFD58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FFD5C: 906B6DA0  stw r3, 0x6da0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28064 as u32), ctx.r[3].u32 ) };
	// 829FFD60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FFD64: 482A96F8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FFD68 size=240
    let mut pc: u32 = 0x829FFD68;
    'dispatch: loop {
        match pc {
            0x829FFD68 => {
    //   block [0x829FFD68..0x829FFDA0)
	// 829FFD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFD6C: 482A96A1  bl 0x82ca940c
	ctx.lr = 0x829FFD70;
	sub_82CA93D0(ctx, base);
	// 829FFD70: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFD74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FFD78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FFD7C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829FFD80: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFD84: 4800024D  bl 0x829fffd0
	ctx.lr = 0x829FFD88;
	sub_829FFFD0(ctx, base);
	// 829FFD88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FFD8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FFD90: 409A0010  bne cr6, 0x829ffda0
	if !ctx.cr[6].eq {
	pc = 0x829FFDA0; continue 'dispatch;
	}
	// 829FFD94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FFD98: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829FFD9C: 482A96C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FFDA0 => {
    //   block [0x829FFDA0..0x829FFDD4)
	// 829FFDA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FFDA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FFDA8: 4B8F2199  bl 0x822f1f40
	ctx.lr = 0x829FFDAC;
	sub_822F1F40(ctx, base);
	// 829FFDAC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FFDB0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 829FFDB4: 388B2130  addi r4, r11, 0x2130
	ctx.r[4].s64 = ctx.r[11].s64 + 8496;
	// 829FFDB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FFDBC: 4B7A17E5  bl 0x821a15a0
	ctx.lr = 0x829FFDC0;
	sub_821A15A0(ctx, base);
	// 829FFDC0: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 829FFDC4: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829FFDC8: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 829FFDCC: 40980008  bge cr6, 0x829ffdd4
	if !ctx.cr[6].lt {
	pc = 0x829FFDD4; continue 'dispatch;
	}
	// 829FFDD0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	pc = 0x829FFDD4; continue 'dispatch;
            }
            0x829FFDD4 => {
    //   block [0x829FFDD4..0x829FFE38)
	// 829FFDD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FFDD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FFDDC: 4B82D0F5  bl 0x8222ced0
	ctx.lr = 0x829FFDE0;
	sub_8222CED0(ctx, base);
	// 829FFDE0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 829FFDE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829FFDE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FFDEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FFDF0: 4826FA21  bl 0x82c6f810
	ctx.lr = 0x829FFDF4;
	sub_82C6F810(ctx, base);
	// 829FFDF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFDF8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 829FFDFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FFE00: 4E800421  bctrl
	ctx.lr = 0x829FFE04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FFE04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FFE08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FFE0C: 4826E63D  bl 0x82c6e448
	ctx.lr = 0x829FFE10;
	sub_82C6E448(ctx, base);
	// 829FFE10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FFE14: 4B814FC5  bl 0x82214dd8
	ctx.lr = 0x829FFE18;
	sub_82214DD8(ctx, base);
	// 829FFE18: 57E9063E  clrlwi r9, r31, 0x18
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 829FFE1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FFE20: 419A0024  beq cr6, 0x829ffe44
	if ctx.cr[6].eq {
	pc = 0x829FFE44; continue 'dispatch;
	}
	// 829FFE24: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 829FFE28: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829FFE2C: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 829FFE30: 40980008  bge cr6, 0x829ffe38
	if !ctx.cr[6].lt {
	pc = 0x829FFE38; continue 'dispatch;
	}
	// 829FFE34: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
            }
            0x829FFE38 => {
    //   block [0x829FFE38..0x829FFE44)
	// 829FFE38: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829FFE3C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFE40: 48000191  bl 0x829fffd0
	ctx.lr = 0x829FFE44;
	sub_829FFFD0(ctx, base);
	pc = 0x829FFE44; continue 'dispatch;
            }
            0x829FFE44 => {
    //   block [0x829FFE44..0x829FFE58)
	// 829FFE44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FFE48: 4B7719C9  bl 0x82171810
	ctx.lr = 0x829FFE4C;
	sub_82171810(ctx, base);
	// 829FFE4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FFE50: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829FFE54: 482A9608  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FFE58 size=180
    let mut pc: u32 = 0x829FFE58;
    'dispatch: loop {
        match pc {
            0x829FFE58 => {
    //   block [0x829FFE58..0x829FFE90)
	// 829FFE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFE5C: 482A95A5  bl 0x82ca9400
	ctx.lr = 0x829FFE60;
	sub_82CA93D0(ctx, base);
	// 829FFE60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFE64: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFE68: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829FFE6C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFE70: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829FFE74: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 829FFE78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFE7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829FFE80: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FFE84: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 829FFE88: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FFE8C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x829FFE90; continue 'dispatch;
            }
            0x829FFE90 => {
    //   block [0x829FFE90..0x829FFEA0)
	// 829FFE90: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FFE94: 419A000C  beq cr6, 0x829ffea0
	if ctx.cr[6].eq {
	pc = 0x829FFEA0; continue 'dispatch;
	}
	// 829FFE98: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 829FFE9C: 419A0008  beq cr6, 0x829ffea4
	if ctx.cr[6].eq {
	pc = 0x829FFEA4; continue 'dispatch;
	}
	pc = 0x829FFEA0; continue 'dispatch;
            }
            0x829FFEA0 => {
    //   block [0x829FFEA0..0x829FFEA4)
	// 829FFEA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFEA4; continue 'dispatch;
            }
            0x829FFEA4 => {
    //   block [0x829FFEA4..0x829FFEB8)
	// 829FFEA4: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 829FFEA8: 419A0058  beq cr6, 0x829fff00
	if ctx.cr[6].eq {
	pc = 0x829FFF00; continue 'dispatch;
	}
	// 829FFEAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FFEB0: 409A0008  bne cr6, 0x829ffeb8
	if !ctx.cr[6].eq {
	pc = 0x829FFEB8; continue 'dispatch;
	}
	// 829FFEB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFEB8; continue 'dispatch;
            }
            0x829FFEB8 => {
    //   block [0x829FFEB8..0x829FFEC8)
	// 829FFEB8: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFEBC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FFEC0: 409A0008  bne cr6, 0x829ffec8
	if !ctx.cr[6].eq {
	pc = 0x829FFEC8; continue 'dispatch;
	}
	// 829FFEC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFEC8; continue 'dispatch;
            }
            0x829FFEC8 => {
    //   block [0x829FFEC8..0x829FFEF8)
	// 829FFEC8: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FFECC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829FFED0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 829FFED4: 4B8CD6C5  bl 0x822cd598
	ctx.lr = 0x829FFED8;
	sub_822CD598(ctx, base);
	// 829FFED8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FFEDC: 80650000  lwz r3, 0(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFEE0: 48001719  bl 0x82a015f8
	ctx.lr = 0x829FFEE4;
	sub_82A015F8(ctx, base);
	// 829FFEE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFEE8: 409A001C  bne cr6, 0x829fff04
	if !ctx.cr[6].eq {
	pc = 0x829FFF04; continue 'dispatch;
	}
	// 829FFEEC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FFEF0: 409A0008  bne cr6, 0x829ffef8
	if !ctx.cr[6].eq {
	pc = 0x829FFEF8; continue 'dispatch;
	}
	// 829FFEF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFEF8; continue 'dispatch;
            }
            0x829FFEF8 => {
    //   block [0x829FFEF8..0x829FFF00)
	// 829FFEF8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFEFC: 4BFFFF94  b 0x829ffe90
	pc = 0x829FFE90; continue 'dispatch;
            }
            0x829FFF00 => {
    //   block [0x829FFF00..0x829FFF04)
	// 829FFF00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829FFF04; continue 'dispatch;
            }
            0x829FFF04 => {
    //   block [0x829FFF04..0x829FFF0C)
	// 829FFF04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FFF08: 482A9548  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FFF10 size=192
    let mut pc: u32 = 0x829FFF10;
    'dispatch: loop {
        match pc {
            0x829FFF10 => {
    //   block [0x829FFF10..0x829FFF48)
	// 829FFF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFF14: 482A94ED  bl 0x82ca9400
	ctx.lr = 0x829FFF18;
	sub_82CA93D0(ctx, base);
	// 829FFF18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFF1C: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFF20: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829FFF24: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFF28: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829FFF2C: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 829FFF30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFF34: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829FFF38: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FFF3C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 829FFF40: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FFF44: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x829FFF48; continue 'dispatch;
            }
            0x829FFF48 => {
    //   block [0x829FFF48..0x829FFF58)
	// 829FFF48: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FFF4C: 419A000C  beq cr6, 0x829fff58
	if ctx.cr[6].eq {
	pc = 0x829FFF58; continue 'dispatch;
	}
	// 829FFF50: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 829FFF54: 419A0008  beq cr6, 0x829fff5c
	if ctx.cr[6].eq {
	pc = 0x829FFF5C; continue 'dispatch;
	}
	pc = 0x829FFF58; continue 'dispatch;
            }
            0x829FFF58 => {
    //   block [0x829FFF58..0x829FFF5C)
	// 829FFF58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFF5C; continue 'dispatch;
            }
            0x829FFF5C => {
    //   block [0x829FFF5C..0x829FFF70)
	// 829FFF5C: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 829FFF60: 419A0064  beq cr6, 0x829fffc4
	if ctx.cr[6].eq {
	pc = 0x829FFFC4; continue 'dispatch;
	}
	// 829FFF64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FFF68: 409A0008  bne cr6, 0x829fff70
	if !ctx.cr[6].eq {
	pc = 0x829FFF70; continue 'dispatch;
	}
	// 829FFF6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFF70; continue 'dispatch;
            }
            0x829FFF70 => {
    //   block [0x829FFF70..0x829FFF80)
	// 829FFF70: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFF74: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FFF78: 409A0008  bne cr6, 0x829fff80
	if !ctx.cr[6].eq {
	pc = 0x829FFF80; continue 'dispatch;
	}
	// 829FFF7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFF80; continue 'dispatch;
            }
            0x829FFF80 => {
    //   block [0x829FFF80..0x829FFF98)
	// 829FFF80: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FFF84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FFF88: 409A0028  bne cr6, 0x829fffb0
	if !ctx.cr[6].eq {
	pc = 0x829FFFB0; continue 'dispatch;
	}
	// 829FFF8C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FFF90: 409A0008  bne cr6, 0x829fff98
	if !ctx.cr[6].eq {
	pc = 0x829FFF98; continue 'dispatch;
	}
	// 829FFF94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFF98; continue 'dispatch;
            }
            0x829FFF98 => {
    //   block [0x829FFF98..0x829FFFB0)
	// 829FFF98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FFF9C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829FFFA0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFFA4: 48001655  bl 0x82a015f8
	ctx.lr = 0x829FFFA8;
	sub_82A015F8(ctx, base);
	// 829FFFA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFFAC: 409A001C  bne cr6, 0x829fffc8
	if !ctx.cr[6].eq {
	pc = 0x829FFFC8; continue 'dispatch;
	}
	pc = 0x829FFFB0; continue 'dispatch;
            }
            0x829FFFB0 => {
    //   block [0x829FFFB0..0x829FFFBC)
	// 829FFFB0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829FFFB4: 409A0008  bne cr6, 0x829fffbc
	if !ctx.cr[6].eq {
	pc = 0x829FFFBC; continue 'dispatch;
	}
	// 829FFFB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829FFFBC; continue 'dispatch;
            }
            0x829FFFBC => {
    //   block [0x829FFFBC..0x829FFFC4)
	// 829FFFBC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFFC0: 4BFFFF88  b 0x829fff48
	pc = 0x829FFF48; continue 'dispatch;
            }
            0x829FFFC4 => {
    //   block [0x829FFFC4..0x829FFFC8)
	// 829FFFC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829FFFC8; continue 'dispatch;
            }
            0x829FFFC8 => {
    //   block [0x829FFFC8..0x829FFFD0)
	// 829FFFC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FFFCC: 482A9484  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FFFD0 size=268
    let mut pc: u32 = 0x829FFFD0;
    'dispatch: loop {
        match pc {
            0x829FFFD0 => {
    //   block [0x829FFFD0..0x82A00028)
	// 829FFFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFFD4: 482A9429  bl 0x82ca93fc
	ctx.lr = 0x829FFFD8;
	sub_82CA93D0(ctx, base);
	// 829FFFD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFFDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FFFE0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 829FFFE4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829FFFE8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 829FFFEC: 4B81F26D  bl 0x8221f258
	ctx.lr = 0x829FFFF0;
	sub_8221F258(ctx, base);
	// 829FFFF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829FFFF4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 829FFFF8: 419A0084  beq cr6, 0x82a0007c
	if ctx.cr[6].eq {
	pc = 0x82A0007C; continue 'dispatch;
	}
	// 829FFFFC: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82A00000: 3BBC000C  addi r29, r28, 0xc
	ctx.r[29].s64 = ctx.r[28].s64 + 12;
	// 82A00004: 4B81F255  bl 0x8221f258
	ctx.lr = 0x82A00008;
	sub_8221F258(ctx, base);
	// 82A00008: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0000C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A00010: 419A005C  beq cr6, 0x82a0006c
	if ctx.cr[6].eq {
	pc = 0x82A0006C; continue 'dispatch;
	}
	// 82A00014: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A00018: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0001C: 419A000C  beq cr6, 0x82a00028
	if ctx.cr[6].eq {
	pc = 0x82A00028; continue 'dispatch;
	}
	// 82A00020: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00024: 48000020  b 0x82a00044
	pc = 0x82A00044; continue 'dispatch;
            }
            0x82A00028 => {
    //   block [0x82A00028..0x82A00040)
	// 82A00028: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82A0002C: 4B81F22D  bl 0x8221f258
	ctx.lr = 0x82A00030;
	sub_8221F258(ctx, base);
	// 82A00030: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00034: 419A000C  beq cr6, 0x82a00040
	if ctx.cr[6].eq {
	pc = 0x82A00040; continue 'dispatch;
	}
	// 82A00038: 48001451  bl 0x82a01488
	ctx.lr = 0x82A0003C;
	sub_82A01488(ctx, base);
	// 82A0003C: 48000008  b 0x82a00044
	pc = 0x82A00044; continue 'dispatch;
            }
            0x82A00040 => {
    //   block [0x82A00040..0x82A00044)
	// 82A00040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82A00044; continue 'dispatch;
            }
            0x82A00044 => {
    //   block [0x82A00044..0x82A0006C)
	// 82A00044: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 82A00048: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82A0004C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A00050: 397F0024  addi r11, r31, 0x24
	ctx.r[11].s64 = ctx.r[31].s64 + 36;
	// 82A00054: 915F003C  stw r10, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 82A00058: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82A0005C: 9BDF0028  stb r30, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82A00060: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A00064: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A00068: 48000018  b 0x82a00080
	pc = 0x82A00080; continue 'dispatch;
            }
            0x82A0006C => {
    //   block [0x82A0006C..0x82A0007C)
	// 82A0006C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A00070: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A00074: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A00078: 48000008  b 0x82a00080
	pc = 0x82A00080; continue 'dispatch;
            }
            0x82A0007C => {
    //   block [0x82A0007C..0x82A00080)
	// 82A0007C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82A00080; continue 'dispatch;
            }
            0x82A00080 => {
    //   block [0x82A00080..0x82A000D0)
	// 82A00080: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A00084: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00088: 48001639  bl 0x82a016c0
	ctx.lr = 0x82A0008C;
	sub_82A016C0(ctx, base);
	// 82A0008C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A00090: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82A00094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A00098: 419A0038  beq cr6, 0x82a000d0
	if ctx.cr[6].eq {
	pc = 0x82A000D0; continue 'dispatch;
	}
	// 82A0009C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A000A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A000A4: 480001DD  bl 0x82a00280
	ctx.lr = 0x82A000A8;
	sub_82A00280(ctx, base);
	// 82A000A8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A000AC: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82A000B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A000B4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A000B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A000BC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82A000C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A000C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A000C8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A000CC: 4BC83AD5  bl 0x82683ba0
	ctx.lr = 0x82A000D0;
	sub_82683BA0(ctx, base);
	pc = 0x82A000D0; continue 'dispatch;
            }
            0x82A000D0 => {
    //   block [0x82A000D0..0x82A000DC)
	// 82A000D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A000D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A000D8: 482A9374  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A000E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A000E0 size=416
    let mut pc: u32 = 0x82A000E0;
    'dispatch: loop {
        match pc {
            0x82A000E0 => {
    //   block [0x82A000E0..0x82A00108)
	// 82A000E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A000E4: 482A9325  bl 0x82ca9408
	ctx.lr = 0x82A000E8;
	sub_82CA93D0(ctx, base);
	// 82A000E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A000EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A000F0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A000F4: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82A000F8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A000FC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82A00100: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A00104: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A00108; continue 'dispatch;
            }
            0x82A00108 => {
    //   block [0x82A00108..0x82A00110)
	// 82A00108: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0010C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82A00110; continue 'dispatch;
            }
            0x82A00110 => {
    //   block [0x82A00110..0x82A00124)
	// 82A00110: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00114: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A00118: 419A000C  beq cr6, 0x82a00124
	if ctx.cr[6].eq {
	pc = 0x82A00124; continue 'dispatch;
	}
	// 82A0011C: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A00120: 419A0008  beq cr6, 0x82a00128
	if ctx.cr[6].eq {
	pc = 0x82A00128; continue 'dispatch;
	}
	pc = 0x82A00124; continue 'dispatch;
            }
            0x82A00124 => {
    //   block [0x82A00124..0x82A00128)
	// 82A00124: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A00128; continue 'dispatch;
            }
            0x82A00128 => {
    //   block [0x82A00128..0x82A0013C)
	// 82A00128: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0012C: 419A00A0  beq cr6, 0x82a001cc
	if ctx.cr[6].eq {
	pc = 0x82A001CC; continue 'dispatch;
	}
	// 82A00130: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A00134: 409A0008  bne cr6, 0x82a0013c
	if !ctx.cr[6].eq {
	pc = 0x82A0013C; continue 'dispatch;
	}
	// 82A00138: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0013C; continue 'dispatch;
            }
            0x82A0013C => {
    //   block [0x82A0013C..0x82A0014C)
	// 82A0013C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00140: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00144: 409A0008  bne cr6, 0x82a0014c
	if !ctx.cr[6].eq {
	pc = 0x82A0014C; continue 'dispatch;
	}
	// 82A00148: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0014C; continue 'dispatch;
            }
            0x82A0014C => {
    //   block [0x82A0014C..0x82A00164)
	// 82A0014C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A00150: 7F08E000  cmpw cr6, r8, r28
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A00154: 409A0068  bne cr6, 0x82a001bc
	if !ctx.cr[6].eq {
	pc = 0x82A001BC; continue 'dispatch;
	}
	// 82A00158: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0015C: 409A0008  bne cr6, 0x82a00164
	if !ctx.cr[6].eq {
	pc = 0x82A00164; continue 'dispatch;
	}
	// 82A00160: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A00164; continue 'dispatch;
            }
            0x82A00164 => {
    //   block [0x82A00164..0x82A00194)
	// 82A00164: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A00168: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0016C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A00170: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A00174: 4B7D9D75  bl 0x821d9ee8
	ctx.lr = 0x82A00178;
	sub_821D9EE8(ctx, base);
	// 82A00178: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A0017C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A00180: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A00184: 419A0010  beq cr6, 0x82a00194
	if ctx.cr[6].eq {
	pc = 0x82A00194; continue 'dispatch;
	}
	// 82A00188: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A0018C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00190: 4BFFFA69  bl 0x829ffbf8
	ctx.lr = 0x82A00194;
	sub_829FFBF8(ctx, base);
	pc = 0x82A00194; continue 'dispatch;
            }
            0x82A00194 => {
    //   block [0x82A00194..0x82A001BC)
	// 82A00194: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A00198: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A0019C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A001A0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A001A4: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A001A8: 482A9809  bl 0x82ca99b0
	ctx.lr = 0x82A001AC;
	sub_82CA99B0(ctx, base);
	// 82A001AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A001B0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A001B4: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82A001B8: 4BFFFF58  b 0x82a00110
	pc = 0x82A00110; continue 'dispatch;
            }
            0x82A001BC => {
    //   block [0x82A001BC..0x82A001CC)
	// 82A001BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A001C0: 409AFF48  bne cr6, 0x82a00108
	if !ctx.cr[6].eq {
	pc = 0x82A00108; continue 'dispatch;
	}
	// 82A001C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82A001C8: 4BFFFF40  b 0x82a00108
	pc = 0x82A00108; continue 'dispatch;
            }
            0x82A001CC => {
    //   block [0x82A001CC..0x82A001F8)
	// 82A001CC: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82A001D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A001D4: 419A00A4  beq cr6, 0x82a00278
	if ctx.cr[6].eq {
	pc = 0x82A00278; continue 'dispatch;
	}
	// 82A001D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A001DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A001E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A001E4: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A001E8: F941005C  std r10, 0x5c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u64 ) };
	// 82A001EC: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A001F0: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A001F4: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x82A001F8; continue 'dispatch;
            }
            0x82A001F8 => {
    //   block [0x82A001F8..0x82A00208)
	// 82A001F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A001FC: 419A000C  beq cr6, 0x82a00208
	if ctx.cr[6].eq {
	pc = 0x82A00208; continue 'dispatch;
	}
	// 82A00200: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A00204: 419A0008  beq cr6, 0x82a0020c
	if ctx.cr[6].eq {
	pc = 0x82A0020C; continue 'dispatch;
	}
	pc = 0x82A00208; continue 'dispatch;
            }
            0x82A00208 => {
    //   block [0x82A00208..0x82A0020C)
	// 82A00208: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0020C; continue 'dispatch;
            }
            0x82A0020C => {
    //   block [0x82A0020C..0x82A00228)
	// 82A0020C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A00210: 419A0068  beq cr6, 0x82a00278
	if ctx.cr[6].eq {
	pc = 0x82A00278; continue 'dispatch;
	}
	// 82A00214: E961005C  ld r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	// 82A00218: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0021C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A00220: 409A0008  bne cr6, 0x82a00228
	if !ctx.cr[6].eq {
	pc = 0x82A00228; continue 'dispatch;
	}
	// 82A00224: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A00228; continue 'dispatch;
            }
            0x82A00228 => {
    //   block [0x82A00228..0x82A00244)
	// 82A00228: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0022C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00230: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00234: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00238: 409A000C  bne cr6, 0x82a00244
	if !ctx.cr[6].eq {
	pc = 0x82A00244; continue 'dispatch;
	}
	// 82A0023C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82A00240: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A00244; continue 'dispatch;
            }
            0x82A00244 => {
    //   block [0x82A00244..0x82A0025C)
	// 82A00244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00248: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0024C: 48000035  bl 0x82a00280
	ctx.lr = 0x82A00250;
	sub_82A00280(ctx, base);
	// 82A00250: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A00254: 409A0008  bne cr6, 0x82a0025c
	if !ctx.cr[6].eq {
	pc = 0x82A0025C; continue 'dispatch;
	}
	// 82A00258: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0025C; continue 'dispatch;
            }
            0x82A0025C => {
    //   block [0x82A0025C..0x82A00278)
	// 82A0025C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00260: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00264: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A00268: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82A0026C: 409AFF8C  bne cr6, 0x82a001f8
	if !ctx.cr[6].eq {
	pc = 0x82A001F8; continue 'dispatch;
	}
	// 82A00270: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82A00274: 4BFFFF84  b 0x82a001f8
	pc = 0x82A001F8; continue 'dispatch;
            }
            0x82A00278 => {
    //   block [0x82A00278..0x82A00280)
	// 82A00278: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0027C: 482A91DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00280 size=204
    let mut pc: u32 = 0x82A00280;
    'dispatch: loop {
        match pc {
            0x82A00280 => {
    //   block [0x82A00280..0x82A002CC)
	// 82A00280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00284: 482A9181  bl 0x82ca9404
	ctx.lr = 0x82A00288;
	sub_82CA93D0(ctx, base);
	// 82A00288: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0028C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A00290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A00294: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A00298: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0029C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A002A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A002A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A002A8: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A002AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A002B0: 48001629  bl 0x82a018d8
	ctx.lr = 0x82A002B4;
	sub_82A018D8(ctx, base);
	// 82A002B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A002B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A002BC: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A002C0: 419A0070  beq cr6, 0x82a00330
	if ctx.cr[6].eq {
	pc = 0x82A00330; continue 'dispatch;
	}
	// 82A002C4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82A002C8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x82A002CC; continue 'dispatch;
            }
            0x82A002CC => {
    //   block [0x82A002CC..0x82A00330)
	// 82A002CC: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A002D0: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A002D4: 7CC7482E  lwzx r6, r7, r9
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A002D8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A002DC: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82A002E0: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A002E4: 8085000C  lwz r4, 0xc(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A002E8: 80650000  lwz r3, 0(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A002EC: 80E50008  lwz r7, 8(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A002F0: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A002F4: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A002F8: 7CC85A14  add r6, r8, r11
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82A002FC: 7CA459D6  mullw r5, r4, r11
	ctx.r[5].s32 = ((ctx.r[4].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82A00300: 54C4083C  slwi r4, r6, 1
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A00304: 54A6B2BE  srwi r6, r5, 0xa
	ctx.r[6].u32 = ctx.r[5].u32.wrapping_shr(10);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A00308: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0030C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A00310: 7C641A2E  lhzx r3, r4, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82A00314: 7C680734  extsh r8, r3
	ctx.r[8].s64 = ctx.r[3].s16 as i64;
	// 82A00318: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82A0031C: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A00320: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82A00324: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A00328: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A0032C: 409AFFA0  bne cr6, 0x82a002cc
	if !ctx.cr[6].eq {
	pc = 0x82A002CC; continue 'dispatch;
	}
	pc = 0x82A00330; continue 'dispatch;
            }
            0x82A00330 => {
    //   block [0x82A00330..0x82A0034C)
	// 82A00330: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A00334: 387B0010  addi r3, r27, 0x10
	ctx.r[3].s64 = ctx.r[27].s64 + 16;
	// 82A00338: 4BFFF649  bl 0x829ff980
	ctx.lr = 0x82A0033C;
	sub_829FF980(ctx, base);
	// 82A0033C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A00340: 4B81B9F9  bl 0x8221bd38
	ctx.lr = 0x82A00344;
	sub_8221BD38(ctx, base);
	// 82A00344: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A00348: 482A910C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00350 size=96
    let mut pc: u32 = 0x82A00350;
    'dispatch: loop {
        match pc {
            0x82A00350 => {
    //   block [0x82A00350..0x82A00388)
	// 82A00350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0035C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A00360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00364: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A00368: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82A0036C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A00370: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A00374: 808BE458  lwz r4, -0x1ba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7080 as u32) ) } as u64;
	// 82A00378: 48000351  bl 0x82a006c8
	ctx.lr = 0x82A0037C;
	sub_82A006C8(ctx, base);
	// 82A0037C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00380: 419A0008  beq cr6, 0x82a00388
	if ctx.cr[6].eq {
	pc = 0x82A00388; continue 'dispatch;
	}
	// 82A00384: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82A00388; continue 'dispatch;
            }
            0x82A00388 => {
    //   block [0x82A00388..0x82A003B0)
	// 82A00388: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0038C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00390: 5549C23E  srwi r9, r10, 8
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A00394: 7C7E4850  subf r3, r30, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	// 82A00398: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0039C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A003A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A003A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A003A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A003AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A003B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A003B0 size=104
    let mut pc: u32 = 0x82A003B0;
    'dispatch: loop {
        match pc {
            0x82A003B0 => {
    //   block [0x82A003B0..0x82A00400)
	// 82A003B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A003B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A003B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A003BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A003C0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A003C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A003C8: 48000301  bl 0x82a006c8
	ctx.lr = 0x82A003CC;
	sub_82A006C8(ctx, base);
	// 82A003CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A003D0: 419A0030  beq cr6, 0x82a00400
	if ctx.cr[6].eq {
	pc = 0x82A00400; continue 'dispatch;
	}
	// 82A003D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A003D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A003DC: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A003E0: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82A003E4: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 82A003E8: 991F0000  stb r8, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82A003EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A003F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A003F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A003F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A003FC: 4E800020  blr
	return;
            }
            0x82A00400 => {
    //   block [0x82A00400..0x82A00418)
	// 82A00400: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A00404: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A00408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0040C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00410: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A00414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00418 size=92
    let mut pc: u32 = 0x82A00418;
    'dispatch: loop {
        match pc {
            0x82A00418 => {
    //   block [0x82A00418..0x82A0045C)
	// 82A00418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0041C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00420: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A00424: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00428: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A0042C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A00430: 48000299  bl 0x82a006c8
	ctx.lr = 0x82A00434;
	sub_82A006C8(ctx, base);
	// 82A00434: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00438: 419A0024  beq cr6, 0x82a0045c
	if ctx.cr[6].eq {
	pc = 0x82A0045C; continue 'dispatch;
	}
	// 82A0043C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00440: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A00444: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A00448: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0044C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00450: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A00458: 4E800020  blr
	return;
            }
            0x82A0045C => {
    //   block [0x82A0045C..0x82A00474)
	// 82A0045C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A00460: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A00464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0046C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A00470: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00478 size=92
    let mut pc: u32 = 0x82A00478;
    'dispatch: loop {
        match pc {
            0x82A00478 => {
    //   block [0x82A00478..0x82A004BC)
	// 82A00478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0047C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00480: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A00484: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00488: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A0048C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A00490: 48000239  bl 0x82a006c8
	ctx.lr = 0x82A00494;
	sub_82A006C8(ctx, base);
	// 82A00494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00498: 419A0024  beq cr6, 0x82a004bc
	if ctx.cr[6].eq {
	pc = 0x82A004BC; continue 'dispatch;
	}
	// 82A0049C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A004A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A004A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A004A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A004AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A004B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A004B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A004B8: 4E800020  blr
	return;
            }
            0x82A004BC => {
    //   block [0x82A004BC..0x82A004D4)
	// 82A004BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A004C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A004C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A004C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A004CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A004D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A004D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A004D8 size=68
    let mut pc: u32 = 0x82A004D8;
    'dispatch: loop {
        match pc {
            0x82A004D8 => {
    //   block [0x82A004D8..0x82A00508)
	// 82A004D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A004DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A004E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A004E4: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82A004E8: 480001E1  bl 0x82a006c8
	ctx.lr = 0x82A004EC;
	sub_82A006C8(ctx, base);
	// 82A004EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A004F0: 419A0018  beq cr6, 0x82a00508
	if ctx.cr[6].eq {
	pc = 0x82A00508; continue 'dispatch;
	}
	// 82A004F4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A004F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A004FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00504: 4E800020  blr
	return;
            }
            0x82A00508 => {
    //   block [0x82A00508..0x82A0051C)
	// 82A00508: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82A0050C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A00510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00520 size=96
    let mut pc: u32 = 0x82A00520;
    'dispatch: loop {
        match pc {
            0x82A00520 => {
    //   block [0x82A00520..0x82A00544)
	// 82A00520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00528: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0052C: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 82A00530: 48000199  bl 0x82a006c8
	ctx.lr = 0x82A00534;
	sub_82A006C8(ctx, base);
	// 82A00534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00538: 419A000C  beq cr6, 0x82a00544
	if ctx.cr[6].eq {
	pc = 0x82A00544; continue 'dispatch;
	}
	// 82A0053C: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00540: 48000008  b 0x82a00548
	pc = 0x82A00548; continue 'dispatch;
            }
            0x82A00544 => {
    //   block [0x82A00544..0x82A00548)
	// 82A00544: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82A00548; continue 'dispatch;
            }
            0x82A00548 => {
    //   block [0x82A00548..0x82A0056C)
	// 82A00548: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A0054C: 419A0020  beq cr6, 0x82a0056c
	if ctx.cr[6].eq {
	pc = 0x82A0056C; continue 'dispatch;
	}
	// 82A00550: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A00554: 806B6DA0  lwz r3, 0x6da0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 82A00558: 4B7E3CF9  bl 0x821e4250
	ctx.lr = 0x82A0055C;
	sub_821E4250(ctx, base);
	// 82A0055C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A00560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00568: 4E800020  blr
	return;
            }
            0x82A0056C => {
    //   block [0x82A0056C..0x82A00580)
	// 82A0056C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A00570: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A00574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0057C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00580 size=212
    let mut pc: u32 = 0x82A00580;
    'dispatch: loop {
        match pc {
            0x82A00580 => {
    //   block [0x82A00580..0x82A005F8)
	// 82A00580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00584: 482A8E89  bl 0x82ca940c
	ctx.lr = 0x82A00588;
	sub_82CA93D0(ctx, base);
	// 82A00588: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0058C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A00590: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A00594: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82A00598: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0059C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82A005A0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A005A4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82A005A8: 4B7F37B1  bl 0x821f3d58
	ctx.lr = 0x82A005AC;
	sub_821F3D58(ctx, base);
	// 82A005AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A005B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A005B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A005B8: 4B87B269  bl 0x8227b820
	ctx.lr = 0x82A005BC;
	sub_8227B820(ctx, base);
	// 82A005BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A005C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A005C4: 419A0084  beq cr6, 0x82a00648
	if ctx.cr[6].eq {
	pc = 0x82A00648; continue 'dispatch;
	}
	// 82A005C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A005CC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A005D0: 480003C1  bl 0x82a00990
	ctx.lr = 0x82A005D4;
	sub_82A00990(ctx, base);
	// 82A005D4: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A005D8: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A005DC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A005E0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A005E4: 419A0060  beq cr6, 0x82a00644
	if ctx.cr[6].eq {
	pc = 0x82A00644; continue 'dispatch;
	}
	// 82A005E8: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82A005EC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A005F0: 38EBE460  addi r7, r11, -0x1ba0
	ctx.r[7].s64 = ctx.r[11].s64 + -7072;
	// 82A005F4: 80C9E454  lwz r6, -0x1bac(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-7084 as u32) ) } as u64;
	pc = 0x82A005F8; continue 'dispatch;
            }
            0x82A005F8 => {
    //   block [0x82A005F8..0x82A00630)
	// 82A005F8: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A005FC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A00600: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00604: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82A00608: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0060C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00610: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A00614: 419A001C  beq cr6, 0x82a00630
	if ctx.cr[6].eq {
	pc = 0x82A00630; continue 'dispatch;
	}
	// 82A00618: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A0061C: 409A0014  bne cr6, 0x82a00630
	if !ctx.cr[6].eq {
	pc = 0x82A00630; continue 'dispatch;
	}
	// 82A00620: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00624: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A00628: 409A0008  bne cr6, 0x82a00630
	if !ctx.cr[6].eq {
	pc = 0x82A00630; continue 'dispatch;
	}
	// 82A0062C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	pc = 0x82A00630; continue 'dispatch;
            }
            0x82A00630 => {
    //   block [0x82A00630..0x82A00644)
	// 82A00630: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00634: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A00638: 7D7FFB78  or r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 | ctx.r[31].u64;
	// 82A0063C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A00640: 409AFFB8  bne cr6, 0x82a005f8
	if !ctx.cr[6].eq {
	pc = 0x82A005F8; continue 'dispatch;
	}
	pc = 0x82A00644; continue 'dispatch;
            }
            0x82A00644 => {
    //   block [0x82A00644..0x82A00648)
	// 82A00644: 4B81B6F5  bl 0x8221bd38
	ctx.lr = 0x82A00648;
	sub_8221BD38(ctx, base);
	pc = 0x82A00648; continue 'dispatch;
            }
            0x82A00648 => {
    //   block [0x82A00648..0x82A00654)
	// 82A00648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0064C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A00650: 482A8E0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00658 size=112
    let mut pc: u32 = 0x82A00658;
    'dispatch: loop {
        match pc {
            0x82A00658 => {
    //   block [0x82A00658..0x82A006B0)
	// 82A00658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0065C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00660: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A00664: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00668: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0066C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82A00670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A00674: 386B0E48  addi r3, r11, 0xe48
	ctx.r[3].s64 = ctx.r[11].s64 + 3656;
	// 82A00678: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82A0067C: 4B7F36DD  bl 0x821f3d58
	ctx.lr = 0x82A00680;
	sub_821F3D58(ctx, base);
	// 82A00680: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A00684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00688: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 82A0068C: 4800003D  bl 0x82a006c8
	ctx.lr = 0x82A00690;
	sub_82A006C8(ctx, base);
	// 82A00690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00694: 419A001C  beq cr6, 0x82a006b0
	if ctx.cr[6].eq {
	pc = 0x82A006B0; continue 'dispatch;
	}
	// 82A00698: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0069C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A006A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A006A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A006A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A006AC: 4E800020  blr
	return;
            }
            0x82A006B0 => {
    //   block [0x82A006B0..0x82A006C8)
	// 82A006B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A006B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A006B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A006BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A006C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A006C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A006C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A006C8 size=108
    let mut pc: u32 = 0x82A006C8;
    'dispatch: loop {
        match pc {
            0x82A006C8 => {
    //   block [0x82A006C8..0x82A0071C)
	// 82A006C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A006CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A006D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A006D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A006D8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A006DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A006E0: 4B7E5329  bl 0x821e5a08
	ctx.lr = 0x82A006E4;
	sub_821E5A08(ctx, base);
	// 82A006E4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A006E8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A006EC: 419A0030  beq cr6, 0x82a0071c
	if ctx.cr[6].eq {
	pc = 0x82A0071C; continue 'dispatch;
	}
	// 82A006F0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A006F4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A006F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A006FC: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 82A00700: 4B89C791  bl 0x8229ce90
	ctx.lr = 0x82A00704;
	sub_8229CE90(ctx, base);
	// 82A00704: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A00708: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0070C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A00718: 4E800020  blr
	return;
            }
            0x82A0071C => {
    //   block [0x82A0071C..0x82A00734)
	// 82A0071C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A00720: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A00724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0072C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A00730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00738 size=132
    let mut pc: u32 = 0x82A00738;
    'dispatch: loop {
        match pc {
            0x82A00738 => {
    //   block [0x82A00738..0x82A007A8)
	// 82A00738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0073C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00740: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00744: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A00748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0074C: 419A005C  beq cr6, 0x82a007a8
	if ctx.cr[6].eq {
	pc = 0x82A007A8; continue 'dispatch;
	}
	// 82A00750: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00754: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00758: 5549002E  rlwinm r9, r10, 0, 0, 0x17
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0075C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A00760: 419A0048  beq cr6, 0x82a007a8
	if ctx.cr[6].eq {
	pc = 0x82A007A8; continue 'dispatch;
	}
	// 82A00764: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 82A00768: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A0076C: 419A003C  beq cr6, 0x82a007a8
	if ctx.cr[6].eq {
	pc = 0x82A007A8; continue 'dispatch;
	}
	// 82A00770: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A00774: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A00778: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A0077C: 4B7E51F5  bl 0x821e5970
	ctx.lr = 0x82A00780;
	sub_821E5970(ctx, base);
	// 82A00780: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A00784: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A00788: 419A0020  beq cr6, 0x82a007a8
	if ctx.cr[6].eq {
	pc = 0x82A007A8; continue 'dispatch;
	}
	// 82A0078C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A00790: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00794: 7C6B3214  add r3, r11, r6
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 82A00798: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0079C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A007A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A007A4: 4E800020  blr
	return;
            }
            0x82A007A8 => {
    //   block [0x82A007A8..0x82A007BC)
	// 82A007A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A007AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A007B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A007B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A007B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A007C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A007C0 size=160
    let mut pc: u32 = 0x82A007C0;
    'dispatch: loop {
        match pc {
            0x82A007C0 => {
    //   block [0x82A007C0..0x82A007F8)
	// 82A007C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A007C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A007C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A007CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A007D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A007D4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A007D8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82A007DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A007E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A007E4: 808BE458  lwz r4, -0x1ba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7080 as u32) ) } as u64;
	// 82A007E8: 4BFFFEE1  bl 0x82a006c8
	ctx.lr = 0x82A007EC;
	sub_82A006C8(ctx, base);
	// 82A007EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A007F0: 419A0008  beq cr6, 0x82a007f8
	if ctx.cr[6].eq {
	pc = 0x82A007F8; continue 'dispatch;
	}
	// 82A007F4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x82A007F8; continue 'dispatch;
            }
            0x82A007F8 => {
    //   block [0x82A007F8..0x82A00844)
	// 82A007F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A007FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00800: 554AC23E  srwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A00804: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00808: 4098003C  bge cr6, 0x82a00844
	if !ctx.cr[6].lt {
	pc = 0x82A00844; continue 'dispatch;
	}
	// 82A0080C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A00810: 419A0034  beq cr6, 0x82a00844
	if ctx.cr[6].eq {
	pc = 0x82A00844; continue 'dispatch;
	}
	// 82A00814: 393E0004  addi r9, r30, 4
	ctx.r[9].s64 = ctx.r[30].s64 + 4;
	// 82A00818: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0081C: 419A0028  beq cr6, 0x82a00844
	if ctx.cr[6].eq {
	pc = 0x82A00844; continue 'dispatch;
	}
	// 82A00820: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00824: 554AC23E  srwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A00828: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82A0082C: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82A00830: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A00834: 7CC7582E  lwzx r6, r7, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A00838: 54CB11BA  rlwinm r11, r6, 2, 6, 0x1d
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x3FFFFFFFu64;
	// 82A0083C: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A00840: 48000008  b 0x82a00848
	pc = 0x82A00848; continue 'dispatch;
            }
            0x82A00844 => {
    //   block [0x82A00844..0x82A00848)
	// 82A00844: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82A00848; continue 'dispatch;
            }
            0x82A00848 => {
    //   block [0x82A00848..0x82A00860)
	// 82A00848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0084C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00854: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A00858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0085C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00860 size=152
    let mut pc: u32 = 0x82A00860;
    'dispatch: loop {
        match pc {
            0x82A00860 => {
    //   block [0x82A00860..0x82A00898)
	// 82A00860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0086C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A00870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00874: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A00878: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82A0087C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A00880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A00884: 808BE458  lwz r4, -0x1ba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7080 as u32) ) } as u64;
	// 82A00888: 4BFFFE41  bl 0x82a006c8
	ctx.lr = 0x82A0088C;
	sub_82A006C8(ctx, base);
	// 82A0088C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00890: 419A0008  beq cr6, 0x82a00898
	if ctx.cr[6].eq {
	pc = 0x82A00898; continue 'dispatch;
	}
	// 82A00894: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82A00898; continue 'dispatch;
            }
            0x82A00898 => {
    //   block [0x82A00898..0x82A008DC)
	// 82A00898: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0089C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A008A0: 5549C23E  srwi r9, r10, 8
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A008A4: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A008A8: 40980034  bge cr6, 0x82a008dc
	if !ctx.cr[6].lt {
	pc = 0x82A008DC; continue 'dispatch;
	}
	// 82A008AC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A008B0: 554AC23E  srwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A008B4: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82A008B8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A008BC: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A008C0: 4182001C  beq 0x82a008dc
	if ctx.cr[0].eq {
	pc = 0x82A008DC; continue 'dispatch;
	}
	// 82A008C4: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A008C8: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A008CC: 552811BA  rlwinm r8, r9, 2, 6, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 82A008D0: 7CE858AE  lbzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A008D4: 7CE30774  extsb r3, r7
	ctx.r[3].s64 = ctx.r[7].s8 as i64;
	// 82A008D8: 48000008  b 0x82a008e0
	pc = 0x82A008E0; continue 'dispatch;
            }
            0x82A008DC => {
    //   block [0x82A008DC..0x82A008E0)
	// 82A008DC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	pc = 0x82A008E0; continue 'dispatch;
            }
            0x82A008E0 => {
    //   block [0x82A008E0..0x82A008F8)
	// 82A008E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A008E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A008E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A008EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A008F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A008F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A008F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A008F8 size=148
    let mut pc: u32 = 0x82A008F8;
    'dispatch: loop {
        match pc {
            0x82A008F8 => {
    //   block [0x82A008F8..0x82A00930)
	// 82A008F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A008FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A00904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A00908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0090C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A00910: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82A00914: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A00918: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0091C: 808BE458  lwz r4, -0x1ba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7080 as u32) ) } as u64;
	// 82A00920: 4BFFFDA9  bl 0x82a006c8
	ctx.lr = 0x82A00924;
	sub_82A006C8(ctx, base);
	// 82A00924: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00928: 419A0008  beq cr6, 0x82a00930
	if ctx.cr[6].eq {
	pc = 0x82A00930; continue 'dispatch;
	}
	// 82A0092C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x82A00930; continue 'dispatch;
            }
            0x82A00930 => {
    //   block [0x82A00930..0x82A00970)
	// 82A00930: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00934: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00938: 5549C23E  srwi r9, r10, 8
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0093C: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A00940: 40980030  bge cr6, 0x82a00970
	if !ctx.cr[6].lt {
	pc = 0x82A00970; continue 'dispatch;
	}
	// 82A00944: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A00948: 554AC23E  srwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0094C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82A00950: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82A00954: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A00958: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A0095C: 54EA023E  clrlwi r10, r7, 8
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82A00960: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 82A00964: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A00968: 7C65582E  lwzx r3, r5, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A0096C: 48000008  b 0x82a00974
	pc = 0x82A00974; continue 'dispatch;
            }
            0x82A00970 => {
    //   block [0x82A00970..0x82A00974)
	// 82A00970: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82A00974; continue 'dispatch;
            }
            0x82A00974 => {
    //   block [0x82A00974..0x82A0098C)
	// 82A00974: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A00978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0097C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00980: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A00984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A00988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00990 size=1168
    let mut pc: u32 = 0x82A00990;
    'dispatch: loop {
        match pc {
            0x82A00990 => {
    //   block [0x82A00990..0x82A009D4)
	// 82A00990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00994: 482A8A41  bl 0x82ca93d4
	ctx.lr = 0x82A00998;
	sub_82CA93D0(ctx, base);
	// 82A00998: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0099C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A009A0: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 82A009A4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82A009A8: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 82A009AC: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 82A009B0: 929F0008  stw r20, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 82A009B4: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 82A009B8: 929F0004  stw r20, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 82A009BC: 7E90A378  mr r16, r20
	ctx.r[16].u64 = ctx.r[20].u64;
	// 82A009C0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A009C4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A009C8: 419A0068  beq cr6, 0x82a00a30
	if ctx.cr[6].eq {
	pc = 0x82A00A30; continue 'dispatch;
	}
	// 82A009CC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A009D0: 836BE458  lwz r27, -0x1ba8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7080 as u32) ) } as u64;
	pc = 0x82A009D4; continue 'dispatch;
            }
            0x82A009D4 => {
    //   block [0x82A009D4..0x82A009F8)
	// 82A009D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A009D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A009DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A009E0: 3A100001  addi r16, r16, 1
	ctx.r[16].s64 = ctx.r[16].s64 + 1;
	// 82A009E4: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 82A009E8: 4B7E5021  bl 0x821e5a08
	ctx.lr = 0x82A009EC;
	sub_821E5A08(ctx, base);
	// 82A009EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A009F0: 419A0008  beq cr6, 0x82a009f8
	if ctx.cr[6].eq {
	pc = 0x82A009F8; continue 'dispatch;
	}
	// 82A009F4: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	pc = 0x82A009F8; continue 'dispatch;
            }
            0x82A009F8 => {
    //   block [0x82A009F8..0x82A00A30)
	// 82A009F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A009FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00A00: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00A04: 5549C23E  srwi r9, r10, 8
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A00A08: 7D7C4850  subf r11, r28, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[28].s64;
	// 82A00A0C: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A00A10: 4B7E4EC9  bl 0x821e58d8
	ctx.lr = 0x82A00A14;
	sub_821E58D8(ctx, base);
	// 82A00A14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A00A18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A00A1C: 409AFFB8  bne cr6, 0x82a009d4
	if !ctx.cr[6].eq {
	pc = 0x82A009D4; continue 'dispatch;
	}
	// 82A00A20: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82A00A24: 616A5555  ori r10, r11, 0x5555
	ctx.r[10].u64 = ctx.r[11].u64 | 21845;
	// 82A00A28: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00A2C: 41990014  bgt cr6, 0x82a00a40
	if ctx.cr[6].gt {
	pc = 0x82A00A40; continue 'dispatch;
	}
	pc = 0x82A00A30; continue 'dispatch;
            }
            0x82A00A30 => {
    //   block [0x82A00A30..0x82A00A40)
	// 82A00A30: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00A34: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A00A38: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A00A3C: 48000008  b 0x82a00a44
	pc = 0x82A00A44; continue 'dispatch;
            }
            0x82A00A40 => {
    //   block [0x82A00A40..0x82A00A44)
	// 82A00A40: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82A00A44; continue 'dispatch;
            }
            0x82A00A44 => {
    //   block [0x82A00A44..0x82A00A78)
	// 82A00A44: 4B81E815  bl 0x8221f258
	ctx.lr = 0x82A00A48;
	sub_8221F258(ctx, base);
	// 82A00A48: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00A4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A00A50: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A00A54: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A00A58: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A00A5C: 482A8F55  bl 0x82ca99b0
	ctx.lr = 0x82A00A60;
	sub_82CA99B0(ctx, base);
	// 82A00A60: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82A00A64: 5603103A  slwi r3, r16, 2
	ctx.r[3].u32 = ctx.r[16].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A00A68: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 82A00A6C: 7F104840  cmplw cr6, r16, r9
	ctx.cr[6].compare_u32(ctx.r[16].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A00A70: 40990008  ble cr6, 0x82a00a78
	if !ctx.cr[6].gt {
	pc = 0x82A00A78; continue 'dispatch;
	}
	// 82A00A74: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82A00A78; continue 'dispatch;
            }
            0x82A00A78 => {
    //   block [0x82A00A78..0x82A00A9C)
	// 82A00A78: 4B81E7E1  bl 0x8221f258
	ctx.lr = 0x82A00A7C;
	sub_8221F258(ctx, base);
	// 82A00A7C: 3AB0FFFF  addi r21, r16, -1
	ctx.r[21].s64 = ctx.r[16].s64 + -1;
	// 82A00A80: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 82A00A84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A00A88: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 82A00A8C: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 82A00A90: 41980020  blt cr6, 0x82a00ab0
	if ctx.cr[6].lt {
	pc = 0x82A00AB0; continue 'dispatch;
	}
	// 82A00A94: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00A98: 7FAB8A14  add r29, r11, r17
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[17].u64;
	pc = 0x82A00A9C; continue 'dispatch;
            }
            0x82A00A9C => {
    //   block [0x82A00A9C..0x82A00AB0)
	// 82A00A9C: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A00AA0: 4B7E4E39  bl 0x821e58d8
	ctx.lr = 0x82A00AA4;
	sub_821E58D8(ctx, base);
	// 82A00AA4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A00AA8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 82A00AAC: 4080FFF0  bge 0x82a00a9c
	if !ctx.cr[0].lt {
	pc = 0x82A00A9C; continue 'dispatch;
	}
	pc = 0x82A00AB0; continue 'dispatch;
            }
            0x82A00AB0 => {
    //   block [0x82A00AB0..0x82A00AE4)
	// 82A00AB0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A00AB4: 4B81E80D  bl 0x8221f2c0
	ctx.lr = 0x82A00AB8;
	sub_8221F2C0(ctx, base);
	// 82A00AB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A00ABC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A00AC0: 409A002C  bne cr6, 0x82a00aec
	if !ctx.cr[6].eq {
	pc = 0x82A00AEC; continue 'dispatch;
	}
	// 82A00AC4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A00AC8: 814B6F6C  lwz r10, 0x6f6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A00ACC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A00AD0: 419A0014  beq cr6, 0x82a00ae4
	if ctx.cr[6].eq {
	pc = 0x82A00AE4; continue 'dispatch;
	}
	// 82A00AD4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00AD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A00ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A00AE0: 4E800421  bctrl
	ctx.lr = 0x82A00AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A00AE4 => {
    //   block [0x82A00AE4..0x82A00AEC)
	// 82A00AE4: 482C18C5  bl 0x82cc23a8
	ctx.lr = 0x82A00AE8;
	sub_82CC23A8(ctx, base);
	// 82A00AE8: 48000008  b 0x82a00af0
	pc = 0x82A00AF0; continue 'dispatch;
            }
            0x82A00AEC => {
    //   block [0x82A00AEC..0x82A00AF0)
	// 82A00AEC: 929E0000  stw r20, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	pc = 0x82A00AF0; continue 'dispatch;
            }
            0x82A00AF0 => {
    //   block [0x82A00AF0..0x82A00AFC)
	// 82A00AF0: 357E0004  addic. r11, r30, 4
	ctx.xer.ca = (ctx.r[30].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A00AF4: 41820008  beq 0x82a00afc
	if ctx.cr[0].eq {
	pc = 0x82A00AFC; continue 'dispatch;
	}
	// 82A00AF8: 928B0000  stw r20, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	pc = 0x82A00AFC; continue 'dispatch;
            }
            0x82A00AFC => {
    //   block [0x82A00AFC..0x82A00B08)
	// 82A00AFC: 357E0008  addic. r11, r30, 8
	ctx.xer.ca = (ctx.r[30].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A00B00: 41820008  beq 0x82a00b08
	if ctx.cr[0].eq {
	pc = 0x82A00B08; continue 'dispatch;
	}
	// 82A00B04: 928B0000  stw r20, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	pc = 0x82A00B08; continue 'dispatch;
            }
            0x82A00B08 => {
    //   block [0x82A00B08..0x82A00B44)
	// 82A00B08: 9A5E0014  stb r18, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[18].u8 ) };
	// 82A00B0C: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 82A00B10: 9A9E0015  stb r20, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[20].u8 ) };
	// 82A00B14: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82A00B18: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82A00B1C: 9A5E0015  stb r18, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[18].u8 ) };
	// 82A00B20: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A00B24: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A00B28: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A00B2C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A00B30: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A00B34: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A00B38: 92810078  stw r20, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[20].u32 ) };
	// 82A00B3C: 419A0294  beq cr6, 0x82a00dd0
	if ctx.cr[6].eq {
	pc = 0x82A00DD0; continue 'dispatch;
	}
	// 82A00B40: 7E338B78  mr r19, r17
	ctx.r[19].u64 = ctx.r[17].u64;
	pc = 0x82A00B44; continue 'dispatch;
            }
            0x82A00B44 => {
    //   block [0x82A00B44..0x82A00B5C)
	// 82A00B44: 83130000  lwz r24, 0(r19)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00B48: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 82A00B4C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A00B50: 4BFFF801  bl 0x82a00350
	ctx.lr = 0x82A00B54;
	sub_82A00350(ctx, base);
	// 82A00B54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00B58: 419A0268  beq cr6, 0x82a00dc0
	if ctx.cr[6].eq {
	pc = 0x82A00DC0; continue 'dispatch;
	}
	pc = 0x82A00B5C; continue 'dispatch;
            }
            0x82A00B5C => {
    //   block [0x82A00B5C..0x82A00B84)
	// 82A00B5C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A00B60: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A00B64: 4BFFFD95  bl 0x82a008f8
	ctx.lr = 0x82A00B68;
	sub_82A008F8(ctx, base);
	// 82A00B68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A00B6C: 7E97A378  mr r23, r20
	ctx.r[23].u64 = ctx.r[20].u64;
	// 82A00B70: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82A00B74: 7F15B000  cmpw cr6, r21, r22
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82A00B78: 4099015C  ble cr6, 0x82a00cd4
	if !ctx.cr[6].gt {
	pc = 0x82A00CD4; continue 'dispatch;
	}
	// 82A00B7C: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00B80: 7FCB8A14  add r30, r11, r17
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[17].u64;
	pc = 0x82A00B84; continue 'dispatch;
            }
            0x82A00B84 => {
    //   block [0x82A00B84..0x82A00BB0)
	// 82A00B84: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00B88: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A00B8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00B90: 4BFFFBA9  bl 0x82a00738
	ctx.lr = 0x82A00B94;
	sub_82A00738(ctx, base);
	// 82A00B94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00B98: 409A0018  bne cr6, 0x82a00bb0
	if !ctx.cr[6].eq {
	pc = 0x82A00BB0; continue 'dispatch;
	}
	// 82A00B9C: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 82A00BA0: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 82A00BA4: 7F1BB000  cmpw cr6, r27, r22
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82A00BA8: 4199FFDC  bgt cr6, 0x82a00b84
	if ctx.cr[6].gt {
	pc = 0x82A00B84; continue 'dispatch;
	}
	// 82A00BAC: 48000128  b 0x82a00cd4
	pc = 0x82A00CD4; continue 'dispatch;
            }
            0x82A00BB0 => {
    //   block [0x82A00BB0..0x82A00BCC)
	// 82A00BB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00BB4: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	// 82A00BB8: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 82A00BBC: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 82A00BC0: 4BFFF791  bl 0x82a00350
	ctx.lr = 0x82A00BC4;
	sub_82A00350(ctx, base);
	// 82A00BC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00BC8: 419A010C  beq cr6, 0x82a00cd4
	if ctx.cr[6].eq {
	pc = 0x82A00CD4; continue 'dispatch;
	}
	pc = 0x82A00BCC; continue 'dispatch;
            }
            0x82A00BCC => {
    //   block [0x82A00BCC..0x82A00C14)
	// 82A00BCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A00BD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00BD4: 4BFFFD25  bl 0x82a008f8
	ctx.lr = 0x82A00BD8;
	sub_82A008F8(ctx, base);
	// 82A00BD8: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A00BDC: 409A00D8  bne cr6, 0x82a00cb4
	if !ctx.cr[6].eq {
	pc = 0x82A00CB4; continue 'dispatch;
	}
	// 82A00BE0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82A00BE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A00BE8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A00BEC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A00BF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A00BF4: 7E5A9378  mr r26, r18
	ctx.r[26].u64 = ctx.r[18].u64;
	// 82A00BF8: 48000449  bl 0x82a01040
	ctx.lr = 0x82A00BFC;
	sub_82A01040(ctx, base);
	// 82A00BFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A00C04: 419A0010  beq cr6, 0x82a00c14
	if ctx.cr[6].eq {
	pc = 0x82A00C14; continue 'dispatch;
	}
	// 82A00C08: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A00C0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00C10: 419A0008  beq cr6, 0x82a00c18
	if ctx.cr[6].eq {
	pc = 0x82A00C18; continue 'dispatch;
	}
	pc = 0x82A00C14; continue 'dispatch;
            }
            0x82A00C14 => {
    //   block [0x82A00C14..0x82A00C18)
	// 82A00C14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A00C18; continue 'dispatch;
            }
            0x82A00C18 => {
    //   block [0x82A00C18..0x82A00CB4)
	// 82A00C18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00C1C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A00C20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00C24: 409A009C  bne cr6, 0x82a00cc0
	if !ctx.cr[6].eq {
	pc = 0x82A00CC0; continue 'dispatch;
	}
	// 82A00C28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A00C2C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A00C30: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A00C34: 4800029D  bl 0x82a00ed0
	ctx.lr = 0x82A00C38;
	sub_82A00ED0(ctx, base);
	// 82A00C38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A00C3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00C40: 4BFFFB81  bl 0x82a007c0
	ctx.lr = 0x82A00C44;
	sub_82A007C0(ctx, base);
	// 82A00C44: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 82A00C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A00C4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00C50: 4BFFFC11  bl 0x82a00860
	ctx.lr = 0x82A00C54;
	sub_82A00860(ctx, base);
	// 82A00C54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00C58: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00C5C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A00C60: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A00C64: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A00C68: 7C67492E  stwx r3, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	// 82A00C6C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00C70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00C74: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A00C78: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A00C7C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00C80: 7CAB4A14  add r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A00C84: 93850004  stw r28, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A00C88: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00C8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00C90: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A00C94: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A00C98: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00C9C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A00CA0: 91E30008  stw r15, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[15].u32 ) };
	// 82A00CA4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00CA8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A00CAC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A00CB0: 48000010  b 0x82a00cc0
	pc = 0x82A00CC0; continue 'dispatch;
            }
            0x82A00CB4 => {
    //   block [0x82A00CB4..0x82A00CC0)
	// 82A00CB4: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A00CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A00CBC: 409A0018  bne cr6, 0x82a00cd4
	if !ctx.cr[6].eq {
	pc = 0x82A00CD4; continue 'dispatch;
	}
	pc = 0x82A00CC0; continue 'dispatch;
            }
            0x82A00CC0 => {
    //   block [0x82A00CC0..0x82A00CD4)
	// 82A00CC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00CC4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A00CC8: 4BFFF689  bl 0x82a00350
	ctx.lr = 0x82A00CCC;
	sub_82A00350(ctx, base);
	// 82A00CCC: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A00CD0: 4198FEFC  blt cr6, 0x82a00bcc
	if ctx.cr[6].lt {
	pc = 0x82A00BCC; continue 'dispatch;
	}
	pc = 0x82A00CD4; continue 'dispatch;
            }
            0x82A00CD4 => {
    //   block [0x82A00CD4..0x82A00D10)
	// 82A00CD4: 56EB063E  clrlwi r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 82A00CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A00CDC: 409A00D0  bne cr6, 0x82a00dac
	if !ctx.cr[6].eq {
	pc = 0x82A00DAC; continue 'dispatch;
	}
	// 82A00CE0: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 82A00CE4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A00CE8: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82A00CEC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A00CF0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A00CF4: 4800034D  bl 0x82a01040
	ctx.lr = 0x82A00CF8;
	sub_82A01040(ctx, base);
	// 82A00CF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A00D00: 419A0010  beq cr6, 0x82a00d10
	if ctx.cr[6].eq {
	pc = 0x82A00D10; continue 'dispatch;
	}
	// 82A00D04: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A00D08: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00D0C: 419A0008  beq cr6, 0x82a00d14
	if ctx.cr[6].eq {
	pc = 0x82A00D14; continue 'dispatch;
	}
	pc = 0x82A00D10; continue 'dispatch;
            }
            0x82A00D10 => {
    //   block [0x82A00D10..0x82A00D14)
	// 82A00D10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A00D14; continue 'dispatch;
            }
            0x82A00D14 => {
    //   block [0x82A00D14..0x82A00DAC)
	// 82A00D14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00D18: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A00D1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00D20: 409A008C  bne cr6, 0x82a00dac
	if !ctx.cr[6].eq {
	pc = 0x82A00DAC; continue 'dispatch;
	}
	// 82A00D24: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A00D28: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A00D2C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A00D30: 480001A1  bl 0x82a00ed0
	ctx.lr = 0x82A00D34;
	sub_82A00ED0(ctx, base);
	// 82A00D34: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A00D38: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A00D3C: 4BFFFA85  bl 0x82a007c0
	ctx.lr = 0x82A00D40;
	sub_82A007C0(ctx, base);
	// 82A00D40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A00D44: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A00D48: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A00D4C: 4BFFFB15  bl 0x82a00860
	ctx.lr = 0x82A00D50;
	sub_82A00860(ctx, base);
	// 82A00D50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00D54: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00D58: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A00D5C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A00D60: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A00D64: 7C67492E  stwx r3, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	// 82A00D68: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00D6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00D70: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A00D74: 7CCB4A14  add r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A00D78: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00D7C: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A00D80: 93850004  stw r28, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A00D84: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00D88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00D8C: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A00D90: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A00D94: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00D98: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A00D9C: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A00DA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00DA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A00DA8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A00DAC; continue 'dispatch;
            }
            0x82A00DAC => {
    //   block [0x82A00DAC..0x82A00DC0)
	// 82A00DAC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A00DB0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82A00DB4: 4BFFF59D  bl 0x82a00350
	ctx.lr = 0x82A00DB8;
	sub_82A00350(ctx, base);
	// 82A00DB8: 7F191840  cmplw cr6, r25, r3
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A00DBC: 4198FDA0  blt cr6, 0x82a00b5c
	if ctx.cr[6].lt {
	pc = 0x82A00B5C; continue 'dispatch;
	}
	pc = 0x82A00DC0; continue 'dispatch;
            }
            0x82A00DC0 => {
    //   block [0x82A00DC0..0x82A00DD0)
	// 82A00DC0: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82A00DC4: 3A730004  addi r19, r19, 4
	ctx.r[19].s64 = ctx.r[19].s64 + 4;
	// 82A00DC8: 7F168040  cmplw cr6, r22, r16
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[16].u32, &mut ctx.xer);
	// 82A00DCC: 4198FD78  blt cr6, 0x82a00b44
	if ctx.cr[6].lt {
	pc = 0x82A00B44; continue 'dispatch;
	}
	pc = 0x82A00DD0; continue 'dispatch;
            }
            0x82A00DD0 => {
    //   block [0x82A00DD0..0x82A00E20)
	// 82A00DD0: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 82A00DD4: 4B81AF65  bl 0x8221bd38
	ctx.lr = 0x82A00DD8;
	sub_8221BD38(ctx, base);
	// 82A00DD8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82A00DDC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A00DE0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A00DE4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A00DE8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A00DEC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A00DF0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A00DF4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00DF8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A00DFC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A00E00: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A00E04: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A00E08: 4B9FB581  bl 0x823fc388
	ctx.lr = 0x82A00E0C;
	sub_823FC388(ctx, base);
	// 82A00E0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A00E10: 4B81AF29  bl 0x8221bd38
	ctx.lr = 0x82A00E14;
	sub_8221BD38(ctx, base);
	// 82A00E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00E18: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A00E1C: 482A8608  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A00E20 size=80
    let mut pc: u32 = 0x82A00E20;
    'dispatch: loop {
        match pc {
            0x82A00E20 => {
    //   block [0x82A00E20..0x82A00E70)
	// 82A00E20: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A00E24: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00E28: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A00E2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A00E30: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00E34: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A00E38: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A00E3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00E40: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A00E44: 419A002C  beq cr6, 0x82a00e70
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A00E70);
		return;
	}
	// 82A00E48: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A00E4C: 409A0024  bne cr6, 0x82a00e70
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A00E70);
		return;
	}
	// 82A00E50: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A00E54: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00E58: 816BE454  lwz r11, -0x1bac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 82A00E5C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A00E60: 409A0010  bne cr6, 0x82a00e70
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A00E70);
		return;
	}
	// 82A00E64: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A00E68: 806BE460  lwz r3, -0x1ba0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7072 as u32) ) } as u64;
	// 82A00E6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A00E78 size=80
    let mut pc: u32 = 0x82A00E78;
    'dispatch: loop {
        match pc {
            0x82A00E78 => {
    //   block [0x82A00E78..0x82A00EC8)
	// 82A00E78: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A00E7C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00E80: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A00E84: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A00E88: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00E8C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A00E90: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A00E94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00E98: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82A00E9C: 419A002C  beq cr6, 0x82a00ec8
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A00EC8);
		return;
	}
	// 82A00EA0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A00EA4: 409A0024  bne cr6, 0x82a00ec8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A00EC8);
		return;
	}
	// 82A00EA8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A00EAC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00EB0: 816BE454  lwz r11, -0x1bac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 82A00EB4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A00EB8: 409A0010  bne cr6, 0x82a00ec8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A00EC8);
		return;
	}
	// 82A00EBC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A00EC0: 806BE460  lwz r3, -0x1ba0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7072 as u32) ) } as u64;
	// 82A00EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A00ED0 size=368
    let mut pc: u32 = 0x82A00ED0;
    'dispatch: loop {
        match pc {
            0x82A00ED0 => {
    //   block [0x82A00ED0..0x82A00F14)
	// 82A00ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00ED4: 482A852D  bl 0x82ca9400
	ctx.lr = 0x82A00ED8;
	sub_82CA93D0(ctx, base);
	// 82A00ED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00EDC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A00EE0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A00EE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A00EE8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A00EEC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A00EF0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00EF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00EF8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A00EFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A00F00: 409A0054  bne cr6, 0x82a00f54
	if !ctx.cr[6].eq {
	pc = 0x82A00F54; continue 'dispatch;
	}
	// 82A00F04: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00F08: A13B0006  lhz r9, 6(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(6 as u32) ) } as u64;
	// 82A00F0C: 5548801E  slwi r8, r10, 0x10
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(16);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A00F10: 7D2A4378  or r10, r9, r8
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	pc = 0x82A00F14; continue 'dispatch;
            }
            0x82A00F14 => {
    //   block [0x82A00F14..0x82A00F44)
	// 82A00F14: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A00F18: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A00F1C: A10B0012  lhz r8, 0x12(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A00F20: 5527801E  slwi r7, r9, 0x10
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(16);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A00F24: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 82A00F28: 7CA65010  subfc r5, r6, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[6].u32;
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 82A00F2C: 7C852910  subfe r4, r5, r5
	let x = (!ctx.r[5].u32);
	let y = ctx.r[5].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[4].u32 = res;
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A00F30: 549D07FE  clrlwi r29, r4, 0x1f
	ctx.r[29].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82A00F34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A00F38: 419A000C  beq cr6, 0x82a00f44
	if ctx.cr[6].eq {
	pc = 0x82A00F44; continue 'dispatch;
	}
	// 82A00F3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00F40: 48000008  b 0x82a00f48
	pc = 0x82A00F48; continue 'dispatch;
            }
            0x82A00F44 => {
    //   block [0x82A00F44..0x82A00F48)
	// 82A00F44: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A00F48; continue 'dispatch;
            }
            0x82A00F48 => {
    //   block [0x82A00F48..0x82A00F54)
	// 82A00F48: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A00F4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A00F50: 419AFFC4  beq cr6, 0x82a00f14
	if ctx.cr[6].eq {
	pc = 0x82A00F14; continue 'dispatch;
	}
	pc = 0x82A00F54; continue 'dispatch;
            }
            0x82A00F54 => {
    //   block [0x82A00F54..0x82A00FB8)
	// 82A00F54: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82A00F58: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A00F5C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A00F60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A00F64: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A00F68: 419A0058  beq cr6, 0x82a00fc0
	if ctx.cr[6].eq {
	pc = 0x82A00FC0; continue 'dispatch;
	}
	// 82A00F6C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00F70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A00F74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00F78: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A00F7C: 409A003C  bne cr6, 0x82a00fb8
	if !ctx.cr[6].eq {
	pc = 0x82A00FB8; continue 'dispatch;
	}
	// 82A00F80: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A00F84: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A00F88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A00F8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A00F90: 4800CE21  bl 0x82a0ddb0
	ctx.lr = 0x82A00F94;
	sub_82A0DDB0(ctx, base);
	// 82A00F94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A00F98: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A00F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00FA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00FA4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A00FA8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A00FAC: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A00FB0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A00FB4: 482A849C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A00FB8 => {
    //   block [0x82A00FB8..0x82A00FC0)
	// 82A00FB8: 480B3541  bl 0x82ab44f8
	ctx.lr = 0x82A00FBC;
	sub_82AB44F8(ctx, base);
	// 82A00FBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A00FC0; continue 'dispatch;
            }
            0x82A00FC0 => {
    //   block [0x82A00FC0..0x82A01024)
	// 82A00FC0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A00FC4: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00FC8: A10B0012  lhz r8, 0x12(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A00FCC: 5547801E  slwi r7, r10, 0x10
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(16);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A00FD0: A0DB0006  lhz r6, 6(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(6 as u32) ) } as u64;
	// 82A00FD4: 5525801E  slwi r5, r9, 0x10
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(16);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A00FD8: 7D043B78  or r4, r8, r7
	ctx.r[4].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 82A00FDC: 7CC32B78  or r3, r6, r5
	ctx.r[3].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82A00FE0: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A00FE4: 40980040  bge cr6, 0x82a01024
	if !ctx.cr[6].lt {
	pc = 0x82A01024; continue 'dispatch;
	}
	// 82A00FE8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A00FEC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A00FF0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A00FF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A00FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A00FFC: 4800CDB5  bl 0x82a0ddb0
	ctx.lr = 0x82A01000;
	sub_82A0DDB0(ctx, base);
	// 82A01000: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A01004: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A01008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0100C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01010: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01014: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A01018: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0101C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A01020: 482A8430  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A01024 => {
    //   block [0x82A01024..0x82A01040)
	// 82A01024: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A01028: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0102C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01030: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82A01034: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A01038: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0103C: 482A8414  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A01040 size=172
    let mut pc: u32 = 0x82A01040;
    'dispatch: loop {
        match pc {
            0x82A01040 => {
    //   block [0x82A01040..0x82A01064)
	// 82A01040: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01044: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01048: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0104C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A01050: 409A0048  bne cr6, 0x82a01098
	if !ctx.cr[6].eq {
	pc = 0x82A01098; continue 'dispatch;
	}
	// 82A01054: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01058: A1050006  lhz r8, 6(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 82A0105C: 5527801E  slwi r7, r9, 0x10
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(16);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A01060: 7D093B78  or r9, r8, r7
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	pc = 0x82A01064; continue 'dispatch;
            }
            0x82A01064 => {
    //   block [0x82A01064..0x82A01084)
	// 82A01064: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A01068: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A0106C: 5506801E  slwi r6, r8, 0x10
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(16);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A01070: 7CE83378  or r8, r7, r6
	ctx.r[8].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 82A01074: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A01078: 4098000C  bge cr6, 0x82a01084
	if !ctx.cr[6].lt {
	pc = 0x82A01084; continue 'dispatch;
	}
	// 82A0107C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A01080: 4800000C  b 0x82a0108c
	pc = 0x82A0108C; continue 'dispatch;
            }
            0x82A01084 => {
    //   block [0x82A01084..0x82A0108C)
	// 82A01084: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A01088: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A0108C; continue 'dispatch;
            }
            0x82A0108C => {
    //   block [0x82A0108C..0x82A01098)
	// 82A0108C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A01090: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A01094: 419AFFD0  beq cr6, 0x82a01064
	if ctx.cr[6].eq {
	pc = 0x82A01064; continue 'dispatch;
	}
	pc = 0x82A01098; continue 'dispatch;
            }
            0x82A01098 => {
    //   block [0x82A01098..0x82A010EC)
	// 82A01098: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0109C: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 82A010A0: 9081FFF0  stw r4, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u32 ) };
	// 82A010A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A010A8: 419A0044  beq cr6, 0x82a010ec
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A010EC);
		return;
	}
	// 82A010AC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A010B0: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A010B4: A0EA0012  lhz r7, 0x12(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A010B8: 5526801E  slwi r6, r9, 0x10
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(16);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A010BC: A0A50006  lhz r5, 6(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 82A010C0: 550A801E  slwi r10, r8, 0x10
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(16);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A010C4: 7CE93378  or r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 82A010C8: 7CA85378  or r8, r5, r10
	ctx.r[8].u64 = ctx.r[5].u64 | ctx.r[10].u64;
	// 82A010CC: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A010D0: 4198001C  blt cr6, 0x82a010ec
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82A010EC);
		return;
	}
	// 82A010D4: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 82A010D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A010DC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A010E0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A010E4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A010E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A01110 size=108
    let mut pc: u32 = 0x82A01110;
    'dispatch: loop {
        match pc {
            0x82A01110 => {
    //   block [0x82A01110..0x82A01134)
	// 82A01110: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01114: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01118: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82A0111C: 7D0B2038  and r11, r8, r4
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[4].u64;
	// 82A01120: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A01124: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A01128: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0112C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A01130: 419A0030  beq cr6, 0x82a01160
	if ctx.cr[6].eq {
	pc = 0x82A01160; continue 'dispatch;
	}
	pc = 0x82A01134; continue 'dispatch;
            }
            0x82A01134 => {
    //   block [0x82A01134..0x82A01160)
	// 82A01134: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01138: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0113C: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A01140: 419A0020  beq cr6, 0x82a01160
	if ctx.cr[6].eq {
	pc = 0x82A01160; continue 'dispatch;
	}
	// 82A01144: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A01148: 7D6B4038  and r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 82A0114C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A01150: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A01154: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01158: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A0115C: 409AFFD8  bne cr6, 0x82a01134
	if !ctx.cr[6].eq {
	pc = 0x82A01134; continue 'dispatch;
	}
	pc = 0x82A01160; continue 'dispatch;
            }
            0x82A01160 => {
    //   block [0x82A01160..0x82A0117C)
	// 82A01160: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A01164: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A01168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0116C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A01170: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82A01174: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A01178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01180 size=260
    let mut pc: u32 = 0x82A01180;
    'dispatch: loop {
        match pc {
            0x82A01180 => {
    //   block [0x82A01180..0x82A011B4)
	// 82A01180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01184: 482A8281  bl 0x82ca9404
	ctx.lr = 0x82A01188;
	sub_82CA93D0(ctx, base);
	// 82A01188: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0118C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01190: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A01194: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A01198: 4BFFFF79  bl 0x82a01110
	ctx.lr = 0x82A0119C;
	sub_82A01110(ctx, base);
	// 82A0119C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A011A0: 409A00D8  bne cr6, 0x82a01278
	if !ctx.cr[6].eq {
	pc = 0x82A01278; continue 'dispatch;
	}
	// 82A011A4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A011A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A011AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A011B0: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	pc = 0x82A011B4; continue 'dispatch;
            }
            0x82A011B4 => {
    //   block [0x82A011B4..0x82A011D8)
	// 82A011B4: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A011B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A011BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A011C0: 409AFFF4  bne cr6, 0x82a011b4
	if !ctx.cr[6].eq {
	pc = 0x82A011B4; continue 'dispatch;
	}
	// 82A011C4: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A011C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A011CC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A011D0: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A011D4: 3B8A0001  addi r28, r10, 1
	ctx.r[28].s64 = ctx.r[10].s64 + 1;
	pc = 0x82A011D8; continue 'dispatch;
            }
            0x82A011D8 => {
    //   block [0x82A011D8..0x82A0121C)
	// 82A011D8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A011DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A011E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A011E4: 409AFFF4  bne cr6, 0x82a011d8
	if !ctx.cr[6].eq {
	pc = 0x82A011D8; continue 'dispatch;
	}
	// 82A011E8: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A011EC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A011F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A011F4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A011F8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A011FC: 3BAB0005  addi r29, r11, 5
	ctx.r[29].s64 = ctx.r[11].s64 + 5;
	// 82A01200: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A01204: 419A0018  beq cr6, 0x82a0121c
	if ctx.cr[6].eq {
	pc = 0x82A0121C; continue 'dispatch;
	}
	// 82A01208: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0120C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01210: 7D3D5A14  add r9, r29, r11
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A01214: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A01218: 4099002C  ble cr6, 0x82a01244
	if !ctx.cr[6].gt {
	pc = 0x82A01244; continue 'dispatch;
	}
	pc = 0x82A0121C; continue 'dispatch;
            }
            0x82A0121C => {
    //   block [0x82A0121C..0x82A01244)
	// 82A0121C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A01220: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01224: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A01228: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0122C: 4B81E02D  bl 0x8221f258
	ctx.lr = 0x82A01230;
	sub_8221F258(ctx, base);
	// 82A01230: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01234: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82A01238: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0123C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A01240: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x82A01244; continue 'dispatch;
            }
            0x82A01244 => {
    //   block [0x82A01244..0x82A01278)
	// 82A01244: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A01248: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0124C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01250: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A01254: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A01258: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A0125C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82A01260: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A01264: 7F6B512E  stwx r27, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[27].u32) };
	// 82A01268: 482A8219  bl 0x82ca9480
	ctx.lr = 0x82A0126C;
	sub_82CA9480(ctx, base);
	// 82A0126C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01270: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A01274: 482A81E0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A01278 => {
    //   block [0x82A01278..0x82A01284)
	// 82A01278: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0127C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A01280: 482A81D4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01288 size=172
    let mut pc: u32 = 0x82A01288;
    'dispatch: loop {
        match pc {
            0x82A01288 => {
    //   block [0x82A01288..0x82A012D4)
	// 82A01288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0128C: 482A8181  bl 0x82ca940c
	ctx.lr = 0x82A01290;
	sub_82CA93D0(ctx, base);
	// 82A01290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01298: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0129C: 4BFFFEE5  bl 0x82a01180
	ctx.lr = 0x82A012A0;
	sub_82A01180(ctx, base);
	// 82A012A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A012A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A012A8: 419A0084  beq cr6, 0x82a0132c
	if ctx.cr[6].eq {
	pc = 0x82A0132C; continue 'dispatch;
	}
	// 82A012AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A012B0: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A012B4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A012B8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A012BC: 5507F0BE  srwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A012C0: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A012C4: 409A0010  bne cr6, 0x82a012d4
	if !ctx.cr[6].eq {
	pc = 0x82A012D4; continue 'dispatch;
	}
	// 82A012C8: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A012CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A012D0: 4BFFE5D1  bl 0x829ff8a0
	ctx.lr = 0x82A012D4;
	sub_829FF8A0(ctx, base);
	pc = 0x82A012D4; continue 'dispatch;
            }
            0x82A012D4 => {
    //   block [0x82A012D4..0x82A012F8)
	// 82A012D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A012D8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A012DC: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82A012E0: 7D0BF038  and r11, r8, r30
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[30].u64;
	// 82A012E4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A012E8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A012EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A012F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A012F4: 419A0030  beq cr6, 0x82a01324
	if ctx.cr[6].eq {
	pc = 0x82A01324; continue 'dispatch;
	}
	pc = 0x82A012F8; continue 'dispatch;
            }
            0x82A012F8 => {
    //   block [0x82A012F8..0x82A01324)
	// 82A012F8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A012FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01300: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A01304: 419A0020  beq cr6, 0x82a01324
	if ctx.cr[6].eq {
	pc = 0x82A01324; continue 'dispatch;
	}
	// 82A01308: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0130C: 7D6B4038  and r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 82A01310: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A01314: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A01318: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0131C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A01320: 409AFFD8  bne cr6, 0x82a012f8
	if !ctx.cr[6].eq {
	pc = 0x82A012F8; continue 'dispatch;
	}
	pc = 0x82A01324; continue 'dispatch;
            }
            0x82A01324 => {
    //   block [0x82A01324..0x82A0132C)
	// 82A01324: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A01328: 7FAB492E  stwx r29, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[29].u32) };
	pc = 0x82A0132C; continue 'dispatch;
            }
            0x82A0132C => {
    //   block [0x82A0132C..0x82A01334)
	// 82A0132C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A01330: 482A812C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01338 size=332
    let mut pc: u32 = 0x82A01338;
    'dispatch: loop {
        match pc {
            0x82A01338 => {
    //   block [0x82A01338..0x82A0138C)
	// 82A01338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0133C: 482A80C1  bl 0x82ca93fc
	ctx.lr = 0x82A01340;
	sub_82CA93D0(ctx, base);
	// 82A01340: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01344: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A01348: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A0134C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A01350: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 82A01354: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82A01358: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A0135C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01360: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A01364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01368: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0136C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A01370: 4E800421  bctrl
	ctx.lr = 0x82A01374;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A01374: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A01378: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0137C: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A01380: 4099000C  ble cr6, 0x82a0138c
	if !ctx.cr[6].gt {
	pc = 0x82A0138C; continue 'dispatch;
	}
	// 82A01384: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A01388: 4BFFE519  bl 0x829ff8a0
	ctx.lr = 0x82A0138C;
	sub_829FF8A0(ctx, base);
            }
            0x82A0138C => {
    //   block [0x82A0138C..0x82A01408)
	// 82A0138C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01390: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 82A01394: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A01398: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A0139C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A013A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A013A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A013A8: 4E800421  bctrl
	ctx.lr = 0x82A013AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A013AC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A013B0: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 82A013B4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A013B8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A013BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A013C0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A013C4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A013C8: 4E800421  bctrl
	ctx.lr = 0x82A013CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A013CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A013D0: 4B81DE89  bl 0x8221f258
	ctx.lr = 0x82A013D4;
	sub_8221F258(ctx, base);
	// 82A013D4: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A013D8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A013DC: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A013E0: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 82A013E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A013E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A013EC: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A013F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A013F4: 4E800421  bctrl
	ctx.lr = 0x82A013F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A013F8: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A013FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A01400: 419A0074  beq cr6, 0x82a01474
	if ctx.cr[6].eq {
	pc = 0x82A01474; continue 'dispatch;
	}
	// 82A01404: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
            }
            0x82A01408 => {
    //   block [0x82A01408..0x82A01464)
	// 82A01408: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0140C: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 82A01410: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82A01414: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A01418: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A0141C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01420: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01424: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A01428: 4E800421  bctrl
	ctx.lr = 0x82A0142C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0142C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A01430: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A01434: 419A0040  beq cr6, 0x82a01474
	if ctx.cr[6].eq {
	pc = 0x82A01474; continue 'dispatch;
	}
	// 82A01438: 7FABD82E  lwzx r29, r11, r27
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82A0143C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A01440: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A01444: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A01448: 4BFFFCC9  bl 0x82a01110
	ctx.lr = 0x82A0144C;
	sub_82A01110(ctx, base);
	// 82A0144C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01450: 409A0014  bne cr6, 0x82a01464
	if !ctx.cr[6].eq {
	pc = 0x82A01464; continue 'dispatch;
	}
	// 82A01454: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 82A01458: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0145C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A01460: 4BFFFE29  bl 0x82a01288
	ctx.lr = 0x82A01464;
	sub_82A01288(ctx, base);
            }
            0x82A01464 => {
    //   block [0x82A01464..0x82A01474)
	// 82A01464: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A01468: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82A0146C: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A01470: 409AFF98  bne cr6, 0x82a01408
	if !ctx.cr[6].eq {
	pc = 0x82A01408; continue 'dispatch;
	}
	pc = 0x82A01474; continue 'dispatch;
            }
            0x82A01474 => {
    //   block [0x82A01474..0x82A01484)
	// 82A01474: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A01478: 4B81A8C1  bl 0x8221bd38
	ctx.lr = 0x82A0147C;
	sub_8221BD38(ctx, base);
	// 82A0147C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A01480: 482A7FCC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01488 size=124
    let mut pc: u32 = 0x82A01488;
    'dispatch: loop {
        match pc {
            0x82A01488 => {
    //   block [0x82A01488..0x82A014E4)
	// 82A01488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0148C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A01494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A01498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0149C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A014A0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A014A4: 4B81DDB5  bl 0x8221f258
	ctx.lr = 0x82A014A8;
	sub_8221F258(ctx, base);
	// 82A014A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A014AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A014B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A014B4: 419A0030  beq cr6, 0x82a014e4
	if ctx.cr[6].eq {
	pc = 0x82A014E4; continue 'dispatch;
	}
	// 82A014B8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 82A014BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A014C0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A014C4: 3C800001  lis r4, 1
	ctx.r[4].s64 = 65536;
	// 82A014C8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A014CC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A014D0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A014D4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A014D8: 4BFFE3C9  bl 0x829ff8a0
	ctx.lr = 0x82A014DC;
	sub_829FF8A0(ctx, base);
	// 82A014DC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A014E0: 48000008  b 0x82a014e8
	pc = 0x82A014E8; continue 'dispatch;
            }
            0x82A014E4 => {
    //   block [0x82A014E4..0x82A014E8)
	// 82A014E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A014E8; continue 'dispatch;
            }
            0x82A014E8 => {
    //   block [0x82A014E8..0x82A01504)
	// 82A014E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A014EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A014F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A014F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A014F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A014FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A01500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01508 size=188
    let mut pc: u32 = 0x82A01508;
    'dispatch: loop {
        match pc {
            0x82A01508 => {
    //   block [0x82A01508..0x82A0153C)
	// 82A01508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0150C: 482A7EFD  bl 0x82ca9408
	ctx.lr = 0x82A01510;
	sub_82CA93D0(ctx, base);
	// 82A01510: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01514: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A01518: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0151C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A01520: 419A0094  beq cr6, 0x82a015b4
	if ctx.cr[6].eq {
	pc = 0x82A015B4; continue 'dispatch;
	}
	// 82A01524: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01528: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A0152C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01530: 419A000C  beq cr6, 0x82a0153c
	if ctx.cr[6].eq {
	pc = 0x82A0153C; continue 'dispatch;
	}
	// 82A01534: 4B81A805  bl 0x8221bd38
	ctx.lr = 0x82A01538;
	sub_8221BD38(ctx, base);
	// 82A01538: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	pc = 0x82A0153C; continue 'dispatch;
            }
            0x82A0153C => {
    //   block [0x82A0153C..0x82A01550)
	// 82A0153C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A01540: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82A01544: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A01548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0154C: 419A0020  beq cr6, 0x82a0156c
	if ctx.cr[6].eq {
	pc = 0x82A0156C; continue 'dispatch;
	}
	pc = 0x82A01550; continue 'dispatch;
            }
            0x82A01550 => {
    //   block [0x82A01550..0x82A0156C)
	// 82A01550: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01554: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01558: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0155C: 4B81A7DD  bl 0x8221bd38
	ctx.lr = 0x82A01560;
	sub_8221BD38(ctx, base);
	// 82A01560: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A01568: 409AFFE8  bne cr6, 0x82a01550
	if !ctx.cr[6].eq {
	pc = 0x82A01550; continue 'dispatch;
	}
	pc = 0x82A0156C; continue 'dispatch;
            }
            0x82A0156C => {
    //   block [0x82A0156C..0x82A01580)
	// 82A0156C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A01570: 93BE0018  stw r29, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82A01574: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0157C: 419A0020  beq cr6, 0x82a0159c
	if ctx.cr[6].eq {
	pc = 0x82A0159C; continue 'dispatch;
	}
	pc = 0x82A01580; continue 'dispatch;
            }
            0x82A01580 => {
    //   block [0x82A01580..0x82A0159C)
	// 82A01580: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01584: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01588: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0158C: 4B81A7AD  bl 0x8221bd38
	ctx.lr = 0x82A01590;
	sub_8221BD38(ctx, base);
	// 82A01590: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01594: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A01598: 409AFFE8  bne cr6, 0x82a01580
	if !ctx.cr[6].eq {
	pc = 0x82A01580; continue 'dispatch;
	}
	pc = 0x82A0159C; continue 'dispatch;
            }
            0x82A0159C => {
    //   block [0x82A0159C..0x82A015B4)
	// 82A0159C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A015A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A015A4: 4B81A795  bl 0x8221bd38
	ctx.lr = 0x82A015A8;
	sub_8221BD38(ctx, base);
	// 82A015A8: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A015AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A015B0: 482A7EA8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A015B4 => {
    //   block [0x82A015B4..0x82A015C4)
	// 82A015B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A015B8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A015BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A015C0: 482A7E98  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A015C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A015C8 size=24
    let mut pc: u32 = 0x82A015C8;
    'dispatch: loop {
        match pc {
            0x82A015C8 => {
    //   block [0x82A015C8..0x82A015E0)
	// 82A015C8: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A015CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A015D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A015D4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A015D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A015DC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A015E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A015E0 size=24
    let mut pc: u32 = 0x82A015E0;
    'dispatch: loop {
        match pc {
            0x82A015E0 => {
    //   block [0x82A015E0..0x82A015F8)
	// 82A015E0: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A015E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A015E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A015EC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A015F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A015F4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A015F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A015F8 size=196
    let mut pc: u32 = 0x82A015F8;
    'dispatch: loop {
        match pc {
            0x82A015F8 => {
    //   block [0x82A015F8..0x82A0161C)
	// 82A015F8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82A015FC: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01600: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01604: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A01608: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82A0160C: 7CAB3A14  add r5, r11, r7
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A01610: 7D672850  subf r11, r7, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 82A01614: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A01618: 4081003C  ble 0x82a01654
	if !ctx.cr[0].gt {
	pc = 0x82A01654; continue 'dispatch;
	}
	pc = 0x82A0161C; continue 'dispatch;
            }
            0x82A0161C => {
    //   block [0x82A0161C..0x82A01648)
	// 82A0161C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A01620: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A01624: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A01628: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82A0162C: 83E90000  lwz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01630: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A01634: 40980014  bge cr6, 0x82a01648
	if !ctx.cr[6].lt {
	pc = 0x82A01648; continue 'dispatch;
	}
	// 82A01638: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A0163C: 39090004  addi r8, r9, 4
	ctx.r[8].s64 = ctx.r[9].s64 + 4;
	// 82A01640: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A01644: 48000008  b 0x82a0164c
	pc = 0x82A0164C; continue 'dispatch;
            }
            0x82A01648 => {
    //   block [0x82A01648..0x82A0164C)
	// 82A01648: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82A0164C; continue 'dispatch;
            }
            0x82A0164C => {
    //   block [0x82A0164C..0x82A01654)
	// 82A0164C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A01650: 4199FFCC  bgt cr6, 0x82a0161c
	if ctx.cr[6].gt {
	pc = 0x82A0161C; continue 'dispatch;
	}
	pc = 0x82A01654; continue 'dispatch;
            }
            0x82A01654 => {
    //   block [0x82A01654..0x82A01678)
	// 82A01654: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A01658: 419A0020  beq cr6, 0x82a01678
	if ctx.cr[6].eq {
	pc = 0x82A01678; continue 'dispatch;
	}
	// 82A0165C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01660: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A01664: 409A0014  bne cr6, 0x82a01678
	if !ctx.cr[6].eq {
	pc = 0x82A01678; continue 'dispatch;
	}
	// 82A01668: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82A0166C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A01670: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A01674: 409A0010  bne cr6, 0x82a01684
	if !ctx.cr[6].eq {
	pc = 0x82A01684; continue 'dispatch;
	}
	pc = 0x82A01678; continue 'dispatch;
            }
            0x82A01678 => {
    //   block [0x82A01678..0x82A01684)
	// 82A01678: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0167C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82A01680: 4E800020  blr
	return;
            }
            0x82A01684 => {
    //   block [0x82A01684..0x82A016BC)
	// 82A01684: 54C9083C  slwi r9, r6, 1
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A01688: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0168C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A01690: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A01694: 7CA859D6  mullw r5, r8, r11
	ctx.r[5].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82A01698: 54C4083C  slwi r4, r6, 1
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0169C: 54A9B2BE  srwi r9, r5, 0xa
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shr(10);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A016A0: 7C643A2E  lhzx r3, r4, r7
	ctx.r[3].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82A016A4: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82A016A8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A016AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A016B0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A016B4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82A016B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A016C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A016C0 size=536
    let mut pc: u32 = 0x82A016C0;
    'dispatch: loop {
        match pc {
            0x82A016C0 => {
    //   block [0x82A016C0..0x82A01720)
	// 82A016C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A016C4: 482A7D49  bl 0x82ca940c
	ctx.lr = 0x82A016C8;
	sub_82CA93D0(ctx, base);
	// 82A016C8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A016CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A016D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A016D4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A016D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A016DC: 409A01F0  bne cr6, 0x82a018cc
	if !ctx.cr[6].eq {
	pc = 0x82A018CC; continue 'dispatch;
	}
	// 82A016E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A016E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A016E8: 4B82B7E9  bl 0x8222ced0
	ctx.lr = 0x82A016EC;
	sub_8222CED0(ctx, base);
	// 82A016EC: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82A016F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A016F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A016F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A016FC: 4826E175  bl 0x82c6f870
	ctx.lr = 0x82A01700;
	sub_82C6F870(ctx, base);
	// 82A01700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A01704: 4B8136D5  bl 0x82214dd8
	ctx.lr = 0x82A01708;
	sub_82214DD8(ctx, base);
	// 82A01708: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0170C: 4826D375  bl 0x82c6ea80
	ctx.lr = 0x82A01710;
	sub_82C6EA80(ctx, base);
	// 82A01710: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A01714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01718: 419A01AC  beq cr6, 0x82a018c4
	if ctx.cr[6].eq {
	pc = 0x82A018C4; continue 'dispatch;
	}
	// 82A0171C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82A01720; continue 'dispatch;
            }
            0x82A01720 => {
    //   block [0x82A01720..0x82A017F8)
	// 82A01720: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01724: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A01728: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0172C: 409AFFF4  bne cr6, 0x82a01720
	if !ctx.cr[6].eq {
	pc = 0x82A01720; continue 'dispatch;
	}
	// 82A01730: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A01734: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A01738: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A0173C: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 82A01740: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A01744: 4B7A79C5  bl 0x821a9108
	ctx.lr = 0x82A01748;
	sub_821A9108(ctx, base);
	// 82A01748: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0174C: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82A01750: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A01754: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A01758: 4826D199  bl 0x82c6e8f0
	ctx.lr = 0x82A0175C;
	sub_82C6E8F0(ctx, base);
	// 82A0175C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A01760: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A01764: 80C10084  lwz r6, 0x84(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A01768: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0176C: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82A01770: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A01774: 7CC62A14  add r6, r6, r5
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[5].u64;
	// 82A01778: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A0177C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A01780: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A01784: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A01788: 54AB083C  slwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0178C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A01790: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A01794: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A01798: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0179C: 4B81DABD  bl 0x8221f258
	ctx.lr = 0x82A017A0;
	sub_8221F258(ctx, base);
	// 82A017A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A017A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A017A8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A017AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A017B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A017B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A017B8: 4826D139  bl 0x82c6e8f0
	ctx.lr = 0x82A017BC;
	sub_82C6E8F0(ctx, base);
	// 82A017BC: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A017C0: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A017C4: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A017C8: 7D7E4214  add r11, r30, r8
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[8].u64;
	// 82A017CC: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A017D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A017D4: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A017D8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A017DC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A017E0: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82A017E4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A017E8: 419A0010  beq cr6, 0x82a017f8
	if ctx.cr[6].eq {
	pc = 0x82A017F8; continue 'dispatch;
	}
	// 82A017EC: 550B402E  slwi r11, r8, 8
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A017F0: 7D2B5396  divwu r9, r11, r10
	ctx.r[9].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82A017F4: 48000008  b 0x82a017fc
	pc = 0x82A017FC; continue 'dispatch;
            }
            0x82A017F8 => {
    //   block [0x82A017F8..0x82A017FC)
	// 82A017F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82A017FC; continue 'dispatch;
            }
            0x82A017FC => {
    //   block [0x82A017FC..0x82A0185C)
	// 82A017FC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A01800: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A01804: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A01808: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A0180C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82A01810: 38C82134  addi r6, r8, 0x2134
	ctx.r[6].s64 = ctx.r[8].s64 + 8500;
	// 82A01814: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A01818: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A0181C: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 82A01820: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A01824: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A01828: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A0182C: 7D43F050  subf r10, r3, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[3].s64;
	// 82A01830: 7D6AEA14  add r11, r10, r29
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82A01834: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A01838: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A0183C: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01840: 4BFFFAF9  bl 0x82a01338
	ctx.lr = 0x82A01844;
	sub_82A01338(ctx, base);
	// 82A01844: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A01848: 4826D041  bl 0x82c6e888
	ctx.lr = 0x82A0184C;
	sub_82C6E888(ctx, base);
	// 82A0184C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A01850: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A01854: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A01858: 419A0058  beq cr6, 0x82a018b0
	if ctx.cr[6].eq {
	pc = 0x82A018B0; continue 'dispatch;
	}
	pc = 0x82A0185C; continue 'dispatch;
            }
            0x82A0185C => {
    //   block [0x82A0185C..0x82A018B0)
	// 82A0185C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01860: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01864: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A01868: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0186C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A01870: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A01874: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A01878: 7C6559D6  mullw r3, r5, r11
	ctx.r[3].s32 = ((ctx.r[5].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82A0187C: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A01880: 5468B2BE  srwi r8, r3, 0xa
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shr(10);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A01884: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A01888: 7CCA322E  lhzx r6, r10, r6
	ctx.r[6].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82A0188C: 7CCA0734  extsh r10, r6
	ctx.r[10].s64 = ctx.r[6].s16 as i64;
	// 82A01890: 7CAA4214  add r5, r10, r8
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A01894: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A01898: 7D0A482E  lwzx r8, r10, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A0189C: 7C883A14  add r4, r8, r7
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82A018A0: 7C8A492E  stwx r4, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[4].u32) };
	// 82A018A4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A018A8: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A018AC: 4198FFB0  blt cr6, 0x82a0185c
	if ctx.cr[6].lt {
	pc = 0x82A0185C; continue 'dispatch;
	}
	pc = 0x82A018B0; continue 'dispatch;
            }
            0x82A018B0 => {
    //   block [0x82A018B0..0x82A018C4)
	// 82A018B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A018B4: 4826D525  bl 0x82c6edd8
	ctx.lr = 0x82A018B8;
	sub_82C6EDD8(ctx, base);
	// 82A018B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A018BC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A018C0: 482A7B9C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A018C4 => {
    //   block [0x82A018C4..0x82A018CC)
	// 82A018C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A018C8: 4826D511  bl 0x82c6edd8
	ctx.lr = 0x82A018CC;
	sub_82C6EDD8(ctx, base);
	pc = 0x82A018CC; continue 'dispatch;
            }
            0x82A018CC => {
    //   block [0x82A018CC..0x82A018D8)
	// 82A018CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A018D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A018D4: 482A7B88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A018D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A018D8 size=96
    let mut pc: u32 = 0x82A018D8;
    'dispatch: loop {
        match pc {
            0x82A018D8 => {
    //   block [0x82A018D8..0x82A01918)
	// 82A018D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A018DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A018E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A018E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A018E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A018EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A018F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A018F4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A018F8: 4B81A441  bl 0x8221bd38
	ctx.lr = 0x82A018FC;
	sub_8221BD38(ctx, base);
	// 82A018FC: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82A01900: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A01904: 57E31838  slwi r3, r31, 3
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A01908: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 82A0190C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A01910: 40990008  ble cr6, 0x82a01918
	if !ctx.cr[6].gt {
	pc = 0x82A01918; continue 'dispatch;
	}
	// 82A01914: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82A01918; continue 'dispatch;
            }
            0x82A01918 => {
    //   block [0x82A01918..0x82A01938)
	// 82A01918: 4B81D941  bl 0x8221f258
	ctx.lr = 0x82A0191C;
	sub_8221F258(ctx, base);
	// 82A0191C: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A01920: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A01924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A01928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0192C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A01930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A01934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01938 size=132
    let mut pc: u32 = 0x82A01938;
    'dispatch: loop {
        match pc {
            0x82A01938 => {
    //   block [0x82A01938..0x82A01964)
	// 82A01938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0193C: 482A7AD1  bl 0x82ca940c
	ctx.lr = 0x82A01940;
	sub_82CA93D0(ctx, base);
	// 82A01940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01944: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A01948: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0194C: 3BBE0028  addi r29, r30, 0x28
	ctx.r[29].s64 = ctx.r[30].s64 + 40;
	// 82A01950: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A01954: 4B8D5335  bl 0x822d6c88
	ctx.lr = 0x82A01958;
	sub_822D6C88(ctx, base);
	// 82A01958: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A0195C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A01960: 419A002C  beq cr6, 0x82a0198c
	if ctx.cr[6].eq {
	pc = 0x82A0198C; continue 'dispatch;
	}
	pc = 0x82A01964; continue 'dispatch;
            }
            0x82A01964 => {
    //   block [0x82A01964..0x82A01980)
	// 82A01964: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01968: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0196C: 41980014  blt cr6, 0x82a01980
	if ctx.cr[6].lt {
	pc = 0x82A01980; continue 'dispatch;
	}
	// 82A01970: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01974: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A01978: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0197C: 41980028  blt cr6, 0x82a019a4
	if ctx.cr[6].lt {
	pc = 0x82A019A4; continue 'dispatch;
	}
	pc = 0x82A01980; continue 'dispatch;
            }
            0x82A01980 => {
    //   block [0x82A01980..0x82A0198C)
	// 82A01980: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A01984: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A01988: 409AFFDC  bne cr6, 0x82a01964
	if !ctx.cr[6].eq {
	pc = 0x82A01964; continue 'dispatch;
	}
	pc = 0x82A0198C; continue 'dispatch;
            }
            0x82A0198C => {
    //   block [0x82A0198C..0x82A019A4)
	// 82A0198C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82A01990: 7C2004AC  lwsync
	// 82A01994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A01998: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0199C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A019A0: 482A7ABC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A019A4 => {
    //   block [0x82A019A4..0x82A019BC)
	// 82A019A4: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A019A8: 7C2004AC  lwsync
	// 82A019AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A019B0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A019B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A019B8: 482A7AA4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A019C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A019C8 size=136
    let mut pc: u32 = 0x82A019C8;
    'dispatch: loop {
        match pc {
            0x82A019C8 => {
    //   block [0x82A019C8..0x82A01A14)
	// 82A019C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A019CC: 482A7A39  bl 0x82ca9404
	ctx.lr = 0x82A019D0;
	sub_82CA93D0(ctx, base);
	// 82A019D0: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82A019D4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A019D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A019DC: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A019E0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A019E4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A019E8: 482A8AA1  bl 0x82caa488
	ctx.lr = 0x82A019EC;
	sub_82CAA488(ctx, base);
	// 82A019EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A019F0: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A019F4: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A019F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A019FC: 419A0018  beq cr6, 0x82a01a14
	if ctx.cr[6].eq {
	pc = 0x82A01A14; continue 'dispatch;
	}
	// 82A01A00: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01A04: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01A08: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01A0C: 4883B2ED  bl 0x8323ccf8
	ctx.lr = 0x82A01A10;
	sub_8323CCF8(ctx, base);
	// 82A01A10: 48000004  b 0x82a01a14
	pc = 0x82A01A14; continue 'dispatch;
            }
            0x82A01A14 => {
    //   block [0x82A01A14..0x82A01A50)
	// 82A01A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01A18: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82A01A1C: 482A7A38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82A01A20: 3BECFF70  addi r31, r12, -0x90
	ctx.r[31].s64 = ctx.r[12].s64 + -144;
	// 82A01A24: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01A28: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01A2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01A30: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A01A34: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A01A38: 48195441  bl 0x82b96e78
	ctx.lr = 0x82A01A3C;
	sub_82B96E78(ctx, base);
	// 82A01A3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A01A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A01A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A01A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01A58 size=232
    let mut pc: u32 = 0x82A01A58;
    'dispatch: loop {
        match pc {
            0x82A01A58 => {
    //   block [0x82A01A58..0x82A01AE0)
	// 82A01A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01A5C: 482A79A9  bl 0x82ca9404
	ctx.lr = 0x82A01A60;
	sub_82CA93D0(ctx, base);
	// 82A01A60: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82A01A64: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01A68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A01A6C: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 82A01A70: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A01A74: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A01A78: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82A01A7C: 482A8A0D  bl 0x82caa488
	ctx.lr = 0x82A01A80;
	sub_82CAA488(ctx, base);
	// 82A01A80: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82A01A84: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A01A88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01A8C: 419A0078  beq cr6, 0x82a01b04
	if ctx.cr[6].eq {
	pc = 0x82A01B04; continue 'dispatch;
	}
	// 82A01A90: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01A94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A01A98: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01A9C: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82A01AA0: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01AA4: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01AA8: 7D494050  subf r10, r9, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82A01AAC: 90E30008  stw r7, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A01AB0: 91230010  stw r9, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82A01AB4: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82A01AB8: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A01ABC: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A01AC0: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A01AC4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A01AC8: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A01ACC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A01AD0: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A01AD4: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A01AD8: 4099001C  ble cr6, 0x82a01af4
	if !ctx.cr[6].gt {
	pc = 0x82A01AF4; continue 'dispatch;
	}
	// 82A01ADC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82A01AE0; continue 'dispatch;
            }
            0x82A01AE0 => {
    //   block [0x82A01AE0..0x82A01AF4)
	// 82A01AE0: 554AF87E  srwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A01AE4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A01AE8: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82A01AEC: 4199FFF4  bgt cr6, 0x82a01ae0
	if ctx.cr[6].gt {
	pc = 0x82A01AE0; continue 'dispatch;
	}
	// 82A01AF0: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	pc = 0x82A01AF4; continue 'dispatch;
            }
            0x82A01AF4 => {
    //   block [0x82A01AF4..0x82A01B04)
	// 82A01AF4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82A01AF8: 39630028  addi r11, r3, 0x28
	ctx.r[11].s64 = ctx.r[3].s64 + 40;
	// 82A01AFC: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A01B00: 48000004  b 0x82a01b04
	pc = 0x82A01B04; continue 'dispatch;
            }
            0x82A01B04 => {
    //   block [0x82A01B04..0x82A01B40)
	// 82A01B04: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82A01B08: 482A794C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82A01B0C: 3BECFF70  addi r31, r12, -0x90
	ctx.r[31].s64 = ctx.r[12].s64 + -144;
	// 82A01B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01B18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01B1C: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A01B20: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A01B24: 48195355  bl 0x82b96e78
	ctx.lr = 0x82A01B28;
	sub_82B96E78(ctx, base);
	// 82A01B28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A01B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A01B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A01B34: 4E800020  blr
	return;
	// 82A01B38: 82CAE348  lwz r22, -0x1cb8(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7352 as u32) ) } as u64;
	// 82A01B3C: 82100F48  lwz r16, 0xf48(r16)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(3912 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01B40 size=248
    let mut pc: u32 = 0x82A01B40;
    'dispatch: loop {
        match pc {
            0x82A01B40 => {
    //   block [0x82A01B40..0x82A01C04)
	// 82A01B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01B44: 482A78C5  bl 0x82ca9408
	ctx.lr = 0x82A01B48;
	sub_82CA93D0(ctx, base);
	// 82A01B48: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82A01B4C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01B50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A01B54: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A01B58: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A01B5C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A01B60: 482A8929  bl 0x82caa488
	ctx.lr = 0x82A01B64;
	sub_82CAA488(ctx, base);
	// 82A01B64: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82A01B68: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A01B6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01B70: 419A0094  beq cr6, 0x82a01c04
	if ctx.cr[6].eq {
	pc = 0x82A01C04; continue 'dispatch;
	}
	// 82A01B74: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01B78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A01B7C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01B80: 39030024  addi r8, r3, 0x24
	ctx.r[8].s64 = ctx.r[3].s64 + 36;
	// 82A01B84: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01B88: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A01B8C: 911F0058  stw r8, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82A01B90: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A01B94: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A01B98: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A01B9C: 91430024  stw r10, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82A01BA0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A01BA4: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A01BA8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01BAC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A01BB0: 7D095A14  add r8, r9, r11
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A01BB4: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A01BB8: 38AB000F  addi r5, r11, 0xf
	ctx.r[5].s64 = ctx.r[11].s64 + 15;
	// 82A01BBC: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A01BC0: 3888FFFF  addi r4, r8, -1
	ctx.r[4].s64 = ctx.r[8].s64 + -1;
	// 82A01BC4: 7D255B96  divwu r9, r5, r11
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[11].u32;
	// 82A01BC8: 7D045B96  divwu r8, r4, r11
	ctx.r[8].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82A01BCC: 7CE959D6  mullw r7, r9, r11
	ctx.r[7].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82A01BD0: 7CA859D6  mullw r5, r8, r11
	ctx.r[5].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82A01BD4: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A01BD8: 80860000  lwz r4, 0(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01BDC: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A01BE0: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82A01BE4: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82A01BE8: 0CCB0000  twi 6, r11, 0
	// 82A01BEC: 0CCB0000  twi 6, r11, 0
	// 82A01BF0: 7D672050  subf r11, r7, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 82A01BF4: 7D4B2B96  divwu r10, r11, r5
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[5].u32;
	// 82A01BF8: 0CC50000  twi 6, r5, 0
	// 82A01BFC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A01C00: 48000004  b 0x82a01c04
	pc = 0x82A01C04; continue 'dispatch;
            }
            0x82A01C04 => {
    //   block [0x82A01C04..0x82A01C38)
	// 82A01C04: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82A01C08: 482A7850  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82A01C0C: 3BECFF70  addi r31, r12, -0x90
	ctx.r[31].s64 = ctx.r[12].s64 + -144;
	// 82A01C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01C14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01C18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01C1C: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A01C20: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A01C24: 48195255  bl 0x82b96e78
	ctx.lr = 0x82A01C28;
	sub_82B96E78(ctx, base);
	// 82A01C28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A01C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A01C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A01C34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A01C38 size=112
    let mut pc: u32 = 0x82A01C38;
    'dispatch: loop {
        match pc {
            0x82A01C38 => {
    //   block [0x82A01C38..0x82A01C50)
	// 82A01C38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01C3C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A01C40: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01C44: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01C4C: 419A0040  beq cr6, 0x82a01c8c
	if ctx.cr[6].eq {
	pc = 0x82A01C8C; continue 'dispatch;
	}
	pc = 0x82A01C50; continue 'dispatch;
            }
            0x82A01C50 => {
    //   block [0x82A01C50..0x82A01C6C)
	// 82A01C50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01C54: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A01C58: 41980014  blt cr6, 0x82a01c6c
	if ctx.cr[6].lt {
	pc = 0x82A01C6C; continue 'dispatch;
	}
	// 82A01C5C: 409A0020  bne cr6, 0x82a01c7c
	if !ctx.cr[6].eq {
	pc = 0x82A01C7C; continue 'dispatch;
	}
	// 82A01C60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01C64: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A01C68: 40980014  bge cr6, 0x82a01c7c
	if !ctx.cr[6].lt {
	pc = 0x82A01C7C; continue 'dispatch;
	}
	pc = 0x82A01C6C; continue 'dispatch;
            }
            0x82A01C6C => {
    //   block [0x82A01C6C..0x82A01C7C)
	// 82A01C6C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A01C70: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A01C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01C78: 409AFFD8  bne cr6, 0x82a01c50
	if !ctx.cr[6].eq {
	pc = 0x82A01C50; continue 'dispatch;
	}
	pc = 0x82A01C7C; continue 'dispatch;
            }
            0x82A01C7C => {
    //   block [0x82A01C7C..0x82A01C8C)
	// 82A01C7C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A01C80: 419A000C  beq cr6, 0x82a01c8c
	if ctx.cr[6].eq {
	pc = 0x82A01C8C; continue 'dispatch;
	}
	// 82A01C84: 9088000C  stw r4, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82A01C88: 48000008  b 0x82a01c90
	pc = 0x82A01C90; continue 'dispatch;
            }
            0x82A01C8C => {
    //   block [0x82A01C8C..0x82A01C90)
	// 82A01C8C: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	pc = 0x82A01C90; continue 'dispatch;
            }
            0x82A01C90 => {
    //   block [0x82A01C90..0x82A01CA8)
	// 82A01C90: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A01C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01C98: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A01C9C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A01CA0: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A01CA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A01CA8 size=120
    let mut pc: u32 = 0x82A01CA8;
    'dispatch: loop {
        match pc {
            0x82A01CA8 => {
    //   block [0x82A01CA8..0x82A01CBC)
	// 82A01CA8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A01CAC: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 82A01CB0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A01CB4: 41980008  blt cr6, 0x82a01cbc
	if ctx.cr[6].lt {
	pc = 0x82A01CBC; continue 'dispatch;
	}
	// 82A01CB8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x82A01CBC; continue 'dispatch;
            }
            0x82A01CBC => {
    //   block [0x82A01CBC..0x82A01D20)
	// 82A01CBC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A01CC0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01CC4: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A01CC8: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A01CCC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A01CD0: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A01CD4: 7D443850  subf r10, r4, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 82A01CD8: 7CE54430  srw r5, r7, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[7].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 82A01CDC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A01CE0: 7C8529D6  mullw r4, r5, r5
	ctx.r[4].s32 = ((ctx.r[5].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82A01CE4: 7D434430  srw r3, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[10].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 82A01CE8: 7CA319D6  mullw r5, r3, r3
	ctx.r[5].s32 = ((ctx.r[3].s32 as i64 * ctx.r[3].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82A01CEC: 7CA34430  srw r3, r5, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[5].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 82A01CF0: 7D4351D6  mullw r10, r3, r10
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A01CF4: 7C884430  srw r8, r4, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[4].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 82A01CF8: 7CAA4396  divwu r5, r10, r8
	ctx.r[5].u32 = ctx.r[10].u32 / ctx.r[8].u32;
	// 82A01CFC: 3889FFFF  addi r4, r9, -1
	ctx.r[4].s64 = ctx.r[9].s64 + -1;
	// 82A01D00: 7C653850  subf r3, r5, r7
	ctx.r[3].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 82A01D04: 0CC80000  twi 6, r8, 0
	// 82A01D08: 7D4B1850  subf r10, r11, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82A01D0C: 0CC60000  twi 6, r6, 0
	// 82A01D10: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A01D14: 7D4B21D6  mullw r10, r11, r4
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A01D18: 7C6A3396  divwu r3, r10, r6
	ctx.r[3].u32 = ctx.r[10].u32 / ctx.r[6].u32;
	// 82A01D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01D20 size=92
    let mut pc: u32 = 0x82A01D20;
    'dispatch: loop {
        match pc {
            0x82A01D20 => {
    //   block [0x82A01D20..0x82A01D7C)
	// 82A01D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A01D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A01D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01D34: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A01D38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A01D3C: 816B6DC0  lwz r11, 0x6dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28096 as u32) ) } as u64;
	// 82A01D40: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82A01D44: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82A01D48: 4B8D4F41  bl 0x822d6c88
	ctx.lr = 0x82A01D4C;
	sub_822D6C88(ctx, base);
	// 82A01D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A01D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01D54: 488345C5  bl 0x83236318
	ctx.lr = 0x82A01D58;
	sub_83236318(ctx, base);
	// 82A01D58: 7C2004AC  lwsync
	// 82A01D5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A01D60: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82A01D64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A01D68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A01D6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A01D70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A01D74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A01D78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01D80 size=208
    let mut pc: u32 = 0x82A01D80;
    'dispatch: loop {
        match pc {
            0x82A01D80 => {
    //   block [0x82A01D80..0x82A01DB0)
	// 82A01D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01D84: 482A7689  bl 0x82ca940c
	ctx.lr = 0x82A01D88;
	sub_82CA93D0(ctx, base);
	// 82A01D88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01D8C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A01D90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01D94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A01D98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01DA0: 409A0010  bne cr6, 0x82a01db0
	if !ctx.cr[6].eq {
	pc = 0x82A01DB0; continue 'dispatch;
	}
	// 82A01DA4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A01DA8: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82A01DAC: 48000008  b 0x82a01db4
	pc = 0x82A01DB4; continue 'dispatch;
            }
            0x82A01DB0 => {
    //   block [0x82A01DB0..0x82A01DB4)
	// 82A01DB0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A01DB4; continue 'dispatch;
            }
            0x82A01DB4 => {
    //   block [0x82A01DB4..0x82A01E14)
	// 82A01DB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A01DB8: 48286F21  bl 0x82c88cd8
	ctx.lr = 0x82A01DBC;
	sub_82C88CD8(ctx, base);
	// 82A01DBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01DC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A01DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01DC8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01DCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A01DD0: 4E800421  bctrl
	ctx.lr = 0x82A01DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A01DD4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A01DD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A01DDC: 419A0038  beq cr6, 0x82a01e14
	if ctx.cr[6].eq {
	pc = 0x82A01E14; continue 'dispatch;
	}
	// 82A01DE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01DE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A01DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01DEC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A01DF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A01DF4: 4E800421  bctrl
	ctx.lr = 0x82A01DF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A01DF8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01E00: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A01E04: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A01E08: 4E800421  bctrl
	ctx.lr = 0x82A01E0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A01E0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A01E10: 48000008  b 0x82a01e18
	pc = 0x82A01E18; continue 'dispatch;
            }
            0x82A01E14 => {
    //   block [0x82A01E14..0x82A01E18)
	// 82A01E14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A01E18; continue 'dispatch;
            }
            0x82A01E18 => {
    //   block [0x82A01E18..0x82A01E44)
	// 82A01E18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A01E1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01E20: 419A0024  beq cr6, 0x82a01e44
	if ctx.cr[6].eq {
	pc = 0x82A01E44; continue 'dispatch;
	}
	// 82A01E24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A01E28: 48286931  bl 0x82c88758
	ctx.lr = 0x82A01E2C;
	sub_82C88758(ctx, base);
	// 82A01E2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A01E30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A01E34: 4B873605  bl 0x82275438
	ctx.lr = 0x82A01E38;
	sub_82275438(ctx, base);
	// 82A01E38: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A01E3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A01E40: 482A761C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A01E44 => {
    //   block [0x82A01E44..0x82A01E50)
	// 82A01E44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A01E48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A01E4C: 482A7610  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01E50 size=220
    let mut pc: u32 = 0x82A01E50;
    'dispatch: loop {
        match pc {
            0x82A01E50 => {
    //   block [0x82A01E50..0x82A01F2C)
	// 82A01E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01E54: 482A75B9  bl 0x82ca940c
	ctx.lr = 0x82A01E58;
	sub_82CA93D0(ctx, base);
	// 82A01E58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01E5C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A01E60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A01E64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A01E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A01E6C: 388B21B0  addi r4, r11, 0x21b0
	ctx.r[4].s64 = ctx.r[11].s64 + 8624;
	// 82A01E70: 48286E69  bl 0x82c88cd8
	ctx.lr = 0x82A01E74;
	sub_82C88CD8(ctx, base);
	// 82A01E74: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01E78: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A01E7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01E80: 388A0E7C  addi r4, r10, 0xe7c
	ctx.r[4].s64 = ctx.r[10].s64 + 3708;
	// 82A01E84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A01E88: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A01E8C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A01E90: 4E800421  bctrl
	ctx.lr = 0x82A01E94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A01E94: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 82A01E98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01E9C: 388706D4  addi r4, r7, 0x6d4
	ctx.r[4].s64 = ctx.r[7].s64 + 1748;
	// 82A01EA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A01EA4: 4BA7E9AD  bl 0x82480850
	ctx.lr = 0x82A01EA8;
	sub_82480850(ctx, base);
	// 82A01EA8: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82A01EAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A01EB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01EB4: 388606D8  addi r4, r6, 0x6d8
	ctx.r[4].s64 = ctx.r[6].s64 + 1752;
	// 82A01EB8: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82A01EBC: 4BA7E995  bl 0x82480850
	ctx.lr = 0x82A01EC0;
	sub_82480850(ctx, base);
	// 82A01EC0: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 82A01EC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A01EC8: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82A01ECC: 3885C2C8  addi r4, r5, -0x3d38
	ctx.r[4].s64 = ctx.r[5].s64 + -15672;
	// 82A01ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01ED4: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82A01ED8: 7D7D5378  or r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82A01EDC: 4BA7E975  bl 0x82480850
	ctx.lr = 0x82A01EE0;
	sub_82480850(ctx, base);
	// 82A01EE0: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A01EE4: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A01EE8: 57A7063E  clrlwi r7, r29, 0x18
	ctx.r[7].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82A01EEC: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82A01EF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01EF4: 388921B8  addi r4, r9, 0x21b8
	ctx.r[4].s64 = ctx.r[9].s64 + 8632;
	// 82A01EF8: 7D1F3B78  or r31, r8, r7
	ctx.r[31].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 82A01EFC: 4BA7E955  bl 0x82480850
	ctx.lr = 0x82A01F00;
	sub_82480850(ctx, base);
	// 82A01F00: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01F04: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A01F08: 57E4063E  clrlwi r4, r31, 0x18
	ctx.r[4].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82A01F0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01F10: 7CBF2378  or r31, r5, r4
	ctx.r[31].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 82A01F14: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A01F18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A01F1C: 4E800421  bctrl
	ctx.lr = 0x82A01F20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A01F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01F24: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A01F28: 482A7534  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01F30 size=104
    let mut pc: u32 = 0x82A01F30;
    'dispatch: loop {
        match pc {
            0x82A01F30 => {
    //   block [0x82A01F30..0x82A01F78)
	// 82A01F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01F34: 482A74D5  bl 0x82ca9408
	ctx.lr = 0x82A01F38;
	sub_82CA93D0(ctx, base);
	// 82A01F38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01F3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A01F40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01F44: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01F48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01F4C: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01F50: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A01F54: 419A0024  beq cr6, 0x82a01f78
	if ctx.cr[6].eq {
	pc = 0x82A01F78; continue 'dispatch;
	}
	// 82A01F58: 4B7B5BC1  bl 0x821b7b18
	ctx.lr = 0x82A01F5C;
	sub_821B7B18(ctx, base);
	// 82A01F5C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A01F60: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A01F64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A01F68: 419A0010  beq cr6, 0x82a01f78
	if ctx.cr[6].eq {
	pc = 0x82A01F78; continue 'dispatch;
	}
	// 82A01F6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01F70: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A01F74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A01F78; continue 'dispatch;
            }
            0x82A01F78 => {
    //   block [0x82A01F78..0x82A01F98)
	// 82A01F78: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 82A01F7C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82A01F80: 4BE82831  bl 0x828847b0
	ctx.lr = 0x82A01F84;
	sub_828847B0(ctx, base);
	// 82A01F84: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A01F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01F8C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A01F90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A01F94: 482A74C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01F98 size=96
    let mut pc: u32 = 0x82A01F98;
    'dispatch: loop {
        match pc {
            0x82A01F98 => {
    //   block [0x82A01F98..0x82A01FD0)
	// 82A01F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01F9C: 482A7471  bl 0x82ca940c
	ctx.lr = 0x82A01FA0;
	sub_82CA93D0(ctx, base);
	// 82A01FA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01FA4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A01FA8: 3BABE48C  addi r29, r11, -0x1b74
	ctx.r[29].s64 = ctx.r[11].s64 + -7028;
	// 82A01FAC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01FB0: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A01FB4: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A01FB8: 556A0038  rlwinm r10, r11, 0, 0, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A01FBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A01FC0: 419A0030  beq cr6, 0x82a01ff0
	if ctx.cr[6].eq {
	pc = 0x82A01FF0; continue 'dispatch;
	}
	// 82A01FC4: 3BDFFFF8  addi r30, r31, -8
	ctx.r[30].s64 = ctx.r[31].s64 + -8;
	// 82A01FC8: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A01FCC: 419A001C  beq cr6, 0x82a01fe8
	if ctx.cr[6].eq {
	pc = 0x82A01FE8; continue 'dispatch;
	}
	pc = 0x82A01FD0; continue 'dispatch;
            }
            0x82A01FD0 => {
    //   block [0x82A01FD0..0x82A01FE8)
	// 82A01FD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01FD4: 4B7B5B45  bl 0x821b7b18
	ctx.lr = 0x82A01FD8;
	sub_821B7B18(ctx, base);
	// 82A01FD8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A01FDC: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A01FE0: 409AFFF0  bne cr6, 0x82a01fd0
	if !ctx.cr[6].eq {
	pc = 0x82A01FD0; continue 'dispatch;
	}
	// 82A01FE4: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A01FE8; continue 'dispatch;
            }
            0x82A01FE8 => {
    //   block [0x82A01FE8..0x82A01FF0)
	// 82A01FE8: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 82A01FEC: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A01FF0; continue 'dispatch;
            }
            0x82A01FF0 => {
    //   block [0x82A01FF0..0x82A01FF8)
	// 82A01FF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A01FF4: 482A7468  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01FF8 size=100
    let mut pc: u32 = 0x82A01FF8;
    'dispatch: loop {
        match pc {
            0x82A01FF8 => {
    //   block [0x82A01FF8..0x82A02030)
	// 82A01FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02004: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02008: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0200C: 3BEBE47C  addi r31, r11, -0x1b84
	ctx.r[31].s64 = ctx.r[11].s64 + -7044;
	// 82A02010: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02014: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A02018: 419A0018  beq cr6, 0x82a02030
	if ctx.cr[6].eq {
	pc = 0x82A02030; continue 'dispatch;
	}
	// 82A0201C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02020: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02024: 4800032D  bl 0x82a02350
	ctx.lr = 0x82A02028;
	sub_82A02350(ctx, base);
	// 82A02028: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0202C: 4B819D0D  bl 0x8221bd38
	ctx.lr = 0x82A02030;
	sub_8221BD38(ctx, base);
	pc = 0x82A02030; continue 'dispatch;
            }
            0x82A02030 => {
    //   block [0x82A02030..0x82A0205C)
	// 82A02030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A02034: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A02038: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0203C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A02040: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A02044: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82A02048: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0204C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A02050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A02054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02060 size=92
    let mut pc: u32 = 0x82A02060;
    'dispatch: loop {
        match pc {
            0x82A02060 => {
    //   block [0x82A02060..0x82A020A8)
	// 82A02060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0206C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02070: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A02074: 3940001C  li r10, 0x1c
	ctx.r[10].s64 = 28;
	// 82A02078: 3BEBE47C  addi r31, r11, -0x1b84
	ctx.r[31].s64 = ctx.r[11].s64 + -7044;
	// 82A0207C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02080: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02084: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A02088: 7D0953D7  divw. r8, r9, r10
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82A0208C: 4182001C  beq 0x82a020a8
	if ctx.cr[0].eq {
	pc = 0x82A020A8; continue 'dispatch;
	}
	// 82A02090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02094: 3885FFE4  addi r4, r5, -0x1c
	ctx.r[4].s64 = ctx.r[5].s64 + -28;
	// 82A02098: 480002B9  bl 0x82a02350
	ctx.lr = 0x82A0209C;
	sub_82A02350(ctx, base);
	// 82A0209C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A020A0: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 82A020A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A020A8; continue 'dispatch;
            }
            0x82A020A8 => {
    //   block [0x82A020A8..0x82A020BC)
	// 82A020A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A020AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A020B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A020B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A020B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A020C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A020C0 size=100
    let mut pc: u32 = 0x82A020C0;
    'dispatch: loop {
        match pc {
            0x82A020C0 => {
    //   block [0x82A020C0..0x82A020F8)
	// 82A020C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A020C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A020C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A020CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A020D0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A020D4: 3BEBE49C  addi r31, r11, -0x1b64
	ctx.r[31].s64 = ctx.r[11].s64 + -7012;
	// 82A020D8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A020DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A020E0: 419A0018  beq cr6, 0x82a020f8
	if ctx.cr[6].eq {
	pc = 0x82A020F8; continue 'dispatch;
	}
	// 82A020E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A020E8: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A020EC: 4808FE15  bl 0x82a91f00
	ctx.lr = 0x82A020F0;
	sub_82A91F00(ctx, base);
	// 82A020F0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A020F4: 4B819C45  bl 0x8221bd38
	ctx.lr = 0x82A020F8;
	sub_8221BD38(ctx, base);
	pc = 0x82A020F8; continue 'dispatch;
            }
            0x82A020F8 => {
    //   block [0x82A020F8..0x82A02124)
	// 82A020F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A020FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A02100: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A02104: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A02108: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0210C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82A02110: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A02114: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A02118: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0211C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02128 size=112
    let mut pc: u32 = 0x82A02128;
    'dispatch: loop {
        match pc {
            0x82A02128 => {
    //   block [0x82A02128..0x82A02198)
	// 82A02128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0212C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02134: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02138: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0213C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A02140: 3BEBE4F0  addi r31, r11, -0x1b10
	ctx.r[31].s64 = ctx.r[11].s64 + -6928;
	// 82A02144: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A02148: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0214C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A02150: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02154: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02158: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0215C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A02160: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A02164: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A02168: 48000DB9  bl 0x82a02f20
	ctx.lr = 0x82A0216C;
	sub_82A02F20(ctx, base);
	// 82A0216C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02170: 4B819BC9  bl 0x8221bd38
	ctx.lr = 0x82A02174;
	sub_8221BD38(ctx, base);
	// 82A02174: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A02178: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0217C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A02180: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A02184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A02188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0218C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A02190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02198 size=112
    let mut pc: u32 = 0x82A02198;
    'dispatch: loop {
        match pc {
            0x82A02198 => {
    //   block [0x82A02198..0x82A02208)
	// 82A02198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0219C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A021A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A021A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A021A8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A021AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A021B0: 3BEB1AA0  addi r31, r11, 0x1aa0
	ctx.r[31].s64 = ctx.r[11].s64 + 6816;
	// 82A021B4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A021B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A021BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A021C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A021C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A021C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A021CC: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A021D0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A021D4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A021D8: 48001179  bl 0x82a03350
	ctx.lr = 0x82A021DC;
	sub_82A03350(ctx, base);
	// 82A021DC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A021E0: 4B819B59  bl 0x8221bd38
	ctx.lr = 0x82A021E4;
	sub_8221BD38(ctx, base);
	// 82A021E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A021E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A021EC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A021F0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A021F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A021F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A021FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A02200: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02208 size=92
    let mut pc: u32 = 0x82A02208;
    'dispatch: loop {
        match pc {
            0x82A02208 => {
    //   block [0x82A02208..0x82A02264)
	// 82A02208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0220C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02214: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02218: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A0221C: 3BEB1AA0  addi r31, r11, 0x1aa0
	ctx.r[31].s64 = ctx.r[11].s64 + 6816;
	// 82A02220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02224: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02228: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0222C: 480188D5  bl 0x82a1ab00
	ctx.lr = 0x82A02230;
	sub_82A1AB00(ctx, base);
	// 82A02230: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02234: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A02238: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0223C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A02240: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02244: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02248: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0224C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A02250: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A02254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A02258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0225C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02268 size=232
    let mut pc: u32 = 0x82A02268;
    'dispatch: loop {
        match pc {
            0x82A02268 => {
    //   block [0x82A02268..0x82A022C8)
	// 82A02268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0226C: 482A7185  bl 0x82ca93f0
	ctx.lr = 0x82A02270;
	sub_82CA93D0(ctx, base);
	// 82A02270: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02274: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82A02278: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82A0227C: FAC100D0  std r22, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[22].u64 ) };
	// 82A02280: F8C100D8  std r6, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[6].u64 ) };
	// 82A02284: 814100D4  lwz r10, 0xd4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A02288: 816100DC  lwz r11, 0xdc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A0228C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A02290: 419A00B0  beq cr6, 0x82a02340
	if ctx.cr[6].eq {
	pc = 0x82A02340; continue 'dispatch;
	}
	// 82A02294: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82A02298: 3900001C  li r8, 0x1c
	ctx.r[8].s64 = 28;
	// 82A0229C: 3B29E47C  addi r25, r9, -0x1b84
	ctx.r[25].s64 = ctx.r[9].s64 + -7044;
	// 82A022A0: 83790008  lwz r27, 8(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A022A4: 7CEBD850  subf r7, r11, r27
	ctx.r[7].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 82A022A8: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A022AC: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 82A022B0: 1D26001C  mulli r9, r6, 0x1c
	ctx.r[9].s32 = ((ctx.r[6].s32 as i64 * 28 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A022B4: 7F095214  add r24, r9, r10
	ctx.r[24].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A022B8: 419A0074  beq cr6, 0x82a0232c
	if ctx.cr[6].eq {
	pc = 0x82A0232C; continue 'dispatch;
	}
	// 82A022BC: 3BCA0004  addi r30, r10, 4
	ctx.r[30].s64 = ctx.r[10].s64 + 4;
	// 82A022C0: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82A022C4: 7F4B5050  subf r26, r11, r10
	ctx.r[26].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x82A022C8; continue 'dispatch;
            }
            0x82A022C8 => {
    //   block [0x82A022C8..0x82A02300)
	// 82A022C8: 83BFFFFC  lwz r29, -4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A022CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A022D0: 839FFFF8  lwz r28, -8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A022D4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A022D8: 419A0028  beq cr6, 0x82a02300
	if ctx.cr[6].eq {
	pc = 0x82A02300; continue 'dispatch;
	}
	// 82A022DC: 387EFFFC  addi r3, r30, -4
	ctx.r[3].s64 = ctx.r[30].s64 + -4;
	// 82A022E0: 4B7B5839  bl 0x821b7b18
	ctx.lr = 0x82A022E4;
	sub_821B7B18(ctx, base);
	// 82A022E4: 939EFFFC  stw r28, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[28].u32 ) };
	// 82A022E8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A022EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A022F0: 419A0010  beq cr6, 0x82a02300
	if ctx.cr[6].eq {
	pc = 0x82A02300; continue 'dispatch;
	}
	// 82A022F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A022F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A022FC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A02300; continue 'dispatch;
            }
            0x82A02300 => {
    //   block [0x82A02300..0x82A0232C)
	// 82A02300: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02304: 7C7AFA14  add r3, r26, r31
	ctx.r[3].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	// 82A02308: 4BE824A9  bl 0x828847b0
	ctx.lr = 0x82A0230C;
	sub_828847B0(ctx, base);
	// 82A0230C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A02310: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82A02314: 395FFFF8  addi r10, r31, -8
	ctx.r[10].s64 = ctx.r[31].s64 + -8;
	// 82A02318: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A0231C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A02320: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82A02324: 409AFFA4  bne cr6, 0x82a022c8
	if !ctx.cr[6].eq {
	pc = 0x82A022C8; continue 'dispatch;
	}
	// 82A02328: 83790008  lwz r27, 8(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0232C; continue 'dispatch;
            }
            0x82A0232C => {
    //   block [0x82A0232C..0x82A02340)
	// 82A0232C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A02330: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A02334: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A02338: 48000019  bl 0x82a02350
	ctx.lr = 0x82A0233C;
	sub_82A02350(ctx, base);
	// 82A0233C: 93190008  stw r24, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	pc = 0x82A02340; continue 'dispatch;
            }
            0x82A02340 => {
    //   block [0x82A02340..0x82A02350)
	// 82A02340: FAD70000  std r22, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[22].u64 ) };
	// 82A02344: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A02348: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A0234C: 482A70F4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02350 size=88
    let mut pc: u32 = 0x82A02350;
    'dispatch: loop {
        match pc {
            0x82A02350 => {
    //   block [0x82A02350..0x82A02374)
	// 82A02350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0235C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02364: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A02368: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0236C: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A02370: 419A0020  beq cr6, 0x82a02390
	if ctx.cr[6].eq {
	pc = 0x82A02390; continue 'dispatch;
	}
	pc = 0x82A02374; continue 'dispatch;
            }
            0x82A02374 => {
    //   block [0x82A02374..0x82A02390)
	// 82A02374: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82A02378: 4B9DA4B1  bl 0x823dc828
	ctx.lr = 0x82A0237C;
	sub_823DC828(ctx, base);
	// 82A0237C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02380: 4B7B5799  bl 0x821b7b18
	ctx.lr = 0x82A02384;
	sub_821B7B18(ctx, base);
	// 82A02384: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82A02388: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0238C: 409AFFE8  bne cr6, 0x82a02374
	if !ctx.cr[6].eq {
	pc = 0x82A02374; continue 'dispatch;
	}
	pc = 0x82A02390; continue 'dispatch;
            }
            0x82A02390 => {
    //   block [0x82A02390..0x82A023A8)
	// 82A02390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A02394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A02398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0239C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A023A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A023A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A023A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A023A8 size=668
    let mut pc: u32 = 0x82A023A8;
    'dispatch: loop {
        match pc {
            0x82A023A8 => {
    //   block [0x82A023A8..0x82A02404)
	// 82A023A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A023AC: 482A7051  bl 0x82ca93fc
	ctx.lr = 0x82A023B0;
	sub_82CA93D0(ctx, base);
	// 82A023B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A023B4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A023B8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A023BC: 3BEBE4F0  addi r31, r11, -0x1b10
	ctx.r[31].s64 = ctx.r[11].s64 + -6928;
	// 82A023C0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A023C4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82A023C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A023CC: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82A023D0: FB4100D0  std r26, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[26].u64 ) };
	// 82A023D4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A023D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A023DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A023E0: 409A0024  bne cr6, 0x82a02404
	if !ctx.cr[6].eq {
	pc = 0x82A02404; continue 'dispatch;
	}
	// 82A023E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A023E8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A023EC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A023F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A023F4: 48000C3D  bl 0x82a03030
	ctx.lr = 0x82A023F8;
	sub_82A03030(ctx, base);
	// 82A023F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A023FC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A02400: 482A704C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A02404 => {
    //   block [0x82A02404..0x82A02420)
	// 82A02404: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02408: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A0240C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02410: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02414: 419A000C  beq cr6, 0x82a02420
	if ctx.cr[6].eq {
	pc = 0x82A02420; continue 'dispatch;
	}
	// 82A02418: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0241C: 419A0008  beq cr6, 0x82a02424
	if ctx.cr[6].eq {
	pc = 0x82A02424; continue 'dispatch;
	}
	pc = 0x82A02420; continue 'dispatch;
            }
            0x82A02420 => {
    //   block [0x82A02420..0x82A02424)
	// 82A02420: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A02424; continue 'dispatch;
            }
            0x82A02424 => {
    //   block [0x82A02424..0x82A02448)
	// 82A02424: 836100D4  lwz r27, 0xd4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A02428: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0242C: 409A004C  bne cr6, 0x82a02478
	if !ctx.cr[6].eq {
	pc = 0x82A02478; continue 'dispatch;
	}
	// 82A02430: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02434: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A02438: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A0243C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A02440: 41980008  blt cr6, 0x82a02448
	if ctx.cr[6].lt {
	pc = 0x82A02448; continue 'dispatch;
	}
	// 82A02444: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A02448; continue 'dispatch;
            }
            0x82A02448 => {
    //   block [0x82A02448..0x82A02478)
	// 82A02448: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0244C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02450: 419A01C4  beq cr6, 0x82a02614
	if ctx.cr[6].eq {
	pc = 0x82A02614; continue 'dispatch;
	}
	// 82A02454: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02458: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A0245C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A02460: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A02464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02468: 48000BC9  bl 0x82a03030
	ctx.lr = 0x82A0246C;
	sub_82A03030(ctx, base);
	// 82A0246C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02470: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A02474: 482A6FD8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A02478 => {
    //   block [0x82A02478..0x82A02488)
	// 82A02478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0247C: 419A000C  beq cr6, 0x82a02488
	if ctx.cr[6].eq {
	pc = 0x82A02488; continue 'dispatch;
	}
	// 82A02480: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02484: 419A0008  beq cr6, 0x82a0248c
	if ctx.cr[6].eq {
	pc = 0x82A0248C; continue 'dispatch;
	}
	pc = 0x82A02488; continue 'dispatch;
            }
            0x82A02488 => {
    //   block [0x82A02488..0x82A0248C)
	// 82A02488: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0248C; continue 'dispatch;
            }
            0x82A0248C => {
    //   block [0x82A0248C..0x82A024B0)
	// 82A0248C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02490: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A02494: 409A0048  bne cr6, 0x82a024dc
	if !ctx.cr[6].eq {
	pc = 0x82A024DC; continue 'dispatch;
	}
	// 82A02498: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0249C: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A024A0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A024A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A024A8: 41980008  blt cr6, 0x82a024b0
	if ctx.cr[6].lt {
	pc = 0x82A024B0; continue 'dispatch;
	}
	// 82A024AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A024B0; continue 'dispatch;
            }
            0x82A024B0 => {
    //   block [0x82A024B0..0x82A024DC)
	// 82A024B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A024B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A024B8: 419A015C  beq cr6, 0x82a02614
	if ctx.cr[6].eq {
	pc = 0x82A02614; continue 'dispatch;
	}
	// 82A024BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A024C0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A024C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A024C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A024CC: 48000B65  bl 0x82a03030
	ctx.lr = 0x82A024D0;
	sub_82A03030(ctx, base);
	// 82A024D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A024D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A024D8: 482A6F74  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A024DC => {
    //   block [0x82A024DC..0x82A024F0)
	// 82A024DC: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A024E0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A024E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A024E8: 41980008  blt cr6, 0x82a024f0
	if ctx.cr[6].lt {
	pc = 0x82A024F0; continue 'dispatch;
	}
	// 82A024EC: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82A024F0; continue 'dispatch;
            }
            0x82A024F0 => {
    //   block [0x82A024F0..0x82A02524)
	// 82A024F0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A024F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A024F8: 419A0070  beq cr6, 0x82a02568
	if ctx.cr[6].eq {
	pc = 0x82A02568; continue 'dispatch;
	}
	// 82A024FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02500: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82A02504: 480014CD  bl 0x82a039d0
	ctx.lr = 0x82A02508;
	sub_82A039D0(ctx, base);
	// 82A02508: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0250C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02510: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A02514: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A02518: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0251C: 41980008  blt cr6, 0x82a02524
	if ctx.cr[6].lt {
	pc = 0x82A02524; continue 'dispatch;
	}
	// 82A02520: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82A02524; continue 'dispatch;
            }
            0x82A02524 => {
    //   block [0x82A02524..0x82A02550)
	// 82A02524: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A02528: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0252C: 419A0038  beq cr6, 0x82a02564
	if ctx.cr[6].eq {
	pc = 0x82A02564; continue 'dispatch;
	}
	// 82A02530: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02534: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02538: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A0253C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02540: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A02544: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A02548: 409A00B8  bne cr6, 0x82a02600
	if !ctx.cr[6].eq {
	pc = 0x82A02600; continue 'dispatch;
	}
	// 82A0254C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A02550; continue 'dispatch;
            }
            0x82A02550 => {
    //   block [0x82A02550..0x82A02564)
	// 82A02550: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A02554: 48000ADD  bl 0x82a03030
	ctx.lr = 0x82A02558;
	sub_82A03030(ctx, base);
	// 82A02558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0255C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A02560: 482A6EEC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A02564 => {
    //   block [0x82A02564..0x82A02568)
	// 82A02564: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A02568; continue 'dispatch;
            }
            0x82A02568 => {
    //   block [0x82A02568..0x82A0257C)
	// 82A02568: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0256C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A02570: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A02574: 41980008  blt cr6, 0x82a0257c
	if ctx.cr[6].lt {
	pc = 0x82A0257C; continue 'dispatch;
	}
	// 82A02578: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A0257C; continue 'dispatch;
            }
            0x82A0257C => {
    //   block [0x82A0257C..0x82A025A8)
	// 82A0257C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A02580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02584: 419A0090  beq cr6, 0x82a02614
	if ctx.cr[6].eq {
	pc = 0x82A02614; continue 'dispatch;
	}
	// 82A02588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0258C: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82A02590: 48000D19  bl 0x82a032a8
	ctx.lr = 0x82A02594;
	sub_82A032A8(ctx, base);
	// 82A02594: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0259C: 419A000C  beq cr6, 0x82a025a8
	if ctx.cr[6].eq {
	pc = 0x82A025A8; continue 'dispatch;
	}
	// 82A025A0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A025A4: 419A0008  beq cr6, 0x82a025ac
	if ctx.cr[6].eq {
	pc = 0x82A025AC; continue 'dispatch;
	}
	pc = 0x82A025A8; continue 'dispatch;
            }
            0x82A025A8 => {
    //   block [0x82A025A8..0x82A025AC)
	// 82A025A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A025AC; continue 'dispatch;
            }
            0x82A025AC => {
    //   block [0x82A025AC..0x82A025D4)
	// 82A025AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A025B0: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A025B4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A025B8: 419A0028  beq cr6, 0x82a025e0
	if ctx.cr[6].eq {
	pc = 0x82A025E0; continue 'dispatch;
	}
	// 82A025BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A025C0: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A025C4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A025C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A025CC: 41980008  blt cr6, 0x82a025d4
	if ctx.cr[6].lt {
	pc = 0x82A025D4; continue 'dispatch;
	}
	// 82A025D0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A025D4; continue 'dispatch;
            }
            0x82A025D4 => {
    //   block [0x82A025D4..0x82A025E0)
	// 82A025D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A025D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A025DC: 419A0038  beq cr6, 0x82a02614
	if ctx.cr[6].eq {
	pc = 0x82A02614; continue 'dispatch;
	}
	pc = 0x82A025E0; continue 'dispatch;
            }
            0x82A025E0 => {
    //   block [0x82A025E0..0x82A02600)
	// 82A025E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A025E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A025E8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A025EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A025F0: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A025F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A025F8: 419AFF58  beq cr6, 0x82a02550
	if ctx.cr[6].eq {
	pc = 0x82A02550; continue 'dispatch;
	}
	// 82A025FC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A02600; continue 'dispatch;
            }
            0x82A02600 => {
    //   block [0x82A02600..0x82A02614)
	// 82A02600: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A02604: 48000A2D  bl 0x82a03030
	ctx.lr = 0x82A02608;
	sub_82A03030(ctx, base);
	// 82A02608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0260C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A02610: 482A6E3C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A02614 => {
    //   block [0x82A02614..0x82A02644)
	// 82A02614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02618: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0261C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A02620: 480007A1  bl 0x82a02dc0
	ctx.lr = 0x82A02624;
	sub_82A02DC0(ctx, base);
	// 82A02624: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A02628: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0262C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02630: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A02634: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02638: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0263C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A02640: 482A6E0C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A02648 size=104
    let mut pc: u32 = 0x82A02648;
    'dispatch: loop {
        match pc {
            0x82A02648 => {
    //   block [0x82A02648..0x82A02668)
	// 82A02648: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0264C: 390BE4F0  addi r8, r11, -0x1b10
	ctx.r[8].s64 = ctx.r[11].s64 + -6928;
	// 82A02650: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02654: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02658: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A0265C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A02660: 409A0044  bne cr6, 0x82a026a4
	if !ctx.cr[6].eq {
	pc = 0x82A026A4; continue 'dispatch;
	}
	// 82A02664: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A02668; continue 'dispatch;
            }
            0x82A02668 => {
    //   block [0x82A02668..0x82A0267C)
	// 82A02668: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0266C: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82A02670: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A02674: 41980008  blt cr6, 0x82a0267c
	if ctx.cr[6].lt {
	pc = 0x82A0267C; continue 'dispatch;
	}
	// 82A02678: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A0267C; continue 'dispatch;
            }
            0x82A0267C => {
    //   block [0x82A0267C..0x82A02690)
	// 82A0267C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A02680: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A02684: 419A000C  beq cr6, 0x82a02690
	if ctx.cr[6].eq {
	pc = 0x82A02690; continue 'dispatch;
	}
	// 82A02688: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0268C: 4800000C  b 0x82a02698
	pc = 0x82A02698; continue 'dispatch;
            }
            0x82A02690 => {
    //   block [0x82A02690..0x82A02698)
	// 82A02690: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A02694: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A02698; continue 'dispatch;
            }
            0x82A02698 => {
    //   block [0x82A02698..0x82A026A4)
	// 82A02698: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A0269C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A026A0: 419AFFC8  beq cr6, 0x82a02668
	if ctx.cr[6].eq {
	pc = 0x82A02668; continue 'dispatch;
	}
	pc = 0x82A026A4; continue 'dispatch;
            }
            0x82A026A4 => {
    //   block [0x82A026A4..0x82A026B0)
	// 82A026A4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A026A8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A026AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A026B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A026B0 size=80
    let mut pc: u32 = 0x82A026B0;
    'dispatch: loop {
        match pc {
            0x82A026B0 => {
    //   block [0x82A026B0..0x82A026D0)
	// 82A026B0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A026B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A026B8: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A026BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A026C0: 892A0011  lbz r9, 0x11(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A026C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A026C8: 409A0008  bne cr6, 0x82a026d0
	if !ctx.cr[6].eq {
	pc = 0x82A026D0; continue 'dispatch;
	}
	// 82A026CC: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A026D0; continue 'dispatch;
            }
            0x82A026D0 => {
    //   block [0x82A026D0..0x82A02700)
	// 82A026D0: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82A026D4: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A026D8: 390A1AA0  addi r8, r10, 0x1aa0
	ctx.r[8].s64 = ctx.r[10].s64 + 6816;
	// 82A026DC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A026E0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A026E4: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A026E8: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A026EC: 409A0014  bne cr6, 0x82a02700
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A02700);
		return;
	}
	// 82A026F0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A026F4: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82A026F8: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A026FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A02730 size=80
    let mut pc: u32 = 0x82A02730;
    'dispatch: loop {
        match pc {
            0x82A02730 => {
    //   block [0x82A02730..0x82A02750)
	// 82A02730: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02734: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02738: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0273C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02740: 892A0011  lbz r9, 0x11(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A02744: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A02748: 409A0008  bne cr6, 0x82a02750
	if !ctx.cr[6].eq {
	pc = 0x82A02750; continue 'dispatch;
	}
	// 82A0274C: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A02750; continue 'dispatch;
            }
            0x82A02750 => {
    //   block [0x82A02750..0x82A02780)
	// 82A02750: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82A02754: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02758: 390A1AA0  addi r8, r10, 0x1aa0
	ctx.r[8].s64 = ctx.r[10].s64 + 6816;
	// 82A0275C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A02760: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02764: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02768: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A0276C: 409A0014  bne cr6, 0x82a02780
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A02780);
		return;
	}
	// 82A02770: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A02774: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A02778: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0277C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A027B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A027B0 size=788
    let mut pc: u32 = 0x82A027B0;
    'dispatch: loop {
        match pc {
            0x82A027B0 => {
    //   block [0x82A027B0..0x82A027EC)
	// 82A027B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A027B4: 482A6C45  bl 0x82ca93f8
	ctx.lr = 0x82A027B8;
	sub_82CA93D0(ctx, base);
	// 82A027B8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A027BC: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 82A027C0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A027C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A027C8: 4B76EF21  bl 0x821716e8
	ctx.lr = 0x82A027CC;
	sub_821716E8(ctx, base);
	// 82A027CC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A027D0: 3B00001C  li r24, 0x1c
	ctx.r[24].s64 = 28;
	// 82A027D4: 3B4BE47C  addi r26, r11, -0x1b84
	ctx.r[26].s64 = ctx.r[11].s64 + -7044;
	// 82A027D8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A027DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A027E0: 409A000C  bne cr6, 0x82a027ec
	if !ctx.cr[6].eq {
	pc = 0x82A027EC; continue 'dispatch;
	}
	// 82A027E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A027E8: 48000010  b 0x82a027f8
	pc = 0x82A027F8; continue 'dispatch;
            }
            0x82A027EC => {
    //   block [0x82A027EC..0x82A027F8)
	// 82A027EC: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A027F0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A027F4: 7D4AC3D6  divw r10, r10, r24
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[24].s32;
	pc = 0x82A027F8; continue 'dispatch;
            }
            0x82A027F8 => {
    //   block [0x82A027F8..0x82A02820)
	// 82A027F8: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A027FC: 3D200924  lis r9, 0x924
	ctx.r[9].s64 = 153354240;
	// 82A02800: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A02804: 61299249  ori r9, r9, 0x9249
	ctx.r[9].u64 = ctx.r[9].u64 | 37449;
	// 82A02808: 7CE8C3D6  divw r7, r8, r24
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	// 82A0280C: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A02810: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 82A02814: 4098000C  bge cr6, 0x82a02820
	if !ctx.cr[6].lt {
	pc = 0x82A02820; continue 'dispatch;
	}
	// 82A02818: 48044CB1  bl 0x82a474c8
	ctx.lr = 0x82A0281C;
	sub_82A474C8(ctx, base);
	// 82A0281C: 48000290  b 0x82a02aac
	pc = 0x82A02AAC; continue 'dispatch;
            }
            0x82A02820 => {
    //   block [0x82A02820..0x82A0284C)
	// 82A02820: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A02824: 7D08C3D6  divw r8, r8, r24
	ctx.r[8].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	// 82A02828: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 82A0282C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A02830: 40980134  bge cr6, 0x82a02964
	if !ctx.cr[6].lt {
	pc = 0x82A02964; continue 'dispatch;
	}
	// 82A02834: 5548F87E  srwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A02838: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A0283C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A02840: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A02844: 41980008  blt cr6, 0x82a0284c
	if ctx.cr[6].lt {
	pc = 0x82A0284C; continue 'dispatch;
	}
	// 82A02848: 7F285214  add r25, r8, r10
	ctx.r[25].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	pc = 0x82A0284C; continue 'dispatch;
            }
            0x82A0284C => {
    //   block [0x82A0284C..0x82A0286C)
	// 82A0284C: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A02850: 7D4AC3D6  divw r10, r10, r24
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[24].s32;
	// 82A02854: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82A02858: 7F194840  cmplw cr6, r25, r9
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0285C: 40980010  bge cr6, 0x82a0286c
	if !ctx.cr[6].lt {
	pc = 0x82A0286C; continue 'dispatch;
	}
	// 82A02860: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A02864: 7D6BC3D6  divw r11, r11, r24
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 82A02868: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	pc = 0x82A0286C; continue 'dispatch;
            }
            0x82A0286C => {
    //   block [0x82A0286C..0x82A02894)
	// 82A0286C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A02870: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A02874: 4823FD1D  bl 0x82c42590
	ctx.lr = 0x82A02878;
	sub_82C42590(ctx, base);
	// 82A02878: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0287C: 838100DC  lwz r28, 0xdc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A02880: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A02884: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A02888: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0288C: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A02890: 419A002C  beq cr6, 0x82a028bc
	if ctx.cr[6].eq {
	pc = 0x82A028BC; continue 'dispatch;
	}
	pc = 0x82A02894; continue 'dispatch;
            }
            0x82A02894 => {
    //   block [0x82A02894..0x82A028A8)
	// 82A02894: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A02898: 419A0010  beq cr6, 0x82a028a8
	if ctx.cr[6].eq {
	pc = 0x82A028A8; continue 'dispatch;
	}
	// 82A0289C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A028A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A028A4: 4B76EE45  bl 0x821716e8
	ctx.lr = 0x82A028A8;
	sub_821716E8(ctx, base);
	pc = 0x82A028A8; continue 'dispatch;
            }
            0x82A028A8 => {
    //   block [0x82A028A8..0x82A028BC)
	// 82A028A8: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82A028AC: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82A028B0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A028B4: 409AFFE0  bne cr6, 0x82a02894
	if !ctx.cr[6].eq {
	pc = 0x82A02894; continue 'dispatch;
	}
	// 82A028B8: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A028BC; continue 'dispatch;
            }
            0x82A028BC => {
    //   block [0x82A028BC..0x82A028D4)
	// 82A028BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A028C0: 419A0014  beq cr6, 0x82a028d4
	if ctx.cr[6].eq {
	pc = 0x82A028D4; continue 'dispatch;
	}
	// 82A028C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A028C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A028CC: 4B76EE1D  bl 0x821716e8
	ctx.lr = 0x82A028D0;
	sub_821716E8(ctx, base);
	// 82A028D0: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A028D4; continue 'dispatch;
            }
            0x82A028D4 => {
    //   block [0x82A028D4..0x82A028F0)
	// 82A028D4: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A028D8: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82A028DC: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A028E0: 419A003C  beq cr6, 0x82a0291c
	if ctx.cr[6].eq {
	pc = 0x82A0291C; continue 'dispatch;
	}
	// 82A028E4: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A028E8: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A028EC: 3BEBFFE4  addi r31, r11, -0x1c
	ctx.r[31].s64 = ctx.r[11].s64 + -28;
	pc = 0x82A028F0; continue 'dispatch;
            }
            0x82A028F0 => {
    //   block [0x82A028F0..0x82A02904)
	// 82A028F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A028F4: 419A0010  beq cr6, 0x82a02904
	if ctx.cr[6].eq {
	pc = 0x82A02904; continue 'dispatch;
	}
	// 82A028F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A028FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02900: 4B76EDE9  bl 0x821716e8
	ctx.lr = 0x82A02904;
	sub_821716E8(ctx, base);
	pc = 0x82A02904; continue 'dispatch;
            }
            0x82A02904 => {
    //   block [0x82A02904..0x82A0291C)
	// 82A02904: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82A02908: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82A0290C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A02910: 409AFFE0  bne cr6, 0x82a028f0
	if !ctx.cr[6].eq {
	pc = 0x82A028F0; continue 'dispatch;
	}
	// 82A02914: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02918: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0291C; continue 'dispatch;
            }
            0x82A0291C => {
    //   block [0x82A0291C..0x82A02944)
	// 82A0291C: 7D64E850  subf r11, r4, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[4].s64;
	// 82A02920: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A02924: 7D6BC3D6  divw r11, r11, r24
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 82A02928: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82A0292C: 419A0018  beq cr6, 0x82a02944
	if ctx.cr[6].eq {
	pc = 0x82A02944; continue 'dispatch;
	}
	// 82A02930: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A02934: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A02938: 4BFFFA19  bl 0x82a02350
	ctx.lr = 0x82A0293C;
	sub_82A02350(ctx, base);
	// 82A0293C: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02940: 4B8193F9  bl 0x8221bd38
	ctx.lr = 0x82A02944;
	sub_8221BD38(ctx, base);
	pc = 0x82A02944; continue 'dispatch;
            }
            0x82A02944 => {
    //   block [0x82A02944..0x82A02964)
	// 82A02944: 1D79001C  mulli r11, r25, 0x1c
	ctx.r[11].s32 = ((ctx.r[25].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A02948: 937A0004  stw r27, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A0294C: 1D5F001C  mulli r10, r31, 0x1c
	ctx.r[10].s32 = ((ctx.r[31].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A02950: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A02954: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A02958: 917A000C  stw r11, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0295C: 915A0008  stw r10, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A02960: 4800014C  b 0x82a02aac
	pc = 0x82A02AAC; continue 'dispatch;
            }
            0x82A02964 => {
    //   block [0x82A02964..0x82A02988)
	// 82A02964: 836100DC  lwz r27, 0xdc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A02968: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0296C: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 82A02970: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A02974: 40980084  bge cr6, 0x82a029f8
	if !ctx.cr[6].lt {
	pc = 0x82A029F8; continue 'dispatch;
	}
	// 82A02978: 3BDB001C  addi r30, r27, 0x1c
	ctx.r[30].s64 = ctx.r[27].s64 + 28;
	// 82A0297C: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02980: 419A0030  beq cr6, 0x82a029b0
	if ctx.cr[6].eq {
	pc = 0x82A029B0; continue 'dispatch;
	}
	// 82A02984: 3BBEFFE4  addi r29, r30, -0x1c
	ctx.r[29].s64 = ctx.r[30].s64 + -28;
	pc = 0x82A02988; continue 'dispatch;
            }
            0x82A02988 => {
    //   block [0x82A02988..0x82A0299C)
	// 82A02988: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0298C: 419A0010  beq cr6, 0x82a0299c
	if ctx.cr[6].eq {
	pc = 0x82A0299C; continue 'dispatch;
	}
	// 82A02990: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A02994: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02998: 4B76ED51  bl 0x821716e8
	ctx.lr = 0x82A0299C;
	sub_821716E8(ctx, base);
	pc = 0x82A0299C; continue 'dispatch;
            }
            0x82A0299C => {
    //   block [0x82A0299C..0x82A029B0)
	// 82A0299C: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 82A029A0: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82A029A4: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A029A8: 409AFFE0  bne cr6, 0x82a02988
	if !ctx.cr[6].eq {
	pc = 0x82A02988; continue 'dispatch;
	}
	// 82A029AC: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A029B0; continue 'dispatch;
            }
            0x82A029B0 => {
    //   block [0x82A029B0..0x82A029C4)
	// 82A029B0: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A029B4: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 82A029B8: 23CA0001  subfic r30, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[30].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A029BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A029C0: 419A0028  beq cr6, 0x82a029e8
	if ctx.cr[6].eq {
	pc = 0x82A029E8; continue 'dispatch;
	}
	pc = 0x82A029C4; continue 'dispatch;
            }
            0x82A029C4 => {
    //   block [0x82A029C4..0x82A029D8)
	// 82A029C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A029C8: 419A0010  beq cr6, 0x82a029d8
	if ctx.cr[6].eq {
	pc = 0x82A029D8; continue 'dispatch;
	}
	// 82A029CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A029D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A029D4: 4B76ED15  bl 0x821716e8
	ctx.lr = 0x82A029D8;
	sub_821716E8(ctx, base);
	pc = 0x82A029D8; continue 'dispatch;
            }
            0x82A029D8 => {
    //   block [0x82A029D8..0x82A029E8)
	// 82A029D8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A029DC: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82A029E0: 4082FFE4  bne 0x82a029c4
	if !ctx.cr[0].eq {
	pc = 0x82A029C4; continue 'dispatch;
	}
	// 82A029E4: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A029E8; continue 'dispatch;
            }
            0x82A029E8 => {
    //   block [0x82A029E8..0x82A029F8)
	// 82A029E8: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82A029EC: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A029F0: 388BFFE4  addi r4, r11, -0x1c
	ctx.r[4].s64 = ctx.r[11].s64 + -28;
	// 82A029F4: 480000AC  b 0x82a02aa0
	pc = 0x82A02AA0; continue 'dispatch;
            }
            0x82A029F8 => {
    //   block [0x82A029F8..0x82A02A0C)
	// 82A029F8: 3B9FFFE4  addi r28, r31, -0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + -28;
	// 82A029FC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A02A00: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A02A04: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02A08: 419A0028  beq cr6, 0x82a02a30
	if ctx.cr[6].eq {
	pc = 0x82A02A30; continue 'dispatch;
	}
	pc = 0x82A02A0C; continue 'dispatch;
            }
            0x82A02A0C => {
    //   block [0x82A02A0C..0x82A02A20)
	// 82A02A0C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A02A10: 419A0010  beq cr6, 0x82a02a20
	if ctx.cr[6].eq {
	pc = 0x82A02A20; continue 'dispatch;
	}
	// 82A02A14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A02A18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02A1C: 4B76ECCD  bl 0x821716e8
	ctx.lr = 0x82A02A20;
	sub_821716E8(ctx, base);
	pc = 0x82A02A20; continue 'dispatch;
            }
            0x82A02A20 => {
    //   block [0x82A02A20..0x82A02A30)
	// 82A02A20: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 82A02A24: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82A02A28: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02A2C: 409AFFE0  bne cr6, 0x82a02a0c
	if !ctx.cr[6].eq {
	pc = 0x82A02A0C; continue 'dispatch;
	}
	pc = 0x82A02A30; continue 'dispatch;
            }
            0x82A02A30 => {
    //   block [0x82A02A30..0x82A02A40)
	// 82A02A30: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A02A34: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A02A38: 419A0064  beq cr6, 0x82a02a9c
	if ctx.cr[6].eq {
	pc = 0x82A02A9C; continue 'dispatch;
	}
	// 82A02A3C: 3BFFFFEC  addi r31, r31, -0x14
	ctx.r[31].s64 = ctx.r[31].s64 + -20;
	pc = 0x82A02A40; continue 'dispatch;
            }
            0x82A02A40 => {
    //   block [0x82A02A40..0x82A02A7C)
	// 82A02A40: 3BFFFFE4  addi r31, r31, -0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + -28;
	// 82A02A44: 83DFFFFC  lwz r30, -4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A02A48: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A02A4C: 83BFFFF8  lwz r29, -8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A02A50: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A02A54: 419A0028  beq cr6, 0x82a02a7c
	if ctx.cr[6].eq {
	pc = 0x82A02A7C; continue 'dispatch;
	}
	// 82A02A58: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82A02A5C: 4B7B50BD  bl 0x821b7b18
	ctx.lr = 0x82A02A60;
	sub_821B7B18(ctx, base);
	// 82A02A60: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82A02A64: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82A02A68: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A02A6C: 419A0010  beq cr6, 0x82a02a7c
	if ctx.cr[6].eq {
	pc = 0x82A02A7C; continue 'dispatch;
	}
	// 82A02A70: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02A74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A02A78: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A02A7C; continue 'dispatch;
            }
            0x82A02A7C => {
    //   block [0x82A02A7C..0x82A02A9C)
	// 82A02A7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02A80: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82A02A84: 4BE81D2D  bl 0x828847b0
	ctx.lr = 0x82A02A88;
	sub_828847B0(ctx, base);
	// 82A02A88: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A02A8C: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 82A02A90: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A02A94: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82A02A98: 409AFFA8  bne cr6, 0x82a02a40
	if !ctx.cr[6].eq {
	pc = 0x82A02A40; continue 'dispatch;
	}
	pc = 0x82A02A9C; continue 'dispatch;
            }
            0x82A02A9C => {
    //   block [0x82A02A9C..0x82A02AA0)
	// 82A02A9C: 389B001C  addi r4, r27, 0x1c
	ctx.r[4].s64 = ctx.r[27].s64 + 28;
	pc = 0x82A02AA0; continue 'dispatch;
            }
            0x82A02AA0 => {
    //   block [0x82A02AA0..0x82A02AAC)
	// 82A02AA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A02AA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A02AA8: 48001079  bl 0x82a03b20
	ctx.lr = 0x82A02AAC;
	sub_82A03B20(ctx, base);
	pc = 0x82A02AAC; continue 'dispatch;
            }
            0x82A02AAC => {
    //   block [0x82A02AAC..0x82A02AC4)
	// 82A02AAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A02AB0: 4B9D9D79  bl 0x823dc828
	ctx.lr = 0x82A02AB4;
	sub_823DC828(ctx, base);
	// 82A02AB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02AB8: 4B7B5061  bl 0x821b7b18
	ctx.lr = 0x82A02ABC;
	sub_821B7B18(ctx, base);
	// 82A02ABC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A02AC0: 482A6988  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02AC8 size=760
    let mut pc: u32 = 0x82A02AC8;
    'dispatch: loop {
        match pc {
            0x82A02AC8 => {
    //   block [0x82A02AC8..0x82A02B00)
	// 82A02AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02ACC: 482A6931  bl 0x82ca93fc
	ctx.lr = 0x82A02AD0;
	sub_82CA93D0(ctx, base);
	// 82A02AD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02AD4: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A02AD8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A02ADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02AE0: 4B794291  bl 0x82196d70
	ctx.lr = 0x82A02AE4;
	sub_82196D70(ctx, base);
	// 82A02AE4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A02AE8: 3B6BE49C  addi r27, r11, -0x1b64
	ctx.r[27].s64 = ctx.r[11].s64 + -7012;
	// 82A02AEC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02AF4: 409A000C  bne cr6, 0x82a02b00
	if !ctx.cr[6].eq {
	pc = 0x82A02B00; continue 'dispatch;
	}
	// 82A02AF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A02AFC: 48000010  b 0x82a02b0c
	pc = 0x82A02B0C; continue 'dispatch;
            }
            0x82A02B00 => {
    //   block [0x82A02B00..0x82A02B0C)
	// 82A02B00: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A02B04: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A02B08: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82A02B0C; continue 'dispatch;
            }
            0x82A02B0C => {
    //   block [0x82A02B0C..0x82A02B34)
	// 82A02B0C: 83FB0008  lwz r31, 8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02B10: 3D201FFF  lis r9, 0x1fff
	ctx.r[9].s64 = 536805376;
	// 82A02B14: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A02B18: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 82A02B1C: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82A02B20: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A02B24: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 82A02B28: 4098000C  bge cr6, 0x82a02b34
	if !ctx.cr[6].lt {
	pc = 0x82A02B34; continue 'dispatch;
	}
	// 82A02B2C: 4804499D  bl 0x82a474c8
	ctx.lr = 0x82A02B30;
	sub_82A474C8(ctx, base);
	// 82A02B30: 48000274  b 0x82a02da4
	pc = 0x82A02DA4; continue 'dispatch;
            }
            0x82A02B34 => {
    //   block [0x82A02B34..0x82A02B60)
	// 82A02B34: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A02B38: 7D081E70  srawi r8, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82A02B3C: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 82A02B40: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A02B44: 40980134  bge cr6, 0x82a02c78
	if !ctx.cr[6].lt {
	pc = 0x82A02C78; continue 'dispatch;
	}
	// 82A02B48: 5548F87E  srwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A02B4C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A02B50: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A02B54: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A02B58: 41980008  blt cr6, 0x82a02b60
	if ctx.cr[6].lt {
	pc = 0x82A02B60; continue 'dispatch;
	}
	// 82A02B5C: 7F285214  add r25, r8, r10
	ctx.r[25].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	pc = 0x82A02B60; continue 'dispatch;
            }
            0x82A02B60 => {
    //   block [0x82A02B60..0x82A02B80)
	// 82A02B60: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A02B64: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82A02B68: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82A02B6C: 7F194840  cmplw cr6, r25, r9
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A02B70: 40980010  bge cr6, 0x82a02b80
	if !ctx.cr[6].lt {
	pc = 0x82A02B80; continue 'dispatch;
	}
	// 82A02B74: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A02B78: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A02B7C: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	pc = 0x82A02B80; continue 'dispatch;
            }
            0x82A02B80 => {
    //   block [0x82A02B80..0x82A02BA8)
	// 82A02B80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A02B84: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A02B88: 480ADDD1  bl 0x82ab0958
	ctx.lr = 0x82A02B8C;
	sub_82AB0958(ctx, base);
	// 82A02B8C: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02B90: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A02B94: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A02B98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A02B9C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82A02BA0: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A02BA4: 419A002C  beq cr6, 0x82a02bd0
	if ctx.cr[6].eq {
	pc = 0x82A02BD0; continue 'dispatch;
	}
	pc = 0x82A02BA8; continue 'dispatch;
            }
            0x82A02BA8 => {
    //   block [0x82A02BA8..0x82A02BBC)
	// 82A02BA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A02BAC: 419A0010  beq cr6, 0x82a02bbc
	if ctx.cr[6].eq {
	pc = 0x82A02BBC; continue 'dispatch;
	}
	// 82A02BB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A02BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02BB8: 4B7941B9  bl 0x82196d70
	ctx.lr = 0x82A02BBC;
	sub_82196D70(ctx, base);
	pc = 0x82A02BBC; continue 'dispatch;
            }
            0x82A02BBC => {
    //   block [0x82A02BBC..0x82A02BD0)
	// 82A02BBC: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A02BC0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A02BC4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A02BC8: 409AFFE0  bne cr6, 0x82a02ba8
	if !ctx.cr[6].eq {
	pc = 0x82A02BA8; continue 'dispatch;
	}
	// 82A02BCC: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A02BD0; continue 'dispatch;
            }
            0x82A02BD0 => {
    //   block [0x82A02BD0..0x82A02BE8)
	// 82A02BD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A02BD4: 419A0014  beq cr6, 0x82a02be8
	if ctx.cr[6].eq {
	pc = 0x82A02BE8; continue 'dispatch;
	}
	// 82A02BD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A02BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02BE0: 4B794191  bl 0x82196d70
	ctx.lr = 0x82A02BE4;
	sub_82196D70(ctx, base);
	// 82A02BE4: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A02BE8; continue 'dispatch;
            }
            0x82A02BE8 => {
    //   block [0x82A02BE8..0x82A02C04)
	// 82A02BE8: 83BB0008  lwz r29, 8(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02BEC: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82A02BF0: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A02BF4: 419A003C  beq cr6, 0x82a02c30
	if ctx.cr[6].eq {
	pc = 0x82A02C30; continue 'dispatch;
	}
	// 82A02BF8: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A02BFC: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A02C00: 3BEBFFF8  addi r31, r11, -8
	ctx.r[31].s64 = ctx.r[11].s64 + -8;
	pc = 0x82A02C04; continue 'dispatch;
            }
            0x82A02C04 => {
    //   block [0x82A02C04..0x82A02C18)
	// 82A02C04: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A02C08: 419A0010  beq cr6, 0x82a02c18
	if ctx.cr[6].eq {
	pc = 0x82A02C18; continue 'dispatch;
	}
	// 82A02C0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02C10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02C14: 4B79415D  bl 0x82196d70
	ctx.lr = 0x82A02C18;
	sub_82196D70(ctx, base);
	pc = 0x82A02C18; continue 'dispatch;
            }
            0x82A02C18 => {
    //   block [0x82A02C18..0x82A02C30)
	// 82A02C18: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A02C1C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A02C20: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A02C24: 409AFFE0  bne cr6, 0x82a02c04
	if !ctx.cr[6].eq {
	pc = 0x82A02C04; continue 'dispatch;
	}
	// 82A02C28: 83BB0008  lwz r29, 8(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02C2C: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A02C30; continue 'dispatch;
            }
            0x82A02C30 => {
    //   block [0x82A02C30..0x82A02C58)
	// 82A02C30: 7D64E850  subf r11, r4, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[4].s64;
	// 82A02C34: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A02C38: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A02C3C: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82A02C40: 419A0018  beq cr6, 0x82a02c58
	if ctx.cr[6].eq {
	pc = 0x82A02C58; continue 'dispatch;
	}
	// 82A02C44: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A02C48: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A02C4C: 4808F2B5  bl 0x82a91f00
	ctx.lr = 0x82A02C50;
	sub_82A91F00(ctx, base);
	// 82A02C50: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02C54: 4B8190E5  bl 0x8221bd38
	ctx.lr = 0x82A02C58;
	sub_8221BD38(ctx, base);
	pc = 0x82A02C58; continue 'dispatch;
            }
            0x82A02C58 => {
    //   block [0x82A02C58..0x82A02C78)
	// 82A02C58: 572B1838  slwi r11, r25, 3
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A02C5C: 935B0004  stw r26, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82A02C60: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A02C64: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A02C68: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82A02C6C: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A02C70: 915B0008  stw r10, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A02C74: 48000130  b 0x82a02da4
	pc = 0x82A02DA4; continue 'dispatch;
            }
            0x82A02C78 => {
    //   block [0x82A02C78..0x82A02C9C)
	// 82A02C78: 834100BC  lwz r26, 0xbc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A02C7C: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A02C80: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A02C84: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A02C88: 40980084  bge cr6, 0x82a02d0c
	if !ctx.cr[6].lt {
	pc = 0x82A02D0C; continue 'dispatch;
	}
	// 82A02C8C: 3BDA0008  addi r30, r26, 8
	ctx.r[30].s64 = ctx.r[26].s64 + 8;
	// 82A02C90: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02C94: 419A0030  beq cr6, 0x82a02cc4
	if ctx.cr[6].eq {
	pc = 0x82A02CC4; continue 'dispatch;
	}
	// 82A02C98: 3BBEFFF8  addi r29, r30, -8
	ctx.r[29].s64 = ctx.r[30].s64 + -8;
	pc = 0x82A02C9C; continue 'dispatch;
            }
            0x82A02C9C => {
    //   block [0x82A02C9C..0x82A02CB0)
	// 82A02C9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A02CA0: 419A0010  beq cr6, 0x82a02cb0
	if ctx.cr[6].eq {
	pc = 0x82A02CB0; continue 'dispatch;
	}
	// 82A02CA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A02CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02CAC: 4B7940C5  bl 0x82196d70
	ctx.lr = 0x82A02CB0;
	sub_82196D70(ctx, base);
	pc = 0x82A02CB0; continue 'dispatch;
            }
            0x82A02CB0 => {
    //   block [0x82A02CB0..0x82A02CC4)
	// 82A02CB0: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A02CB4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A02CB8: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02CBC: 409AFFE0  bne cr6, 0x82a02c9c
	if !ctx.cr[6].eq {
	pc = 0x82A02C9C; continue 'dispatch;
	}
	// 82A02CC0: 83FB0008  lwz r31, 8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A02CC4; continue 'dispatch;
            }
            0x82A02CC4 => {
    //   block [0x82A02CC4..0x82A02CD8)
	// 82A02CC4: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A02CC8: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A02CCC: 23CA0001  subfic r30, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[30].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A02CD0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A02CD4: 419A0028  beq cr6, 0x82a02cfc
	if ctx.cr[6].eq {
	pc = 0x82A02CFC; continue 'dispatch;
	}
	pc = 0x82A02CD8; continue 'dispatch;
            }
            0x82A02CD8 => {
    //   block [0x82A02CD8..0x82A02CEC)
	// 82A02CD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A02CDC: 419A0010  beq cr6, 0x82a02cec
	if ctx.cr[6].eq {
	pc = 0x82A02CEC; continue 'dispatch;
	}
	// 82A02CE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A02CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02CE8: 4B794089  bl 0x82196d70
	ctx.lr = 0x82A02CEC;
	sub_82196D70(ctx, base);
	pc = 0x82A02CEC; continue 'dispatch;
            }
            0x82A02CEC => {
    //   block [0x82A02CEC..0x82A02CFC)
	// 82A02CEC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A02CF0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A02CF4: 4082FFE4  bne 0x82a02cd8
	if !ctx.cr[0].eq {
	pc = 0x82A02CD8; continue 'dispatch;
	}
	// 82A02CF8: 83FB0008  lwz r31, 8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A02CFC; continue 'dispatch;
            }
            0x82A02CFC => {
    //   block [0x82A02CFC..0x82A02D0C)
	// 82A02CFC: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A02D00: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A02D04: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 82A02D08: 48000090  b 0x82a02d98
	pc = 0x82A02D98; continue 'dispatch;
            }
            0x82A02D0C => {
    //   block [0x82A02D0C..0x82A02D20)
	// 82A02D0C: 3B9FFFF8  addi r28, r31, -8
	ctx.r[28].s64 = ctx.r[31].s64 + -8;
	// 82A02D10: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A02D14: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A02D18: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02D1C: 419A0028  beq cr6, 0x82a02d44
	if ctx.cr[6].eq {
	pc = 0x82A02D44; continue 'dispatch;
	}
	pc = 0x82A02D20; continue 'dispatch;
            }
            0x82A02D20 => {
    //   block [0x82A02D20..0x82A02D34)
	// 82A02D20: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A02D24: 419A0010  beq cr6, 0x82a02d34
	if ctx.cr[6].eq {
	pc = 0x82A02D34; continue 'dispatch;
	}
	// 82A02D28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A02D2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02D30: 4B794041  bl 0x82196d70
	ctx.lr = 0x82A02D34;
	sub_82196D70(ctx, base);
	pc = 0x82A02D34; continue 'dispatch;
            }
            0x82A02D34 => {
    //   block [0x82A02D34..0x82A02D44)
	// 82A02D34: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A02D38: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A02D3C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02D40: 409AFFE0  bne cr6, 0x82a02d20
	if !ctx.cr[6].eq {
	pc = 0x82A02D20; continue 'dispatch;
	}
	pc = 0x82A02D44; continue 'dispatch;
            }
            0x82A02D44 => {
    //   block [0x82A02D44..0x82A02D54)
	// 82A02D44: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A02D48: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A02D4C: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A02D50: 419A0044  beq cr6, 0x82a02d94
	if ctx.cr[6].eq {
	pc = 0x82A02D94; continue 'dispatch;
	}
	pc = 0x82A02D54; continue 'dispatch;
            }
            0x82A02D54 => {
    //   block [0x82A02D54..0x82A02D78)
	// 82A02D54: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A02D58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02D60: 419A0020  beq cr6, 0x82a02d80
	if ctx.cr[6].eq {
	pc = 0x82A02D80; continue 'dispatch;
	}
	// 82A02D64: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02D68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A02D6C: 419A000C  beq cr6, 0x82a02d78
	if ctx.cr[6].eq {
	pc = 0x82A02D78; continue 'dispatch;
	}
	// 82A02D70: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A02D74: 48000010  b 0x82a02d84
	pc = 0x82A02D84; continue 'dispatch;
            }
            0x82A02D78 => {
    //   block [0x82A02D78..0x82A02D80)
	// 82A02D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02D7C: 4B7910BD  bl 0x82193e38
	ctx.lr = 0x82A02D80;
	sub_82193E38(ctx, base);
	pc = 0x82A02D80; continue 'dispatch;
            }
            0x82A02D80 => {
    //   block [0x82A02D80..0x82A02D84)
	// 82A02D80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82A02D84; continue 'dispatch;
            }
            0x82A02D84 => {
    //   block [0x82A02D84..0x82A02D94)
	// 82A02D84: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82A02D88: 4B811B11  bl 0x82214898
	ctx.lr = 0x82A02D8C;
	sub_82214898(ctx, base);
	// 82A02D8C: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A02D90: 409AFFC4  bne cr6, 0x82a02d54
	if !ctx.cr[6].eq {
	pc = 0x82A02D54; continue 'dispatch;
	}
	pc = 0x82A02D94; continue 'dispatch;
            }
            0x82A02D94 => {
    //   block [0x82A02D94..0x82A02D98)
	// 82A02D94: 389A0008  addi r4, r26, 8
	ctx.r[4].s64 = ctx.r[26].s64 + 8;
	pc = 0x82A02D98; continue 'dispatch;
            }
            0x82A02D98 => {
    //   block [0x82A02D98..0x82A02DA4)
	// 82A02D98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A02D9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A02DA0: 4B969CC1  bl 0x8236ca60
	ctx.lr = 0x82A02DA4;
	sub_8236CA60(ctx, base);
	pc = 0x82A02DA4; continue 'dispatch;
            }
            0x82A02DA4 => {
    //   block [0x82A02DA4..0x82A02DC0)
	// 82A02DA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A02DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02DAC: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 82A02DB0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A02DB4: 4B791085  bl 0x82193e38
	ctx.lr = 0x82A02DB8;
	sub_82193E38(ctx, base);
	// 82A02DB8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A02DBC: 482A6690  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02DC0 size=348
    let mut pc: u32 = 0x82A02DC0;
    'dispatch: loop {
        match pc {
            0x82A02DC0 => {
    //   block [0x82A02DC0..0x82A02E00)
	// 82A02DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02DC4: 482A663D  bl 0x82ca9400
	ctx.lr = 0x82A02DC8;
	sub_82CA93D0(ctx, base);
	// 82A02DC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02DCC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A02DD0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A02DD4: 3B8BE4F0  addi r28, r11, -0x1b10
	ctx.r[28].s64 = ctx.r[11].s64 + -6928;
	// 82A02DD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A02DDC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A02DE0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A02DE4: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02DE8: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82A02DEC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02DF0: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A02DF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A02DF8: 409A0044  bne cr6, 0x82a02e3c
	if !ctx.cr[6].eq {
	pc = 0x82A02E3C; continue 'dispatch;
	}
	// 82A02DFC: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A02E00; continue 'dispatch;
            }
            0x82A02E00 => {
    //   block [0x82A02E00..0x82A02E18)
	// 82A02E00: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A02E04: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82A02E08: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A02E0C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82A02E10: 41980008  blt cr6, 0x82a02e18
	if ctx.cr[6].lt {
	pc = 0x82A02E18; continue 'dispatch;
	}
	// 82A02E14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A02E18; continue 'dispatch;
            }
            0x82A02E18 => {
    //   block [0x82A02E18..0x82A02E2C)
	// 82A02E18: 555E063E  clrlwi r30, r10, 0x18
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A02E1C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A02E20: 419A000C  beq cr6, 0x82a02e2c
	if ctx.cr[6].eq {
	pc = 0x82A02E2C; continue 'dispatch;
	}
	// 82A02E24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02E28: 48000008  b 0x82a02e30
	pc = 0x82A02E30; continue 'dispatch;
            }
            0x82A02E2C => {
    //   block [0x82A02E2C..0x82A02E30)
	// 82A02E2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A02E30; continue 'dispatch;
            }
            0x82A02E30 => {
    //   block [0x82A02E30..0x82A02E3C)
	// 82A02E30: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A02E34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A02E38: 419AFFC8  beq cr6, 0x82a02e00
	if ctx.cr[6].eq {
	pc = 0x82A02E00; continue 'dispatch;
	}
	pc = 0x82A02E3C; continue 'dispatch;
            }
            0x82A02E3C => {
    //   block [0x82A02E3C..0x82A02E98)
	// 82A02E3C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82A02E40: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A02E44: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A02E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02E4C: 419A0050  beq cr6, 0x82a02e9c
	if ctx.cr[6].eq {
	pc = 0x82A02E9C; continue 'dispatch;
	}
	// 82A02E50: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02E54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02E58: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A02E5C: 409A003C  bne cr6, 0x82a02e98
	if !ctx.cr[6].eq {
	pc = 0x82A02E98; continue 'dispatch;
	}
	// 82A02E60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A02E64: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A02E68: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A02E6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A02E70: 480001C1  bl 0x82a03030
	ctx.lr = 0x82A02E74;
	sub_82A03030(ctx, base);
	// 82A02E74: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A02E78: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A02E7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02E80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02E84: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02E88: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A02E8C: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A02E90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A02E94: 482A65BC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A02E98 => {
    //   block [0x82A02E98..0x82A02E9C)
	// 82A02E98: 48000B39  bl 0x82a039d0
	ctx.lr = 0x82A02E9C;
	sub_82A039D0(ctx, base);
	pc = 0x82A02E9C; continue 'dispatch;
            }
            0x82A02E9C => {
    //   block [0x82A02E9C..0x82A02EB8)
	// 82A02E9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A02EA0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02EA4: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A02EA8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82A02EAC: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A02EB0: 41980008  blt cr6, 0x82a02eb8
	if ctx.cr[6].lt {
	pc = 0x82A02EB8; continue 'dispatch;
	}
	// 82A02EB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A02EB8; continue 'dispatch;
            }
            0x82A02EB8 => {
    //   block [0x82A02EB8..0x82A02F00)
	// 82A02EB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A02EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02EC0: 419A0040  beq cr6, 0x82a02f00
	if ctx.cr[6].eq {
	pc = 0x82A02F00; continue 'dispatch;
	}
	// 82A02EC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A02EC8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A02ECC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A02ED0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A02ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02ED8: 48000159  bl 0x82a03030
	ctx.lr = 0x82A02EDC;
	sub_82A03030(ctx, base);
	// 82A02EDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A02EE0: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A02EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02EE8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02EEC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02EF0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A02EF4: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A02EF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A02EFC: 482A6554  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A02F00 => {
    //   block [0x82A02F00..0x82A02F1C)
	// 82A02F00: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A02F04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A02F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02F0C: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82A02F10: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A02F14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A02F18: 482A6538  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02F20 size=272
    let mut pc: u32 = 0x82A02F20;
    'dispatch: loop {
        match pc {
            0x82A02F20 => {
    //   block [0x82A02F20..0x82A02F5C)
	// 82A02F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02F24: 482A64E1  bl 0x82ca9404
	ctx.lr = 0x82A02F28;
	sub_82CA93D0(ctx, base);
	// 82A02F28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02F2C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A02F30: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82A02F34: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A02F38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A02F3C: 3BEBE4F0  addi r31, r11, -0x1b10
	ctx.r[31].s64 = ctx.r[11].s64 + -6928;
	// 82A02F40: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82A02F44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A02F48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02F4C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02F50: 419A000C  beq cr6, 0x82a02f5c
	if ctx.cr[6].eq {
	pc = 0x82A02F5C; continue 'dispatch;
	}
	// 82A02F54: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02F58: 419A0008  beq cr6, 0x82a02f60
	if ctx.cr[6].eq {
	pc = 0x82A02F60; continue 'dispatch;
	}
	pc = 0x82A02F5C; continue 'dispatch;
            }
            0x82A02F5C => {
    //   block [0x82A02F5C..0x82A02F60)
	// 82A02F5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A02F60; continue 'dispatch;
            }
            0x82A02F60 => {
    //   block [0x82A02F60..0x82A02F84)
	// 82A02F60: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A02F64: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A02F68: 83A100B8  lwz r29, 0xb8(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82A02F6C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A02F70: 409A0068  bne cr6, 0x82a02fd8
	if !ctx.cr[6].eq {
	pc = 0x82A02FD8; continue 'dispatch;
	}
	// 82A02F74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A02F78: 419A000C  beq cr6, 0x82a02f84
	if ctx.cr[6].eq {
	pc = 0x82A02F84; continue 'dispatch;
	}
	// 82A02F7C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A02F80: 419A0008  beq cr6, 0x82a02f88
	if ctx.cr[6].eq {
	pc = 0x82A02F88; continue 'dispatch;
	}
	pc = 0x82A02F84; continue 'dispatch;
            }
            0x82A02F84 => {
    //   block [0x82A02F84..0x82A02F88)
	// 82A02F84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A02F88; continue 'dispatch;
            }
            0x82A02F88 => {
    //   block [0x82A02F88..0x82A02FD8)
	// 82A02F88: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A02F8C: 409A004C  bne cr6, 0x82a02fd8
	if !ctx.cr[6].eq {
	pc = 0x82A02FD8; continue 'dispatch;
	}
	// 82A02F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02F94: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02F98: 480009D1  bl 0x82a03968
	ctx.lr = 0x82A02F9C;
	sub_82A03968(ctx, base);
	// 82A02F9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02FA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A02FA4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A02FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02FAC: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A02FB0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A02FB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02FB8: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02FBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02FC0: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A02FC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02FC8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02FCC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A02FD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A02FD4: 482A6480  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A02FD8 => {
    //   block [0x82A02FD8..0x82A02FE8)
	// 82A02FD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A02FDC: 419A000C  beq cr6, 0x82a02fe8
	if ctx.cr[6].eq {
	pc = 0x82A02FE8; continue 'dispatch;
	}
	// 82A02FE0: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A02FE4: 419A0008  beq cr6, 0x82a02fec
	if ctx.cr[6].eq {
	pc = 0x82A02FEC; continue 'dispatch;
	}
	pc = 0x82A02FE8; continue 'dispatch;
            }
            0x82A02FE8 => {
    //   block [0x82A02FE8..0x82A02FEC)
	// 82A02FE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A02FEC; continue 'dispatch;
            }
            0x82A02FEC => {
    //   block [0x82A02FEC..0x82A03020)
	// 82A02FEC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A02FF0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A02FF4: 419A002C  beq cr6, 0x82a03020
	if ctx.cr[6].eq {
	pc = 0x82A03020; continue 'dispatch;
	}
	// 82A02FF8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A02FFC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A03000: 480002A9  bl 0x82a032a8
	ctx.lr = 0x82A03004;
	sub_82A032A8(ctx, base);
	// 82A03004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A03008: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A0300C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A03010: 48000431  bl 0x82a03440
	ctx.lr = 0x82A03014;
	sub_82A03440(ctx, base);
	// 82A03014: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A03018: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A0301C: 4BFFFFBC  b 0x82a02fd8
	pc = 0x82A02FD8; continue 'dispatch;
            }
            0x82A03020 => {
    //   block [0x82A03020..0x82A03030)
	// 82A03020: F8BE0000  std r5, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A03024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A03028: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0302C: 482A6428  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03030 size=628
    let mut pc: u32 = 0x82A03030;
    'dispatch: loop {
        match pc {
            0x82A03030 => {
    //   block [0x82A03030..0x82A030AC)
	// 82A03030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03034: 482A63C5  bl 0x82ca93f8
	ctx.lr = 0x82A03038;
	sub_82CA93D0(ctx, base);
	// 82A03038: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0303C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A03040: 3D400249  lis r10, 0x249
	ctx.r[10].s64 = 38338560;
	// 82A03044: 3BCBE4F0  addi r30, r11, -0x1b10
	ctx.r[30].s64 = ctx.r[11].s64 + -6928;
	// 82A03048: 61492491  ori r9, r10, 0x2491
	ctx.r[9].u64 = ctx.r[10].u64 | 9361;
	// 82A0304C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A03050: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A03054: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A03058: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0305C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A03060: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A03064: 41980048  blt cr6, 0x82a030ac
	if ctx.cr[6].lt {
	pc = 0x82A030AC; continue 'dispatch;
	}
	// 82A03068: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0306C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A03070: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82A03074: 4B8EEECD  bl 0x822f1f40
	ctx.lr = 0x82A03078;
	sub_822F1F40(ctx, base);
	// 82A03078: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0307C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A03080: 4B8EED31  bl 0x822f1db0
	ctx.lr = 0x82A03084;
	sub_822F1DB0(ctx, base);
	// 82A03084: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A03088: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0308C: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82A03090: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A03094: 4B8EED8D  bl 0x822f1e20
	ctx.lr = 0x82A03098;
	sub_822F1E20(ctx, base);
	// 82A03098: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A0309C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A030A0: 4BC78741  bl 0x8267b7e0
	ctx.lr = 0x82A030A4;
	sub_8267B7E0(ctx, base);
	// 82A030A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A030A8: 4B76E769  bl 0x82171810
	ctx.lr = 0x82A030AC;
	sub_82171810(ctx, base);
	pc = 0x82A030AC; continue 'dispatch;
            }
            0x82A030AC => {
    //   block [0x82A030AC..0x82A030EC)
	// 82A030AC: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82A030B0: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A030B4: 4B81C1A5  bl 0x8221f258
	ctx.lr = 0x82A030B8;
	sub_8221F258(ctx, base);
	// 82A030B8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A030BC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A030C0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A030C4: 419A0028  beq cr6, 0x82a030ec
	if ctx.cr[6].eq {
	pc = 0x82A030EC; continue 'dispatch;
	}
	// 82A030C8: 93BB0000  stw r29, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A030CC: 387B0010  addi r3, r27, 0x10
	ctx.r[3].s64 = ctx.r[27].s64 + 16;
	// 82A030D0: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A030D4: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 82A030D8: 93BB0008  stw r29, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A030DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A030E0: 482A63A1  bl 0x82ca9480
	ctx.lr = 0x82A030E4;
	sub_82CA9480(ctx, base);
	// 82A030E4: 9B3B0080  stb r25, 0x80(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(128 as u32), ctx.r[25].u8 ) };
	// 82A030E8: 9B3B0081  stb r25, 0x81(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(129 as u32), ctx.r[25].u8 ) };
	pc = 0x82A030EC; continue 'dispatch;
            }
            0x82A030EC => {
    //   block [0x82A030EC..0x82A03118)
	// 82A030EC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A030F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A030F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A030F8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A030FC: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A03100: 409A0018  bne cr6, 0x82a03118
	if !ctx.cr[6].eq {
	pc = 0x82A03118; continue 'dispatch;
	}
	// 82A03104: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A03108: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0310C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A03110: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03114: 48000044  b 0x82a03158
	pc = 0x82A03158; continue 'dispatch;
            }
            0x82A03118 => {
    //   block [0x82A03118..0x82A03144)
	// 82A03118: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A0311C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03120: 419A0024  beq cr6, 0x82a03144
	if ctx.cr[6].eq {
	pc = 0x82A03144; continue 'dispatch;
	}
	// 82A03124: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A03128: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0312C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03130: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A03134: 409A0028  bne cr6, 0x82a0315c
	if !ctx.cr[6].eq {
	pc = 0x82A0315C; continue 'dispatch;
	}
	// 82A03138: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0313C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A03140: 4800001C  b 0x82a0315c
	pc = 0x82A0315C; continue 'dispatch;
            }
            0x82A03144 => {
    //   block [0x82A03144..0x82A03158)
	// 82A03144: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A03148: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0314C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03150: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A03154: 409A0008  bne cr6, 0x82a0315c
	if !ctx.cr[6].eq {
	pc = 0x82A0315C; continue 'dispatch;
	}
	pc = 0x82A03158; continue 'dispatch;
            }
            0x82A03158 => {
    //   block [0x82A03158..0x82A0315C)
	// 82A03158: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A0315C; continue 'dispatch;
            }
            0x82A0315C => {
    //   block [0x82A0315C..0x82A03178)
	// 82A0315C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03160: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82A03164: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A03168: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0316C: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03170: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03174: 409A0110  bne cr6, 0x82a03284
	if !ctx.cr[6].eq {
	pc = 0x82A03284; continue 'dispatch;
	}
	pc = 0x82A03178; continue 'dispatch;
            }
            0x82A03178 => {
    //   block [0x82A03178..0x82A031C0)
	// 82A03178: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0317C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03180: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03184: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A03188: 409A0078  bne cr6, 0x82a03200
	if !ctx.cr[6].eq {
	pc = 0x82A03200; continue 'dispatch;
	}
	// 82A0318C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03190: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03194: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03198: 409A0028  bne cr6, 0x82a031c0
	if !ctx.cr[6].eq {
	pc = 0x82A031C0; continue 'dispatch;
	}
	// 82A0319C: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A031A0: 9BA90080  stb r29, 0x80(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A031A4: 9BAA0080  stb r29, 0x80(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A031A8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A031AC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A031B0: 9B270080  stb r25, 0x80(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(128 as u32), ctx.r[25].u8 ) };
	// 82A031B4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A031B8: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A031BC: 480000B4  b 0x82a03270
	pc = 0x82A03270; continue 'dispatch;
            }
            0x82A031C0 => {
    //   block [0x82A031C0..0x82A031D8)
	// 82A031C0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A031C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A031C8: 409A0010  bne cr6, 0x82a031d8
	if !ctx.cr[6].eq {
	pc = 0x82A031D8; continue 'dispatch;
	}
	// 82A031CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A031D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A031D4: 48000695  bl 0x82a03868
	ctx.lr = 0x82A031D8;
	sub_82A03868(ctx, base);
	pc = 0x82A031D8; continue 'dispatch;
            }
            0x82A031D8 => {
    //   block [0x82A031D8..0x82A03200)
	// 82A031D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A031DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A031E0: 9BAB0080  stb r29, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A031E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A031E8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A031EC: 9B290080  stb r25, 0x80(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), ctx.r[25].u8 ) };
	// 82A031F0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A031F4: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A031F8: 480006F1  bl 0x82a038e8
	ctx.lr = 0x82A031FC;
	sub_82A038E8(ctx, base);
	// 82A031FC: 48000074  b 0x82a03270
	pc = 0x82A03270; continue 'dispatch;
            }
            0x82A03200 => {
    //   block [0x82A03200..0x82A03234)
	// 82A03200: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03204: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03208: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0320C: 409A0028  bne cr6, 0x82a03234
	if !ctx.cr[6].eq {
	pc = 0x82A03234; continue 'dispatch;
	}
	// 82A03210: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03214: 9BA90080  stb r29, 0x80(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A03218: 9BAA0080  stb r29, 0x80(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A0321C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03220: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03224: 9B270080  stb r25, 0x80(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(128 as u32), ctx.r[25].u8 ) };
	// 82A03228: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0322C: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03230: 48000040  b 0x82a03270
	pc = 0x82A03270; continue 'dispatch;
            }
            0x82A03234 => {
    //   block [0x82A03234..0x82A0324C)
	// 82A03234: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03238: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0323C: 409A0010  bne cr6, 0x82a0324c
	if !ctx.cr[6].eq {
	pc = 0x82A0324C; continue 'dispatch;
	}
	// 82A03240: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A03244: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A03248: 480006A1  bl 0x82a038e8
	ctx.lr = 0x82A0324C;
	sub_82A038E8(ctx, base);
	pc = 0x82A0324C; continue 'dispatch;
            }
            0x82A0324C => {
    //   block [0x82A0324C..0x82A03270)
	// 82A0324C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A03254: 9BAB0080  stb r29, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A03258: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0325C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03260: 9B290080  stb r25, 0x80(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), ctx.r[25].u8 ) };
	// 82A03264: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03268: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0326C: 480005FD  bl 0x82a03868
	ctx.lr = 0x82A03270;
	sub_82A03868(ctx, base);
	pc = 0x82A03270; continue 'dispatch;
            }
            0x82A03270 => {
    //   block [0x82A03270..0x82A03284)
	// 82A03270: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03274: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A03278: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A0327C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03280: 419AFEF8  beq cr6, 0x82a03178
	if ctx.cr[6].eq {
	pc = 0x82A03178; continue 'dispatch;
	}
	pc = 0x82A03284; continue 'dispatch;
            }
            0x82A03284 => {
    //   block [0x82A03284..0x82A032A4)
	// 82A03284: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03288: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A0328C: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A03290: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A03294: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03298: 9BAA0080  stb r29, 0x80(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A0329C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A032A0: 482A61A8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A032A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A032A8 size=40
    let mut pc: u32 = 0x82A032A8;
    'dispatch: loop {
        match pc {
            0x82A032A8 => {
    //   block [0x82A032A8..0x82A032B8)
	// 82A032A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A032AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A032B0: 409A0008  bne cr6, 0x82a032b8
	if !ctx.cr[6].eq {
	pc = 0x82A032B8; continue 'dispatch;
	}
	// 82A032B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A032B8; continue 'dispatch;
            }
            0x82A032B8 => {
    //   block [0x82A032B8..0x82A032D0)
	// 82A032B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A032BC: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A032C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A032C4: 419A000C  beq cr6, 0x82a032d0
	if ctx.cr[6].eq {
		sub_82A032D0(ctx, base);
		return;
	}
	// 82A032C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82A032CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A032D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A032D0 size=60
    let mut pc: u32 = 0x82A032D0;
    'dispatch: loop {
        match pc {
            0x82A032D0 => {
    //   block [0x82A032D0..0x82A032F0)
	// 82A032D0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A032D4: 892A0081  lbz r9, 0x81(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A032D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A032DC: 409A0030  bne cr6, 0x82a0330c
	if !ctx.cr[6].eq {
		sub_82A0330C(ctx, base);
		return;
	}
	// 82A032E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A032E4: 892B0081  lbz r9, 0x81(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A032E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A032EC: 409A0018  bne cr6, 0x82a03304
	if !ctx.cr[6].eq {
	pc = 0x82A03304; continue 'dispatch;
	}
	pc = 0x82A032F0; continue 'dispatch;
            }
            0x82A032F0 => {
    //   block [0x82A032F0..0x82A03304)
	// 82A032F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A032F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A032F8: 892B0081  lbz r9, 0x81(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A032FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03300: 419AFFF0  beq cr6, 0x82a032f0
	if ctx.cr[6].eq {
	pc = 0x82A032F0; continue 'dispatch;
	}
	pc = 0x82A03304; continue 'dispatch;
            }
            0x82A03304 => {
    //   block [0x82A03304..0x82A0330C)
	// 82A03304: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A03308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0330C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0330C size=64
    let mut pc: u32 = 0x82A0330C;
    'dispatch: loop {
        match pc {
            0x82A0330C => {
    //   block [0x82A0330C..0x82A0331C)
	// 82A0330C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03310: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03314: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03318: 409A002C  bne cr6, 0x82a03344
	if !ctx.cr[6].eq {
	pc = 0x82A03344; continue 'dispatch;
	}
	pc = 0x82A0331C; continue 'dispatch;
            }
            0x82A0331C => {
    //   block [0x82A0331C..0x82A03344)
	// 82A0331C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03320: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03324: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A03328: 409A001C  bne cr6, 0x82a03344
	if !ctx.cr[6].eq {
	pc = 0x82A03344; continue 'dispatch;
	}
	// 82A0332C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A03330: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A03334: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03338: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A0333C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03340: 419AFFDC  beq cr6, 0x82a0331c
	if ctx.cr[6].eq {
	pc = 0x82A0331C; continue 'dispatch;
	}
	pc = 0x82A03344; continue 'dispatch;
            }
            0x82A03344 => {
    //   block [0x82A03344..0x82A0334C)
	// 82A03344: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A03348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03350 size=236
    let mut pc: u32 = 0x82A03350;
    'dispatch: loop {
        match pc {
            0x82A03350 => {
    //   block [0x82A03350..0x82A0338C)
	// 82A03350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03354: 482A60B1  bl 0x82ca9404
	ctx.lr = 0x82A03358;
	sub_82CA93D0(ctx, base);
	// 82A03358: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0335C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A03360: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82A03364: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A03368: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0336C: 3BEB1AA0  addi r31, r11, 0x1aa0
	ctx.r[31].s64 = ctx.r[11].s64 + 6816;
	// 82A03370: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82A03374: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03378: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0337C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03380: 419A000C  beq cr6, 0x82a0338c
	if ctx.cr[6].eq {
	pc = 0x82A0338C; continue 'dispatch;
	}
	// 82A03384: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A03388: 419A0008  beq cr6, 0x82a03390
	if ctx.cr[6].eq {
	pc = 0x82A03390; continue 'dispatch;
	}
	pc = 0x82A0338C; continue 'dispatch;
            }
            0x82A0338C => {
    //   block [0x82A0338C..0x82A03390)
	// 82A0338C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A03390; continue 'dispatch;
            }
            0x82A03390 => {
    //   block [0x82A03390..0x82A033B4)
	// 82A03390: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A03394: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A03398: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82A0339C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A033A0: 409A0044  bne cr6, 0x82a033e4
	if !ctx.cr[6].eq {
	pc = 0x82A033E4; continue 'dispatch;
	}
	// 82A033A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A033A8: 419A000C  beq cr6, 0x82a033b4
	if ctx.cr[6].eq {
	pc = 0x82A033B4; continue 'dispatch;
	}
	// 82A033AC: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A033B0: 419A0008  beq cr6, 0x82a033b8
	if ctx.cr[6].eq {
	pc = 0x82A033B8; continue 'dispatch;
	}
	pc = 0x82A033B4; continue 'dispatch;
            }
            0x82A033B4 => {
    //   block [0x82A033B4..0x82A033B8)
	// 82A033B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A033B8; continue 'dispatch;
            }
            0x82A033B8 => {
    //   block [0x82A033B8..0x82A033E4)
	// 82A033B8: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A033BC: 409A0028  bne cr6, 0x82a033e4
	if !ctx.cr[6].eq {
	pc = 0x82A033E4; continue 'dispatch;
	}
	// 82A033C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A033C4: 4BFFEE45  bl 0x82a02208
	ctx.lr = 0x82A033C8;
	sub_82A02208(ctx, base);
	// 82A033C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A033CC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A033D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A033D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A033D8: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A033DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A033E0: 482A6074  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A033E4 => {
    //   block [0x82A033E4..0x82A033F4)
	// 82A033E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A033E8: 419A000C  beq cr6, 0x82a033f4
	if ctx.cr[6].eq {
	pc = 0x82A033F4; continue 'dispatch;
	}
	// 82A033EC: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A033F0: 419A0008  beq cr6, 0x82a033f8
	if ctx.cr[6].eq {
	pc = 0x82A033F8; continue 'dispatch;
	}
	pc = 0x82A033F4; continue 'dispatch;
            }
            0x82A033F4 => {
    //   block [0x82A033F4..0x82A033F8)
	// 82A033F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A033F8; continue 'dispatch;
            }
            0x82A033F8 => {
    //   block [0x82A033F8..0x82A0342C)
	// 82A033F8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A033FC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A03400: 419A002C  beq cr6, 0x82a0342c
	if ctx.cr[6].eq {
	pc = 0x82A0342C; continue 'dispatch;
	}
	// 82A03404: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A03408: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A0340C: 4B8FCD1D  bl 0x82300128
	ctx.lr = 0x82A03410;
	sub_82300128(ctx, base);
	// 82A03410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A03414: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A03418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0341C: 4B8B3FA5  bl 0x822b73c0
	ctx.lr = 0x82A03420;
	sub_822B73C0(ctx, base);
	// 82A03420: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A03424: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A03428: 4BFFFFBC  b 0x82a033e4
	pc = 0x82A033E4; continue 'dispatch;
            }
            0x82A0342C => {
    //   block [0x82A0342C..0x82A0343C)
	// 82A0342C: F8BD0000  std r5, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A03430: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A03434: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A03438: 482A601C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03440 size=1064
    let mut pc: u32 = 0x82A03440;
    'dispatch: loop {
        match pc {
            0x82A03440 => {
    //   block [0x82A03440..0x82A034A8)
	// 82A03440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03444: 482A5FB9  bl 0x82ca93fc
	ctx.lr = 0x82A03448;
	sub_82CA93D0(ctx, base);
	// 82A03448: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0344C: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82A03450: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A03454: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A03458: 897F0081  lbz r11, 0x81(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A0345C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03460: 419A0048  beq cr6, 0x82a034a8
	if ctx.cr[6].eq {
	pc = 0x82A034A8; continue 'dispatch;
	}
	// 82A03464: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A03468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0346C: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82A03470: 4B8EEAD1  bl 0x822f1f40
	ctx.lr = 0x82A03474;
	sub_822F1F40(ctx, base);
	// 82A03474: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A03478: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0347C: 4B8EE935  bl 0x822f1db0
	ctx.lr = 0x82A03480;
	sub_822F1DB0(ctx, base);
	// 82A03480: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A03484: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A03488: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82A0348C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A03490: 4B8EE991  bl 0x822f1e20
	ctx.lr = 0x82A03494;
	sub_822F1E20(ctx, base);
	// 82A03494: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A03498: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0349C: 4BC78345  bl 0x8267b7e0
	ctx.lr = 0x82A034A0;
	sub_8267B7E0(ctx, base);
	// 82A034A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A034A4: 4B76E36D  bl 0x82171810
	ctx.lr = 0x82A034A8;
	sub_82171810(ctx, base);
	pc = 0x82A034A8; continue 'dispatch;
            }
            0x82A034A8 => {
    //   block [0x82A034A8..0x82A034CC)
	// 82A034A8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A034AC: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82A034B0: 4BFFFDF9  bl 0x82a032a8
	ctx.lr = 0x82A034B4;
	sub_82A032A8(ctx, base);
	// 82A034B4: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A034B8: 896A0081  lbz r11, 0x81(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A034BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A034C0: 419A000C  beq cr6, 0x82a034cc
	if ctx.cr[6].eq {
	pc = 0x82A034CC; continue 'dispatch;
	}
	// 82A034C4: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A034C8: 4800002C  b 0x82a034f4
	pc = 0x82A034F4; continue 'dispatch;
            }
            0x82A034CC => {
    //   block [0x82A034CC..0x82A034E4)
	// 82A034CC: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A034D0: 892B0081  lbz r9, 0x81(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A034D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A034D8: 419A000C  beq cr6, 0x82a034e4
	if ctx.cr[6].eq {
	pc = 0x82A034E4; continue 'dispatch;
	}
	// 82A034DC: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82A034E0: 48000014  b 0x82a034f4
	pc = 0x82A034F4; continue 'dispatch;
            }
            0x82A034E4 => {
    //   block [0x82A034E4..0x82A034F4)
	// 82A034E4: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A034E8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A034EC: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A034F0: 409A00FC  bne cr6, 0x82a035ec
	if !ctx.cr[6].eq {
	pc = 0x82A035EC; continue 'dispatch;
	}
	pc = 0x82A034F4; continue 'dispatch;
            }
            0x82A034F4 => {
    //   block [0x82A034F4..0x82A03508)
	// 82A034F4: 897B0081  lbz r11, 0x81(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A034F8: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A034FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03500: 409A0008  bne cr6, 0x82a03508
	if !ctx.cr[6].eq {
	pc = 0x82A03508; continue 'dispatch;
	}
	// 82A03504: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A03508; continue 'dispatch;
            }
            0x82A03508 => {
    //   block [0x82A03508..0x82A03528)
	// 82A03508: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0350C: 3B8BE4F0  addi r28, r11, -0x1b10
	ctx.r[28].s64 = ctx.r[11].s64 + -6928;
	// 82A03510: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03514: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03518: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0351C: 409A000C  bne cr6, 0x82a03528
	if !ctx.cr[6].eq {
	pc = 0x82A03528; continue 'dispatch;
	}
	// 82A03520: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A03524: 4800001C  b 0x82a03540
	pc = 0x82A03540; continue 'dispatch;
            }
            0x82A03528 => {
    //   block [0x82A03528..0x82A0353C)
	// 82A03528: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0352C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A03530: 409A000C  bne cr6, 0x82a0353c
	if !ctx.cr[6].eq {
	pc = 0x82A0353C; continue 'dispatch;
	}
	// 82A03534: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A03538: 48000008  b 0x82a03540
	pc = 0x82A03540; continue 'dispatch;
            }
            0x82A0353C => {
    //   block [0x82A0353C..0x82A03540)
	// 82A0353C: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A03540; continue 'dispatch;
            }
            0x82A03540 => {
    //   block [0x82A03540..0x82A03564)
	// 82A03540: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03544: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03548: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0354C: 409A0048  bne cr6, 0x82a03594
	if !ctx.cr[6].eq {
	pc = 0x82A03594; continue 'dispatch;
	}
	// 82A03550: 897B0081  lbz r11, 0x81(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03558: 419A000C  beq cr6, 0x82a03564
	if ctx.cr[6].eq {
	pc = 0x82A03564; continue 'dispatch;
	}
	// 82A0355C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A03560: 4800002C  b 0x82a0358c
	pc = 0x82A0358C; continue 'dispatch;
            }
            0x82A03564 => {
    //   block [0x82A03564..0x82A03578)
	// 82A03564: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03568: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A0356C: 892B0081  lbz r9, 0x81(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03570: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03574: 409A0018  bne cr6, 0x82a0358c
	if !ctx.cr[6].eq {
	pc = 0x82A0358C; continue 'dispatch;
	}
	pc = 0x82A03578; continue 'dispatch;
            }
            0x82A03578 => {
    //   block [0x82A03578..0x82A0358C)
	// 82A03578: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A0357C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03580: 892B0081  lbz r9, 0x81(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03584: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03588: 419AFFF0  beq cr6, 0x82a03578
	if ctx.cr[6].eq {
	pc = 0x82A03578; continue 'dispatch;
	}
	pc = 0x82A0358C; continue 'dispatch;
            }
            0x82A0358C => {
    //   block [0x82A0358C..0x82A03594)
	// 82A0358C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03590: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A03594; continue 'dispatch;
            }
            0x82A03594 => {
    //   block [0x82A03594..0x82A035BC)
	// 82A03594: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03598: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0359C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A035A0: 409A00E8  bne cr6, 0x82a03688
	if !ctx.cr[6].eq {
	pc = 0x82A03688; continue 'dispatch;
	}
	// 82A035A4: 897B0081  lbz r11, 0x81(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A035A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A035AC: 419A0010  beq cr6, 0x82a035bc
	if ctx.cr[6].eq {
	pc = 0x82A035BC; continue 'dispatch;
	}
	// 82A035B0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A035B4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A035B8: 480000D0  b 0x82a03688
	pc = 0x82A03688; continue 'dispatch;
            }
            0x82A035BC => {
    //   block [0x82A035BC..0x82A035D0)
	// 82A035BC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A035C0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A035C4: 890B0081  lbz r8, 0x81(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A035C8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A035CC: 409A0018  bne cr6, 0x82a035e4
	if !ctx.cr[6].eq {
	pc = 0x82A035E4; continue 'dispatch;
	}
	pc = 0x82A035D0; continue 'dispatch;
            }
            0x82A035D0 => {
    //   block [0x82A035D0..0x82A035E4)
	// 82A035D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A035D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A035D8: 890B0081  lbz r8, 0x81(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A035DC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A035E0: 419AFFF0  beq cr6, 0x82a035d0
	if ctx.cr[6].eq {
	pc = 0x82A035D0; continue 'dispatch;
	}
	pc = 0x82A035E4; continue 'dispatch;
            }
            0x82A035E4 => {
    //   block [0x82A035E4..0x82A035EC)
	// 82A035E4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A035E8: 480000A0  b 0x82a03688
	pc = 0x82A03688; continue 'dispatch;
            }
            0x82A035EC => {
    //   block [0x82A035EC..0x82A0360C)
	// 82A035EC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A035F0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A035F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A035F8: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A035FC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A03600: 409A000C  bne cr6, 0x82a0360c
	if !ctx.cr[6].eq {
	pc = 0x82A0360C; continue 'dispatch;
	}
	// 82A03604: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A03608: 4800002C  b 0x82a03634
	pc = 0x82A03634; continue 'dispatch;
            }
            0x82A0360C => {
    //   block [0x82A0360C..0x82A03620)
	// 82A0360C: 895B0081  lbz r10, 0x81(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03610: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03614: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03618: 409A0008  bne cr6, 0x82a03620
	if !ctx.cr[6].eq {
	pc = 0x82A03620; continue 'dispatch;
	}
	// 82A0361C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A03620; continue 'dispatch;
            }
            0x82A03620 => {
    //   block [0x82A03620..0x82A03634)
	// 82A03620: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A03624: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03628: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0362C: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03630: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A03634; continue 'dispatch;
            }
            0x82A03634 => {
    //   block [0x82A03634..0x82A03654)
	// 82A03634: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A03638: 3B8AE4F0  addi r28, r10, -0x1b10
	ctx.r[28].s64 = ctx.r[10].s64 + -6928;
	// 82A0363C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03640: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03644: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A03648: 409A000C  bne cr6, 0x82a03654
	if !ctx.cr[6].eq {
	pc = 0x82A03654; continue 'dispatch;
	}
	// 82A0364C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A03650: 48000020  b 0x82a03670
	pc = 0x82A03670; continue 'dispatch;
            }
            0x82A03654 => {
    //   block [0x82A03654..0x82A0366C)
	// 82A03654: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03658: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0365C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A03660: 409A000C  bne cr6, 0x82a0366c
	if !ctx.cr[6].eq {
	pc = 0x82A0366C; continue 'dispatch;
	}
	// 82A03664: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A03668: 48000008  b 0x82a03670
	pc = 0x82A03670; continue 'dispatch;
            }
            0x82A0366C => {
    //   block [0x82A0366C..0x82A03670)
	// 82A0366C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A03670; continue 'dispatch;
            }
            0x82A03670 => {
    //   block [0x82A03670..0x82A03688)
	// 82A03670: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03674: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A03678: 893A0080  lbz r9, 0x80(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A0367C: 890B0080  lbz r8, 0x80(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03680: 992B0080  stb r9, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u8 ) };
	// 82A03684: 991A0080  stb r8, 0x80(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(128 as u32), ctx.r[8].u8 ) };
	pc = 0x82A03688; continue 'dispatch;
            }
            0x82A03688 => {
    //   block [0x82A03688..0x82A036AC)
	// 82A03688: 897A0080  lbz r11, 0x80(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A0368C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A03690: 409A0198  bne cr6, 0x82a03828
	if !ctx.cr[6].eq {
	pc = 0x82A03828; continue 'dispatch;
	}
	// 82A03694: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03698: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A0369C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A036A0: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A036A4: 419A0180  beq cr6, 0x82a03824
	if ctx.cr[6].eq {
	pc = 0x82A03824; continue 'dispatch;
	}
	// 82A036A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82A036AC; continue 'dispatch;
            }
            0x82A036AC => {
    //   block [0x82A036AC..0x82A036EC)
	// 82A036AC: 897B0080  lbz r11, 0x80(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A036B0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A036B4: 409A0170  bne cr6, 0x82a03824
	if !ctx.cr[6].eq {
	pc = 0x82A03824; continue 'dispatch;
	}
	// 82A036B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A036BC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A036C0: 409A00A8  bne cr6, 0x82a03768
	if !ctx.cr[6].eq {
	pc = 0x82A03768; continue 'dispatch;
	}
	// 82A036C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A036C8: 894B0080  lbz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A036CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A036D0: 409A001C  bne cr6, 0x82a036ec
	if !ctx.cr[6].eq {
	pc = 0x82A036EC; continue 'dispatch;
	}
	// 82A036D4: 9BAB0080  stb r29, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A036D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A036DC: 9BDF0080  stb r30, 0x80(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	// 82A036E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A036E4: 48000185  bl 0x82a03868
	ctx.lr = 0x82A036E8;
	sub_82A03868(ctx, base);
	// 82A036E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A036EC; continue 'dispatch;
            }
            0x82A036EC => {
    //   block [0x82A036EC..0x82A03718)
	// 82A036EC: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A036F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A036F4: 409A00C8  bne cr6, 0x82a037bc
	if !ctx.cr[6].eq {
	pc = 0x82A037BC; continue 'dispatch;
	}
	// 82A036F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A036FC: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03700: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A03704: 409A0014  bne cr6, 0x82a03718
	if !ctx.cr[6].eq {
	pc = 0x82A03718; continue 'dispatch;
	}
	// 82A03708: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0370C: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03710: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A03714: 419A00A4  beq cr6, 0x82a037b8
	if ctx.cr[6].eq {
	pc = 0x82A037B8; continue 'dispatch;
	}
	pc = 0x82A03718; continue 'dispatch;
            }
            0x82A03718 => {
    //   block [0x82A03718..0x82A03744)
	// 82A03718: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0371C: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03720: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A03724: 409A0020  bne cr6, 0x82a03744
	if !ctx.cr[6].eq {
	pc = 0x82A03744; continue 'dispatch;
	}
	// 82A03728: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0372C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A03730: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A03734: 9BAA0080  stb r29, 0x80(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A03738: 9BCB0080  stb r30, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	// 82A0373C: 480001AD  bl 0x82a038e8
	ctx.lr = 0x82A03740;
	sub_82A038E8(ctx, base);
	// 82A03740: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A03744; continue 'dispatch;
            }
            0x82A03744 => {
    //   block [0x82A03744..0x82A03768)
	// 82A03744: 895F0080  lbz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03748: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0374C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A03750: 994B0080  stb r10, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u8 ) };
	// 82A03754: 9BBF0080  stb r29, 0x80(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A03758: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0375C: 9BA90080  stb r29, 0x80(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A03760: 48000109  bl 0x82a03868
	ctx.lr = 0x82A03764;
	sub_82A03868(ctx, base);
	// 82A03764: 480000C0  b 0x82a03824
	pc = 0x82A03824; continue 'dispatch;
            }
            0x82A03768 => {
    //   block [0x82A03768..0x82A0378C)
	// 82A03768: 894B0080  lbz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A0376C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03770: 409A001C  bne cr6, 0x82a0378c
	if !ctx.cr[6].eq {
	pc = 0x82A0378C; continue 'dispatch;
	}
	// 82A03774: 9BAB0080  stb r29, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A03778: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0377C: 9BDF0080  stb r30, 0x80(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	// 82A03780: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A03784: 48000165  bl 0x82a038e8
	ctx.lr = 0x82A03788;
	sub_82A038E8(ctx, base);
	// 82A03788: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A0378C; continue 'dispatch;
            }
            0x82A0378C => {
    //   block [0x82A0378C..0x82A037B8)
	// 82A0378C: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03790: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03794: 409A0028  bne cr6, 0x82a037bc
	if !ctx.cr[6].eq {
	pc = 0x82A037BC; continue 'dispatch;
	}
	// 82A03798: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0379C: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A037A0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A037A4: 409A0034  bne cr6, 0x82a037d8
	if !ctx.cr[6].eq {
	pc = 0x82A037D8; continue 'dispatch;
	}
	// 82A037A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A037AC: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A037B0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A037B4: 409A0024  bne cr6, 0x82a037d8
	if !ctx.cr[6].eq {
	pc = 0x82A037D8; continue 'dispatch;
	}
	pc = 0x82A037B8; continue 'dispatch;
            }
            0x82A037B8 => {
    //   block [0x82A037B8..0x82A037BC)
	// 82A037B8: 9BCB0080  stb r30, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	pc = 0x82A037BC; continue 'dispatch;
            }
            0x82A037BC => {
    //   block [0x82A037BC..0x82A037D8)
	// 82A037BC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A037C0: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82A037C4: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A037C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A037CC: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A037D0: 409AFEDC  bne cr6, 0x82a036ac
	if !ctx.cr[6].eq {
	pc = 0x82A036AC; continue 'dispatch;
	}
	// 82A037D4: 48000050  b 0x82a03824
	pc = 0x82A03824; continue 'dispatch;
            }
            0x82A037D8 => {
    //   block [0x82A037D8..0x82A03804)
	// 82A037D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A037DC: 892A0080  lbz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A037E0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A037E4: 409A0020  bne cr6, 0x82a03804
	if !ctx.cr[6].eq {
	pc = 0x82A03804; continue 'dispatch;
	}
	// 82A037E8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A037EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A037F0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A037F4: 9BAA0080  stb r29, 0x80(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A037F8: 9BCB0080  stb r30, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	// 82A037FC: 4800006D  bl 0x82a03868
	ctx.lr = 0x82A03800;
	sub_82A03868(ctx, base);
	// 82A03800: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A03804; continue 'dispatch;
            }
            0x82A03804 => {
    //   block [0x82A03804..0x82A03824)
	// 82A03804: 895F0080  lbz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03808: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0380C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A03810: 994B0080  stb r10, 0x80(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u8 ) };
	// 82A03814: 9BBF0080  stb r29, 0x80(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A03818: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0381C: 9BA90080  stb r29, 0x80(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 82A03820: 480000C9  bl 0x82a038e8
	ctx.lr = 0x82A03824;
	sub_82A038E8(ctx, base);
	pc = 0x82A03824; continue 'dispatch;
            }
            0x82A03824 => {
    //   block [0x82A03824..0x82A03828)
	// 82A03824: 9BBB0080  stb r29, 0x80(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	pc = 0x82A03828; continue 'dispatch;
            }
            0x82A03828 => {
    //   block [0x82A03828..0x82A03858)
	// 82A03828: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A0382C: 4B81850D  bl 0x8221bd38
	ctx.lr = 0x82A03830;
	sub_8221BD38(ctx, base);
	// 82A03830: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03834: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A03838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0383C: 419A001C  beq cr6, 0x82a03858
	if ctx.cr[6].eq {
	pc = 0x82A03858; continue 'dispatch;
	}
	// 82A03840: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82A03844: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A03848: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0384C: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82A03850: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A03854: 482A5BF8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A03858 => {
    //   block [0x82A03858..0x82A03868)
	// 82A03858: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82A0385C: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A03860: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A03864: 482A5BE8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A03868 size=80
    let mut pc: u32 = 0x82A03868;
    'dispatch: loop {
        match pc {
            0x82A03868 => {
    //   block [0x82A03868..0x82A03888)
	// 82A03868: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0386C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03870: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A03874: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03878: 892A0081  lbz r9, 0x81(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A0387C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03880: 409A0008  bne cr6, 0x82a03888
	if !ctx.cr[6].eq {
	pc = 0x82A03888; continue 'dispatch;
	}
	// 82A03884: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A03888; continue 'dispatch;
            }
            0x82A03888 => {
    //   block [0x82A03888..0x82A038B8)
	// 82A03888: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A0388C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03890: 390AE4F0  addi r8, r10, -0x1b10
	ctx.r[8].s64 = ctx.r[10].s64 + -6928;
	// 82A03894: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A03898: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0389C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A038A0: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A038A4: 409A0014  bne cr6, 0x82a038b8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A038B8);
		return;
	}
	// 82A038A8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A038AC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82A038B0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A038B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A038E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A038E8 size=80
    let mut pc: u32 = 0x82A038E8;
    'dispatch: loop {
        match pc {
            0x82A038E8 => {
    //   block [0x82A038E8..0x82A03908)
	// 82A038E8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A038EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A038F0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A038F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A038F8: 892A0081  lbz r9, 0x81(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A038FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03900: 409A0008  bne cr6, 0x82a03908
	if !ctx.cr[6].eq {
	pc = 0x82A03908; continue 'dispatch;
	}
	// 82A03904: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A03908; continue 'dispatch;
            }
            0x82A03908 => {
    //   block [0x82A03908..0x82A03938)
	// 82A03908: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A0390C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03910: 390AE4F0  addi r8, r10, -0x1b10
	ctx.r[8].s64 = ctx.r[10].s64 + -6928;
	// 82A03914: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A03918: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0391C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03920: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A03924: 409A0014  bne cr6, 0x82a03938
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A03938);
		return;
	}
	// 82A03928: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0392C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A03930: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A03934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03968 size=100
    let mut pc: u32 = 0x82A03968;
    'dispatch: loop {
        match pc {
            0x82A03968 => {
    //   block [0x82A03968..0x82A03990)
	// 82A03968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0396C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A03970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A03974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A03978: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0397C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A03980: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A03984: 897F0081  lbz r11, 0x81(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0398C: 409A0028  bne cr6, 0x82a039b4
	if !ctx.cr[6].eq {
	pc = 0x82A039B4; continue 'dispatch;
	}
	pc = 0x82A03990; continue 'dispatch;
            }
            0x82A03990 => {
    //   block [0x82A03990..0x82A039B4)
	// 82A03990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A03994: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03998: 4BFFFFD1  bl 0x82a03968
	ctx.lr = 0x82A0399C;
	sub_82A03968(ctx, base);
	// 82A0399C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A039A0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A039A4: 4B818395  bl 0x8221bd38
	ctx.lr = 0x82A039A8;
	sub_8221BD38(ctx, base);
	// 82A039A8: 897F0081  lbz r11, 0x81(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A039AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A039B0: 419AFFE0  beq cr6, 0x82a03990
	if ctx.cr[6].eq {
	pc = 0x82A03990; continue 'dispatch;
	}
	pc = 0x82A039B4; continue 'dispatch;
            }
            0x82A039B4 => {
    //   block [0x82A039B4..0x82A039CC)
	// 82A039B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A039B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A039BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A039C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A039C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A039C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A039D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A039D0 size=60
    let mut pc: u32 = 0x82A039D0;
    'dispatch: loop {
        match pc {
            0x82A039D0 => {
    //   block [0x82A039D0..0x82A039E0)
	// 82A039D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A039D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A039D8: 409A0008  bne cr6, 0x82a039e0
	if !ctx.cr[6].eq {
	pc = 0x82A039E0; continue 'dispatch;
	}
	// 82A039DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A039E0; continue 'dispatch;
            }
            0x82A039E0 => {
    //   block [0x82A039E0..0x82A03A0C)
	// 82A039E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A039E4: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A039E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A039EC: 419A0020  beq cr6, 0x82a03a0c
	if ctx.cr[6].eq {
		sub_82A03A0C(ctx, base);
		return;
	}
	// 82A039F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A039F4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A039F8: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A039FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03A00: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A03A04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82A03A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03A0C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A03A0C size=60
    let mut pc: u32 = 0x82A03A0C;
    'dispatch: loop {
        match pc {
            0x82A03A0C => {
    //   block [0x82A03A0C..0x82A03A2C)
	// 82A03A0C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03A10: 892A0081  lbz r9, 0x81(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03A14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03A18: 409A0030  bne cr6, 0x82a03a48
	if !ctx.cr[6].eq {
		sub_82A03A48(ctx, base);
		return;
	}
	// 82A03A1C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03A20: 892B0081  lbz r9, 0x81(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03A24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03A28: 409A0018  bne cr6, 0x82a03a40
	if !ctx.cr[6].eq {
	pc = 0x82A03A40; continue 'dispatch;
	}
	pc = 0x82A03A2C; continue 'dispatch;
            }
            0x82A03A2C => {
    //   block [0x82A03A2C..0x82A03A40)
	// 82A03A2C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A03A30: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03A34: 892B0081  lbz r9, 0x81(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03A38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03A3C: 419AFFF0  beq cr6, 0x82a03a2c
	if ctx.cr[6].eq {
	pc = 0x82A03A2C; continue 'dispatch;
	}
	pc = 0x82A03A40; continue 'dispatch;
            }
            0x82A03A40 => {
    //   block [0x82A03A40..0x82A03A48)
	// 82A03A40: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A03A44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A03A48 size=80
    let mut pc: u32 = 0x82A03A48;
    'dispatch: loop {
        match pc {
            0x82A03A48 => {
    //   block [0x82A03A48..0x82A03A58)
	// 82A03A48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03A4C: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03A50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03A54: 409A002C  bne cr6, 0x82a03a80
	if !ctx.cr[6].eq {
	pc = 0x82A03A80; continue 'dispatch;
	}
	pc = 0x82A03A58; continue 'dispatch;
            }
            0x82A03A58 => {
    //   block [0x82A03A58..0x82A03A80)
	// 82A03A58: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03A5C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03A60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A03A64: 409A001C  bne cr6, 0x82a03a80
	if !ctx.cr[6].eq {
	pc = 0x82A03A80; continue 'dispatch;
	}
	// 82A03A68: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A03A6C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A03A70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03A74: 894B0081  lbz r10, 0x81(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03A78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03A7C: 419AFFDC  beq cr6, 0x82a03a58
	if ctx.cr[6].eq {
	pc = 0x82A03A58; continue 'dispatch;
	}
	pc = 0x82A03A80; continue 'dispatch;
            }
            0x82A03A80 => {
    //   block [0x82A03A80..0x82A03A98)
	// 82A03A80: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03A84: 892A0081  lbz r9, 0x81(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A03A88: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A03A8C: 409AFF78  bne cr6, 0x82a03a04
	if !ctx.cr[6].eq {
		sub_82A039D0(ctx, base);
		return;
	}
	// 82A03A90: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A03A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03A98 size=132
    let mut pc: u32 = 0x82A03A98;
    'dispatch: loop {
        match pc {
            0x82A03A98 => {
    //   block [0x82A03A98..0x82A03AC8)
	// 82A03A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03A9C: 482A596D  bl 0x82ca9408
	ctx.lr = 0x82A03AA0;
	sub_82CA93D0(ctx, base);
	// 82A03AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A03AA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A03AA8: 7D63E850  subf r11, r3, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	// 82A03AAC: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A03AB0: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A03AB4: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A03AB8: 7F8B2A14  add r28, r11, r5
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82A03ABC: 419A0054  beq cr6, 0x82a03b10
	if ctx.cr[6].eq {
	pc = 0x82A03B10; continue 'dispatch;
	}
	// 82A03AC0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A03AC4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A03AC8; continue 'dispatch;
            }
            0x82A03AC8 => {
    //   block [0x82A03AC8..0x82A03AE8)
	// 82A03AC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03ACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03AD0: 419A0020  beq cr6, 0x82a03af0
	if ctx.cr[6].eq {
	pc = 0x82A03AF0; continue 'dispatch;
	}
	// 82A03AD4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03AD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03ADC: 419A000C  beq cr6, 0x82a03ae8
	if ctx.cr[6].eq {
	pc = 0x82A03AE8; continue 'dispatch;
	}
	// 82A03AE0: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A03AE4: 48000010  b 0x82a03af4
	pc = 0x82A03AF4; continue 'dispatch;
            }
            0x82A03AE8 => {
    //   block [0x82A03AE8..0x82A03AF0)
	// 82A03AE8: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 82A03AEC: 4B79034D  bl 0x82193e38
	ctx.lr = 0x82A03AF0;
	sub_82193E38(ctx, base);
	pc = 0x82A03AF0; continue 'dispatch;
            }
            0x82A03AF0 => {
    //   block [0x82A03AF0..0x82A03AF4)
	// 82A03AF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82A03AF4; continue 'dispatch;
            }
            0x82A03AF4 => {
    //   block [0x82A03AF4..0x82A03B10)
	// 82A03AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A03AF8: 4B810DA1  bl 0x82214898
	ctx.lr = 0x82A03AFC;
	sub_82214898(ctx, base);
	// 82A03AFC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A03B00: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A03B04: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 82A03B08: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A03B0C: 409AFFBC  bne cr6, 0x82a03ac8
	if !ctx.cr[6].eq {
	pc = 0x82A03AC8; continue 'dispatch;
	}
	pc = 0x82A03B10; continue 'dispatch;
            }
            0x82A03B10 => {
    //   block [0x82A03B10..0x82A03B1C)
	// 82A03B10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A03B14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A03B18: 482A5940  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03B20 size=136
    let mut pc: u32 = 0x82A03B20;
    'dispatch: loop {
        match pc {
            0x82A03B20 => {
    //   block [0x82A03B20..0x82A03B44)
	// 82A03B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03B24: 482A58DD  bl 0x82ca9400
	ctx.lr = 0x82A03B28;
	sub_82CA93D0(ctx, base);
	// 82A03B28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A03B2C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82A03B30: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A03B34: 7F03D040  cmplw cr6, r3, r26
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A03B38: 419A0068  beq cr6, 0x82a03ba0
	if ctx.cr[6].eq {
	pc = 0x82A03BA0; continue 'dispatch;
	}
	// 82A03B3C: 3B7D0008  addi r27, r29, 8
	ctx.r[27].s64 = ctx.r[29].s64 + 8;
	// 82A03B40: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A03B44; continue 'dispatch;
            }
            0x82A03B44 => {
    //   block [0x82A03B44..0x82A03B7C)
	// 82A03B44: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03B48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03B4C: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03B50: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A03B54: 419A0028  beq cr6, 0x82a03b7c
	if ctx.cr[6].eq {
	pc = 0x82A03B7C; continue 'dispatch;
	}
	// 82A03B58: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 82A03B5C: 4B7B3FBD  bl 0x821b7b18
	ctx.lr = 0x82A03B60;
	sub_821B7B18(ctx, base);
	// 82A03B60: 939FFFFC  stw r28, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[28].u32 ) };
	// 82A03B64: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A03B68: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A03B6C: 419A0010  beq cr6, 0x82a03b7c
	if ctx.cr[6].eq {
	pc = 0x82A03B7C; continue 'dispatch;
	}
	// 82A03B70: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03B74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A03B78: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A03B7C; continue 'dispatch;
            }
            0x82A03B7C => {
    //   block [0x82A03B7C..0x82A03BA0)
	// 82A03B7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A03B80: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A03B84: 4BE80C2D  bl 0x828847b0
	ctx.lr = 0x82A03B88;
	sub_828847B0(ctx, base);
	// 82A03B88: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A03B8C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A03B90: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82A03B94: 395FFFFC  addi r10, r31, -4
	ctx.r[10].s64 = ctx.r[31].s64 + -4;
	// 82A03B98: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A03B9C: 409AFFA8  bne cr6, 0x82a03b44
	if !ctx.cr[6].eq {
	pc = 0x82A03B44; continue 'dispatch;
	}
	pc = 0x82A03BA0; continue 'dispatch;
            }
            0x82A03BA0 => {
    //   block [0x82A03BA0..0x82A03BA8)
	// 82A03BA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A03BA4: 482A58AC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A03BA8 size=60
    let mut pc: u32 = 0x82A03BA8;
    'dispatch: loop {
        match pc {
            0x82A03BA8 => {
    //   block [0x82A03BA8..0x82A03BE4)
	// 82A03BA8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A03BAC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A03BB0: 392B91A0  addi r9, r11, -0x6e60
	ctx.r[9].s64 = ctx.r[11].s64 + -28256;
	// 82A03BB4: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 82A03BB8: 38E00050  li r7, 0x50
	ctx.r[7].s64 = 80;
	// 82A03BBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A03BC0: C00A9490  lfs f0, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A03BE8 size=68
    let mut pc: u32 = 0x82A03BE8;
    'dispatch: loop {
        match pc {
            0x82A03BE8 => {
    //   block [0x82A03BE8..0x82A03C2C)
	// 82A03BE8: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 82A03BEC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A03BF0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A03BF4: 390A91A0  addi r8, r10, -0x6e60
	ctx.r[8].s64 = ctx.r[10].s64 + -28256;
	// 82A03BF8: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A03C30 size=12
    let mut pc: u32 = 0x82A03C30;
    'dispatch: loop {
        match pc {
            0x82A03C30 => {
    //   block [0x82A03C30..0x82A03C3C)
	// 82A03C30: D02300CC  stfs f1, 0xcc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82A03C34: D023019C  stfs f1, 0x19c(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82A03C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03C40 size=80
    let mut pc: u32 = 0x82A03C40;
    'dispatch: loop {
        match pc {
            0x82A03C40 => {
    //   block [0x82A03C40..0x82A03C78)
	// 82A03C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A03C48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A03C4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A03C50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A03C54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A03C58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A03C5C: 4882E8D5  bl 0x83232530
	ctx.lr = 0x82A03C60;
	sub_83232530(ctx, base);
	// 82A03C60: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A03C64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A03C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03C6C: 419A000C  beq cr6, 0x82a03c78
	if ctx.cr[6].eq {
	pc = 0x82A03C78; continue 'dispatch;
	}
	// 82A03C70: 4B8180C9  bl 0x8221bd38
	ctx.lr = 0x82A03C74;
	sub_8221BD38(ctx, base);
	// 82A03C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A03C78; continue 'dispatch;
            }
            0x82A03C78 => {
    //   block [0x82A03C78..0x82A03C90)
	// 82A03C78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A03C7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A03C80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A03C84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A03C88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A03C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03C90 size=200
    let mut pc: u32 = 0x82A03C90;
    'dispatch: loop {
        match pc {
            0x82A03C90 => {
    //   block [0x82A03C90..0x82A03CF8)
	// 82A03C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A03C98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A03C9C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A03CA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A03CA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A03CA8: 394B6958  addi r10, r11, 0x6958
	ctx.r[10].s64 = ctx.r[11].s64 + 26968;
	// 82A03CAC: 807F01E0  lwz r3, 0x1e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82A03CB0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A03CB4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03CB8: 8109003C  lwz r8, 0x3c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 82A03CBC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A03CC0: 4E800421  bctrl
	ctx.lr = 0x82A03CC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A03CC4: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82A03CC8: 409A0074  bne cr6, 0x82a03d3c
	if !ctx.cr[6].eq {
	pc = 0x82A03D3C; continue 'dispatch;
	}
	// 82A03CCC: 817F01E4  lwz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A03CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03CD4: 419A0068  beq cr6, 0x82a03d3c
	if ctx.cr[6].eq {
	pc = 0x82A03D3C; continue 'dispatch;
	}
	// 82A03CD8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A03CDC: 392BE4E8  addi r9, r11, -0x1b18
	ctx.r[9].s64 = ctx.r[11].s64 + -6936;
	// 82A03CE0: 814BE4E8  lwz r10, -0x1b18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6936 as u32) ) } as u64;
	// 82A03CE4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03CEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A03CF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A03CF4: 419A0020  beq cr6, 0x82a03d14
	if ctx.cr[6].eq {
	pc = 0x82A03D14; continue 'dispatch;
	}
            }
            0x82A03CF8 => {
    //   block [0x82A03CF8..0x82A03D14)
	// 82A03CF8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A03CFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03D00: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A03D04: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A03D08: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A03D0C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03D10: 4082FFE8  bne 0x82a03cf8
	if !ctx.cr[0].eq {
	pc = 0x82A03CF8; continue 'dispatch;
	}
	pc = 0x82A03D14; continue 'dispatch;
            }
            0x82A03D14 => {
    //   block [0x82A03D14..0x82A03D34)
	// 82A03D14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A03D18: 419A001C  beq cr6, 0x82a03d34
	if ctx.cr[6].eq {
	pc = 0x82A03D34; continue 'dispatch;
	}
	// 82A03D1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03D20: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A03D24: 809F01E4  lwz r4, 0x1e4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A03D28: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A03D2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A03D30: 4E800421  bctrl
	ctx.lr = 0x82A03D34;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A03D34 => {
    //   block [0x82A03D34..0x82A03D3C)
	// 82A03D34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A03D38: 4B7B3DE1  bl 0x821b7b18
	ctx.lr = 0x82A03D3C;
	sub_821B7B18(ctx, base);
	pc = 0x82A03D3C; continue 'dispatch;
            }
            0x82A03D3C => {
    //   block [0x82A03D3C..0x82A03D58)
	// 82A03D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A03D40: 488294B9  bl 0x8322d1f8
	ctx.lr = 0x82A03D44;
	sub_8322D1F8(ctx, base);
	// 82A03D44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A03D48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A03D4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A03D50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A03D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A03D58 size=996
    let mut pc: u32 = 0x82A03D58;
    'dispatch: loop {
        match pc {
            0x82A03D58 => {
    //   block [0x82A03D58..0x82A0413C)
	// 82A03D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03D5C: 482A569D  bl 0x82ca93f8
	ctx.lr = 0x82A03D60;
	sub_82CA93D0(ctx, base);
	// 82A03D60: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82A03D64: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04140 size=200
    let mut pc: u32 = 0x82A04140;
    'dispatch: loop {
        match pc {
            0x82A04140 => {
    //   block [0x82A04140..0x82A041A8)
	// 82A04140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0414C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04150: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04154: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A04158: 394B66A8  addi r10, r11, 0x66a8
	ctx.r[10].s64 = ctx.r[11].s64 + 26280;
	// 82A0415C: 807F01E0  lwz r3, 0x1e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82A04160: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A04164: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04168: 8109003C  lwz r8, 0x3c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 82A0416C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A04170: 4E800421  bctrl
	ctx.lr = 0x82A04174;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04174: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82A04178: 409A0074  bne cr6, 0x82a041ec
	if !ctx.cr[6].eq {
	pc = 0x82A041EC; continue 'dispatch;
	}
	// 82A0417C: 817F01E4  lwz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A04180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04184: 419A0068  beq cr6, 0x82a041ec
	if ctx.cr[6].eq {
	pc = 0x82A041EC; continue 'dispatch;
	}
	// 82A04188: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0418C: 392BE4E8  addi r9, r11, -0x1b18
	ctx.r[9].s64 = ctx.r[11].s64 + -6936;
	// 82A04190: 814BE4E8  lwz r10, -0x1b18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6936 as u32) ) } as u64;
	// 82A04194: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0419C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A041A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A041A4: 419A0020  beq cr6, 0x82a041c4
	if ctx.cr[6].eq {
	pc = 0x82A041C4; continue 'dispatch;
	}
            }
            0x82A041A8 => {
    //   block [0x82A041A8..0x82A041C4)
	// 82A041A8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A041AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A041B0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A041B4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A041B8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A041BC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A041C0: 4082FFE8  bne 0x82a041a8
	if !ctx.cr[0].eq {
	pc = 0x82A041A8; continue 'dispatch;
	}
	pc = 0x82A041C4; continue 'dispatch;
            }
            0x82A041C4 => {
    //   block [0x82A041C4..0x82A041E4)
	// 82A041C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A041C8: 419A001C  beq cr6, 0x82a041e4
	if ctx.cr[6].eq {
	pc = 0x82A041E4; continue 'dispatch;
	}
	// 82A041CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A041D0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A041D4: 809F01E4  lwz r4, 0x1e4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A041D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A041DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A041E0: 4E800421  bctrl
	ctx.lr = 0x82A041E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A041E4 => {
    //   block [0x82A041E4..0x82A041EC)
	// 82A041E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A041E8: 4B7B3931  bl 0x821b7b18
	ctx.lr = 0x82A041EC;
	sub_821B7B18(ctx, base);
	pc = 0x82A041EC; continue 'dispatch;
            }
            0x82A041EC => {
    //   block [0x82A041EC..0x82A04208)
	// 82A041EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A041F0: 48829009  bl 0x8322d1f8
	ctx.lr = 0x82A041F4;
	sub_8322D1F8(ctx, base);
	// 82A041F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A041F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A041FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04200: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A04208 size=996
    let mut pc: u32 = 0x82A04208;
    'dispatch: loop {
        match pc {
            0x82A04208 => {
    //   block [0x82A04208..0x82A045EC)
	// 82A04208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0420C: 482A51ED  bl 0x82ca93f8
	ctx.lr = 0x82A04210;
	sub_82CA93D0(ctx, base);
	// 82A04210: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82A04214: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A045F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A045F0 size=200
    let mut pc: u32 = 0x82A045F0;
    'dispatch: loop {
        match pc {
            0x82A045F0 => {
    //   block [0x82A045F0..0x82A04658)
	// 82A045F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A045F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A045F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A045FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04604: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A04608: 394B21D0  addi r10, r11, 0x21d0
	ctx.r[10].s64 = ctx.r[11].s64 + 8656;
	// 82A0460C: 807F01E0  lwz r3, 0x1e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82A04610: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A04614: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04618: 8109003C  lwz r8, 0x3c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 82A0461C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A04620: 4E800421  bctrl
	ctx.lr = 0x82A04624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04624: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82A04628: 409A0074  bne cr6, 0x82a0469c
	if !ctx.cr[6].eq {
	pc = 0x82A0469C; continue 'dispatch;
	}
	// 82A0462C: 817F01E4  lwz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A04630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04634: 419A0068  beq cr6, 0x82a0469c
	if ctx.cr[6].eq {
	pc = 0x82A0469C; continue 'dispatch;
	}
	// 82A04638: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0463C: 392BE4E8  addi r9, r11, -0x1b18
	ctx.r[9].s64 = ctx.r[11].s64 + -6936;
	// 82A04640: 814BE4E8  lwz r10, -0x1b18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6936 as u32) ) } as u64;
	// 82A04644: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0464C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A04650: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04654: 419A0020  beq cr6, 0x82a04674
	if ctx.cr[6].eq {
	pc = 0x82A04674; continue 'dispatch;
	}
            }
            0x82A04658 => {
    //   block [0x82A04658..0x82A04674)
	// 82A04658: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A0465C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A04660: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A04664: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A04668: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0466C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A04670: 4082FFE8  bne 0x82a04658
	if !ctx.cr[0].eq {
	pc = 0x82A04658; continue 'dispatch;
	}
	pc = 0x82A04674; continue 'dispatch;
            }
            0x82A04674 => {
    //   block [0x82A04674..0x82A04694)
	// 82A04674: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A04678: 419A001C  beq cr6, 0x82a04694
	if ctx.cr[6].eq {
	pc = 0x82A04694; continue 'dispatch;
	}
	// 82A0467C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04680: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A04684: 809F01E4  lwz r4, 0x1e4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A04688: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0468C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A04690: 4E800421  bctrl
	ctx.lr = 0x82A04694;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A04694 => {
    //   block [0x82A04694..0x82A0469C)
	// 82A04694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04698: 4B7B3481  bl 0x821b7b18
	ctx.lr = 0x82A0469C;
	sub_821B7B18(ctx, base);
	pc = 0x82A0469C; continue 'dispatch;
            }
            0x82A0469C => {
    //   block [0x82A0469C..0x82A046B8)
	// 82A0469C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A046A0: 48828B59  bl 0x8322d1f8
	ctx.lr = 0x82A046A4;
	sub_8322D1F8(ctx, base);
	// 82A046A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A046A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A046AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A046B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A046B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A046B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A046B8 size=996
    let mut pc: u32 = 0x82A046B8;
    'dispatch: loop {
        match pc {
            0x82A046B8 => {
    //   block [0x82A046B8..0x82A04A9C)
	// 82A046B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A046BC: 482A4D3D  bl 0x82ca93f8
	ctx.lr = 0x82A046C0;
	sub_82CA93D0(ctx, base);
	// 82A046C0: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82A046C4: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04AA0 size=80
    let mut pc: u32 = 0x82A04AA0;
    'dispatch: loop {
        match pc {
            0x82A04AA0 => {
    //   block [0x82A04AA0..0x82A04AD8)
	// 82A04AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04AB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A04ABC: 4BFFF1D5  bl 0x82a03c90
	ctx.lr = 0x82A04AC0;
	sub_82A03C90(ctx, base);
	// 82A04AC0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A04AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04ACC: 419A000C  beq cr6, 0x82a04ad8
	if ctx.cr[6].eq {
	pc = 0x82A04AD8; continue 'dispatch;
	}
	// 82A04AD0: 4B817269  bl 0x8221bd38
	ctx.lr = 0x82A04AD4;
	sub_8221BD38(ctx, base);
	// 82A04AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A04AD8; continue 'dispatch;
            }
            0x82A04AD8 => {
    //   block [0x82A04AD8..0x82A04AF0)
	// 82A04AD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04ADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04AE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04AE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04AE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04AEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04AF0 size=80
    let mut pc: u32 = 0x82A04AF0;
    'dispatch: loop {
        match pc {
            0x82A04AF0 => {
    //   block [0x82A04AF0..0x82A04B28)
	// 82A04AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04B00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04B08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A04B0C: 4B7767C5  bl 0x8217b2d0
	ctx.lr = 0x82A04B10;
	sub_8217B2D0(ctx, base);
	// 82A04B10: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A04B14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04B1C: 419A000C  beq cr6, 0x82a04b28
	if ctx.cr[6].eq {
	pc = 0x82A04B28; continue 'dispatch;
	}
	// 82A04B20: 4B817219  bl 0x8221bd38
	ctx.lr = 0x82A04B24;
	sub_8221BD38(ctx, base);
	// 82A04B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A04B28; continue 'dispatch;
            }
            0x82A04B28 => {
    //   block [0x82A04B28..0x82A04B40)
	// 82A04B28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04B34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04B40 size=80
    let mut pc: u32 = 0x82A04B40;
    'dispatch: loop {
        match pc {
            0x82A04B40 => {
    //   block [0x82A04B40..0x82A04B78)
	// 82A04B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04B48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04B4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04B50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04B54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04B58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A04B5C: 4BFFF5E5  bl 0x82a04140
	ctx.lr = 0x82A04B60;
	sub_82A04140(ctx, base);
	// 82A04B60: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A04B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04B6C: 419A000C  beq cr6, 0x82a04b78
	if ctx.cr[6].eq {
	pc = 0x82A04B78; continue 'dispatch;
	}
	// 82A04B70: 4B8171C9  bl 0x8221bd38
	ctx.lr = 0x82A04B74;
	sub_8221BD38(ctx, base);
	// 82A04B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A04B78; continue 'dispatch;
            }
            0x82A04B78 => {
    //   block [0x82A04B78..0x82A04B90)
	// 82A04B78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04B7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04B80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04B84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04B88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04B90 size=80
    let mut pc: u32 = 0x82A04B90;
    'dispatch: loop {
        match pc {
            0x82A04B90 => {
    //   block [0x82A04B90..0x82A04BC8)
	// 82A04B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04B98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04B9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04BA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04BA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A04BAC: 4BFFFA45  bl 0x82a045f0
	ctx.lr = 0x82A04BB0;
	sub_82A045F0(ctx, base);
	// 82A04BB0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A04BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04BBC: 419A000C  beq cr6, 0x82a04bc8
	if ctx.cr[6].eq {
	pc = 0x82A04BC8; continue 'dispatch;
	}
	// 82A04BC0: 4B817179  bl 0x8221bd38
	ctx.lr = 0x82A04BC4;
	sub_8221BD38(ctx, base);
	// 82A04BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A04BC8; continue 'dispatch;
            }
            0x82A04BC8 => {
    //   block [0x82A04BC8..0x82A04BE0)
	// 82A04BC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04BD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04BD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04BE0 size=220
    let mut pc: u32 = 0x82A04BE0;
    'dispatch: loop {
        match pc {
            0x82A04BE0 => {
    //   block [0x82A04BE0..0x82A04C08)
	// 82A04BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04BEC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A04BF0: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04BF4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04BF8: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A04BFC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A04C00: 409A0030  bne cr6, 0x82a04c30
	if !ctx.cr[6].eq {
	pc = 0x82A04C30; continue 'dispatch;
	}
	// 82A04C04: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A04C08; continue 'dispatch;
            }
            0x82A04C08 => {
    //   block [0x82A04C08..0x82A04C1C)
	// 82A04C08: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A04C0C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A04C10: 4098000C  bge cr6, 0x82a04c1c
	if !ctx.cr[6].lt {
	pc = 0x82A04C1C; continue 'dispatch;
	}
	// 82A04C14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A04C18: 4800000C  b 0x82a04c24
	pc = 0x82A04C24; continue 'dispatch;
            }
            0x82A04C1C => {
    //   block [0x82A04C1C..0x82A04C24)
	// 82A04C1C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A04C20: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A04C24; continue 'dispatch;
            }
            0x82A04C24 => {
    //   block [0x82A04C24..0x82A04C30)
	// 82A04C24: 88EB0015  lbz r7, 0x15(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A04C28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A04C2C: 419AFFDC  beq cr6, 0x82a04c08
	if ctx.cr[6].eq {
	pc = 0x82A04C08; continue 'dispatch;
	}
	pc = 0x82A04C30; continue 'dispatch;
            }
            0x82A04C30 => {
    //   block [0x82A04C30..0x82A04C58)
	// 82A04C30: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04C34: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A04C38: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A04C3C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04C40: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A04C44: 419A0014  beq cr6, 0x82a04c58
	if ctx.cr[6].eq {
	pc = 0x82A04C58; continue 'dispatch;
	}
	// 82A04C48: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04C4C: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A04C50: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A04C54: 40980038  bge cr6, 0x82a04c8c
	if !ctx.cr[6].lt {
	pc = 0x82A04C8C; continue 'dispatch;
	}
	pc = 0x82A04C58; continue 'dispatch;
            }
            0x82A04C58 => {
    //   block [0x82A04C58..0x82A04C8C)
	// 82A04C58: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04C5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A04C60: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A04C64: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A04C68: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A04C6C: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82A04C70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A04C74: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A04C78: 480000B1  bl 0x82a04d28
	ctx.lr = 0x82A04C7C;
	sub_82A04D28(ctx, base);
	// 82A04C7C: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A04C80: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A04C84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A04C88: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A04C8C; continue 'dispatch;
            }
            0x82A04C8C => {
    //   block [0x82A04C8C..0x82A04C98)
	// 82A04C8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A04C90: 409A0008  bne cr6, 0x82a04c98
	if !ctx.cr[6].eq {
	pc = 0x82A04C98; continue 'dispatch;
	}
	// 82A04C94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A04C98; continue 'dispatch;
            }
            0x82A04C98 => {
    //   block [0x82A04C98..0x82A04CA8)
	// 82A04C98: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04C9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A04CA0: 409A0008  bne cr6, 0x82a04ca8
	if !ctx.cr[6].eq {
	pc = 0x82A04CA8; continue 'dispatch;
	}
	// 82A04CA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A04CA8; continue 'dispatch;
            }
            0x82A04CA8 => {
    //   block [0x82A04CA8..0x82A04CBC)
	// 82A04CA8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82A04CAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04CC0 size=104
    let mut pc: u32 = 0x82A04CC0;
    'dispatch: loop {
        match pc {
            0x82A04CC0 => {
    //   block [0x82A04CC0..0x82A04D0C)
	// 82A04CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04CCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04CD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04CD4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A04CD8: 4B81A581  bl 0x8221f258
	ctx.lr = 0x82A04CDC;
	sub_8221F258(ctx, base);
	// 82A04CDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04CE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04CE8: 419A0024  beq cr6, 0x82a04d0c
	if ctx.cr[6].eq {
	pc = 0x82A04D0C; continue 'dispatch;
	}
	// 82A04CEC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04CF0: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 82A04CF4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A04CF8: 38E99238  addi r7, r9, -0x6dc8
	ctx.r[7].s64 = ctx.r[9].s64 + -28104;
	// 82A04CFC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A04D00: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A04D04: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04D08: 48000008  b 0x82a04d10
	pc = 0x82A04D10; continue 'dispatch;
            }
            0x82A04D0C => {
    //   block [0x82A04D0C..0x82A04D10)
	// 82A04D0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A04D10; continue 'dispatch;
            }
            0x82A04D10 => {
    //   block [0x82A04D10..0x82A04D28)
	// 82A04D10: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A04D14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A04D18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04D1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04D20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04D24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04D28 size=540
    let mut pc: u32 = 0x82A04D28;
    'dispatch: loop {
        match pc {
            0x82A04D28 => {
    //   block [0x82A04D28..0x82A04D7C)
	// 82A04D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04D2C: 482A46D9  bl 0x82ca9404
	ctx.lr = 0x82A04D30;
	sub_82CA93D0(ctx, base);
	// 82A04D30: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04D34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04D38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04D3C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A04D40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04D44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A04D48: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 82A04D4C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A04D50: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A04D54: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04D58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A04D5C: 409A0020  bne cr6, 0x82a04d7c
	if !ctx.cr[6].eq {
	pc = 0x82A04D7C; continue 'dispatch;
	}
	// 82A04D60: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A04D64: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04D68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A04D6C: 48009045  bl 0x82a0ddb0
	ctx.lr = 0x82A04D70;
	sub_82A0DDB0(ctx, base);
	// 82A04D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04D74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A04D78: 482A46DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A04D7C => {
    //   block [0x82A04D7C..0x82A04D98)
	// 82A04D7C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04D80: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A04D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04D88: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04D8C: 419A000C  beq cr6, 0x82a04d98
	if ctx.cr[6].eq {
	pc = 0x82A04D98; continue 'dispatch;
	}
	// 82A04D90: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A04D94: 419A0008  beq cr6, 0x82a04d9c
	if ctx.cr[6].eq {
	pc = 0x82A04D9C; continue 'dispatch;
	}
	pc = 0x82A04D98; continue 'dispatch;
            }
            0x82A04D98 => {
    //   block [0x82A04D98..0x82A04D9C)
	// 82A04D98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A04D9C; continue 'dispatch;
            }
            0x82A04D9C => {
    //   block [0x82A04D9C..0x82A04DDC)
	// 82A04D9C: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A04DA0: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A04DA4: 409A0038  bne cr6, 0x82a04ddc
	if !ctx.cr[6].eq {
	pc = 0x82A04DDC; continue 'dispatch;
	}
	// 82A04DA8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04DAC: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A04DB0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A04DB4: 40980160  bge cr6, 0x82a04f14
	if !ctx.cr[6].lt {
	pc = 0x82A04F14; continue 'dispatch;
	}
	// 82A04DB8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A04DBC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A04DC0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A04DC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A04DC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04DCC: 48008FE5  bl 0x82a0ddb0
	ctx.lr = 0x82A04DD0;
	sub_82A0DDB0(ctx, base);
	// 82A04DD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04DD4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A04DD8: 482A467C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A04DDC => {
    //   block [0x82A04DDC..0x82A04DEC)
	// 82A04DDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04DE0: 419A000C  beq cr6, 0x82a04dec
	if ctx.cr[6].eq {
	pc = 0x82A04DEC; continue 'dispatch;
	}
	// 82A04DE4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A04DE8: 419A0008  beq cr6, 0x82a04df0
	if ctx.cr[6].eq {
	pc = 0x82A04DF0; continue 'dispatch;
	}
	pc = 0x82A04DEC; continue 'dispatch;
            }
            0x82A04DEC => {
    //   block [0x82A04DEC..0x82A04DF0)
	// 82A04DEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A04DF0; continue 'dispatch;
            }
            0x82A04DF0 => {
    //   block [0x82A04DF0..0x82A04E2C)
	// 82A04DF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04DF4: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A04DF8: 409A0034  bne cr6, 0x82a04e2c
	if !ctx.cr[6].eq {
	pc = 0x82A04E2C; continue 'dispatch;
	}
	// 82A04DFC: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A04E00: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A04E04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A04E08: 4098010C  bge cr6, 0x82a04f14
	if !ctx.cr[6].lt {
	pc = 0x82A04F14; continue 'dispatch;
	}
	// 82A04E0C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A04E10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A04E14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A04E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04E1C: 48008F95  bl 0x82a0ddb0
	ctx.lr = 0x82A04E20;
	sub_82A0DDB0(ctx, base);
	// 82A04E20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04E24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A04E28: 482A462C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A04E2C => {
    //   block [0x82A04E2C..0x82A04E78)
	// 82A04E2C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A04E30: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A04E34: 40980058  bge cr6, 0x82a04e8c
	if !ctx.cr[6].lt {
	pc = 0x82A04E8C; continue 'dispatch;
	}
	// 82A04E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04E3C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82A04E40: 480AF6B9  bl 0x82ab44f8
	ctx.lr = 0x82A04E44;
	sub_82AB44F8(ctx, base);
	// 82A04E44: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A04E48: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04E4C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A04E50: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A04E54: 40980038  bge cr6, 0x82a04e8c
	if !ctx.cr[6].lt {
	pc = 0x82A04E8C; continue 'dispatch;
	}
	// 82A04E58: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A04E5C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A04E60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A04E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04E68: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A04E6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A04E70: 409A0090  bne cr6, 0x82a04f00
	if !ctx.cr[6].eq {
	pc = 0x82A04F00; continue 'dispatch;
	}
	// 82A04E74: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A04E78; continue 'dispatch;
            }
            0x82A04E78 => {
    //   block [0x82A04E78..0x82A04E8C)
	// 82A04E78: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A04E7C: 48008F35  bl 0x82a0ddb0
	ctx.lr = 0x82A04E80;
	sub_82A0DDB0(ctx, base);
	// 82A04E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04E84: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A04E88: 482A45CC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A04E8C => {
    //   block [0x82A04E8C..0x82A04EBC)
	// 82A04E8C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A04E90: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A04E94: 40980080  bge cr6, 0x82a04f14
	if !ctx.cr[6].lt {
	pc = 0x82A04F14; continue 'dispatch;
	}
	// 82A04E98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04E9C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82A04EA0: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04EA4: 4BB519B5  bl 0x82556858
	ctx.lr = 0x82A04EA8;
	sub_82556858(ctx, base);
	// 82A04EA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04EB0: 419A000C  beq cr6, 0x82a04ebc
	if ctx.cr[6].eq {
	pc = 0x82A04EBC; continue 'dispatch;
	}
	// 82A04EB4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A04EB8: 419A0008  beq cr6, 0x82a04ec0
	if ctx.cr[6].eq {
	pc = 0x82A04EC0; continue 'dispatch;
	}
	pc = 0x82A04EBC; continue 'dispatch;
            }
            0x82A04EBC => {
    //   block [0x82A04EBC..0x82A04EC0)
	// 82A04EBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A04EC0; continue 'dispatch;
            }
            0x82A04EC0 => {
    //   block [0x82A04EC0..0x82A04EE0)
	// 82A04EC0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04EC4: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A04EC8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A04ECC: 419A0014  beq cr6, 0x82a04ee0
	if ctx.cr[6].eq {
	pc = 0x82A04EE0; continue 'dispatch;
	}
	// 82A04ED0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04ED4: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A04ED8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A04EDC: 40980038  bge cr6, 0x82a04f14
	if !ctx.cr[6].lt {
	pc = 0x82A04F14; continue 'dispatch;
	}
	pc = 0x82A04EE0; continue 'dispatch;
            }
            0x82A04EE0 => {
    //   block [0x82A04EE0..0x82A04F00)
	// 82A04EE0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A04EE4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A04EE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A04EEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04EF0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A04EF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A04EF8: 419AFF80  beq cr6, 0x82a04e78
	if ctx.cr[6].eq {
	pc = 0x82A04E78; continue 'dispatch;
	}
	// 82A04EFC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A04F00; continue 'dispatch;
            }
            0x82A04F00 => {
    //   block [0x82A04F00..0x82A04F14)
	// 82A04F00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A04F04: 48008EAD  bl 0x82a0ddb0
	ctx.lr = 0x82A04F08;
	sub_82A0DDB0(ctx, base);
	// 82A04F08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04F0C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A04F10: 482A4544  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A04F14 => {
    //   block [0x82A04F14..0x82A04F44)
	// 82A04F14: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A04F18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A04F1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A04F20: 4B965BD9  bl 0x8236aaf8
	ctx.lr = 0x82A04F24;
	sub_8236AAF8(ctx, base);
	// 82A04F24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04F28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04F2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04F30: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A04F34: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04F38: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A04F3C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A04F40: 482A4514  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04F48 size=84
    let mut pc: u32 = 0x82A04F48;
    'dispatch: loop {
        match pc {
            0x82A04F48 => {
    //   block [0x82A04F48..0x82A04F84)
	// 82A04F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04F50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04F54: 386300EC  addi r3, r3, 0xec
	ctx.r[3].s64 = ctx.r[3].s64 + 236;
	// 82A04F58: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04F60: 419A0028  beq cr6, 0x82a04f88
	if ctx.cr[6].eq {
	pc = 0x82A04F88; continue 'dispatch;
	}
	// 82A04F64: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04F68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A04F6C: 419A0018  beq cr6, 0x82a04f84
	if ctx.cr[6].eq {
	pc = 0x82A04F84; continue 'dispatch;
	}
	// 82A04F70: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A04F74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A04F78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04F7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04F80: 4E800020  blr
	return;
            }
            0x82A04F84 => {
    //   block [0x82A04F84..0x82A04F88)
	// 82A04F84: 4B78EEB5  bl 0x82193e38
	ctx.lr = 0x82A04F88;
	sub_82193E38(ctx, base);
	pc = 0x82A04F88; continue 'dispatch;
            }
            0x82A04F88 => {
    //   block [0x82A04F88..0x82A04F9C)
	// 82A04F88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A04F8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A04F90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04F94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04F98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04FA0 size=80
    let mut pc: u32 = 0x82A04FA0;
    'dispatch: loop {
        match pc {
            0x82A04FA0 => {
    //   block [0x82A04FA0..0x82A04FD8)
	// 82A04FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04FA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04FAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04FB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04FB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A04FBC: 4882B4B5  bl 0x83230470
	ctx.lr = 0x82A04FC0;
	sub_83230470(ctx, base);
	// 82A04FC0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A04FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04FC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04FCC: 419A000C  beq cr6, 0x82a04fd8
	if ctx.cr[6].eq {
	pc = 0x82A04FD8; continue 'dispatch;
	}
	// 82A04FD0: 4B816D69  bl 0x8221bd38
	ctx.lr = 0x82A04FD4;
	sub_8221BD38(ctx, base);
	// 82A04FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A04FD8; continue 'dispatch;
            }
            0x82A04FD8 => {
    //   block [0x82A04FD8..0x82A04FF0)
	// 82A04FD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04FDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04FE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04FE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04FE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04FF0 size=188
    let mut pc: u32 = 0x82A04FF0;
    'dispatch: loop {
        match pc {
            0x82A04FF0 => {
    //   block [0x82A04FF0..0x82A05054)
	// 82A04FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04FF8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04FFC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05000: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 82A05004: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05008: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A0500C: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A05010: 7D083BD6  divw r8, r8, r7
	ctx.r[8].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 82A05014: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A05018: 4099003C  ble cr6, 0x82a05054
	if !ctx.cr[6].gt {
	pc = 0x82A05054; continue 'dispatch;
	}
	// 82A0501C: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A05020: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A05024: 7CAA4850  subf r5, r10, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A05028: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A0502C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A05030: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A05034: 7C853BD6  divw r4, r5, r7
	ctx.r[4].s32 = ctx.r[5].s32 / ctx.r[7].s32;
	// 82A05038: 7CA45850  subf r5, r4, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82A0503C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A05040: 48000251  bl 0x82a05290
	ctx.lr = 0x82A05044;
	sub_82A05290(ctx, base);
	// 82A05044: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A05048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0504C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A05050: 4E800020  blr
	return;
            }
            0x82A05054 => {
    //   block [0x82A05054..0x82A0509C)
	// 82A05054: 40980048  bge cr6, 0x82a0509c
	if !ctx.cr[6].lt {
	pc = 0x82A0509C; continue 'dispatch;
	}
	// 82A05058: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A0505C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A05060: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A05064: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A05068: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A0506C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A05070: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A05074: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82A05078: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0507C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A05080: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05084: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A05088: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0508C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A05090: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A05094: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A05098: 480000D9  bl 0x82a05170
	ctx.lr = 0x82A0509C;
	sub_82A05170(ctx, base);
	pc = 0x82A0509C; continue 'dispatch;
            }
            0x82A0509C => {
    //   block [0x82A0509C..0x82A050AC)
	// 82A0509C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A050A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A050A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A050A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A050B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A050B0 size=188
    let mut pc: u32 = 0x82A050B0;
    'dispatch: loop {
        match pc {
            0x82A050B0 => {
    //   block [0x82A050B0..0x82A05114)
	// 82A050B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A050B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A050B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A050BC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A050C0: 38E00024  li r7, 0x24
	ctx.r[7].s64 = 36;
	// 82A050C4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A050C8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A050CC: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A050D0: 7D083BD6  divw r8, r8, r7
	ctx.r[8].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 82A050D4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A050D8: 4099003C  ble cr6, 0x82a05114
	if !ctx.cr[6].gt {
	pc = 0x82A05114; continue 'dispatch;
	}
	// 82A050DC: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A050E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A050E4: 7CAA4850  subf r5, r10, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A050E8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A050EC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A050F0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A050F4: 7C853BD6  divw r4, r5, r7
	ctx.r[4].s32 = ctx.r[5].s32 / ctx.r[7].s32;
	// 82A050F8: 7CA45850  subf r5, r4, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82A050FC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A05100: 480005A9  bl 0x82a056a8
	ctx.lr = 0x82A05104;
	sub_82A056A8(ctx, base);
	// 82A05104: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A05108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0510C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A05110: 4E800020  blr
	return;
            }
            0x82A05114 => {
    //   block [0x82A05114..0x82A0515C)
	// 82A05114: 40980048  bge cr6, 0x82a0515c
	if !ctx.cr[6].lt {
	pc = 0x82A0515C; continue 'dispatch;
	}
	// 82A05118: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A0511C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A05120: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A05124: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A05128: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A0512C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A05130: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A05134: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82A05138: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0513C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A05140: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05144: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A05148: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0514C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A05150: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A05154: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A05158: 480000A9  bl 0x82a05200
	ctx.lr = 0x82A0515C;
	sub_82A05200(ctx, base);
	pc = 0x82A0515C; continue 'dispatch;
            }
            0x82A0515C => {
    //   block [0x82A0515C..0x82A0516C)
	// 82A0515C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A05160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A05164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A05168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A05170 size=140
    let mut pc: u32 = 0x82A05170;
    'dispatch: loop {
        match pc {
            0x82A05170 => {
    //   block [0x82A05170..0x82A051BC)
	// 82A05170: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82A05174: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82A05178: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82A0517C: 80E10024  lwz r7, 0x24(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A05180: 8161002C  lwz r11, 0x2c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A05184: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A05188: 419A0068  beq cr6, 0x82a051f0
	if ctx.cr[6].eq {
	pc = 0x82A051F0; continue 'dispatch;
	}
	// 82A0518C: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05190: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82A05194: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A05198: 7D0B3050  subf r8, r11, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 82A0519C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A051A0: 7D4853D6  divw r10, r8, r10
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	// 82A051A4: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A051A8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A051AC: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A051B0: 7FEA3A14  add r31, r10, r7
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82A051B4: 419A0038  beq cr6, 0x82a051ec
	if ctx.cr[6].eq {
	pc = 0x82A051EC; continue 'dispatch;
	}
	// 82A051B8: 7CEB3850  subf r7, r11, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	pc = 0x82A051BC; continue 'dispatch;
            }
            0x82A051BC => {
    //   block [0x82A051BC..0x82A051CC)
	// 82A051BC: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82A051C0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A051C4: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A051C8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A051CC; continue 'dispatch;
            }
            0x82A051CC => {
    //   block [0x82A051CC..0x82A051EC)
	// 82A051CC: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A051D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A051D4: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A051D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A051DC: 4200FFF0  bdnz 0x82a051cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A051CC; continue 'dispatch;
	}
	// 82A051E0: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 82A051E4: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A051E8: 409AFFD4  bne cr6, 0x82a051bc
	if !ctx.cr[6].eq {
	pc = 0x82A051BC; continue 'dispatch;
	}
	pc = 0x82A051EC; continue 'dispatch;
            }
            0x82A051EC => {
    //   block [0x82A051EC..0x82A051F0)
	// 82A051EC: 93E40008  stw r31, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82A051F0; continue 'dispatch;
            }
            0x82A051F0 => {
    //   block [0x82A051F0..0x82A051FC)
	// 82A051F0: F8A30000  std r5, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A051F4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82A051F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A05200 size=140
    let mut pc: u32 = 0x82A05200;
    'dispatch: loop {
        match pc {
            0x82A05200 => {
    //   block [0x82A05200..0x82A0524C)
	// 82A05200: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82A05204: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82A05208: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82A0520C: 80E10024  lwz r7, 0x24(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A05210: 8161002C  lwz r11, 0x2c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A05214: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A05218: 419A0068  beq cr6, 0x82a05280
	if ctx.cr[6].eq {
	pc = 0x82A05280; continue 'dispatch;
	}
	// 82A0521C: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05220: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 82A05224: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A05228: 7D0B3050  subf r8, r11, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 82A0522C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A05230: 7D4853D6  divw r10, r8, r10
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	// 82A05234: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A05238: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A0523C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A05240: 7FEA3A14  add r31, r10, r7
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82A05244: 419A0038  beq cr6, 0x82a0527c
	if ctx.cr[6].eq {
	pc = 0x82A0527C; continue 'dispatch;
	}
	// 82A05248: 7CEB3850  subf r7, r11, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	pc = 0x82A0524C; continue 'dispatch;
            }
            0x82A0524C => {
    //   block [0x82A0524C..0x82A0525C)
	// 82A0524C: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82A05250: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A05254: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 82A05258: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A0525C; continue 'dispatch;
            }
            0x82A0525C => {
    //   block [0x82A0525C..0x82A0527C)
	// 82A0525C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05260: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A05264: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A05268: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A0526C: 4200FFF0  bdnz 0x82a0525c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0525C; continue 'dispatch;
	}
	// 82A05270: 39290024  addi r9, r9, 0x24
	ctx.r[9].s64 = ctx.r[9].s64 + 36;
	// 82A05274: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A05278: 409AFFD4  bne cr6, 0x82a0524c
	if !ctx.cr[6].eq {
	pc = 0x82A0524C; continue 'dispatch;
	}
	pc = 0x82A0527C; continue 'dispatch;
            }
            0x82A0527C => {
    //   block [0x82A0527C..0x82A05280)
	// 82A0527C: 93E40008  stw r31, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82A05280; continue 'dispatch;
            }
            0x82A05280 => {
    //   block [0x82A05280..0x82A0528C)
	// 82A05280: F8A30000  std r5, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A05284: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82A05288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05290 size=1044
    let mut pc: u32 = 0x82A05290;
    'dispatch: loop {
        match pc {
            0x82A05290 => {
    //   block [0x82A05290..0x82A052B8)
	// 82A05290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05294: 482A4171  bl 0x82ca9404
	ctx.lr = 0x82A05298;
	sub_82CA93D0(ctx, base);
	// 82A05298: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0529C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A052A0: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82A052A4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A052A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A052AC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A052B0: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A052B4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A052B8; continue 'dispatch;
            }
            0x82A052B8 => {
    //   block [0x82A052B8..0x82A052E4)
	// 82A052B8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A052BC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A052C0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A052C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A052C8: 4200FFF0  bdnz 0x82a052b8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A052B8; continue 'dispatch;
	}
	// 82A052CC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A052D0: 3B600030  li r27, 0x30
	ctx.r[27].s64 = 48;
	// 82A052D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A052D8: 409A000C  bne cr6, 0x82a052e4
	if !ctx.cr[6].eq {
	pc = 0x82A052E4; continue 'dispatch;
	}
	// 82A052DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A052E0: 48000010  b 0x82a052f0
	pc = 0x82A052F0; continue 'dispatch;
            }
            0x82A052E4 => {
    //   block [0x82A052E4..0x82A052F0)
	// 82A052E4: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A052E8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A052EC: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A052F0; continue 'dispatch;
            }
            0x82A052F0 => {
    //   block [0x82A052F0..0x82A05324)
	// 82A052F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A052F4: 419A03A8  beq cr6, 0x82a0569c
	if ctx.cr[6].eq {
	pc = 0x82A0569C; continue 'dispatch;
	}
	// 82A052F8: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A052FC: 3D400555  lis r10, 0x555
	ctx.r[10].s64 = 89456640;
	// 82A05300: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A05304: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 82A05308: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A0530C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A05310: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A05314: 40980010  bge cr6, 0x82a05324
	if !ctx.cr[6].lt {
	pc = 0x82A05324; continue 'dispatch;
	}
	// 82A05318: 480421B1  bl 0x82a474c8
	ctx.lr = 0x82A0531C;
	sub_82A474C8(ctx, base);
	// 82A0531C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A05320: 482A4134  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A05324 => {
    //   block [0x82A05324..0x82A05348)
	// 82A05324: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A05328: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0532C: 40980188  bge cr6, 0x82a054b4
	if !ctx.cr[6].lt {
	pc = 0x82A054B4; continue 'dispatch;
	}
	// 82A05330: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05334: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A05338: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0533C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A05340: 41980008  blt cr6, 0x82a05348
	if ctx.cr[6].lt {
	pc = 0x82A05348; continue 'dispatch;
	}
	// 82A05344: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A05348; continue 'dispatch;
            }
            0x82A05348 => {
    //   block [0x82A05348..0x82A05354)
	// 82A05348: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0534C: 40980008  bge cr6, 0x82a05354
	if !ctx.cr[6].lt {
	pc = 0x82A05354; continue 'dispatch;
	}
	// 82A05350: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x82A05354; continue 'dispatch;
            }
            0x82A05354 => {
    //   block [0x82A05354..0x82A05378)
	// 82A05354: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A05358: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0535C: 481273D5  bl 0x82b2c730
	ctx.lr = 0x82A05360;
	sub_82B2C730(ctx, base);
	// 82A05360: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05364: 80A100CC  lwz r5, 0xcc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A05368: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0536C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A05370: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A05374: 419A0040  beq cr6, 0x82a053b4
	if ctx.cr[6].eq {
	pc = 0x82A053B4; continue 'dispatch;
	}
	pc = 0x82A05378; continue 'dispatch;
            }
            0x82A05378 => {
    //   block [0x82A05378..0x82A05390)
	// 82A05378: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A0537C: 419A0028  beq cr6, 0x82a053a4
	if ctx.cr[6].eq {
	pc = 0x82A053A4; continue 'dispatch;
	}
	// 82A05380: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A05384: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A05388: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A0538C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A05390; continue 'dispatch;
            }
            0x82A05390 => {
    //   block [0x82A05390..0x82A053A4)
	// 82A05390: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A05394: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A05398: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A0539C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A053A0: 4200FFF0  bdnz 0x82a05390
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05390; continue 'dispatch;
	}
	pc = 0x82A053A4; continue 'dispatch;
            }
            0x82A053A4 => {
    //   block [0x82A053A4..0x82A053B4)
	// 82A053A4: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 82A053A8: 38E70030  addi r7, r7, 0x30
	ctx.r[7].s64 = ctx.r[7].s64 + 48;
	// 82A053AC: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A053B0: 409AFFC8  bne cr6, 0x82a05378
	if !ctx.cr[6].eq {
	pc = 0x82A05378; continue 'dispatch;
	}
	pc = 0x82A053B4; continue 'dispatch;
            }
            0x82A053B4 => {
    //   block [0x82A053B4..0x82A053C4)
	// 82A053B4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A053B8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82A053BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A053C0: 419A003C  beq cr6, 0x82a053fc
	if ctx.cr[6].eq {
	pc = 0x82A053FC; continue 'dispatch;
	}
	pc = 0x82A053C4; continue 'dispatch;
            }
            0x82A053C4 => {
    //   block [0x82A053C4..0x82A053DC)
	// 82A053C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A053C8: 419A0028  beq cr6, 0x82a053f0
	if ctx.cr[6].eq {
	pc = 0x82A053F0; continue 'dispatch;
	}
	// 82A053CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A053D0: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A053D4: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A053D8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A053DC; continue 'dispatch;
            }
            0x82A053DC => {
    //   block [0x82A053DC..0x82A053F0)
	// 82A053DC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A053E0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A053E4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A053E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A053EC: 4200FFF0  bdnz 0x82a053dc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A053DC; continue 'dispatch;
	}
	pc = 0x82A053F0; continue 'dispatch;
            }
            0x82A053F0 => {
    //   block [0x82A053F0..0x82A053FC)
	// 82A053F0: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A053F4: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 82A053F8: 4082FFCC  bne 0x82a053c4
	if !ctx.cr[0].eq {
	pc = 0x82A053C4; continue 'dispatch;
	}
	pc = 0x82A053FC; continue 'dispatch;
            }
            0x82A053FC => {
    //   block [0x82A053FC..0x82A05424)
	// 82A053FC: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05400: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05404: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A05408: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A0540C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05410: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A05414: 419A004C  beq cr6, 0x82a05460
	if ctx.cr[6].eq {
	pc = 0x82A05460; continue 'dispatch;
	}
	// 82A05418: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A0541C: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A05420: 7D0B2A14  add r8, r11, r5
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	pc = 0x82A05424; continue 'dispatch;
            }
            0x82A05424 => {
    //   block [0x82A05424..0x82A0543C)
	// 82A05424: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A05428: 419A0028  beq cr6, 0x82a05450
	if ctx.cr[6].eq {
	pc = 0x82A05450; continue 'dispatch;
	}
	// 82A0542C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A05430: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A05434: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 82A05438: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A0543C; continue 'dispatch;
            }
            0x82A0543C => {
    //   block [0x82A0543C..0x82A05450)
	// 82A0543C: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A05440: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A05444: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 82A05448: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A0544C: 4200FFF0  bdnz 0x82a0543c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0543C; continue 'dispatch;
	}
	pc = 0x82A05450; continue 'dispatch;
            }
            0x82A05450 => {
    //   block [0x82A05450..0x82A05460)
	// 82A05450: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 82A05454: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 82A05458: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A0545C: 409AFFC8  bne cr6, 0x82a05424
	if !ctx.cr[6].eq {
	pc = 0x82A05424; continue 'dispatch;
	}
	pc = 0x82A05460; continue 'dispatch;
            }
            0x82A05460 => {
    //   block [0x82A05460..0x82A05480)
	// 82A05460: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05464: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0546C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A05470: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A05474: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A05478: 419A0008  beq cr6, 0x82a05480
	if ctx.cr[6].eq {
	pc = 0x82A05480; continue 'dispatch;
	}
	// 82A0547C: 4B8168BD  bl 0x8221bd38
	ctx.lr = 0x82A05480;
	sub_8221BD38(ctx, base);
	pc = 0x82A05480; continue 'dispatch;
            }
            0x82A05480 => {
    //   block [0x82A05480..0x82A054B4)
	// 82A05480: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05484: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A05488: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0548C: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A05490: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82A05494: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05498: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0549C: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A054A0: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A054A4: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A054A8: 911C000C  stw r8, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A054AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A054B0: 482A3FA4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A054B4 => {
    //   block [0x82A054B4..0x82A054E4)
	// 82A054B4: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A054B8: 7D632850  subf r11, r3, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	// 82A054BC: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A054C0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A054C4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A054C8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A054CC: 409800F8  bge cr6, 0x82a055c4
	if !ctx.cr[6].lt {
	pc = 0x82A055C4; continue 'dispatch;
	}
	// 82A054D0: 55662036  slwi r6, r11, 4
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A054D4: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A054D8: 7D261A14  add r9, r6, r3
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A054DC: 419A0044  beq cr6, 0x82a05520
	if ctx.cr[6].eq {
	pc = 0x82A05520; continue 'dispatch;
	}
	// 82A054E0: 7CE64850  subf r7, r6, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	pc = 0x82A054E4; continue 'dispatch;
            }
            0x82A054E4 => {
    //   block [0x82A054E4..0x82A054FC)
	// 82A054E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A054E8: 419A0028  beq cr6, 0x82a05510
	if ctx.cr[6].eq {
	pc = 0x82A05510; continue 'dispatch;
	}
	// 82A054EC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A054F0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A054F4: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A054F8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A054FC; continue 'dispatch;
            }
            0x82A054FC => {
    //   block [0x82A054FC..0x82A05510)
	// 82A054FC: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A05500: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A05504: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A05508: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A0550C: 4200FFF0  bdnz 0x82a054fc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A054FC; continue 'dispatch;
	}
	pc = 0x82A05510; continue 'dispatch;
            }
            0x82A05510 => {
    //   block [0x82A05510..0x82A05520)
	// 82A05510: 38E70030  addi r7, r7, 0x30
	ctx.r[7].s64 = ctx.r[7].s64 + 48;
	// 82A05514: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 82A05518: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A0551C: 409AFFC8  bne cr6, 0x82a054e4
	if !ctx.cr[6].eq {
	pc = 0x82A054E4; continue 'dispatch;
	}
	pc = 0x82A05520; continue 'dispatch;
            }
            0x82A05520 => {
    //   block [0x82A05520..0x82A05538)
	// 82A05520: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05524: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A05528: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A0552C: 7D2ADBD6  divw r9, r10, r27
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A05530: 7CE9F851  subf. r7, r9, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A05534: 4182003C  beq 0x82a05570
	if ctx.cr[0].eq {
	pc = 0x82A05570; continue 'dispatch;
	}
	pc = 0x82A05538; continue 'dispatch;
            }
            0x82A05538 => {
    //   block [0x82A05538..0x82A05550)
	// 82A05538: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A0553C: 419A0028  beq cr6, 0x82a05564
	if ctx.cr[6].eq {
	pc = 0x82A05564; continue 'dispatch;
	}
	// 82A05540: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A05544: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A05548: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A0554C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A05550; continue 'dispatch;
            }
            0x82A05550 => {
    //   block [0x82A05550..0x82A05564)
	// 82A05550: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A05554: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A05558: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A0555C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A05560: 4200FFF0  bdnz 0x82a05550
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05550; continue 'dispatch;
	}
	pc = 0x82A05564; continue 'dispatch;
            }
            0x82A05564 => {
    //   block [0x82A05564..0x82A05570)
	// 82A05564: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A05568: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 82A0556C: 4082FFCC  bne 0x82a05538
	if !ctx.cr[0].eq {
	pc = 0x82A05538; continue 'dispatch;
	}
	pc = 0x82A05570; continue 'dispatch;
            }
            0x82A05570 => {
    //   block [0x82A05570..0x82A0558C)
	// 82A05570: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05574: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A05578: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A0557C: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82A05580: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A05584: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A05588: 419A0114  beq cr6, 0x82a0569c
	if ctx.cr[6].eq {
	pc = 0x82A0569C; continue 'dispatch;
	}
	pc = 0x82A0558C; continue 'dispatch;
            }
            0x82A0558C => {
    //   block [0x82A0558C..0x82A0559C)
	// 82A0558C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A05590: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A05594: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A05598: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A0559C; continue 'dispatch;
            }
            0x82A0559C => {
    //   block [0x82A0559C..0x82A055C4)
	// 82A0559C: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A055A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A055A4: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A055A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A055AC: 4200FFF0  bdnz 0x82a0559c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0559C; continue 'dispatch;
	}
	// 82A055B0: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 82A055B4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A055B8: 409AFFD4  bne cr6, 0x82a0558c
	if !ctx.cr[6].eq {
	pc = 0x82A0558C; continue 'dispatch;
	}
	// 82A055BC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A055C0: 482A3E94  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A055C4 => {
    //   block [0x82A055C4..0x82A055DC)
	// 82A055C4: 55642036  slwi r4, r11, 4
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A055C8: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82A055CC: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82A055D0: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82A055D4: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A055D8: 419A0040  beq cr6, 0x82a05618
	if ctx.cr[6].eq {
	pc = 0x82A05618; continue 'dispatch;
	}
	pc = 0x82A055DC; continue 'dispatch;
            }
            0x82A055DC => {
    //   block [0x82A055DC..0x82A055F4)
	// 82A055DC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A055E0: 419A0028  beq cr6, 0x82a05608
	if ctx.cr[6].eq {
	pc = 0x82A05608; continue 'dispatch;
	}
	// 82A055E4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A055E8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A055EC: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82A055F0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x82A055F4; continue 'dispatch;
            }
            0x82A055F4 => {
    //   block [0x82A055F4..0x82A05608)
	// 82A055F4: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A055F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A055FC: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82A05600: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A05604: 4200FFF0  bdnz 0x82a055f4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A055F4; continue 'dispatch;
	}
	pc = 0x82A05608; continue 'dispatch;
            }
            0x82A05608 => {
    //   block [0x82A05608..0x82A05618)
	// 82A05608: 38E70030  addi r7, r7, 0x30
	ctx.r[7].s64 = ctx.r[7].s64 + 48;
	// 82A0560C: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 82A05610: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A05614: 409AFFC8  bne cr6, 0x82a055dc
	if !ctx.cr[6].eq {
	pc = 0x82A055DC; continue 'dispatch;
	}
	pc = 0x82A05618; continue 'dispatch;
            }
            0x82A05618 => {
    //   block [0x82A05618..0x82A05628)
	// 82A05618: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A0561C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A05620: 419A003C  beq cr6, 0x82a0565c
	if ctx.cr[6].eq {
	pc = 0x82A0565C; continue 'dispatch;
	}
	// 82A05624: 7D045A14  add r8, r4, r11
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	pc = 0x82A05628; continue 'dispatch;
            }
            0x82A05628 => {
    //   block [0x82A05628..0x82A05640)
	// 82A05628: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 82A0562C: 3908FFD0  addi r8, r8, -0x30
	ctx.r[8].s64 = ctx.r[8].s64 + -48;
	// 82A05630: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A05634: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A05638: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 82A0563C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A05640; continue 'dispatch;
            }
            0x82A05640 => {
    //   block [0x82A05640..0x82A0565C)
	// 82A05640: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A05644: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A05648: F8E90000  std r7, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 82A0564C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A05650: 4200FFF0  bdnz 0x82a05640
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05640; continue 'dispatch;
	}
	// 82A05654: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A05658: 409AFFD0  bne cr6, 0x82a05628
	if !ctx.cr[6].eq {
	pc = 0x82A05628; continue 'dispatch;
	}
	pc = 0x82A0565C; continue 'dispatch;
            }
            0x82A0565C => {
    //   block [0x82A0565C..0x82A0566C)
	// 82A0565C: 7CE41A14  add r7, r4, r3
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 82A05660: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A05664: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A05668: 419A0034  beq cr6, 0x82a0569c
	if ctx.cr[6].eq {
	pc = 0x82A0569C; continue 'dispatch;
	}
	pc = 0x82A0566C; continue 'dispatch;
            }
            0x82A0566C => {
    //   block [0x82A0566C..0x82A0567C)
	// 82A0566C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A05670: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A05674: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A05678: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A0567C; continue 'dispatch;
            }
            0x82A0567C => {
    //   block [0x82A0567C..0x82A0569C)
	// 82A0567C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A05680: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A05684: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A05688: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A0568C: 4200FFF0  bdnz 0x82a0567c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0567C; continue 'dispatch;
	}
	// 82A05690: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 82A05694: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A05698: 409AFFD4  bne cr6, 0x82a0566c
	if !ctx.cr[6].eq {
	pc = 0x82A0566C; continue 'dispatch;
	}
	pc = 0x82A0569C; continue 'dispatch;
            }
            0x82A0569C => {
    //   block [0x82A0569C..0x82A056A4)
	// 82A0569C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A056A0: 482A3DB4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A056A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A056A8 size=1044
    let mut pc: u32 = 0x82A056A8;
    'dispatch: loop {
        match pc {
            0x82A056A8 => {
    //   block [0x82A056A8..0x82A056D0)
	// 82A056A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A056AC: 482A3D59  bl 0x82ca9404
	ctx.lr = 0x82A056B0;
	sub_82CA93D0(ctx, base);
	// 82A056B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A056B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A056B8: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82A056BC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A056C0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A056C4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A056C8: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 82A056CC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A056D0; continue 'dispatch;
            }
            0x82A056D0 => {
    //   block [0x82A056D0..0x82A056FC)
	// 82A056D0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A056D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A056D8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A056DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A056E0: 4200FFF0  bdnz 0x82a056d0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A056D0; continue 'dispatch;
	}
	// 82A056E4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A056E8: 3B600024  li r27, 0x24
	ctx.r[27].s64 = 36;
	// 82A056EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A056F0: 409A000C  bne cr6, 0x82a056fc
	if !ctx.cr[6].eq {
	pc = 0x82A056FC; continue 'dispatch;
	}
	// 82A056F4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A056F8: 48000010  b 0x82a05708
	pc = 0x82A05708; continue 'dispatch;
            }
            0x82A056FC => {
    //   block [0x82A056FC..0x82A05708)
	// 82A056FC: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A05700: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A05704: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A05708; continue 'dispatch;
            }
            0x82A05708 => {
    //   block [0x82A05708..0x82A0573C)
	// 82A05708: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0570C: 419A03A8  beq cr6, 0x82a05ab4
	if ctx.cr[6].eq {
	pc = 0x82A05AB4; continue 'dispatch;
	}
	// 82A05710: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05714: 3D40071C  lis r10, 0x71c
	ctx.r[10].s64 = 119275520;
	// 82A05718: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A0571C: 614A71C7  ori r10, r10, 0x71c7
	ctx.r[10].u64 = ctx.r[10].u64 | 29127;
	// 82A05720: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A05724: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A05728: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0572C: 40980010  bge cr6, 0x82a0573c
	if !ctx.cr[6].lt {
	pc = 0x82A0573C; continue 'dispatch;
	}
	// 82A05730: 48041D99  bl 0x82a474c8
	ctx.lr = 0x82A05734;
	sub_82A474C8(ctx, base);
	// 82A05734: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A05738: 482A3D1C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0573C => {
    //   block [0x82A0573C..0x82A05760)
	// 82A0573C: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A05740: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A05744: 40980188  bge cr6, 0x82a058cc
	if !ctx.cr[6].lt {
	pc = 0x82A058CC; continue 'dispatch;
	}
	// 82A05748: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0574C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A05750: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A05754: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A05758: 41980008  blt cr6, 0x82a05760
	if ctx.cr[6].lt {
	pc = 0x82A05760; continue 'dispatch;
	}
	// 82A0575C: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A05760; continue 'dispatch;
            }
            0x82A05760 => {
    //   block [0x82A05760..0x82A0576C)
	// 82A05760: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A05764: 40980008  bge cr6, 0x82a0576c
	if !ctx.cr[6].lt {
	pc = 0x82A0576C; continue 'dispatch;
	}
	// 82A05768: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x82A0576C; continue 'dispatch;
            }
            0x82A0576C => {
    //   block [0x82A0576C..0x82A05790)
	// 82A0576C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A05770: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A05774: 481419CD  bl 0x82b47140
	ctx.lr = 0x82A05778;
	sub_82B47140(ctx, base);
	// 82A05778: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0577C: 80A100CC  lwz r5, 0xcc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A05780: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A05784: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A05788: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A0578C: 419A0040  beq cr6, 0x82a057cc
	if ctx.cr[6].eq {
	pc = 0x82A057CC; continue 'dispatch;
	}
	pc = 0x82A05790; continue 'dispatch;
            }
            0x82A05790 => {
    //   block [0x82A05790..0x82A057A8)
	// 82A05790: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A05794: 419A0028  beq cr6, 0x82a057bc
	if ctx.cr[6].eq {
	pc = 0x82A057BC; continue 'dispatch;
	}
	// 82A05798: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A0579C: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A057A0: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 82A057A4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A057A8; continue 'dispatch;
            }
            0x82A057A8 => {
    //   block [0x82A057A8..0x82A057BC)
	// 82A057A8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A057AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A057B0: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A057B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A057B8: 4200FFF0  bdnz 0x82a057a8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A057A8; continue 'dispatch;
	}
	pc = 0x82A057BC; continue 'dispatch;
            }
            0x82A057BC => {
    //   block [0x82A057BC..0x82A057CC)
	// 82A057BC: 39290024  addi r9, r9, 0x24
	ctx.r[9].s64 = ctx.r[9].s64 + 36;
	// 82A057C0: 38E70024  addi r7, r7, 0x24
	ctx.r[7].s64 = ctx.r[7].s64 + 36;
	// 82A057C4: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A057C8: 409AFFC8  bne cr6, 0x82a05790
	if !ctx.cr[6].eq {
	pc = 0x82A05790; continue 'dispatch;
	}
	pc = 0x82A057CC; continue 'dispatch;
            }
            0x82A057CC => {
    //   block [0x82A057CC..0x82A057DC)
	// 82A057CC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A057D0: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82A057D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A057D8: 419A003C  beq cr6, 0x82a05814
	if ctx.cr[6].eq {
	pc = 0x82A05814; continue 'dispatch;
	}
	pc = 0x82A057DC; continue 'dispatch;
            }
            0x82A057DC => {
    //   block [0x82A057DC..0x82A057F4)
	// 82A057DC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A057E0: 419A0028  beq cr6, 0x82a05808
	if ctx.cr[6].eq {
	pc = 0x82A05808; continue 'dispatch;
	}
	// 82A057E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A057E8: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A057EC: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 82A057F0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A057F4; continue 'dispatch;
            }
            0x82A057F4 => {
    //   block [0x82A057F4..0x82A05808)
	// 82A057F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A057F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A057FC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A05800: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A05804: 4200FFF0  bdnz 0x82a057f4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A057F4; continue 'dispatch;
	}
	pc = 0x82A05808; continue 'dispatch;
            }
            0x82A05808 => {
    //   block [0x82A05808..0x82A05814)
	// 82A05808: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A0580C: 39080024  addi r8, r8, 0x24
	ctx.r[8].s64 = ctx.r[8].s64 + 36;
	// 82A05810: 4082FFCC  bne 0x82a057dc
	if !ctx.cr[0].eq {
	pc = 0x82A057DC; continue 'dispatch;
	}
	pc = 0x82A05814; continue 'dispatch;
            }
            0x82A05814 => {
    //   block [0x82A05814..0x82A0583C)
	// 82A05814: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05818: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0581C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A05820: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A05824: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A05828: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A0582C: 419A004C  beq cr6, 0x82a05878
	if ctx.cr[6].eq {
	pc = 0x82A05878; continue 'dispatch;
	}
	// 82A05830: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A05834: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A05838: 7D0B2A14  add r8, r11, r5
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	pc = 0x82A0583C; continue 'dispatch;
            }
            0x82A0583C => {
    //   block [0x82A0583C..0x82A05854)
	// 82A0583C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A05840: 419A0028  beq cr6, 0x82a05868
	if ctx.cr[6].eq {
	pc = 0x82A05868; continue 'dispatch;
	}
	// 82A05844: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A05848: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A0584C: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 82A05850: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A05854; continue 'dispatch;
            }
            0x82A05854 => {
    //   block [0x82A05854..0x82A05868)
	// 82A05854: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05858: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0585C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A05860: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A05864: 4200FFF0  bdnz 0x82a05854
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05854; continue 'dispatch;
	}
	pc = 0x82A05868; continue 'dispatch;
            }
            0x82A05868 => {
    //   block [0x82A05868..0x82A05878)
	// 82A05868: 39080024  addi r8, r8, 0x24
	ctx.r[8].s64 = ctx.r[8].s64 + 36;
	// 82A0586C: 39290024  addi r9, r9, 0x24
	ctx.r[9].s64 = ctx.r[9].s64 + 36;
	// 82A05870: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A05874: 409AFFC8  bne cr6, 0x82a0583c
	if !ctx.cr[6].eq {
	pc = 0x82A0583C; continue 'dispatch;
	}
	pc = 0x82A05878; continue 'dispatch;
            }
            0x82A05878 => {
    //   block [0x82A05878..0x82A05898)
	// 82A05878: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0587C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05884: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A05888: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A0588C: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A05890: 419A0008  beq cr6, 0x82a05898
	if ctx.cr[6].eq {
	pc = 0x82A05898; continue 'dispatch;
	}
	// 82A05894: 4B8164A5  bl 0x8221bd38
	ctx.lr = 0x82A05898;
	sub_8221BD38(ctx, base);
	pc = 0x82A05898; continue 'dispatch;
            }
            0x82A05898 => {
    //   block [0x82A05898..0x82A058CC)
	// 82A05898: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0589C: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A058A0: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A058A4: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A058A8: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82A058AC: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A058B0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A058B4: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A058B8: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A058BC: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A058C0: 911C000C  stw r8, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A058C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A058C8: 482A3B8C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A058CC => {
    //   block [0x82A058CC..0x82A058FC)
	// 82A058CC: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A058D0: 7D632850  subf r11, r3, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	// 82A058D4: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A058D8: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A058DC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A058E0: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A058E4: 409800F8  bge cr6, 0x82a059dc
	if !ctx.cr[6].lt {
	pc = 0x82A059DC; continue 'dispatch;
	}
	// 82A058E8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A058EC: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A058F0: 7D261A14  add r9, r6, r3
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A058F4: 419A0044  beq cr6, 0x82a05938
	if ctx.cr[6].eq {
	pc = 0x82A05938; continue 'dispatch;
	}
	// 82A058F8: 7CE64850  subf r7, r6, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	pc = 0x82A058FC; continue 'dispatch;
            }
            0x82A058FC => {
    //   block [0x82A058FC..0x82A05914)
	// 82A058FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A05900: 419A0028  beq cr6, 0x82a05928
	if ctx.cr[6].eq {
	pc = 0x82A05928; continue 'dispatch;
	}
	// 82A05904: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A05908: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A0590C: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 82A05910: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A05914; continue 'dispatch;
            }
            0x82A05914 => {
    //   block [0x82A05914..0x82A05928)
	// 82A05914: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05918: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0591C: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A05920: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A05924: 4200FFF0  bdnz 0x82a05914
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05914; continue 'dispatch;
	}
	pc = 0x82A05928; continue 'dispatch;
            }
            0x82A05928 => {
    //   block [0x82A05928..0x82A05938)
	// 82A05928: 38E70024  addi r7, r7, 0x24
	ctx.r[7].s64 = ctx.r[7].s64 + 36;
	// 82A0592C: 39290024  addi r9, r9, 0x24
	ctx.r[9].s64 = ctx.r[9].s64 + 36;
	// 82A05930: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A05934: 409AFFC8  bne cr6, 0x82a058fc
	if !ctx.cr[6].eq {
	pc = 0x82A058FC; continue 'dispatch;
	}
	pc = 0x82A05938; continue 'dispatch;
            }
            0x82A05938 => {
    //   block [0x82A05938..0x82A05950)
	// 82A05938: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0593C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A05940: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A05944: 7D2ADBD6  divw r9, r10, r27
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A05948: 7CE9F851  subf. r7, r9, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A0594C: 4182003C  beq 0x82a05988
	if ctx.cr[0].eq {
	pc = 0x82A05988; continue 'dispatch;
	}
	pc = 0x82A05950; continue 'dispatch;
            }
            0x82A05950 => {
    //   block [0x82A05950..0x82A05968)
	// 82A05950: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A05954: 419A0028  beq cr6, 0x82a0597c
	if ctx.cr[6].eq {
	pc = 0x82A0597C; continue 'dispatch;
	}
	// 82A05958: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A0595C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A05960: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 82A05964: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A05968; continue 'dispatch;
            }
            0x82A05968 => {
    //   block [0x82A05968..0x82A0597C)
	// 82A05968: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0596C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A05970: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A05974: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A05978: 4200FFF0  bdnz 0x82a05968
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05968; continue 'dispatch;
	}
	pc = 0x82A0597C; continue 'dispatch;
            }
            0x82A0597C => {
    //   block [0x82A0597C..0x82A05988)
	// 82A0597C: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A05980: 39080024  addi r8, r8, 0x24
	ctx.r[8].s64 = ctx.r[8].s64 + 36;
	// 82A05984: 4082FFCC  bne 0x82a05950
	if !ctx.cr[0].eq {
	pc = 0x82A05950; continue 'dispatch;
	}
	pc = 0x82A05988; continue 'dispatch;
            }
            0x82A05988 => {
    //   block [0x82A05988..0x82A059A4)
	// 82A05988: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0598C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A05990: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A05994: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82A05998: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0599C: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A059A0: 419A0114  beq cr6, 0x82a05ab4
	if ctx.cr[6].eq {
	pc = 0x82A05AB4; continue 'dispatch;
	}
	pc = 0x82A059A4; continue 'dispatch;
            }
            0x82A059A4 => {
    //   block [0x82A059A4..0x82A059B4)
	// 82A059A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A059A8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A059AC: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 82A059B0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A059B4; continue 'dispatch;
            }
            0x82A059B4 => {
    //   block [0x82A059B4..0x82A059DC)
	// 82A059B4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A059B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A059BC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A059C0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A059C4: 4200FFF0  bdnz 0x82a059b4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A059B4; continue 'dispatch;
	}
	// 82A059C8: 39290024  addi r9, r9, 0x24
	ctx.r[9].s64 = ctx.r[9].s64 + 36;
	// 82A059CC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A059D0: 409AFFD4  bne cr6, 0x82a059a4
	if !ctx.cr[6].eq {
	pc = 0x82A059A4; continue 'dispatch;
	}
	// 82A059D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A059D8: 482A3A7C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A059DC => {
    //   block [0x82A059DC..0x82A059F4)
	// 82A059DC: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A059E0: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82A059E4: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82A059E8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82A059EC: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A059F0: 419A0040  beq cr6, 0x82a05a30
	if ctx.cr[6].eq {
	pc = 0x82A05A30; continue 'dispatch;
	}
	pc = 0x82A059F4; continue 'dispatch;
            }
            0x82A059F4 => {
    //   block [0x82A059F4..0x82A05A0C)
	// 82A059F4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A059F8: 419A0028  beq cr6, 0x82a05a20
	if ctx.cr[6].eq {
	pc = 0x82A05A20; continue 'dispatch;
	}
	// 82A059FC: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A05A00: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A05A04: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 82A05A08: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x82A05A0C; continue 'dispatch;
            }
            0x82A05A0C => {
    //   block [0x82A05A0C..0x82A05A20)
	// 82A05A0C: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05A10: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A05A14: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82A05A18: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A05A1C: 4200FFF0  bdnz 0x82a05a0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05A0C; continue 'dispatch;
	}
	pc = 0x82A05A20; continue 'dispatch;
            }
            0x82A05A20 => {
    //   block [0x82A05A20..0x82A05A30)
	// 82A05A20: 38E70024  addi r7, r7, 0x24
	ctx.r[7].s64 = ctx.r[7].s64 + 36;
	// 82A05A24: 39080024  addi r8, r8, 0x24
	ctx.r[8].s64 = ctx.r[8].s64 + 36;
	// 82A05A28: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A05A2C: 409AFFC8  bne cr6, 0x82a059f4
	if !ctx.cr[6].eq {
	pc = 0x82A059F4; continue 'dispatch;
	}
	pc = 0x82A05A30; continue 'dispatch;
            }
            0x82A05A30 => {
    //   block [0x82A05A30..0x82A05A40)
	// 82A05A30: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A05A34: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A05A38: 419A003C  beq cr6, 0x82a05a74
	if ctx.cr[6].eq {
	pc = 0x82A05A74; continue 'dispatch;
	}
	// 82A05A3C: 7D045A14  add r8, r4, r11
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	pc = 0x82A05A40; continue 'dispatch;
            }
            0x82A05A40 => {
    //   block [0x82A05A40..0x82A05A58)
	// 82A05A40: 396BFFDC  addi r11, r11, -0x24
	ctx.r[11].s64 = ctx.r[11].s64 + -36;
	// 82A05A44: 3908FFDC  addi r8, r8, -0x24
	ctx.r[8].s64 = ctx.r[8].s64 + -36;
	// 82A05A48: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A05A4C: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A05A50: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 82A05A54: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A05A58; continue 'dispatch;
            }
            0x82A05A58 => {
    //   block [0x82A05A58..0x82A05A74)
	// 82A05A58: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05A5C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A05A60: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A05A64: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A05A68: 4200FFF0  bdnz 0x82a05a58
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05A58; continue 'dispatch;
	}
	// 82A05A6C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A05A70: 409AFFD0  bne cr6, 0x82a05a40
	if !ctx.cr[6].eq {
	pc = 0x82A05A40; continue 'dispatch;
	}
	pc = 0x82A05A74; continue 'dispatch;
            }
            0x82A05A74 => {
    //   block [0x82A05A74..0x82A05A84)
	// 82A05A74: 7CE41A14  add r7, r4, r3
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 82A05A78: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A05A7C: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A05A80: 419A0034  beq cr6, 0x82a05ab4
	if ctx.cr[6].eq {
	pc = 0x82A05AB4; continue 'dispatch;
	}
	pc = 0x82A05A84; continue 'dispatch;
            }
            0x82A05A84 => {
    //   block [0x82A05A84..0x82A05A94)
	// 82A05A84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A05A88: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A05A8C: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 82A05A90: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A05A94; continue 'dispatch;
            }
            0x82A05A94 => {
    //   block [0x82A05A94..0x82A05AB4)
	// 82A05A94: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05A98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A05A9C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A05AA0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A05AA4: 4200FFF0  bdnz 0x82a05a94
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A05A94; continue 'dispatch;
	}
	// 82A05AA8: 39080024  addi r8, r8, 0x24
	ctx.r[8].s64 = ctx.r[8].s64 + 36;
	// 82A05AAC: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A05AB0: 409AFFD4  bne cr6, 0x82a05a84
	if !ctx.cr[6].eq {
	pc = 0x82A05A84; continue 'dispatch;
	}
	pc = 0x82A05AB4; continue 'dispatch;
            }
            0x82A05AB4 => {
    //   block [0x82A05AB4..0x82A05ABC)
	// 82A05AB4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A05AB8: 482A399C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A05AC0 size=500
    let mut pc: u32 = 0x82A05AC0;
    'dispatch: loop {
        match pc {
            0x82A05AC0 => {
    //   block [0x82A05AC0..0x82A05B1C)
	// 82A05AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05AC4: 482A391D  bl 0x82ca93e0
	ctx.lr = 0x82A05AC8;
	sub_82CA93D0(ctx, base);
	// 82A05AC8: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 82A05ACC: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82A05AD0: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82A05AD4: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05AD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05ADC: 82DF0168  lwz r22, 0x168(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A05AE0: 3AB60004  addi r21, r22, 4
	ctx.r[21].s64 = ctx.r[22].s64 + 4;
	// 82A05AE4: 3A960040  addi r20, r22, 0x40
	ctx.r[20].s64 = ctx.r[22].s64 + 64;
	// 82A05AE8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A05AEC: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82A05AF0: 4882A649  bl 0x83230138
	ctx.lr = 0x82A05AF4;
	sub_83230138(ctx, base);
	// 82A05AF4: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A05AF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A05AFC: 419A0028  beq cr6, 0x82a05b24
	if ctx.cr[6].eq {
	pc = 0x82A05B24; continue 'dispatch;
	}
	// 82A05B00: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A05B04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A05B08: 419A0014  beq cr6, 0x82a05b1c
	if ctx.cr[6].eq {
	pc = 0x82A05B1C; continue 'dispatch;
	}
	// 82A05B0C: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A05B10: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A05B14: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A05B18: 4199000C  bgt cr6, 0x82a05b24
	if ctx.cr[6].gt {
	pc = 0x82A05B24; continue 'dispatch;
	}
	pc = 0x82A05B1C; continue 'dispatch;
            }
            0x82A05B1C => {
    //   block [0x82A05B1C..0x82A05B24)
	// 82A05B1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A05B20: 48000008  b 0x82a05b28
	pc = 0x82A05B28; continue 'dispatch;
            }
            0x82A05B24 => {
    //   block [0x82A05B24..0x82A05B28)
	// 82A05B24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A05B28; continue 'dispatch;
            }
            0x82A05B28 => {
    //   block [0x82A05B28..0x82A05CA0)
	// 82A05B28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A05B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A05B30: 419A0170  beq cr6, 0x82a05ca0
	if ctx.cr[6].eq {
	pc = 0x82A05CA0; continue 'dispatch;
	}
	// 82A05B34: 897F01B0  lbz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A05B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A05B3C: 419A0164  beq cr6, 0x82a05ca0
	if ctx.cr[6].eq {
	pc = 0x82A05CA0; continue 'dispatch;
	}
	// 82A05B40: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A05B44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A05B48: 419A0158  beq cr6, 0x82a05ca0
	if ctx.cr[6].eq {
	pc = 0x82A05CA0; continue 'dispatch;
	}
	// 82A05B4C: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A05B50: 3BBF01C4  addi r29, r31, 0x1c4
	ctx.r[29].s64 = ctx.r[31].s64 + 452;
	// 82A05B54: 815F01C8  lwz r10, 0x1c8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A05B58: 83DF0154  lwz r30, 0x154(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A05B5C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A05B60: 7D282670  srawi r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 82A05B64: 7CFE4051  subf. r7, r30, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A05B68: 41820138  beq 0x82a05ca0
	if ctx.cr[0].eq {
	pc = 0x82A05CA0; continue 'dispatch;
	}
	// 82A05B6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05B70: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A05B74: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A05B78: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05B7C: 3A6B9490  addi r19, r11, -0x6b70
	ctx.r[19].s64 = ctx.r[11].s64 + -27504;
	// 82A05B80: 80FD0004  lwz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05B84: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82A05B88: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A05B8C: 38869160  addi r4, r6, -0x6ea0
	ctx.r[4].s64 = ctx.r[6].s64 + -28320;
	// 82A05B90: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A05B94: 7C674050  subf r3, r7, r8
	ctx.r[3].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82A05B98: C0130000  lfs f0, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A05B9C: 3B4B0030  addi r26, r11, 0x30
	ctx.r[26].s64 = ctx.r[11].s64 + 48;
	// 82A05BA0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A05BA4: 7C6A2670  srawi r10, r3, 4
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[3].s32 >> 4) as i64;
	pc = 0x82A05CA0; continue 'dispatch;
            }
            0x82A05CA0 => {
    //   block [0x82A05CA0..0x82A05CB4)
	// 82A05CA0: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82A05CA4: CBA1FF70  lfd f29, -0x90(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82A05CA8: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82A05CAC: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82A05CB0: 482A3780  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A05CB8 size=896
    let mut pc: u32 = 0x82A05CB8;
    'dispatch: loop {
        match pc {
            0x82A05CB8 => {
    //   block [0x82A05CB8..0x82A06024)
	// 82A05CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05CBC: 482A371D  bl 0x82ca93d8
	ctx.lr = 0x82A05CC0;
	sub_82CA93D0(ctx, base);
	// 82A05CC0: DBA1FF60  stfd f29, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[29].u64 ) };
	// 82A05CC4: DBC1FF68  stfd f30, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 82A05CC8: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 82A05CCC: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05CD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05CD4: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
	// 82A05CD8: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A05CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A05CE0: 419A0344  beq cr6, 0x82a06024
	if ctx.cr[6].eq {
	pc = 0x82A06024; continue 'dispatch;
	}
	// 82A05CE4: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82A05CE8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A05CEC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A05CF0: 831F0168  lwz r24, 0x168(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A05CF4: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82A05CF8: 3B2A9490  addi r25, r10, -0x6b70
	ctx.r[25].s64 = ctx.r[10].s64 + -27504;
	// 82A05CFC: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 82A05D00: C009A924  lfs f0, -0x56dc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A05D04: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A05D08: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A05D0C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A05D10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A05D14: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A05D18: C3F9FFF4  lfs f31, -0xc(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A05D1C: 38A9A924  addi r5, r9, -0x56dc
	ctx.r[5].s64 = ctx.r[9].s64 + -22236;
	pc = 0x82A06024; continue 'dispatch;
            }
            0x82A06024 => {
    //   block [0x82A06024..0x82A06038)
	// 82A06024: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82A06028: CBA1FF60  lfd f29, -0xa0(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82A0602C: CBC1FF68  lfd f30, -0x98(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82A06030: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82A06034: 482A33F4  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06038 size=508
    let mut pc: u32 = 0x82A06038;
    'dispatch: loop {
        match pc {
            0x82A06038 => {
    //   block [0x82A06038..0x82A06094)
	// 82A06038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0603C: 482A33A5  bl 0x82ca93e0
	ctx.lr = 0x82A06040;
	sub_82CA93D0(ctx, base);
	// 82A06040: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 82A06044: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82A06048: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82A0604C: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A06054: 82DF0168  lwz r22, 0x168(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A06058: 3AB60004  addi r21, r22, 4
	ctx.r[21].s64 = ctx.r[22].s64 + 4;
	// 82A0605C: 3A960050  addi r20, r22, 0x50
	ctx.r[20].s64 = ctx.r[22].s64 + 80;
	// 82A06060: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A06064: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82A06068: 48001F89  bl 0x82a07ff0
	ctx.lr = 0x82A0606C;
	sub_82A07FF0(ctx, base);
	// 82A0606C: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A06070: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A06074: 419A0028  beq cr6, 0x82a0609c
	if ctx.cr[6].eq {
	pc = 0x82A0609C; continue 'dispatch;
	}
	// 82A06078: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A0607C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06080: 419A0014  beq cr6, 0x82a06094
	if ctx.cr[6].eq {
	pc = 0x82A06094; continue 'dispatch;
	}
	// 82A06084: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A06088: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0608C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A06090: 4199000C  bgt cr6, 0x82a0609c
	if ctx.cr[6].gt {
	pc = 0x82A0609C; continue 'dispatch;
	}
	pc = 0x82A06094; continue 'dispatch;
            }
            0x82A06094 => {
    //   block [0x82A06094..0x82A0609C)
	// 82A06094: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A06098: 48000008  b 0x82a060a0
	pc = 0x82A060A0; continue 'dispatch;
            }
            0x82A0609C => {
    //   block [0x82A0609C..0x82A060A0)
	// 82A0609C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A060A0; continue 'dispatch;
            }
            0x82A060A0 => {
    //   block [0x82A060A0..0x82A06220)
	// 82A060A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A060A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A060A8: 419A0178  beq cr6, 0x82a06220
	if ctx.cr[6].eq {
	pc = 0x82A06220; continue 'dispatch;
	}
	// 82A060AC: 897F01B0  lbz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A060B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A060B4: 419A016C  beq cr6, 0x82a06220
	if ctx.cr[6].eq {
	pc = 0x82A06220; continue 'dispatch;
	}
	// 82A060B8: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A060BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A060C0: 419A0160  beq cr6, 0x82a06220
	if ctx.cr[6].eq {
	pc = 0x82A06220; continue 'dispatch;
	}
	// 82A060C4: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A060C8: 3BBF01C4  addi r29, r31, 0x1c4
	ctx.r[29].s64 = ctx.r[31].s64 + 452;
	// 82A060CC: 813F01C8  lwz r9, 0x1c8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A060D0: 83DF0154  lwz r30, 0x154(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A060D4: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A060D8: 7D072670  srawi r7, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 82A060DC: 7CDE3851  subf. r6, r30, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A060E0: 41820140  beq 0x82a06220
	if ctx.cr[0].eq {
	pc = 0x82A06220; continue 'dispatch;
	}
	// 82A060E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A060E8: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A060EC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A060F0: 80FD0004  lwz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A060F4: 3A6B9490  addi r19, r11, -0x6b70
	ctx.r[19].s64 = ctx.r[11].s64 + -27504;
	// 82A060F8: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A060FC: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82A06100: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A06104: 38869160  addi r4, r6, -0x6ea0
	ctx.r[4].s64 = ctx.r[6].s64 + -28320;
	// 82A06108: 7C674850  subf r3, r7, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A0610C: C0130000  lfs f0, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A06110: 832B0014  lwz r25, 0x14(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A06114: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A06118: 7C6A2670  srawi r10, r3, 4
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[3].s32 >> 4) as i64;
	pc = 0x82A06220; continue 'dispatch;
            }
            0x82A06220 => {
    //   block [0x82A06220..0x82A06234)
	// 82A06220: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82A06224: CBA1FF70  lfd f29, -0x90(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82A06228: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82A0622C: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82A06230: 482A3200  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06238 size=924
    let mut pc: u32 = 0x82A06238;
    'dispatch: loop {
        match pc {
            0x82A06238 => {
    //   block [0x82A06238..0x82A065C0)
	// 82A06238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0623C: 482A31A1  bl 0x82ca93dc
	ctx.lr = 0x82A06240;
	sub_82CA93D0(ctx, base);
	// 82A06240: DBA1FF68  stfd f29, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[29].u64 ) };
	// 82A06244: DBC1FF70  stfd f30, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 82A06248: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 82A0624C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06250: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A06254: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 82A06258: 817E0170  lwz r11, 0x170(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0625C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06260: 419A0360  beq cr6, 0x82a065c0
	if ctx.cr[6].eq {
	pc = 0x82A065C0; continue 'dispatch;
	}
	// 82A06264: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82A06268: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A0626C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A06270: 833E0168  lwz r25, 0x168(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A06274: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82A06278: 3AAA9490  addi r21, r10, -0x6b70
	ctx.r[21].s64 = ctx.r[10].s64 + -27504;
	// 82A0627C: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 82A06280: C009A924  lfs f0, -0x56dc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A06284: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A06288: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A0628C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A06290: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A06294: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A06298: C3F5FFF4  lfs f31, -0xc(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0629C: 38A9A924  addi r5, r9, -0x56dc
	ctx.r[5].s64 = ctx.r[9].s64 + -22236;
	pc = 0x82A065C0; continue 'dispatch;
            }
            0x82A065C0 => {
    //   block [0x82A065C0..0x82A065D4)
	// 82A065C0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A065C4: CBA1FF68  lfd f29, -0x98(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82A065C8: CBC1FF70  lfd f30, -0x90(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82A065CC: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82A065D0: 482A2E5C  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A065D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A065D8 size=508
    let mut pc: u32 = 0x82A065D8;
    'dispatch: loop {
        match pc {
            0x82A065D8 => {
    //   block [0x82A065D8..0x82A06634)
	// 82A065D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A065DC: 482A2E05  bl 0x82ca93e0
	ctx.lr = 0x82A065E0;
	sub_82CA93D0(ctx, base);
	// 82A065E0: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 82A065E4: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82A065E8: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82A065EC: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A065F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A065F4: 82DF0168  lwz r22, 0x168(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A065F8: 3AB60004  addi r21, r22, 4
	ctx.r[21].s64 = ctx.r[22].s64 + 4;
	// 82A065FC: 3A960030  addi r20, r22, 0x30
	ctx.r[20].s64 = ctx.r[22].s64 + 48;
	// 82A06600: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A06604: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82A06608: 480019E9  bl 0x82a07ff0
	ctx.lr = 0x82A0660C;
	sub_82A07FF0(ctx, base);
	// 82A0660C: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A06610: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A06614: 419A0028  beq cr6, 0x82a0663c
	if ctx.cr[6].eq {
	pc = 0x82A0663C; continue 'dispatch;
	}
	// 82A06618: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A0661C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06620: 419A0014  beq cr6, 0x82a06634
	if ctx.cr[6].eq {
	pc = 0x82A06634; continue 'dispatch;
	}
	// 82A06624: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A06628: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0662C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A06630: 4199000C  bgt cr6, 0x82a0663c
	if ctx.cr[6].gt {
	pc = 0x82A0663C; continue 'dispatch;
	}
	pc = 0x82A06634; continue 'dispatch;
            }
            0x82A06634 => {
    //   block [0x82A06634..0x82A0663C)
	// 82A06634: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A06638: 48000008  b 0x82a06640
	pc = 0x82A06640; continue 'dispatch;
            }
            0x82A0663C => {
    //   block [0x82A0663C..0x82A06640)
	// 82A0663C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A06640; continue 'dispatch;
            }
            0x82A06640 => {
    //   block [0x82A06640..0x82A067C0)
	// 82A06640: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A06644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06648: 419A0178  beq cr6, 0x82a067c0
	if ctx.cr[6].eq {
	pc = 0x82A067C0; continue 'dispatch;
	}
	// 82A0664C: 897F01B0  lbz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A06650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06654: 419A016C  beq cr6, 0x82a067c0
	if ctx.cr[6].eq {
	pc = 0x82A067C0; continue 'dispatch;
	}
	// 82A06658: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0665C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A06660: 419A0160  beq cr6, 0x82a067c0
	if ctx.cr[6].eq {
	pc = 0x82A067C0; continue 'dispatch;
	}
	// 82A06664: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A06668: 3BBF01C4  addi r29, r31, 0x1c4
	ctx.r[29].s64 = ctx.r[31].s64 + 452;
	// 82A0666C: 813F01C8  lwz r9, 0x1c8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A06670: 83DF0154  lwz r30, 0x154(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A06674: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A06678: 7D072670  srawi r7, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 82A0667C: 7CDE3851  subf. r6, r30, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A06680: 41820140  beq 0x82a067c0
	if ctx.cr[0].eq {
	pc = 0x82A067C0; continue 'dispatch;
	}
	// 82A06684: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A06688: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0668C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A06690: 80FD0004  lwz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A06694: 3A6B9490  addi r19, r11, -0x6b70
	ctx.r[19].s64 = ctx.r[11].s64 + -27504;
	// 82A06698: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A0669C: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82A066A0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A066A4: 38869160  addi r4, r6, -0x6ea0
	ctx.r[4].s64 = ctx.r[6].s64 + -28320;
	// 82A066A8: 7C674850  subf r3, r7, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A066AC: C0130000  lfs f0, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A066B0: 832B0014  lwz r25, 0x14(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A066B4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A066B8: 7C6A2670  srawi r10, r3, 4
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[3].s32 >> 4) as i64;
	pc = 0x82A067C0; continue 'dispatch;
            }
            0x82A067C0 => {
    //   block [0x82A067C0..0x82A067D4)
	// 82A067C0: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82A067C4: CBA1FF70  lfd f29, -0x90(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82A067C8: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82A067CC: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82A067D0: 482A2C60  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A067D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A067D8 size=924
    let mut pc: u32 = 0x82A067D8;
    'dispatch: loop {
        match pc {
            0x82A067D8 => {
    //   block [0x82A067D8..0x82A06B60)
	// 82A067D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A067DC: 482A2C01  bl 0x82ca93dc
	ctx.lr = 0x82A067E0;
	sub_82CA93D0(ctx, base);
	// 82A067E0: DBA1FF68  stfd f29, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[29].u64 ) };
	// 82A067E4: DBC1FF70  stfd f30, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 82A067E8: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 82A067EC: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A067F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A067F4: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 82A067F8: 817E0170  lwz r11, 0x170(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A067FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06800: 419A0360  beq cr6, 0x82a06b60
	if ctx.cr[6].eq {
	pc = 0x82A06B60; continue 'dispatch;
	}
	// 82A06804: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82A06808: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A0680C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A06810: 833E0168  lwz r25, 0x168(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A06814: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82A06818: 3AAA9490  addi r21, r10, -0x6b70
	ctx.r[21].s64 = ctx.r[10].s64 + -27504;
	// 82A0681C: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 82A06820: C009A924  lfs f0, -0x56dc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A06824: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A06828: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A0682C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A06830: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A06834: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A06838: C3F5FFF4  lfs f31, -0xc(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0683C: 38A9A924  addi r5, r9, -0x56dc
	ctx.r[5].s64 = ctx.r[9].s64 + -22236;
	pc = 0x82A06B60; continue 'dispatch;
            }
            0x82A06B60 => {
    //   block [0x82A06B60..0x82A06B74)
	// 82A06B60: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A06B64: CBA1FF68  lfd f29, -0x98(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82A06B68: CBC1FF70  lfd f30, -0x90(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82A06B6C: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82A06B70: 482A28BC  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06B78 size=508
    let mut pc: u32 = 0x82A06B78;
    'dispatch: loop {
        match pc {
            0x82A06B78 => {
    //   block [0x82A06B78..0x82A06BD4)
	// 82A06B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A06B7C: 482A2865  bl 0x82ca93e0
	ctx.lr = 0x82A06B80;
	sub_82CA93D0(ctx, base);
	// 82A06B80: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 82A06B84: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82A06B88: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82A06B8C: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06B90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A06B94: 82DF0168  lwz r22, 0x168(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A06B98: 3AB60004  addi r21, r22, 4
	ctx.r[21].s64 = ctx.r[22].s64 + 4;
	// 82A06B9C: 3A96002C  addi r20, r22, 0x2c
	ctx.r[20].s64 = ctx.r[22].s64 + 44;
	// 82A06BA0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A06BA4: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82A06BA8: 48001751  bl 0x82a082f8
	ctx.lr = 0x82A06BAC;
	sub_82A082F8(ctx, base);
	// 82A06BAC: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A06BB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A06BB4: 419A0028  beq cr6, 0x82a06bdc
	if ctx.cr[6].eq {
	pc = 0x82A06BDC; continue 'dispatch;
	}
	// 82A06BB8: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A06BBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06BC0: 419A0014  beq cr6, 0x82a06bd4
	if ctx.cr[6].eq {
	pc = 0x82A06BD4; continue 'dispatch;
	}
	// 82A06BC4: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A06BC8: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A06BCC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A06BD0: 4199000C  bgt cr6, 0x82a06bdc
	if ctx.cr[6].gt {
	pc = 0x82A06BDC; continue 'dispatch;
	}
	pc = 0x82A06BD4; continue 'dispatch;
            }
            0x82A06BD4 => {
    //   block [0x82A06BD4..0x82A06BDC)
	// 82A06BD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A06BD8: 48000008  b 0x82a06be0
	pc = 0x82A06BE0; continue 'dispatch;
            }
            0x82A06BDC => {
    //   block [0x82A06BDC..0x82A06BE0)
	// 82A06BDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A06BE0; continue 'dispatch;
            }
            0x82A06BE0 => {
    //   block [0x82A06BE0..0x82A06D60)
	// 82A06BE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A06BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06BE8: 419A0178  beq cr6, 0x82a06d60
	if ctx.cr[6].eq {
	pc = 0x82A06D60; continue 'dispatch;
	}
	// 82A06BEC: 897F01B0  lbz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A06BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06BF4: 419A016C  beq cr6, 0x82a06d60
	if ctx.cr[6].eq {
	pc = 0x82A06D60; continue 'dispatch;
	}
	// 82A06BF8: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A06BFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A06C00: 419A0160  beq cr6, 0x82a06d60
	if ctx.cr[6].eq {
	pc = 0x82A06D60; continue 'dispatch;
	}
	// 82A06C04: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A06C08: 3BBF01C4  addi r29, r31, 0x1c4
	ctx.r[29].s64 = ctx.r[31].s64 + 452;
	// 82A06C0C: 813F01C8  lwz r9, 0x1c8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A06C10: 83DF0154  lwz r30, 0x154(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A06C14: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A06C18: 7D072670  srawi r7, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 82A06C1C: 7CDE3851  subf. r6, r30, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A06C20: 41820140  beq 0x82a06d60
	if ctx.cr[0].eq {
	pc = 0x82A06D60; continue 'dispatch;
	}
	// 82A06C24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A06C28: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A06C2C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A06C30: 80FD0004  lwz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A06C34: 3A6B9490  addi r19, r11, -0x6b70
	ctx.r[19].s64 = ctx.r[11].s64 + -27504;
	// 82A06C38: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A06C3C: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82A06C40: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A06C44: 38869160  addi r4, r6, -0x6ea0
	ctx.r[4].s64 = ctx.r[6].s64 + -28320;
	// 82A06C48: 7C674850  subf r3, r7, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A06C4C: C0130000  lfs f0, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A06C50: 832B0014  lwz r25, 0x14(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A06C54: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A06C58: 7C6A2670  srawi r10, r3, 4
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[3].s32 >> 4) as i64;
	pc = 0x82A06D60; continue 'dispatch;
            }
            0x82A06D60 => {
    //   block [0x82A06D60..0x82A06D74)
	// 82A06D60: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82A06D64: CBA1FF70  lfd f29, -0x90(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82A06D68: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82A06D6C: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82A06D70: 482A26C0  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06D78 size=928
    let mut pc: u32 = 0x82A06D78;
    'dispatch: loop {
        match pc {
            0x82A06D78 => {
    //   block [0x82A06D78..0x82A07104)
	// 82A06D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A06D7C: 482A2665  bl 0x82ca93e0
	ctx.lr = 0x82A06D80;
	sub_82CA93D0(ctx, base);
	// 82A06D80: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 82A06D84: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82A06D88: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82A06D8C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06D90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A06D94: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 82A06D98: 817E0170  lwz r11, 0x170(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A06D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06DA0: 419A0364  beq cr6, 0x82a07104
	if ctx.cr[6].eq {
	pc = 0x82A07104; continue 'dispatch;
	}
	// 82A06DA4: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82A06DA8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A06DAC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A06DB0: 831E0168  lwz r24, 0x168(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A06DB4: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82A06DB8: 3B2A9490  addi r25, r10, -0x6b70
	ctx.r[25].s64 = ctx.r[10].s64 + -27504;
	// 82A06DBC: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 82A06DC0: C009A924  lfs f0, -0x56dc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A06DC4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A06DC8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A06DCC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A06DD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A06DD4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A06DD8: C3F9FFF4  lfs f31, -0xc(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A06DDC: 38A9A924  addi r5, r9, -0x56dc
	ctx.r[5].s64 = ctx.r[9].s64 + -22236;
	pc = 0x82A07104; continue 'dispatch;
            }
            0x82A07104 => {
    //   block [0x82A07104..0x82A07118)
	// 82A07104: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A07108: CBA1FF70  lfd f29, -0x90(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82A0710C: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82A07110: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82A07114: 482A231C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A07118 size=364
    let mut pc: u32 = 0x82A07118;
    'dispatch: loop {
        match pc {
            0x82A07118 => {
    //   block [0x82A07118..0x82A07158)
	// 82A07118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0711C: 482A22E9  bl 0x82ca9404
	ctx.lr = 0x82A07120;
	sub_82CA93D0(ctx, base);
	// 82A07120: 83C30170  lwz r30, 0x170(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A07124: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A07128: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0712C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A07130: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A07134: 83FE0034  lwz r31, 0x34(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A07138: 40990148  ble cr6, 0x82a07280
	if !ctx.cr[6].gt {
	pc = 0x82A07280; continue 'dispatch;
	}
	// 82A0713C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A07140: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A07144: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82A07148: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A0714C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A07150: C00A92D4  lfs f0, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A07154: 390B2280  addi r8, r11, 0x2280
	ctx.r[8].s64 = ctx.r[11].s64 + 8832;
	pc = 0x82A07158; continue 'dispatch;
            }
            0x82A07158 => {
    //   block [0x82A07158..0x82A07194)
	// 82A07158: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0715C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A07160: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A07164: 419A0048  beq cr6, 0x82a071ac
	if ctx.cr[6].eq {
	pc = 0x82A071AC; continue 'dispatch;
	}
	// 82A07168: C1BE0030  lfs f13, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0716C: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A07170: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82A07174: 41990038  bgt cr6, 0x82a071ac
	if ctx.cr[6].gt {
	pc = 0x82A071AC; continue 'dispatch;
	}
	// 82A07178: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0717C: 41980018  blt cr6, 0x82a07194
	if ctx.cr[6].lt {
	pc = 0x82A07194; continue 'dispatch;
	}
	// 82A07180: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A07184: 7F0AF800  cmpw cr6, r10, r31
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82A07188: 4198000C  blt cr6, 0x82a07194
	if ctx.cr[6].lt {
	pc = 0x82A07194; continue 'dispatch;
	}
	// 82A0718C: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82A07190: 4800001C  b 0x82a071ac
	pc = 0x82A071AC; continue 'dispatch;
            }
            0x82A07194 => {
    //   block [0x82A07194..0x82A071AC)
	// 82A07194: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A07198: C1BE002C  lfs f13, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0719C: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A071A0: 90EB0014  stw r7, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82A071A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A071A8: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	pc = 0x82A071AC; continue 'dispatch;
            }
            0x82A071AC => {
    //   block [0x82A071AC..0x82A07204)
	// 82A071AC: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A071B0: 7FA9512E  stwx r29, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82A071B4: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A071B8: 81430170  lwz r10, 0x170(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A071BC: 838B0014  lwz r28, 0x14(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A071C0: 7F9BFE70  srawi r27, r28, 0x1f
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[28].s32 >> 31) as i64;
	// 82A071C4: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A071C8: 7F7BE038  and r27, r27, r28
	ctx.r[27].u64 = ctx.r[27].u64 & ctx.r[28].u64;
	// 82A071CC: 7F9BE050  subf r28, r27, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[27].s64;
	// 82A071D0: 579C103A  slwi r28, r28, 2
	ctx.r[28].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A071D4: 7D9C542E  lfsx f12, r28, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A071D8: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A071DC: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A071E0: D941FFB0  stfd f10, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[10].u64 ) };
	// 82A071E4: 8141FFB4  lwz r10, -0x4c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-76 as u32) ) } as u64;
	// 82A071E8: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A071EC: F941FFB8  std r10, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[10].u64 ) };
	// 82A071F0: C921FFB8  lfd f9, -0x48(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A071F4: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A071F8: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A071FC: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A07200: 41980068  blt cr6, 0x82a07268
	if ctx.cr[6].lt {
	pc = 0x82A07268; continue 'dispatch;
	}
	pc = 0x82A07204; continue 'dispatch;
            }
            0x82A07204 => {
    //   block [0x82A07204..0x82A07268)
	// 82A07204: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A07208: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0720C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82A07210: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A07214: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 82A07218: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0721C: 81430170  lwz r10, 0x170(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A07220: 838B0014  lwz r28, 0x14(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A07224: 7F9BFE70  srawi r27, r28, 0x1f
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[28].s32 >> 31) as i64;
	// 82A07228: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0722C: 7F7BE038  and r27, r27, r28
	ctx.r[27].u64 = ctx.r[27].u64 & ctx.r[28].u64;
	// 82A07230: 7F9BE050  subf r28, r27, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[27].s64;
	// 82A07234: 579C103A  slwi r28, r28, 2
	ctx.r[28].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A07238: 7D9C542E  lfsx f12, r28, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0723C: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A07240: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A07244: D941FFB0  stfd f10, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[10].u64 ) };
	// 82A07248: 8141FFB4  lwz r10, -0x4c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-76 as u32) ) } as u64;
	// 82A0724C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A07250: F941FFC0  std r10, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[10].u64 ) };
	// 82A07254: C921FFC0  lfd f9, -0x40(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A07258: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A0725C: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A07260: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A07264: 4098FFA0  bge cr6, 0x82a07204
	if !ctx.cr[6].lt {
	pc = 0x82A07204; continue 'dispatch;
	}
	pc = 0x82A07268; continue 'dispatch;
            }
            0x82A07268 => {
    //   block [0x82A07268..0x82A07280)
	// 82A07268: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0726C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82A07270: 38C60024  addi r6, r6, 0x24
	ctx.r[6].s64 = ctx.r[6].s64 + 36;
	// 82A07274: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A07278: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0727C: 4198FEDC  blt cr6, 0x82a07158
	if ctx.cr[6].lt {
	pc = 0x82A07158; continue 'dispatch;
	}
	pc = 0x82A07280; continue 'dispatch;
            }
            0x82A07280 => {
    //   block [0x82A07280..0x82A07284)
	// 82A07280: 482A21D4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A07288 size=208
    let mut pc: u32 = 0x82A07288;
    'dispatch: loop {
        match pc {
            0x82A07288 => {
    //   block [0x82A07288..0x82A07354)
	// 82A07288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0728C: 482A2175  bl 0x82ca9400
	ctx.lr = 0x82A07290;
	sub_82CA93D0(ctx, base);
	// 82A07290: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A07294: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A07298: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0729C: 409900B8  ble cr6, 0x82a07354
	if !ctx.cr[6].gt {
	pc = 0x82A07354; continue 'dispatch;
	}
	// 82A072A0: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82A072A4: 39030130  addi r8, r3, 0x130
	ctx.r[8].s64 = ctx.r[3].s64 + 304;
	// 82A072A8: 38E30140  addi r7, r3, 0x140
	ctx.r[7].s64 = ctx.r[3].s64 + 320;
	// 82A072AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A072B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A072B4: C0069484  lfs f0, -0x6b7c(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A072B8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82A072BC: D001FF80  stfs f0, -0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), tmp.u32 ) };
	// 82A072C0: 83E301C8  lwz r31, 0x1c8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A072C4: 3B81FFA0  addi r28, r1, -0x60
	ctx.r[28].s64 = ctx.r[1].s64 + -96;
	// 82A072C8: 3B61FFB0  addi r27, r1, -0x50
	ctx.r[27].s64 = ctx.r[1].s64 + -80;
	// 82A072CC: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A072D0: 3B41FFA4  addi r26, r1, -0x5c
	ctx.r[26].s64 = ctx.r[1].s64 + -92;
	// 82A072D4: 3BC1FF90  addi r30, r1, -0x70
	ctx.r[30].s64 = ctx.r[1].s64 + -112;
	// 82A072D8: 3BA1FF98  addi r29, r1, -0x68
	ctx.r[29].s64 = ctx.r[1].s64 + -104;
	pc = 0x82A07354; continue 'dispatch;
            }
            0x82A07354 => {
    //   block [0x82A07354..0x82A07358)
	// 82A07354: 482A20FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A07358 size=576
    let mut pc: u32 = 0x82A07358;
    'dispatch: loop {
        match pc {
            0x82A07358 => {
    //   block [0x82A07358..0x82A07598)
	// 82A07358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0735C: 482A2095  bl 0x82ca93f0
	ctx.lr = 0x82A07360;
	sub_82CA93D0(ctx, base);
	// 82A07360: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82A07364: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A07598 size=704
    let mut pc: u32 = 0x82A07598;
    'dispatch: loop {
        match pc {
            0x82A07598 => {
    //   block [0x82A07598..0x82A07858)
	// 82A07598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0759C: 482A1E5D  bl 0x82ca93f8
	ctx.lr = 0x82A075A0;
	sub_82CA93D0(ctx, base);
	// 82A075A0: 814301C8  lwz r10, 0x1c8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A075A4: 3921FF90  addi r9, r1, -0x70
	ctx.r[9].s64 = ctx.r[1].s64 + -112;
	// 82A075A8: 38C1FF90  addi r6, r1, -0x70
	ctx.r[6].s64 = ctx.r[1].s64 + -112;
	// 82A075AC: 80E301C0  lwz r7, 0x1c0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(448 as u32) ) } as u64;
	// 82A075B0: 3901FF98  addi r8, r1, -0x68
	ctx.r[8].s64 = ctx.r[1].s64 + -104;
	// 82A075B4: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A075B8: 3BE1FFA0  addi r31, r1, -0x60
	ctx.r[31].s64 = ctx.r[1].s64 + -96;
	// 82A075BC: C0030210  lfs f0, 0x210(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A075C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A07858 size=384
    let mut pc: u32 = 0x82A07858;
    'dispatch: loop {
        match pc {
            0x82A07858 => {
    //   block [0x82A07858..0x82A07894)
	// 82A07858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0785C: 482A1BAD  bl 0x82ca9408
	ctx.lr = 0x82A07860;
	sub_82CA93D0(ctx, base);
	// 82A07860: 83C30170  lwz r30, 0x170(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A07864: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A07868: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0786C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A07870: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A07874: 83FE0034  lwz r31, 0x34(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A07878: 4099015C  ble cr6, 0x82a079d4
	if !ctx.cr[6].gt {
	pc = 0x82A079D4; continue 'dispatch;
	}
	// 82A0787C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A07880: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A07884: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82A07888: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A0788C: 38EB2270  addi r7, r11, 0x2270
	ctx.r[7].s64 = ctx.r[11].s64 + 8816;
	// 82A07890: C00A92D4  lfs f0, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82A07894; continue 'dispatch;
            }
            0x82A07894 => {
    //   block [0x82A07894..0x82A078EC)
	// 82A07894: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A07898: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0789C: 8124001C  lwz r9, 0x1c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A078A0: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82A078A4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A078A8: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 82A078AC: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A078B0: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A078B4: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A078B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A078BC: 419A0048  beq cr6, 0x82a07904
	if ctx.cr[6].eq {
	pc = 0x82A07904; continue 'dispatch;
	}
	// 82A078C0: C1BE0030  lfs f13, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A078C4: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A078C8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82A078CC: 41990038  bgt cr6, 0x82a07904
	if ctx.cr[6].gt {
	pc = 0x82A07904; continue 'dispatch;
	}
	// 82A078D0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A078D4: 41980018  blt cr6, 0x82a078ec
	if ctx.cr[6].lt {
	pc = 0x82A078EC; continue 'dispatch;
	}
	// 82A078D8: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A078DC: 7F0AF800  cmpw cr6, r10, r31
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82A078E0: 4198000C  blt cr6, 0x82a078ec
	if ctx.cr[6].lt {
	pc = 0x82A078EC; continue 'dispatch;
	}
	// 82A078E4: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A078E8: 4800001C  b 0x82a07904
	pc = 0x82A07904; continue 'dispatch;
            }
            0x82A078EC => {
    //   block [0x82A078EC..0x82A07904)
	// 82A078EC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A078F0: C1BE002C  lfs f13, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A078F4: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A078F8: 90CB0010  stw r6, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82A078FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A07900: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	pc = 0x82A07904; continue 'dispatch;
            }
            0x82A07904 => {
    //   block [0x82A07904..0x82A0795C)
	// 82A07904: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A07908: 7FA8512E  stwx r29, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82A0790C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A07910: 81430170  lwz r10, 0x170(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A07914: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A07918: 7D3CFE70  srawi r28, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 82A0791C: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A07920: 7F9C4838  and r28, r28, r9
	ctx.r[28].u64 = ctx.r[28].u64 & ctx.r[9].u64;
	// 82A07924: 7D3C4850  subf r9, r28, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[28].s64;
	// 82A07928: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0792C: 7D89542E  lfsx f12, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A07930: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A07934: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A07938: D941FFC0  stfd f10, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[10].u64 ) };
	// 82A0793C: 8141FFC4  lwz r10, -0x3c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) } as u64;
	// 82A07940: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 82A07944: F921FFC8  std r9, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[9].u64 ) };
	// 82A07948: C921FFC8  lfd f9, -0x38(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A0794C: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A07950: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A07954: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A07958: 41980068  blt cr6, 0x82a079c0
	if ctx.cr[6].lt {
	pc = 0x82A079C0; continue 'dispatch;
	}
	pc = 0x82A0795C; continue 'dispatch;
            }
            0x82A0795C => {
    //   block [0x82A0795C..0x82A079C0)
	// 82A0795C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A07960: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A07964: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A07968: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0796C: 7CC8512E  stwx r6, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A07970: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A07974: 81230170  lwz r9, 0x170(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A07978: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0797C: 7D5CFE70  srawi r28, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A07980: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A07984: 7F9C5038  and r28, r28, r10
	ctx.r[28].u64 = ctx.r[28].u64 & ctx.r[10].u64;
	// 82A07988: 7D5C5050  subf r10, r28, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[28].s64;
	// 82A0798C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A07990: 7D8A4C2E  lfsx f12, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A07994: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A07998: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A0799C: D941FFC0  stfd f10, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[10].u64 ) };
	// 82A079A0: 8121FFC4  lwz r9, -0x3c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) } as u64;
	// 82A079A4: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 82A079A8: F941FFD0  std r10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[10].u64 ) };
	// 82A079AC: C921FFD0  lfd f9, -0x30(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A079B0: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A079B4: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A079B8: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A079BC: 4098FFA0  bge cr6, 0x82a0795c
	if !ctx.cr[6].lt {
	pc = 0x82A0795C; continue 'dispatch;
	}
	pc = 0x82A079C0; continue 'dispatch;
            }
            0x82A079C0 => {
    //   block [0x82A079C0..0x82A079D4)
	// 82A079C0: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A079C4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82A079C8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82A079CC: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A079D0: 4198FEC4  blt cr6, 0x82a07894
	if ctx.cr[6].lt {
	pc = 0x82A07894; continue 'dispatch;
	}
	pc = 0x82A079D4; continue 'dispatch;
            }
            0x82A079D4 => {
    //   block [0x82A079D4..0x82A079D8)
	// 82A079D4: 482A1A84  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A079D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A079D8 size=212
    let mut pc: u32 = 0x82A079D8;
    'dispatch: loop {
        match pc {
            0x82A079D8 => {
    //   block [0x82A079D8..0x82A07AA8)
	// 82A079D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A079DC: 482A1A25  bl 0x82ca9400
	ctx.lr = 0x82A079E0;
	sub_82CA93D0(ctx, base);
	// 82A079E0: 81430154  lwz r10, 0x154(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A079E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A079E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A079EC: 409900BC  ble cr6, 0x82a07aa8
	if !ctx.cr[6].gt {
	pc = 0x82A07AA8; continue 'dispatch;
	}
	// 82A079F0: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82A079F4: 39230130  addi r9, r3, 0x130
	ctx.r[9].s64 = ctx.r[3].s64 + 304;
	// 82A079F8: 39030140  addi r8, r3, 0x140
	ctx.r[8].s64 = ctx.r[3].s64 + 320;
	// 82A079FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A07A00: C0079484  lfs f0, -0x6b7c(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A07A04: D001FF80  stfs f0, -0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), tmp.u32 ) };
	// 82A07A08: 80C301C8  lwz r6, 0x1c8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A07A0C: 3BC1FFA0  addi r30, r1, -0x60
	ctx.r[30].s64 = ctx.r[1].s64 + -96;
	// 82A07A10: 3B81FFB0  addi r28, r1, -0x50
	ctx.r[28].s64 = ctx.r[1].s64 + -80;
	// 82A07A14: 80E40010  lwz r7, 0x10(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A07A18: 3B41FFA4  addi r26, r1, -0x5c
	ctx.r[26].s64 = ctx.r[1].s64 + -92;
	// 82A07A1C: 83A4001C  lwz r29, 0x1c(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A07A20: 38A1FF90  addi r5, r1, -0x70
	ctx.r[5].s64 = ctx.r[1].s64 + -112;
	// 82A07A24: 83640004  lwz r27, 4(r4)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A07A28: 3BE1FF98  addi r31, r1, -0x68
	ctx.r[31].s64 = ctx.r[1].s64 + -104;
	pc = 0x82A07AA8; continue 'dispatch;
            }
            0x82A07AA8 => {
    //   block [0x82A07AA8..0x82A07AAC)
	// 82A07AA8: 482A19A8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A07AB0 size=604
    let mut pc: u32 = 0x82A07AB0;
    'dispatch: loop {
        match pc {
            0x82A07AB0 => {
    //   block [0x82A07AB0..0x82A07D0C)
	// 82A07AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07AB4: 482A1945  bl 0x82ca93f8
	ctx.lr = 0x82A07AB8;
	sub_82CA93D0(ctx, base);
	// 82A07AB8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82A07ABC: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A07D10 size=736
    let mut pc: u32 = 0x82A07D10;
    'dispatch: loop {
        match pc {
            0x82A07D10 => {
    //   block [0x82A07D10..0x82A07FF0)
	// 82A07D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07D14: 482A16E5  bl 0x82ca93f8
	ctx.lr = 0x82A07D18;
	sub_82CA93D0(ctx, base);
	// 82A07D18: 814301C8  lwz r10, 0x1c8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A07D1C: 3921FF90  addi r9, r1, -0x70
	ctx.r[9].s64 = ctx.r[1].s64 + -112;
	// 82A07D20: 3901FF98  addi r8, r1, -0x68
	ctx.r[8].s64 = ctx.r[1].s64 + -104;
	// 82A07D24: 80A40010  lwz r5, 0x10(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A07D28: 38C1FF90  addi r6, r1, -0x70
	ctx.r[6].s64 = ctx.r[1].s64 + -112;
	// 82A07D2C: 80E4001C  lwz r7, 0x1c(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A07D30: 3BE1FF80  addi r31, r1, -0x80
	ctx.r[31].s64 = ctx.r[1].s64 + -128;
	// 82A07D34: 83C301C0  lwz r30, 0x1c0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(448 as u32) ) } as u64;
	// 82A07D38: 3B81FF80  addi r28, r1, -0x80
	ctx.r[28].s64 = ctx.r[1].s64 + -128;
	// 82A07D3C: 83A40004  lwz r29, 4(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A07FF0 size=388
    let mut pc: u32 = 0x82A07FF0;
    'dispatch: loop {
        match pc {
            0x82A07FF0 => {
    //   block [0x82A07FF0..0x82A08024)
	// 82A07FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A07FF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A07FFC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A08000: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82A08004: 48820B45  bl 0x83228b48
	ctx.lr = 0x82A08008;
	sub_83228B48(ctx, base);
	// 82A08008: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0800C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A08010: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A08014: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A08018: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A0801C: 419A0008  beq cr6, 0x82a08024
	if ctx.cr[6].eq {
	pc = 0x82A08024; continue 'dispatch;
	}
	// 82A08020: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82A08024; continue 'dispatch;
            }
            0x82A08024 => {
    //   block [0x82A08024..0x82A0805C)
	// 82A08024: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A08028: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0802C: 419A0030  beq cr6, 0x82a0805c
	if ctx.cr[6].eq {
	pc = 0x82A0805C; continue 'dispatch;
	}
	// 82A08030: 91660154  stw r11, 0x154(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 82A08034: 91640014  stw r11, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A08038: 91640010  stw r11, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A0803C: 91640020  stw r11, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A08040: 91670014  stw r11, 0x14(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A08044: 91670010  stw r11, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A08048: 91670020  stw r11, 0x20(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A0804C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A08050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A08054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08058: 4E800020  blr
	return;
            }
            0x82A0805C => {
    //   block [0x82A0805C..0x82A08078)
	// 82A0805C: 816601CC  lwz r11, 0x1cc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A08060: 814601C8  lwz r10, 0x1c8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A08064: 81260154  lwz r9, 0x154(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A08068: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A0806C: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 82A08070: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A08074: 40980050  bge cr6, 0x82a080c4
	if !ctx.cr[6].lt {
	pc = 0x82A080C4; continue 'dispatch;
	}
	pc = 0x82A08078; continue 'dispatch;
            }
            0x82A08078 => {
    //   block [0x82A08078..0x82A080C4)
	// 82A08078: 81460154  lwz r10, 0x154(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0807C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A08080: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A08084: 91460154  stw r10, 0x154(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 82A08088: 81440020  lwz r10, 0x20(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A0808C: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A08090: 38A9FFFF  addi r5, r9, -1
	ctx.r[5].s64 = ctx.r[9].s64 + -1;
	// 82A08094: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 82A08098: 90A40014  stw r5, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 82A0809C: 91040020  stw r8, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 82A080A0: 81270014  lwz r9, 0x14(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A080A4: 81470020  lwz r10, 0x20(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A080A8: 386AFFFF  addi r3, r10, -1
	ctx.r[3].s64 = ctx.r[10].s64 + -1;
	// 82A080AC: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 82A080B0: 90670020  stw r3, 0x20(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82A080B4: 91470014  stw r10, 0x14(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82A080B8: 81260154  lwz r9, 0x154(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A080BC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A080C0: 4198FFB8  blt cr6, 0x82a08078
	if ctx.cr[6].lt {
	pc = 0x82A08078; continue 'dispatch;
	}
	pc = 0x82A080C4; continue 'dispatch;
            }
            0x82A080C4 => {
    //   block [0x82A080C4..0x82A080D4)
	// 82A080C4: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A080C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A080CC: 419A0098  beq cr6, 0x82a08164
	if ctx.cr[6].eq {
	pc = 0x82A08164; continue 'dispatch;
	}
	// 82A080D0: 8167001C  lwz r11, 0x1c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82A080D4; continue 'dispatch;
            }
            0x82A080D4 => {
    //   block [0x82A080D4..0x82A08164)
	// 82A080D4: 81270010  lwz r9, 0x10(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A080D8: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82A080DC: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A080E0: 7D2B5838  and r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 82A080E4: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A080E8: 7D0B4A14  add r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A080EC: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A080F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A080F4: 88AB0014  lbz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A080F8: C02B000C  lfs f1, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A080FC: 48826AED  bl 0x8322ebe8
	ctx.lr = 0x82A08100;
	sub_8322EBE8(ctx, base);
	// 82A08100: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A08104: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A08108: 419A005C  beq cr6, 0x82a08164
	if ctx.cr[6].eq {
	pc = 0x82A08164; continue 'dispatch;
	}
	// 82A0810C: 81660154  lwz r11, 0x154(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A08110: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A08114: 91660154  stw r11, 0x154(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 82A08118: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0811C: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82A08120: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08124: 8124001C  lwz r9, 0x1c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A08128: 386BFFFF  addi r3, r11, -1
	ctx.r[3].s64 = ctx.r[11].s64 + -1;
	// 82A0812C: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A08130: 90640020  stw r3, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82A08134: 90A40010  stw r5, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 82A08138: 8167001C  lwz r11, 0x1c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0813C: 81470020  lwz r10, 0x20(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08140: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 82A08144: 81270010  lwz r9, 0x10(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08148: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A0814C: 7D255838  and r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 82A08150: 91070020  stw r8, 0x20(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 82A08154: 90A70010  stw r5, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 82A08158: 80640020  lwz r3, 0x20(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A0815C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A08160: 409AFF74  bne cr6, 0x82a080d4
	if !ctx.cr[6].eq {
	pc = 0x82A080D4; continue 'dispatch;
	}
	pc = 0x82A08164; continue 'dispatch;
            }
            0x82A08164 => {
    //   block [0x82A08164..0x82A08174)
	// 82A08164: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A08168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0816C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A08178 size=384
    let mut pc: u32 = 0x82A08178;
    'dispatch: loop {
        match pc {
            0x82A08178 => {
    //   block [0x82A08178..0x82A081B4)
	// 82A08178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0817C: 482A128D  bl 0x82ca9408
	ctx.lr = 0x82A08180;
	sub_82CA93D0(ctx, base);
	// 82A08180: 83C30170  lwz r30, 0x170(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A08184: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A08188: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0818C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A08190: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A08194: 83FE0034  lwz r31, 0x34(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A08198: 4099015C  ble cr6, 0x82a082f4
	if !ctx.cr[6].gt {
	pc = 0x82A082F4; continue 'dispatch;
	}
	// 82A0819C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A081A0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A081A4: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82A081A8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A081AC: 38EB2260  addi r7, r11, 0x2260
	ctx.r[7].s64 = ctx.r[11].s64 + 8800;
	// 82A081B0: C00A92D4  lfs f0, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82A081B4; continue 'dispatch;
            }
            0x82A081B4 => {
    //   block [0x82A081B4..0x82A0820C)
	// 82A081B4: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A081B8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A081BC: 8124001C  lwz r9, 0x1c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A081C0: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82A081C4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A081C8: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 82A081CC: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A081D0: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A081D4: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A081D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A081DC: 419A0048  beq cr6, 0x82a08224
	if ctx.cr[6].eq {
	pc = 0x82A08224; continue 'dispatch;
	}
	// 82A081E0: C1BE0030  lfs f13, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A081E4: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A081E8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82A081EC: 41990038  bgt cr6, 0x82a08224
	if ctx.cr[6].gt {
	pc = 0x82A08224; continue 'dispatch;
	}
	// 82A081F0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A081F4: 41980018  blt cr6, 0x82a0820c
	if ctx.cr[6].lt {
	pc = 0x82A0820C; continue 'dispatch;
	}
	// 82A081F8: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A081FC: 7F0AF800  cmpw cr6, r10, r31
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82A08200: 4198000C  blt cr6, 0x82a0820c
	if ctx.cr[6].lt {
	pc = 0x82A0820C; continue 'dispatch;
	}
	// 82A08204: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A08208: 4800001C  b 0x82a08224
	pc = 0x82A08224; continue 'dispatch;
            }
            0x82A0820C => {
    //   block [0x82A0820C..0x82A08224)
	// 82A0820C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A08210: C1BE002C  lfs f13, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A08214: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A08218: 90CB0010  stw r6, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82A0821C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A08220: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	pc = 0x82A08224; continue 'dispatch;
            }
            0x82A08224 => {
    //   block [0x82A08224..0x82A0827C)
	// 82A08224: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08228: 7FA8512E  stwx r29, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82A0822C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A08230: 81430170  lwz r10, 0x170(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A08234: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08238: 7D3CFE70  srawi r28, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 82A0823C: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08240: 7F9C4838  and r28, r28, r9
	ctx.r[28].u64 = ctx.r[28].u64 & ctx.r[9].u64;
	// 82A08244: 7D3C4850  subf r9, r28, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[28].s64;
	// 82A08248: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0824C: 7D89542E  lfsx f12, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A08250: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A08254: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A08258: D941FFC0  stfd f10, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[10].u64 ) };
	// 82A0825C: 8141FFC4  lwz r10, -0x3c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) } as u64;
	// 82A08260: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 82A08264: F921FFC8  std r9, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[9].u64 ) };
	// 82A08268: C921FFC8  lfd f9, -0x38(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A0826C: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A08270: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A08274: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A08278: 41980068  blt cr6, 0x82a082e0
	if ctx.cr[6].lt {
	pc = 0x82A082E0; continue 'dispatch;
	}
	pc = 0x82A0827C; continue 'dispatch;
            }
            0x82A0827C => {
    //   block [0x82A0827C..0x82A082E0)
	// 82A0827C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08280: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A08284: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A08288: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0828C: 7CC8512E  stwx r6, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A08290: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A08294: 81230170  lwz r9, 0x170(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A08298: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0829C: 7D5CFE70  srawi r28, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A082A0: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A082A4: 7F9C5038  and r28, r28, r10
	ctx.r[28].u64 = ctx.r[28].u64 & ctx.r[10].u64;
	// 82A082A8: 7D5C5050  subf r10, r28, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[28].s64;
	// 82A082AC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A082B0: 7D8A4C2E  lfsx f12, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A082B4: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A082B8: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A082BC: D941FFC0  stfd f10, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[10].u64 ) };
	// 82A082C0: 8121FFC4  lwz r9, -0x3c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) } as u64;
	// 82A082C4: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 82A082C8: F941FFD0  std r10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[10].u64 ) };
	// 82A082CC: C921FFD0  lfd f9, -0x30(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A082D0: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A082D4: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A082D8: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A082DC: 4098FFA0  bge cr6, 0x82a0827c
	if !ctx.cr[6].lt {
	pc = 0x82A0827C; continue 'dispatch;
	}
	pc = 0x82A082E0; continue 'dispatch;
            }
            0x82A082E0 => {
    //   block [0x82A082E0..0x82A082F4)
	// 82A082E0: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A082E4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82A082E8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82A082EC: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A082F0: 4198FEC4  blt cr6, 0x82a081b4
	if ctx.cr[6].lt {
	pc = 0x82A081B4; continue 'dispatch;
	}
	pc = 0x82A082F4; continue 'dispatch;
            }
            0x82A082F4 => {
    //   block [0x82A082F4..0x82A082F8)
	// 82A082F4: 482A1164  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A082F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A082F8 size=380
    let mut pc: u32 = 0x82A082F8;
    'dispatch: loop {
        match pc {
            0x82A082F8 => {
    //   block [0x82A082F8..0x82A0832C)
	// 82A082F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A082FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A08300: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A08304: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A08308: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82A0830C: 4882083D  bl 0x83228b48
	ctx.lr = 0x82A08310;
	sub_83228B48(ctx, base);
	// 82A08310: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A08314: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A08318: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0831C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A08320: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A08324: 419A0008  beq cr6, 0x82a0832c
	if ctx.cr[6].eq {
	pc = 0x82A0832C; continue 'dispatch;
	}
	// 82A08328: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82A0832C; continue 'dispatch;
            }
            0x82A0832C => {
    //   block [0x82A0832C..0x82A08364)
	// 82A0832C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A08330: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A08334: 419A0030  beq cr6, 0x82a08364
	if ctx.cr[6].eq {
	pc = 0x82A08364; continue 'dispatch;
	}
	// 82A08338: 91660154  stw r11, 0x154(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 82A0833C: 91640014  stw r11, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A08340: 91640010  stw r11, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A08344: 91640020  stw r11, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A08348: 91670014  stw r11, 0x14(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A0834C: 91670010  stw r11, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A08350: 91670020  stw r11, 0x20(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A08354: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A08358: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0835C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08360: 4E800020  blr
	return;
            }
            0x82A08364 => {
    //   block [0x82A08364..0x82A08380)
	// 82A08364: 816601CC  lwz r11, 0x1cc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A08368: 814601C8  lwz r10, 0x1c8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A0836C: 81260154  lwz r9, 0x154(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A08370: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A08374: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 82A08378: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A0837C: 40980050  bge cr6, 0x82a083cc
	if !ctx.cr[6].lt {
	pc = 0x82A083CC; continue 'dispatch;
	}
	pc = 0x82A08380; continue 'dispatch;
            }
            0x82A08380 => {
    //   block [0x82A08380..0x82A083CC)
	// 82A08380: 81460154  lwz r10, 0x154(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A08384: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A08388: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A0838C: 91460154  stw r10, 0x154(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 82A08390: 81440020  lwz r10, 0x20(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08394: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A08398: 38A9FFFF  addi r5, r9, -1
	ctx.r[5].s64 = ctx.r[9].s64 + -1;
	// 82A0839C: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 82A083A0: 90A40014  stw r5, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 82A083A4: 91040020  stw r8, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 82A083A8: 81270014  lwz r9, 0x14(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A083AC: 81470020  lwz r10, 0x20(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A083B0: 386AFFFF  addi r3, r10, -1
	ctx.r[3].s64 = ctx.r[10].s64 + -1;
	// 82A083B4: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 82A083B8: 90670020  stw r3, 0x20(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82A083BC: 91470014  stw r10, 0x14(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82A083C0: 81260154  lwz r9, 0x154(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A083C4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A083C8: 4198FFB8  blt cr6, 0x82a08380
	if ctx.cr[6].lt {
	pc = 0x82A08380; continue 'dispatch;
	}
	pc = 0x82A083CC; continue 'dispatch;
            }
            0x82A083CC => {
    //   block [0x82A083CC..0x82A083DC)
	// 82A083CC: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A083D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A083D4: 419A0090  beq cr6, 0x82a08464
	if ctx.cr[6].eq {
	pc = 0x82A08464; continue 'dispatch;
	}
	// 82A083D8: 8167001C  lwz r11, 0x1c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82A083DC; continue 'dispatch;
            }
            0x82A083DC => {
    //   block [0x82A083DC..0x82A08464)
	// 82A083DC: 81270010  lwz r9, 0x10(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A083E0: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82A083E4: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A083E8: 7D285838  and r8, r9, r11
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 82A083EC: 1D68002C  mulli r11, r8, 0x2c
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A083F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A083F4: 88AB0014  lbz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A083F8: C02B000C  lfs f1, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A083FC: 488267ED  bl 0x8322ebe8
	ctx.lr = 0x82A08400;
	sub_8322EBE8(ctx, base);
	// 82A08400: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A08404: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A08408: 419A005C  beq cr6, 0x82a08464
	if ctx.cr[6].eq {
	pc = 0x82A08464; continue 'dispatch;
	}
	// 82A0840C: 81660154  lwz r11, 0x154(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A08410: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A08414: 91660154  stw r11, 0x154(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 82A08418: 8124001C  lwz r9, 0x1c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0841C: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08420: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82A08424: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08428: 90A40020  stw r5, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[5].u32 ) };
	// 82A0842C: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82A08430: 7D234038  and r3, r9, r8
	ctx.r[3].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A08434: 90640010  stw r3, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82A08438: 81270010  lwz r9, 0x10(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0843C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A08440: 81470020  lwz r10, 0x20(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08444: 8167001C  lwz r11, 0x1c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A08448: 7D285838  and r8, r9, r11
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 82A0844C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A08450: 91070010  stw r8, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82A08454: 91470020  stw r10, 0x20(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82A08458: 80A40020  lwz r5, 0x20(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A0845C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A08460: 409AFF7C  bne cr6, 0x82a083dc
	if !ctx.cr[6].eq {
	pc = 0x82A083DC; continue 'dispatch;
	}
	pc = 0x82A08464; continue 'dispatch;
            }
            0x82A08464 => {
    //   block [0x82A08464..0x82A08474)
	// 82A08464: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A08468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0846C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08470: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A08478 size=376
    let mut pc: u32 = 0x82A08478;
    'dispatch: loop {
        match pc {
            0x82A08478 => {
    //   block [0x82A08478..0x82A084B4)
	// 82A08478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0847C: 482A0F8D  bl 0x82ca9408
	ctx.lr = 0x82A08480;
	sub_82CA93D0(ctx, base);
	// 82A08480: 83E30170  lwz r31, 0x170(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A08484: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A08488: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0848C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A08490: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A08494: 80BF0034  lwz r5, 0x34(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A08498: 40990154  ble cr6, 0x82a085ec
	if !ctx.cr[6].gt {
	pc = 0x82A085EC; continue 'dispatch;
	}
	// 82A0849C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A084A0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A084A4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A084A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A084AC: 390B2250  addi r8, r11, 0x2250
	ctx.r[8].s64 = ctx.r[11].s64 + 8784;
	// 82A084B0: C00A92D4  lfs f0, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82A084B4; continue 'dispatch;
            }
            0x82A084B4 => {
    //   block [0x82A084B4..0x82A08504)
	// 82A084B4: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A084B8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A084BC: 83A4001C  lwz r29, 0x1c(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A084C0: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 82A084C4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A084C8: 7D6BE838  and r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[29].u64;
	// 82A084CC: 1D6B002C  mulli r11, r11, 0x2c
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A084D0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A084D4: 419A0048  beq cr6, 0x82a0851c
	if ctx.cr[6].eq {
	pc = 0x82A0851C; continue 'dispatch;
	}
	// 82A084D8: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A084DC: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A084E0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82A084E4: 41990038  bgt cr6, 0x82a0851c
	if ctx.cr[6].gt {
	pc = 0x82A0851C; continue 'dispatch;
	}
	// 82A084E8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A084EC: 41980018  blt cr6, 0x82a08504
	if ctx.cr[6].lt {
	pc = 0x82A08504; continue 'dispatch;
	}
	// 82A084F0: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A084F4: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82A084F8: 4198000C  blt cr6, 0x82a08504
	if ctx.cr[6].lt {
	pc = 0x82A08504; continue 'dispatch;
	}
	// 82A084FC: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A08500: 4800001C  b 0x82a0851c
	pc = 0x82A0851C; continue 'dispatch;
            }
            0x82A08504 => {
    //   block [0x82A08504..0x82A0851C)
	// 82A08504: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A08508: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0850C: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A08510: 90EB0010  stw r7, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82A08514: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A08518: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	pc = 0x82A0851C; continue 'dispatch;
            }
            0x82A0851C => {
    //   block [0x82A0851C..0x82A08574)
	// 82A0851C: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08520: 7FC9512E  stwx r30, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 82A08524: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A08528: 81430170  lwz r10, 0x170(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0852C: 83AB0010  lwz r29, 0x10(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08530: 7FBCFE70  srawi r28, r29, 0x1f
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[29].s32 >> 31) as i64;
	// 82A08534: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08538: 7F9CE838  and r28, r28, r29
	ctx.r[28].u64 = ctx.r[28].u64 & ctx.r[29].u64;
	// 82A0853C: 7FBCE850  subf r29, r28, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 82A08540: 57BD103A  slwi r29, r29, 2
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82A08544: 7D9D542E  lfsx f12, r29, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A08548: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A0854C: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A08550: D941FFC0  stfd f10, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[10].u64 ) };
	// 82A08554: 8141FFC4  lwz r10, -0x3c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) } as u64;
	// 82A08558: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A0855C: F941FFC8  std r10, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[10].u64 ) };
	// 82A08560: C921FFC8  lfd f9, -0x38(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A08564: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A08568: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A0856C: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A08570: 41980068  blt cr6, 0x82a085d8
	if ctx.cr[6].lt {
	pc = 0x82A085D8; continue 'dispatch;
	}
	pc = 0x82A08574; continue 'dispatch;
            }
            0x82A08574 => {
    //   block [0x82A08574..0x82A085D8)
	// 82A08574: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08578: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0857C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A08580: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08584: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 82A08588: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0858C: 81430170  lwz r10, 0x170(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A08590: 83AB0010  lwz r29, 0x10(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08594: 7FBCFE70  srawi r28, r29, 0x1f
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[29].s32 >> 31) as i64;
	// 82A08598: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0859C: 7F9CE838  and r28, r28, r29
	ctx.r[28].u64 = ctx.r[28].u64 & ctx.r[29].u64;
	// 82A085A0: 7FBCE850  subf r29, r28, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 82A085A4: 57BD103A  slwi r29, r29, 2
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82A085A8: 7D9D542E  lfsx f12, r29, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A085AC: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A085B0: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A085B4: D941FFC0  stfd f10, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[10].u64 ) };
	// 82A085B8: 8141FFC4  lwz r10, -0x3c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) } as u64;
	// 82A085BC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A085C0: F941FFD0  std r10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[10].u64 ) };
	// 82A085C4: C921FFD0  lfd f9, -0x30(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A085C8: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A085CC: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A085D0: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A085D4: 4098FFA0  bge cr6, 0x82a08574
	if !ctx.cr[6].lt {
	pc = 0x82A08574; continue 'dispatch;
	}
	pc = 0x82A085D8; continue 'dispatch;
            }
            0x82A085D8 => {
    //   block [0x82A085D8..0x82A085EC)
	// 82A085D8: 81630154  lwz r11, 0x154(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A085DC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82A085E0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A085E4: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A085E8: 4198FECC  blt cr6, 0x82a084b4
	if ctx.cr[6].lt {
	pc = 0x82A084B4; continue 'dispatch;
	}
	pc = 0x82A085EC; continue 'dispatch;
            }
            0x82A085EC => {
    //   block [0x82A085EC..0x82A085F0)
	// 82A085EC: 482A0E6C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A085F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A085F0 size=228
    let mut pc: u32 = 0x82A085F0;
    'dispatch: loop {
        match pc {
            0x82A085F0 => {
    //   block [0x82A085F0..0x82A086D0)
	// 82A085F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A085F4: 482A0E09  bl 0x82ca93fc
	ctx.lr = 0x82A085F8;
	sub_82CA93D0(ctx, base);
	// 82A085F8: 81430154  lwz r10, 0x154(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A085FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A08600: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A08604: 409900CC  ble cr6, 0x82a086d0
	if !ctx.cr[6].gt {
	pc = 0x82A086D0; continue 'dispatch;
	}
	// 82A08608: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A0860C: 39030130  addi r8, r3, 0x130
	ctx.r[8].s64 = ctx.r[3].s64 + 304;
	// 82A08610: 38E30140  addi r7, r3, 0x140
	ctx.r[7].s64 = ctx.r[3].s64 + 320;
	// 82A08614: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A08618: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 82A0861C: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A08620: D001FF80  stfs f0, -0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), tmp.u32 ) };
	// 82A08624: 80C301C8  lwz r6, 0x1c8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A08628: 3B81FFA0  addi r28, r1, -0x60
	ctx.r[28].s64 = ctx.r[1].s64 + -96;
	// 82A0862C: 3B41FFB0  addi r26, r1, -0x50
	ctx.r[26].s64 = ctx.r[1].s64 + -80;
	// 82A08630: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08634: 3B21FFA4  addi r25, r1, -0x5c
	ctx.r[25].s64 = ctx.r[1].s64 + -92;
	// 82A08638: 8364001C  lwz r27, 0x1c(r4)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0863C: 3BC1FF90  addi r30, r1, -0x70
	ctx.r[30].s64 = ctx.r[1].s64 + -112;
	// 82A08640: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08644: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	pc = 0x82A086D0; continue 'dispatch;
            }
            0x82A086D0 => {
    //   block [0x82A086D0..0x82A086D4)
	// 82A086D0: 482A0D7C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A086D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A086D8 size=640
    let mut pc: u32 = 0x82A086D8;
    'dispatch: loop {
        match pc {
            0x82A086D8 => {
    //   block [0x82A086D8..0x82A08958)
	// 82A086D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A086DC: 482A0D19  bl 0x82ca93f4
	ctx.lr = 0x82A086E0;
	sub_82CA93D0(ctx, base);
	// 82A086E0: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82A086E4: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A08958 size=768
    let mut pc: u32 = 0x82A08958;
    'dispatch: loop {
        match pc {
            0x82A08958 => {
    //   block [0x82A08958..0x82A08C58)
	// 82A08958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0895C: 482A0AA1  bl 0x82ca93fc
	ctx.lr = 0x82A08960;
	sub_82CA93D0(ctx, base);
	// 82A08960: 814301C8  lwz r10, 0x1c8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 82A08964: 3901FFA0  addi r8, r1, -0x60
	ctx.r[8].s64 = ctx.r[1].s64 + -96;
	// 82A08968: 38A1FFA0  addi r5, r1, -0x60
	ctx.r[5].s64 = ctx.r[1].s64 + -96;
	// 82A0896C: 80C4001C  lwz r6, 0x1c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A08970: 38E1FFA8  addi r7, r1, -0x58
	ctx.r[7].s64 = ctx.r[1].s64 + -88;
	// 82A08974: 83E40010  lwz r31, 0x10(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08978: 3BC1FF90  addi r30, r1, -0x70
	ctx.r[30].s64 = ctx.r[1].s64 + -112;
	// 82A0897C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08980: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A08984: 83A301C0  lwz r29, 0x1c0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(448 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A08C58 size=456
    let mut pc: u32 = 0x82A08C58;
    'dispatch: loop {
        match pc {
            0x82A08C58 => {
    //   block [0x82A08C58..0x82A08CD8)
	// 82A08C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A08C5C: 482A07AD  bl 0x82ca9408
	ctx.lr = 0x82A08C60;
	sub_82CA93D0(ctx, base);
	// 82A08C60: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A08C64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A08C68: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A08C6C: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A08C70: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08C74: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08C78: 7D283850  subf r9, r8, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82A08C7C: 7D2B2E70  srawi r11, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 82A08C80: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A08C84: 41980148  blt cr6, 0x82a08dcc
	if ctx.cr[6].lt {
	pc = 0x82A08DCC; continue 'dispatch;
	}
	// 82A08C88: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A08C8C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A08C90: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08C94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A08C98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A08C9C: 7FA65850  subf r29, r6, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82A08CA0: 7D295030  slw r9, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 82A08CA4: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A08CA8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A08CAC: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 82A08CB0: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82A08CB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A08CB8: 40990020  ble cr6, 0x82a08cd8
	if !ctx.cr[6].gt {
	pc = 0x82A08CD8; continue 'dispatch;
	}
	// 82A08CBC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A08CC0: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82A08CC4: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A08CC8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A08CCC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A08CD0: 48000BE9  bl 0x82a098b8
	ctx.lr = 0x82A08CD4;
	sub_82A098B8(ctx, base);
	// 82A08CD4: 48000040  b 0x82a08d14
	pc = 0x82A08D14; continue 'dispatch;
            }
            0x82A08CD8 => {
    //   block [0x82A08CD8..0x82A08D14)
	// 82A08CD8: 4098003C  bge cr6, 0x82a08d14
	if !ctx.cr[6].lt {
	pc = 0x82A08D14; continue 'dispatch;
	}
	// 82A08CDC: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A08CE0: 554B2834  slwi r11, r10, 5
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A08CE4: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A08CE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A08CEC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A08CF0: 7D2B4214  add r9, r11, r8
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A08CF4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A08CF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A08CFC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A08D00: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A08D04: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A08D08: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A08D0C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A08D10: 48000719  bl 0x82a09428
	ctx.lr = 0x82A08D14;
	sub_82A09428(ctx, base);
	pc = 0x82A08D14; continue 'dispatch;
            }
            0x82A08D14 => {
    //   block [0x82A08D14..0x82A08D7C)
	// 82A08D14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08D18: 57AA2834  slwi r10, r29, 5
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A08D1C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A08D20: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A08D24: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A08D28: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08D2C: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A08D30: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A08D34: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A08D38: 55082834  slwi r8, r8, 5
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A08D3C: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82A08D40: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82A08D44: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A08D48: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A08D4C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A08D50: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A08D54: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A08D58: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A08D5C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A08D60: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A08D64: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A08D68: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A08D6C: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82A08D70: 419A003C  beq cr6, 0x82a08dac
	if ctx.cr[6].eq {
	pc = 0x82A08DAC; continue 'dispatch;
	}
	// 82A08D74: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A08D78: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A08D7C; continue 'dispatch;
            }
            0x82A08D7C => {
    //   block [0x82A08D7C..0x82A08DAC)
	// 82A08D7C: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A08D80: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A08D84: E8EB0008  ld r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82A08D88: F8EA0008  std r7, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 82A08D8C: E8CB0010  ld r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82A08D90: F8CA0010  std r6, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82A08D94: E8AB0018  ld r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82A08D98: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A08D9C: F8AA0018  std r5, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[5].u64 ) };
	// 82A08DA0: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82A08DA4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A08DA8: 409AFFD4  bne cr6, 0x82a08d7c
	if !ctx.cr[6].eq {
	pc = 0x82A08D7C; continue 'dispatch;
	}
	pc = 0x82A08DAC; continue 'dispatch;
            }
            0x82A08DAC => {
    //   block [0x82A08DAC..0x82A08DCC)
	// 82A08DAC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08DB0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A08DB4: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A08DB8: 7D285850  subf r9, r8, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82A08DBC: 7D272E70  srawi r7, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 82A08DC0: 7CDD3850  subf r6, r29, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[29].s64;
	// 82A08DC4: 7CC55038  and r5, r6, r10
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[10].u64;
	// 82A08DC8: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	pc = 0x82A08DCC; continue 'dispatch;
            }
            0x82A08DCC => {
    //   block [0x82A08DCC..0x82A08E20)
	// 82A08DCC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A08DD0: E95C0000  ld r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 82A08DD4: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A08DD8: 7D2B4214  add r9, r11, r8
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A08DDC: 7D4B412A  stdx r10, r11, r8
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u64) };
	// 82A08DE0: E91C0008  ld r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 82A08DE4: F9090008  std r8, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 82A08DE8: E8FC0010  ld r7, 0x10(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	// 82A08DEC: F8E90010  std r7, 0x10(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 82A08DF0: E8DC0018  ld r6, 0x18(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	// 82A08DF4: F8C90018  std r6, 0x18(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[6].u64 ) };
	// 82A08DF8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08DFC: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A08E00: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A08E04: 388A0001  addi r4, r10, 1
	ctx.r[4].s64 = ctx.r[10].s64 + 1;
	// 82A08E08: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82A08E0C: 7CAB2038  and r11, r5, r4
	ctx.r[11].u64 = ctx.r[5].u64 & ctx.r[4].u64;
	// 82A08E10: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82A08E14: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A08E18: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A08E1C: 482A063C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A08E20 size=400
    let mut pc: u32 = 0x82A08E20;
    'dispatch: loop {
        match pc {
            0x82A08E20 => {
    //   block [0x82A08E20..0x82A08F00)
	// 82A08E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A08E24: 482A05E5  bl 0x82ca9408
	ctx.lr = 0x82A08E28;
	sub_82CA93D0(ctx, base);
	// 82A08E28: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A08E2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A08E30: 3B800018  li r28, 0x18
	ctx.r[28].s64 = 24;
	// 82A08E34: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A08E38: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A08E3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08E40: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08E44: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A08E48: 7D27E3D6  divw r9, r7, r28
	ctx.r[9].s32 = ctx.r[7].s32 / ctx.r[28].s32;
	// 82A08E4C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A08E50: 41980104  blt cr6, 0x82a08f54
	if ctx.cr[6].lt {
	pc = 0x82A08F54; continue 'dispatch;
	}
	// 82A08E54: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A08E58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A08E5C: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08E60: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A08E64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A08E68: 7FC84850  subf r30, r8, r9
	ctx.r[30].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A08E6C: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82A08E70: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A08E74: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82A08E78: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A08E7C: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82A08E80: 480004C9  bl 0x82a09348
	ctx.lr = 0x82A08E84;
	sub_82A09348(ctx, base);
	// 82A08E84: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08E88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A08E8C: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A08E90: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A08E94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A08E98: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A08E9C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A08EA0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A08EA4: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A08EA8: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A08EAC: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82A08EB0: 7CAA4050  subf r5, r10, r8
	ctx.r[5].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82A08EB4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A08EB8: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A08EBC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08EC0: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82A08EC4: 5567083C  slwi r7, r11, 1
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A08EC8: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82A08ECC: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A08ED0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A08ED4: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82A08ED8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A08EDC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A08EE0: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A08EE4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A08EE8: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A08EEC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A08EF0: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A08EF4: 419A0040  beq cr6, 0x82a08f34
	if ctx.cr[6].eq {
	pc = 0x82A08F34; continue 'dispatch;
	}
	// 82A08EF8: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A08EFC: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A08F00; continue 'dispatch;
            }
            0x82A08F00 => {
    //   block [0x82A08F00..0x82A08F10)
	// 82A08F00: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A08F04: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 82A08F08: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A08F0C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A08F10; continue 'dispatch;
            }
            0x82A08F10 => {
    //   block [0x82A08F10..0x82A08F34)
	// 82A08F10: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08F14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A08F18: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A08F1C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A08F20: 4200FFF0  bdnz 0x82a08f10
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A08F10; continue 'dispatch;
	}
	// 82A08F24: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A08F28: 38C60018  addi r6, r6, 0x18
	ctx.r[6].s64 = ctx.r[6].s64 + 24;
	// 82A08F2C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A08F30: 409AFFD0  bne cr6, 0x82a08f00
	if !ctx.cr[6].eq {
	pc = 0x82A08F00; continue 'dispatch;
	}
	pc = 0x82A08F34; continue 'dispatch;
            }
            0x82A08F34 => {
    //   block [0x82A08F34..0x82A08F54)
	// 82A08F34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08F38: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A08F3C: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A08F40: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A08F44: 7CE8E3D6  divw r7, r8, r28
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[28].s32;
	// 82A08F48: 7CDE3850  subf r6, r30, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[30].s64;
	// 82A08F4C: 7CC54838  and r5, r6, r9
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[9].u64;
	// 82A08F50: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	pc = 0x82A08F54; continue 'dispatch;
            }
            0x82A08F54 => {
    //   block [0x82A08F54..0x82A08F74)
	// 82A08F54: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A08F58: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82A08F5C: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A08F60: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A08F64: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82A08F68: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A08F6C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A08F70: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A08F74; continue 'dispatch;
            }
            0x82A08F74 => {
    //   block [0x82A08F74..0x82A08FB0)
	// 82A08F74: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08F78: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A08F7C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A08F80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A08F84: 4200FFF0  bdnz 0x82a08f74
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A08F74; continue 'dispatch;
	}
	// 82A08F88: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A08F8C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08F90: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A08F94: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82A08F98: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82A08F9C: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A08FA0: 90FF0020  stw r7, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82A08FA4: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82A08FA8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A08FAC: 482A04AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A08FB0 size=468
    let mut pc: u32 = 0x82A08FB0;
    'dispatch: loop {
        match pc {
            0x82A08FB0 => {
    //   block [0x82A08FB0..0x82A09034)
	// 82A08FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A08FB4: 482A0451  bl 0x82ca9404
	ctx.lr = 0x82A08FB8;
	sub_82CA93D0(ctx, base);
	// 82A08FB8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A08FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A08FC0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A08FC4: 3B600060  li r27, 0x60
	ctx.r[27].s64 = 96;
	// 82A08FC8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A08FCC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08FD0: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A08FD4: 7D092050  subf r8, r9, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82A08FD8: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A08FDC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A08FE0: 41980148  blt cr6, 0x82a09128
	if ctx.cr[6].lt {
	pc = 0x82A09128; continue 'dispatch;
	}
	// 82A08FE4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A08FE8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A08FEC: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A08FF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A08FF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A08FF8: 7FA75850  subf r29, r7, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A08FFC: 7D085030  slw r8, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 82A09000: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A09004: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82A09008: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 82A0900C: 911F001C  stw r8, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 82A09010: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A09014: 40990020  ble cr6, 0x82a09034
	if !ctx.cr[6].gt {
	pc = 0x82A09034; continue 'dispatch;
	}
	// 82A09018: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A0901C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82A09020: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09024: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A09028: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0902C: 48000C65  bl 0x82a09c90
	ctx.lr = 0x82A09030;
	sub_82A09C90(ctx, base);
	// 82A09030: 4800002C  b 0x82a0905c
	pc = 0x82A0905C; continue 'dispatch;
            }
            0x82A09034 => {
    //   block [0x82A09034..0x82A0905C)
	// 82A09034: 40980028  bge cr6, 0x82a0905c
	if !ctx.cr[6].lt {
	pc = 0x82A0905C; continue 'dispatch;
	}
	// 82A09038: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0903C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A09040: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09044: 7CAB4A14  add r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A09048: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A0904C: 419A0010  beq cr6, 0x82a0905c
	if ctx.cr[6].eq {
	pc = 0x82A0905C; continue 'dispatch;
	}
	// 82A09050: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A09054: 48001385  bl 0x82a0a3d8
	ctx.lr = 0x82A09058;
	sub_82A0A3D8(ctx, base);
	// 82A09058: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x82A0905C; continue 'dispatch;
            }
            0x82A0905C => {
    //   block [0x82A0905C..0x82A090D4)
	// 82A0905C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09060: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A09064: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09068: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A0906C: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82A09070: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A09074: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A09078: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0907C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A09080: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82A09084: 5567083C  slwi r7, r11, 1
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A09088: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0908C: 7C8A4050  subf r4, r10, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82A09090: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A09094: 7CAB3A14  add r5, r11, r7
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A09098: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 82A0909C: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A090A0: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82A090A4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82A090A8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A090AC: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A090B0: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A090B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A090B8: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A090BC: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82A090C0: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A090C4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A090C8: 419A0040  beq cr6, 0x82a09108
	if ctx.cr[6].eq {
	pc = 0x82A09108; continue 'dispatch;
	}
	// 82A090CC: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A090D0: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A090D4; continue 'dispatch;
            }
            0x82A090D4 => {
    //   block [0x82A090D4..0x82A090E4)
	// 82A090D4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A090D8: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A090DC: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82A090E0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A090E4; continue 'dispatch;
            }
            0x82A090E4 => {
    //   block [0x82A090E4..0x82A09108)
	// 82A090E4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A090E8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A090EC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A090F0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A090F4: 4200FFF0  bdnz 0x82a090e4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A090E4; continue 'dispatch;
	}
	// 82A090F8: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 82A090FC: 38E70060  addi r7, r7, 0x60
	ctx.r[7].s64 = ctx.r[7].s64 + 96;
	// 82A09100: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A09104: 409AFFD0  bne cr6, 0x82a090d4
	if !ctx.cr[6].eq {
	pc = 0x82A090D4; continue 'dispatch;
	}
	pc = 0x82A09108; continue 'dispatch;
            }
            0x82A09108 => {
    //   block [0x82A09108..0x82A09128)
	// 82A09108: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0910C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09110: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A09114: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A09118: 7CE8DBD6  divw r7, r8, r27
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A0911C: 7CDD3850  subf r6, r29, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[29].s64;
	// 82A09120: 7CC55038  and r5, r6, r10
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[10].u64;
	// 82A09124: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	pc = 0x82A09128; continue 'dispatch;
            }
            0x82A09128 => {
    //   block [0x82A09128..0x82A09148)
	// 82A09128: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0912C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82A09130: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 82A09134: 5567083C  slwi r7, r11, 1
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A09138: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A0913C: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09140: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A09144: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A09148; continue 'dispatch;
            }
            0x82A09148 => {
    //   block [0x82A09148..0x82A09184)
	// 82A09148: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A0914C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09150: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A09154: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A09158: 4200FFF0  bdnz 0x82a09148
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09148; continue 'dispatch;
	}
	// 82A0915C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A09160: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A09164: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A09168: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82A0916C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82A09170: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A09174: 90FF0020  stw r7, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82A09178: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82A0917C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A09180: 482A02D4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A09188 size=448
    let mut pc: u32 = 0x82A09188;
    'dispatch: loop {
        match pc {
            0x82A09188 => {
    //   block [0x82A09188..0x82A0920C)
	// 82A09188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0918C: 482A0269  bl 0x82ca93f4
	ctx.lr = 0x82A09190;
	sub_82CA93D0(ctx, base);
	// 82A09190: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A09198: 3B00002C  li r24, 0x2c
	ctx.r[24].s64 = 44;
	// 82A0919C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82A091A0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A091A4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A091A8: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A091AC: 7D28F050  subf r9, r8, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[8].s64;
	// 82A091B0: 7D69C3D6  divw r11, r9, r24
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82A091B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A091B8: 41980150  blt cr6, 0x82a09308
	if ctx.cr[6].lt {
	pc = 0x82A09308; continue 'dispatch;
	}
	// 82A091BC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A091C0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A091C4: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A091C8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A091CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A091D0: 7F275850  subf r25, r7, r11
	ctx.r[25].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A091D4: 7D295030  slw r9, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 82A091D8: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A091DC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A091E0: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 82A091E4: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82A091E8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A091EC: 40990020  ble cr6, 0x82a0920c
	if !ctx.cr[6].gt {
	pc = 0x82A0920C; continue 'dispatch;
	}
	// 82A091F0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A091F4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A091F8: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A091FC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A09200: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A09204: 48000EA5  bl 0x82a0a0a8
	ctx.lr = 0x82A09208;
	sub_82A0A0A8(ctx, base);
	// 82A09208: 48000058  b 0x82a09260
	pc = 0x82A09260; continue 'dispatch;
            }
            0x82A0920C => {
    //   block [0x82A0920C..0x82A09240)
	// 82A0920C: 40980054  bge cr6, 0x82a09260
	if !ctx.cr[6].lt {
	pc = 0x82A09260; continue 'dispatch;
	}
	// 82A09210: 1D6A002C  mulli r11, r10, 0x2c
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A09214: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A09218: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0921C: 419A0044  beq cr6, 0x82a09260
	if ctx.cr[6].eq {
	pc = 0x82A09260; continue 'dispatch;
	}
	// 82A09220: 7D5EF050  subf r10, r30, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[30].s64;
	// 82A09224: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A09228: 7D2AC3D6  divw r9, r10, r24
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[24].s32;
	// 82A0922C: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A09230: 1D49002C  mulli r10, r9, 0x2c
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 44 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A09234: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A09238: 419A0024  beq cr6, 0x82a0925c
	if ctx.cr[6].eq {
	pc = 0x82A0925C; continue 'dispatch;
	}
	// 82A0923C: 7F9E5850  subf r28, r30, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	pc = 0x82A09240; continue 'dispatch;
            }
            0x82A09240 => {
    //   block [0x82A09240..0x82A0925C)
	// 82A09240: 7C7CEA14  add r3, r28, r29
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 82A09244: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A09248: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0924C: 482A0235  bl 0x82ca9480
	ctx.lr = 0x82A09250;
	sub_82CA9480(ctx, base);
	// 82A09250: 3BBD002C  addi r29, r29, 0x2c
	ctx.r[29].s64 = ctx.r[29].s64 + 44;
	// 82A09254: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A09258: 409AFFE8  bne cr6, 0x82a09240
	if !ctx.cr[6].eq {
	pc = 0x82A09240; continue 'dispatch;
	}
	pc = 0x82A0925C; continue 'dispatch;
            }
            0x82A0925C => {
    //   block [0x82A0925C..0x82A09260)
	// 82A0925C: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A09260; continue 'dispatch;
            }
            0x82A09260 => {
    //   block [0x82A09260..0x82A092C8)
	// 82A09260: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09264: 1D59002C  mulli r10, r25, 0x2c
	ctx.r[10].s32 = ((ctx.r[25].s32 as i64 * 44 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A09268: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0926C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A09270: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82A09274: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A09278: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A0927C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A09280: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A09284: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A09288: 7CCA4850  subf r6, r10, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A0928C: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A09290: 1D08002C  mulli r8, r8, 0x2c
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 44 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82A09294: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 82A09298: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82A0929C: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 82A092A0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A092A4: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A092A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A092AC: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A092B0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A092B4: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 82A092B8: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A092BC: 419A002C  beq cr6, 0x82a092e8
	if ctx.cr[6].eq {
	pc = 0x82A092E8; continue 'dispatch;
	}
	// 82A092C0: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A092C4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A092C8; continue 'dispatch;
            }
            0x82A092C8 => {
    //   block [0x82A092C8..0x82A092E8)
	// 82A092C8: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A092CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A092D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A092D4: 482A01AD  bl 0x82ca9480
	ctx.lr = 0x82A092D8;
	sub_82CA9480(ctx, base);
	// 82A092D8: 3BDE002C  addi r30, r30, 0x2c
	ctx.r[30].s64 = ctx.r[30].s64 + 44;
	// 82A092DC: 3B9C002C  addi r28, r28, 0x2c
	ctx.r[28].s64 = ctx.r[28].s64 + 44;
	// 82A092E0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A092E4: 409AFFE4  bne cr6, 0x82a092c8
	if !ctx.cr[6].eq {
	pc = 0x82A092C8; continue 'dispatch;
	}
	pc = 0x82A092E8; continue 'dispatch;
            }
            0x82A092E8 => {
    //   block [0x82A092E8..0x82A09308)
	// 82A092E8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A092EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A092F0: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A092F4: 7D285850  subf r9, r8, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82A092F8: 7CE9C3D6  divw r7, r9, r24
	ctx.r[7].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82A092FC: 7CD93850  subf r6, r25, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[25].s64;
	// 82A09300: 7CC55038  and r5, r6, r10
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[10].u64;
	// 82A09304: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	pc = 0x82A09308; continue 'dispatch;
            }
            0x82A09308 => {
    //   block [0x82A09308..0x82A09348)
	// 82A09308: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0930C: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A09310: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A09314: 1D6B002C  mulli r11, r11, 0x2c
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A09318: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A0931C: 482A0165  bl 0x82ca9480
	ctx.lr = 0x82A09320;
	sub_82CA9480(ctx, base);
	// 82A09320: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A09324: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A09328: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0932C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A09330: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82A09334: 7D474038  and r7, r10, r8
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[8].u64;
	// 82A09338: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82A0933C: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82A09340: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A09344: 482A0100  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A09348 size=220
    let mut pc: u32 = 0x82A09348;
    'dispatch: loop {
        match pc {
            0x82A09348 => {
    //   block [0x82A09348..0x82A0939C)
	// 82A09348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0934C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A09350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09354: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09358: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 82A0935C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09360: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82A09364: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A09368: 7D4A43D6  divw r10, r10, r8
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 82A0936C: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A09370: 4099002C  ble cr6, 0x82a0939c
	if !ctx.cr[6].gt {
	pc = 0x82A0939C; continue 'dispatch;
	}
	// 82A09374: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A09378: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0937C: 7CAA2050  subf r5, r10, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82A09380: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A09384: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A09388: 48000119  bl 0x82a094a0
	ctx.lr = 0x82A0938C;
	sub_82A094A0(ctx, base);
	// 82A0938C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A09390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A09394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A09398: 4E800020  blr
	return;
            }
            0x82A0939C => {
    //   block [0x82A0939C..0x82A093E0)
	// 82A0939C: 40980078  bge cr6, 0x82a09414
	if !ctx.cr[6].lt {
	pc = 0x82A09414; continue 'dispatch;
	}
	// 82A093A0: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A093A4: 7D445214  add r10, r4, r10
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 82A093A8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A093AC: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A093B0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A093B4: 419A0060  beq cr6, 0x82a09414
	if ctx.cr[6].eq {
	pc = 0x82A09414; continue 'dispatch;
	}
	// 82A093B8: 7D4B5850  subf r10, r11, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 82A093BC: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A093C0: 7D4A43D6  divw r10, r10, r8
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 82A093C4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A093C8: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A093CC: 7CEA3A14  add r7, r10, r7
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82A093D0: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A093D4: 7CAA4A14  add r5, r10, r9
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A093D8: 419A0038  beq cr6, 0x82a09410
	if ctx.cr[6].eq {
	pc = 0x82A09410; continue 'dispatch;
	}
	// 82A093DC: 7CCB4850  subf r6, r11, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x82A093E0; continue 'dispatch;
            }
            0x82A093E0 => {
    //   block [0x82A093E0..0x82A093F0)
	// 82A093E0: 7D264214  add r9, r6, r8
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82A093E4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A093E8: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 82A093EC: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A093F0; continue 'dispatch;
            }
            0x82A093F0 => {
    //   block [0x82A093F0..0x82A09410)
	// 82A093F0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A093F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A093F8: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A093FC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A09400: 4200FFF0  bdnz 0x82a093f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A093F0; continue 'dispatch;
	}
	// 82A09404: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A09408: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0940C: 409AFFD4  bne cr6, 0x82a093e0
	if !ctx.cr[6].eq {
	pc = 0x82A093E0; continue 'dispatch;
	}
	pc = 0x82A09410; continue 'dispatch;
            }
            0x82A09410 => {
    //   block [0x82A09410..0x82A09414)
	// 82A09410: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	pc = 0x82A09414; continue 'dispatch;
            }
            0x82A09414 => {
    //   block [0x82A09414..0x82A09424)
	// 82A09414: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A09418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0941C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A09420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A09428 size=116
    let mut pc: u32 = 0x82A09428;
    'dispatch: loop {
        match pc {
            0x82A09428 => {
    //   block [0x82A09428..0x82A09460)
	// 82A09428: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82A0942C: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82A09430: 81210024  lwz r9, 0x24(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A09434: 8161002C  lwz r11, 0x2c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A09438: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0943C: 419A0058  beq cr6, 0x82a09494
	if ctx.cr[6].eq {
	pc = 0x82A09494; continue 'dispatch;
	}
	// 82A09440: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09444: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09448: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0944C: 7D072E70  srawi r7, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 82A09450: 54E82834  slwi r8, r7, 5
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A09454: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A09458: 419A0038  beq cr6, 0x82a09490
	if ctx.cr[6].eq {
	pc = 0x82A09490; continue 'dispatch;
	}
	// 82A0945C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x82A09460; continue 'dispatch;
            }
            0x82A09460 => {
    //   block [0x82A09460..0x82A09490)
	// 82A09460: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09464: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A09468: 7CE9592A  stdx r7, r9, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u64) };
	// 82A0946C: E8EB0008  ld r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82A09470: F8E60008  std r7, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 82A09474: E8EB0010  ld r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82A09478: F8E60010  std r7, 0x10(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 82A0947C: E8EB0018  ld r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82A09480: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A09484: F8E60018  std r7, 0x18(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[7].u64 ) };
	// 82A09488: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0948C: 409AFFD4  bne cr6, 0x82a09460
	if !ctx.cr[6].eq {
	pc = 0x82A09460; continue 'dispatch;
	}
	pc = 0x82A09490; continue 'dispatch;
            }
            0x82A09490 => {
    //   block [0x82A09490..0x82A09494)
	// 82A09490: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82A09494; continue 'dispatch;
            }
            0x82A09494 => {
    //   block [0x82A09494..0x82A0949C)
	// 82A09494: F8A30000  std r5, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A09498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A094A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A094A0 size=1044
    let mut pc: u32 = 0x82A094A0;
    'dispatch: loop {
        match pc {
            0x82A094A0 => {
    //   block [0x82A094A0..0x82A094C8)
	// 82A094A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A094A4: 4829FF61  bl 0x82ca9404
	ctx.lr = 0x82A094A8;
	sub_82CA93D0(ctx, base);
	// 82A094A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A094AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A094B0: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A094B4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A094B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A094BC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A094C0: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A094C4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A094C8; continue 'dispatch;
            }
            0x82A094C8 => {
    //   block [0x82A094C8..0x82A094F4)
	// 82A094C8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A094CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A094D0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A094D4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A094D8: 4200FFF0  bdnz 0x82a094c8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A094C8; continue 'dispatch;
	}
	// 82A094DC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A094E0: 3B600018  li r27, 0x18
	ctx.r[27].s64 = 24;
	// 82A094E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A094E8: 409A000C  bne cr6, 0x82a094f4
	if !ctx.cr[6].eq {
	pc = 0x82A094F4; continue 'dispatch;
	}
	// 82A094EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A094F0: 48000010  b 0x82a09500
	pc = 0x82A09500; continue 'dispatch;
            }
            0x82A094F4 => {
    //   block [0x82A094F4..0x82A09500)
	// 82A094F4: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A094F8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A094FC: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A09500; continue 'dispatch;
            }
            0x82A09500 => {
    //   block [0x82A09500..0x82A09534)
	// 82A09500: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A09504: 419A03A8  beq cr6, 0x82a098ac
	if ctx.cr[6].eq {
	pc = 0x82A098AC; continue 'dispatch;
	}
	// 82A09508: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0950C: 3D400AAA  lis r10, 0xaaa
	ctx.r[10].s64 = 178913280;
	// 82A09510: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A09514: 614AAAAA  ori r10, r10, 0xaaaa
	ctx.r[10].u64 = ctx.r[10].u64 | 43690;
	// 82A09518: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A0951C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09520: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A09524: 40980010  bge cr6, 0x82a09534
	if !ctx.cr[6].lt {
	pc = 0x82A09534; continue 'dispatch;
	}
	// 82A09528: 4803DFA1  bl 0x82a474c8
	ctx.lr = 0x82A0952C;
	sub_82A474C8(ctx, base);
	// 82A0952C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A09530: 4829FF24  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A09534 => {
    //   block [0x82A09534..0x82A09558)
	// 82A09534: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A09538: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0953C: 40980188  bge cr6, 0x82a096c4
	if !ctx.cr[6].lt {
	pc = 0x82A096C4; continue 'dispatch;
	}
	// 82A09540: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09544: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A09548: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0954C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A09550: 41980008  blt cr6, 0x82a09558
	if ctx.cr[6].lt {
	pc = 0x82A09558; continue 'dispatch;
	}
	// 82A09554: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A09558; continue 'dispatch;
            }
            0x82A09558 => {
    //   block [0x82A09558..0x82A09564)
	// 82A09558: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0955C: 40980008  bge cr6, 0x82a09564
	if !ctx.cr[6].lt {
	pc = 0x82A09564; continue 'dispatch;
	}
	// 82A09560: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x82A09564; continue 'dispatch;
            }
            0x82A09564 => {
    //   block [0x82A09564..0x82A09588)
	// 82A09564: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A09568: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0956C: 4807AB8D  bl 0x82a840f8
	ctx.lr = 0x82A09570;
	sub_82A840F8(ctx, base);
	// 82A09570: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09574: 80A100BC  lwz r5, 0xbc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A09578: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0957C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A09580: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A09584: 419A0040  beq cr6, 0x82a095c4
	if ctx.cr[6].eq {
	pc = 0x82A095C4; continue 'dispatch;
	}
	pc = 0x82A09588; continue 'dispatch;
            }
            0x82A09588 => {
    //   block [0x82A09588..0x82A095A0)
	// 82A09588: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A0958C: 419A0028  beq cr6, 0x82a095b4
	if ctx.cr[6].eq {
	pc = 0x82A095B4; continue 'dispatch;
	}
	// 82A09590: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A09594: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A09598: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A0959C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A095A0; continue 'dispatch;
            }
            0x82A095A0 => {
    //   block [0x82A095A0..0x82A095B4)
	// 82A095A0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A095A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A095A8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A095AC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A095B0: 4200FFF0  bdnz 0x82a095a0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A095A0; continue 'dispatch;
	}
	pc = 0x82A095B4; continue 'dispatch;
            }
            0x82A095B4 => {
    //   block [0x82A095B4..0x82A095C4)
	// 82A095B4: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A095B8: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 82A095BC: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A095C0: 409AFFC8  bne cr6, 0x82a09588
	if !ctx.cr[6].eq {
	pc = 0x82A09588; continue 'dispatch;
	}
	pc = 0x82A095C4; continue 'dispatch;
            }
            0x82A095C4 => {
    //   block [0x82A095C4..0x82A095D4)
	// 82A095C4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A095C8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82A095CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A095D0: 419A003C  beq cr6, 0x82a0960c
	if ctx.cr[6].eq {
	pc = 0x82A0960C; continue 'dispatch;
	}
	pc = 0x82A095D4; continue 'dispatch;
            }
            0x82A095D4 => {
    //   block [0x82A095D4..0x82A095EC)
	// 82A095D4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A095D8: 419A0028  beq cr6, 0x82a09600
	if ctx.cr[6].eq {
	pc = 0x82A09600; continue 'dispatch;
	}
	// 82A095DC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A095E0: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A095E4: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A095E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A095EC; continue 'dispatch;
            }
            0x82A095EC => {
    //   block [0x82A095EC..0x82A09600)
	// 82A095EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A095F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A095F4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A095F8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A095FC: 4200FFF0  bdnz 0x82a095ec
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A095EC; continue 'dispatch;
	}
	pc = 0x82A09600; continue 'dispatch;
            }
            0x82A09600 => {
    //   block [0x82A09600..0x82A0960C)
	// 82A09600: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A09604: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A09608: 4082FFCC  bne 0x82a095d4
	if !ctx.cr[0].eq {
	pc = 0x82A095D4; continue 'dispatch;
	}
	pc = 0x82A0960C; continue 'dispatch;
            }
            0x82A0960C => {
    //   block [0x82A0960C..0x82A09634)
	// 82A0960C: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09610: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09614: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A09618: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A0961C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09620: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A09624: 419A004C  beq cr6, 0x82a09670
	if ctx.cr[6].eq {
	pc = 0x82A09670; continue 'dispatch;
	}
	// 82A09628: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A0962C: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A09630: 7D0B2A14  add r8, r11, r5
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	pc = 0x82A09634; continue 'dispatch;
            }
            0x82A09634 => {
    //   block [0x82A09634..0x82A0964C)
	// 82A09634: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A09638: 419A0028  beq cr6, 0x82a09660
	if ctx.cr[6].eq {
	pc = 0x82A09660; continue 'dispatch;
	}
	// 82A0963C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A09640: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A09644: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 82A09648: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A0964C; continue 'dispatch;
            }
            0x82A0964C => {
    //   block [0x82A0964C..0x82A09660)
	// 82A0964C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09650: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A09654: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A09658: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A0965C: 4200FFF0  bdnz 0x82a0964c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0964C; continue 'dispatch;
	}
	pc = 0x82A09660; continue 'dispatch;
            }
            0x82A09660 => {
    //   block [0x82A09660..0x82A09670)
	// 82A09660: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A09664: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A09668: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A0966C: 409AFFC8  bne cr6, 0x82a09634
	if !ctx.cr[6].eq {
	pc = 0x82A09634; continue 'dispatch;
	}
	pc = 0x82A09670; continue 'dispatch;
            }
            0x82A09670 => {
    //   block [0x82A09670..0x82A09690)
	// 82A09670: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09674: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0967C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A09680: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A09684: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A09688: 419A0008  beq cr6, 0x82a09690
	if ctx.cr[6].eq {
	pc = 0x82A09690; continue 'dispatch;
	}
	// 82A0968C: 4B8126AD  bl 0x8221bd38
	ctx.lr = 0x82A09690;
	sub_8221BD38(ctx, base);
	pc = 0x82A09690; continue 'dispatch;
            }
            0x82A09690 => {
    //   block [0x82A09690..0x82A096C4)
	// 82A09690: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09694: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A09698: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0969C: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A096A0: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82A096A4: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A096A8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A096AC: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A096B0: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A096B4: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A096B8: 911C000C  stw r8, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A096BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A096C0: 4829FD94  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A096C4 => {
    //   block [0x82A096C4..0x82A096F4)
	// 82A096C4: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A096C8: 7D632850  subf r11, r3, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	// 82A096CC: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A096D0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A096D4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A096D8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A096DC: 409800F8  bge cr6, 0x82a097d4
	if !ctx.cr[6].lt {
	pc = 0x82A097D4; continue 'dispatch;
	}
	// 82A096E0: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A096E4: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A096E8: 7D261A14  add r9, r6, r3
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A096EC: 419A0044  beq cr6, 0x82a09730
	if ctx.cr[6].eq {
	pc = 0x82A09730; continue 'dispatch;
	}
	// 82A096F0: 7CE64850  subf r7, r6, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	pc = 0x82A096F4; continue 'dispatch;
            }
            0x82A096F4 => {
    //   block [0x82A096F4..0x82A0970C)
	// 82A096F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A096F8: 419A0028  beq cr6, 0x82a09720
	if ctx.cr[6].eq {
	pc = 0x82A09720; continue 'dispatch;
	}
	// 82A096FC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A09700: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A09704: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A09708: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A0970C; continue 'dispatch;
            }
            0x82A0970C => {
    //   block [0x82A0970C..0x82A09720)
	// 82A0970C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09710: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A09714: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A09718: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A0971C: 4200FFF0  bdnz 0x82a0970c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0970C; continue 'dispatch;
	}
	pc = 0x82A09720; continue 'dispatch;
            }
            0x82A09720 => {
    //   block [0x82A09720..0x82A09730)
	// 82A09720: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 82A09724: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A09728: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A0972C: 409AFFC8  bne cr6, 0x82a096f4
	if !ctx.cr[6].eq {
	pc = 0x82A096F4; continue 'dispatch;
	}
	pc = 0x82A09730; continue 'dispatch;
            }
            0x82A09730 => {
    //   block [0x82A09730..0x82A09748)
	// 82A09730: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09734: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A09738: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A0973C: 7D2ADBD6  divw r9, r10, r27
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A09740: 7CE9F851  subf. r7, r9, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A09744: 4182003C  beq 0x82a09780
	if ctx.cr[0].eq {
	pc = 0x82A09780; continue 'dispatch;
	}
	pc = 0x82A09748; continue 'dispatch;
            }
            0x82A09748 => {
    //   block [0x82A09748..0x82A09760)
	// 82A09748: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A0974C: 419A0028  beq cr6, 0x82a09774
	if ctx.cr[6].eq {
	pc = 0x82A09774; continue 'dispatch;
	}
	// 82A09750: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A09754: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A09758: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A0975C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A09760; continue 'dispatch;
            }
            0x82A09760 => {
    //   block [0x82A09760..0x82A09774)
	// 82A09760: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09764: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A09768: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0976C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A09770: 4200FFF0  bdnz 0x82a09760
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09760; continue 'dispatch;
	}
	pc = 0x82A09774; continue 'dispatch;
            }
            0x82A09774 => {
    //   block [0x82A09774..0x82A09780)
	// 82A09774: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A09778: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A0977C: 4082FFCC  bne 0x82a09748
	if !ctx.cr[0].eq {
	pc = 0x82A09748; continue 'dispatch;
	}
	pc = 0x82A09780; continue 'dispatch;
            }
            0x82A09780 => {
    //   block [0x82A09780..0x82A0979C)
	// 82A09780: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09784: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A09788: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A0978C: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82A09790: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A09794: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A09798: 419A0114  beq cr6, 0x82a098ac
	if ctx.cr[6].eq {
	pc = 0x82A098AC; continue 'dispatch;
	}
	pc = 0x82A0979C; continue 'dispatch;
            }
            0x82A0979C => {
    //   block [0x82A0979C..0x82A097AC)
	// 82A0979C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A097A0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A097A4: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A097A8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A097AC; continue 'dispatch;
            }
            0x82A097AC => {
    //   block [0x82A097AC..0x82A097D4)
	// 82A097AC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A097B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A097B4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A097B8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A097BC: 4200FFF0  bdnz 0x82a097ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A097AC; continue 'dispatch;
	}
	// 82A097C0: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A097C4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A097C8: 409AFFD4  bne cr6, 0x82a0979c
	if !ctx.cr[6].eq {
	pc = 0x82A0979C; continue 'dispatch;
	}
	// 82A097CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A097D0: 4829FC84  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A097D4 => {
    //   block [0x82A097D4..0x82A097EC)
	// 82A097D4: 55641838  slwi r4, r11, 3
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A097D8: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82A097DC: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82A097E0: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82A097E4: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A097E8: 419A0040  beq cr6, 0x82a09828
	if ctx.cr[6].eq {
	pc = 0x82A09828; continue 'dispatch;
	}
	pc = 0x82A097EC; continue 'dispatch;
            }
            0x82A097EC => {
    //   block [0x82A097EC..0x82A09804)
	// 82A097EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A097F0: 419A0028  beq cr6, 0x82a09818
	if ctx.cr[6].eq {
	pc = 0x82A09818; continue 'dispatch;
	}
	// 82A097F4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A097F8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A097FC: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82A09800: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x82A09804; continue 'dispatch;
            }
            0x82A09804 => {
    //   block [0x82A09804..0x82A09818)
	// 82A09804: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09808: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A0980C: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82A09810: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A09814: 4200FFF0  bdnz 0x82a09804
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09804; continue 'dispatch;
	}
	pc = 0x82A09818; continue 'dispatch;
            }
            0x82A09818 => {
    //   block [0x82A09818..0x82A09828)
	// 82A09818: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 82A0981C: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A09820: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A09824: 409AFFC8  bne cr6, 0x82a097ec
	if !ctx.cr[6].eq {
	pc = 0x82A097EC; continue 'dispatch;
	}
	pc = 0x82A09828; continue 'dispatch;
            }
            0x82A09828 => {
    //   block [0x82A09828..0x82A09838)
	// 82A09828: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A0982C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A09830: 419A003C  beq cr6, 0x82a0986c
	if ctx.cr[6].eq {
	pc = 0x82A0986C; continue 'dispatch;
	}
	// 82A09834: 7D045A14  add r8, r4, r11
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	pc = 0x82A09838; continue 'dispatch;
            }
            0x82A09838 => {
    //   block [0x82A09838..0x82A09850)
	// 82A09838: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 82A0983C: 3908FFE8  addi r8, r8, -0x18
	ctx.r[8].s64 = ctx.r[8].s64 + -24;
	// 82A09840: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A09844: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A09848: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 82A0984C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A09850; continue 'dispatch;
            }
            0x82A09850 => {
    //   block [0x82A09850..0x82A0986C)
	// 82A09850: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09854: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A09858: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A0985C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A09860: 4200FFF0  bdnz 0x82a09850
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09850; continue 'dispatch;
	}
	// 82A09864: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A09868: 409AFFD0  bne cr6, 0x82a09838
	if !ctx.cr[6].eq {
	pc = 0x82A09838; continue 'dispatch;
	}
	pc = 0x82A0986C; continue 'dispatch;
            }
            0x82A0986C => {
    //   block [0x82A0986C..0x82A0987C)
	// 82A0986C: 7CE41A14  add r7, r4, r3
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 82A09870: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A09874: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A09878: 419A0034  beq cr6, 0x82a098ac
	if ctx.cr[6].eq {
	pc = 0x82A098AC; continue 'dispatch;
	}
	pc = 0x82A0987C; continue 'dispatch;
            }
            0x82A0987C => {
    //   block [0x82A0987C..0x82A0988C)
	// 82A0987C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A09880: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A09884: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A09888: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A0988C; continue 'dispatch;
            }
            0x82A0988C => {
    //   block [0x82A0988C..0x82A098AC)
	// 82A0988C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09890: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A09894: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A09898: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A0989C: 4200FFF0  bdnz 0x82a0988c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0988C; continue 'dispatch;
	}
	// 82A098A0: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A098A4: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A098A8: 409AFFD4  bne cr6, 0x82a0987c
	if !ctx.cr[6].eq {
	pc = 0x82A0987C; continue 'dispatch;
	}
	pc = 0x82A098AC; continue 'dispatch;
            }
            0x82A098AC => {
    //   block [0x82A098AC..0x82A098B4)
	// 82A098AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A098B0: 4829FBA4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A098B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A098B8 size=984
    let mut pc: u32 = 0x82A098B8;
    'dispatch: loop {
        match pc {
            0x82A098B8 => {
    //   block [0x82A098B8..0x82A09908)
	// 82A098B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A098BC: 4829FB4D  bl 0x82ca9408
	ctx.lr = 0x82A098C0;
	sub_82CA93D0(ctx, base);
	// 82A098C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A098C4: E9460000  ld r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 82A098C8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A098CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A098D0: E9060008  ld r8, 8(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 82A098D4: E8E60010  ld r7, 0x10(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82A098D8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A098DC: E8C60018  ld r6, 0x18(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) };
	// 82A098E0: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A098E4: F9490000  std r10, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82A098E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A098EC: F9090008  std r8, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 82A098F0: F8E90010  std r7, 0x10(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 82A098F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A098F8: F8C90018  std r6, 0x18(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[6].u64 ) };
	// 82A098FC: 409A000C  bne cr6, 0x82a09908
	if !ctx.cr[6].eq {
	pc = 0x82A09908; continue 'dispatch;
	}
	// 82A09900: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A09904: 48000010  b 0x82a09914
	pc = 0x82A09914; continue 'dispatch;
            }
            0x82A09908 => {
    //   block [0x82A09908..0x82A09914)
	// 82A09908: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0990C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09910: 7D292E70  srawi r9, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x82A09914; continue 'dispatch;
            }
            0x82A09914 => {
    //   block [0x82A09914..0x82A09948)
	// 82A09914: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A09918: 419A0370  beq cr6, 0x82a09c88
	if ctx.cr[6].eq {
	pc = 0x82A09C88; continue 'dispatch;
	}
	// 82A0991C: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09920: 3D4007FF  lis r10, 0x7ff
	ctx.r[10].s64 = 134152192;
	// 82A09924: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A09928: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82A0992C: 7CEB2E70  srawi r11, r7, 5
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 5) as i64;
	// 82A09930: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09934: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A09938: 40980010  bge cr6, 0x82a09948
	if !ctx.cr[6].lt {
	pc = 0x82A09948; continue 'dispatch;
	}
	// 82A0993C: 4803DB8D  bl 0x82a474c8
	ctx.lr = 0x82A09940;
	sub_82A474C8(ctx, base);
	// 82A09940: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A09944: 4829FB14  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A09948 => {
    //   block [0x82A09948..0x82A0996C)
	// 82A09948: 7CEBFA14  add r7, r11, r31
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A0994C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A09950: 40980168  bge cr6, 0x82a09ab8
	if !ctx.cr[6].lt {
	pc = 0x82A09AB8; continue 'dispatch;
	}
	// 82A09954: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09958: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A0995C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09960: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A09964: 41980008  blt cr6, 0x82a0996c
	if ctx.cr[6].lt {
	pc = 0x82A0996C; continue 'dispatch;
	}
	// 82A09968: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A0996C; continue 'dispatch;
            }
            0x82A0996C => {
    //   block [0x82A0996C..0x82A09978)
	// 82A0996C: 7F1C3840  cmplw cr6, r28, r7
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A09970: 40980008  bge cr6, 0x82a09978
	if !ctx.cr[6].lt {
	pc = 0x82A09978; continue 'dispatch;
	}
	// 82A09974: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	pc = 0x82A09978; continue 'dispatch;
            }
            0x82A09978 => {
    //   block [0x82A09978..0x82A0999C)
	// 82A09978: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0997C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A09980: 48007C51  bl 0x82a115d0
	ctx.lr = 0x82A09984;
	sub_82A115D0(ctx, base);
	// 82A09984: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09988: 80E100BC  lwz r7, 0xbc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A0998C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A09990: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A09994: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A09998: 419A003C  beq cr6, 0x82a099d4
	if ctx.cr[6].eq {
	pc = 0x82A099D4; continue 'dispatch;
	}
	pc = 0x82A0999C; continue 'dispatch;
            }
            0x82A0999C => {
    //   block [0x82A0999C..0x82A099C4)
	// 82A0999C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A099A0: 419A0024  beq cr6, 0x82a099c4
	if ctx.cr[6].eq {
	pc = 0x82A099C4; continue 'dispatch;
	}
	// 82A099A4: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A099A8: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A099AC: E90A0008  ld r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82A099B0: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 82A099B4: E8CA0010  ld r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	// 82A099B8: F8CB0010  std r6, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82A099BC: E8AA0018  ld r5, 0x18(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	// 82A099C0: F8AB0018  std r5, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[5].u64 ) };
	pc = 0x82A099C4; continue 'dispatch;
            }
            0x82A099C4 => {
    //   block [0x82A099C4..0x82A099D4)
	// 82A099C4: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82A099C8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A099CC: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A099D0: 409AFFCC  bne cr6, 0x82a0999c
	if !ctx.cr[6].eq {
	pc = 0x82A0999C; continue 'dispatch;
	}
	pc = 0x82A099D4; continue 'dispatch;
            }
            0x82A099D4 => {
    //   block [0x82A099D4..0x82A099E4)
	// 82A099D4: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82A099D8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A099DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A099E0: 419A003C  beq cr6, 0x82a09a1c
	if ctx.cr[6].eq {
	pc = 0x82A09A1C; continue 'dispatch;
	}
	pc = 0x82A099E4; continue 'dispatch;
            }
            0x82A099E4 => {
    //   block [0x82A099E4..0x82A09A10)
	// 82A099E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A099E8: 419A0028  beq cr6, 0x82a09a10
	if ctx.cr[6].eq {
	pc = 0x82A09A10; continue 'dispatch;
	}
	// 82A099EC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82A099F0: E8C80000  ld r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 82A099F4: E8A80008  ld r5, 8(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 82A099F8: E8880010  ld r4, 0x10(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 82A099FC: E8680018  ld r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) };
	// 82A09A00: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82A09A04: F8AA0008  std r5, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 82A09A08: F88A0010  std r4, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[4].u64 ) };
	// 82A09A0C: F86A0018  std r3, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[3].u64 ) };
	pc = 0x82A09A10; continue 'dispatch;
            }
            0x82A09A10 => {
    //   block [0x82A09A10..0x82A09A1C)
	// 82A09A10: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A09A14: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82A09A18: 4082FFCC  bne 0x82a099e4
	if !ctx.cr[0].eq {
	pc = 0x82A099E4; continue 'dispatch;
	}
	pc = 0x82A09A1C; continue 'dispatch;
            }
            0x82A09A1C => {
    //   block [0x82A09A1C..0x82A09A3C)
	// 82A09A1C: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09A20: 57E92834  slwi r9, r31, 5
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A09A24: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A09A28: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A09A2C: 419A0048  beq cr6, 0x82a09a74
	if ctx.cr[6].eq {
	pc = 0x82A09A74; continue 'dispatch;
	}
	// 82A09A30: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A09A34: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A09A38: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	pc = 0x82A09A3C; continue 'dispatch;
            }
            0x82A09A3C => {
    //   block [0x82A09A3C..0x82A09A64)
	// 82A09A3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A09A40: 419A0024  beq cr6, 0x82a09a64
	if ctx.cr[6].eq {
	pc = 0x82A09A64; continue 'dispatch;
	}
	// 82A09A44: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09A48: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A09A4C: E8EB0008  ld r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82A09A50: F8EA0008  std r7, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 82A09A54: E8CB0010  ld r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82A09A58: F8CA0010  std r6, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82A09A5C: E8AB0018  ld r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82A09A60: F8AA0018  std r5, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[5].u64 ) };
	pc = 0x82A09A64; continue 'dispatch;
            }
            0x82A09A64 => {
    //   block [0x82A09A64..0x82A09A74)
	// 82A09A64: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A09A68: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82A09A6C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A09A70: 409AFFCC  bne cr6, 0x82a09a3c
	if !ctx.cr[6].eq {
	pc = 0x82A09A3C; continue 'dispatch;
	}
	pc = 0x82A09A74; continue 'dispatch;
            }
            0x82A09A74 => {
    //   block [0x82A09A74..0x82A09A94)
	// 82A09A74: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09A78: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09A7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A09A80: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A09A84: 7D4B2E70  srawi r11, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82A09A88: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A09A8C: 419A0008  beq cr6, 0x82a09a94
	if ctx.cr[6].eq {
	pc = 0x82A09A94; continue 'dispatch;
	}
	// 82A09A90: 4B8122A9  bl 0x8221bd38
	ctx.lr = 0x82A09A94;
	sub_8221BD38(ctx, base);
	pc = 0x82A09A94; continue 'dispatch;
            }
            0x82A09A94 => {
    //   block [0x82A09A94..0x82A09AB8)
	// 82A09A94: 578B2834  slwi r11, r28, 5
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09A98: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A09A9C: 57EA2834  slwi r10, r31, 5
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A09AA0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A09AA4: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82A09AA8: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A09AAC: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A09AB0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A09AB4: 4829F9A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A09AB8 => {
    //   block [0x82A09AB8..0x82A09AE0)
	// 82A09AB8: 80E100BC  lwz r7, 0xbc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A09ABC: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82A09AC0: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82A09AC4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A09AC8: 409800F0  bge cr6, 0x82a09bb8
	if !ctx.cr[6].lt {
	pc = 0x82A09BB8; continue 'dispatch;
	}
	// 82A09ACC: 57E92834  slwi r9, r31, 5
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A09AD0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A09AD4: 7D693A14  add r11, r9, r7
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 82A09AD8: 419A0040  beq cr6, 0x82a09b18
	if ctx.cr[6].eq {
	pc = 0x82A09B18; continue 'dispatch;
	}
	// 82A09ADC: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x82A09AE0; continue 'dispatch;
            }
            0x82A09AE0 => {
    //   block [0x82A09AE0..0x82A09B08)
	// 82A09AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A09AE4: 419A0024  beq cr6, 0x82a09b08
	if ctx.cr[6].eq {
	pc = 0x82A09B08; continue 'dispatch;
	}
	// 82A09AE8: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A09AEC: F8CB0000  std r6, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82A09AF0: E8AA0008  ld r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82A09AF4: F8AB0008  std r5, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 82A09AF8: E88A0010  ld r4, 0x10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	// 82A09AFC: F88B0010  std r4, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[4].u64 ) };
	// 82A09B00: E86A0018  ld r3, 0x18(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	// 82A09B04: F86B0018  std r3, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[3].u64 ) };
	pc = 0x82A09B08; continue 'dispatch;
            }
            0x82A09B08 => {
    //   block [0x82A09B08..0x82A09B18)
	// 82A09B08: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82A09B0C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A09B10: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A09B14: 409AFFCC  bne cr6, 0x82a09ae0
	if !ctx.cr[6].eq {
	pc = 0x82A09AE0; continue 'dispatch;
	}
	pc = 0x82A09B18; continue 'dispatch;
            }
            0x82A09B18 => {
    //   block [0x82A09B18..0x82A09B2C)
	// 82A09B18: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09B1C: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A09B20: 7D482E70  srawi r8, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82A09B24: 7D48F851  subf. r10, r8, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A09B28: 4182003C  beq 0x82a09b64
	if ctx.cr[0].eq {
	pc = 0x82A09B64; continue 'dispatch;
	}
	pc = 0x82A09B2C; continue 'dispatch;
            }
            0x82A09B2C => {
    //   block [0x82A09B2C..0x82A09B58)
	// 82A09B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A09B30: 419A0028  beq cr6, 0x82a09b58
	if ctx.cr[6].eq {
	pc = 0x82A09B58; continue 'dispatch;
	}
	// 82A09B34: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82A09B38: E8C80000  ld r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 82A09B3C: E8A80008  ld r5, 8(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 82A09B40: E8880010  ld r4, 0x10(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 82A09B44: E8680018  ld r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) };
	// 82A09B48: F8CB0000  std r6, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82A09B4C: F8AB0008  std r5, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 82A09B50: F88B0010  std r4, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[4].u64 ) };
	// 82A09B54: F86B0018  std r3, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[3].u64 ) };
	pc = 0x82A09B58; continue 'dispatch;
            }
            0x82A09B58 => {
    //   block [0x82A09B58..0x82A09B64)
	// 82A09B58: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A09B5C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A09B60: 4082FFCC  bne 0x82a09b2c
	if !ctx.cr[0].eq {
	pc = 0x82A09B2C; continue 'dispatch;
	}
	pc = 0x82A09B64; continue 'dispatch;
            }
            0x82A09B64 => {
    //   block [0x82A09B64..0x82A09B80)
	// 82A09B64: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09B68: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A09B6C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A09B70: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A09B74: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A09B78: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A09B7C: 419A010C  beq cr6, 0x82a09c88
	if ctx.cr[6].eq {
	pc = 0x82A09C88; continue 'dispatch;
	}
	pc = 0x82A09B80; continue 'dispatch;
            }
            0x82A09B80 => {
    //   block [0x82A09B80..0x82A09BB8)
	// 82A09B80: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A09B84: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A09B88: E8EA0008  ld r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82A09B8C: E8CA0010  ld r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	// 82A09B90: E8AA0018  ld r5, 0x18(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	// 82A09B94: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A09B98: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 82A09B9C: F8CB0010  std r6, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82A09BA0: F8AB0018  std r5, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[5].u64 ) };
	// 82A09BA4: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A09BA8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A09BAC: 409AFFD4  bne cr6, 0x82a09b80
	if !ctx.cr[6].eq {
	pc = 0x82A09B80; continue 'dispatch;
	}
	// 82A09BB0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A09BB4: 4829F8A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A09BB8 => {
    //   block [0x82A09BB8..0x82A09BD0)
	// 82A09BB8: 57E62834  slwi r6, r31, 5
	ctx.r[6].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A09BBC: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A09BC0: 7D664050  subf r11, r6, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 82A09BC4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A09BC8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A09BCC: 419A003C  beq cr6, 0x82a09c08
	if ctx.cr[6].eq {
	pc = 0x82A09C08; continue 'dispatch;
	}
	pc = 0x82A09BD0; continue 'dispatch;
            }
            0x82A09BD0 => {
    //   block [0x82A09BD0..0x82A09BF8)
	// 82A09BD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A09BD4: 419A0024  beq cr6, 0x82a09bf8
	if ctx.cr[6].eq {
	pc = 0x82A09BF8; continue 'dispatch;
	}
	// 82A09BD8: E8A90000  ld r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82A09BDC: F8AA0000  std r5, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A09BE0: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 82A09BE4: F88A0008  std r4, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u64 ) };
	// 82A09BE8: E8690010  ld r3, 0x10(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	// 82A09BEC: F86A0010  std r3, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 82A09BF0: E8A90018  ld r5, 0x18(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	// 82A09BF4: F8AA0018  std r5, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[5].u64 ) };
	pc = 0x82A09BF8; continue 'dispatch;
            }
            0x82A09BF8 => {
    //   block [0x82A09BF8..0x82A09C08)
	// 82A09BF8: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 82A09BFC: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82A09C00: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A09C04: 409AFFCC  bne cr6, 0x82a09bd0
	if !ctx.cr[6].eq {
	pc = 0x82A09BD0; continue 'dispatch;
	}
	pc = 0x82A09C08; continue 'dispatch;
            }
            0x82A09C08 => {
    //   block [0x82A09C08..0x82A09C18)
	// 82A09C08: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A09C0C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A09C10: 419A0038  beq cr6, 0x82a09c48
	if ctx.cr[6].eq {
	pc = 0x82A09C48; continue 'dispatch;
	}
	// 82A09C14: 7D465A14  add r10, r6, r11
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	pc = 0x82A09C18; continue 'dispatch;
            }
            0x82A09C18 => {
    //   block [0x82A09C18..0x82A09C48)
	// 82A09C18: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 82A09C1C: 394AFFE0  addi r10, r10, -0x20
	ctx.r[10].s64 = ctx.r[10].s64 + -32;
	// 82A09C20: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A09C24: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09C28: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A09C2C: E90B0008  ld r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82A09C30: F90A0008  std r8, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 82A09C34: E8AB0010  ld r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82A09C38: F8AA0010  std r5, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[5].u64 ) };
	// 82A09C3C: E88B0018  ld r4, 0x18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82A09C40: F88A0018  std r4, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82A09C44: 409AFFD4  bne cr6, 0x82a09c18
	if !ctx.cr[6].eq {
	pc = 0x82A09C18; continue 'dispatch;
	}
	pc = 0x82A09C48; continue 'dispatch;
            }
            0x82A09C48 => {
    //   block [0x82A09C48..0x82A09C58)
	// 82A09C48: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82A09C4C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A09C50: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A09C54: 419A0034  beq cr6, 0x82a09c88
	if ctx.cr[6].eq {
	pc = 0x82A09C88; continue 'dispatch;
	}
	pc = 0x82A09C58; continue 'dispatch;
            }
            0x82A09C58 => {
    //   block [0x82A09C58..0x82A09C88)
	// 82A09C58: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A09C5C: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82A09C60: E8E90008  ld r7, 8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 82A09C64: E8C90010  ld r6, 0x10(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	// 82A09C68: E8A90018  ld r5, 0x18(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	// 82A09C6C: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A09C70: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 82A09C74: F8CB0010  std r6, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82A09C78: F8AB0018  std r5, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[5].u64 ) };
	// 82A09C7C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A09C80: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A09C84: 409AFFD4  bne cr6, 0x82a09c58
	if !ctx.cr[6].eq {
	pc = 0x82A09C58; continue 'dispatch;
	}
	pc = 0x82A09C88; continue 'dispatch;
            }
            0x82A09C88 => {
    //   block [0x82A09C88..0x82A09C90)
	// 82A09C88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A09C8C: 4829F7CC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A09C90 size=1044
    let mut pc: u32 = 0x82A09C90;
    'dispatch: loop {
        match pc {
            0x82A09C90 => {
    //   block [0x82A09C90..0x82A09CB8)
	// 82A09C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09C94: 4829F771  bl 0x82ca9404
	ctx.lr = 0x82A09C98;
	sub_82CA93D0(ctx, base);
	// 82A09C98: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09C9C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A09CA0: F88100F8  std r4, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[4].u64 ) };
	// 82A09CA4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A09CA8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A09CAC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A09CB0: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82A09CB4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A09CB8; continue 'dispatch;
            }
            0x82A09CB8 => {
    //   block [0x82A09CB8..0x82A09CE4)
	// 82A09CB8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09CBC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A09CC0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A09CC4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09CC8: 4200FFF0  bdnz 0x82a09cb8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09CB8; continue 'dispatch;
	}
	// 82A09CCC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09CD0: 3B600060  li r27, 0x60
	ctx.r[27].s64 = 96;
	// 82A09CD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A09CD8: 409A000C  bne cr6, 0x82a09ce4
	if !ctx.cr[6].eq {
	pc = 0x82A09CE4; continue 'dispatch;
	}
	// 82A09CDC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A09CE0: 48000010  b 0x82a09cf0
	pc = 0x82A09CF0; continue 'dispatch;
            }
            0x82A09CE4 => {
    //   block [0x82A09CE4..0x82A09CF0)
	// 82A09CE4: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A09CE8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09CEC: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A09CF0; continue 'dispatch;
            }
            0x82A09CF0 => {
    //   block [0x82A09CF0..0x82A09D24)
	// 82A09CF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A09CF4: 419A03A8  beq cr6, 0x82a0a09c
	if ctx.cr[6].eq {
	pc = 0x82A0A09C; continue 'dispatch;
	}
	// 82A09CF8: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09CFC: 3D4002AA  lis r10, 0x2aa
	ctx.r[10].s64 = 44695552;
	// 82A09D00: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A09D04: 614AAAAA  ori r10, r10, 0xaaaa
	ctx.r[10].u64 = ctx.r[10].u64 | 43690;
	// 82A09D08: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A09D0C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09D10: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A09D14: 40980010  bge cr6, 0x82a09d24
	if !ctx.cr[6].lt {
	pc = 0x82A09D24; continue 'dispatch;
	}
	// 82A09D18: 4803D7B1  bl 0x82a474c8
	ctx.lr = 0x82A09D1C;
	sub_82A474C8(ctx, base);
	// 82A09D1C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A09D20: 4829F734  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A09D24 => {
    //   block [0x82A09D24..0x82A09D48)
	// 82A09D24: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A09D28: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A09D2C: 40980188  bge cr6, 0x82a09eb4
	if !ctx.cr[6].lt {
	pc = 0x82A09EB4; continue 'dispatch;
	}
	// 82A09D30: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09D34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A09D38: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A09D3C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A09D40: 41980008  blt cr6, 0x82a09d48
	if ctx.cr[6].lt {
	pc = 0x82A09D48; continue 'dispatch;
	}
	// 82A09D44: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A09D48; continue 'dispatch;
            }
            0x82A09D48 => {
    //   block [0x82A09D48..0x82A09D54)
	// 82A09D48: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A09D4C: 40980008  bge cr6, 0x82a09d54
	if !ctx.cr[6].lt {
	pc = 0x82A09D54; continue 'dispatch;
	}
	// 82A09D50: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x82A09D54; continue 'dispatch;
            }
            0x82A09D54 => {
    //   block [0x82A09D54..0x82A09D78)
	// 82A09D54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A09D58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A09D5C: 48069925  bl 0x82a73680
	ctx.lr = 0x82A09D60;
	sub_82A73680(ctx, base);
	// 82A09D60: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09D64: 80A100FC  lwz r5, 0xfc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A09D68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A09D6C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A09D70: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A09D74: 419A0040  beq cr6, 0x82a09db4
	if ctx.cr[6].eq {
	pc = 0x82A09DB4; continue 'dispatch;
	}
	pc = 0x82A09D78; continue 'dispatch;
            }
            0x82A09D78 => {
    //   block [0x82A09D78..0x82A09D90)
	// 82A09D78: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A09D7C: 419A0028  beq cr6, 0x82a09da4
	if ctx.cr[6].eq {
	pc = 0x82A09DA4; continue 'dispatch;
	}
	// 82A09D80: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A09D84: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A09D88: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 82A09D8C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A09D90; continue 'dispatch;
            }
            0x82A09D90 => {
    //   block [0x82A09D90..0x82A09DA4)
	// 82A09D90: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09D94: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A09D98: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A09D9C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09DA0: 4200FFF0  bdnz 0x82a09d90
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09D90; continue 'dispatch;
	}
	pc = 0x82A09DA4; continue 'dispatch;
            }
            0x82A09DA4 => {
    //   block [0x82A09DA4..0x82A09DB4)
	// 82A09DA4: 39290060  addi r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 + 96;
	// 82A09DA8: 38E70060  addi r7, r7, 0x60
	ctx.r[7].s64 = ctx.r[7].s64 + 96;
	// 82A09DAC: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A09DB0: 409AFFC8  bne cr6, 0x82a09d78
	if !ctx.cr[6].eq {
	pc = 0x82A09D78; continue 'dispatch;
	}
	pc = 0x82A09DB4; continue 'dispatch;
            }
            0x82A09DB4 => {
    //   block [0x82A09DB4..0x82A09DC4)
	// 82A09DB4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A09DB8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82A09DBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A09DC0: 419A003C  beq cr6, 0x82a09dfc
	if ctx.cr[6].eq {
	pc = 0x82A09DFC; continue 'dispatch;
	}
	pc = 0x82A09DC4; continue 'dispatch;
            }
            0x82A09DC4 => {
    //   block [0x82A09DC4..0x82A09DDC)
	// 82A09DC4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A09DC8: 419A0028  beq cr6, 0x82a09df0
	if ctx.cr[6].eq {
	pc = 0x82A09DF0; continue 'dispatch;
	}
	// 82A09DCC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A09DD0: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A09DD4: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82A09DD8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A09DDC; continue 'dispatch;
            }
            0x82A09DDC => {
    //   block [0x82A09DDC..0x82A09DF0)
	// 82A09DDC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09DE0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A09DE4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A09DE8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09DEC: 4200FFF0  bdnz 0x82a09ddc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09DDC; continue 'dispatch;
	}
	pc = 0x82A09DF0; continue 'dispatch;
            }
            0x82A09DF0 => {
    //   block [0x82A09DF0..0x82A09DFC)
	// 82A09DF0: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A09DF4: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 82A09DF8: 4082FFCC  bne 0x82a09dc4
	if !ctx.cr[0].eq {
	pc = 0x82A09DC4; continue 'dispatch;
	}
	pc = 0x82A09DFC; continue 'dispatch;
            }
            0x82A09DFC => {
    //   block [0x82A09DFC..0x82A09E24)
	// 82A09DFC: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09E00: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09E04: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A09E08: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A09E0C: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09E10: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A09E14: 419A004C  beq cr6, 0x82a09e60
	if ctx.cr[6].eq {
	pc = 0x82A09E60; continue 'dispatch;
	}
	// 82A09E18: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A09E1C: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A09E20: 7D0B2A14  add r8, r11, r5
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	pc = 0x82A09E24; continue 'dispatch;
            }
            0x82A09E24 => {
    //   block [0x82A09E24..0x82A09E3C)
	// 82A09E24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A09E28: 419A0028  beq cr6, 0x82a09e50
	if ctx.cr[6].eq {
	pc = 0x82A09E50; continue 'dispatch;
	}
	// 82A09E2C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A09E30: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A09E34: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 82A09E38: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A09E3C; continue 'dispatch;
            }
            0x82A09E3C => {
    //   block [0x82A09E3C..0x82A09E50)
	// 82A09E3C: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09E40: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A09E44: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 82A09E48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09E4C: 4200FFF0  bdnz 0x82a09e3c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09E3C; continue 'dispatch;
	}
	pc = 0x82A09E50; continue 'dispatch;
            }
            0x82A09E50 => {
    //   block [0x82A09E50..0x82A09E60)
	// 82A09E50: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 82A09E54: 39290060  addi r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 + 96;
	// 82A09E58: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A09E5C: 409AFFC8  bne cr6, 0x82a09e24
	if !ctx.cr[6].eq {
	pc = 0x82A09E24; continue 'dispatch;
	}
	pc = 0x82A09E60; continue 'dispatch;
            }
            0x82A09E60 => {
    //   block [0x82A09E60..0x82A09E80)
	// 82A09E60: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09E64: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09E68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A09E6C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A09E70: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A09E74: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A09E78: 419A0008  beq cr6, 0x82a09e80
	if ctx.cr[6].eq {
	pc = 0x82A09E80; continue 'dispatch;
	}
	// 82A09E7C: 4B811EBD  bl 0x8221bd38
	ctx.lr = 0x82A09E80;
	sub_8221BD38(ctx, base);
	pc = 0x82A09E80; continue 'dispatch;
            }
            0x82A09E80 => {
    //   block [0x82A09E80..0x82A09EB4)
	// 82A09E80: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09E84: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A09E88: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A09E8C: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A09E90: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82A09E94: 552B2834  slwi r11, r9, 5
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09E98: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A09E9C: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A09EA0: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A09EA4: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A09EA8: 911C000C  stw r8, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A09EAC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A09EB0: 4829F5A4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A09EB4 => {
    //   block [0x82A09EB4..0x82A09EE4)
	// 82A09EB4: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A09EB8: 7D632850  subf r11, r3, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	// 82A09EBC: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A09EC0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A09EC4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A09EC8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A09ECC: 409800F8  bge cr6, 0x82a09fc4
	if !ctx.cr[6].lt {
	pc = 0x82A09FC4; continue 'dispatch;
	}
	// 82A09ED0: 55662834  slwi r6, r11, 5
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A09ED4: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A09ED8: 7D261A14  add r9, r6, r3
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A09EDC: 419A0044  beq cr6, 0x82a09f20
	if ctx.cr[6].eq {
	pc = 0x82A09F20; continue 'dispatch;
	}
	// 82A09EE0: 7CE64850  subf r7, r6, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	pc = 0x82A09EE4; continue 'dispatch;
            }
            0x82A09EE4 => {
    //   block [0x82A09EE4..0x82A09EFC)
	// 82A09EE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A09EE8: 419A0028  beq cr6, 0x82a09f10
	if ctx.cr[6].eq {
	pc = 0x82A09F10; continue 'dispatch;
	}
	// 82A09EEC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A09EF0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A09EF4: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 82A09EF8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A09EFC; continue 'dispatch;
            }
            0x82A09EFC => {
    //   block [0x82A09EFC..0x82A09F10)
	// 82A09EFC: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09F00: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A09F04: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A09F08: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09F0C: 4200FFF0  bdnz 0x82a09efc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09EFC; continue 'dispatch;
	}
	pc = 0x82A09F10; continue 'dispatch;
            }
            0x82A09F10 => {
    //   block [0x82A09F10..0x82A09F20)
	// 82A09F10: 38E70060  addi r7, r7, 0x60
	ctx.r[7].s64 = ctx.r[7].s64 + 96;
	// 82A09F14: 39290060  addi r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 + 96;
	// 82A09F18: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A09F1C: 409AFFC8  bne cr6, 0x82a09ee4
	if !ctx.cr[6].eq {
	pc = 0x82A09EE4; continue 'dispatch;
	}
	pc = 0x82A09F20; continue 'dispatch;
            }
            0x82A09F20 => {
    //   block [0x82A09F20..0x82A09F38)
	// 82A09F20: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09F24: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A09F28: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A09F2C: 7D2ADBD6  divw r9, r10, r27
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A09F30: 7CE9F851  subf. r7, r9, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A09F34: 4182003C  beq 0x82a09f70
	if ctx.cr[0].eq {
	pc = 0x82A09F70; continue 'dispatch;
	}
	pc = 0x82A09F38; continue 'dispatch;
            }
            0x82A09F38 => {
    //   block [0x82A09F38..0x82A09F50)
	// 82A09F38: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A09F3C: 419A0028  beq cr6, 0x82a09f64
	if ctx.cr[6].eq {
	pc = 0x82A09F64; continue 'dispatch;
	}
	// 82A09F40: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A09F44: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A09F48: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82A09F4C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A09F50; continue 'dispatch;
            }
            0x82A09F50 => {
    //   block [0x82A09F50..0x82A09F64)
	// 82A09F50: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09F54: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A09F58: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A09F5C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09F60: 4200FFF0  bdnz 0x82a09f50
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09F50; continue 'dispatch;
	}
	pc = 0x82A09F64; continue 'dispatch;
            }
            0x82A09F64 => {
    //   block [0x82A09F64..0x82A09F70)
	// 82A09F64: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A09F68: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 82A09F6C: 4082FFCC  bne 0x82a09f38
	if !ctx.cr[0].eq {
	pc = 0x82A09F38; continue 'dispatch;
	}
	pc = 0x82A09F70; continue 'dispatch;
            }
            0x82A09F70 => {
    //   block [0x82A09F70..0x82A09F8C)
	// 82A09F70: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A09F74: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A09F78: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A09F7C: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82A09F80: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A09F84: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A09F88: 419A0114  beq cr6, 0x82a0a09c
	if ctx.cr[6].eq {
	pc = 0x82A0A09C; continue 'dispatch;
	}
	pc = 0x82A09F8C; continue 'dispatch;
            }
            0x82A09F8C => {
    //   block [0x82A09F8C..0x82A09F9C)
	// 82A09F8C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A09F90: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A09F94: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 82A09F98: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A09F9C; continue 'dispatch;
            }
            0x82A09F9C => {
    //   block [0x82A09F9C..0x82A09FC4)
	// 82A09F9C: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A09FA0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A09FA4: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A09FA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09FAC: 4200FFF0  bdnz 0x82a09f9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09F9C; continue 'dispatch;
	}
	// 82A09FB0: 39290060  addi r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 + 96;
	// 82A09FB4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A09FB8: 409AFFD4  bne cr6, 0x82a09f8c
	if !ctx.cr[6].eq {
	pc = 0x82A09F8C; continue 'dispatch;
	}
	// 82A09FBC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A09FC0: 4829F494  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A09FC4 => {
    //   block [0x82A09FC4..0x82A09FDC)
	// 82A09FC4: 55642834  slwi r4, r11, 5
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A09FC8: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82A09FCC: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82A09FD0: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82A09FD4: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A09FD8: 419A0040  beq cr6, 0x82a0a018
	if ctx.cr[6].eq {
	pc = 0x82A0A018; continue 'dispatch;
	}
	pc = 0x82A09FDC; continue 'dispatch;
            }
            0x82A09FDC => {
    //   block [0x82A09FDC..0x82A09FF4)
	// 82A09FDC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A09FE0: 419A0028  beq cr6, 0x82a0a008
	if ctx.cr[6].eq {
	pc = 0x82A0A008; continue 'dispatch;
	}
	// 82A09FE4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A09FE8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A09FEC: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 82A09FF0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x82A09FF4; continue 'dispatch;
            }
            0x82A09FF4 => {
    //   block [0x82A09FF4..0x82A0A008)
	// 82A09FF4: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A09FF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A09FFC: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82A0A000: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A0A004: 4200FFF0  bdnz 0x82a09ff4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A09FF4; continue 'dispatch;
	}
	pc = 0x82A0A008; continue 'dispatch;
            }
            0x82A0A008 => {
    //   block [0x82A0A008..0x82A0A018)
	// 82A0A008: 38E70060  addi r7, r7, 0x60
	ctx.r[7].s64 = ctx.r[7].s64 + 96;
	// 82A0A00C: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 82A0A010: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A0A014: 409AFFC8  bne cr6, 0x82a09fdc
	if !ctx.cr[6].eq {
	pc = 0x82A09FDC; continue 'dispatch;
	}
	pc = 0x82A0A018; continue 'dispatch;
            }
            0x82A0A018 => {
    //   block [0x82A0A018..0x82A0A028)
	// 82A0A018: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A0A01C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0A020: 419A003C  beq cr6, 0x82a0a05c
	if ctx.cr[6].eq {
	pc = 0x82A0A05C; continue 'dispatch;
	}
	// 82A0A024: 7D045A14  add r8, r4, r11
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	pc = 0x82A0A028; continue 'dispatch;
            }
            0x82A0A028 => {
    //   block [0x82A0A028..0x82A0A040)
	// 82A0A028: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 82A0A02C: 3908FFA0  addi r8, r8, -0x60
	ctx.r[8].s64 = ctx.r[8].s64 + -96;
	// 82A0A030: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A0A034: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A0A038: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 82A0A03C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A0A040; continue 'dispatch;
            }
            0x82A0A040 => {
    //   block [0x82A0A040..0x82A0A05C)
	// 82A0A040: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A0A044: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A0A048: F8E90000  std r7, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 82A0A04C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A0A050: 4200FFF0  bdnz 0x82a0a040
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0A040; continue 'dispatch;
	}
	// 82A0A054: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A0A058: 409AFFD0  bne cr6, 0x82a0a028
	if !ctx.cr[6].eq {
	pc = 0x82A0A028; continue 'dispatch;
	}
	pc = 0x82A0A05C; continue 'dispatch;
            }
            0x82A0A05C => {
    //   block [0x82A0A05C..0x82A0A06C)
	// 82A0A05C: 7CE41A14  add r7, r4, r3
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 82A0A060: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A0A064: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A0A068: 419A0034  beq cr6, 0x82a0a09c
	if ctx.cr[6].eq {
	pc = 0x82A0A09C; continue 'dispatch;
	}
	pc = 0x82A0A06C; continue 'dispatch;
            }
            0x82A0A06C => {
    //   block [0x82A0A06C..0x82A0A07C)
	// 82A0A06C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A0A070: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A0A074: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82A0A078: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A0A07C; continue 'dispatch;
            }
            0x82A0A07C => {
    //   block [0x82A0A07C..0x82A0A09C)
	// 82A0A07C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A0A080: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A0A084: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A0A088: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A0A08C: 4200FFF0  bdnz 0x82a0a07c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0A07C; continue 'dispatch;
	}
	// 82A0A090: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 82A0A094: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A0A098: 409AFFD4  bne cr6, 0x82a0a06c
	if !ctx.cr[6].eq {
	pc = 0x82A0A06C; continue 'dispatch;
	}
	pc = 0x82A0A09C; continue 'dispatch;
            }
            0x82A0A09C => {
    //   block [0x82A0A09C..0x82A0A0A4)
	// 82A0A09C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A0A0A0: 4829F3B4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A0A8 size=816
    let mut pc: u32 = 0x82A0A0A8;
    'dispatch: loop {
        match pc {
            0x82A0A0A8 => {
    //   block [0x82A0A0A8..0x82A0A0E8)
	// 82A0A0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A0AC: 4829F349  bl 0x82ca93f4
	ctx.lr = 0x82A0A0B0;
	sub_82CA93D0(ctx, base);
	// 82A0A0B0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A0B4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A0A0B8: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82A0A0BC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A0A0C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0A0C4: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A0C8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A0A0CC: 4829F3B5  bl 0x82ca9480
	ctx.lr = 0x82A0A0D0;
	sub_82CA9480(ctx, base);
	// 82A0A0D0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0A0D4: 3AE0002C  li r23, 0x2c
	ctx.r[23].s64 = 44;
	// 82A0A0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A0DC: 409A000C  bne cr6, 0x82a0a0e8
	if !ctx.cr[6].eq {
	pc = 0x82A0A0E8; continue 'dispatch;
	}
	// 82A0A0E0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0A0E4: 48000010  b 0x82a0a0f4
	pc = 0x82A0A0F4; continue 'dispatch;
            }
            0x82A0A0E8 => {
    //   block [0x82A0A0E8..0x82A0A0F4)
	// 82A0A0E8: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0A0EC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0A0F0: 7D29BBD6  divw r9, r9, r23
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[23].s32;
	pc = 0x82A0A0F4; continue 'dispatch;
            }
            0x82A0A0F4 => {
    //   block [0x82A0A0F4..0x82A0A128)
	// 82A0A0F4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0A0F8: 419A02D8  beq cr6, 0x82a0a3d0
	if ctx.cr[6].eq {
	pc = 0x82A0A3D0; continue 'dispatch;
	}
	// 82A0A0FC: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0A100: 3D4005D1  lis r10, 0x5d1
	ctx.r[10].s64 = 97583104;
	// 82A0A104: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A0A108: 614A745D  ori r10, r10, 0x745d
	ctx.r[10].u64 = ctx.r[10].u64 | 29789;
	// 82A0A10C: 7D68BBD6  divw r11, r8, r23
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[23].s32;
	// 82A0A110: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0A114: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0A118: 40980010  bge cr6, 0x82a0a128
	if !ctx.cr[6].lt {
	pc = 0x82A0A128; continue 'dispatch;
	}
	// 82A0A11C: 4803D3AD  bl 0x82a474c8
	ctx.lr = 0x82A0A120;
	sub_82A474C8(ctx, base);
	// 82A0A120: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A0A124: 4829F320  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0A128 => {
    //   block [0x82A0A128..0x82A0A14C)
	// 82A0A128: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A0A12C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0A130: 40980134  bge cr6, 0x82a0a264
	if !ctx.cr[6].lt {
	pc = 0x82A0A264; continue 'dispatch;
	}
	// 82A0A134: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0A138: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A0A13C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0A140: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0A144: 41980008  blt cr6, 0x82a0a14c
	if ctx.cr[6].lt {
	pc = 0x82A0A14C; continue 'dispatch;
	}
	// 82A0A148: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A0A14C; continue 'dispatch;
            }
            0x82A0A14C => {
    //   block [0x82A0A14C..0x82A0A158)
	// 82A0A14C: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0A150: 40980008  bge cr6, 0x82a0a158
	if !ctx.cr[6].lt {
	pc = 0x82A0A158; continue 'dispatch;
	}
	// 82A0A154: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x82A0A158; continue 'dispatch;
            }
            0x82A0A158 => {
    //   block [0x82A0A158..0x82A0A17C)
	// 82A0A158: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A0A15C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A0A160: 4BA22619  bl 0x8242c778
	ctx.lr = 0x82A0A164;
	sub_8242C778(ctx, base);
	// 82A0A164: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0A168: 838100EC  lwz r28, 0xec(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A0A16C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0A170: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0A174: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0A178: 419A002C  beq cr6, 0x82a0a1a4
	if ctx.cr[6].eq {
	pc = 0x82A0A1A4; continue 'dispatch;
	}
	pc = 0x82A0A17C; continue 'dispatch;
            }
            0x82A0A17C => {
    //   block [0x82A0A17C..0x82A0A194)
	// 82A0A17C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0A180: 419A0014  beq cr6, 0x82a0a194
	if ctx.cr[6].eq {
	pc = 0x82A0A194; continue 'dispatch;
	}
	// 82A0A184: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A188: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0A18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A190: 4829F2F1  bl 0x82ca9480
	ctx.lr = 0x82A0A194;
	sub_82CA9480(ctx, base);
	pc = 0x82A0A194; continue 'dispatch;
            }
            0x82A0A194 => {
    //   block [0x82A0A194..0x82A0A1A4)
	// 82A0A194: 3BDE002C  addi r30, r30, 0x2c
	ctx.r[30].s64 = ctx.r[30].s64 + 44;
	// 82A0A198: 3BFF002C  addi r31, r31, 0x2c
	ctx.r[31].s64 = ctx.r[31].s64 + 44;
	// 82A0A19C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0A1A0: 409AFFDC  bne cr6, 0x82a0a17c
	if !ctx.cr[6].eq {
	pc = 0x82A0A17C; continue 'dispatch;
	}
	pc = 0x82A0A1A4; continue 'dispatch;
            }
            0x82A0A1A4 => {
    //   block [0x82A0A1A4..0x82A0A1B4)
	// 82A0A1A4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A0A1A8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A0A1AC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0A1B0: 419A0028  beq cr6, 0x82a0a1d8
	if ctx.cr[6].eq {
	pc = 0x82A0A1D8; continue 'dispatch;
	}
	pc = 0x82A0A1B4; continue 'dispatch;
            }
            0x82A0A1B4 => {
    //   block [0x82A0A1B4..0x82A0A1CC)
	// 82A0A1B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0A1B8: 419A0014  beq cr6, 0x82a0a1cc
	if ctx.cr[6].eq {
	pc = 0x82A0A1CC; continue 'dispatch;
	}
	// 82A0A1BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0A1C0: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A1C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A1C8: 4829F2B9  bl 0x82ca9480
	ctx.lr = 0x82A0A1CC;
	sub_82CA9480(ctx, base);
	pc = 0x82A0A1CC; continue 'dispatch;
            }
            0x82A0A1CC => {
    //   block [0x82A0A1CC..0x82A0A1D8)
	// 82A0A1CC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0A1D0: 3BDE002C  addi r30, r30, 0x2c
	ctx.r[30].s64 = ctx.r[30].s64 + 44;
	// 82A0A1D4: 4082FFE0  bne 0x82a0a1b4
	if !ctx.cr[0].eq {
	pc = 0x82A0A1B4; continue 'dispatch;
	}
	pc = 0x82A0A1D8; continue 'dispatch;
            }
            0x82A0A1D8 => {
    //   block [0x82A0A1D8..0x82A0A1F8)
	// 82A0A1D8: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0A1DC: 1D7A002C  mulli r11, r26, 0x2c
	ctx.r[11].s32 = ((ctx.r[26].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A0A1E0: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A0A1E4: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0A1E8: 419A0038  beq cr6, 0x82a0a220
	if ctx.cr[6].eq {
	pc = 0x82A0A220; continue 'dispatch;
	}
	// 82A0A1EC: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82A0A1F0: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82A0A1F4: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82A0A1F8; continue 'dispatch;
            }
            0x82A0A1F8 => {
    //   block [0x82A0A1F8..0x82A0A210)
	// 82A0A1F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0A1FC: 419A0014  beq cr6, 0x82a0a210
	if ctx.cr[6].eq {
	pc = 0x82A0A210; continue 'dispatch;
	}
	// 82A0A200: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A204: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0A208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A20C: 4829F275  bl 0x82ca9480
	ctx.lr = 0x82A0A210;
	sub_82CA9480(ctx, base);
	pc = 0x82A0A210; continue 'dispatch;
            }
            0x82A0A210 => {
    //   block [0x82A0A210..0x82A0A220)
	// 82A0A210: 3BFF002C  addi r31, r31, 0x2c
	ctx.r[31].s64 = ctx.r[31].s64 + 44;
	// 82A0A214: 3BDE002C  addi r30, r30, 0x2c
	ctx.r[30].s64 = ctx.r[30].s64 + 44;
	// 82A0A218: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0A21C: 409AFFDC  bne cr6, 0x82a0a1f8
	if !ctx.cr[6].eq {
	pc = 0x82A0A1F8; continue 'dispatch;
	}
	pc = 0x82A0A220; continue 'dispatch;
            }
            0x82A0A220 => {
    //   block [0x82A0A220..0x82A0A240)
	// 82A0A220: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0A224: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0A228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0A22C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A0A230: 7D6ABBD6  divw r11, r10, r23
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 82A0A234: 7FEBD214  add r31, r11, r26
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A0A238: 419A0008  beq cr6, 0x82a0a240
	if ctx.cr[6].eq {
	pc = 0x82A0A240; continue 'dispatch;
	}
	// 82A0A23C: 4B811AFD  bl 0x8221bd38
	ctx.lr = 0x82A0A240;
	sub_8221BD38(ctx, base);
	pc = 0x82A0A240; continue 'dispatch;
            }
            0x82A0A240 => {
    //   block [0x82A0A240..0x82A0A264)
	// 82A0A240: 1D58002C  mulli r10, r24, 0x2c
	ctx.r[10].s32 = ((ctx.r[24].s32 as i64 * 44 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A0A244: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A0A248: 1D7F002C  mulli r11, r31, 0x2c
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A0A24C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A0A250: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A0A254: 9159000C  stw r10, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82A0A258: 91390008  stw r9, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A0A25C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A0A260: 4829F1E4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0A264 => {
    //   block [0x82A0A264..0x82A0A28C)
	// 82A0A264: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A0A268: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0A26C: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A0A270: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0A274: 409800BC  bge cr6, 0x82a0a330
	if !ctx.cr[6].lt {
	pc = 0x82A0A330; continue 'dispatch;
	}
	// 82A0A278: 1F9A002C  mulli r28, r26, 0x2c
	ctx.r[28].s32 = ((ctx.r[26].s32 as i64 * 44 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82A0A27C: 7FDCDA14  add r30, r28, r27
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82A0A280: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0A284: 419A0030  beq cr6, 0x82a0a2b4
	if ctx.cr[6].eq {
	pc = 0x82A0A2B4; continue 'dispatch;
	}
	// 82A0A288: 7FBCF050  subf r29, r28, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	pc = 0x82A0A28C; continue 'dispatch;
            }
            0x82A0A28C => {
    //   block [0x82A0A28C..0x82A0A2A4)
	// 82A0A28C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0A290: 419A0014  beq cr6, 0x82a0a2a4
	if ctx.cr[6].eq {
	pc = 0x82A0A2A4; continue 'dispatch;
	}
	// 82A0A294: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A298: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0A29C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A2A0: 4829F1E1  bl 0x82ca9480
	ctx.lr = 0x82A0A2A4;
	sub_82CA9480(ctx, base);
	pc = 0x82A0A2A4; continue 'dispatch;
            }
            0x82A0A2A4 => {
    //   block [0x82A0A2A4..0x82A0A2B4)
	// 82A0A2A4: 3BBD002C  addi r29, r29, 0x2c
	ctx.r[29].s64 = ctx.r[29].s64 + 44;
	// 82A0A2A8: 3BDE002C  addi r30, r30, 0x2c
	ctx.r[30].s64 = ctx.r[30].s64 + 44;
	// 82A0A2AC: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0A2B0: 409AFFDC  bne cr6, 0x82a0a28c
	if !ctx.cr[6].eq {
	pc = 0x82A0A28C; continue 'dispatch;
	}
	pc = 0x82A0A2B4; continue 'dispatch;
            }
            0x82A0A2B4 => {
    //   block [0x82A0A2B4..0x82A0A2CC)
	// 82A0A2B4: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0A2B8: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82A0A2BC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82A0A2C0: 7D2ABBD6  divw r9, r10, r23
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 82A0A2C4: 7FE9D051  subf. r31, r9, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0A2C8: 41820028  beq 0x82a0a2f0
	if ctx.cr[0].eq {
	pc = 0x82A0A2F0; continue 'dispatch;
	}
	pc = 0x82A0A2CC; continue 'dispatch;
            }
            0x82A0A2CC => {
    //   block [0x82A0A2CC..0x82A0A2E4)
	// 82A0A2CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0A2D0: 419A0014  beq cr6, 0x82a0a2e4
	if ctx.cr[6].eq {
	pc = 0x82A0A2E4; continue 'dispatch;
	}
	// 82A0A2D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0A2D8: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A2DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A2E0: 4829F1A1  bl 0x82ca9480
	ctx.lr = 0x82A0A2E4;
	sub_82CA9480(ctx, base);
	pc = 0x82A0A2E4; continue 'dispatch;
            }
            0x82A0A2E4 => {
    //   block [0x82A0A2E4..0x82A0A2F0)
	// 82A0A2E4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0A2E8: 3BDE002C  addi r30, r30, 0x2c
	ctx.r[30].s64 = ctx.r[30].s64 + 44;
	// 82A0A2EC: 4082FFE0  bne 0x82a0a2cc
	if !ctx.cr[0].eq {
	pc = 0x82A0A2CC; continue 'dispatch;
	}
	pc = 0x82A0A2F0; continue 'dispatch;
            }
            0x82A0A2F0 => {
    //   block [0x82A0A2F0..0x82A0A30C)
	// 82A0A2F0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0A2F4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0A2F8: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82A0A2FC: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82A0A300: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0A304: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0A308: 419A00C8  beq cr6, 0x82a0a3d0
	if ctx.cr[6].eq {
	pc = 0x82A0A3D0; continue 'dispatch;
	}
	pc = 0x82A0A30C; continue 'dispatch;
            }
            0x82A0A30C => {
    //   block [0x82A0A30C..0x82A0A330)
	// 82A0A30C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0A310: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A318: 4829F169  bl 0x82ca9480
	ctx.lr = 0x82A0A31C;
	sub_82CA9480(ctx, base);
	// 82A0A31C: 3BFF002C  addi r31, r31, 0x2c
	ctx.r[31].s64 = ctx.r[31].s64 + 44;
	// 82A0A320: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0A324: 409AFFE8  bne cr6, 0x82a0a30c
	if !ctx.cr[6].eq {
	pc = 0x82A0A30C; continue 'dispatch;
	}
	// 82A0A328: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A0A32C: 4829F118  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0A330 => {
    //   block [0x82A0A330..0x82A0A348)
	// 82A0A330: 1F5A002C  mulli r26, r26, 0x2c
	ctx.r[26].s32 = ((ctx.r[26].s32 as i64 * 44 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	// 82A0A334: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A0A338: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A0A33C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A0A340: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0A344: 419A002C  beq cr6, 0x82a0a370
	if ctx.cr[6].eq {
	pc = 0x82A0A370; continue 'dispatch;
	}
	pc = 0x82A0A348; continue 'dispatch;
            }
            0x82A0A348 => {
    //   block [0x82A0A348..0x82A0A360)
	// 82A0A348: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0A34C: 419A0014  beq cr6, 0x82a0a360
	if ctx.cr[6].eq {
	pc = 0x82A0A360; continue 'dispatch;
	}
	// 82A0A350: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A354: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0A358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A35C: 4829F125  bl 0x82ca9480
	ctx.lr = 0x82A0A360;
	sub_82CA9480(ctx, base);
	pc = 0x82A0A360; continue 'dispatch;
            }
            0x82A0A360 => {
    //   block [0x82A0A360..0x82A0A370)
	// 82A0A360: 3BBD002C  addi r29, r29, 0x2c
	ctx.r[29].s64 = ctx.r[29].s64 + 44;
	// 82A0A364: 3BDE002C  addi r30, r30, 0x2c
	ctx.r[30].s64 = ctx.r[30].s64 + 44;
	// 82A0A368: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0A36C: 409AFFDC  bne cr6, 0x82a0a348
	if !ctx.cr[6].eq {
	pc = 0x82A0A348; continue 'dispatch;
	}
	pc = 0x82A0A370; continue 'dispatch;
            }
            0x82A0A370 => {
    //   block [0x82A0A370..0x82A0A384)
	// 82A0A370: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A0A374: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A0A378: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0A37C: 419A0028  beq cr6, 0x82a0a3a4
	if ctx.cr[6].eq {
	pc = 0x82A0A3A4; continue 'dispatch;
	}
	// 82A0A380: 7FDAFA14  add r30, r26, r31
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	pc = 0x82A0A384; continue 'dispatch;
            }
            0x82A0A384 => {
    //   block [0x82A0A384..0x82A0A3A4)
	// 82A0A384: 3BFFFFD4  addi r31, r31, -0x2c
	ctx.r[31].s64 = ctx.r[31].s64 + -44;
	// 82A0A388: 3BDEFFD4  addi r30, r30, -0x2c
	ctx.r[30].s64 = ctx.r[30].s64 + -44;
	// 82A0A38C: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0A394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A398: 4829F0E9  bl 0x82ca9480
	ctx.lr = 0x82A0A39C;
	sub_82CA9480(ctx, base);
	// 82A0A39C: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0A3A0: 409AFFE4  bne cr6, 0x82a0a384
	if !ctx.cr[6].eq {
	pc = 0x82A0A384; continue 'dispatch;
	}
	pc = 0x82A0A3A4; continue 'dispatch;
            }
            0x82A0A3A4 => {
    //   block [0x82A0A3A4..0x82A0A3B4)
	// 82A0A3A4: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82A0A3A8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0A3AC: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0A3B0: 419A0020  beq cr6, 0x82a0a3d0
	if ctx.cr[6].eq {
	pc = 0x82A0A3D0; continue 'dispatch;
	}
	pc = 0x82A0A3B4; continue 'dispatch;
            }
            0x82A0A3B4 => {
    //   block [0x82A0A3B4..0x82A0A3D0)
	// 82A0A3B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0A3B8: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A0A3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A3C0: 4829F0C1  bl 0x82ca9480
	ctx.lr = 0x82A0A3C4;
	sub_82CA9480(ctx, base);
	// 82A0A3C4: 3BFF002C  addi r31, r31, 0x2c
	ctx.r[31].s64 = ctx.r[31].s64 + 44;
	// 82A0A3C8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0A3CC: 409AFFE8  bne cr6, 0x82a0a3b4
	if !ctx.cr[6].eq {
	pc = 0x82A0A3B4; continue 'dispatch;
	}
	pc = 0x82A0A3D0; continue 'dispatch;
            }
            0x82A0A3D0 => {
    //   block [0x82A0A3D0..0x82A0A3D8)
	// 82A0A3D0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A0A3D4: 4829F070  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0A3D8 size=100
    let mut pc: u32 = 0x82A0A3D8;
    'dispatch: loop {
        match pc {
            0x82A0A3D8 => {
    //   block [0x82A0A3D8..0x82A0A408)
	// 82A0A3D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0A3DC: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 82A0A3E0: 7D4B2050  subf r10, r11, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82A0A3E4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A0A3E8: 7D4A43D6  divw r10, r10, r8
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 82A0A3EC: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A0A3F0: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0A3F4: 7CEA4214  add r7, r10, r8
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A0A3F8: 54EA2834  slwi r10, r7, 5
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0A3FC: 7C6A2A14  add r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82A0A400: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A0A404: 7CEB2850  subf r7, r11, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	pc = 0x82A0A408; continue 'dispatch;
            }
            0x82A0A408 => {
    //   block [0x82A0A408..0x82A0A418)
	// 82A0A408: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82A0A40C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A0A410: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 82A0A414: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A0A418; continue 'dispatch;
            }
            0x82A0A418 => {
    //   block [0x82A0A418..0x82A0A43C)
	// 82A0A418: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A0A41C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A0A420: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A0A424: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A0A428: 4200FFF0  bdnz 0x82a0a418
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A0A418; continue 'dispatch;
	}
	// 82A0A42C: 39290060  addi r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 + 96;
	// 82A0A430: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A0A434: 409AFFD4  bne cr6, 0x82a0a408
	if !ctx.cr[6].eq {
	pc = 0x82A0A408; continue 'dispatch;
	}
	// 82A0A438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A440 size=108
    let mut pc: u32 = 0x82A0A440;
    'dispatch: loop {
        match pc {
            0x82A0A440 => {
    //   block [0x82A0A440..0x82A0A49C)
	// 82A0A440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A444: 4829EFC5  bl 0x82ca9408
	ctx.lr = 0x82A0A448;
	sub_82CA93D0(ctx, base);
	// 82A0A448: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A44C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0A450: 83E40004  lwz r31, 4(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0A454: 83840000  lwz r28, 0(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0A458: 3BDD00D0  addi r30, r29, 0xd0
	ctx.r[30].s64 = ctx.r[29].s64 + 208;
	// 82A0A45C: 817D00D4  lwz r11, 0xd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A0A460: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0A464: 419A0038  beq cr6, 0x82a0a49c
	if ctx.cr[6].eq {
	pc = 0x82A0A49C; continue 'dispatch;
	}
	// 82A0A468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A46C: 4B7AD6AD  bl 0x821b7b18
	ctx.lr = 0x82A0A470;
	sub_821B7B18(ctx, base);
	// 82A0A470: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A0A474: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A0A478: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0A47C: 419A0020  beq cr6, 0x82a0a49c
	if ctx.cr[6].eq {
	pc = 0x82A0A49C; continue 'dispatch;
	}
	// 82A0A480: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0A484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0A488: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82A0A48C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0A490: 995D00B0  stb r10, 0xb0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(176 as u32), ctx.r[10].u8 ) };
	// 82A0A494: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0A498: 4829EFC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0A49C => {
    //   block [0x82A0A49C..0x82A0A4AC)
	// 82A0A49C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0A4A0: 997D00B0  stb r11, 0xb0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
	// 82A0A4A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0A4A8: 4829EFB0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A4B0 size=80
    let mut pc: u32 = 0x82A0A4B0;
    'dispatch: loop {
        match pc {
            0x82A0A4B0 => {
    //   block [0x82A0A4B0..0x82A0A4E8)
	// 82A0A4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0A4B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0A4BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0A4C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A4C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A4C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0A4CC: 48824875  bl 0x8322ed40
	ctx.lr = 0x82A0A4D0;
	sub_8322ED40(ctx, base);
	// 82A0A4D0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A0A4D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A4DC: 419A000C  beq cr6, 0x82a0a4e8
	if ctx.cr[6].eq {
	pc = 0x82A0A4E8; continue 'dispatch;
	}
	// 82A0A4E0: 4B811859  bl 0x8221bd38
	ctx.lr = 0x82A0A4E4;
	sub_8221BD38(ctx, base);
	// 82A0A4E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0A4E8; continue 'dispatch;
            }
            0x82A0A4E8 => {
    //   block [0x82A0A4E8..0x82A0A500)
	// 82A0A4E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0A4EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A4F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A4F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0A4F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A4FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A0A500 size=16
    let mut pc: u32 = 0x82A0A500;
    'dispatch: loop {
        match pc {
            0x82A0A500 => {
    //   block [0x82A0A500..0x82A0A510)
	// 82A0A500: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0A504: D02300CC  stfs f1, 0xcc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82A0A508: 996300B0  stb r11, 0xb0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
	// 82A0A50C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A510 size=80
    let mut pc: u32 = 0x82A0A510;
    'dispatch: loop {
        match pc {
            0x82A0A510 => {
    //   block [0x82A0A510..0x82A0A548)
	// 82A0A510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0A518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0A51C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0A520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A528: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0A52C: 48823F2D  bl 0x8322e458
	ctx.lr = 0x82A0A530;
	sub_8322E458(ctx, base);
	// 82A0A530: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A0A534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A53C: 419A000C  beq cr6, 0x82a0a548
	if ctx.cr[6].eq {
	pc = 0x82A0A548; continue 'dispatch;
	}
	// 82A0A540: 4B8117F9  bl 0x8221bd38
	ctx.lr = 0x82A0A544;
	sub_8221BD38(ctx, base);
	// 82A0A544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0A548; continue 'dispatch;
            }
            0x82A0A548 => {
    //   block [0x82A0A548..0x82A0A560)
	// 82A0A548: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0A54C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A554: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0A558: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A55C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A560 size=80
    let mut pc: u32 = 0x82A0A560;
    'dispatch: loop {
        match pc {
            0x82A0A560 => {
    //   block [0x82A0A560..0x82A0A598)
	// 82A0A560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0A568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0A56C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0A570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A578: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0A57C: 48822C7D  bl 0x8322d1f8
	ctx.lr = 0x82A0A580;
	sub_8322D1F8(ctx, base);
	// 82A0A580: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A0A584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A58C: 419A000C  beq cr6, 0x82a0a598
	if ctx.cr[6].eq {
	pc = 0x82A0A598; continue 'dispatch;
	}
	// 82A0A590: 4B8117A9  bl 0x8221bd38
	ctx.lr = 0x82A0A594;
	sub_8221BD38(ctx, base);
	// 82A0A594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0A598; continue 'dispatch;
            }
            0x82A0A598 => {
    //   block [0x82A0A598..0x82A0A5B0)
	// 82A0A598: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0A59C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A5A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A5A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0A5A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A5AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A5B0 size=144
    let mut pc: u32 = 0x82A0A5B0;
    'dispatch: loop {
        match pc {
            0x82A0A5B0 => {
    //   block [0x82A0A5B0..0x82A0A5E0)
	// 82A0A5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0A5B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0A5BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A5C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A5C4: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A0A5C8: 4B814C91  bl 0x8221f258
	ctx.lr = 0x82A0A5CC;
	sub_8221F258(ctx, base);
	// 82A0A5CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0A5D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0A5D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A5D8: 419A0008  beq cr6, 0x82a0a5e0
	if ctx.cr[6].eq {
	pc = 0x82A0A5E0; continue 'dispatch;
	}
	// 82A0A5DC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A0A5E0; continue 'dispatch;
            }
            0x82A0A5E0 => {
    //   block [0x82A0A5E0..0x82A0A5EC)
	// 82A0A5E0: 352B0004  addic. r9, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A0A5E4: 41820008  beq 0x82a0a5ec
	if ctx.cr[0].eq {
	pc = 0x82A0A5EC; continue 'dispatch;
	}
	// 82A0A5E8: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A0A5EC; continue 'dispatch;
            }
            0x82A0A5EC => {
    //   block [0x82A0A5EC..0x82A0A5F8)
	// 82A0A5EC: 352B0008  addic. r9, r11, 8
	ctx.xer.ca = (ctx.r[11].u32 > (!(8 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A0A5F0: 41820008  beq 0x82a0a5f8
	if ctx.cr[0].eq {
	pc = 0x82A0A5F8; continue 'dispatch;
	}
	// 82A0A5F4: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A0A5F8; continue 'dispatch;
            }
            0x82A0A5F8 => {
    //   block [0x82A0A5F8..0x82A0A640)
	// 82A0A5F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A0A5FC: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 82A0A600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A604: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 82A0A608: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0A60C: 992B0015  stb r9, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[9].u8 ) };
	// 82A0A610: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0A614: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0A618: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0A61C: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0A620: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0A624: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A0A628: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0A62C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0A630: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A634: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A63C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0A640 size=332
    let mut pc: u32 = 0x82A0A640;
    'dispatch: loop {
        match pc {
            0x82A0A640 => {
    //   block [0x82A0A640..0x82A0A678)
	// 82A0A640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A644: 4829EDC9  bl 0x82ca940c
	ctx.lr = 0x82A0A648;
	sub_82CA93D0(ctx, base);
	// 82A0A648: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A64C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A650: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0A654: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0A658: 419A0028  beq cr6, 0x82a0a680
	if ctx.cr[6].eq {
	pc = 0x82A0A680; continue 'dispatch;
	}
	// 82A0A65C: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A0A660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A664: 419A0014  beq cr6, 0x82a0a678
	if ctx.cr[6].eq {
	pc = 0x82A0A678; continue 'dispatch;
	}
	// 82A0A668: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0A66C: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0A670: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0A674: 4199000C  bgt cr6, 0x82a0a680
	if ctx.cr[6].gt {
	pc = 0x82A0A680; continue 'dispatch;
	}
	pc = 0x82A0A678; continue 'dispatch;
            }
            0x82A0A678 => {
    //   block [0x82A0A678..0x82A0A680)
	// 82A0A678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0A67C: 48000008  b 0x82a0a684
	pc = 0x82A0A684; continue 'dispatch;
            }
            0x82A0A680 => {
    //   block [0x82A0A680..0x82A0A684)
	// 82A0A680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0A684; continue 'dispatch;
            }
            0x82A0A684 => {
    //   block [0x82A0A684..0x82A0A784)
	// 82A0A684: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0A688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A68C: 419A00F8  beq cr6, 0x82a0a784
	if ctx.cr[6].eq {
	pc = 0x82A0A784; continue 'dispatch;
	}
	// 82A0A690: 811F0170  lwz r8, 0x170(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0A694: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A0A698: 419A00EC  beq cr6, 0x82a0a784
	if ctx.cr[6].eq {
	pc = 0x82A0A784; continue 'dispatch;
	}
	// 82A0A69C: 81680024  lwz r11, 0x24(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A0A6A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A0A6A4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0A6A8: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 82A0A6AC: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 82A0A6B0: 83DF0168  lwz r30, 0x168(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A0A6B4: 38CA9160  addi r6, r10, -0x6ea0
	ctx.r[6].s64 = ctx.r[10].s64 + -28320;
	// 82A0A6B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0A6BC: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0A6C0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A0A6C4: 98FF01DC  stb r7, 0x1dc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[7].u8 ) };
	// 82A0A6C8: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82A0A6CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	pc = 0x82A0A784; continue 'dispatch;
            }
            0x82A0A784 => {
    //   block [0x82A0A784..0x82A0A78C)
	// 82A0A784: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A0A788: 4829ECD4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0A790 size=388
    let mut pc: u32 = 0x82A0A790;
    'dispatch: loop {
        match pc {
            0x82A0A790 => {
    //   block [0x82A0A790..0x82A0A7D0)
	// 82A0A790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0A798: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0A79C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0A7A0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A7A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A7A8: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0A7AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0A7B0: 419A0028  beq cr6, 0x82a0a7d8
	if ctx.cr[6].eq {
	pc = 0x82A0A7D8; continue 'dispatch;
	}
	// 82A0A7B4: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A0A7B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A7BC: 419A0014  beq cr6, 0x82a0a7d0
	if ctx.cr[6].eq {
	pc = 0x82A0A7D0; continue 'dispatch;
	}
	// 82A0A7C0: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0A7C4: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0A7C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0A7CC: 4199000C  bgt cr6, 0x82a0a7d8
	if ctx.cr[6].gt {
	pc = 0x82A0A7D8; continue 'dispatch;
	}
	pc = 0x82A0A7D0; continue 'dispatch;
            }
            0x82A0A7D0 => {
    //   block [0x82A0A7D0..0x82A0A7D8)
	// 82A0A7D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0A7D4: 48000008  b 0x82a0a7dc
	pc = 0x82A0A7DC; continue 'dispatch;
            }
            0x82A0A7D8 => {
    //   block [0x82A0A7D8..0x82A0A7DC)
	// 82A0A7D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0A7DC; continue 'dispatch;
            }
            0x82A0A7DC => {
    //   block [0x82A0A7DC..0x82A0A8FC)
	// 82A0A7DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0A7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A7E4: 419A0118  beq cr6, 0x82a0a8fc
	if ctx.cr[6].eq {
	pc = 0x82A0A8FC; continue 'dispatch;
	}
	// 82A0A7E8: 811F0170  lwz r8, 0x170(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0A7EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A0A7F0: 419A010C  beq cr6, 0x82a0a8fc
	if ctx.cr[6].eq {
	pc = 0x82A0A8FC; continue 'dispatch;
	}
	// 82A0A7F4: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82A0A7F8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0A7FC: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82A0A800: 81680024  lwz r11, 0x24(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A0A804: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A0A808: 83DF0168  lwz r30, 0x168(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A0A80C: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 82A0A810: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82A0A814: C00A9490  lfs f0, -0x6b70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0A818: 386A9490  addi r3, r10, -0x6b70
	ctx.r[3].s64 = ctx.r[10].s64 + -27504;
	// 82A0A81C: 394491A0  addi r10, r4, -0x6e60
	ctx.r[10].s64 = ctx.r[4].s64 + -28256;
	// 82A0A820: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x82A0A8FC; continue 'dispatch;
            }
            0x82A0A8FC => {
    //   block [0x82A0A8FC..0x82A0A914)
	// 82A0A8FC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A0A900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A908: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0A90C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0A918 size=876
    let mut pc: u32 = 0x82A0A918;
    'dispatch: loop {
        match pc {
            0x82A0A918 => {
    //   block [0x82A0A918..0x82A0A95C)
	// 82A0A918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A91C: 4829EAB9  bl 0x82ca93d4
	ctx.lr = 0x82A0A920;
	sub_82CA93D0(ctx, base);
	// 82A0A920: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82A0A924: 482A33B5  bl 0x82cadcd8
	ctx.lr = 0x82A0A928;
	sub_82CADCA0(ctx, base);
	// 82A0A928: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A92C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A930: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 82A0A934: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0A938: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0A93C: 419A0028  beq cr6, 0x82a0a964
	if ctx.cr[6].eq {
	pc = 0x82A0A964; continue 'dispatch;
	}
	// 82A0A940: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A0A944: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A948: 419A0014  beq cr6, 0x82a0a95c
	if ctx.cr[6].eq {
	pc = 0x82A0A95C; continue 'dispatch;
	}
	// 82A0A94C: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0A950: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0A954: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0A958: 4199000C  bgt cr6, 0x82a0a964
	if ctx.cr[6].gt {
	pc = 0x82A0A964; continue 'dispatch;
	}
	pc = 0x82A0A95C; continue 'dispatch;
            }
            0x82A0A95C => {
    //   block [0x82A0A95C..0x82A0A964)
	// 82A0A95C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82A0A960: 48000008  b 0x82a0a968
	pc = 0x82A0A968; continue 'dispatch;
            }
            0x82A0A964 => {
    //   block [0x82A0A964..0x82A0A968)
	// 82A0A964: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0A968; continue 'dispatch;
            }
            0x82A0A968 => {
    //   block [0x82A0A968..0x82A0A9D0)
	// 82A0A968: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0A96C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A970: 419A0304  beq cr6, 0x82a0ac74
	if ctx.cr[6].eq {
	pc = 0x82A0AC74; continue 'dispatch;
	}
	// 82A0A974: 897F01A9  lbz r11, 0x1a9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(425 as u32) ) } as u64;
	// 82A0A978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A97C: 419A02F8  beq cr6, 0x82a0ac74
	if ctx.cr[6].eq {
	pc = 0x82A0AC74; continue 'dispatch;
	}
	// 82A0A980: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0A984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A988: 419A02EC  beq cr6, 0x82a0ac74
	if ctx.cr[6].eq {
	pc = 0x82A0AC74; continue 'dispatch;
	}
	// 82A0A98C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0A990: 82FF0168  lwz r23, 0x168(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A0A994: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0A998: 3ACBE5F0  addi r22, r11, -0x1a10
	ctx.r[22].s64 = ctx.r[11].s64 + -6672;
	// 82A0A99C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0A9A0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A0A9A4: C02A9A80  lfs f1, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0A9A8: 4B830FF9  bl 0x8223b9a0
	ctx.lr = 0x82A0A9AC;
	sub_8223B9A0(ctx, base);
	// 82A0A9AC: 893F01A8  lbz r9, 0x1a8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82A0A9B0: 3A800110  li r20, 0x110
	ctx.r[20].s64 = 272;
	// 82A0A9B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0A9B8: 419A0018  beq cr6, 0x82a0a9d0
	if ctx.cr[6].eq {
	pc = 0x82A0A9D0; continue 'dispatch;
	}
	// 82A0A9BC: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82A0A9C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A0A9D0; continue 'dispatch;
            }
            0x82A0A9D0 => {
    //   block [0x82A0A9D0..0x82A0AC74)
	// 82A0A9D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0A9D4: 895F01B0  lbz r10, 0x1b0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A0A9D8: 3BAB9490  addi r29, r11, -0x6b70
	ctx.r[29].s64 = ctx.r[11].s64 + -27504;
	// 82A0A9DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0A9E0: C39DFFF4  lfs f28, -0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A0A9E4: 419A015C  beq cr6, 0x82a0ab40
	if ctx.cr[6].eq {
	pc = 0x82A0AB40; continue 'dispatch;
	}
	// 82A0A9E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A0A9EC: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0A9F0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0A9F4: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A0A9F8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A0A9FC: D9A10060  stfd f13, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[13].u64 ) };
	// 82A0AA00: 3BCAF1BC  addi r30, r10, -0xe44
	ctx.r[30].s64 = ctx.r[10].s64 + -3652;
	// 82A0AA04: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0AA08: 807F01D8  lwz r3, 0x1d8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82A0AA0C: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A0AA10: 393E0018  addi r9, r30, 0x18
	ctx.r[9].s64 = ctx.r[30].s64 + 24;
	// 82A0AA14: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0AA18: 7FA84C2E  lfsx f29, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A0AA1C: 4881A4FD  bl 0x83224f18
	ctx.lr = 0x82A0AA20;
	sub_83224F18(ctx, base);
	// 82A0AA20: ED810772  fmuls f12, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[29].f64) as f32) as f64);
	// 82A0AA24: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 82A0AA28: C3DE0028  lfs f30, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A0AA2C: 8167859C  lwz r11, -0x7a64(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-31332 as u32) ) } as u64;
	// 82A0AA30: 2F0B010B  cmpwi cr6, r11, 0x10b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 267, &mut ctx.xer);
	// 82A0AA34: 390BFEF5  addi r8, r11, -0x10b
	ctx.r[8].s64 = ctx.r[11].s64 + -267;
	// 82A0AA38: EDAC07B2  fmuls f13, f12, f30
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A0AA3C: 40980008  bge cr6, 0x82a0aa44
	if !ctx.cr[6].lt {
	pc = 0x82A0AA44; continue 'dispatch;
	}
	// 82A0AA40: 390B0067  addi r8, r11, 0x67
	ctx.r[8].s64 = ctx.r[11].s64 + 103;
	// 82A0AA44: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0AA48: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0AA4C: 394AF1F8  addi r10, r10, -0xe08
	ctx.r[10].s64 = ctx.r[10].s64 + -3592;
	// 82A0AA50: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0AA54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0AA58: 2F0B0172  cmpwi cr6, r11, 0x172
	ctx.cr[6].compare_i32(ctx.r[11].s32, 370, &mut ctx.xer);
	// 82A0AA5C: 7CC9502E  lwzx r6, r9, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A0AA60: 7CA8502E  lwzx r5, r8, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A0AA64: 7CA83278  xor r8, r5, r6
	ctx.r[8].u64 = ctx.r[5].u64 ^ ctx.r[6].u64;
	// 82A0AA68: 7D09512E  stwx r8, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 82A0AA6C: 41980008  blt cr6, 0x82a0aa74
	if ctx.cr[6].lt {
	pc = 0x82A0AA74; continue 'dispatch;
	}
	// 82A0AA70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0AA74: 9167859C  stw r11, -0x7a64(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-31332 as u32), ctx.r[11].u32 ) };
	// 82A0AA78: 550B023E  clrlwi r11, r8, 8
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82A0AA7C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 82A0AA80: 83DF01D8  lwz r30, 0x1d8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82A0AA84: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A0AA88: C19F00FC  lfs f12, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0AA8C: FD00601E  fctiwz f8, f12
	ctx.f[8].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A0AA90: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A0AA94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AA98: C00A5F50  lfs f0, 0x5f50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0AA9C: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0AAA0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82A0AAA4: D9010060  stfd f8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[8].u64 ) };
	// 82A0AAA8: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0AAAC: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82A0AAB0: ECE90372  fmuls f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A0AAB4: EFE70032  fmuls f31, f7, f0
	ctx.f[31].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A0AAB8: 4881A461  bl 0x83224f18
	ctx.lr = 0x82A0AABC;
	sub_83224F18(ctx, base);
	// 82A0AABC: 813F0170  lwz r9, 0x170(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0AAC0: EC0107B2  fmuls f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A0AAC4: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A0AAC8: 2F080003  cmpwi cr6, r8, 3
	ctx.cr[6].compare_i32(ctx.r[8].s32, 3, &mut ctx.xer);
	// 82A0AACC: 419A000C  beq cr6, 0x82a0aad8
	if ctx.cr[6].eq {
	pc = 0x82A0AAD8; continue 'dispatch;
	}
	// 82A0AAD0: EFFD07F2  fmuls f31, f29, f31
	ctx.f[31].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82A0AAD4: EC1D0032  fmuls f0, f29, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A0AAD8: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A0AADC: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A0AAE0: C1BF01AC  lfs f13, 0x1ac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0AAE4: 815F0154  lwz r10, 0x154(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0AAE8: C18B0044  lfs f12, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0AAEC: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A0AAF0: D01F01AC  stfs f0, 0x1ac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A0AAF4: FD60001E  fctiwz f11, f0
	ctx.f[11].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A0AAF8: D9610060  stfd f11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[11].u64 ) };
	// 82A0AAFC: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0AB00: 7D0A4A14  add r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A0AB04: 817E00C4  lwz r11, 0xc4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0AB08: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0AB0C: 40990038  ble cr6, 0x82a0ab44
	if !ctx.cr[6].gt {
	pc = 0x82A0AB44; continue 'dispatch;
	}
	// 82A0AB10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0AB14: 41980030  blt cr6, 0x82a0ab44
	if ctx.cr[6].lt {
	pc = 0x82A0AB44; continue 'dispatch;
	}
	// 82A0AB18: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0AB1C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A0AB20: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 82A0AB24: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82A0AB28: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0AB2C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A0AB30: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A0AB34: ED405828  fsubs f10, f0, f11
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82A0AB38: D15F01AC  stfs f10, 0x1ac(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A0AB3C: 48000008  b 0x82a0ab44
	pc = 0x82A0AB44; continue 'dispatch;
	// 82A0AB40: D39F01AC  stfs f28, 0x1ac(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A0AB44: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0AB48: C3FD0000  lfs f31, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0AB4C: C01F01AC  lfs f0, 0x1ac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0AB50: 3BD70004  addi r30, r23, 4
	ctx.r[30].s64 = ctx.r[23].s64 + 4;
	// 82A0AB54: EFBF0024  fdivs f29, f31, f0
	ctx.f[29].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A0AB58: 3BB70030  addi r29, r23, 0x30
	ctx.r[29].s64 = ctx.r[23].s64 + 48;
	// 82A0AB5C: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82A0AB60: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A0AB64: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A0AB68: 3B8B0030  addi r28, r11, 0x30
	ctx.r[28].s64 = ctx.r[11].s64 + 48;
	// 82A0AB6C: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0AB70: 419800F8  blt cr6, 0x82a0ac68
	if ctx.cr[6].lt {
	pc = 0x82A0AC68; continue 'dispatch;
	}
	// 82A0AB74: EB410078  ld r26, 0x78(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A0AB78: 3B1F019C  addi r24, r31, 0x19c
	ctx.r[24].s64 = ctx.r[31].s64 + 412;
	// 82A0AB7C: EB210070  ld r25, 0x70(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A0AB80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0AB84: C01F01AC  lfs f0, 0x1ac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0AB88: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A0AB8C: D1BF01AC  stfs f13, 0x1ac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A0AB90: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82A0AB94: 9ABF01DC  stb r21, 0x1dc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[21].u8 ) };
	// 82A0AB98: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A0AB9C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A0ABA0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A0ABA4: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0ABA8: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82A0ABAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0ABB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A0ABB4: 4E800421  bctrl
	ctx.lr = 0x82A0ABB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0ABB8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            0x82A0AC74 => {
    //   block [0x82A0AC74..0x82A0AC84)
	// 82A0AC74: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82A0AC78: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82A0AC7C: 482A30A9  bl 0x82cadd24
	ctx.lr = 0x82A0AC80;
	sub_82CADCEC(ctx, base);
	// 82A0AC80: 4829E7A4  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0AC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0AC88 size=1068
    let mut pc: u32 = 0x82A0AC88;
    'dispatch: loop {
        match pc {
            0x82A0AC88 => {
    //   block [0x82A0AC88..0x82A0B0B4)
	// 82A0AC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0AC8C: 4829E749  bl 0x82ca93d4
	ctx.lr = 0x82A0AC90;
	sub_82CA93D0(ctx, base);
	// 82A0AC90: DBC1FF60  stfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 82A0AC94: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 82A0AC98: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0B0B8 size=876
    let mut pc: u32 = 0x82A0B0B8;
    'dispatch: loop {
        match pc {
            0x82A0B0B8 => {
    //   block [0x82A0B0B8..0x82A0B0FC)
	// 82A0B0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B0BC: 4829E319  bl 0x82ca93d4
	ctx.lr = 0x82A0B0C0;
	sub_82CA93D0(ctx, base);
	// 82A0B0C0: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82A0B0C4: 482A2C15  bl 0x82cadcd8
	ctx.lr = 0x82A0B0C8;
	sub_82CADCA0(ctx, base);
	// 82A0B0C8: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B0CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0B0D0: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 82A0B0D4: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0B0D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0B0DC: 419A0028  beq cr6, 0x82a0b104
	if ctx.cr[6].eq {
	pc = 0x82A0B104; continue 'dispatch;
	}
	// 82A0B0E0: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A0B0E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B0E8: 419A0014  beq cr6, 0x82a0b0fc
	if ctx.cr[6].eq {
	pc = 0x82A0B0FC; continue 'dispatch;
	}
	// 82A0B0EC: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0B0F0: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0B0F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0B0F8: 4199000C  bgt cr6, 0x82a0b104
	if ctx.cr[6].gt {
	pc = 0x82A0B104; continue 'dispatch;
	}
	pc = 0x82A0B0FC; continue 'dispatch;
            }
            0x82A0B0FC => {
    //   block [0x82A0B0FC..0x82A0B104)
	// 82A0B0FC: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82A0B100: 48000008  b 0x82a0b108
	pc = 0x82A0B108; continue 'dispatch;
            }
            0x82A0B104 => {
    //   block [0x82A0B104..0x82A0B108)
	// 82A0B104: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0B108; continue 'dispatch;
            }
            0x82A0B108 => {
    //   block [0x82A0B108..0x82A0B170)
	// 82A0B108: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0B10C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B110: 419A0304  beq cr6, 0x82a0b414
	if ctx.cr[6].eq {
	pc = 0x82A0B414; continue 'dispatch;
	}
	// 82A0B114: 897F01A9  lbz r11, 0x1a9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(425 as u32) ) } as u64;
	// 82A0B118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B11C: 419A02F8  beq cr6, 0x82a0b414
	if ctx.cr[6].eq {
	pc = 0x82A0B414; continue 'dispatch;
	}
	// 82A0B120: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0B124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B128: 419A02EC  beq cr6, 0x82a0b414
	if ctx.cr[6].eq {
	pc = 0x82A0B414; continue 'dispatch;
	}
	// 82A0B12C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0B130: 82FF0168  lwz r23, 0x168(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A0B134: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0B138: 3ACBE5F0  addi r22, r11, -0x1a10
	ctx.r[22].s64 = ctx.r[11].s64 + -6672;
	// 82A0B13C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0B140: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A0B144: C02A9A80  lfs f1, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0B148: 4B830859  bl 0x8223b9a0
	ctx.lr = 0x82A0B14C;
	sub_8223B9A0(ctx, base);
	// 82A0B14C: 893F01A8  lbz r9, 0x1a8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82A0B150: 3A800110  li r20, 0x110
	ctx.r[20].s64 = 272;
	// 82A0B154: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0B158: 419A0018  beq cr6, 0x82a0b170
	if ctx.cr[6].eq {
	pc = 0x82A0B170; continue 'dispatch;
	}
	// 82A0B15C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82A0B160: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A0B170; continue 'dispatch;
            }
            0x82A0B170 => {
    //   block [0x82A0B170..0x82A0B414)
	// 82A0B170: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0B174: 895F01B0  lbz r10, 0x1b0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A0B178: 3BAB9490  addi r29, r11, -0x6b70
	ctx.r[29].s64 = ctx.r[11].s64 + -27504;
	// 82A0B17C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0B180: C39DFFF4  lfs f28, -0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A0B184: 419A015C  beq cr6, 0x82a0b2e0
	if ctx.cr[6].eq {
	pc = 0x82A0B2E0; continue 'dispatch;
	}
	// 82A0B188: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A0B18C: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0B190: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0B194: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A0B198: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A0B19C: D9A10060  stfd f13, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[13].u64 ) };
	// 82A0B1A0: 3BCAF1BC  addi r30, r10, -0xe44
	ctx.r[30].s64 = ctx.r[10].s64 + -3652;
	// 82A0B1A4: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0B1A8: 807F01D8  lwz r3, 0x1d8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82A0B1AC: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A0B1B0: 393E0018  addi r9, r30, 0x18
	ctx.r[9].s64 = ctx.r[30].s64 + 24;
	// 82A0B1B4: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0B1B8: 7FA84C2E  lfsx f29, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A0B1BC: 48819D5D  bl 0x83224f18
	ctx.lr = 0x82A0B1C0;
	sub_83224F18(ctx, base);
	// 82A0B1C0: ED810772  fmuls f12, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[29].f64) as f32) as f64);
	// 82A0B1C4: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 82A0B1C8: C3DE0028  lfs f30, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A0B1CC: 8167859C  lwz r11, -0x7a64(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-31332 as u32) ) } as u64;
	// 82A0B1D0: 2F0B010B  cmpwi cr6, r11, 0x10b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 267, &mut ctx.xer);
	// 82A0B1D4: 390BFEF5  addi r8, r11, -0x10b
	ctx.r[8].s64 = ctx.r[11].s64 + -267;
	// 82A0B1D8: EDAC07B2  fmuls f13, f12, f30
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A0B1DC: 40980008  bge cr6, 0x82a0b1e4
	if !ctx.cr[6].lt {
	pc = 0x82A0B1E4; continue 'dispatch;
	}
	// 82A0B1E0: 390B0067  addi r8, r11, 0x67
	ctx.r[8].s64 = ctx.r[11].s64 + 103;
	// 82A0B1E4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0B1E8: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0B1EC: 394AF1F8  addi r10, r10, -0xe08
	ctx.r[10].s64 = ctx.r[10].s64 + -3592;
	// 82A0B1F0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0B1F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0B1F8: 2F0B0172  cmpwi cr6, r11, 0x172
	ctx.cr[6].compare_i32(ctx.r[11].s32, 370, &mut ctx.xer);
	// 82A0B1FC: 7CC9502E  lwzx r6, r9, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A0B200: 7CA8502E  lwzx r5, r8, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A0B204: 7CA83278  xor r8, r5, r6
	ctx.r[8].u64 = ctx.r[5].u64 ^ ctx.r[6].u64;
	// 82A0B208: 7D09512E  stwx r8, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 82A0B20C: 41980008  blt cr6, 0x82a0b214
	if ctx.cr[6].lt {
	pc = 0x82A0B214; continue 'dispatch;
	}
	// 82A0B210: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B214: 9167859C  stw r11, -0x7a64(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-31332 as u32), ctx.r[11].u32 ) };
	// 82A0B218: 550B023E  clrlwi r11, r8, 8
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82A0B21C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 82A0B220: 83DF01D8  lwz r30, 0x1d8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82A0B224: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A0B228: C19F00FC  lfs f12, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0B22C: FD00601E  fctiwz f8, f12
	ctx.f[8].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A0B230: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A0B234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0B238: C00A5F50  lfs f0, 0x5f50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0B23C: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0B240: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82A0B244: D9010060  stfd f8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[8].u64 ) };
	// 82A0B248: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0B24C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82A0B250: ECE90372  fmuls f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A0B254: EFE70032  fmuls f31, f7, f0
	ctx.f[31].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A0B258: 48819CC1  bl 0x83224f18
	ctx.lr = 0x82A0B25C;
	sub_83224F18(ctx, base);
	// 82A0B25C: 813F0170  lwz r9, 0x170(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0B260: EC0107B2  fmuls f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A0B264: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A0B268: 2F080003  cmpwi cr6, r8, 3
	ctx.cr[6].compare_i32(ctx.r[8].s32, 3, &mut ctx.xer);
	// 82A0B26C: 419A000C  beq cr6, 0x82a0b278
	if ctx.cr[6].eq {
	pc = 0x82A0B278; continue 'dispatch;
	}
	// 82A0B270: EFFD07F2  fmuls f31, f29, f31
	ctx.f[31].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82A0B274: EC1D0032  fmuls f0, f29, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A0B278: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A0B27C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A0B280: C1BF01AC  lfs f13, 0x1ac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0B284: 815F0154  lwz r10, 0x154(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0B288: C18B0044  lfs f12, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0B28C: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A0B290: D01F01AC  stfs f0, 0x1ac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A0B294: FD60001E  fctiwz f11, f0
	ctx.f[11].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A0B298: D9610060  stfd f11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[11].u64 ) };
	// 82A0B29C: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0B2A0: 7D0A4A14  add r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A0B2A4: 817E00C4  lwz r11, 0xc4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0B2A8: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0B2AC: 40990038  ble cr6, 0x82a0b2e4
	if !ctx.cr[6].gt {
	pc = 0x82A0B2E4; continue 'dispatch;
	}
	// 82A0B2B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0B2B4: 41980030  blt cr6, 0x82a0b2e4
	if ctx.cr[6].lt {
	pc = 0x82A0B2E4; continue 'dispatch;
	}
	// 82A0B2B8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0B2BC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A0B2C0: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 82A0B2C4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82A0B2C8: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0B2CC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A0B2D0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A0B2D4: ED405828  fsubs f10, f0, f11
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82A0B2D8: D15F01AC  stfs f10, 0x1ac(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A0B2DC: 48000008  b 0x82a0b2e4
	pc = 0x82A0B2E4; continue 'dispatch;
	// 82A0B2E0: D39F01AC  stfs f28, 0x1ac(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A0B2E4: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A0B2E8: C3FD0000  lfs f31, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0B2EC: C01F01AC  lfs f0, 0x1ac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0B2F0: 3BD70004  addi r30, r23, 4
	ctx.r[30].s64 = ctx.r[23].s64 + 4;
	// 82A0B2F4: EFBF0024  fdivs f29, f31, f0
	ctx.f[29].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A0B2F8: 3BB7002C  addi r29, r23, 0x2c
	ctx.r[29].s64 = ctx.r[23].s64 + 44;
	// 82A0B2FC: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82A0B300: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A0B304: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A0B308: 3B8B0030  addi r28, r11, 0x30
	ctx.r[28].s64 = ctx.r[11].s64 + 48;
	// 82A0B30C: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0B310: 419800F8  blt cr6, 0x82a0b408
	if ctx.cr[6].lt {
	pc = 0x82A0B408; continue 'dispatch;
	}
	// 82A0B314: EB410078  ld r26, 0x78(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A0B318: 3B1F019C  addi r24, r31, 0x19c
	ctx.r[24].s64 = ctx.r[31].s64 + 412;
	// 82A0B31C: EB210070  ld r25, 0x70(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A0B320: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B324: C01F01AC  lfs f0, 0x1ac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0B328: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A0B32C: D1BF01AC  stfs f13, 0x1ac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A0B330: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82A0B334: 9ABF01DC  stb r21, 0x1dc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[21].u8 ) };
	// 82A0B338: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A0B33C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A0B340: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A0B344: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0B348: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82A0B34C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B350: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A0B354: 4E800421  bctrl
	ctx.lr = 0x82A0B358;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0B358: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            0x82A0B414 => {
    //   block [0x82A0B414..0x82A0B424)
	// 82A0B414: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82A0B418: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82A0B41C: 482A2909  bl 0x82cadd24
	ctx.lr = 0x82A0B420;
	sub_82CADCEC(ctx, base);
	// 82A0B420: 4829E004  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0B428 size=1124
    let mut pc: u32 = 0x82A0B428;
    'dispatch: loop {
        match pc {
            0x82A0B428 => {
    //   block [0x82A0B428..0x82A0B88C)
	// 82A0B428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B42C: 4829DFA5  bl 0x82ca93d0
	ctx.lr = 0x82A0B430;
	sub_82CA93D0(ctx, base);
	// 82A0B430: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 82A0B434: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 82A0B438: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0B890 size=832
    let mut pc: u32 = 0x82A0B890;
    'dispatch: loop {
        match pc {
            0x82A0B890 => {
    //   block [0x82A0B890..0x82A0B8D4)
	// 82A0B890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B894: 4829DB61  bl 0x82ca93f4
	ctx.lr = 0x82A0B898;
	sub_82CA93D0(ctx, base);
	// 82A0B898: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B89C: F8810218  std r4, 0x218(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), ctx.r[4].u64 ) };
	// 82A0B8A0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A0B8A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0B8A8: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0B8AC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A0B8B0: 4829DBD1  bl 0x82ca9480
	ctx.lr = 0x82A0B8B4;
	sub_82CA9480(ctx, base);
	// 82A0B8B4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A0B8B8: 3AE00160  li r23, 0x160
	ctx.r[23].s64 = 352;
	// 82A0B8BC: 3B2B1A90  addi r25, r11, 0x1a90
	ctx.r[25].s64 = ctx.r[11].s64 + 6800;
	// 82A0B8C0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0B8C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B8C8: 409A000C  bne cr6, 0x82a0b8d4
	if !ctx.cr[6].eq {
	pc = 0x82A0B8D4; continue 'dispatch;
	}
	// 82A0B8CC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0B8D0: 48000010  b 0x82a0b8e0
	pc = 0x82A0B8E0; continue 'dispatch;
            }
            0x82A0B8D4 => {
    //   block [0x82A0B8D4..0x82A0B8E0)
	// 82A0B8D4: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0B8D8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0B8DC: 7D2ABBD6  divw r9, r10, r23
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	pc = 0x82A0B8E0; continue 'dispatch;
            }
            0x82A0B8E0 => {
    //   block [0x82A0B8E0..0x82A0B914)
	// 82A0B8E0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0B8E4: 419A02E4  beq cr6, 0x82a0bbc8
	if ctx.cr[6].eq {
	pc = 0x82A0BBC8; continue 'dispatch;
	}
	// 82A0B8E8: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0B8EC: 3D4000BA  lis r10, 0xba
	ctx.r[10].s64 = 12189696;
	// 82A0B8F0: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A0B8F4: 614A2E8B  ori r10, r10, 0x2e8b
	ctx.r[10].u64 = ctx.r[10].u64 | 11915;
	// 82A0B8F8: 7D68BBD6  divw r11, r8, r23
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[23].s32;
	// 82A0B8FC: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0B900: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0B904: 40980010  bge cr6, 0x82a0b914
	if !ctx.cr[6].lt {
	pc = 0x82A0B914; continue 'dispatch;
	}
	// 82A0B908: 4803BBC1  bl 0x82a474c8
	ctx.lr = 0x82A0B90C;
	sub_82A474C8(ctx, base);
	// 82A0B90C: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82A0B910: 4829DB34  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0B914 => {
    //   block [0x82A0B914..0x82A0B938)
	// 82A0B914: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A0B918: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0B91C: 40980144  bge cr6, 0x82a0ba60
	if !ctx.cr[6].lt {
	pc = 0x82A0BA60; continue 'dispatch;
	}
	// 82A0B920: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0B924: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A0B928: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0B92C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0B930: 41980008  blt cr6, 0x82a0b938
	if ctx.cr[6].lt {
	pc = 0x82A0B938; continue 'dispatch;
	}
	// 82A0B934: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A0B938; continue 'dispatch;
            }
            0x82A0B938 => {
    //   block [0x82A0B938..0x82A0B944)
	// 82A0B938: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0B93C: 40980008  bge cr6, 0x82a0b944
	if !ctx.cr[6].lt {
	pc = 0x82A0B944; continue 'dispatch;
	}
	// 82A0B940: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x82A0B944; continue 'dispatch;
            }
            0x82A0B944 => {
    //   block [0x82A0B944..0x82A0B96C)
	// 82A0B944: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A0B948: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A0B94C: 48000C45  bl 0x82a0c590
	ctx.lr = 0x82A0B950;
	sub_82A0C590(ctx, base);
	// 82A0B950: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0B954: 8381021C  lwz r28, 0x21c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82A0B958: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0B95C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A0B960: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82A0B964: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0B968: 419A0030  beq cr6, 0x82a0b998
	if ctx.cr[6].eq {
	pc = 0x82A0B998; continue 'dispatch;
	}
	pc = 0x82A0B96C; continue 'dispatch;
            }
            0x82A0B96C => {
    //   block [0x82A0B96C..0x82A0B984)
	// 82A0B96C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0B970: 419A0014  beq cr6, 0x82a0b984
	if ctx.cr[6].eq {
	pc = 0x82A0B984; continue 'dispatch;
	}
	// 82A0B974: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0B978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0B97C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0B980: 4829DB01  bl 0x82ca9480
	ctx.lr = 0x82A0B984;
	sub_82CA9480(ctx, base);
	pc = 0x82A0B984; continue 'dispatch;
            }
            0x82A0B984 => {
    //   block [0x82A0B984..0x82A0B998)
	// 82A0B984: 3BFF0160  addi r31, r31, 0x160
	ctx.r[31].s64 = ctx.r[31].s64 + 352;
	// 82A0B988: 3BDE0160  addi r30, r30, 0x160
	ctx.r[30].s64 = ctx.r[30].s64 + 352;
	// 82A0B98C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0B990: 409AFFDC  bne cr6, 0x82a0b96c
	if !ctx.cr[6].eq {
	pc = 0x82A0B96C; continue 'dispatch;
	}
	// 82A0B994: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0B998; continue 'dispatch;
            }
            0x82A0B998 => {
    //   block [0x82A0B998..0x82A0B9A8)
	// 82A0B998: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A0B99C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A0B9A0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0B9A4: 419A002C  beq cr6, 0x82a0b9d0
	if ctx.cr[6].eq {
	pc = 0x82A0B9D0; continue 'dispatch;
	}
	pc = 0x82A0B9A8; continue 'dispatch;
            }
            0x82A0B9A8 => {
    //   block [0x82A0B9A8..0x82A0B9C0)
	// 82A0B9A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B9AC: 419A0014  beq cr6, 0x82a0b9c0
	if ctx.cr[6].eq {
	pc = 0x82A0B9C0; continue 'dispatch;
	}
	// 82A0B9B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0B9B4: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0B9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B9BC: 4829DAC5  bl 0x82ca9480
	ctx.lr = 0x82A0B9C0;
	sub_82CA9480(ctx, base);
	pc = 0x82A0B9C0; continue 'dispatch;
            }
            0x82A0B9C0 => {
    //   block [0x82A0B9C0..0x82A0B9D0)
	// 82A0B9C0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0B9C4: 3BFF0160  addi r31, r31, 0x160
	ctx.r[31].s64 = ctx.r[31].s64 + 352;
	// 82A0B9C8: 4082FFE0  bne 0x82a0b9a8
	if !ctx.cr[0].eq {
	pc = 0x82A0B9A8; continue 'dispatch;
	}
	// 82A0B9CC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0B9D0; continue 'dispatch;
            }
            0x82A0B9D0 => {
    //   block [0x82A0B9D0..0x82A0B9F0)
	// 82A0B9D0: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0B9D4: 1D5A0160  mulli r10, r26, 0x160
	ctx.r[10].s32 = ((ctx.r[26].s32 as i64 * 352 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A0B9D8: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A0B9DC: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0B9E0: 419A0040  beq cr6, 0x82a0ba20
	if ctx.cr[6].eq {
	pc = 0x82A0BA20; continue 'dispatch;
	}
	// 82A0B9E4: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A0B9E8: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A0B9EC: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82A0B9F0; continue 'dispatch;
            }
            0x82A0B9F0 => {
    //   block [0x82A0B9F0..0x82A0BA08)
	// 82A0B9F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B9F4: 419A0014  beq cr6, 0x82a0ba08
	if ctx.cr[6].eq {
	pc = 0x82A0BA08; continue 'dispatch;
	}
	// 82A0B9F8: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0B9FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0BA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BA04: 4829DA7D  bl 0x82ca9480
	ctx.lr = 0x82A0BA08;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BA08; continue 'dispatch;
            }
            0x82A0BA08 => {
    //   block [0x82A0BA08..0x82A0BA20)
	// 82A0BA08: 3BDE0160  addi r30, r30, 0x160
	ctx.r[30].s64 = ctx.r[30].s64 + 352;
	// 82A0BA0C: 3BFF0160  addi r31, r31, 0x160
	ctx.r[31].s64 = ctx.r[31].s64 + 352;
	// 82A0BA10: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0BA14: 409AFFDC  bne cr6, 0x82a0b9f0
	if !ctx.cr[6].eq {
	pc = 0x82A0B9F0; continue 'dispatch;
	}
	// 82A0BA18: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0BA1C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0BA20; continue 'dispatch;
            }
            0x82A0BA20 => {
    //   block [0x82A0BA20..0x82A0BA3C)
	// 82A0BA20: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A0BA24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0BA28: 7D4ABBD6  divw r10, r10, r23
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 82A0BA2C: 7FEAD214  add r31, r10, r26
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82A0BA30: 419A000C  beq cr6, 0x82a0ba3c
	if ctx.cr[6].eq {
	pc = 0x82A0BA3C; continue 'dispatch;
	}
	// 82A0BA34: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A0BA38: 4B810301  bl 0x8221bd38
	ctx.lr = 0x82A0BA3C;
	sub_8221BD38(ctx, base);
	pc = 0x82A0BA3C; continue 'dispatch;
            }
            0x82A0BA3C => {
    //   block [0x82A0BA3C..0x82A0BA60)
	// 82A0BA3C: 1D780160  mulli r11, r24, 0x160
	ctx.r[11].s32 = ((ctx.r[24].s32 as i64 * 352 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A0BA40: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A0BA44: 1D5F0160  mulli r10, r31, 0x160
	ctx.r[10].s32 = ((ctx.r[31].s32 as i64 * 352 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A0BA48: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A0BA4C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A0BA50: 9179000C  stw r11, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0BA54: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0BA58: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82A0BA5C: 4829D9E8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0BA60 => {
    //   block [0x82A0BA60..0x82A0BA88)
	// 82A0BA60: 8361021C  lwz r27, 0x21c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82A0BA64: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0BA68: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A0BA6C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0BA70: 409800B8  bge cr6, 0x82a0bb28
	if !ctx.cr[6].lt {
	pc = 0x82A0BB28; continue 'dispatch;
	}
	// 82A0BA74: 1F9A0160  mulli r28, r26, 0x160
	ctx.r[28].s32 = ((ctx.r[26].s32 as i64 * 352 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82A0BA78: 7FDCDA14  add r30, r28, r27
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82A0BA7C: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0BA80: 419A0034  beq cr6, 0x82a0bab4
	if ctx.cr[6].eq {
	pc = 0x82A0BAB4; continue 'dispatch;
	}
	// 82A0BA84: 7FBCF050  subf r29, r28, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	pc = 0x82A0BA88; continue 'dispatch;
            }
            0x82A0BA88 => {
    //   block [0x82A0BA88..0x82A0BAA0)
	// 82A0BA88: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0BA8C: 419A0014  beq cr6, 0x82a0baa0
	if ctx.cr[6].eq {
	pc = 0x82A0BAA0; continue 'dispatch;
	}
	// 82A0BA90: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0BA94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0BA98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BA9C: 4829D9E5  bl 0x82ca9480
	ctx.lr = 0x82A0BAA0;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BAA0; continue 'dispatch;
            }
            0x82A0BAA0 => {
    //   block [0x82A0BAA0..0x82A0BAB4)
	// 82A0BAA0: 3BBD0160  addi r29, r29, 0x160
	ctx.r[29].s64 = ctx.r[29].s64 + 352;
	// 82A0BAA4: 3BDE0160  addi r30, r30, 0x160
	ctx.r[30].s64 = ctx.r[30].s64 + 352;
	// 82A0BAA8: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0BAAC: 409AFFDC  bne cr6, 0x82a0ba88
	if !ctx.cr[6].eq {
	pc = 0x82A0BA88; continue 'dispatch;
	}
	// 82A0BAB0: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0BAB4; continue 'dispatch;
            }
            0x82A0BAB4 => {
    //   block [0x82A0BAB4..0x82A0BAC4)
	// 82A0BAB4: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0BAB8: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A0BABC: 7FCAD051  subf. r30, r10, r26
	ctx.r[30].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0BAC0: 4182002C  beq 0x82a0baec
	if ctx.cr[0].eq {
	pc = 0x82A0BAEC; continue 'dispatch;
	}
	pc = 0x82A0BAC4; continue 'dispatch;
            }
            0x82A0BAC4 => {
    //   block [0x82A0BAC4..0x82A0BADC)
	// 82A0BAC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BAC8: 419A0014  beq cr6, 0x82a0badc
	if ctx.cr[6].eq {
	pc = 0x82A0BADC; continue 'dispatch;
	}
	// 82A0BACC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0BAD0: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0BAD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BAD8: 4829D9A9  bl 0x82ca9480
	ctx.lr = 0x82A0BADC;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BADC; continue 'dispatch;
            }
            0x82A0BADC => {
    //   block [0x82A0BADC..0x82A0BAEC)
	// 82A0BADC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0BAE0: 3BFF0160  addi r31, r31, 0x160
	ctx.r[31].s64 = ctx.r[31].s64 + 352;
	// 82A0BAE4: 4082FFE0  bne 0x82a0bac4
	if !ctx.cr[0].eq {
	pc = 0x82A0BAC4; continue 'dispatch;
	}
	// 82A0BAE8: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0BAEC; continue 'dispatch;
            }
            0x82A0BAEC => {
    //   block [0x82A0BAEC..0x82A0BB04)
	// 82A0BAEC: 7D7CFA14  add r11, r28, r31
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 82A0BAF0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0BAF4: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82A0BAF8: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0BAFC: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0BB00: 419A00C8  beq cr6, 0x82a0bbc8
	if ctx.cr[6].eq {
	pc = 0x82A0BBC8; continue 'dispatch;
	}
	pc = 0x82A0BB04; continue 'dispatch;
            }
            0x82A0BB04 => {
    //   block [0x82A0BB04..0x82A0BB28)
	// 82A0BB04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0BB08: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0BB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BB10: 4829D971  bl 0x82ca9480
	ctx.lr = 0x82A0BB14;
	sub_82CA9480(ctx, base);
	// 82A0BB14: 3BFF0160  addi r31, r31, 0x160
	ctx.r[31].s64 = ctx.r[31].s64 + 352;
	// 82A0BB18: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0BB1C: 409AFFE8  bne cr6, 0x82a0bb04
	if !ctx.cr[6].eq {
	pc = 0x82A0BB04; continue 'dispatch;
	}
	// 82A0BB20: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82A0BB24: 4829D920  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0BB28 => {
    //   block [0x82A0BB28..0x82A0BB40)
	// 82A0BB28: 1F5A0160  mulli r26, r26, 0x160
	ctx.r[26].s32 = ((ctx.r[26].s32 as i64 * 352 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	// 82A0BB2C: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A0BB30: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A0BB34: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A0BB38: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0BB3C: 419A002C  beq cr6, 0x82a0bb68
	if ctx.cr[6].eq {
	pc = 0x82A0BB68; continue 'dispatch;
	}
	pc = 0x82A0BB40; continue 'dispatch;
            }
            0x82A0BB40 => {
    //   block [0x82A0BB40..0x82A0BB58)
	// 82A0BB40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0BB44: 419A0014  beq cr6, 0x82a0bb58
	if ctx.cr[6].eq {
	pc = 0x82A0BB58; continue 'dispatch;
	}
	// 82A0BB48: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0BB4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0BB50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BB54: 4829D92D  bl 0x82ca9480
	ctx.lr = 0x82A0BB58;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BB58; continue 'dispatch;
            }
            0x82A0BB58 => {
    //   block [0x82A0BB58..0x82A0BB68)
	// 82A0BB58: 3BBD0160  addi r29, r29, 0x160
	ctx.r[29].s64 = ctx.r[29].s64 + 352;
	// 82A0BB5C: 3BDE0160  addi r30, r30, 0x160
	ctx.r[30].s64 = ctx.r[30].s64 + 352;
	// 82A0BB60: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0BB64: 409AFFDC  bne cr6, 0x82a0bb40
	if !ctx.cr[6].eq {
	pc = 0x82A0BB40; continue 'dispatch;
	}
	pc = 0x82A0BB68; continue 'dispatch;
            }
            0x82A0BB68 => {
    //   block [0x82A0BB68..0x82A0BB7C)
	// 82A0BB68: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A0BB6C: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A0BB70: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0BB74: 419A0028  beq cr6, 0x82a0bb9c
	if ctx.cr[6].eq {
	pc = 0x82A0BB9C; continue 'dispatch;
	}
	// 82A0BB78: 7FDAFA14  add r30, r26, r31
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	pc = 0x82A0BB7C; continue 'dispatch;
            }
            0x82A0BB7C => {
    //   block [0x82A0BB7C..0x82A0BB9C)
	// 82A0BB7C: 3BFFFEA0  addi r31, r31, -0x160
	ctx.r[31].s64 = ctx.r[31].s64 + -352;
	// 82A0BB80: 3BDEFEA0  addi r30, r30, -0x160
	ctx.r[30].s64 = ctx.r[30].s64 + -352;
	// 82A0BB84: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0BB88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BB8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BB90: 4829D8F1  bl 0x82ca9480
	ctx.lr = 0x82A0BB94;
	sub_82CA9480(ctx, base);
	// 82A0BB94: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0BB98: 409AFFE4  bne cr6, 0x82a0bb7c
	if !ctx.cr[6].eq {
	pc = 0x82A0BB7C; continue 'dispatch;
	}
	pc = 0x82A0BB9C; continue 'dispatch;
            }
            0x82A0BB9C => {
    //   block [0x82A0BB9C..0x82A0BBAC)
	// 82A0BB9C: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82A0BBA0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0BBA4: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0BBA8: 419A0020  beq cr6, 0x82a0bbc8
	if ctx.cr[6].eq {
	pc = 0x82A0BBC8; continue 'dispatch;
	}
	pc = 0x82A0BBAC; continue 'dispatch;
            }
            0x82A0BBAC => {
    //   block [0x82A0BBAC..0x82A0BBC8)
	// 82A0BBAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0BBB0: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 82A0BBB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BBB8: 4829D8C9  bl 0x82ca9480
	ctx.lr = 0x82A0BBBC;
	sub_82CA9480(ctx, base);
	// 82A0BBBC: 3BFF0160  addi r31, r31, 0x160
	ctx.r[31].s64 = ctx.r[31].s64 + 352;
	// 82A0BBC0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0BBC4: 409AFFE8  bne cr6, 0x82a0bbac
	if !ctx.cr[6].eq {
	pc = 0x82A0BBAC; continue 'dispatch;
	}
	pc = 0x82A0BBC8; continue 'dispatch;
            }
            0x82A0BBC8 => {
    //   block [0x82A0BBC8..0x82A0BBD0)
	// 82A0BBC8: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82A0BBCC: 4829D878  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0BBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0BBD0 size=832
    let mut pc: u32 = 0x82A0BBD0;
    'dispatch: loop {
        match pc {
            0x82A0BBD0 => {
    //   block [0x82A0BBD0..0x82A0BC14)
	// 82A0BBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0BBD4: 4829D821  bl 0x82ca93f4
	ctx.lr = 0x82A0BBD8;
	sub_82CA93D0(ctx, base);
	// 82A0BBD8: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0BBDC: F8810188  std r4, 0x188(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[4].u64 ) };
	// 82A0BBE0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A0BBE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0BBE8: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BBEC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A0BBF0: 4829D891  bl 0x82ca9480
	ctx.lr = 0x82A0BBF4;
	sub_82CA9480(ctx, base);
	// 82A0BBF4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A0BBF8: 3AE000D0  li r23, 0xd0
	ctx.r[23].s64 = 208;
	// 82A0BBFC: 3B2B1A80  addi r25, r11, 0x1a80
	ctx.r[25].s64 = ctx.r[11].s64 + 6784;
	// 82A0BC00: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0BC04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0BC08: 409A000C  bne cr6, 0x82a0bc14
	if !ctx.cr[6].eq {
	pc = 0x82A0BC14; continue 'dispatch;
	}
	// 82A0BC0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0BC10: 48000010  b 0x82a0bc20
	pc = 0x82A0BC20; continue 'dispatch;
            }
            0x82A0BC14 => {
    //   block [0x82A0BC14..0x82A0BC20)
	// 82A0BC14: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0BC18: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0BC1C: 7D2ABBD6  divw r9, r10, r23
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	pc = 0x82A0BC20; continue 'dispatch;
            }
            0x82A0BC20 => {
    //   block [0x82A0BC20..0x82A0BC54)
	// 82A0BC20: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0BC24: 419A02E4  beq cr6, 0x82a0bf08
	if ctx.cr[6].eq {
	pc = 0x82A0BF08; continue 'dispatch;
	}
	// 82A0BC28: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0BC2C: 3D40013B  lis r10, 0x13b
	ctx.r[10].s64 = 20643840;
	// 82A0BC30: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A0BC34: 614A13B1  ori r10, r10, 0x13b1
	ctx.r[10].u64 = ctx.r[10].u64 | 5041;
	// 82A0BC38: 7D68BBD6  divw r11, r8, r23
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[23].s32;
	// 82A0BC3C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0BC40: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0BC44: 40980010  bge cr6, 0x82a0bc54
	if !ctx.cr[6].lt {
	pc = 0x82A0BC54; continue 'dispatch;
	}
	// 82A0BC48: 4803B881  bl 0x82a474c8
	ctx.lr = 0x82A0BC4C;
	sub_82A474C8(ctx, base);
	// 82A0BC4C: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82A0BC50: 4829D7F4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0BC54 => {
    //   block [0x82A0BC54..0x82A0BC78)
	// 82A0BC54: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A0BC58: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0BC5C: 40980144  bge cr6, 0x82a0bda0
	if !ctx.cr[6].lt {
	pc = 0x82A0BDA0; continue 'dispatch;
	}
	// 82A0BC60: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0BC64: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A0BC68: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0BC6C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0BC70: 41980008  blt cr6, 0x82a0bc78
	if ctx.cr[6].lt {
	pc = 0x82A0BC78; continue 'dispatch;
	}
	// 82A0BC74: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A0BC78; continue 'dispatch;
            }
            0x82A0BC78 => {
    //   block [0x82A0BC78..0x82A0BC84)
	// 82A0BC78: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0BC7C: 40980008  bge cr6, 0x82a0bc84
	if !ctx.cr[6].lt {
	pc = 0x82A0BC84; continue 'dispatch;
	}
	// 82A0BC80: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x82A0BC84; continue 'dispatch;
            }
            0x82A0BC84 => {
    //   block [0x82A0BC84..0x82A0BCAC)
	// 82A0BC84: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A0BC88: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A0BC8C: 48000975  bl 0x82a0c600
	ctx.lr = 0x82A0BC90;
	sub_82A0C600(ctx, base);
	// 82A0BC90: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0BC94: 8381018C  lwz r28, 0x18c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 82A0BC98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0BC9C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A0BCA0: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82A0BCA4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0BCA8: 419A0030  beq cr6, 0x82a0bcd8
	if ctx.cr[6].eq {
	pc = 0x82A0BCD8; continue 'dispatch;
	}
	pc = 0x82A0BCAC; continue 'dispatch;
            }
            0x82A0BCAC => {
    //   block [0x82A0BCAC..0x82A0BCC4)
	// 82A0BCAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0BCB0: 419A0014  beq cr6, 0x82a0bcc4
	if ctx.cr[6].eq {
	pc = 0x82A0BCC4; continue 'dispatch;
	}
	// 82A0BCB4: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BCB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BCBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BCC0: 4829D7C1  bl 0x82ca9480
	ctx.lr = 0x82A0BCC4;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BCC4; continue 'dispatch;
            }
            0x82A0BCC4 => {
    //   block [0x82A0BCC4..0x82A0BCD8)
	// 82A0BCC4: 3BFF00D0  addi r31, r31, 0xd0
	ctx.r[31].s64 = ctx.r[31].s64 + 208;
	// 82A0BCC8: 3BDE00D0  addi r30, r30, 0xd0
	ctx.r[30].s64 = ctx.r[30].s64 + 208;
	// 82A0BCCC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0BCD0: 409AFFDC  bne cr6, 0x82a0bcac
	if !ctx.cr[6].eq {
	pc = 0x82A0BCAC; continue 'dispatch;
	}
	// 82A0BCD4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0BCD8; continue 'dispatch;
            }
            0x82A0BCD8 => {
    //   block [0x82A0BCD8..0x82A0BCE8)
	// 82A0BCD8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A0BCDC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A0BCE0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0BCE4: 419A002C  beq cr6, 0x82a0bd10
	if ctx.cr[6].eq {
	pc = 0x82A0BD10; continue 'dispatch;
	}
	pc = 0x82A0BCE8; continue 'dispatch;
            }
            0x82A0BCE8 => {
    //   block [0x82A0BCE8..0x82A0BD00)
	// 82A0BCE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BCEC: 419A0014  beq cr6, 0x82a0bd00
	if ctx.cr[6].eq {
	pc = 0x82A0BD00; continue 'dispatch;
	}
	// 82A0BCF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0BCF4: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BCF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BCFC: 4829D785  bl 0x82ca9480
	ctx.lr = 0x82A0BD00;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BD00; continue 'dispatch;
            }
            0x82A0BD00 => {
    //   block [0x82A0BD00..0x82A0BD10)
	// 82A0BD00: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0BD04: 3BFF00D0  addi r31, r31, 0xd0
	ctx.r[31].s64 = ctx.r[31].s64 + 208;
	// 82A0BD08: 4082FFE0  bne 0x82a0bce8
	if !ctx.cr[0].eq {
	pc = 0x82A0BCE8; continue 'dispatch;
	}
	// 82A0BD0C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0BD10; continue 'dispatch;
            }
            0x82A0BD10 => {
    //   block [0x82A0BD10..0x82A0BD30)
	// 82A0BD10: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0BD14: 1D5A00D0  mulli r10, r26, 0xd0
	ctx.r[10].s32 = ((ctx.r[26].s32 as i64 * 208 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A0BD18: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A0BD1C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0BD20: 419A0040  beq cr6, 0x82a0bd60
	if ctx.cr[6].eq {
	pc = 0x82A0BD60; continue 'dispatch;
	}
	// 82A0BD24: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A0BD28: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A0BD2C: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82A0BD30; continue 'dispatch;
            }
            0x82A0BD30 => {
    //   block [0x82A0BD30..0x82A0BD48)
	// 82A0BD30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BD34: 419A0014  beq cr6, 0x82a0bd48
	if ctx.cr[6].eq {
	pc = 0x82A0BD48; continue 'dispatch;
	}
	// 82A0BD38: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BD3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0BD40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BD44: 4829D73D  bl 0x82ca9480
	ctx.lr = 0x82A0BD48;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BD48; continue 'dispatch;
            }
            0x82A0BD48 => {
    //   block [0x82A0BD48..0x82A0BD60)
	// 82A0BD48: 3BDE00D0  addi r30, r30, 0xd0
	ctx.r[30].s64 = ctx.r[30].s64 + 208;
	// 82A0BD4C: 3BFF00D0  addi r31, r31, 0xd0
	ctx.r[31].s64 = ctx.r[31].s64 + 208;
	// 82A0BD50: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0BD54: 409AFFDC  bne cr6, 0x82a0bd30
	if !ctx.cr[6].eq {
	pc = 0x82A0BD30; continue 'dispatch;
	}
	// 82A0BD58: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0BD5C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0BD60; continue 'dispatch;
            }
            0x82A0BD60 => {
    //   block [0x82A0BD60..0x82A0BD7C)
	// 82A0BD60: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A0BD64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0BD68: 7D4ABBD6  divw r10, r10, r23
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 82A0BD6C: 7FEAD214  add r31, r10, r26
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82A0BD70: 419A000C  beq cr6, 0x82a0bd7c
	if ctx.cr[6].eq {
	pc = 0x82A0BD7C; continue 'dispatch;
	}
	// 82A0BD74: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A0BD78: 4B80FFC1  bl 0x8221bd38
	ctx.lr = 0x82A0BD7C;
	sub_8221BD38(ctx, base);
	pc = 0x82A0BD7C; continue 'dispatch;
            }
            0x82A0BD7C => {
    //   block [0x82A0BD7C..0x82A0BDA0)
	// 82A0BD7C: 1D7800D0  mulli r11, r24, 0xd0
	ctx.r[11].s32 = ((ctx.r[24].s32 as i64 * 208 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A0BD80: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A0BD84: 1D5F00D0  mulli r10, r31, 0xd0
	ctx.r[10].s32 = ((ctx.r[31].s32 as i64 * 208 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A0BD88: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A0BD8C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A0BD90: 9179000C  stw r11, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0BD94: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0BD98: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82A0BD9C: 4829D6A8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0BDA0 => {
    //   block [0x82A0BDA0..0x82A0BDC8)
	// 82A0BDA0: 8361018C  lwz r27, 0x18c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 82A0BDA4: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0BDA8: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A0BDAC: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0BDB0: 409800B8  bge cr6, 0x82a0be68
	if !ctx.cr[6].lt {
	pc = 0x82A0BE68; continue 'dispatch;
	}
	// 82A0BDB4: 1F9A00D0  mulli r28, r26, 0xd0
	ctx.r[28].s32 = ((ctx.r[26].s32 as i64 * 208 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82A0BDB8: 7FDCDA14  add r30, r28, r27
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82A0BDBC: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0BDC0: 419A0034  beq cr6, 0x82a0bdf4
	if ctx.cr[6].eq {
	pc = 0x82A0BDF4; continue 'dispatch;
	}
	// 82A0BDC4: 7FBCF050  subf r29, r28, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	pc = 0x82A0BDC8; continue 'dispatch;
            }
            0x82A0BDC8 => {
    //   block [0x82A0BDC8..0x82A0BDE0)
	// 82A0BDC8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0BDCC: 419A0014  beq cr6, 0x82a0bde0
	if ctx.cr[6].eq {
	pc = 0x82A0BDE0; continue 'dispatch;
	}
	// 82A0BDD0: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BDD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0BDD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BDDC: 4829D6A5  bl 0x82ca9480
	ctx.lr = 0x82A0BDE0;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BDE0; continue 'dispatch;
            }
            0x82A0BDE0 => {
    //   block [0x82A0BDE0..0x82A0BDF4)
	// 82A0BDE0: 3BBD00D0  addi r29, r29, 0xd0
	ctx.r[29].s64 = ctx.r[29].s64 + 208;
	// 82A0BDE4: 3BDE00D0  addi r30, r30, 0xd0
	ctx.r[30].s64 = ctx.r[30].s64 + 208;
	// 82A0BDE8: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0BDEC: 409AFFDC  bne cr6, 0x82a0bdc8
	if !ctx.cr[6].eq {
	pc = 0x82A0BDC8; continue 'dispatch;
	}
	// 82A0BDF0: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0BDF4; continue 'dispatch;
            }
            0x82A0BDF4 => {
    //   block [0x82A0BDF4..0x82A0BE04)
	// 82A0BDF4: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0BDF8: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A0BDFC: 7FCAD051  subf. r30, r10, r26
	ctx.r[30].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0BE00: 4182002C  beq 0x82a0be2c
	if ctx.cr[0].eq {
	pc = 0x82A0BE2C; continue 'dispatch;
	}
	pc = 0x82A0BE04; continue 'dispatch;
            }
            0x82A0BE04 => {
    //   block [0x82A0BE04..0x82A0BE1C)
	// 82A0BE04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BE08: 419A0014  beq cr6, 0x82a0be1c
	if ctx.cr[6].eq {
	pc = 0x82A0BE1C; continue 'dispatch;
	}
	// 82A0BE0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0BE10: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BE14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BE18: 4829D669  bl 0x82ca9480
	ctx.lr = 0x82A0BE1C;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BE1C; continue 'dispatch;
            }
            0x82A0BE1C => {
    //   block [0x82A0BE1C..0x82A0BE2C)
	// 82A0BE1C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0BE20: 3BFF00D0  addi r31, r31, 0xd0
	ctx.r[31].s64 = ctx.r[31].s64 + 208;
	// 82A0BE24: 4082FFE0  bne 0x82a0be04
	if !ctx.cr[0].eq {
	pc = 0x82A0BE04; continue 'dispatch;
	}
	// 82A0BE28: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0BE2C; continue 'dispatch;
            }
            0x82A0BE2C => {
    //   block [0x82A0BE2C..0x82A0BE44)
	// 82A0BE2C: 7D7CFA14  add r11, r28, r31
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 82A0BE30: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0BE34: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82A0BE38: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0BE3C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0BE40: 419A00C8  beq cr6, 0x82a0bf08
	if ctx.cr[6].eq {
	pc = 0x82A0BF08; continue 'dispatch;
	}
	pc = 0x82A0BE44; continue 'dispatch;
            }
            0x82A0BE44 => {
    //   block [0x82A0BE44..0x82A0BE68)
	// 82A0BE44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0BE48: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BE4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BE50: 4829D631  bl 0x82ca9480
	ctx.lr = 0x82A0BE54;
	sub_82CA9480(ctx, base);
	// 82A0BE54: 3BFF00D0  addi r31, r31, 0xd0
	ctx.r[31].s64 = ctx.r[31].s64 + 208;
	// 82A0BE58: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0BE5C: 409AFFE8  bne cr6, 0x82a0be44
	if !ctx.cr[6].eq {
	pc = 0x82A0BE44; continue 'dispatch;
	}
	// 82A0BE60: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82A0BE64: 4829D5E0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0BE68 => {
    //   block [0x82A0BE68..0x82A0BE80)
	// 82A0BE68: 1F5A00D0  mulli r26, r26, 0xd0
	ctx.r[26].s32 = ((ctx.r[26].s32 as i64 * 208 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	// 82A0BE6C: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A0BE70: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A0BE74: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A0BE78: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0BE7C: 419A002C  beq cr6, 0x82a0bea8
	if ctx.cr[6].eq {
	pc = 0x82A0BEA8; continue 'dispatch;
	}
	pc = 0x82A0BE80; continue 'dispatch;
            }
            0x82A0BE80 => {
    //   block [0x82A0BE80..0x82A0BE98)
	// 82A0BE80: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0BE84: 419A0014  beq cr6, 0x82a0be98
	if ctx.cr[6].eq {
	pc = 0x82A0BE98; continue 'dispatch;
	}
	// 82A0BE88: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BE8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0BE90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BE94: 4829D5ED  bl 0x82ca9480
	ctx.lr = 0x82A0BE98;
	sub_82CA9480(ctx, base);
	pc = 0x82A0BE98; continue 'dispatch;
            }
            0x82A0BE98 => {
    //   block [0x82A0BE98..0x82A0BEA8)
	// 82A0BE98: 3BBD00D0  addi r29, r29, 0xd0
	ctx.r[29].s64 = ctx.r[29].s64 + 208;
	// 82A0BE9C: 3BDE00D0  addi r30, r30, 0xd0
	ctx.r[30].s64 = ctx.r[30].s64 + 208;
	// 82A0BEA0: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0BEA4: 409AFFDC  bne cr6, 0x82a0be80
	if !ctx.cr[6].eq {
	pc = 0x82A0BE80; continue 'dispatch;
	}
	pc = 0x82A0BEA8; continue 'dispatch;
            }
            0x82A0BEA8 => {
    //   block [0x82A0BEA8..0x82A0BEBC)
	// 82A0BEA8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A0BEAC: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A0BEB0: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0BEB4: 419A0028  beq cr6, 0x82a0bedc
	if ctx.cr[6].eq {
	pc = 0x82A0BEDC; continue 'dispatch;
	}
	// 82A0BEB8: 7FDAFA14  add r30, r26, r31
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	pc = 0x82A0BEBC; continue 'dispatch;
            }
            0x82A0BEBC => {
    //   block [0x82A0BEBC..0x82A0BEDC)
	// 82A0BEBC: 3BFFFF30  addi r31, r31, -0xd0
	ctx.r[31].s64 = ctx.r[31].s64 + -208;
	// 82A0BEC0: 3BDEFF30  addi r30, r30, -0xd0
	ctx.r[30].s64 = ctx.r[30].s64 + -208;
	// 82A0BEC4: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BEC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BECC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BED0: 4829D5B1  bl 0x82ca9480
	ctx.lr = 0x82A0BED4;
	sub_82CA9480(ctx, base);
	// 82A0BED4: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0BED8: 409AFFE4  bne cr6, 0x82a0bebc
	if !ctx.cr[6].eq {
	pc = 0x82A0BEBC; continue 'dispatch;
	}
	pc = 0x82A0BEDC; continue 'dispatch;
            }
            0x82A0BEDC => {
    //   block [0x82A0BEDC..0x82A0BEEC)
	// 82A0BEDC: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82A0BEE0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0BEE4: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0BEE8: 419A0020  beq cr6, 0x82a0bf08
	if ctx.cr[6].eq {
	pc = 0x82A0BF08; continue 'dispatch;
	}
	pc = 0x82A0BEEC; continue 'dispatch;
            }
            0x82A0BEEC => {
    //   block [0x82A0BEEC..0x82A0BF08)
	// 82A0BEEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0BEF0: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82A0BEF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BEF8: 4829D589  bl 0x82ca9480
	ctx.lr = 0x82A0BEFC;
	sub_82CA9480(ctx, base);
	// 82A0BEFC: 3BFF00D0  addi r31, r31, 0xd0
	ctx.r[31].s64 = ctx.r[31].s64 + 208;
	// 82A0BF00: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0BF04: 409AFFE8  bne cr6, 0x82a0beec
	if !ctx.cr[6].eq {
	pc = 0x82A0BEEC; continue 'dispatch;
	}
	pc = 0x82A0BF08; continue 'dispatch;
            }
            0x82A0BF08 => {
    //   block [0x82A0BF08..0x82A0BF10)
	// 82A0BF08: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82A0BF0C: 4829D538  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0BF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0BF10 size=828
    let mut pc: u32 = 0x82A0BF10;
    'dispatch: loop {
        match pc {
            0x82A0BF10 => {
    //   block [0x82A0BF10..0x82A0BF50)
	// 82A0BF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0BF14: 4829D4E5  bl 0x82ca93f8
	ctx.lr = 0x82A0BF18;
	sub_82CA93D0(ctx, base);
	// 82A0BF18: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0BF1C: F88101B8  std r4, 0x1b8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[4].u64 ) };
	// 82A0BF20: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A0BF24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0BF28: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0BF2C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A0BF30: 4829D551  bl 0x82ca9480
	ctx.lr = 0x82A0BF34;
	sub_82CA9480(ctx, base);
	// 82A0BF34: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A0BF38: 3B2B1A70  addi r25, r11, 0x1a70
	ctx.r[25].s64 = ctx.r[11].s64 + 6768;
	// 82A0BF3C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0BF40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0BF44: 409A000C  bne cr6, 0x82a0bf50
	if !ctx.cr[6].eq {
	pc = 0x82A0BF50; continue 'dispatch;
	}
	// 82A0BF48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0BF4C: 48000010  b 0x82a0bf5c
	pc = 0x82A0BF5C; continue 'dispatch;
            }
            0x82A0BF50 => {
    //   block [0x82A0BF50..0x82A0BF5C)
	// 82A0BF50: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0BF54: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0BF58: 7D494670  srawi r9, r10, 8
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 8) as i64;
	pc = 0x82A0BF5C; continue 'dispatch;
            }
            0x82A0BF5C => {
    //   block [0x82A0BF5C..0x82A0BF90)
	// 82A0BF5C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0BF60: 419A02E4  beq cr6, 0x82a0c244
	if ctx.cr[6].eq {
	pc = 0x82A0C244; continue 'dispatch;
	}
	// 82A0BF64: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0BF68: 3D4000FF  lis r10, 0xff
	ctx.r[10].s64 = 16711680;
	// 82A0BF6C: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A0BF70: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82A0BF74: 7D0B4670  srawi r11, r8, 8
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 8) as i64;
	// 82A0BF78: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0BF7C: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0BF80: 40980010  bge cr6, 0x82a0bf90
	if !ctx.cr[6].lt {
	pc = 0x82A0BF90; continue 'dispatch;
	}
	// 82A0BF84: 4803B545  bl 0x82a474c8
	ctx.lr = 0x82A0BF88;
	sub_82A474C8(ctx, base);
	// 82A0BF88: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82A0BF8C: 4829D4BC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0BF90 => {
    //   block [0x82A0BF90..0x82A0BFB4)
	// 82A0BF90: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A0BF94: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0BF98: 40980144  bge cr6, 0x82a0c0dc
	if !ctx.cr[6].lt {
	pc = 0x82A0C0DC; continue 'dispatch;
	}
	// 82A0BF9C: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0BFA0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A0BFA4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0BFA8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0BFAC: 41980008  blt cr6, 0x82a0bfb4
	if ctx.cr[6].lt {
	pc = 0x82A0BFB4; continue 'dispatch;
	}
	// 82A0BFB0: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A0BFB4; continue 'dispatch;
            }
            0x82A0BFB4 => {
    //   block [0x82A0BFB4..0x82A0BFC0)
	// 82A0BFB4: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0BFB8: 40980008  bge cr6, 0x82a0bfc0
	if !ctx.cr[6].lt {
	pc = 0x82A0BFC0; continue 'dispatch;
	}
	// 82A0BFBC: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x82A0BFC0; continue 'dispatch;
            }
            0x82A0BFC0 => {
    //   block [0x82A0BFC0..0x82A0BFE8)
	// 82A0BFC0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A0BFC4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A0BFC8: 480006A9  bl 0x82a0c670
	ctx.lr = 0x82A0BFCC;
	sub_82A0C670(ctx, base);
	// 82A0BFCC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0BFD0: 838101BC  lwz r28, 0x1bc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) } as u64;
	// 82A0BFD4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0BFD8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A0BFDC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82A0BFE0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0BFE4: 419A0030  beq cr6, 0x82a0c014
	if ctx.cr[6].eq {
	pc = 0x82A0C014; continue 'dispatch;
	}
	pc = 0x82A0BFE8; continue 'dispatch;
            }
            0x82A0BFE8 => {
    //   block [0x82A0BFE8..0x82A0C000)
	// 82A0BFE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0BFEC: 419A0014  beq cr6, 0x82a0c000
	if ctx.cr[6].eq {
	pc = 0x82A0C000; continue 'dispatch;
	}
	// 82A0BFF0: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0BFF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BFF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BFFC: 4829D485  bl 0x82ca9480
	ctx.lr = 0x82A0C000;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C000; continue 'dispatch;
            }
            0x82A0C000 => {
    //   block [0x82A0C000..0x82A0C014)
	// 82A0C000: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82A0C004: 3BDE0100  addi r30, r30, 0x100
	ctx.r[30].s64 = ctx.r[30].s64 + 256;
	// 82A0C008: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0C00C: 409AFFDC  bne cr6, 0x82a0bfe8
	if !ctx.cr[6].eq {
	pc = 0x82A0BFE8; continue 'dispatch;
	}
	// 82A0C010: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0C014; continue 'dispatch;
            }
            0x82A0C014 => {
    //   block [0x82A0C014..0x82A0C024)
	// 82A0C014: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A0C018: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A0C01C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0C020: 419A002C  beq cr6, 0x82a0c04c
	if ctx.cr[6].eq {
	pc = 0x82A0C04C; continue 'dispatch;
	}
	pc = 0x82A0C024; continue 'dispatch;
            }
            0x82A0C024 => {
    //   block [0x82A0C024..0x82A0C03C)
	// 82A0C024: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C028: 419A0014  beq cr6, 0x82a0c03c
	if ctx.cr[6].eq {
	pc = 0x82A0C03C; continue 'dispatch;
	}
	// 82A0C02C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C030: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0C034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C038: 4829D449  bl 0x82ca9480
	ctx.lr = 0x82A0C03C;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C03C; continue 'dispatch;
            }
            0x82A0C03C => {
    //   block [0x82A0C03C..0x82A0C04C)
	// 82A0C03C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0C040: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82A0C044: 4082FFE0  bne 0x82a0c024
	if !ctx.cr[0].eq {
	pc = 0x82A0C024; continue 'dispatch;
	}
	// 82A0C048: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0C04C; continue 'dispatch;
            }
            0x82A0C04C => {
    //   block [0x82A0C04C..0x82A0C06C)
	// 82A0C04C: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0C050: 574A402E  slwi r10, r26, 8
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0C054: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A0C058: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0C05C: 419A0040  beq cr6, 0x82a0c09c
	if ctx.cr[6].eq {
	pc = 0x82A0C09C; continue 'dispatch;
	}
	// 82A0C060: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A0C064: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A0C068: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82A0C06C; continue 'dispatch;
            }
            0x82A0C06C => {
    //   block [0x82A0C06C..0x82A0C084)
	// 82A0C06C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C070: 419A0014  beq cr6, 0x82a0c084
	if ctx.cr[6].eq {
	pc = 0x82A0C084; continue 'dispatch;
	}
	// 82A0C074: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0C078: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0C07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C080: 4829D401  bl 0x82ca9480
	ctx.lr = 0x82A0C084;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C084; continue 'dispatch;
            }
            0x82A0C084 => {
    //   block [0x82A0C084..0x82A0C09C)
	// 82A0C084: 3BDE0100  addi r30, r30, 0x100
	ctx.r[30].s64 = ctx.r[30].s64 + 256;
	// 82A0C088: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82A0C08C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0C090: 409AFFDC  bne cr6, 0x82a0c06c
	if !ctx.cr[6].eq {
	pc = 0x82A0C06C; continue 'dispatch;
	}
	// 82A0C094: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0C098: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0C09C; continue 'dispatch;
            }
            0x82A0C09C => {
    //   block [0x82A0C09C..0x82A0C0B8)
	// 82A0C09C: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A0C0A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C0A4: 7D4A4670  srawi r10, r10, 8
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 8) as i64;
	// 82A0C0A8: 7FEAD214  add r31, r10, r26
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82A0C0AC: 419A000C  beq cr6, 0x82a0c0b8
	if ctx.cr[6].eq {
	pc = 0x82A0C0B8; continue 'dispatch;
	}
	// 82A0C0B0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A0C0B4: 4B80FC85  bl 0x8221bd38
	ctx.lr = 0x82A0C0B8;
	sub_8221BD38(ctx, base);
	pc = 0x82A0C0B8; continue 'dispatch;
            }
            0x82A0C0B8 => {
    //   block [0x82A0C0B8..0x82A0C0DC)
	// 82A0C0B8: 570B402E  slwi r11, r24, 8
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0C0BC: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A0C0C0: 57EA402E  slwi r10, r31, 8
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0C0C4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A0C0C8: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A0C0CC: 9179000C  stw r11, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0C0D0: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0C0D4: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82A0C0D8: 4829D370  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0C0DC => {
    //   block [0x82A0C0DC..0x82A0C104)
	// 82A0C0DC: 836101BC  lwz r27, 0x1bc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) } as u64;
	// 82A0C0E0: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0C0E4: 7D6A4670  srawi r10, r11, 8
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 8) as i64;
	// 82A0C0E8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0C0EC: 409800B8  bge cr6, 0x82a0c1a4
	if !ctx.cr[6].lt {
	pc = 0x82A0C1A4; continue 'dispatch;
	}
	// 82A0C0F0: 575C402E  slwi r28, r26, 8
	ctx.r[28].u32 = ctx.r[26].u32.wrapping_shl(8);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A0C0F4: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0C0F8: 7FDCDA14  add r30, r28, r27
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82A0C0FC: 419A0034  beq cr6, 0x82a0c130
	if ctx.cr[6].eq {
	pc = 0x82A0C130; continue 'dispatch;
	}
	// 82A0C100: 7FBCF050  subf r29, r28, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	pc = 0x82A0C104; continue 'dispatch;
            }
            0x82A0C104 => {
    //   block [0x82A0C104..0x82A0C11C)
	// 82A0C104: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0C108: 419A0014  beq cr6, 0x82a0c11c
	if ctx.cr[6].eq {
	pc = 0x82A0C11C; continue 'dispatch;
	}
	// 82A0C10C: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0C110: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0C114: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C118: 4829D369  bl 0x82ca9480
	ctx.lr = 0x82A0C11C;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C11C; continue 'dispatch;
            }
            0x82A0C11C => {
    //   block [0x82A0C11C..0x82A0C130)
	// 82A0C11C: 3BBD0100  addi r29, r29, 0x100
	ctx.r[29].s64 = ctx.r[29].s64 + 256;
	// 82A0C120: 3BDE0100  addi r30, r30, 0x100
	ctx.r[30].s64 = ctx.r[30].s64 + 256;
	// 82A0C124: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0C128: 409AFFDC  bne cr6, 0x82a0c104
	if !ctx.cr[6].eq {
	pc = 0x82A0C104; continue 'dispatch;
	}
	// 82A0C12C: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0C130; continue 'dispatch;
            }
            0x82A0C130 => {
    //   block [0x82A0C130..0x82A0C140)
	// 82A0C130: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0C134: 7D6A4670  srawi r10, r11, 8
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 8) as i64;
	// 82A0C138: 7FCAD051  subf. r30, r10, r26
	ctx.r[30].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0C13C: 4182002C  beq 0x82a0c168
	if ctx.cr[0].eq {
	pc = 0x82A0C168; continue 'dispatch;
	}
	pc = 0x82A0C140; continue 'dispatch;
            }
            0x82A0C140 => {
    //   block [0x82A0C140..0x82A0C158)
	// 82A0C140: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C144: 419A0014  beq cr6, 0x82a0c158
	if ctx.cr[6].eq {
	pc = 0x82A0C158; continue 'dispatch;
	}
	// 82A0C148: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C14C: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0C150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C154: 4829D32D  bl 0x82ca9480
	ctx.lr = 0x82A0C158;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C158; continue 'dispatch;
            }
            0x82A0C158 => {
    //   block [0x82A0C158..0x82A0C168)
	// 82A0C158: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0C15C: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82A0C160: 4082FFE0  bne 0x82a0c140
	if !ctx.cr[0].eq {
	pc = 0x82A0C140; continue 'dispatch;
	}
	// 82A0C164: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0C168; continue 'dispatch;
            }
            0x82A0C168 => {
    //   block [0x82A0C168..0x82A0C180)
	// 82A0C168: 7D7CFA14  add r11, r28, r31
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 82A0C16C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0C170: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82A0C174: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0C178: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0C17C: 419A00C8  beq cr6, 0x82a0c244
	if ctx.cr[6].eq {
	pc = 0x82A0C244; continue 'dispatch;
	}
	pc = 0x82A0C180; continue 'dispatch;
            }
            0x82A0C180 => {
    //   block [0x82A0C180..0x82A0C1A4)
	// 82A0C180: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C184: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0C188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C18C: 4829D2F5  bl 0x82ca9480
	ctx.lr = 0x82A0C190;
	sub_82CA9480(ctx, base);
	// 82A0C190: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82A0C194: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0C198: 409AFFE8  bne cr6, 0x82a0c180
	if !ctx.cr[6].eq {
	pc = 0x82A0C180; continue 'dispatch;
	}
	// 82A0C19C: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82A0C1A0: 4829D2A8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0C1A4 => {
    //   block [0x82A0C1A4..0x82A0C1BC)
	// 82A0C1A4: 575A402E  slwi r26, r26, 8
	ctx.r[26].u32 = ctx.r[26].u32.wrapping_shl(8);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82A0C1A8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A0C1AC: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A0C1B0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A0C1B4: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0C1B8: 419A002C  beq cr6, 0x82a0c1e4
	if ctx.cr[6].eq {
	pc = 0x82A0C1E4; continue 'dispatch;
	}
	pc = 0x82A0C1BC; continue 'dispatch;
            }
            0x82A0C1BC => {
    //   block [0x82A0C1BC..0x82A0C1D4)
	// 82A0C1BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0C1C0: 419A0014  beq cr6, 0x82a0c1d4
	if ctx.cr[6].eq {
	pc = 0x82A0C1D4; continue 'dispatch;
	}
	// 82A0C1C4: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0C1C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0C1CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C1D0: 4829D2B1  bl 0x82ca9480
	ctx.lr = 0x82A0C1D4;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C1D4; continue 'dispatch;
            }
            0x82A0C1D4 => {
    //   block [0x82A0C1D4..0x82A0C1E4)
	// 82A0C1D4: 3BBD0100  addi r29, r29, 0x100
	ctx.r[29].s64 = ctx.r[29].s64 + 256;
	// 82A0C1D8: 3BDE0100  addi r30, r30, 0x100
	ctx.r[30].s64 = ctx.r[30].s64 + 256;
	// 82A0C1DC: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0C1E0: 409AFFDC  bne cr6, 0x82a0c1bc
	if !ctx.cr[6].eq {
	pc = 0x82A0C1BC; continue 'dispatch;
	}
	pc = 0x82A0C1E4; continue 'dispatch;
            }
            0x82A0C1E4 => {
    //   block [0x82A0C1E4..0x82A0C1F8)
	// 82A0C1E4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A0C1E8: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A0C1EC: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0C1F0: 419A0028  beq cr6, 0x82a0c218
	if ctx.cr[6].eq {
	pc = 0x82A0C218; continue 'dispatch;
	}
	// 82A0C1F4: 7FDAFA14  add r30, r26, r31
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	pc = 0x82A0C1F8; continue 'dispatch;
            }
            0x82A0C1F8 => {
    //   block [0x82A0C1F8..0x82A0C218)
	// 82A0C1F8: 3BFFFF00  addi r31, r31, -0x100
	ctx.r[31].s64 = ctx.r[31].s64 + -256;
	// 82A0C1FC: 3BDEFF00  addi r30, r30, -0x100
	ctx.r[30].s64 = ctx.r[30].s64 + -256;
	// 82A0C200: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0C204: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C20C: 4829D275  bl 0x82ca9480
	ctx.lr = 0x82A0C210;
	sub_82CA9480(ctx, base);
	// 82A0C210: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0C214: 409AFFE4  bne cr6, 0x82a0c1f8
	if !ctx.cr[6].eq {
	pc = 0x82A0C1F8; continue 'dispatch;
	}
	pc = 0x82A0C218; continue 'dispatch;
            }
            0x82A0C218 => {
    //   block [0x82A0C218..0x82A0C228)
	// 82A0C218: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82A0C21C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0C220: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0C224: 419A0020  beq cr6, 0x82a0c244
	if ctx.cr[6].eq {
	pc = 0x82A0C244; continue 'dispatch;
	}
	pc = 0x82A0C228; continue 'dispatch;
            }
            0x82A0C228 => {
    //   block [0x82A0C228..0x82A0C244)
	// 82A0C228: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C22C: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A0C230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C234: 4829D24D  bl 0x82ca9480
	ctx.lr = 0x82A0C238;
	sub_82CA9480(ctx, base);
	// 82A0C238: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82A0C23C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0C240: 409AFFE8  bne cr6, 0x82a0c228
	if !ctx.cr[6].eq {
	pc = 0x82A0C228; continue 'dispatch;
	}
	pc = 0x82A0C244; continue 'dispatch;
            }
            0x82A0C244 => {
    //   block [0x82A0C244..0x82A0C24C)
	// 82A0C244: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82A0C248: 4829D200  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0C250 size=832
    let mut pc: u32 = 0x82A0C250;
    'dispatch: loop {
        match pc {
            0x82A0C250 => {
    //   block [0x82A0C250..0x82A0C294)
	// 82A0C250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C254: 4829D1A1  bl 0x82ca93f4
	ctx.lr = 0x82A0C258;
	sub_82CA93D0(ctx, base);
	// 82A0C258: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C25C: F8810278  std r4, 0x278(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(632 as u32), ctx.r[4].u64 ) };
	// 82A0C260: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A0C264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0C268: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C26C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A0C270: 4829D211  bl 0x82ca9480
	ctx.lr = 0x82A0C274;
	sub_82CA9480(ctx, base);
	// 82A0C274: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A0C278: 3AE001C0  li r23, 0x1c0
	ctx.r[23].s64 = 448;
	// 82A0C27C: 3B2B1A60  addi r25, r11, 0x1a60
	ctx.r[25].s64 = ctx.r[11].s64 + 6752;
	// 82A0C280: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C288: 409A000C  bne cr6, 0x82a0c294
	if !ctx.cr[6].eq {
	pc = 0x82A0C294; continue 'dispatch;
	}
	// 82A0C28C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0C290: 48000010  b 0x82a0c2a0
	pc = 0x82A0C2A0; continue 'dispatch;
            }
            0x82A0C294 => {
    //   block [0x82A0C294..0x82A0C2A0)
	// 82A0C294: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0C298: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0C29C: 7D2ABBD6  divw r9, r10, r23
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	pc = 0x82A0C2A0; continue 'dispatch;
            }
            0x82A0C2A0 => {
    //   block [0x82A0C2A0..0x82A0C2D4)
	// 82A0C2A0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0C2A4: 419A02E4  beq cr6, 0x82a0c588
	if ctx.cr[6].eq {
	pc = 0x82A0C588; continue 'dispatch;
	}
	// 82A0C2A8: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0C2AC: 3D400092  lis r10, 0x92
	ctx.r[10].s64 = 9568256;
	// 82A0C2B0: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A0C2B4: 614A4924  ori r10, r10, 0x4924
	ctx.r[10].u64 = ctx.r[10].u64 | 18724;
	// 82A0C2B8: 7D68BBD6  divw r11, r8, r23
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[23].s32;
	// 82A0C2BC: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0C2C0: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0C2C4: 40980010  bge cr6, 0x82a0c2d4
	if !ctx.cr[6].lt {
	pc = 0x82A0C2D4; continue 'dispatch;
	}
	// 82A0C2C8: 4803B201  bl 0x82a474c8
	ctx.lr = 0x82A0C2CC;
	sub_82A474C8(ctx, base);
	// 82A0C2CC: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 82A0C2D0: 4829D174  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0C2D4 => {
    //   block [0x82A0C2D4..0x82A0C2F8)
	// 82A0C2D4: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A0C2D8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0C2DC: 40980144  bge cr6, 0x82a0c420
	if !ctx.cr[6].lt {
	pc = 0x82A0C420; continue 'dispatch;
	}
	// 82A0C2E0: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0C2E4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A0C2E8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0C2EC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0C2F0: 41980008  blt cr6, 0x82a0c2f8
	if ctx.cr[6].lt {
	pc = 0x82A0C2F8; continue 'dispatch;
	}
	// 82A0C2F4: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A0C2F8; continue 'dispatch;
            }
            0x82A0C2F8 => {
    //   block [0x82A0C2F8..0x82A0C304)
	// 82A0C2F8: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0C2FC: 40980008  bge cr6, 0x82a0c304
	if !ctx.cr[6].lt {
	pc = 0x82A0C304; continue 'dispatch;
	}
	// 82A0C300: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x82A0C304; continue 'dispatch;
            }
            0x82A0C304 => {
    //   block [0x82A0C304..0x82A0C32C)
	// 82A0C304: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A0C308: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A0C30C: 480003D5  bl 0x82a0c6e0
	ctx.lr = 0x82A0C310;
	sub_82A0C6E0(ctx, base);
	// 82A0C310: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C314: 8381027C  lwz r28, 0x27c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(636 as u32) ) } as u64;
	// 82A0C318: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0C31C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A0C320: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82A0C324: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0C328: 419A0030  beq cr6, 0x82a0c358
	if ctx.cr[6].eq {
	pc = 0x82A0C358; continue 'dispatch;
	}
	pc = 0x82A0C32C; continue 'dispatch;
            }
            0x82A0C32C => {
    //   block [0x82A0C32C..0x82A0C344)
	// 82A0C32C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0C330: 419A0014  beq cr6, 0x82a0c344
	if ctx.cr[6].eq {
	pc = 0x82A0C344; continue 'dispatch;
	}
	// 82A0C334: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C338: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C33C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C340: 4829D141  bl 0x82ca9480
	ctx.lr = 0x82A0C344;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C344; continue 'dispatch;
            }
            0x82A0C344 => {
    //   block [0x82A0C344..0x82A0C358)
	// 82A0C344: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 82A0C348: 3BDE01C0  addi r30, r30, 0x1c0
	ctx.r[30].s64 = ctx.r[30].s64 + 448;
	// 82A0C34C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0C350: 409AFFDC  bne cr6, 0x82a0c32c
	if !ctx.cr[6].eq {
	pc = 0x82A0C32C; continue 'dispatch;
	}
	// 82A0C354: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0C358; continue 'dispatch;
            }
            0x82A0C358 => {
    //   block [0x82A0C358..0x82A0C368)
	// 82A0C358: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A0C35C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A0C360: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A0C364: 419A002C  beq cr6, 0x82a0c390
	if ctx.cr[6].eq {
	pc = 0x82A0C390; continue 'dispatch;
	}
	pc = 0x82A0C368; continue 'dispatch;
            }
            0x82A0C368 => {
    //   block [0x82A0C368..0x82A0C380)
	// 82A0C368: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C36C: 419A0014  beq cr6, 0x82a0c380
	if ctx.cr[6].eq {
	pc = 0x82A0C380; continue 'dispatch;
	}
	// 82A0C370: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C374: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C37C: 4829D105  bl 0x82ca9480
	ctx.lr = 0x82A0C380;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C380; continue 'dispatch;
            }
            0x82A0C380 => {
    //   block [0x82A0C380..0x82A0C390)
	// 82A0C380: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0C384: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 82A0C388: 4082FFE0  bne 0x82a0c368
	if !ctx.cr[0].eq {
	pc = 0x82A0C368; continue 'dispatch;
	}
	// 82A0C38C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0C390; continue 'dispatch;
            }
            0x82A0C390 => {
    //   block [0x82A0C390..0x82A0C3B0)
	// 82A0C390: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0C394: 1D5A01C0  mulli r10, r26, 0x1c0
	ctx.r[10].s32 = ((ctx.r[26].s32 as i64 * 448 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A0C398: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A0C39C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0C3A0: 419A0040  beq cr6, 0x82a0c3e0
	if ctx.cr[6].eq {
	pc = 0x82A0C3E0; continue 'dispatch;
	}
	// 82A0C3A4: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A0C3A8: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A0C3AC: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82A0C3B0; continue 'dispatch;
            }
            0x82A0C3B0 => {
    //   block [0x82A0C3B0..0x82A0C3C8)
	// 82A0C3B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C3B4: 419A0014  beq cr6, 0x82a0c3c8
	if ctx.cr[6].eq {
	pc = 0x82A0C3C8; continue 'dispatch;
	}
	// 82A0C3B8: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C3BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0C3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C3C4: 4829D0BD  bl 0x82ca9480
	ctx.lr = 0x82A0C3C8;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C3C8; continue 'dispatch;
            }
            0x82A0C3C8 => {
    //   block [0x82A0C3C8..0x82A0C3E0)
	// 82A0C3C8: 3BDE01C0  addi r30, r30, 0x1c0
	ctx.r[30].s64 = ctx.r[30].s64 + 448;
	// 82A0C3CC: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 82A0C3D0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0C3D4: 409AFFDC  bne cr6, 0x82a0c3b0
	if !ctx.cr[6].eq {
	pc = 0x82A0C3B0; continue 'dispatch;
	}
	// 82A0C3D8: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0C3DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0C3E0; continue 'dispatch;
            }
            0x82A0C3E0 => {
    //   block [0x82A0C3E0..0x82A0C3FC)
	// 82A0C3E0: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A0C3E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C3E8: 7D4ABBD6  divw r10, r10, r23
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 82A0C3EC: 7FEAD214  add r31, r10, r26
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82A0C3F0: 419A000C  beq cr6, 0x82a0c3fc
	if ctx.cr[6].eq {
	pc = 0x82A0C3FC; continue 'dispatch;
	}
	// 82A0C3F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A0C3F8: 4B80F941  bl 0x8221bd38
	ctx.lr = 0x82A0C3FC;
	sub_8221BD38(ctx, base);
	pc = 0x82A0C3FC; continue 'dispatch;
            }
            0x82A0C3FC => {
    //   block [0x82A0C3FC..0x82A0C420)
	// 82A0C3FC: 1D7801C0  mulli r11, r24, 0x1c0
	ctx.r[11].s32 = ((ctx.r[24].s32 as i64 * 448 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A0C400: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A0C404: 1D5F01C0  mulli r10, r31, 0x1c0
	ctx.r[10].s32 = ((ctx.r[31].s32 as i64 * 448 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A0C408: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A0C40C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A0C410: 9179000C  stw r11, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0C414: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0C418: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 82A0C41C: 4829D028  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0C420 => {
    //   block [0x82A0C420..0x82A0C448)
	// 82A0C420: 8361027C  lwz r27, 0x27c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(636 as u32) ) } as u64;
	// 82A0C424: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0C428: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A0C42C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0C430: 409800B8  bge cr6, 0x82a0c4e8
	if !ctx.cr[6].lt {
	pc = 0x82A0C4E8; continue 'dispatch;
	}
	// 82A0C434: 1F9A01C0  mulli r28, r26, 0x1c0
	ctx.r[28].s32 = ((ctx.r[26].s32 as i64 * 448 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82A0C438: 7FDCDA14  add r30, r28, r27
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82A0C43C: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0C440: 419A0034  beq cr6, 0x82a0c474
	if ctx.cr[6].eq {
	pc = 0x82A0C474; continue 'dispatch;
	}
	// 82A0C444: 7FBCF050  subf r29, r28, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	pc = 0x82A0C448; continue 'dispatch;
            }
            0x82A0C448 => {
    //   block [0x82A0C448..0x82A0C460)
	// 82A0C448: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0C44C: 419A0014  beq cr6, 0x82a0c460
	if ctx.cr[6].eq {
	pc = 0x82A0C460; continue 'dispatch;
	}
	// 82A0C450: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C454: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0C458: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C45C: 4829D025  bl 0x82ca9480
	ctx.lr = 0x82A0C460;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C460; continue 'dispatch;
            }
            0x82A0C460 => {
    //   block [0x82A0C460..0x82A0C474)
	// 82A0C460: 3BBD01C0  addi r29, r29, 0x1c0
	ctx.r[29].s64 = ctx.r[29].s64 + 448;
	// 82A0C464: 3BDE01C0  addi r30, r30, 0x1c0
	ctx.r[30].s64 = ctx.r[30].s64 + 448;
	// 82A0C468: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0C46C: 409AFFDC  bne cr6, 0x82a0c448
	if !ctx.cr[6].eq {
	pc = 0x82A0C448; continue 'dispatch;
	}
	// 82A0C470: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0C474; continue 'dispatch;
            }
            0x82A0C474 => {
    //   block [0x82A0C474..0x82A0C484)
	// 82A0C474: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A0C478: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A0C47C: 7FCAD051  subf. r30, r10, r26
	ctx.r[30].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0C480: 4182002C  beq 0x82a0c4ac
	if ctx.cr[0].eq {
	pc = 0x82A0C4AC; continue 'dispatch;
	}
	pc = 0x82A0C484; continue 'dispatch;
            }
            0x82A0C484 => {
    //   block [0x82A0C484..0x82A0C49C)
	// 82A0C484: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C488: 419A0014  beq cr6, 0x82a0c49c
	if ctx.cr[6].eq {
	pc = 0x82A0C49C; continue 'dispatch;
	}
	// 82A0C48C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C490: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C498: 4829CFE9  bl 0x82ca9480
	ctx.lr = 0x82A0C49C;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C49C; continue 'dispatch;
            }
            0x82A0C49C => {
    //   block [0x82A0C49C..0x82A0C4AC)
	// 82A0C49C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0C4A0: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 82A0C4A4: 4082FFE0  bne 0x82a0c484
	if !ctx.cr[0].eq {
	pc = 0x82A0C484; continue 'dispatch;
	}
	// 82A0C4A8: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0C4AC; continue 'dispatch;
            }
            0x82A0C4AC => {
    //   block [0x82A0C4AC..0x82A0C4C4)
	// 82A0C4AC: 7D7CFA14  add r11, r28, r31
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 82A0C4B0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0C4B4: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82A0C4B8: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0C4BC: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0C4C0: 419A00C8  beq cr6, 0x82a0c588
	if ctx.cr[6].eq {
	pc = 0x82A0C588; continue 'dispatch;
	}
	pc = 0x82A0C4C4; continue 'dispatch;
            }
            0x82A0C4C4 => {
    //   block [0x82A0C4C4..0x82A0C4E8)
	// 82A0C4C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C4C8: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C4CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C4D0: 4829CFB1  bl 0x82ca9480
	ctx.lr = 0x82A0C4D4;
	sub_82CA9480(ctx, base);
	// 82A0C4D4: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 82A0C4D8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0C4DC: 409AFFE8  bne cr6, 0x82a0c4c4
	if !ctx.cr[6].eq {
	pc = 0x82A0C4C4; continue 'dispatch;
	}
	// 82A0C4E0: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 82A0C4E4: 4829CF60  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0C4E8 => {
    //   block [0x82A0C4E8..0x82A0C500)
	// 82A0C4E8: 1F5A01C0  mulli r26, r26, 0x1c0
	ctx.r[26].s32 = ((ctx.r[26].s32 as i64 * 448 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	// 82A0C4EC: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A0C4F0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A0C4F4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A0C4F8: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0C4FC: 419A002C  beq cr6, 0x82a0c528
	if ctx.cr[6].eq {
	pc = 0x82A0C528; continue 'dispatch;
	}
	pc = 0x82A0C500; continue 'dispatch;
            }
            0x82A0C500 => {
    //   block [0x82A0C500..0x82A0C518)
	// 82A0C500: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0C504: 419A0014  beq cr6, 0x82a0c518
	if ctx.cr[6].eq {
	pc = 0x82A0C518; continue 'dispatch;
	}
	// 82A0C508: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C50C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0C510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C514: 4829CF6D  bl 0x82ca9480
	ctx.lr = 0x82A0C518;
	sub_82CA9480(ctx, base);
	pc = 0x82A0C518; continue 'dispatch;
            }
            0x82A0C518 => {
    //   block [0x82A0C518..0x82A0C528)
	// 82A0C518: 3BBD01C0  addi r29, r29, 0x1c0
	ctx.r[29].s64 = ctx.r[29].s64 + 448;
	// 82A0C51C: 3BDE01C0  addi r30, r30, 0x1c0
	ctx.r[30].s64 = ctx.r[30].s64 + 448;
	// 82A0C520: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0C524: 409AFFDC  bne cr6, 0x82a0c500
	if !ctx.cr[6].eq {
	pc = 0x82A0C500; continue 'dispatch;
	}
	pc = 0x82A0C528; continue 'dispatch;
            }
            0x82A0C528 => {
    //   block [0x82A0C528..0x82A0C53C)
	// 82A0C528: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A0C52C: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A0C530: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0C534: 419A0028  beq cr6, 0x82a0c55c
	if ctx.cr[6].eq {
	pc = 0x82A0C55C; continue 'dispatch;
	}
	// 82A0C538: 7FDAFA14  add r30, r26, r31
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	pc = 0x82A0C53C; continue 'dispatch;
            }
            0x82A0C53C => {
    //   block [0x82A0C53C..0x82A0C55C)
	// 82A0C53C: 3BFFFE40  addi r31, r31, -0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + -448;
	// 82A0C540: 3BDEFE40  addi r30, r30, -0x1c0
	ctx.r[30].s64 = ctx.r[30].s64 + -448;
	// 82A0C544: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C548: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C54C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C550: 4829CF31  bl 0x82ca9480
	ctx.lr = 0x82A0C554;
	sub_82CA9480(ctx, base);
	// 82A0C554: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0C558: 409AFFE4  bne cr6, 0x82a0c53c
	if !ctx.cr[6].eq {
	pc = 0x82A0C53C; continue 'dispatch;
	}
	pc = 0x82A0C55C; continue 'dispatch;
            }
            0x82A0C55C => {
    //   block [0x82A0C55C..0x82A0C56C)
	// 82A0C55C: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82A0C560: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0C564: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0C568: 419A0020  beq cr6, 0x82a0c588
	if ctx.cr[6].eq {
	pc = 0x82A0C588; continue 'dispatch;
	}
	pc = 0x82A0C56C; continue 'dispatch;
            }
            0x82A0C56C => {
    //   block [0x82A0C56C..0x82A0C588)
	// 82A0C56C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C570: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 82A0C574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C578: 4829CF09  bl 0x82ca9480
	ctx.lr = 0x82A0C57C;
	sub_82CA9480(ctx, base);
	// 82A0C57C: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 82A0C580: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0C584: 409AFFE8  bne cr6, 0x82a0c56c
	if !ctx.cr[6].eq {
	pc = 0x82A0C56C; continue 'dispatch;
	}
	pc = 0x82A0C588; continue 'dispatch;
            }
            0x82A0C588 => {
    //   block [0x82A0C588..0x82A0C590)
	// 82A0C588: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 82A0C58C: 4829CEB8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0C590 size=112
    let mut pc: u32 = 0x82A0C590;
    'dispatch: loop {
        match pc {
            0x82A0C590 => {
    //   block [0x82A0C590..0x82A0C5E4)
	// 82A0C590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0C598: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0C59C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C5A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0C5A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C5A8: 419A003C  beq cr6, 0x82a0c5e4
	if ctx.cr[6].eq {
	pc = 0x82A0C5E4; continue 'dispatch;
	}
	// 82A0C5AC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A0C5B0: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82A0C5B4: 2B0A0160  cmplwi cr6, r10, 0x160
	ctx.cr[6].compare_u32(ctx.r[10].u32, 352 as u32, &mut ctx.xer);
	// 82A0C5B8: 4098002C  bge cr6, 0x82a0c5e4
	if !ctx.cr[6].lt {
	pc = 0x82A0C5E4; continue 'dispatch;
	}
	// 82A0C5BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0C5C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0C5C4: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82A0C5C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A0C5CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0C5D0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A0C5D4: 4B8E584D  bl 0x822f1e20
	ctx.lr = 0x82A0C5D8;
	sub_822F1E20(ctx, base);
	// 82A0C5D8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A0C5DC: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82A0C5E0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82A0C5E4; continue 'dispatch;
            }
            0x82A0C5E4 => {
    //   block [0x82A0C5E4..0x82A0C600)
	// 82A0C5E4: 1C7F0160  mulli r3, r31, 0x160
	ctx.r[3].s32 = ((ctx.r[31].s32 as i64 * 352 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82A0C5E8: 4B812C71  bl 0x8221f258
	ctx.lr = 0x82A0C5EC;
	sub_8221F258(ctx, base);
	// 82A0C5EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0C5F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0C5F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0C5F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0C5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0C600 size=112
    let mut pc: u32 = 0x82A0C600;
    'dispatch: loop {
        match pc {
            0x82A0C600 => {
    //   block [0x82A0C600..0x82A0C654)
	// 82A0C600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0C608: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0C60C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C610: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0C614: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C618: 419A003C  beq cr6, 0x82a0c654
	if ctx.cr[6].eq {
	pc = 0x82A0C654; continue 'dispatch;
	}
	// 82A0C61C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A0C620: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82A0C624: 2B0A00D0  cmplwi cr6, r10, 0xd0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 208 as u32, &mut ctx.xer);
	// 82A0C628: 4098002C  bge cr6, 0x82a0c654
	if !ctx.cr[6].lt {
	pc = 0x82A0C654; continue 'dispatch;
	}
	// 82A0C62C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0C630: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0C634: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82A0C638: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A0C63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0C640: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A0C644: 4B8E57DD  bl 0x822f1e20
	ctx.lr = 0x82A0C648;
	sub_822F1E20(ctx, base);
	// 82A0C648: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A0C64C: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82A0C650: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82A0C654; continue 'dispatch;
            }
            0x82A0C654 => {
    //   block [0x82A0C654..0x82A0C670)
	// 82A0C654: 1C7F00D0  mulli r3, r31, 0xd0
	ctx.r[3].s32 = ((ctx.r[31].s32 as i64 * 208 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82A0C658: 4B812C01  bl 0x8221f258
	ctx.lr = 0x82A0C65C;
	sub_8221F258(ctx, base);
	// 82A0C65C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0C660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0C664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0C668: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0C66C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0C670 size=112
    let mut pc: u32 = 0x82A0C670;
    'dispatch: loop {
        match pc {
            0x82A0C670 => {
    //   block [0x82A0C670..0x82A0C6C4)
	// 82A0C670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0C678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0C67C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C680: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0C684: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C688: 419A003C  beq cr6, 0x82a0c6c4
	if ctx.cr[6].eq {
	pc = 0x82A0C6C4; continue 'dispatch;
	}
	// 82A0C68C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A0C690: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82A0C694: 2B0A0100  cmplwi cr6, r10, 0x100
	ctx.cr[6].compare_u32(ctx.r[10].u32, 256 as u32, &mut ctx.xer);
	// 82A0C698: 4098002C  bge cr6, 0x82a0c6c4
	if !ctx.cr[6].lt {
	pc = 0x82A0C6C4; continue 'dispatch;
	}
	// 82A0C69C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0C6A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0C6A4: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82A0C6A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A0C6AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0C6B0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A0C6B4: 4B8E576D  bl 0x822f1e20
	ctx.lr = 0x82A0C6B8;
	sub_822F1E20(ctx, base);
	// 82A0C6B8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A0C6BC: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82A0C6C0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82A0C6C4; continue 'dispatch;
            }
            0x82A0C6C4 => {
    //   block [0x82A0C6C4..0x82A0C6E0)
	// 82A0C6C4: 57E3402E  slwi r3, r31, 8
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(8);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A0C6C8: 4B812B91  bl 0x8221f258
	ctx.lr = 0x82A0C6CC;
	sub_8221F258(ctx, base);
	// 82A0C6CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0C6D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0C6D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0C6D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0C6DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0C6E0 size=112
    let mut pc: u32 = 0x82A0C6E0;
    'dispatch: loop {
        match pc {
            0x82A0C6E0 => {
    //   block [0x82A0C6E0..0x82A0C734)
	// 82A0C6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0C6E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0C6EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C6F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0C6F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0C6F8: 419A003C  beq cr6, 0x82a0c734
	if ctx.cr[6].eq {
	pc = 0x82A0C734; continue 'dispatch;
	}
	// 82A0C6FC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A0C700: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82A0C704: 2B0A01C0  cmplwi cr6, r10, 0x1c0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 448 as u32, &mut ctx.xer);
	// 82A0C708: 4098002C  bge cr6, 0x82a0c734
	if !ctx.cr[6].lt {
	pc = 0x82A0C734; continue 'dispatch;
	}
	// 82A0C70C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0C710: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0C714: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82A0C718: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A0C71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0C720: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A0C724: 4B8E56FD  bl 0x822f1e20
	ctx.lr = 0x82A0C728;
	sub_822F1E20(ctx, base);
	// 82A0C728: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A0C72C: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82A0C730: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82A0C734; continue 'dispatch;
            }
            0x82A0C734 => {
    //   block [0x82A0C734..0x82A0C750)
	// 82A0C734: 1C7F01C0  mulli r3, r31, 0x1c0
	ctx.r[3].s32 = ((ctx.r[31].s32 as i64 * 448 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82A0C738: 4B812B21  bl 0x8221f258
	ctx.lr = 0x82A0C73C;
	sub_8221F258(ctx, base);
	// 82A0C73C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0C740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0C744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0C748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0C74C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0C750 size=1188
    let mut pc: u32 = 0x82A0C750;
    'dispatch: loop {
        match pc {
            0x82A0C750 => {
    //   block [0x82A0C750..0x82A0C78C)
	// 82A0C750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C754: 4829CC7D  bl 0x82ca93d0
	ctx.lr = 0x82A0C758;
	sub_82CA93D0(ctx, base);
	// 82A0C758: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C75C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A0C760: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82A0C764: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82A0C768: 4881C3E1  bl 0x83228b48
	ctx.lr = 0x82A0C76C;
	sub_83228B48(ctx, base);
	// 82A0C76C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0C770: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A0C774: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A0C778: C0EB9484  lfs f7, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82A0C77C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A0C780: FF013800  fcmpu cr6, f1, f7
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[7].f64);
	// 82A0C784: 419A0008  beq cr6, 0x82a0c78c
	if ctx.cr[6].eq {
	pc = 0x82A0C78C; continue 'dispatch;
	}
	// 82A0C788: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82A0C78C; continue 'dispatch;
            }
            0x82A0C78C => {
    //   block [0x82A0C78C..0x82A0C7A4)
	// 82A0C78C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0C790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C794: 419A0010  beq cr6, 0x82a0c7a4
	if ctx.cr[6].eq {
	pc = 0x82A0C7A4; continue 'dispatch;
	}
	// 82A0C798: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0C79C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A0C7A0: 4829CC80  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0C7A4 => {
    //   block [0x82A0C7A4..0x82A0C7D0)
	// 82A0C7A4: 81780154  lwz r11, 0x154(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0C7A8: 7FD4F378  mr r20, r30
	ctx.r[20].u64 = ctx.r[30].u64;
	// 82A0C7AC: 7FD2F378  mr r18, r30
	ctx.r[18].u64 = ctx.r[30].u64;
	// 82A0C7B0: 9281005C  stw r20, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[20].u32 ) };
	// 82A0C7B4: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 82A0C7B8: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 82A0C7BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C7C0: 40990424  ble cr6, 0x82a0cbe4
	if !ctx.cr[6].gt {
	pc = 0x82A0CBE4; continue 'dispatch;
	}
	// 82A0C7C4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A0C7C8: 7FD7F378  mr r23, r30
	ctx.r[23].u64 = ctx.r[30].u64;
	// 82A0C7CC: 3BEB1A70  addi r31, r11, 0x1a70
	ctx.r[31].s64 = ctx.r[11].s64 + 6768;
	pc = 0x82A0C7D0; continue 'dispatch;
            }
            0x82A0C7D0 => {
    //   block [0x82A0C7D0..0x82A0C864)
	// 82A0C7D0: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0C7D4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A0C7D8: 8139001C  lwz r9, 0x1c(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0C7DC: 7D1A5A14  add r8, r26, r11
	ctx.r[8].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82A0C7E0: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C7E4: 7D0B4838  and r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A0C7E8: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0C7EC: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A0C7F0: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0C7F4: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A0C7F8: 89670014  lbz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0C7FC: C027000C  lfs f1, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0C800: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 82A0C804: 488223E5  bl 0x8322ebe8
	ctx.lr = 0x82A0C808;
	sub_8322EBE8(ctx, base);
	// 82A0C808: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A0C80C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A0C810: 409A008C  bne cr6, 0x82a0c89c
	if !ctx.cr[6].eq {
	pc = 0x82A0C89C; continue 'dispatch;
	}
	// 82A0C814: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0C818: 5649103A  slwi r9, r18, 2
	ctx.r[9].u32 = ctx.r[18].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0C81C: 8116001C  lwz r8, 0x1c(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0C820: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82A0C824: 7CABD214  add r5, r11, r26
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A0C828: 81560004  lwz r10, 4(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C82C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A0C830: 7CA34038  and r3, r5, r8
	ctx.r[3].u64 = ctx.r[5].u64 & ctx.r[8].u64;
	// 82A0C834: 3A520001  addi r18, r18, 1
	ctx.r[18].s64 = ctx.r[18].s64 + 1;
	// 82A0C838: 546B2834  slwi r11, r3, 5
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0C83C: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 82A0C840: 2F120004  cmpwi cr6, r18, 4
	ctx.cr[6].compare_i32(ctx.r[18].s32, 4, &mut ctx.xer);
	// 82A0C844: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A0C848: 7CE9212E  stwx r7, r9, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 82A0C84C: 7D69312E  stwx r11, r9, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 82A0C850: 409A004C  bne cr6, 0x82a0c89c
	if !ctx.cr[6].eq {
	pc = 0x82A0C89C; continue 'dispatch;
	}
	// 82A0C854: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C858: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82A0C85C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82A0C860: 7CD75A14  add r6, r23, r11
	ctx.r[6].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	pc = 0x82A0C864; continue 'dispatch;
            }
            0x82A0C864 => {
    //   block [0x82A0C864..0x82A0C89C)
	// 82A0C864: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82A0C868: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A0C86C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A0C870: 7CBC582E  lwzx r5, r28, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A0C874: 7C9C502E  lwzx r4, r28, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A0C878: 488152D1  bl 0x83221b48
	ctx.lr = 0x82A0C87C;
	sub_83221B48(ctx, base);
	// 82A0C87C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82A0C880: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82A0C884: 2F1C0010  cmpwi cr6, r28, 0x10
	ctx.cr[6].compare_i32(ctx.r[28].s32, 16, &mut ctx.xer);
	// 82A0C888: 4198FFDC  blt cr6, 0x82a0c864
	if ctx.cr[6].lt {
	pc = 0x82A0C864; continue 'dispatch;
	}
	// 82A0C88C: 7FD2F378  mr r18, r30
	ctx.r[18].u64 = ctx.r[30].u64;
	// 82A0C890: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 82A0C894: 3AF70100  addi r23, r23, 0x100
	ctx.r[23].s64 = ctx.r[23].s64 + 256;
	// 82A0C898: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	pc = 0x82A0C89C; continue 'dispatch;
            }
            0x82A0C89C => {
    //   block [0x82A0C89C..0x82A0C8C4)
	// 82A0C89C: 81780154  lwz r11, 0x154(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0C8A0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82A0C8A4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0C8A8: 4198FF28  blt cr6, 0x82a0c7d0
	if ctx.cr[6].lt {
	pc = 0x82A0C7D0; continue 'dispatch;
	}
	// 82A0C8AC: 9281005C  stw r20, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[20].u32 ) };
	// 82A0C8B0: 2F120000  cmpwi cr6, r18, 0
	ctx.cr[6].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 82A0C8B4: 40990330  ble cr6, 0x82a0cbe4
	if !ctx.cr[6].gt {
	pc = 0x82A0CBE4; continue 'dispatch;
	}
	// 82A0C8B8: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82A0C8BC: 569A402E  slwi r26, r20, 8
	ctx.r[26].u32 = ctx.r[20].u32.wrapping_shl(8);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82A0C8C0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	pc = 0x82A0C8C4; continue 'dispatch;
            }
            0x82A0C8C4 => {
    //   block [0x82A0C8C4..0x82A0CB48)
	// 82A0C8C4: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A0C8C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C8CC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A0C8D0: 7CDA5A14  add r6, r26, r11
	ctx.r[6].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82A0C8D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A0C8D8: 7CBC502E  lwzx r5, r28, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A0C8DC: 7C9C482E  lwzx r4, r28, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A0C8E0: 48815269  bl 0x83221b48
	ctx.lr = 0x82A0C8E4;
	sub_83221B48(ctx, base);
	// 82A0C8E4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82A0C8E8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82A0C8EC: 7F1B9000  cmpw cr6, r27, r18
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[18].s32, &mut ctx.xer);
	// 82A0C8F0: 4198FFD4  blt cr6, 0x82a0c8c4
	if ctx.cr[6].lt {
	pc = 0x82A0C8C4; continue 'dispatch;
	}
	// 82A0C8F4: 21320004  subfic r9, r18, 4
	ctx.xer.ca = ctx.r[18].u32 <= 4 as u32;
	ctx.r[9].s64 = (4 as i64) - ctx.r[18].s64;
	// 82A0C8F8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0C8FC: 3A60FFC0  li r19, -0x40
	ctx.r[19].s64 = -64;
	// 82A0C900: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 82A0C904: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 82A0C908: 38CA91B0  addi r6, r10, -0x6e50
	ctx.r[6].s64 = ctx.r[10].s64 + -28240;
	// 82A0C90C: 4198023C  blt cr6, 0x82a0cb48
	if ctx.cr[6].lt {
	pc = 0x82A0CB48; continue 'dispatch;
	}
	// 82A0C910: 7D7200D0  neg r11, r18
	ctx.r[11].s64 = -ctx.r[18].s64;
	// 82A0C914: D0E10050  stfs f7, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A0C918: 23860080  subfic r28, r6, 0x80
	ctx.xer.ca = ctx.r[6].u32 <= 128 as u32;
	ctx.r[28].s64 = (128 as i64) - ctx.r[6].s64;
	// 82A0C91C: D0E10054  stfs f7, 0x54(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A0C920: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0C924: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82A0C928: 23660050  subfic r27, r6, 0x50
	ctx.xer.ca = ctx.r[6].u32 <= 80 as u32;
	ctx.r[27].s64 = (80 as i64) - ctx.r[6].s64;
	// 82A0C92C: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82A0C930: 23460090  subfic r26, r6, 0x90
	ctx.xer.ca = ctx.r[6].u32 <= 144 as u32;
	ctx.r[26].s64 = (144 as i64) - ctx.r[6].s64;
	// 82A0C934: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0C938: 23260020  subfic r25, r6, 0x20
	ctx.xer.ca = ctx.r[6].u32 <= 32 as u32;
	ctx.r[25].s64 = (32 as i64) - ctx.r[6].s64;
	// 82A0C93C: 7D0B9214  add r8, r11, r18
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[18].u64;
	// 82A0C940: 23060060  subfic r24, r6, 0x60
	ctx.xer.ca = ctx.r[6].u32 <= 96 as u32;
	ctx.r[24].s64 = (96 as i64) - ctx.r[6].s64;
	// 82A0C944: 3932003C  addi r9, r18, 0x3c
	ctx.r[9].s64 = ctx.r[18].s64 + 60;
	// 82A0C948: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 82A0C94C: 22E600A0  subfic r23, r6, 0xa0
	ctx.xer.ca = ctx.r[6].u32 <= 160 as u32;
	ctx.r[23].s64 = (160 as i64) - ctx.r[6].s64;
	// 82A0C950: 22C60030  subfic r22, r6, 0x30
	ctx.xer.ca = ctx.r[6].u32 <= 48 as u32;
	ctx.r[22].s64 = (48 as i64) - ctx.r[6].s64;
	// 82A0C954: 22A60070  subfic r21, r6, 0x70
	ctx.xer.ca = ctx.r[6].u32 <= 112 as u32;
	ctx.r[21].s64 = (112 as i64) - ctx.r[6].s64;
	// 82A0C958: 5687402E  slwi r7, r20, 8
	ctx.r[7].u32 = ctx.r[20].u32.wrapping_shl(8);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A0C95C: 56482036  slwi r8, r18, 4
	ctx.r[8].u32 = ctx.r[18].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0C960: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0C964: 228600B0  subfic r20, r6, 0xb0
	ctx.xer.ca = ctx.r[6].u32 <= 176 as u32;
	ctx.r[20].s64 = (176 as i64) - ctx.r[6].s64;
	// 82A0C968: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C96C: 7D683214  add r11, r8, r6
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82A0C970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0C974: FB810080  std r28, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u64 ) };
	// 82A0C978: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82A0C97C: 7CBC5A14  add r5, r28, r11
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82A0C980: 388900C0  addi r4, r9, 0xc0
	ctx.r[4].s64 = ctx.r[9].s64 + 192;
	// 82A0C984: 7E454A14  add r18, r5, r9
	ctx.r[18].u64 = ctx.r[5].u64 + ctx.r[9].u64;
	pc = 0x82A0CB48; continue 'dispatch;
            }
            0x82A0CB48 => {
    //   block [0x82A0CB48..0x82A0CBE4)
	// 82A0CB48: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A0CB4C: 40980098  bge cr6, 0x82a0cbe4
	if !ctx.cr[6].lt {
	pc = 0x82A0CBE4; continue 'dispatch;
	}
	// 82A0CB50: 394B003C  addi r10, r11, 0x3c
	ctx.r[10].s64 = ctx.r[11].s64 + 60;
	// 82A0CB54: D0E10050  stfs f7, 0x50(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A0CB58: D0E10054  stfs f7, 0x54(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A0CB5C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82A0CB60: 5684402E  slwi r4, r20, 8
	ctx.r[4].u32 = ctx.r[20].u32.wrapping_shl(8);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0CB64: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0CB68: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0CB6C: 20660080  subfic r3, r6, 0x80
	ctx.xer.ca = ctx.r[6].u32 <= 128 as u32;
	ctx.r[3].s64 = (128 as i64) - ctx.r[6].s64;
	// 82A0CB70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0CB74: 7D093214  add r8, r9, r6
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 82A0CB78: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A0CB7C: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82A0CB80: 7CA81A14  add r5, r8, r3
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 82A0CB84: 38EB00C0  addi r7, r11, 0xc0
	ctx.r[7].s64 = ctx.r[11].s64 + 192;
	// 82A0CB88: 7F655A14  add r27, r5, r11
	ctx.r[27].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	pc = 0x82A0CBE4; continue 'dispatch;
            }
            0x82A0CBE4 => {
    //   block [0x82A0CBE4..0x82A0CBF4)
	// 82A0CBE4: 568B103A  slwi r11, r20, 2
	ctx.r[11].u32 = ctx.r[20].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0CBE8: 7C6B9214  add r3, r11, r18
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[18].u64;
	// 82A0CBEC: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A0CBF0: 4829C830  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0CBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A0CBF8 size=368
    let mut pc: u32 = 0x82A0CBF8;
    'dispatch: loop {
        match pc {
            0x82A0CBF8 => {
    //   block [0x82A0CBF8..0x82A0CC5C)
	// 82A0CBF8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82A0CBFC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82A0CC00: 83E40034  lwz r31, 0x34(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A0CC04: C0040030  lfs f0, 0x30(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0CC08: 3904002C  addi r8, r4, 0x2c
	ctx.r[8].s64 = ctx.r[4].s64 + 44;
	// 82A0CC0C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A0CC10: 419A014C  beq cr6, 0x82a0cd5c
	if ctx.cr[6].eq {
	pc = 0x82A0CD5C; continue 'dispatch;
	}
	// 82A0CC14: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0CC18: 396300F0  addi r11, r3, 0xf0
	ctx.r[11].s64 = ctx.r[3].s64 + 240;
	// 82A0CC1C: 392A91B0  addi r9, r10, -0x6e50
	ctx.r[9].s64 = ctx.r[10].s64 + -28240;
	// 82A0CC20: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82A0CC24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A0CC28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A0CC2C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0CC30: 419A0054  beq cr6, 0x82a0cc84
	if ctx.cr[6].eq {
	pc = 0x82A0CC84; continue 'dispatch;
	}
	// 82A0CC34: C1ABFFE0  lfs f13, -0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0CC38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0CC3C: 41990048  bgt cr6, 0x82a0cc84
	if ctx.cr[6].gt {
	pc = 0x82A0CC84; continue 'dispatch;
	}
	// 82A0CC40: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0CC44: 41980018  blt cr6, 0x82a0cc5c
	if ctx.cr[6].lt {
	pc = 0x82A0CC5C; continue 'dispatch;
	}
	// 82A0CC48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0CC4C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0CC50: 4198000C  blt cr6, 0x82a0cc5c
	if ctx.cr[6].lt {
	pc = 0x82A0CC5C; continue 'dispatch;
	}
	// 82A0CC54: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A0CC58: 4800002C  b 0x82a0cc84
	pc = 0x82A0CC84; continue 'dispatch;
            }
            0x82A0CC5C => {
    //   block [0x82A0CC5C..0x82A0CC84)
	// 82A0CC5C: 394300D0  addi r10, r3, 0xd0
	ctx.r[10].s64 = ctx.r[3].s64 + 208;
	pc = 0x82A0CC84; continue 'dispatch;
            }
            0x82A0CC84 => {
    //   block [0x82A0CC84..0x82A0CD5C)
	// 82A0CC84: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A0CC88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0CC8C: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 82A0CC90: 4082FF9C  bne 0x82a0cc2c
	if !ctx.cr[0].eq {
	pc = 0x82A0CC2C; continue 'dispatch;
	}
	// 82A0CC94: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A0CC98: 419A00C4  beq cr6, 0x82a0cd5c
	if ctx.cr[6].eq {
	pc = 0x82A0CD5C; continue 'dispatch;
	}
	// 82A0CC9C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A0CCA0: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0CCA4: 396300D0  addi r11, r3, 0xd0
	ctx.r[11].s64 = ctx.r[3].s64 + 208;
	// 82A0CCA8: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82A0CCAC: C00892D4  lfs f0, -0x6d2c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0CCB0: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0CCB4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0CCB8: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 82A0CCBC: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A0CCC0: 7CA64050  subf r5, r6, r8
	ctx.r[5].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 82A0CCC4: 54A3103A  slwi r3, r5, 2
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A0CCC8: 7D83542E  lfsx f12, r3, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0CCCC: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A0CCD0: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A0CCD4: D941FFD0  stfd f10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[10].u64 ) };
	// 82A0CCD8: 8101FFD4  lwz r8, -0x2c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82A0CCDC: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 82A0CCE0: F8E1FFD8  std r7, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[7].u64 ) };
	// 82A0CCE4: C921FFD8  lfd f9, -0x28(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A0CCE8: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A0CCEC: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A0CCF0: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A0CCF4: 4198005C  blt cr6, 0x82a0cd50
	if ctx.cr[6].lt {
	pc = 0x82A0CD50; continue 'dispatch;
	}
	// 82A0CCF8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0CCFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0CD00: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A0CD04: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0CD08: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0CD0C: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0CD10: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 82A0CD14: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A0CD18: 7CA64050  subf r5, r6, r8
	ctx.r[5].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 82A0CD1C: 54A3103A  slwi r3, r5, 2
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A0CD20: 7D83542E  lfsx f12, r3, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0CD24: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A0CD28: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A0CD2C: D941FFD0  stfd f10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[10].u64 ) };
	// 82A0CD30: 8101FFD4  lwz r8, -0x2c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82A0CD34: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 82A0CD38: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82A0CD3C: C921FFE0  lfd f9, -0x20(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A0CD40: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A0CD44: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A0CD48: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A0CD4C: 4098FFAC  bge cr6, 0x82a0ccf8
	if !ctx.cr[6].lt {
	pc = 0x82A0CCF8; continue 'dispatch;
	}
	// 82A0CD50: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A0CD54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0CD58: 4082FF58  bne 0x82a0ccb0
	if !ctx.cr[0].eq {
	pc = 0x82A0CCB0; continue 'dispatch;
	}
	pc = 0x82A0CD5C; continue 'dispatch;
            }
            0x82A0CD5C => {
    //   block [0x82A0CD5C..0x82A0CD68)
	// 82A0CD5C: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0CD60: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82A0CD64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0CD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0CD68 size=444
    let mut pc: u32 = 0x82A0CD68;
    'dispatch: loop {
        match pc {
            0x82A0CD68 => {
    //   block [0x82A0CD68..0x82A0CF24)
	// 82A0CD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0CD6C: 4829C675  bl 0x82ca93e0
	ctx.lr = 0x82A0CD70;
	sub_82CA93D0(ctx, base);
	// 82A0CD70: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82A0CD74: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0CF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0CF28 size=384
    let mut pc: u32 = 0x82A0CF28;
    'dispatch: loop {
        match pc {
            0x82A0CF28 => {
    //   block [0x82A0CF28..0x82A0D0A8)
	// 82A0CF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0CF2C: 4829C4C1  bl 0x82ca93ec
	ctx.lr = 0x82A0CF30;
	sub_82CA93D0(ctx, base);
	// 82A0CF30: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A0CF34: 80A300EC  lwz r5, 0xec(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A0CF38: 83E300E8  lwz r31, 0xe8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A0CF3C: 396300D0  addi r11, r3, 0xd0
	ctx.r[11].s64 = ctx.r[3].s64 + 208;
	// 82A0CF40: 83C300E4  lwz r30, 0xe4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A0CF44: 3945FFFF  addi r10, r5, -1
	ctx.r[10].s64 = ctx.r[5].s64 + -1;
	// 82A0CF48: 83A300E0  lwz r29, 0xe0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 82A0CF4C: 393FFFFF  addi r9, r31, -1
	ctx.r[9].s64 = ctx.r[31].s64 + -1;
	// 82A0CF50: 391EFFFF  addi r8, r30, -1
	ctx.r[8].s64 = ctx.r[30].s64 + -1;
	// 82A0CF54: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0CF58: 7D5AFE70  srawi r26, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A0CF5C: 11A1038C  vspltisw v13, 1
	for i in 0..4 {
		ctx.v[13].u32[i] = 1;
	}
	// 82A0CF60: 38FDFFFF  addi r7, r29, -1
	ctx.r[7].s64 = ctx.r[29].s64 + -1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0D0A8 size=452
    let mut pc: u32 = 0x82A0D0A8;
    'dispatch: loop {
        match pc {
            0x82A0D0A8 => {
    //   block [0x82A0D0A8..0x82A0D0DC)
	// 82A0D0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D0AC: 4829C349  bl 0x82ca93f4
	ctx.lr = 0x82A0D0B0;
	sub_82CA93D0(ctx, base);
	// 82A0D0B0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0D0B4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A0D0B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A0D0BC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A0D0C0: 4881BA89  bl 0x83228b48
	ctx.lr = 0x82A0D0C4;
	sub_83228B48(ctx, base);
	// 82A0D0C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0D0C8: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0D0CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0D0D0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A0D0D4: 419A0008  beq cr6, 0x82a0d0dc
	if ctx.cr[6].eq {
	pc = 0x82A0D0DC; continue 'dispatch;
	}
	// 82A0D0D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0D0DC; continue 'dispatch;
            }
            0x82A0D0DC => {
    //   block [0x82A0D0DC..0x82A0D0F4)
	// 82A0D0DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0D0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0D0E4: 419A0010  beq cr6, 0x82a0d0f4
	if ctx.cr[6].eq {
	pc = 0x82A0D0F4; continue 'dispatch;
	}
	// 82A0D0E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0D0EC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A0D0F0: 4829C354  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0D0F4 => {
    //   block [0x82A0D0F4..0x82A0D118)
	// 82A0D0F4: 81790154  lwz r11, 0x154(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0D0F8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82A0D0FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0D100: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A0D104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0D108: 40990154  ble cr6, 0x82a0d25c
	if !ctx.cr[6].gt {
	pc = 0x82A0D25C; continue 'dispatch;
	}
	// 82A0D10C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A0D110: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A0D114: 3B0B1A60  addi r24, r11, 0x1a60
	ctx.r[24].s64 = ctx.r[11].s64 + 6752;
	pc = 0x82A0D118; continue 'dispatch;
            }
            0x82A0D118 => {
    //   block [0x82A0D118..0x82A0D1A8)
	// 82A0D118: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0D11C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A0D120: 813B001C  lwz r9, 0x1c(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0D124: 7D1D5A14  add r8, r29, r11
	ctx.r[8].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A0D128: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D12C: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A0D130: 1D67002C  mulli r11, r7, 0x2c
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A0D134: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A0D138: 89670014  lbz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0D13C: C027000C  lfs f1, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0D140: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 82A0D144: 48821AA5  bl 0x8322ebe8
	ctx.lr = 0x82A0D148;
	sub_8322EBE8(ctx, base);
	// 82A0D148: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A0D14C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A0D150: 409A008C  bne cr6, 0x82a0d1dc
	if !ctx.cr[6].eq {
	pc = 0x82A0D1DC; continue 'dispatch;
	}
	// 82A0D154: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0D158: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0D15C: 80DC001C  lwz r6, 0x1c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0D160: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0D164: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A0D168: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D16C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0D170: 7C8B3038  and r11, r4, r6
	ctx.r[11].u64 = ctx.r[4].u64 & ctx.r[6].u64;
	// 82A0D174: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A0D178: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0D17C: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 82A0D180: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A0D184: 7CE8192E  stwx r7, r8, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32), ctx.r[7].u32) };
	// 82A0D188: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0D18C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A0D190: 7D48292E  stwx r10, r8, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32), ctx.r[10].u32) };
	// 82A0D194: 409A0048  bne cr6, 0x82a0d1dc
	if !ctx.cr[6].eq {
	pc = 0x82A0D1DC; continue 'dispatch;
	}
	// 82A0D198: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D19C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A0D1A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0D1A4: 7CDA5A14  add r6, r26, r11
	ctx.r[6].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	pc = 0x82A0D1A8; continue 'dispatch;
            }
            0x82A0D1A8 => {
    //   block [0x82A0D1A8..0x82A0D1DC)
	// 82A0D1A8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A0D1AC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A0D1B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0D1B4: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A0D1B8: 7C9F502E  lwzx r4, r31, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A0D1BC: 48813EA5  bl 0x83221060
	ctx.lr = 0x82A0D1C0;
	sub_83221060(ctx, base);
	// 82A0D1C0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A0D1C4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A0D1C8: 2F1F0010  cmpwi cr6, r31, 0x10
	ctx.cr[6].compare_i32(ctx.r[31].s32, 16, &mut ctx.xer);
	// 82A0D1CC: 4198FFDC  blt cr6, 0x82a0d1a8
	if ctx.cr[6].lt {
	pc = 0x82A0D1A8; continue 'dispatch;
	}
	// 82A0D1D0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82A0D1D4: 3B5A01C0  addi r26, r26, 0x1c0
	ctx.r[26].s64 = ctx.r[26].s64 + 448;
	// 82A0D1D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82A0D1DC; continue 'dispatch;
            }
            0x82A0D1DC => {
    //   block [0x82A0D1DC..0x82A0D200)
	// 82A0D1DC: 81790154  lwz r11, 0x154(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0D1E0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82A0D1E4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0D1E8: 4198FF30  blt cr6, 0x82a0d118
	if ctx.cr[6].lt {
	pc = 0x82A0D118; continue 'dispatch;
	}
	// 82A0D1EC: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0D1F0: 4099006C  ble cr6, 0x82a0d25c
	if !ctx.cr[6].gt {
	pc = 0x82A0D25C; continue 'dispatch;
	}
	// 82A0D1F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A0D1F8: 1F9701C0  mulli r28, r23, 0x1c0
	ctx.r[28].s32 = ((ctx.r[23].s32 as i64 * 448 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82A0D1FC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82A0D200; continue 'dispatch;
            }
            0x82A0D200 => {
    //   block [0x82A0D200..0x82A0D240)
	// 82A0D200: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A0D204: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D208: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A0D20C: 7CDC5A14  add r6, r28, r11
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82A0D210: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0D214: 7CBE502E  lwzx r5, r30, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A0D218: 7C9E482E  lwzx r4, r30, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A0D21C: 48813E45  bl 0x83221060
	ctx.lr = 0x82A0D220;
	sub_83221060(ctx, base);
	// 82A0D220: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82A0D224: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A0D228: 7F1DF800  cmpw cr6, r29, r31
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82A0D22C: 4198FFD4  blt cr6, 0x82a0d200
	if ctx.cr[6].lt {
	pc = 0x82A0D200; continue 'dispatch;
	}
	// 82A0D230: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A0D234: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 82A0D238: 40980024  bge cr6, 0x82a0d25c
	if !ctx.cr[6].lt {
	pc = 0x82A0D25C; continue 'dispatch;
	}
	// 82A0D23C: 1FB701C0  mulli r29, r23, 0x1c0
	ctx.r[29].s32 = ((ctx.r[23].s32 as i64 * 448 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	pc = 0x82A0D240; continue 'dispatch;
            }
            0x82A0D240 => {
    //   block [0x82A0D240..0x82A0D25C)
	// 82A0D240: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0D248: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A0D24C: 488136D5  bl 0x83220920
	ctx.lr = 0x82A0D250;
	sub_83220920(ctx, base);
	// 82A0D250: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A0D254: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82A0D258: 4198FFE8  blt cr6, 0x82a0d240
	if ctx.cr[6].lt {
	pc = 0x82A0D240; continue 'dispatch;
	}
	pc = 0x82A0D25C; continue 'dispatch;
            }
            0x82A0D25C => {
    //   block [0x82A0D25C..0x82A0D26C)
	// 82A0D25C: 56EB103A  slwi r11, r23, 2
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0D260: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A0D264: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A0D268: 4829C1DC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0D270 size=424
    let mut pc: u32 = 0x82A0D270;
    'dispatch: loop {
        match pc {
            0x82A0D270 => {
    //   block [0x82A0D270..0x82A0D2E8)
	// 82A0D270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D274: 4829C189  bl 0x82ca93fc
	ctx.lr = 0x82A0D278;
	sub_82CA93D0(ctx, base);
	// 82A0D278: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A0D27C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0D280: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A0D284: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A0D288: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A0D28C: 391D002C  addi r8, r29, 0x2c
	ctx.r[8].s64 = ctx.r[29].s64 + 44;
	// 82A0D290: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A0D294: 80DD0034  lwz r6, 0x34(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A0D298: C01D0030  lfs f0, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0D29C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A0D2A0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A0D2A4: 419A007C  beq cr6, 0x82a0d320
	if ctx.cr[6].eq {
	pc = 0x82A0D320; continue 'dispatch;
	}
	// 82A0D2A8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0D2AC: 396301B0  addi r11, r3, 0x1b0
	ctx.r[11].s64 = ctx.r[3].s64 + 432;
	// 82A0D2B0: 392A91B0  addi r9, r10, -0x6e50
	ctx.r[9].s64 = ctx.r[10].s64 + -28240;
	// 82A0D2B4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A0D2B8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A0D2BC: 419A0054  beq cr6, 0x82a0d310
	if ctx.cr[6].eq {
	pc = 0x82A0D310; continue 'dispatch;
	}
	// 82A0D2C0: C1ABFFD0  lfs f13, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0D2C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0D2C8: 41990048  bgt cr6, 0x82a0d310
	if ctx.cr[6].gt {
	pc = 0x82A0D310; continue 'dispatch;
	}
	// 82A0D2CC: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A0D2D0: 41980018  blt cr6, 0x82a0d2e8
	if ctx.cr[6].lt {
	pc = 0x82A0D2E8; continue 'dispatch;
	}
	// 82A0D2D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D2D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A0D2DC: 4198000C  blt cr6, 0x82a0d2e8
	if ctx.cr[6].lt {
	pc = 0x82A0D2E8; continue 'dispatch;
	}
	// 82A0D2E0: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82A0D2E4: 4800002C  b 0x82a0d310
	pc = 0x82A0D310; continue 'dispatch;
            }
            0x82A0D2E8 => {
    //   block [0x82A0D2E8..0x82A0D310)
	// 82A0D2E8: 39430180  addi r10, r3, 0x180
	ctx.r[10].s64 = ctx.r[3].s64 + 384;
	pc = 0x82A0D310; continue 'dispatch;
            }
            0x82A0D310 => {
    //   block [0x82A0D310..0x82A0D320)
	// 82A0D310: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A0D314: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0D318: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 82A0D31C: 4082FF9C  bne 0x82a0d2b8
	if !ctx.cr[0].eq {
	pc = 0x82A0D2B8; continue 'dispatch;
	}
	pc = 0x82A0D320; continue 'dispatch;
            }
            0x82A0D320 => {
    //   block [0x82A0D320..0x82A0D418)
	// 82A0D320: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82A0D324: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A0D328: 419A00E4  beq cr6, 0x82a0d40c
	if ctx.cr[6].eq {
	pc = 0x82A0D40C; continue 'dispatch;
	}
	// 82A0D32C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0D330: 3BE30180  addi r31, r3, 0x180
	ctx.r[31].s64 = ctx.r[3].s64 + 384;
	// 82A0D334: C3EB92D4  lfs f31, -0x6d2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0D338: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0D33C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0D340: 813D0010  lwz r9, 0x10(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0D344: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82A0D348: 7D68FE70  srawi r8, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 82A0D34C: 7D075838  and r7, r8, r11
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[11].u64;
	// 82A0D350: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A0D354: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A0D358: 7DA54C2E  lfsx f13, r5, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0D35C: ED8DF82A  fadds f12, f13, f31
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A0D360: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A0D364: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 82A0D368: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0D36C: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 82A0D370: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82A0D374: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0D378: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82A0D37C: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82A0D380: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 82A0D384: 41980060  blt cr6, 0x82a0d3e4
	if ctx.cr[6].lt {
	pc = 0x82A0D3E4; continue 'dispatch;
	}
	// 82A0D388: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A0D38C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0D390: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0D394: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A0D398: 5568003E  slwi r8, r11, 0
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0D39C: 813D0010  lwz r9, 0x10(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0D3A0: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0D3A4: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 82A0D3A8: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A0D3AC: 7CA64050  subf r5, r6, r8
	ctx.r[5].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 82A0D3B0: 54A4103A  slwi r4, r5, 2
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0D3B4: 7DA44C2E  lfsx f13, r4, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0D3B8: ED8DF82A  fadds f12, f13, f31
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A0D3BC: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A0D3C0: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 82A0D3C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0D3C8: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82A0D3CC: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 82A0D3D0: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0D3D4: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82A0D3D8: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82A0D3DC: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 82A0D3E0: 4098FFAC  bge cr6, 0x82a0d38c
	if !ctx.cr[6].lt {
	pc = 0x82A0D38C; continue 'dispatch;
	}
	// 82A0D3E4: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0D3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0D3EC: 419A0010  beq cr6, 0x82a0d3fc
	if ctx.cr[6].eq {
	pc = 0x82A0D3FC; continue 'dispatch;
	}
	// 82A0D3F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A0D3F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0D3F8: 488133F1  bl 0x832207e8
	ctx.lr = 0x82A0D3FC;
	sub_832207E8(ctx, base);
	// 82A0D3FC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A0D400: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A0D404: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0D408: 4198FF30  blt cr6, 0x82a0d338
	if ctx.cr[6].lt {
	pc = 0x82A0D338; continue 'dispatch;
	}
	// 82A0D40C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A0D410: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A0D414: 4829C038  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0D418 size=444
    let mut pc: u32 = 0x82A0D418;
    'dispatch: loop {
        match pc {
            0x82A0D418 => {
    //   block [0x82A0D418..0x82A0D5D4)
	// 82A0D418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D41C: 4829BFC5  bl 0x82ca93e0
	ctx.lr = 0x82A0D420;
	sub_82CA93D0(ctx, base);
	// 82A0D420: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82A0D424: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0D5D8 size=384
    let mut pc: u32 = 0x82A0D5D8;
    'dispatch: loop {
        match pc {
            0x82A0D5D8 => {
    //   block [0x82A0D5D8..0x82A0D758)
	// 82A0D5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D5DC: 4829BE19  bl 0x82ca93f4
	ctx.lr = 0x82A0D5E0;
	sub_82CA93D0(ctx, base);
	// 82A0D5E0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A0D5E4: 80A3019C  lwz r5, 0x19c(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A0D5E8: 83E30198  lwz r31, 0x198(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(408 as u32) ) } as u64;
	// 82A0D5EC: 39630180  addi r11, r3, 0x180
	ctx.r[11].s64 = ctx.r[3].s64 + 384;
	// 82A0D5F0: 7CAA07B4  extsw r10, r5
	ctx.r[10].s64 = ctx.r[5].s32 as i64;
	// 82A0D5F4: 83C30194  lwz r30, 0x194(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82A0D5F8: 7FE907B4  extsw r9, r31
	ctx.r[9].s64 = ctx.r[31].s32 as i64;
	// 82A0D5FC: 83A30190  lwz r29, 0x190(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(400 as u32) ) } as u64;
	// 82A0D600: F941FF90  std r10, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[10].u64 ) };
	// 82A0D604: 3945FFFF  addi r10, r5, -1
	ctx.r[10].s64 = ctx.r[5].s64 + -1;
	// 82A0D608: F921FF88  std r9, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.r[9].u64 ) };
	// 82A0D60C: 393FFFFF  addi r9, r31, -1
	ctx.r[9].s64 = ctx.r[31].s64 + -1;
	// 82A0D610: 391EFFFF  addi r8, r30, -1
	ctx.r[8].s64 = ctx.r[30].s64 + -1;
	// 82A0D614: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A0D618: 7D5AFE70  srawi r26, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> 31) as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0D758 size=72
    let mut pc: u32 = 0x82A0D758;
    'dispatch: loop {
        match pc {
            0x82A0D758 => {
    //   block [0x82A0D758..0x82A0D78C)
	// 82A0D758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0D760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0D764: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0D768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0D76C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A0D770: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82A0D774: 392B2390  addi r9, r11, 0x2390
	ctx.r[9].s64 = ctx.r[11].s64 + 9104;
	// 82A0D778: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0D77C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0D780: 419A000C  beq cr6, 0x82a0d78c
	if ctx.cr[6].eq {
	pc = 0x82A0D78C; continue 'dispatch;
	}
	// 82A0D784: 4B80E5B5  bl 0x8221bd38
	ctx.lr = 0x82A0D788;
	sub_8221BD38(ctx, base);
	// 82A0D788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0D78C; continue 'dispatch;
            }
            0x82A0D78C => {
    //   block [0x82A0D78C..0x82A0D7A0)
	// 82A0D78C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0D790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0D794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0D798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0D79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0D7A0 size=80
    let mut pc: u32 = 0x82A0D7A0;
    'dispatch: loop {
        match pc {
            0x82A0D7A0 => {
    //   block [0x82A0D7A0..0x82A0D7D8)
	// 82A0D7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0D7A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0D7AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0D7B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0D7B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0D7B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0D7BC: 4881BB5D  bl 0x83229318
	ctx.lr = 0x82A0D7C0;
	sub_83229318(ctx, base);
	// 82A0D7C0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A0D7C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0D7C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0D7CC: 419A000C  beq cr6, 0x82a0d7d8
	if ctx.cr[6].eq {
	pc = 0x82A0D7D8; continue 'dispatch;
	}
	// 82A0D7D0: 4B80E569  bl 0x8221bd38
	ctx.lr = 0x82A0D7D4;
	sub_8221BD38(ctx, base);
	// 82A0D7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0D7D8; continue 'dispatch;
            }
            0x82A0D7D8 => {
    //   block [0x82A0D7D8..0x82A0D7F0)
	// 82A0D7D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0D7DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0D7E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0D7E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0D7E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0D7EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0D7F0 size=260
    let mut pc: u32 = 0x82A0D7F0;
    'dispatch: loop {
        match pc {
            0x82A0D7F0 => {
    //   block [0x82A0D7F0..0x82A0D818)
	// 82A0D7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D7F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0D7F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0D7FC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A0D800: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D804: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D808: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0D80C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0D810: 409A0044  bne cr6, 0x82a0d854
	if !ctx.cr[6].eq {
	pc = 0x82A0D854; continue 'dispatch;
	}
	// 82A0D814: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A0D818; continue 'dispatch;
            }
            0x82A0D818 => {
    //   block [0x82A0D818..0x82A0D82C)
	// 82A0D818: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0D81C: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82A0D820: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0D824: 41980008  blt cr6, 0x82a0d82c
	if ctx.cr[6].lt {
	pc = 0x82A0D82C; continue 'dispatch;
	}
	// 82A0D828: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A0D82C; continue 'dispatch;
            }
            0x82A0D82C => {
    //   block [0x82A0D82C..0x82A0D840)
	// 82A0D82C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0D830: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0D834: 419A000C  beq cr6, 0x82a0d840
	if ctx.cr[6].eq {
	pc = 0x82A0D840; continue 'dispatch;
	}
	// 82A0D838: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0D83C: 4800000C  b 0x82a0d848
	pc = 0x82A0D848; continue 'dispatch;
            }
            0x82A0D840 => {
    //   block [0x82A0D840..0x82A0D848)
	// 82A0D840: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A0D844: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A0D848; continue 'dispatch;
            }
            0x82A0D848 => {
    //   block [0x82A0D848..0x82A0D854)
	// 82A0D848: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0D84C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0D850: 419AFFC8  beq cr6, 0x82a0d818
	if ctx.cr[6].eq {
	pc = 0x82A0D818; continue 'dispatch;
	}
	pc = 0x82A0D854; continue 'dispatch;
            }
            0x82A0D854 => {
    //   block [0x82A0D854..0x82A0D884)
	// 82A0D854: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D858: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A0D85C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A0D860: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A0D864: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0D868: 419A0028  beq cr6, 0x82a0d890
	if ctx.cr[6].eq {
	pc = 0x82A0D890; continue 'dispatch;
	}
	// 82A0D86C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D870: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0D874: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A0D878: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0D87C: 41980008  blt cr6, 0x82a0d884
	if ctx.cr[6].lt {
	pc = 0x82A0D884; continue 'dispatch;
	}
	// 82A0D880: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0D884; continue 'dispatch;
            }
            0x82A0D884 => {
    //   block [0x82A0D884..0x82A0D890)
	// 82A0D884: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0D888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0D88C: 419A0038  beq cr6, 0x82a0d8c4
	if ctx.cr[6].eq {
	pc = 0x82A0D8C4; continue 'dispatch;
	}
	pc = 0x82A0D890; continue 'dispatch;
            }
            0x82A0D890 => {
    //   block [0x82A0D890..0x82A0D8C4)
	// 82A0D890: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D894: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0D898: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A0D89C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0D8A0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A0D8A4: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82A0D8A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0D8AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0D8B0: 48000111  bl 0x82a0d9c0
	ctx.lr = 0x82A0D8B4;
	sub_82A0D9C0(ctx, base);
	// 82A0D8B4: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A0D8B8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A0D8BC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0D8C0: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A0D8C4; continue 'dispatch;
            }
            0x82A0D8C4 => {
    //   block [0x82A0D8C4..0x82A0D8D0)
	// 82A0D8C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A0D8C8: 409A0008  bne cr6, 0x82a0d8d0
	if !ctx.cr[6].eq {
	pc = 0x82A0D8D0; continue 'dispatch;
	}
	// 82A0D8CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0D8D0; continue 'dispatch;
            }
            0x82A0D8D0 => {
    //   block [0x82A0D8D0..0x82A0D8E0)
	// 82A0D8D0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D8D4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0D8D8: 409A0008  bne cr6, 0x82a0d8e0
	if !ctx.cr[6].eq {
	pc = 0x82A0D8E0; continue 'dispatch;
	}
	// 82A0D8DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0D8E0; continue 'dispatch;
            }
            0x82A0D8E0 => {
    //   block [0x82A0D8E0..0x82A0D8F4)
	// 82A0D8E0: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 82A0D8E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0D8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0D8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0D8F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0D8F8 size=164
    let mut pc: u32 = 0x82A0D8F8;
    'dispatch: loop {
        match pc {
            0x82A0D8F8 => {
    //   block [0x82A0D8F8..0x82A0D910)
	// 82A0D8F8: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D8FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D900: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0D904: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0D908: 409A0044  bne cr6, 0x82a0d94c
	if !ctx.cr[6].eq {
	pc = 0x82A0D94C; continue 'dispatch;
	}
	// 82A0D90C: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A0D910; continue 'dispatch;
            }
            0x82A0D910 => {
    //   block [0x82A0D910..0x82A0D924)
	// 82A0D910: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0D914: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A0D918: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0D91C: 41980008  blt cr6, 0x82a0d924
	if ctx.cr[6].lt {
	pc = 0x82A0D924; continue 'dispatch;
	}
	// 82A0D920: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A0D924; continue 'dispatch;
            }
            0x82A0D924 => {
    //   block [0x82A0D924..0x82A0D938)
	// 82A0D924: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0D928: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0D92C: 419A000C  beq cr6, 0x82a0d938
	if ctx.cr[6].eq {
	pc = 0x82A0D938; continue 'dispatch;
	}
	// 82A0D930: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0D934: 4800000C  b 0x82a0d940
	pc = 0x82A0D940; continue 'dispatch;
            }
            0x82A0D938 => {
    //   block [0x82A0D938..0x82A0D940)
	// 82A0D938: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A0D93C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A0D940; continue 'dispatch;
            }
            0x82A0D940 => {
    //   block [0x82A0D940..0x82A0D94C)
	// 82A0D940: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0D944: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0D948: 419AFFC8  beq cr6, 0x82a0d910
	if ctx.cr[6].eq {
	pc = 0x82A0D910; continue 'dispatch;
	}
	pc = 0x82A0D94C; continue 'dispatch;
            }
            0x82A0D94C => {
    //   block [0x82A0D94C..0x82A0D978)
	// 82A0D94C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D950: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 82A0D954: 9081FFF0  stw r4, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u32 ) };
	// 82A0D958: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0D95C: 419A0040  beq cr6, 0x82a0d99c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A0D99C);
		return;
	}
	// 82A0D960: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D964: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0D968: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A0D96C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0D970: 41980008  blt cr6, 0x82a0d978
	if ctx.cr[6].lt {
	pc = 0x82A0D978; continue 'dispatch;
	}
	// 82A0D974: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0D978; continue 'dispatch;
            }
            0x82A0D978 => {
    //   block [0x82A0D978..0x82A0D99C)
	// 82A0D978: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0D97C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0D980: 409A001C  bne cr6, 0x82a0d99c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A0D99C);
		return;
	}
	// 82A0D984: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 82A0D988: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D98C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0D990: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0D994: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0D998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0D9C0 size=660
    let mut pc: u32 = 0x82A0D9C0;
    'dispatch: loop {
        match pc {
            0x82A0D9C0 => {
    //   block [0x82A0D9C0..0x82A0DA14)
	// 82A0D9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D9C4: 4829BA3D  bl 0x82ca9400
	ctx.lr = 0x82A0D9C8;
	sub_82CA93D0(ctx, base);
	// 82A0D9C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0D9CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0D9D0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A0D9D4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A0D9D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0D9DC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A0D9E0: FBE100C0  std r31, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u64 ) };
	// 82A0D9E4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A0D9E8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0D9EC: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A0D9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0D9F4: 409A0020  bne cr6, 0x82a0da14
	if !ctx.cr[6].eq {
	pc = 0x82A0DA14; continue 'dispatch;
	}
	// 82A0D9F8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A0D9FC: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DA00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A0DA04: 480003AD  bl 0x82a0ddb0
	ctx.lr = 0x82A0DA08;
	sub_82A0DDB0(ctx, base);
	// 82A0DA08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DA0C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0DA10: 4829BA40  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0DA14 => {
    //   block [0x82A0DA14..0x82A0DA30)
	// 82A0DA14: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DA18: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A0DA1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DA20: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DA24: 419A000C  beq cr6, 0x82a0da30
	if ctx.cr[6].eq {
	pc = 0x82A0DA30; continue 'dispatch;
	}
	// 82A0DA28: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0DA2C: 419A0008  beq cr6, 0x82a0da34
	if ctx.cr[6].eq {
	pc = 0x82A0DA34; continue 'dispatch;
	}
	pc = 0x82A0DA30; continue 'dispatch;
            }
            0x82A0DA30 => {
    //   block [0x82A0DA30..0x82A0DA34)
	// 82A0DA30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0DA34; continue 'dispatch;
            }
            0x82A0DA34 => {
    //   block [0x82A0DA34..0x82A0DA58)
	// 82A0DA34: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0DA38: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0DA3C: 409A004C  bne cr6, 0x82a0da88
	if !ctx.cr[6].eq {
	pc = 0x82A0DA88; continue 'dispatch;
	}
	// 82A0DA40: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DA44: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0DA48: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A0DA4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0DA50: 41980008  blt cr6, 0x82a0da58
	if ctx.cr[6].lt {
	pc = 0x82A0DA58; continue 'dispatch;
	}
	// 82A0DA54: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A0DA58; continue 'dispatch;
            }
            0x82A0DA58 => {
    //   block [0x82A0DA58..0x82A0DA88)
	// 82A0DA58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0DA5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DA60: 419A01C4  beq cr6, 0x82a0dc24
	if ctx.cr[6].eq {
	pc = 0x82A0DC24; continue 'dispatch;
	}
	// 82A0DA64: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A0DA68: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A0DA6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A0DA70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DA74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DA78: 48000339  bl 0x82a0ddb0
	ctx.lr = 0x82A0DA7C;
	sub_82A0DDB0(ctx, base);
	// 82A0DA7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DA80: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0DA84: 4829B9CC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0DA88 => {
    //   block [0x82A0DA88..0x82A0DA98)
	// 82A0DA88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DA8C: 419A000C  beq cr6, 0x82a0da98
	if ctx.cr[6].eq {
	pc = 0x82A0DA98; continue 'dispatch;
	}
	// 82A0DA90: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0DA94: 419A0008  beq cr6, 0x82a0da9c
	if ctx.cr[6].eq {
	pc = 0x82A0DA9C; continue 'dispatch;
	}
	pc = 0x82A0DA98; continue 'dispatch;
            }
            0x82A0DA98 => {
    //   block [0x82A0DA98..0x82A0DA9C)
	// 82A0DA98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0DA9C; continue 'dispatch;
            }
            0x82A0DA9C => {
    //   block [0x82A0DA9C..0x82A0DAC0)
	// 82A0DA9C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DAA0: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0DAA4: 409A0048  bne cr6, 0x82a0daec
	if !ctx.cr[6].eq {
	pc = 0x82A0DAEC; continue 'dispatch;
	}
	// 82A0DAA8: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0DAAC: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0DAB0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0DAB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0DAB8: 41980008  blt cr6, 0x82a0dac0
	if ctx.cr[6].lt {
	pc = 0x82A0DAC0; continue 'dispatch;
	}
	// 82A0DABC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A0DAC0; continue 'dispatch;
            }
            0x82A0DAC0 => {
    //   block [0x82A0DAC0..0x82A0DAEC)
	// 82A0DAC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0DAC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DAC8: 419A015C  beq cr6, 0x82a0dc24
	if ctx.cr[6].eq {
	pc = 0x82A0DC24; continue 'dispatch;
	}
	// 82A0DACC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A0DAD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A0DAD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DAD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DADC: 480002D5  bl 0x82a0ddb0
	ctx.lr = 0x82A0DAE0;
	sub_82A0DDB0(ctx, base);
	// 82A0DAE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DAE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0DAE8: 4829B968  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0DAEC => {
    //   block [0x82A0DAEC..0x82A0DB00)
	// 82A0DAEC: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0DAF0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A0DAF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0DAF8: 41980008  blt cr6, 0x82a0db00
	if ctx.cr[6].lt {
	pc = 0x82A0DB00; continue 'dispatch;
	}
	// 82A0DAFC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x82A0DB00; continue 'dispatch;
            }
            0x82A0DB00 => {
    //   block [0x82A0DB00..0x82A0DB34)
	// 82A0DB00: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0DB04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0DB08: 419A006C  beq cr6, 0x82a0db74
	if ctx.cr[6].eq {
	pc = 0x82A0DB74; continue 'dispatch;
	}
	// 82A0DB0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DB10: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 82A0DB14: 480A69E5  bl 0x82ab44f8
	ctx.lr = 0x82A0DB18;
	sub_82AB44F8(ctx, base);
	// 82A0DB18: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0DB1C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DB20: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0DB24: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0DB28: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0DB2C: 41980008  blt cr6, 0x82a0db34
	if ctx.cr[6].lt {
	pc = 0x82A0DB34; continue 'dispatch;
	}
	// 82A0DB30: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x82A0DB34; continue 'dispatch;
            }
            0x82A0DB34 => {
    //   block [0x82A0DB34..0x82A0DB60)
	// 82A0DB34: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0DB38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0DB3C: 419A0038  beq cr6, 0x82a0db74
	if ctx.cr[6].eq {
	pc = 0x82A0DB74; continue 'dispatch;
	}
	// 82A0DB40: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0DB44: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A0DB48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DB4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DB50: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0DB54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0DB58: 409A00B8  bne cr6, 0x82a0dc10
	if !ctx.cr[6].eq {
	pc = 0x82A0DC10; continue 'dispatch;
	}
	// 82A0DB5C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A0DB60; continue 'dispatch;
            }
            0x82A0DB60 => {
    //   block [0x82A0DB60..0x82A0DB74)
	// 82A0DB60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A0DB64: 4800024D  bl 0x82a0ddb0
	ctx.lr = 0x82A0DB68;
	sub_82A0DDB0(ctx, base);
	// 82A0DB68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DB6C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0DB70: 4829B8E0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0DB74 => {
    //   block [0x82A0DB74..0x82A0DB88)
	// 82A0DB74: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0DB78: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0DB7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0DB80: 41980008  blt cr6, 0x82a0db88
	if ctx.cr[6].lt {
	pc = 0x82A0DB88; continue 'dispatch;
	}
	// 82A0DB84: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A0DB88; continue 'dispatch;
            }
            0x82A0DB88 => {
    //   block [0x82A0DB88..0x82A0DBB8)
	// 82A0DB88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0DB8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DB90: 419A0094  beq cr6, 0x82a0dc24
	if ctx.cr[6].eq {
	pc = 0x82A0DC24; continue 'dispatch;
	}
	// 82A0DB94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DB98: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 82A0DB9C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DBA0: 4BB48CB9  bl 0x82556858
	ctx.lr = 0x82A0DBA4;
	sub_82556858(ctx, base);
	// 82A0DBA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DBAC: 419A000C  beq cr6, 0x82a0dbb8
	if ctx.cr[6].eq {
	pc = 0x82A0DBB8; continue 'dispatch;
	}
	// 82A0DBB0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0DBB4: 419A0008  beq cr6, 0x82a0dbbc
	if ctx.cr[6].eq {
	pc = 0x82A0DBBC; continue 'dispatch;
	}
	pc = 0x82A0DBB8; continue 'dispatch;
            }
            0x82A0DBB8 => {
    //   block [0x82A0DBB8..0x82A0DBBC)
	// 82A0DBB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A0DBBC; continue 'dispatch;
            }
            0x82A0DBBC => {
    //   block [0x82A0DBBC..0x82A0DBE4)
	// 82A0DBBC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DBC0: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0DBC4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0DBC8: 419A0028  beq cr6, 0x82a0dbf0
	if ctx.cr[6].eq {
	pc = 0x82A0DBF0; continue 'dispatch;
	}
	// 82A0DBCC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DBD0: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0DBD4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A0DBD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0DBDC: 41980008  blt cr6, 0x82a0dbe4
	if ctx.cr[6].lt {
	pc = 0x82A0DBE4; continue 'dispatch;
	}
	// 82A0DBE0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A0DBE4; continue 'dispatch;
            }
            0x82A0DBE4 => {
    //   block [0x82A0DBE4..0x82A0DBF0)
	// 82A0DBE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0DBE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DBEC: 419A0038  beq cr6, 0x82a0dc24
	if ctx.cr[6].eq {
	pc = 0x82A0DC24; continue 'dispatch;
	}
	pc = 0x82A0DBF0; continue 'dispatch;
            }
            0x82A0DBF0 => {
    //   block [0x82A0DBF0..0x82A0DC10)
	// 82A0DBF0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0DBF4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A0DBF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DBFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DC00: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0DC04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0DC08: 419AFF58  beq cr6, 0x82a0db60
	if ctx.cr[6].eq {
	pc = 0x82A0DB60; continue 'dispatch;
	}
	// 82A0DC0C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A0DC10; continue 'dispatch;
            }
            0x82A0DC10 => {
    //   block [0x82A0DC10..0x82A0DC24)
	// 82A0DC10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A0DC14: 4800019D  bl 0x82a0ddb0
	ctx.lr = 0x82A0DC18;
	sub_82A0DDB0(ctx, base);
	// 82A0DC18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DC1C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0DC20: 4829B830  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0DC24 => {
    //   block [0x82A0DC24..0x82A0DC54)
	// 82A0DC24: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A0DC28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DC2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0DC30: 48000029  bl 0x82a0dc58
	ctx.lr = 0x82A0DC34;
	sub_82A0DC58(ctx, base);
	// 82A0DC34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0DC38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DC3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DC40: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0DC44: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DC48: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0DC4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0DC50: 4829B800  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0DC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0DC58 size=344
    let mut pc: u32 = 0x82A0DC58;
    'dispatch: loop {
        match pc {
            0x82A0DC58 => {
    //   block [0x82A0DC58..0x82A0DC90)
	// 82A0DC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0DC5C: 4829B7A5  bl 0x82ca9400
	ctx.lr = 0x82A0DC60;
	sub_82CA93D0(ctx, base);
	// 82A0DC60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0DC64: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A0DC68: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A0DC6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0DC70: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A0DC74: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A0DC78: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DC7C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DC80: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0DC84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0DC88: 409A0044  bne cr6, 0x82a0dccc
	if !ctx.cr[6].eq {
	pc = 0x82A0DCCC; continue 'dispatch;
	}
	// 82A0DC8C: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A0DC90; continue 'dispatch;
            }
            0x82A0DC90 => {
    //   block [0x82A0DC90..0x82A0DCA8)
	// 82A0DC90: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0DC94: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82A0DC98: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A0DC9C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82A0DCA0: 41980008  blt cr6, 0x82a0dca8
	if ctx.cr[6].lt {
	pc = 0x82A0DCA8; continue 'dispatch;
	}
	// 82A0DCA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A0DCA8; continue 'dispatch;
            }
            0x82A0DCA8 => {
    //   block [0x82A0DCA8..0x82A0DCBC)
	// 82A0DCA8: 555D063E  clrlwi r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0DCAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0DCB0: 419A000C  beq cr6, 0x82a0dcbc
	if ctx.cr[6].eq {
	pc = 0x82A0DCBC; continue 'dispatch;
	}
	// 82A0DCB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DCB8: 48000008  b 0x82a0dcc0
	pc = 0x82A0DCC0; continue 'dispatch;
            }
            0x82A0DCBC => {
    //   block [0x82A0DCBC..0x82A0DCC0)
	// 82A0DCBC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A0DCC0; continue 'dispatch;
            }
            0x82A0DCC0 => {
    //   block [0x82A0DCC0..0x82A0DCCC)
	// 82A0DCC0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A0DCC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0DCC8: 419AFFC8  beq cr6, 0x82a0dc90
	if ctx.cr[6].eq {
	pc = 0x82A0DC90; continue 'dispatch;
	}
	pc = 0x82A0DCCC; continue 'dispatch;
            }
            0x82A0DCCC => {
    //   block [0x82A0DCCC..0x82A0DD2C)
	// 82A0DCCC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82A0DCD0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A0DCD4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A0DCD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DCDC: 419A0054  beq cr6, 0x82a0dd30
	if ctx.cr[6].eq {
	pc = 0x82A0DD30; continue 'dispatch;
	}
	// 82A0DCE0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DCE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DCE8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DCEC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0DCF0: 409A003C  bne cr6, 0x82a0dd2c
	if !ctx.cr[6].eq {
	pc = 0x82A0DD2C; continue 'dispatch;
	}
	// 82A0DCF4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A0DCF8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A0DCFC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A0DD00: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0DD04: 480000AD  bl 0x82a0ddb0
	ctx.lr = 0x82A0DD08;
	sub_82A0DDB0(ctx, base);
	// 82A0DD08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0DD0C: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A0DD10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0DD14: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DD18: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DD1C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0DD20: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0DD24: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0DD28: 4829B728  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0DD2C => {
    //   block [0x82A0DD2C..0x82A0DD30)
	// 82A0DD2C: 480A67CD  bl 0x82ab44f8
	ctx.lr = 0x82A0DD30;
	sub_82AB44F8(ctx, base);
	pc = 0x82A0DD30; continue 'dispatch;
            }
            0x82A0DD30 => {
    //   block [0x82A0DD30..0x82A0DD4C)
	// 82A0DD30: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0DD34: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DD38: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0DD3C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82A0DD40: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A0DD44: 41980008  blt cr6, 0x82a0dd4c
	if ctx.cr[6].lt {
	pc = 0x82A0DD4C; continue 'dispatch;
	}
	// 82A0DD48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0DD4C; continue 'dispatch;
            }
            0x82A0DD4C => {
    //   block [0x82A0DD4C..0x82A0DD94)
	// 82A0DD4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0DD50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DD54: 419A0040  beq cr6, 0x82a0dd94
	if ctx.cr[6].eq {
	pc = 0x82A0DD94; continue 'dispatch;
	}
	// 82A0DD58: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A0DD5C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A0DD60: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0DD64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0DD68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DD6C: 48000045  bl 0x82a0ddb0
	ctx.lr = 0x82A0DD70;
	sub_82A0DDB0(ctx, base);
	// 82A0DD70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0DD74: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A0DD78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0DD7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DD80: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DD84: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0DD88: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0DD8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0DD90: 4829B6C0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0DD94 => {
    //   block [0x82A0DD94..0x82A0DDB0)
	// 82A0DD94: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0DD98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0DD9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0DDA0: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82A0DDA4: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A0DDA8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0DDAC: 4829B6A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0DDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0DDB0 size=624
    let mut pc: u32 = 0x82A0DDB0;
    'dispatch: loop {
        match pc {
            0x82A0DDB0 => {
    //   block [0x82A0DDB0..0x82A0DE28)
	// 82A0DDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0DDB4: 4829B645  bl 0x82ca93f8
	ctx.lr = 0x82A0DDB8;
	sub_82CA93D0(ctx, base);
	// 82A0DDB8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0DDBC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A0DDC0: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82A0DDC4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A0DDC8: 6169FFFE  ori r9, r11, 0xfffe
	ctx.r[9].u64 = ctx.r[11].u64 | 65534;
	// 82A0DDCC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A0DDD0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0DDD4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A0DDD8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A0DDDC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0DDE0: 41980048  blt cr6, 0x82a0de28
	if ctx.cr[6].lt {
	pc = 0x82A0DE28; continue 'dispatch;
	}
	// 82A0DDE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0DDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DDEC: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82A0DDF0: 4B8E4151  bl 0x822f1f40
	ctx.lr = 0x82A0DDF4;
	sub_822F1F40(ctx, base);
	// 82A0DDF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0DDF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0DDFC: 4B8E3FB5  bl 0x822f1db0
	ctx.lr = 0x82A0DE00;
	sub_822F1DB0(ctx, base);
	// 82A0DE00: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0DE04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0DE08: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82A0DE0C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A0DE10: 4B8E4011  bl 0x822f1e20
	ctx.lr = 0x82A0DE14;
	sub_822F1E20(ctx, base);
	// 82A0DE14: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A0DE18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0DE1C: 4BC6D9C5  bl 0x8267b7e0
	ctx.lr = 0x82A0DE20;
	sub_8267B7E0(ctx, base);
	// 82A0DE20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DE24: 4B7639ED  bl 0x82171810
	ctx.lr = 0x82A0DE28;
	sub_82171810(ctx, base);
	pc = 0x82A0DE28; continue 'dispatch;
            }
            0x82A0DE28 => {
    //   block [0x82A0DE28..0x82A0DE68)
	// 82A0DE28: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A0DE2C: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DE30: 4B811429  bl 0x8221f258
	ctx.lr = 0x82A0DE34;
	sub_8221F258(ctx, base);
	// 82A0DE34: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0DE38: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A0DE3C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A0DE40: 419A0028  beq cr6, 0x82a0de68
	if ctx.cr[6].eq {
	pc = 0x82A0DE68; continue 'dispatch;
	}
	// 82A0DE44: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A0DE48: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A0DE4C: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A0DE50: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DE54: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0DE58: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DE5C: 915B0010  stw r10, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A0DE60: 9B3B0014  stb r25, 0x14(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A0DE64: 9B3B0015  stb r25, 0x15(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(21 as u32), ctx.r[25].u8 ) };
	pc = 0x82A0DE68; continue 'dispatch;
            }
            0x82A0DE68 => {
    //   block [0x82A0DE68..0x82A0DE98)
	// 82A0DE68: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0DE6C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DE70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0DE74: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0DE78: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0DE7C: 409A001C  bne cr6, 0x82a0de98
	if !ctx.cr[6].eq {
	pc = 0x82A0DE98; continue 'dispatch;
	}
	// 82A0DE80: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A0DE84: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DE88: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A0DE8C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DE90: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A0DE94: 48000044  b 0x82a0ded8
	pc = 0x82A0DED8; continue 'dispatch;
            }
            0x82A0DE98 => {
    //   block [0x82A0DE98..0x82A0DEC0)
	// 82A0DE98: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A0DE9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0DEA0: 419A0020  beq cr6, 0x82a0dec0
	if ctx.cr[6].eq {
	pc = 0x82A0DEC0; continue 'dispatch;
	}
	// 82A0DEA4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A0DEA8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DEAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DEB0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0DEB4: 409A0024  bne cr6, 0x82a0ded8
	if !ctx.cr[6].eq {
	pc = 0x82A0DED8; continue 'dispatch;
	}
	// 82A0DEB8: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A0DEBC: 4800001C  b 0x82a0ded8
	pc = 0x82A0DED8; continue 'dispatch;
            }
            0x82A0DEC0 => {
    //   block [0x82A0DEC0..0x82A0DED8)
	// 82A0DEC0: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A0DEC4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DEC8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0DECC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0DED0: 409A0008  bne cr6, 0x82a0ded8
	if !ctx.cr[6].eq {
	pc = 0x82A0DED8; continue 'dispatch;
	}
	// 82A0DED4: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A0DED8; continue 'dispatch;
            }
            0x82A0DED8 => {
    //   block [0x82A0DED8..0x82A0DEF4)
	// 82A0DED8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DEDC: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82A0DEE0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A0DEE4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A0DEE8: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0DEEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0DEF0: 409A0110  bne cr6, 0x82a0e000
	if !ctx.cr[6].eq {
	pc = 0x82A0E000; continue 'dispatch;
	}
	pc = 0x82A0DEF4; continue 'dispatch;
            }
            0x82A0DEF4 => {
    //   block [0x82A0DEF4..0x82A0DF3C)
	// 82A0DEF4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DEF8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DEFC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DF00: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0DF04: 409A0078  bne cr6, 0x82a0df7c
	if !ctx.cr[6].eq {
	pc = 0x82A0DF7C; continue 'dispatch;
	}
	// 82A0DF08: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0DF0C: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0DF10: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0DF14: 409A0028  bne cr6, 0x82a0df3c
	if !ctx.cr[6].eq {
	pc = 0x82A0DF3C; continue 'dispatch;
	}
	// 82A0DF18: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0DF1C: 9BC90014  stb r30, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A0DF20: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A0DF24: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DF28: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DF2C: 9B270014  stb r25, 0x14(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A0DF30: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DF34: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DF38: 480000B4  b 0x82a0dfec
	pc = 0x82A0DFEC; continue 'dispatch;
            }
            0x82A0DF3C => {
    //   block [0x82A0DF3C..0x82A0DF54)
	// 82A0DF3C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0DF40: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0DF44: 409A0010  bne cr6, 0x82a0df54
	if !ctx.cr[6].eq {
	pc = 0x82A0DF54; continue 'dispatch;
	}
	// 82A0DF48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DF4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0DF50: 4BFAA611  bl 0x829b8560
	ctx.lr = 0x82A0DF54;
	sub_829B8560(ctx, base);
	pc = 0x82A0DF54; continue 'dispatch;
            }
            0x82A0DF54 => {
    //   block [0x82A0DF54..0x82A0DF7C)
	// 82A0DF54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DF58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DF5C: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A0DF60: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DF64: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DF68: 9B290014  stb r25, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A0DF6C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DF70: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DF74: 4B8FAE95  bl 0x82308e08
	ctx.lr = 0x82A0DF78;
	sub_82308E08(ctx, base);
	// 82A0DF78: 48000074  b 0x82a0dfec
	pc = 0x82A0DFEC; continue 'dispatch;
            }
            0x82A0DF7C => {
    //   block [0x82A0DF7C..0x82A0DFB0)
	// 82A0DF7C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DF80: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0DF84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0DF88: 409A0028  bne cr6, 0x82a0dfb0
	if !ctx.cr[6].eq {
	pc = 0x82A0DFB0; continue 'dispatch;
	}
	// 82A0DF8C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DF90: 9BC90014  stb r30, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A0DF94: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A0DF98: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DF9C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DFA0: 9B270014  stb r25, 0x14(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A0DFA4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DFA8: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DFAC: 48000040  b 0x82a0dfec
	pc = 0x82A0DFEC; continue 'dispatch;
            }
            0x82A0DFB0 => {
    //   block [0x82A0DFB0..0x82A0DFC8)
	// 82A0DFB0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DFB4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0DFB8: 409A0010  bne cr6, 0x82a0dfc8
	if !ctx.cr[6].eq {
	pc = 0x82A0DFC8; continue 'dispatch;
	}
	// 82A0DFBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DFC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0DFC4: 4B8FAE45  bl 0x82308e08
	ctx.lr = 0x82A0DFC8;
	sub_82308E08(ctx, base);
	pc = 0x82A0DFC8; continue 'dispatch;
            }
            0x82A0DFC8 => {
    //   block [0x82A0DFC8..0x82A0DFEC)
	// 82A0DFC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DFCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0DFD0: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A0DFD4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DFD8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DFDC: 9B290014  stb r25, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A0DFE0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DFE4: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DFE8: 4BFAA579  bl 0x829b8560
	ctx.lr = 0x82A0DFEC;
	sub_829B8560(ctx, base);
	pc = 0x82A0DFEC; continue 'dispatch;
            }
            0x82A0DFEC => {
    //   block [0x82A0DFEC..0x82A0E000)
	// 82A0DFEC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0DFF0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0DFF4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A0DFF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0DFFC: 419AFEF8  beq cr6, 0x82a0def4
	if ctx.cr[6].eq {
	pc = 0x82A0DEF4; continue 'dispatch;
	}
	pc = 0x82A0E000; continue 'dispatch;
            }
            0x82A0E000 => {
    //   block [0x82A0E000..0x82A0E020)
	// 82A0E000: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E004: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A0E008: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A0E00C: 93B80000  stw r29, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A0E010: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E014: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A0E018: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A0E01C: 4829B42C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0E020 size=280
    let mut pc: u32 = 0x82A0E020;
    'dispatch: loop {
        match pc {
            0x82A0E020 => {
    //   block [0x82A0E020..0x82A0E064)
	// 82A0E020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E024: 4829B3E5  bl 0x82ca9408
	ctx.lr = 0x82A0E028;
	sub_82CA93D0(ctx, base);
	// 82A0E028: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E02C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A0E030: 386001F0  li r3, 0x1f0
	ctx.r[3].s64 = 496;
	// 82A0E034: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0E038: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A0E03C: 4B81121D  bl 0x8221f258
	ctx.lr = 0x82A0E040;
	sub_8221F258(ctx, base);
	// 82A0E040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0E044: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0E048: 419A0074  beq cr6, 0x82a0e0bc
	if ctx.cr[6].eq {
	pc = 0x82A0E0BC; continue 'dispatch;
	}
	// 82A0E04C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E050: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E058: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0E05C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0E060: 419A0020  beq cr6, 0x82a0e080
	if ctx.cr[6].eq {
	pc = 0x82A0E080; continue 'dispatch;
	}
	pc = 0x82A0E064; continue 'dispatch;
            }
            0x82A0E064 => {
    //   block [0x82A0E064..0x82A0E080)
	// 82A0E064: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0E068: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E06C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0E070: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0E074: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0E078: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E07C: 4082FFE8  bne 0x82a0e064
	if !ctx.cr[0].eq {
	pc = 0x82A0E064; continue 'dispatch;
	}
	pc = 0x82A0E080; continue 'dispatch;
            }
            0x82A0E080 => {
    //   block [0x82A0E080..0x82A0E0BC)
	// 82A0E080: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0E084: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E08C: 4881F5F5  bl 0x8322d680
	ctx.lr = 0x82A0E090;
	sub_8322D680(ctx, base);
	// 82A0E090: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E094: 4B7A9A85  bl 0x821b7b18
	ctx.lr = 0x82A0E098;
	sub_821B7B18(ctx, base);
	// 82A0E098: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0E09C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0E0A0: 392B6958  addi r9, r11, 0x6958
	ctx.r[9].s64 = ctx.r[11].s64 + 26968;
	// 82A0E0A4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A0E0A8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0E0AC: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E0B0: 915F01E4  stw r10, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[10].u32 ) };
	// 82A0E0B4: 911F01E0  stw r8, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[8].u32 ) };
	// 82A0E0B8: 48000008  b 0x82a0e0c0
	pc = 0x82A0E0C0; continue 'dispatch;
            }
            0x82A0E0BC => {
    //   block [0x82A0E0BC..0x82A0E0C0)
	// 82A0E0BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0E0C0; continue 'dispatch;
            }
            0x82A0E0C0 => {
    //   block [0x82A0E0C0..0x82A0E0D8)
	// 82A0E0C0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0E0C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E0C8: 419A0010  beq cr6, 0x82a0e0d8
	if ctx.cr[6].eq {
	pc = 0x82A0E0D8; continue 'dispatch;
	}
	// 82A0E0CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0E0D0: 4BFF6BF1  bl 0x82a04cc0
	ctx.lr = 0x82A0E0D4;
	sub_82A04CC0(ctx, base);
	// 82A0E0D4: 4800000C  b 0x82a0e0e0
	pc = 0x82A0E0E0; continue 'dispatch;
            }
            0x82A0E0D8 => {
    //   block [0x82A0E0D8..0x82A0E0E0)
	// 82A0E0D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0E0DC: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A0E0E0; continue 'dispatch;
            }
            0x82A0E0E0 => {
    //   block [0x82A0E0E0..0x82A0E0F8)
	// 82A0E0E0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E0E4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E0E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E0EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0E0F0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0E0F4: 419A0020  beq cr6, 0x82a0e114
	if ctx.cr[6].eq {
	pc = 0x82A0E114; continue 'dispatch;
	}
	pc = 0x82A0E0F8; continue 'dispatch;
            }
            0x82A0E0F8 => {
    //   block [0x82A0E0F8..0x82A0E114)
	// 82A0E0F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0E0FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E100: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0E104: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0E108: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0E10C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E110: 4082FFE8  bne 0x82a0e0f8
	if !ctx.cr[0].eq {
	pc = 0x82A0E0F8; continue 'dispatch;
	}
	pc = 0x82A0E114; continue 'dispatch;
            }
            0x82A0E114 => {
    //   block [0x82A0E114..0x82A0E138)
	// 82A0E114: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0E118: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E11C: 386BE48C  addi r3, r11, -0x1b74
	ctx.r[3].s64 = ctx.r[11].s64 + -7028;
	// 82A0E120: 4BA42C99  bl 0x82450db8
	ctx.lr = 0x82A0E124;
	sub_82450DB8(ctx, base);
	// 82A0E124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E128: 4B7A99F1  bl 0x821b7b18
	ctx.lr = 0x82A0E12C;
	sub_821B7B18(ctx, base);
	// 82A0E12C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0E130: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0E134: 4829B324  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0E138 size=280
    let mut pc: u32 = 0x82A0E138;
    'dispatch: loop {
        match pc {
            0x82A0E138 => {
    //   block [0x82A0E138..0x82A0E17C)
	// 82A0E138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E13C: 4829B2CD  bl 0x82ca9408
	ctx.lr = 0x82A0E140;
	sub_82CA93D0(ctx, base);
	// 82A0E140: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E144: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A0E148: 386001F0  li r3, 0x1f0
	ctx.r[3].s64 = 496;
	// 82A0E14C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0E150: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A0E154: 4B811105  bl 0x8221f258
	ctx.lr = 0x82A0E158;
	sub_8221F258(ctx, base);
	// 82A0E158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0E15C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0E160: 419A0074  beq cr6, 0x82a0e1d4
	if ctx.cr[6].eq {
	pc = 0x82A0E1D4; continue 'dispatch;
	}
	// 82A0E164: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E168: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E16C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E170: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0E174: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0E178: 419A0020  beq cr6, 0x82a0e198
	if ctx.cr[6].eq {
	pc = 0x82A0E198; continue 'dispatch;
	}
	pc = 0x82A0E17C; continue 'dispatch;
            }
            0x82A0E17C => {
    //   block [0x82A0E17C..0x82A0E198)
	// 82A0E17C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0E180: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E184: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0E188: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0E18C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0E190: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E194: 4082FFE8  bne 0x82a0e17c
	if !ctx.cr[0].eq {
	pc = 0x82A0E17C; continue 'dispatch;
	}
	pc = 0x82A0E198; continue 'dispatch;
            }
            0x82A0E198 => {
    //   block [0x82A0E198..0x82A0E1D4)
	// 82A0E198: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0E19C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E1A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E1A4: 4881F4DD  bl 0x8322d680
	ctx.lr = 0x82A0E1A8;
	sub_8322D680(ctx, base);
	// 82A0E1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E1AC: 4B7A996D  bl 0x821b7b18
	ctx.lr = 0x82A0E1B0;
	sub_821B7B18(ctx, base);
	// 82A0E1B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0E1B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0E1B8: 392B6718  addi r9, r11, 0x6718
	ctx.r[9].s64 = ctx.r[11].s64 + 26392;
	// 82A0E1BC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A0E1C0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0E1C4: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E1C8: 915F01E4  stw r10, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[10].u32 ) };
	// 82A0E1CC: 911F01E0  stw r8, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[8].u32 ) };
	// 82A0E1D0: 48000008  b 0x82a0e1d8
	pc = 0x82A0E1D8; continue 'dispatch;
            }
            0x82A0E1D4 => {
    //   block [0x82A0E1D4..0x82A0E1D8)
	// 82A0E1D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0E1D8; continue 'dispatch;
            }
            0x82A0E1D8 => {
    //   block [0x82A0E1D8..0x82A0E1F0)
	// 82A0E1D8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0E1DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E1E0: 419A0010  beq cr6, 0x82a0e1f0
	if ctx.cr[6].eq {
	pc = 0x82A0E1F0; continue 'dispatch;
	}
	// 82A0E1E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0E1E8: 4BFF6AD9  bl 0x82a04cc0
	ctx.lr = 0x82A0E1EC;
	sub_82A04CC0(ctx, base);
	// 82A0E1EC: 4800000C  b 0x82a0e1f8
	pc = 0x82A0E1F8; continue 'dispatch;
            }
            0x82A0E1F0 => {
    //   block [0x82A0E1F0..0x82A0E1F8)
	// 82A0E1F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0E1F4: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A0E1F8; continue 'dispatch;
            }
            0x82A0E1F8 => {
    //   block [0x82A0E1F8..0x82A0E210)
	// 82A0E1F8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E1FC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E204: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0E208: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0E20C: 419A0020  beq cr6, 0x82a0e22c
	if ctx.cr[6].eq {
	pc = 0x82A0E22C; continue 'dispatch;
	}
	pc = 0x82A0E210; continue 'dispatch;
            }
            0x82A0E210 => {
    //   block [0x82A0E210..0x82A0E22C)
	// 82A0E210: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0E214: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E218: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0E21C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0E220: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0E224: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E228: 4082FFE8  bne 0x82a0e210
	if !ctx.cr[0].eq {
	pc = 0x82A0E210; continue 'dispatch;
	}
	pc = 0x82A0E22C; continue 'dispatch;
            }
            0x82A0E22C => {
    //   block [0x82A0E22C..0x82A0E250)
	// 82A0E22C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0E230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E234: 386BE48C  addi r3, r11, -0x1b74
	ctx.r[3].s64 = ctx.r[11].s64 + -7028;
	// 82A0E238: 4BA42B81  bl 0x82450db8
	ctx.lr = 0x82A0E23C;
	sub_82450DB8(ctx, base);
	// 82A0E23C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E240: 4B7A98D9  bl 0x821b7b18
	ctx.lr = 0x82A0E244;
	sub_821B7B18(ctx, base);
	// 82A0E244: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0E248: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0E24C: 4829B20C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0E250 size=280
    let mut pc: u32 = 0x82A0E250;
    'dispatch: loop {
        match pc {
            0x82A0E250 => {
    //   block [0x82A0E250..0x82A0E294)
	// 82A0E250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E254: 4829B1B5  bl 0x82ca9408
	ctx.lr = 0x82A0E258;
	sub_82CA93D0(ctx, base);
	// 82A0E258: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E25C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A0E260: 386001F0  li r3, 0x1f0
	ctx.r[3].s64 = 496;
	// 82A0E264: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0E268: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A0E26C: 4B810FED  bl 0x8221f258
	ctx.lr = 0x82A0E270;
	sub_8221F258(ctx, base);
	// 82A0E270: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0E274: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0E278: 419A0074  beq cr6, 0x82a0e2ec
	if ctx.cr[6].eq {
	pc = 0x82A0E2EC; continue 'dispatch;
	}
	// 82A0E27C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E280: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E288: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0E28C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0E290: 419A0020  beq cr6, 0x82a0e2b0
	if ctx.cr[6].eq {
	pc = 0x82A0E2B0; continue 'dispatch;
	}
	pc = 0x82A0E294; continue 'dispatch;
            }
            0x82A0E294 => {
    //   block [0x82A0E294..0x82A0E2B0)
	// 82A0E294: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0E298: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E29C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0E2A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0E2A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0E2A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E2AC: 4082FFE8  bne 0x82a0e294
	if !ctx.cr[0].eq {
	pc = 0x82A0E294; continue 'dispatch;
	}
	pc = 0x82A0E2B0; continue 'dispatch;
            }
            0x82A0E2B0 => {
    //   block [0x82A0E2B0..0x82A0E2EC)
	// 82A0E2B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0E2B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E2B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E2BC: 4881F3C5  bl 0x8322d680
	ctx.lr = 0x82A0E2C0;
	sub_8322D680(ctx, base);
	// 82A0E2C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E2C4: 4B7A9855  bl 0x821b7b18
	ctx.lr = 0x82A0E2C8;
	sub_821B7B18(ctx, base);
	// 82A0E2C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0E2CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0E2D0: 392B66A8  addi r9, r11, 0x66a8
	ctx.r[9].s64 = ctx.r[11].s64 + 26280;
	// 82A0E2D4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A0E2D8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0E2DC: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E2E0: 915F01E4  stw r10, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[10].u32 ) };
	// 82A0E2E4: 911F01E0  stw r8, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[8].u32 ) };
	// 82A0E2E8: 48000008  b 0x82a0e2f0
	pc = 0x82A0E2F0; continue 'dispatch;
            }
            0x82A0E2EC => {
    //   block [0x82A0E2EC..0x82A0E2F0)
	// 82A0E2EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0E2F0; continue 'dispatch;
            }
            0x82A0E2F0 => {
    //   block [0x82A0E2F0..0x82A0E308)
	// 82A0E2F0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0E2F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E2F8: 419A0010  beq cr6, 0x82a0e308
	if ctx.cr[6].eq {
	pc = 0x82A0E308; continue 'dispatch;
	}
	// 82A0E2FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0E300: 4BFF69C1  bl 0x82a04cc0
	ctx.lr = 0x82A0E304;
	sub_82A04CC0(ctx, base);
	// 82A0E304: 4800000C  b 0x82a0e310
	pc = 0x82A0E310; continue 'dispatch;
            }
            0x82A0E308 => {
    //   block [0x82A0E308..0x82A0E310)
	// 82A0E308: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0E30C: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A0E310; continue 'dispatch;
            }
            0x82A0E310 => {
    //   block [0x82A0E310..0x82A0E328)
	// 82A0E310: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E314: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E31C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0E320: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0E324: 419A0020  beq cr6, 0x82a0e344
	if ctx.cr[6].eq {
	pc = 0x82A0E344; continue 'dispatch;
	}
	pc = 0x82A0E328; continue 'dispatch;
            }
            0x82A0E328 => {
    //   block [0x82A0E328..0x82A0E344)
	// 82A0E328: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0E32C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E330: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0E334: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0E338: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0E33C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E340: 4082FFE8  bne 0x82a0e328
	if !ctx.cr[0].eq {
	pc = 0x82A0E328; continue 'dispatch;
	}
	pc = 0x82A0E344; continue 'dispatch;
            }
            0x82A0E344 => {
    //   block [0x82A0E344..0x82A0E368)
	// 82A0E344: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0E348: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E34C: 386BE48C  addi r3, r11, -0x1b74
	ctx.r[3].s64 = ctx.r[11].s64 + -7028;
	// 82A0E350: 4BA42A69  bl 0x82450db8
	ctx.lr = 0x82A0E354;
	sub_82450DB8(ctx, base);
	// 82A0E354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E358: 4B7A97C1  bl 0x821b7b18
	ctx.lr = 0x82A0E35C;
	sub_821B7B18(ctx, base);
	// 82A0E35C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0E360: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0E364: 4829B0F4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0E368 size=280
    let mut pc: u32 = 0x82A0E368;
    'dispatch: loop {
        match pc {
            0x82A0E368 => {
    //   block [0x82A0E368..0x82A0E3AC)
	// 82A0E368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E36C: 4829B09D  bl 0x82ca9408
	ctx.lr = 0x82A0E370;
	sub_82CA93D0(ctx, base);
	// 82A0E370: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E374: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A0E378: 386001F0  li r3, 0x1f0
	ctx.r[3].s64 = 496;
	// 82A0E37C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0E380: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A0E384: 4B810ED5  bl 0x8221f258
	ctx.lr = 0x82A0E388;
	sub_8221F258(ctx, base);
	// 82A0E388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0E38C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0E390: 419A0074  beq cr6, 0x82a0e404
	if ctx.cr[6].eq {
	pc = 0x82A0E404; continue 'dispatch;
	}
	// 82A0E394: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E398: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E3A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0E3A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0E3A8: 419A0020  beq cr6, 0x82a0e3c8
	if ctx.cr[6].eq {
	pc = 0x82A0E3C8; continue 'dispatch;
	}
	pc = 0x82A0E3AC; continue 'dispatch;
            }
            0x82A0E3AC => {
    //   block [0x82A0E3AC..0x82A0E3C8)
	// 82A0E3AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0E3B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E3B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0E3B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0E3BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0E3C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E3C4: 4082FFE8  bne 0x82a0e3ac
	if !ctx.cr[0].eq {
	pc = 0x82A0E3AC; continue 'dispatch;
	}
	pc = 0x82A0E3C8; continue 'dispatch;
            }
            0x82A0E3C8 => {
    //   block [0x82A0E3C8..0x82A0E404)
	// 82A0E3C8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0E3CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E3D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E3D4: 4881F2AD  bl 0x8322d680
	ctx.lr = 0x82A0E3D8;
	sub_8322D680(ctx, base);
	// 82A0E3D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E3DC: 4B7A973D  bl 0x821b7b18
	ctx.lr = 0x82A0E3E0;
	sub_821B7B18(ctx, base);
	// 82A0E3E0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A0E3E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0E3E8: 392B21D0  addi r9, r11, 0x21d0
	ctx.r[9].s64 = ctx.r[11].s64 + 8656;
	// 82A0E3EC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A0E3F0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0E3F4: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E3F8: 915F01E4  stw r10, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[10].u32 ) };
	// 82A0E3FC: 911F01E0  stw r8, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[8].u32 ) };
	// 82A0E400: 48000008  b 0x82a0e408
	pc = 0x82A0E408; continue 'dispatch;
            }
            0x82A0E404 => {
    //   block [0x82A0E404..0x82A0E408)
	// 82A0E404: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0E408; continue 'dispatch;
            }
            0x82A0E408 => {
    //   block [0x82A0E408..0x82A0E420)
	// 82A0E408: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0E40C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E410: 419A0010  beq cr6, 0x82a0e420
	if ctx.cr[6].eq {
	pc = 0x82A0E420; continue 'dispatch;
	}
	// 82A0E414: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0E418: 4BFF68A9  bl 0x82a04cc0
	ctx.lr = 0x82A0E41C;
	sub_82A04CC0(ctx, base);
	// 82A0E41C: 4800000C  b 0x82a0e428
	pc = 0x82A0E428; continue 'dispatch;
            }
            0x82A0E420 => {
    //   block [0x82A0E420..0x82A0E428)
	// 82A0E420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0E424: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A0E428; continue 'dispatch;
            }
            0x82A0E428 => {
    //   block [0x82A0E428..0x82A0E440)
	// 82A0E428: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E42C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E434: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0E438: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0E43C: 419A0020  beq cr6, 0x82a0e45c
	if ctx.cr[6].eq {
	pc = 0x82A0E45C; continue 'dispatch;
	}
	pc = 0x82A0E440; continue 'dispatch;
            }
            0x82A0E440 => {
    //   block [0x82A0E440..0x82A0E45C)
	// 82A0E440: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0E444: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E448: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0E44C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0E450: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0E454: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0E458: 4082FFE8  bne 0x82a0e440
	if !ctx.cr[0].eq {
	pc = 0x82A0E440; continue 'dispatch;
	}
	pc = 0x82A0E45C; continue 'dispatch;
            }
            0x82A0E45C => {
    //   block [0x82A0E45C..0x82A0E480)
	// 82A0E45C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A0E460: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E464: 386BE48C  addi r3, r11, -0x1b74
	ctx.r[3].s64 = ctx.r[11].s64 + -7028;
	// 82A0E468: 4BA42951  bl 0x82450db8
	ctx.lr = 0x82A0E46C;
	sub_82450DB8(ctx, base);
	// 82A0E46C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E470: 4B7A96A9  bl 0x821b7b18
	ctx.lr = 0x82A0E474;
	sub_821B7B18(ctx, base);
	// 82A0E474: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0E478: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0E47C: 4829AFDC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0E480 size=136
    let mut pc: u32 = 0x82A0E480;
    'dispatch: loop {
        match pc {
            0x82A0E480 => {
    //   block [0x82A0E480..0x82A0E4EC)
	// 82A0E480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0E488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0E48C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0E490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0E498: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A0E49C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E4A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E4A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A0E4A8: 4E800421  bctrl
	ctx.lr = 0x82A0E4AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0E4AC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A0E4B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0E4B4: 419A0038  beq cr6, 0x82a0e4ec
	if ctx.cr[6].eq {
	pc = 0x82A0E4EC; continue 'dispatch;
	}
	// 82A0E4B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E4BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0E4C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E4C4: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0E4C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A0E4CC: 4E800421  bctrl
	ctx.lr = 0x82A0E4D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0E4D0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E4D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E4D8: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0E4DC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A0E4E0: 4E800421  bctrl
	ctx.lr = 0x82A0E4E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0E4E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A0E4E8: 48000008  b 0x82a0e4f0
	pc = 0x82A0E4F0; continue 'dispatch;
            }
            0x82A0E4EC => {
    //   block [0x82A0E4EC..0x82A0E4F0)
	// 82A0E4EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82A0E4F0; continue 'dispatch;
            }
            0x82A0E4F0 => {
    //   block [0x82A0E4F0..0x82A0E508)
	// 82A0E4F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0E4F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0E4F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0E4FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0E500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0E504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0E508 size=80
    let mut pc: u32 = 0x82A0E508;
    'dispatch: loop {
        match pc {
            0x82A0E508 => {
    //   block [0x82A0E508..0x82A0E540)
	// 82A0E508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0E510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0E514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0E518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E51C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0E520: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0E524: 48819F65  bl 0x83228488
	ctx.lr = 0x82A0E528;
	sub_83228488(ctx, base);
	// 82A0E528: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A0E52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E534: 419A000C  beq cr6, 0x82a0e540
	if ctx.cr[6].eq {
	pc = 0x82A0E540; continue 'dispatch;
	}
	// 82A0E538: 4B80D801  bl 0x8221bd38
	ctx.lr = 0x82A0E53C;
	sub_8221BD38(ctx, base);
	// 82A0E53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0E540; continue 'dispatch;
            }
            0x82A0E540 => {
    //   block [0x82A0E540..0x82A0E558)
	// 82A0E540: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0E544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0E548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0E54C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0E550: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0E554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0E558 size=168
    let mut pc: u32 = 0x82A0E558;
    'dispatch: loop {
        match pc {
            0x82A0E558 => {
    //   block [0x82A0E558..0x82A0E5C0)
	// 82A0E558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0E560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0E564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0E568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E56C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0E570: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0E574: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0E578: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E57C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A0E580: 7D241670  srawi r4, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82A0E584: 4BA3BF9D  bl 0x8244a520
	ctx.lr = 0x82A0E588;
	sub_8244A520(ctx, base);
	// 82A0E588: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A0E58C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A0E590: 419A0054  beq cr6, 0x82a0e5e4
	if ctx.cr[6].eq {
	pc = 0x82A0E5E4; continue 'dispatch;
	}
	// 82A0E594: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0E59C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0E5A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A0E5A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0E5A8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E5AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A0E5B0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0E5B4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A0E5B8: 419A0028  beq cr6, 0x82a0e5e0
	if ctx.cr[6].eq {
	pc = 0x82A0E5E0; continue 'dispatch;
	}
	// 82A0E5BC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A0E5C0; continue 'dispatch;
            }
            0x82A0E5C0 => {
    //   block [0x82A0E5C0..0x82A0E5D0)
	// 82A0E5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E5C4: 419A000C  beq cr6, 0x82a0e5d0
	if ctx.cr[6].eq {
	pc = 0x82A0E5D0; continue 'dispatch;
	}
	// 82A0E5C8: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0E5CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82A0E5D0; continue 'dispatch;
            }
            0x82A0E5D0 => {
    //   block [0x82A0E5D0..0x82A0E5E0)
	// 82A0E5D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A0E5D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0E5D8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0E5DC: 409AFFE4  bne cr6, 0x82a0e5c0
	if !ctx.cr[6].eq {
	pc = 0x82A0E5C0; continue 'dispatch;
	}
	pc = 0x82A0E5E0; continue 'dispatch;
            }
            0x82A0E5E0 => {
    //   block [0x82A0E5E0..0x82A0E5E4)
	// 82A0E5E0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A0E5E4; continue 'dispatch;
            }
            0x82A0E5E4 => {
    //   block [0x82A0E5E4..0x82A0E600)
	// 82A0E5E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0E5E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0E5EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0E5F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0E5F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0E5F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0E5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0E600 size=616
    let mut pc: u32 = 0x82A0E600;
    'dispatch: loop {
        match pc {
            0x82A0E600 => {
    //   block [0x82A0E600..0x82A0E63C)
	// 82A0E600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E604: 4829ADF5  bl 0x82ca93f8
	ctx.lr = 0x82A0E608;
	sub_82CA93D0(ctx, base);
	// 82A0E608: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E60C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0E610: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82A0E614: FBA10100  std r29, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[29].u64 ) };
	// 82A0E618: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A0E61C: FB210108  std r25, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[25].u64 ) };
	// 82A0E620: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A0E624: 83410104  lwz r26, 0x104(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A0E628: 83C1010C  lwz r30, 0x10c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A0E62C: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 82A0E630: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0E634: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A0E638: 409900C8  ble cr6, 0x82a0e700
	if !ctx.cr[6].gt {
	pc = 0x82A0E700; continue 'dispatch;
	}
	pc = 0x82A0E63C; continue 'dispatch;
            }
            0x82A0E63C => {
    //   block [0x82A0E63C..0x82A0E6C8)
	// 82A0E63C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0E640: 4099010C  ble cr6, 0x82a0e74c
	if !ctx.cr[6].gt {
	pc = 0x82A0E74C; continue 'dispatch;
	}
	// 82A0E644: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A0E648: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0E64C: 4BFFFF0D  bl 0x82a0e558
	ctx.lr = 0x82A0E650;
	sub_82A0E558(ctx, base);
	// 82A0E650: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A0E654: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A0E658: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0E65C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E660: 48000209  bl 0x82a0e868
	ctx.lr = 0x82A0E664;
	sub_82A0E868(ctx, base);
	// 82A0E664: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 82A0E668: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0E66C: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0E670: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A0E674: 7CFA4850  subf r7, r26, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[26].s64;
	// 82A0E678: 7CC8F050  subf r6, r8, r30
	ctx.r[6].s64 = ctx.r[30].s64 - ctx.r[8].s64;
	// 82A0E67C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A0E680: 54C40038  rlwinm r4, r6, 0, 0, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0E684: 54E50038  rlwinm r5, r7, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0E688: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A0E68C: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82A0E690: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A0E694: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A0E698: 40980030  bge cr6, 0x82a0e6c8
	if !ctx.cr[6].lt {
	pc = 0x82A0E6C8; continue 'dispatch;
	}
	// 82A0E69C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0E6A0: 4BFFFEB9  bl 0x82a0e558
	ctx.lr = 0x82A0E6A4;
	sub_82A0E558(ctx, base);
	// 82A0E6A4: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82A0E6A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0E6AC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0E6B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0E6B4: 4BFFFF4D  bl 0x82a0e600
	ctx.lr = 0x82A0E6B8;
	sub_82A0E600(ctx, base);
	// 82A0E6B8: EBA10058  ld r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0E6BC: FBA10100  std r29, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[29].u64 ) };
	// 82A0E6C0: 83410104  lwz r26, 0x104(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A0E6C4: 4800002C  b 0x82a0e6f0
	pc = 0x82A0E6F0; continue 'dispatch;
            }
            0x82A0E6C8 => {
    //   block [0x82A0E6C8..0x82A0E6F0)
	// 82A0E6C8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A0E6CC: 4BFFFE8D  bl 0x82a0e558
	ctx.lr = 0x82A0E6D0;
	sub_82A0E558(ctx, base);
	// 82A0E6D0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82A0E6D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0E6D8: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0E6DC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A0E6E0: 4BFFFF21  bl 0x82a0e600
	ctx.lr = 0x82A0E6E4;
	sub_82A0E600(ctx, base);
	// 82A0E6E4: EB210050  ld r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0E6E8: FB210108  std r25, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[25].u64 ) };
	// 82A0E6EC: 83C1010C  lwz r30, 0x10c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	pc = 0x82A0E6F0; continue 'dispatch;
            }
            0x82A0E6F0 => {
    //   block [0x82A0E6F0..0x82A0E700)
	// 82A0E6F0: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 82A0E6F4: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0E6F8: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A0E6FC: 4199FF40  bgt cr6, 0x82a0e63c
	if ctx.cr[6].gt {
	pc = 0x82A0E63C; continue 'dispatch;
	}
	pc = 0x82A0E700; continue 'dispatch;
            }
            0x82A0E700 => {
    //   block [0x82A0E700..0x82A0E724)
	// 82A0E700: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A0E704: 40990020  ble cr6, 0x82a0e724
	if !ctx.cr[6].gt {
	pc = 0x82A0E724; continue 'dispatch;
	}
	// 82A0E708: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A0E70C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A0E710: 4BFFFE49  bl 0x82a0e558
	ctx.lr = 0x82A0E714;
	sub_82A0E558(ctx, base);
	// 82A0E714: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A0E718: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A0E71C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0E720: 48000591  bl 0x82a0ecb0
	ctx.lr = 0x82A0E724;
	sub_82A0ECB0(ctx, base);
	pc = 0x82A0E724; continue 'dispatch;
            }
            0x82A0E724 => {
    //   block [0x82A0E724..0x82A0E734)
	// 82A0E724: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E728: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E72C: 419A0008  beq cr6, 0x82a0e734
	if ctx.cr[6].eq {
	pc = 0x82A0E734; continue 'dispatch;
	}
	// 82A0E730: 4B80D609  bl 0x8221bd38
	ctx.lr = 0x82A0E734;
	sub_8221BD38(ctx, base);
	pc = 0x82A0E734; continue 'dispatch;
            }
            0x82A0E734 => {
    //   block [0x82A0E734..0x82A0E74C)
	// 82A0E734: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0E738: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0E73C: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0E740: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0E744: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A0E748: 4829AD00  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0E74C => {
    //   block [0x82A0E74C..0x82A0E790)
	// 82A0E74C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A0E750: 4099FFB0  ble cr6, 0x82a0e700
	if !ctx.cr[6].gt {
	pc = 0x82A0E700; continue 'dispatch;
	}
	// 82A0E754: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A0E758: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0E75C: 4BFFFDFD  bl 0x82a0e558
	ctx.lr = 0x82A0E760;
	sub_82A0E558(ctx, base);
	// 82A0E760: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 82A0E764: 7D7C1E70  srawi r28, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0E768: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 82A0E76C: 4099006C  ble cr6, 0x82a0e7d8
	if !ctx.cr[6].gt {
	pc = 0x82A0E7D8; continue 'dispatch;
	}
	// 82A0E770: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A0E774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E778: 4BFFFDE1  bl 0x82a0e558
	ctx.lr = 0x82A0E77C;
	sub_82A0E558(ctx, base);
	// 82A0E77C: 7F8B0E70  srawi r11, r28, 1
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 1) as i64;
	// 82A0E780: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0E784: 40810044  ble 0x82a0e7c8
	if !ctx.cr[0].gt {
	pc = 0x82A0E7C8; continue 'dispatch;
	}
	// 82A0E788: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0E78C: 7FCBD214  add r30, r11, r26
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	pc = 0x82A0E790; continue 'dispatch;
            }
            0x82A0E790 => {
    //   block [0x82A0E790..0x82A0E7C8)
	// 82A0E790: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82A0E794: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0E798: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0E79C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82A0E7A0: EB1E0000  ld r24, 0(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A0E7A4: 4BFFFDB5  bl 0x82a0e558
	ctx.lr = 0x82A0E7A8;
	sub_82A0E558(ctx, base);
	// 82A0E7A8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82A0E7AC: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82A0E7B0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A0E7B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0E7B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0E7BC: 48000925  bl 0x82a0f0e0
	ctx.lr = 0x82A0E7C0;
	sub_82A0F0E0(ctx, base);
	// 82A0E7C0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0E7C4: 4199FFCC  bgt cr6, 0x82a0e790
	if ctx.cr[6].gt {
	pc = 0x82A0E790; continue 'dispatch;
	}
	pc = 0x82A0E7C8; continue 'dispatch;
            }
            0x82A0E7C8 => {
    //   block [0x82A0E7C8..0x82A0E7D8)
	// 82A0E7C8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0E7CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E7D0: 419A0008  beq cr6, 0x82a0e7d8
	if ctx.cr[6].eq {
	pc = 0x82A0E7D8; continue 'dispatch;
	}
	// 82A0E7D4: 4B80D565  bl 0x8221bd38
	ctx.lr = 0x82A0E7D8;
	sub_8221BD38(ctx, base);
	pc = 0x82A0E7D8; continue 'dispatch;
            }
            0x82A0E7D8 => {
    //   block [0x82A0E7D8..0x82A0E7E8)
	// 82A0E7D8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0E7DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E7E0: 419A0008  beq cr6, 0x82a0e7e8
	if ctx.cr[6].eq {
	pc = 0x82A0E7E8; continue 'dispatch;
	}
	// 82A0E7E4: 4B80D555  bl 0x8221bd38
	ctx.lr = 0x82A0E7E8;
	sub_8221BD38(ctx, base);
	pc = 0x82A0E7E8; continue 'dispatch;
            }
            0x82A0E7E8 => {
    //   block [0x82A0E7E8..0x82A0E810)
	// 82A0E7E8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A0E7EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0E7F0: 4BFFFD69  bl 0x82a0e558
	ctx.lr = 0x82A0E7F4;
	sub_82A0E558(ctx, base);
	// 82A0E7F4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A0E7F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0E7FC: 4BFFFD5D  bl 0x82a0e558
	ctx.lr = 0x82A0E800;
	sub_82A0E558(ctx, base);
	// 82A0E800: FB210050  std r25, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u64 ) };
	// 82A0E804: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 82A0E808: 4099003C  ble cr6, 0x82a0e844
	if !ctx.cr[6].gt {
	pc = 0x82A0E844; continue 'dispatch;
	}
	// 82A0E80C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A0E810; continue 'dispatch;
            }
            0x82A0E810 => {
    //   block [0x82A0E810..0x82A0E844)
	// 82A0E810: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A0E814: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A0E818: 4BFFFD41  bl 0x82a0e558
	ctx.lr = 0x82A0E81C;
	sub_82A0E558(ctx, base);
	// 82A0E81C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A0E820: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0E824: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0E828: 48000A79  bl 0x82a0f2a0
	ctx.lr = 0x82A0E82C;
	sub_82A0F2A0(ctx, base);
	// 82A0E82C: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A0E830: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A0E834: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A0E838: 556A0038  rlwinm r10, r11, 0, 0, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0E83C: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 82A0E840: 4199FFD0  bgt cr6, 0x82a0e810
	if ctx.cr[6].gt {
	pc = 0x82A0E810; continue 'dispatch;
	}
	pc = 0x82A0E844; continue 'dispatch;
            }
            0x82A0E844 => {
    //   block [0x82A0E844..0x82A0E854)
	// 82A0E844: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0E848: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E84C: 419A0008  beq cr6, 0x82a0e854
	if ctx.cr[6].eq {
	pc = 0x82A0E854; continue 'dispatch;
	}
	// 82A0E850: 4B80D4E9  bl 0x8221bd38
	ctx.lr = 0x82A0E854;
	sub_8221BD38(ctx, base);
	pc = 0x82A0E854; continue 'dispatch;
            }
            0x82A0E854 => {
    //   block [0x82A0E854..0x82A0E868)
	// 82A0E854: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0E858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E85C: 419AFEC8  beq cr6, 0x82a0e724
	if ctx.cr[6].eq {
	pc = 0x82A0E724; continue 'dispatch;
	}
	// 82A0E860: 4B80D4D9  bl 0x8221bd38
	ctx.lr = 0x82A0E864;
	sub_8221BD38(ctx, base);
	// 82A0E864: 4BFFFEC0  b 0x82a0e724
	pc = 0x82A0E724; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0E868 size=1092
    let mut pc: u32 = 0x82A0E868;
    'dispatch: loop {
        match pc {
            0x82A0E868 => {
    //   block [0x82A0E868..0x82A0E910)
	// 82A0E868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E86C: 4829AB8D  bl 0x82ca93f8
	ctx.lr = 0x82A0E870;
	sub_82CA93D0(ctx, base);
	// 82A0E870: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E874: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0E878: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A0E87C: FBE100E8  std r31, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[31].u64 ) };
	// 82A0E880: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A0E884: FB8100F0  std r28, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 82A0E888: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A0E88C: 832100F4  lwz r25, 0xf4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A0E890: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0E894: 834100EC  lwz r26, 0xec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A0E898: 7D7AC850  subf r11, r26, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[26].s64;
	// 82A0E89C: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0E8A0: FBE10060  std r31, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u64 ) };
	// 82A0E8A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A0E8A8: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82A0E8AC: 7D090194  addze r8, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82A0E8B0: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0E8B4: 7FCBD214  add r30, r11, r26
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A0E8B8: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A0E8BC: 4BFFFC9D  bl 0x82a0e558
	ctx.lr = 0x82A0E8C0;
	sub_82A0E558(ctx, base);
	// 82A0E8C0: EBA10060  ld r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0E8C4: 38F9FFF8  addi r7, r25, -8
	ctx.r[7].s64 = ctx.r[25].s64 + -8;
	// 82A0E8C8: FB810060  std r28, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u64 ) };
	// 82A0E8CC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A0E8D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0E8D4: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82A0E8D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E8DC: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0E8E0: 48000529  bl 0x82a0ee08
	ctx.lr = 0x82A0E8E4;
	sub_82A0EE08(ctx, base);
	// 82A0E8E4: 393E0008  addi r9, r30, 8
	ctx.r[9].s64 = ctx.r[30].s64 + 8;
	// 82A0E8E8: FBA10060  std r29, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u64 ) };
	// 82A0E8EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0E8F0: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82A0E8F4: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A0E8F8: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0E8FC: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82A0E900: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0E904: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82A0E908: 40980074  bge cr6, 0x82a0e97c
	if !ctx.cr[6].lt {
	pc = 0x82A0E97C; continue 'dispatch;
	}
	// 82A0E90C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0E910; continue 'dispatch;
            }
            0x82A0E910 => {
    //   block [0x82A0E910..0x82A0E938)
	// 82A0E910: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E914: 80E8FFF8  lwz r7, -8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0E918: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A0E91C: 54E5103A  slwi r5, r7, 2
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A0E920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0E924: 7C06542E  lfsx f0, r6, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0E928: 7DA5542E  lfsx f13, r5, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0E92C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0E930: 41990008  bgt cr6, 0x82a0e938
	if ctx.cr[6].gt {
	pc = 0x82A0E938; continue 'dispatch;
	}
	// 82A0E934: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A0E938; continue 'dispatch;
            }
            0x82A0E938 => {
    //   block [0x82A0E938..0x82A0E960)
	// 82A0E938: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0E93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E940: 409A003C  bne cr6, 0x82a0e97c
	if !ctx.cr[6].eq {
	pc = 0x82A0E97C; continue 'dispatch;
	}
	// 82A0E944: 8168FFF8  lwz r11, -8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0E948: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A0E94C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0E950: 7DA7542E  lfsx f13, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0E954: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0E958: 41990008  bgt cr6, 0x82a0e960
	if ctx.cr[6].gt {
	pc = 0x82A0E960; continue 'dispatch;
	}
	// 82A0E95C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A0E960; continue 'dispatch;
            }
            0x82A0E960 => {
    //   block [0x82A0E960..0x82A0E97C)
	// 82A0E960: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0E964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E968: 409A0014  bne cr6, 0x82a0e97c
	if !ctx.cr[6].eq {
	pc = 0x82A0E97C; continue 'dispatch;
	}
	// 82A0E96C: 3908FFF8  addi r8, r8, -8
	ctx.r[8].s64 = ctx.r[8].s64 + -8;
	// 82A0E970: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A0E974: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0E978: 4198FF98  blt cr6, 0x82a0e910
	if ctx.cr[6].lt {
	pc = 0x82A0E910; continue 'dispatch;
	}
	pc = 0x82A0E97C; continue 'dispatch;
            }
            0x82A0E97C => {
    //   block [0x82A0E97C..0x82A0E998)
	// 82A0E97C: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0E980: 7F09C840  cmplw cr6, r9, r25
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A0E984: 40980068  bge cr6, 0x82a0e9ec
	if !ctx.cr[6].lt {
	pc = 0x82A0E9EC; continue 'dispatch;
	}
	// 82A0E988: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E98C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0E990: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0E994: 7DA9542E  lfsx f13, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82A0E998; continue 'dispatch;
            }
            0x82A0E998 => {
    //   block [0x82A0E998..0x82A0E9B4)
	// 82A0E998: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E99C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0E9A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0E9A4: 7C09542E  lfsx f0, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0E9A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0E9AC: 41990008  bgt cr6, 0x82a0e9b4
	if ctx.cr[6].gt {
	pc = 0x82A0E9B4; continue 'dispatch;
	}
	// 82A0E9B0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A0E9B4; continue 'dispatch;
            }
            0x82A0E9B4 => {
    //   block [0x82A0E9B4..0x82A0E9D0)
	// 82A0E9B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0E9B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E9BC: 409A0030  bne cr6, 0x82a0e9ec
	if !ctx.cr[6].eq {
	pc = 0x82A0E9EC; continue 'dispatch;
	}
	// 82A0E9C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0E9C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0E9C8: 41990008  bgt cr6, 0x82a0e9d0
	if ctx.cr[6].gt {
	pc = 0x82A0E9D0; continue 'dispatch;
	}
	// 82A0E9CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A0E9D0; continue 'dispatch;
            }
            0x82A0E9D0 => {
    //   block [0x82A0E9D0..0x82A0E9EC)
	// 82A0E9D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0E9D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0E9D8: 409A0014  bne cr6, 0x82a0e9ec
	if !ctx.cr[6].eq {
	pc = 0x82A0E9EC; continue 'dispatch;
	}
	// 82A0E9DC: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82A0E9E0: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82A0E9E4: 7F05C840  cmplw cr6, r5, r25
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A0E9E8: 4198FFB0  blt cr6, 0x82a0e998
	if ctx.cr[6].lt {
	pc = 0x82A0E998; continue 'dispatch;
	}
	pc = 0x82A0E9EC; continue 'dispatch;
            }
            0x82A0E9EC => {
    //   block [0x82A0E9EC..0x82A0EA04)
	// 82A0E9EC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0E9F0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0E9F4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A0E9F8: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82A0E9FC: 80E10064  lwz r7, 0x64(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0EA00: 80C1006C  lwz r6, 0x6c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x82A0EA04; continue 'dispatch;
            }
            0x82A0EA04 => {
    //   block [0x82A0EA04..0x82A0EA0C)
	// 82A0EA04: 7F07C840  cmplw cr6, r7, r25
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A0EA08: 4098009C  bge cr6, 0x82a0eaa4
	if !ctx.cr[6].lt {
	pc = 0x82A0EAA4; continue 'dispatch;
	}
	pc = 0x82A0EA0C; continue 'dispatch;
            }
            0x82A0EA0C => {
    //   block [0x82A0EA0C..0x82A0EA38)
	// 82A0EA0C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EA10: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EA14: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EA18: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0EA1C: 5543103A  slwi r3, r10, 2
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A0EA20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0EA24: 7C044C2E  lfsx f0, r4, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0EA28: 7DA34C2E  lfsx f13, r3, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0EA2C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0EA30: 41990008  bgt cr6, 0x82a0ea38
	if ctx.cr[6].gt {
	pc = 0x82A0EA38; continue 'dispatch;
	}
	// 82A0EA34: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A0EA38; continue 'dispatch;
            }
            0x82A0EA38 => {
    //   block [0x82A0EA38..0x82A0EA54)
	// 82A0EA38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0EA3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0EA40: 409A0054  bne cr6, 0x82a0ea94
	if !ctx.cr[6].eq {
	pc = 0x82A0EA94; continue 'dispatch;
	}
	// 82A0EA44: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0EA48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0EA4C: 41990008  bgt cr6, 0x82a0ea54
	if ctx.cr[6].gt {
	pc = 0x82A0EA54; continue 'dispatch;
	}
	// 82A0EA50: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A0EA54; continue 'dispatch;
            }
            0x82A0EA54 => {
    //   block [0x82A0EA54..0x82A0EA94)
	// 82A0EA54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0EA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0EA5C: 409A0048  bne cr6, 0x82a0eaa4
	if !ctx.cr[6].eq {
	pc = 0x82A0EAA4; continue 'dispatch;
	}
	// 82A0EA60: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0EA64: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82A0EA68: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EA6C: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82A0EA70: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82A0EA74: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0EA78: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EA7C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0EA80: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0EA84: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EA88: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EA8C: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A0EA90: 90870004  stw r4, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A0EA94; continue 'dispatch;
            }
            0x82A0EA94 => {
    //   block [0x82A0EA94..0x82A0EAA4)
	// 82A0EA94: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82A0EA98: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82A0EA9C: 7F07C840  cmplw cr6, r7, r25
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A0EAA0: 4198FF6C  blt cr6, 0x82a0ea0c
	if ctx.cr[6].lt {
	pc = 0x82A0EA0C; continue 'dispatch;
	}
	pc = 0x82A0EAA4; continue 'dispatch;
            }
            0x82A0EAA4 => {
    //   block [0x82A0EAA4..0x82A0EAAC)
	// 82A0EAA4: 7F06D040  cmplw cr6, r6, r26
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A0EAA8: 409900A4  ble cr6, 0x82a0eb4c
	if !ctx.cr[6].gt {
	pc = 0x82A0EB4C; continue 'dispatch;
	}
	pc = 0x82A0EAAC; continue 'dispatch;
            }
            0x82A0EAAC => {
    //   block [0x82A0EAAC..0x82A0EADC)
	// 82A0EAAC: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EAB0: 3946FFF8  addi r10, r6, -8
	ctx.r[10].s64 = ctx.r[6].s64 + -8;
	// 82A0EAB4: 8086FFF8  lwz r4, -8(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0EAB8: 5523103A  slwi r3, r9, 2
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A0EABC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EAC0: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0EAC4: 7C035C2E  lfsx f0, r3, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0EAC8: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0EACC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A0EAD0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0EAD4: 41990008  bgt cr6, 0x82a0eadc
	if ctx.cr[6].gt {
	pc = 0x82A0EADC; continue 'dispatch;
	}
	// 82A0EAD8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x82A0EADC; continue 'dispatch;
            }
            0x82A0EADC => {
    //   block [0x82A0EADC..0x82A0EB04)
	// 82A0EADC: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82A0EAE0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0EAE4: 409A0058  bne cr6, 0x82a0eb3c
	if !ctx.cr[6].eq {
	pc = 0x82A0EB3C; continue 'dispatch;
	}
	// 82A0EAE8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EAEC: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0EAF0: 7DA45C2E  lfsx f13, r4, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0EAF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0EAF8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0EAFC: 41990008  bgt cr6, 0x82a0eb04
	if ctx.cr[6].gt {
	pc = 0x82A0EB04; continue 'dispatch;
	}
	// 82A0EB00: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A0EB04; continue 'dispatch;
            }
            0x82A0EB04 => {
    //   block [0x82A0EB04..0x82A0EB3C)
	// 82A0EB04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0EB08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0EB0C: 409A003C  bne cr6, 0x82a0eb48
	if !ctx.cr[6].eq {
	pc = 0x82A0EB48; continue 'dispatch;
	}
	// 82A0EB10: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A0EB14: 3908FFF8  addi r8, r8, -8
	ctx.r[8].s64 = ctx.r[8].s64 + -8;
	// 82A0EB18: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A0EB1C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EB20: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EB24: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0EB28: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82A0EB2C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EB30: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EB34: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A0EB38: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A0EB3C; continue 'dispatch;
            }
            0x82A0EB3C => {
    //   block [0x82A0EB3C..0x82A0EB48)
	// 82A0EB3C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82A0EB40: 7F1A3040  cmplw cr6, r26, r6
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A0EB44: 4198FF68  blt cr6, 0x82a0eaac
	if ctx.cr[6].lt {
	pc = 0x82A0EAAC; continue 'dispatch;
	}
	pc = 0x82A0EB48; continue 'dispatch;
            }
            0x82A0EB48 => {
    //   block [0x82A0EB48..0x82A0EB4C)
	// 82A0EB48: 7F06D040  cmplw cr6, r6, r26
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[26].u32, &mut ctx.xer);
	pc = 0x82A0EB4C; continue 'dispatch;
            }
            0x82A0EB4C => {
    //   block [0x82A0EB4C..0x82A0EB80)
	// 82A0EB4C: 409A0088  bne cr6, 0x82a0ebd4
	if !ctx.cr[6].eq {
	pc = 0x82A0EBD4; continue 'dispatch;
	}
	// 82A0EB50: 7F07C840  cmplw cr6, r7, r25
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A0EB54: 419A0120  beq cr6, 0x82a0ec74
	if ctx.cr[6].eq {
	pc = 0x82A0EC74; continue 'dispatch;
	}
	// 82A0EB58: 7F053840  cmplw cr6, r5, r7
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A0EB5C: 419A0024  beq cr6, 0x82a0eb80
	if ctx.cr[6].eq {
	pc = 0x82A0EB80; continue 'dispatch;
	}
	// 82A0EB60: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EB64: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EB68: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0EB6C: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0EB70: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EB74: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EB78: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0EB7C: 90850004  stw r4, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A0EB80; continue 'dispatch;
            }
            0x82A0EB80 => {
    //   block [0x82A0EB80..0x82A0EBD4)
	// 82A0EB80: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0EB84: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82A0EB88: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0EB8C: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82A0EB90: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82A0EB94: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82A0EB98: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82A0EB9C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A0EBA0: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82A0EBA4: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 82A0EBA8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0EBAC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0EBB0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EBB4: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EBB8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0EBBC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82A0EBC0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EBC4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EBC8: 906A0004  stw r3, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A0EBCC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0EBD0: 4BFFFE34  b 0x82a0ea04
	pc = 0x82A0EA04; continue 'dispatch;
            }
            0x82A0EBD4 => {
    //   block [0x82A0EBD4..0x82A0EC10)
	// 82A0EBD4: 7F07C840  cmplw cr6, r7, r25
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A0EBD8: 38C6FFF8  addi r6, r6, -8
	ctx.r[6].s64 = ctx.r[6].s64 + -8;
	// 82A0EBDC: 409A0060  bne cr6, 0x82a0ec3c
	if !ctx.cr[6].eq {
	pc = 0x82A0EC3C; continue 'dispatch;
	}
	// 82A0EBE0: 3908FFF8  addi r8, r8, -8
	ctx.r[8].s64 = ctx.r[8].s64 + -8;
	// 82A0EBE4: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A0EBE8: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0EBEC: 419A0024  beq cr6, 0x82a0ec10
	if ctx.cr[6].eq {
	pc = 0x82A0EC10; continue 'dispatch;
	}
	// 82A0EBF0: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EBF4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EBF8: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0EBFC: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0EC00: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EC04: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EC08: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0EC0C: 90880004  stw r4, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A0EC10; continue 'dispatch;
            }
            0x82A0EC10 => {
    //   block [0x82A0EC10..0x82A0EC3C)
	// 82A0EC10: 38A5FFF8  addi r5, r5, -8
	ctx.r[5].s64 = ctx.r[5].s64 + -8;
	// 82A0EC14: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EC18: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82A0EC1C: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EC20: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0EC24: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0EC28: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EC2C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EC30: 90880004  stw r4, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A0EC34: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0EC38: 4BFFFDCC  b 0x82a0ea04
	pc = 0x82A0EA04; continue 'dispatch;
            }
            0x82A0EC3C => {
    //   block [0x82A0EC3C..0x82A0EC74)
	// 82A0EC3C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0EC40: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82A0EC44: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EC48: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82A0EC4C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82A0EC50: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0EC54: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EC58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0EC5C: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0EC60: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EC64: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EC68: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A0EC6C: 90660004  stw r3, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A0EC70: 4BFFFD94  b 0x82a0ea04
	pc = 0x82A0EA04; continue 'dispatch;
            }
            0x82A0EC74 => {
    //   block [0x82A0EC74..0x82A0EC94)
	// 82A0EC74: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0EC78: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0EC7C: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EC80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0EC84: F9780000  std r11, 0(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A0EC88: F9580008  std r10, 8(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82A0EC8C: 419A0008  beq cr6, 0x82a0ec94
	if ctx.cr[6].eq {
	pc = 0x82A0EC94; continue 'dispatch;
	}
	// 82A0EC90: 4B80D0A9  bl 0x8221bd38
	ctx.lr = 0x82A0EC94;
	sub_8221BD38(ctx, base);
	pc = 0x82A0EC94; continue 'dispatch;
            }
            0x82A0EC94 => {
    //   block [0x82A0EC94..0x82A0ECAC)
	// 82A0EC94: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A0EC98: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A0EC9C: 93FB0008  stw r31, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82A0ECA0: 93FB000C  stw r31, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0ECA4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A0ECA8: 4829A7A0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0ECB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0ECB0 size=340
    let mut pc: u32 = 0x82A0ECB0;
    'dispatch: loop {
        match pc {
            0x82A0ECB0 => {
    //   block [0x82A0ECB0..0x82A0ECF4)
	// 82A0ECB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0ECB4: 4829A74D  bl 0x82ca9400
	ctx.lr = 0x82A0ECB8;
	sub_82CA93D0(ctx, base);
	// 82A0ECB8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0ECBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A0ECC0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A0ECC4: FB8100B0  std r28, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u64 ) };
	// 82A0ECC8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A0ECCC: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A0ECD0: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A0ECD4: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A0ECD8: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0ECDC: 419A0104  beq cr6, 0x82a0ede0
	if ctx.cr[6].eq {
	pc = 0x82A0EDE0; continue 'dispatch;
	}
	// 82A0ECE0: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82A0ECE4: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82A0ECE8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A0ECEC: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0ECF0: 419A00F0  beq cr6, 0x82a0ede0
	if ctx.cr[6].eq {
	pc = 0x82A0EDE0; continue 'dispatch;
	}
	pc = 0x82A0ECF4; continue 'dispatch;
            }
            0x82A0ECF4 => {
    //   block [0x82A0ECF4..0x82A0ED20)
	// 82A0ECF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0ECF8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0ECFC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0ED00: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0ED04: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A0ED08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0ED0C: 7C084C2E  lfsx f0, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0ED10: 7DA74C2E  lfsx f13, r7, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0ED14: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0ED18: 41990008  bgt cr6, 0x82a0ed20
	if ctx.cr[6].gt {
	pc = 0x82A0ED20; continue 'dispatch;
	}
	// 82A0ED1C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A0ED20; continue 'dispatch;
            }
            0x82A0ED20 => {
    //   block [0x82A0ED20..0x82A0ED54)
	// 82A0ED20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0ED24: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0ED28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0ED2C: 419A0028  beq cr6, 0x82a0ed54
	if ctx.cr[6].eq {
	pc = 0x82A0ED54; continue 'dispatch;
	}
	// 82A0ED30: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A0ED34: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A0ED38: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0ED3C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A0ED40: 419A0090  beq cr6, 0x82a0edd0
	if ctx.cr[6].eq {
	pc = 0x82A0EDD0; continue 'dispatch;
	}
	// 82A0ED44: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0ED48: 419A0088  beq cr6, 0x82a0edd0
	if ctx.cr[6].eq {
	pc = 0x82A0EDD0; continue 'dispatch;
	}
	// 82A0ED4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0ED50: 48000070  b 0x82a0edc0
	pc = 0x82A0EDC0; continue 'dispatch;
            }
            0x82A0ED54 => {
    //   block [0x82A0ED54..0x82A0ED64)
	// 82A0ED54: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A0ED58: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82A0ED5C: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A0ED60: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82A0ED64; continue 'dispatch;
            }
            0x82A0ED64 => {
    //   block [0x82A0ED64..0x82A0ED88)
	// 82A0ED64: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82A0ED68: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A0ED6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0ED70: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0ED74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0ED78: 7DA84C2E  lfsx f13, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0ED7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0ED80: 41990008  bgt cr6, 0x82a0ed88
	if ctx.cr[6].gt {
	pc = 0x82A0ED88; continue 'dispatch;
	}
	// 82A0ED84: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A0ED88; continue 'dispatch;
            }
            0x82A0ED88 => {
    //   block [0x82A0ED88..0x82A0ED9C)
	// 82A0ED88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0ED8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0ED90: 419A000C  beq cr6, 0x82a0ed9c
	if ctx.cr[6].eq {
	pc = 0x82A0ED9C; continue 'dispatch;
	}
	// 82A0ED94: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0ED98: 4BFFFFCC  b 0x82a0ed64
	pc = 0x82A0ED64; continue 'dispatch;
            }
            0x82A0ED9C => {
    //   block [0x82A0ED9C..0x82A0EDC0)
	// 82A0ED9C: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82A0EDA0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0EDA4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0EDA8: 419A0028  beq cr6, 0x82a0edd0
	if ctx.cr[6].eq {
	pc = 0x82A0EDD0; continue 'dispatch;
	}
	// 82A0EDAC: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A0EDB0: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A0EDB4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A0EDB8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0EDBC: 419A0014  beq cr6, 0x82a0edd0
	if ctx.cr[6].eq {
	pc = 0x82A0EDD0; continue 'dispatch;
	}
	pc = 0x82A0EDC0; continue 'dispatch;
            }
            0x82A0EDC0 => {
    //   block [0x82A0EDC0..0x82A0EDD0)
	// 82A0EDC0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A0EDC4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0EDC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0EDCC: 480841ED  bl 0x82a92fb8
	ctx.lr = 0x82A0EDD0;
	sub_82A92FB8(ctx, base);
	pc = 0x82A0EDD0; continue 'dispatch;
            }
            0x82A0EDD0 => {
    //   block [0x82A0EDD0..0x82A0EDE0)
	// 82A0EDD0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A0EDD4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A0EDD8: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0EDDC: 409AFF18  bne cr6, 0x82a0ecf4
	if !ctx.cr[6].eq {
	pc = 0x82A0ECF4; continue 'dispatch;
	}
	pc = 0x82A0EDE0; continue 'dispatch;
            }
            0x82A0EDE0 => {
    //   block [0x82A0EDE0..0x82A0EDF0)
	// 82A0EDE0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EDE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0EDE8: 419A0008  beq cr6, 0x82a0edf0
	if ctx.cr[6].eq {
	pc = 0x82A0EDF0; continue 'dispatch;
	}
	// 82A0EDEC: 4B80CF4D  bl 0x8221bd38
	ctx.lr = 0x82A0EDF0;
	sub_8221BD38(ctx, base);
	pc = 0x82A0EDF0; continue 'dispatch;
            }
            0x82A0EDF0 => {
    //   block [0x82A0EDF0..0x82A0EE04)
	// 82A0EDF0: 935D0004  stw r26, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82A0EDF4: 935D0008  stw r26, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82A0EDF8: 935D000C  stw r26, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 82A0EDFC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0EE00: 4829A650  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0EE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0EE08 size=360
    let mut pc: u32 = 0x82A0EE08;
    'dispatch: loop {
        match pc {
            0x82A0EE08 => {
    //   block [0x82A0EE08..0x82A0EF30)
	// 82A0EE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0EE0C: 4829A5E9  bl 0x82ca93f4
	ctx.lr = 0x82A0EE10;
	sub_82CA93D0(ctx, base);
	// 82A0EE10: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0EE14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0EE18: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A0EE1C: FBA100D0  std r29, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[29].u64 ) };
	// 82A0EE20: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A0EE24: FB6100E0  std r27, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[27].u64 ) };
	// 82A0EE28: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A0EE2C: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A0EE30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0EE34: 82E100E4  lwz r23, 0xe4(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A0EE38: 7D78B850  subf r11, r24, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[24].s64;
	// 82A0EE3C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0EE40: FB8100D8  std r28, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[28].u64 ) };
	// 82A0EE44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0EE48: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 82A0EE4C: 409900E4  ble cr6, 0x82a0ef30
	if !ctx.cr[6].gt {
	pc = 0x82A0EF30; continue 'dispatch;
	}
	// 82A0EE50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0EE54: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0EE58: 7F4A0194  addze r26, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[26].s64 = tmp.s64;
	// 82A0EE5C: 4BFFF6FD  bl 0x82a0e558
	ctx.lr = 0x82A0EE60;
	sub_82A0E558(ctx, base);
	// 82A0EE60: 57592036  slwi r25, r26, 4
	ctx.r[25].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82A0EE64: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82A0EE68: 575E1838  slwi r30, r26, 3
	ctx.r[30].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82A0EE6C: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 82A0EE70: 7D39C214  add r9, r25, r24
	ctx.r[9].u64 = ctx.r[25].u64 + ctx.r[24].u64;
	// 82A0EE74: 7F5EC214  add r26, r30, r24
	ctx.r[26].u64 = ctx.r[30].u64 + ctx.r[24].u64;
	// 82A0EE78: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A0EE7C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A0EE80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0EE84: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A0EE88: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0EE8C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0EE90: 480000E1  bl 0x82a0ef70
	ctx.lr = 0x82A0EE94;
	sub_82A0EF70(ctx, base);
	// 82A0EE94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0EE98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0EE9C: 4BFFF6BD  bl 0x82a0e558
	ctx.lr = 0x82A0EEA0;
	sub_82A0E558(ctx, base);
	// 82A0EEA0: 816100DC  lwz r11, 0xdc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A0EEA4: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A0EEA8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A0EEAC: 7D1E5A14  add r8, r30, r11
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A0EEB0: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82A0EEB4: 7CFE5850  subf r7, r30, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A0EEB8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0EEBC: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82A0EEC0: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82A0EEC4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0EEC8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0EECC: 480000A5  bl 0x82a0ef70
	ctx.lr = 0x82A0EED0;
	sub_82A0EF70(ctx, base);
	// 82A0EED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0EED4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0EED8: 4BFFF681  bl 0x82a0e558
	ctx.lr = 0x82A0EEDC;
	sub_82A0E558(ctx, base);
	// 82A0EEDC: 7C99B850  subf r4, r25, r23
	ctx.r[4].s64 = ctx.r[23].s64 - ctx.r[25].s64;
	// 82A0EEE0: 7FDEB850  subf r30, r30, r23
	ctx.r[30].s64 = ctx.r[23].s64 - ctx.r[30].s64;
	// 82A0EEE4: FB610058  std r27, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u64 ) };
	// 82A0EEE8: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82A0EEEC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A0EEF0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A0EEF4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82A0EEF8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A0EEFC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0EF00: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0EF04: 4800006D  bl 0x82a0ef70
	ctx.lr = 0x82A0EF08;
	sub_82A0EF70(ctx, base);
	// 82A0EF08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0EF0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0EF10: 4BFFF649  bl 0x82a0e558
	ctx.lr = 0x82A0EF14;
	sub_82A0E558(ctx, base);
	// 82A0EF14: FB610058  std r27, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u64 ) };
	// 82A0EF18: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82A0EF1C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A0EF20: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A0EF24: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0EF28: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0EF2C: 48000010  b 0x82a0ef3c
	pc = 0x82A0EF3C; continue 'dispatch;
            }
            0x82A0EF30 => {
    //   block [0x82A0EF30..0x82A0EF3C)
	// 82A0EF30: 4BFFF629  bl 0x82a0e558
	ctx.lr = 0x82A0EF34;
	sub_82A0E558(ctx, base);
	// 82A0EF34: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A0EF38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82A0EF3C; continue 'dispatch;
            }
            0x82A0EF3C => {
    //   block [0x82A0EF3C..0x82A0EF58)
	// 82A0EF3C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A0EF40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0EF44: 4800002D  bl 0x82a0ef70
	ctx.lr = 0x82A0EF48;
	sub_82A0EF70(ctx, base);
	// 82A0EF48: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EF4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0EF50: 419A0008  beq cr6, 0x82a0ef58
	if ctx.cr[6].eq {
	pc = 0x82A0EF58; continue 'dispatch;
	}
	// 82A0EF54: 4B80CDE5  bl 0x8221bd38
	ctx.lr = 0x82A0EF58;
	sub_8221BD38(ctx, base);
	pc = 0x82A0EF58; continue 'dispatch;
            }
            0x82A0EF58 => {
    //   block [0x82A0EF58..0x82A0EF70)
	// 82A0EF58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0EF5C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0EF60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0EF64: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0EF68: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A0EF6C: 4829A4D8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0EF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0EF70 size=368
    let mut pc: u32 = 0x82A0EF70;
    'dispatch: loop {
        match pc {
            0x82A0EF70 => {
    //   block [0x82A0EF70..0x82A0EFCC)
	// 82A0EF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0EF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0EF78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0EF7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0EF80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0EF84: F8610080  std r3, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u64 ) };
	// 82A0EF88: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A0EF8C: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 82A0EF90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A0EF94: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A0EF98: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A0EF9C: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 82A0EFA0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EFA4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EFA8: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EFAC: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A0EFB0: 54E5103A  slwi r5, r7, 2
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A0EFB4: 7C06542E  lfsx f0, r6, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0EFB8: 7DA5542E  lfsx f13, r5, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0EFBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0EFC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0EFC4: 41990008  bgt cr6, 0x82a0efcc
	if ctx.cr[6].gt {
	pc = 0x82A0EFCC; continue 'dispatch;
	}
	// 82A0EFC8: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x82A0EFCC; continue 'dispatch;
            }
            0x82A0EFCC => {
    //   block [0x82A0EFCC..0x82A0EFF8)
	// 82A0EFCC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0EFD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0EFD4: 419A0024  beq cr6, 0x82a0eff8
	if ctx.cr[6].eq {
	pc = 0x82A0EFF8; continue 'dispatch;
	}
	// 82A0EFD8: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EFDC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0EFE0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0EFE4: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0EFE8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EFEC: 80C80004  lwz r6, 4(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0EFF0: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A0EFF4: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82A0EFF8; continue 'dispatch;
            }
            0x82A0EFF8 => {
    //   block [0x82A0EFF8..0x82A0F028)
	// 82A0EFF8: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A0EFFC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F000: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F004: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A0F008: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A0F00C: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F010: 54A4103A  slwi r4, r5, 2
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0F014: 7C063C2E  lfsx f0, r6, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0F018: 7DA43C2E  lfsx f13, r4, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0F01C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0F020: 41990008  bgt cr6, 0x82a0f028
	if ctx.cr[6].gt {
	pc = 0x82A0F028; continue 'dispatch;
	}
	// 82A0F024: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82A0F028; continue 'dispatch;
            }
            0x82A0F028 => {
    //   block [0x82A0F028..0x82A0F054)
	// 82A0F028: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82A0F02C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0F030: 419A0024  beq cr6, 0x82a0f054
	if ctx.cr[6].eq {
	pc = 0x82A0F054; continue 'dispatch;
	}
	// 82A0F034: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F038: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F03C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0F040: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A0F044: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F048: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F04C: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A0F050: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	pc = 0x82A0F054; continue 'dispatch;
            }
            0x82A0F054 => {
    //   block [0x82A0F054..0x82A0F080)
	// 82A0F054: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F058: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F05C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F060: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A0F064: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A0F068: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0F06C: 7C063C2E  lfsx f0, r6, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0F070: 7DA53C2E  lfsx f13, r5, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0F074: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0F078: 41990008  bgt cr6, 0x82a0f080
	if ctx.cr[6].gt {
	pc = 0x82A0F080; continue 'dispatch;
	}
	// 82A0F07C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x82A0F080; continue 'dispatch;
            }
            0x82A0F080 => {
    //   block [0x82A0F080..0x82A0F0AC)
	// 82A0F080: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0F084: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0F088: 419A0024  beq cr6, 0x82a0f0ac
	if ctx.cr[6].eq {
	pc = 0x82A0F0AC; continue 'dispatch;
	}
	// 82A0F08C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F090: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F094: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0F098: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0F09C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F0A0: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F0A4: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A0F0A8: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	pc = 0x82A0F0AC; continue 'dispatch;
            }
            0x82A0F0AC => {
    //   block [0x82A0F0AC..0x82A0F0BC)
	// 82A0F0AC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F0B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0F0B4: 419A0008  beq cr6, 0x82a0f0bc
	if ctx.cr[6].eq {
	pc = 0x82A0F0BC; continue 'dispatch;
	}
	// 82A0F0B8: 4B80CC81  bl 0x8221bd38
	ctx.lr = 0x82A0F0BC;
	sub_8221BD38(ctx, base);
	pc = 0x82A0F0BC; continue 'dispatch;
            }
            0x82A0F0BC => {
    //   block [0x82A0F0BC..0x82A0F0E0)
	// 82A0F0BC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A0F0C0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A0F0C4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A0F0C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0F0CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F0D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0F0D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0F0D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0F0DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0F0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0F0E0 size=444
    let mut pc: u32 = 0x82A0F0E0;
    'dispatch: loop {
        match pc {
            0x82A0F0E0 => {
    //   block [0x82A0F0E0..0x82A0F11C)
	// 82A0F0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F0E4: 4829A31D  bl 0x82ca9400
	ctx.lr = 0x82A0F0E8;
	sub_82CA93D0(ctx, base);
	// 82A0F0E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F0EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0F0F0: F86100B0  std r3, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u64 ) };
	// 82A0F0F4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A0F0F8: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A0F0FC: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82A0F100: FB6100C8  std r27, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[27].u64 ) };
	// 82A0F104: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A0F108: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F10C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A0F110: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82A0F114: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82A0F118: 40980088  bge cr6, 0x82a0f1a0
	if !ctx.cr[6].lt {
	pc = 0x82A0F1A0; continue 'dispatch;
	}
	pc = 0x82A0F11C; continue 'dispatch;
            }
            0x82A0F11C => {
    //   block [0x82A0F11C..0x82A0F158)
	// 82A0F11C: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0F120: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F124: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A0F128: 390AFFF8  addi r8, r10, -8
	ctx.r[8].s64 = ctx.r[10].s64 + -8;
	// 82A0F12C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A0F130: 80EAFFF8  lwz r7, -8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F134: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F138: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0F13C: 54E4103A  slwi r4, r7, 2
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0F140: 54C3103A  slwi r3, r6, 2
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A0F144: 7C044C2E  lfsx f0, r4, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0F148: 7DA34C2E  lfsx f13, r3, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0F14C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0F150: 41990008  bgt cr6, 0x82a0f158
	if ctx.cr[6].gt {
	pc = 0x82A0F158; continue 'dispatch;
	}
	// 82A0F154: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x82A0F158; continue 'dispatch;
            }
            0x82A0F158 => {
    //   block [0x82A0F158..0x82A0F168)
	// 82A0F158: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A0F15C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0F160: 419A0008  beq cr6, 0x82a0f168
	if ctx.cr[6].eq {
	pc = 0x82A0F168; continue 'dispatch;
	}
	// 82A0F164: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82A0F168; continue 'dispatch;
            }
            0x82A0F168 => {
    //   block [0x82A0F168..0x82A0F1A0)
	// 82A0F168: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0F16C: 57E91838  slwi r9, r31, 3
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0F170: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A0F174: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A0F178: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82A0F17C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A0F180: 550B083C  slwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F184: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F188: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82A0F18C: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A0F190: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F194: 90C90004  stw r6, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A0F198: 4198FF84  blt cr6, 0x82a0f11c
	if ctx.cr[6].lt {
	pc = 0x82A0F11C; continue 'dispatch;
	}
	// 82A0F19C: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	pc = 0x82A0F1A0; continue 'dispatch;
            }
            0x82A0F1A0 => {
    //   block [0x82A0F1A0..0x82A0F1CC)
	// 82A0F1A0: 409A002C  bne cr6, 0x82a0f1cc
	if !ctx.cr[6].eq {
	pc = 0x82A0F1CC; continue 'dispatch;
	}
	// 82A0F1A4: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F1A8: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0F1AC: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A0F1B0: 7D69F214  add r11, r9, r30
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A0F1B4: 3BE5FFFF  addi r31, r5, -1
	ctx.r[31].s64 = ctx.r[5].s64 + -1;
	// 82A0F1B8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82A0F1BC: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F1C0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0F1C4: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A0F1C8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82A0F1CC; continue 'dispatch;
            }
            0x82A0F1CC => {
    //   block [0x82A0F1CC..0x82A0F1FC)
	// 82A0F1CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0F1D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0F1D4: 4BFFF385  bl 0x82a0e558
	ctx.lr = 0x82A0F1D8;
	sub_82A0E558(ctx, base);
	// 82A0F1D8: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82A0F1DC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0F1E0: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82A0F1E4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A0F1E8: 7F1DF800  cmpw cr6, r29, r31
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82A0F1EC: 7D6A0194  addze r11, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A0F1F0: 40980074  bge cr6, 0x82a0f264
	if !ctx.cr[6].lt {
	pc = 0x82A0F264; continue 'dispatch;
	}
	// 82A0F1F4: 814100C8  lwz r10, 0xc8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82A0F1F8: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x82A0F1FC; continue 'dispatch;
            }
            0x82A0F1FC => {
    //   block [0x82A0F1FC..0x82A0F224)
	// 82A0F1FC: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0F200: 7C071C2E  lfsx f0, r7, r3
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0F204: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A0F208: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F20C: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A0F210: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A0F214: 7DA61C2E  lfsx f13, r6, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0F218: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0F21C: 41990008  bgt cr6, 0x82a0f224
	if ctx.cr[6].gt {
	pc = 0x82A0F224; continue 'dispatch;
	}
	// 82A0F220: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x82A0F224; continue 'dispatch;
            }
            0x82A0F224 => {
    //   block [0x82A0F224..0x82A0F264)
	// 82A0F224: 5508063E  clrlwi r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82A0F228: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A0F22C: 419A0038  beq cr6, 0x82a0f264
	if ctx.cr[6].eq {
	pc = 0x82A0F264; continue 'dispatch;
	}
	// 82A0F230: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82A0F234: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0F238: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 82A0F23C: 7D49F214  add r10, r9, r30
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A0F240: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A0F244: 80A80000  lwz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F248: 7CC40E70  srawi r4, r6, 1
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[6].s32 >> 1) as i64;
	// 82A0F24C: 7F1D4800  cmpw cr6, r29, r9
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A0F250: 7D640194  addze r11, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A0F254: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A0F258: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F25C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A0F260: 4198FF9C  blt cr6, 0x82a0f1fc
	if ctx.cr[6].lt {
	pc = 0x82A0F1FC; continue 'dispatch;
	}
	pc = 0x82A0F264; continue 'dispatch;
            }
            0x82A0F264 => {
    //   block [0x82A0F264..0x82A0F278)
	// 82A0F264: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F268: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0F26C: 7F6BF12A  stdx r27, r11, r30
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[27].u64) };
	// 82A0F270: 419A0008  beq cr6, 0x82a0f278
	if ctx.cr[6].eq {
	pc = 0x82A0F278; continue 'dispatch;
	}
	// 82A0F274: 4B80CAC5  bl 0x8221bd38
	ctx.lr = 0x82A0F278;
	sub_8221BD38(ctx, base);
	pc = 0x82A0F278; continue 'dispatch;
            }
            0x82A0F278 => {
    //   block [0x82A0F278..0x82A0F288)
	// 82A0F278: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F27C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0F280: 419A0008  beq cr6, 0x82a0f288
	if ctx.cr[6].eq {
	pc = 0x82A0F288; continue 'dispatch;
	}
	// 82A0F284: 4B80CAB5  bl 0x8221bd38
	ctx.lr = 0x82A0F288;
	sub_8221BD38(ctx, base);
	pc = 0x82A0F288; continue 'dispatch;
            }
            0x82A0F288 => {
    //   block [0x82A0F288..0x82A0F29C)
	// 82A0F288: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82A0F28C: 935C0008  stw r26, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82A0F290: 935C000C  stw r26, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 82A0F294: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0F298: 4829A1B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0F2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0F2A0 size=216
    let mut pc: u32 = 0x82A0F2A0;
    'dispatch: loop {
        match pc {
            0x82A0F2A0 => {
    //   block [0x82A0F2A0..0x82A0F340)
	// 82A0F2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F2A4: 4829A161  bl 0x82ca9404
	ctx.lr = 0x82A0F2A8;
	sub_82CA93D0(ctx, base);
	// 82A0F2A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F2AC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0F2B0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A0F2B4: FB6100C0  std r27, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u64 ) };
	// 82A0F2B8: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82A0F2BC: 83E100C4  lwz r31, 0xc4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0F2C0: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A0F2C4: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 82A0F2C8: 556A0038  rlwinm r10, r11, 0, 0, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0F2CC: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 82A0F2D0: 40990080  ble cr6, 0x82a0f350
	if !ctx.cr[6].gt {
	pc = 0x82A0F350; continue 'dispatch;
	}
	// 82A0F2D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0F2D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0F2DC: 4BFFF27D  bl 0x82a0e558
	ctx.lr = 0x82A0F2E0;
	sub_82A0E558(ctx, base);
	// 82A0F2E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A0F2E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0F2E8: 3BDDFFF8  addi r30, r29, -8
	ctx.r[30].s64 = ctx.r[29].s64 + -8;
	// 82A0F2EC: EBBDFFF8  ld r29, -8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) };
	// 82A0F2F0: 4BFFF269  bl 0x82a0e558
	ctx.lr = 0x82A0F2F4;
	sub_82A0E558(ctx, base);
	// 82A0F2F4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F2F8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A0F2FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0F300: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0F304: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0F308: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F30C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0F310: 4BFFF249  bl 0x82a0e558
	ctx.lr = 0x82A0F314;
	sub_82A0E558(ctx, base);
	// 82A0F314: 7D1FF050  subf r8, r31, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A0F318: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82A0F31C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A0F320: 7D051E70  srawi r5, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82A0F324: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A0F328: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A0F32C: 4BFFFDB5  bl 0x82a0f0e0
	ctx.lr = 0x82A0F330;
	sub_82A0F0E0(ctx, base);
	// 82A0F330: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0F334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0F338: 419A0008  beq cr6, 0x82a0f340
	if ctx.cr[6].eq {
	pc = 0x82A0F340; continue 'dispatch;
	}
	// 82A0F33C: 4B80C9FD  bl 0x8221bd38
	ctx.lr = 0x82A0F340;
	sub_8221BD38(ctx, base);
	pc = 0x82A0F340; continue 'dispatch;
            }
            0x82A0F340 => {
    //   block [0x82A0F340..0x82A0F350)
	// 82A0F340: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0F344: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0F348: 419A0008  beq cr6, 0x82a0f350
	if ctx.cr[6].eq {
	pc = 0x82A0F350; continue 'dispatch;
	}
	// 82A0F34C: 4B80C9ED  bl 0x8221bd38
	ctx.lr = 0x82A0F350;
	sub_8221BD38(ctx, base);
	pc = 0x82A0F350; continue 'dispatch;
            }
            0x82A0F350 => {
    //   block [0x82A0F350..0x82A0F360)
	// 82A0F350: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0F358: 419A0008  beq cr6, 0x82a0f360
	if ctx.cr[6].eq {
	pc = 0x82A0F360; continue 'dispatch;
	}
	// 82A0F35C: 4B80C9DD  bl 0x8221bd38
	ctx.lr = 0x82A0F360;
	sub_8221BD38(ctx, base);
	pc = 0x82A0F360; continue 'dispatch;
            }
            0x82A0F360 => {
    //   block [0x82A0F360..0x82A0F378)
	// 82A0F360: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0F364: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0F368: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A0F36C: 917C000C  stw r11, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0F370: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A0F374: 4829A0E0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0F378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0F378 size=80
    let mut pc: u32 = 0x82A0F378;
    'dispatch: loop {
        match pc {
            0x82A0F378 => {
    //   block [0x82A0F378..0x82A0F3B0)
	// 82A0F378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0F380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0F384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0F388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F38C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0F390: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0F394: 48830525  bl 0x8323f8b8
	ctx.lr = 0x82A0F398;
	sub_8323F8B8(ctx, base);
	// 82A0F398: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A0F39C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0F3A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0F3A4: 419A000C  beq cr6, 0x82a0f3b0
	if ctx.cr[6].eq {
	pc = 0x82A0F3B0; continue 'dispatch;
	}
	// 82A0F3A8: 4B80C991  bl 0x8221bd38
	ctx.lr = 0x82A0F3AC;
	sub_8221BD38(ctx, base);
	// 82A0F3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0F3B0; continue 'dispatch;
            }
            0x82A0F3B0 => {
    //   block [0x82A0F3B0..0x82A0F3C8)
	// 82A0F3B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0F3B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F3B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0F3BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0F3C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0F3C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0F3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0F3C8 size=80
    let mut pc: u32 = 0x82A0F3C8;
    'dispatch: loop {
        match pc {
            0x82A0F3C8 => {
    //   block [0x82A0F3C8..0x82A0F400)
	// 82A0F3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F3CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0F3D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0F3D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0F3D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F3DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0F3E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0F3E4: 4882FCED  bl 0x8323f0d0
	ctx.lr = 0x82A0F3E8;
	sub_8323F0D0(ctx, base);
	// 82A0F3E8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A0F3EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0F3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0F3F4: 419A000C  beq cr6, 0x82a0f400
	if ctx.cr[6].eq {
	pc = 0x82A0F400; continue 'dispatch;
	}
	// 82A0F3F8: 4B80C941  bl 0x8221bd38
	ctx.lr = 0x82A0F3FC;
	sub_8221BD38(ctx, base);
	// 82A0F3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0F400; continue 'dispatch;
            }
            0x82A0F400 => {
    //   block [0x82A0F400..0x82A0F418)
	// 82A0F400: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0F404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0F40C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0F410: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0F414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0F418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0F418 size=80
    let mut pc: u32 = 0x82A0F418;
    'dispatch: loop {
        match pc {
            0x82A0F418 => {
    //   block [0x82A0F418..0x82A0F450)
	// 82A0F418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0F420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0F424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0F428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0F430: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0F434: 4881845D  bl 0x83227890
	ctx.lr = 0x82A0F438;
	sub_83227890(ctx, base);
	// 82A0F438: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A0F43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0F440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0F444: 419A000C  beq cr6, 0x82a0f450
	if ctx.cr[6].eq {
	pc = 0x82A0F450; continue 'dispatch;
	}
	// 82A0F448: 4B80C8F1  bl 0x8221bd38
	ctx.lr = 0x82A0F44C;
	sub_8221BD38(ctx, base);
	// 82A0F44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A0F450; continue 'dispatch;
            }
            0x82A0F450 => {
    //   block [0x82A0F450..0x82A0F468)
	// 82A0F450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0F454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0F45C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0F460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0F464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


