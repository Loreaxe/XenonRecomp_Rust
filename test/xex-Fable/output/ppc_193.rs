pub fn sub_830EF608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EF608 size=12
    let mut pc: u32 = 0x830EF608;
    'dispatch: loop {
        match pc {
            0x830EF608 => {
    //   block [0x830EF608..0x830EF614)
	// 830EF608: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830EF60C: 386BBA88  addi r3, r11, -0x4578
	ctx.r[3].s64 = ctx.r[11].s64 + -17784;
	// 830EF610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF618 size=168
    let mut pc: u32 = 0x830EF618;
    'dispatch: loop {
        match pc {
            0x830EF618 => {
    //   block [0x830EF618..0x830EF650)
	// 830EF618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF61C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EF620: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EF624: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EF628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF62C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF630: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830EF634: 394AA694  addi r10, r10, -0x596c
	ctx.r[10].s64 = ctx.r[10].s64 + -22892;
	// 830EF638: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF63C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF640: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EF644: 41820058  beq 0x830ef69c
	if ctx.cr[0].eq {
	pc = 0x830EF69C; continue 'dispatch;
	}
	// 830EF648: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF64C: 48000028  b 0x830ef674
	pc = 0x830EF674; continue 'dispatch;
            }
            0x830EF650 => {
    //   block [0x830EF650..0x830EF670)
	// 830EF650: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF654: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF658: 41820018  beq 0x830ef670
	if ctx.cr[0].eq {
	pc = 0x830EF670; continue 'dispatch;
	}
	// 830EF65C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF660: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EF664: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EF66C: 4E800421  bctrl
	ctx.lr = 0x830EF670;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EF670 => {
    //   block [0x830EF670..0x830EF674)
	// 830EF670: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x830EF674; continue 'dispatch;
            }
            0x830EF674 => {
    //   block [0x830EF674..0x830EF69C)
	// 830EF674: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF678: 4082FFD8  bne 0x830ef650
	if !ctx.cr[0].eq {
	pc = 0x830EF650; continue 'dispatch;
	}
	// 830EF67C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF680: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF684: 41820018  beq 0x830ef69c
	if ctx.cr[0].eq {
	pc = 0x830EF69C; continue 'dispatch;
	}
	// 830EF688: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF68C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EF690: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF694: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EF698: 4E800421  bctrl
	ctx.lr = 0x830EF69C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EF69C => {
    //   block [0x830EF69C..0x830EF6C0)
	// 830EF69C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830EF6A0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830EF6A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EF6A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EF6AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EF6B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EF6B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EF6B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EF6BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF6C0 size=192
    let mut pc: u32 = 0x830EF6C0;
    'dispatch: loop {
        match pc {
            0x830EF6C0 => {
    //   block [0x830EF6C0..0x830EF6F0)
	// 830EF6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF6C4: 4BBB9D3D  bl 0x82ca9400
	ctx.lr = 0x830EF6C8;
	sub_82CA93D0(ctx, base);
	// 830EF6C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF6CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EF6D0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830EF6D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EF6D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830EF6DC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EF6E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF6E4: 40990088  ble cr6, 0x830ef76c
	if !ctx.cr[6].gt {
	pc = 0x830EF76C; continue 'dispatch;
	}
	// 830EF6E8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830EF6EC: 3B6B2304  addi r27, r11, 0x2304
	ctx.r[27].s64 = ctx.r[11].s64 + 8964;
	pc = 0x830EF6F0; continue 'dispatch;
            }
            0x830EF6F0 => {
    //   block [0x830EF6F0..0x830EF730)
	// 830EF6F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EF6F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EF6F8: 4BD94931  bl 0x82e84028
	ctx.lr = 0x830EF6FC;
	sub_82E84028(ctx, base);
	// 830EF6FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830EF700: 41820030  beq 0x830ef730
	if ctx.cr[0].eq {
	pc = 0x830EF730; continue 'dispatch;
	}
	// 830EF704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF708: 480CC959  bl 0x831bc060
	ctx.lr = 0x830EF70C;
	sub_831BC060(ctx, base);
	// 830EF70C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF710: 41820020  beq 0x830ef730
	if ctx.cr[0].eq {
	pc = 0x830EF730; continue 'dispatch;
	}
	// 830EF714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF718: 480CC949  bl 0x831bc060
	ctx.lr = 0x830EF71C;
	sub_831BC060(ctx, base);
	// 830EF71C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830EF720: 4BBBD431  bl 0x82cacb50
	ctx.lr = 0x830EF724;
	sub_82CACB50(ctx, base);
	// 830EF724: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EF728: 40820008  bne 0x830ef730
	if !ctx.cr[0].eq {
	pc = 0x830EF730; continue 'dispatch;
	}
	// 830EF72C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	pc = 0x830EF730; continue 'dispatch;
            }
            0x830EF730 => {
    //   block [0x830EF730..0x830EF764)
	// 830EF730: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EF734: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830EF738: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EF73C: 4198FFB4  blt cr6, 0x830ef6f0
	if ctx.cr[6].lt {
	pc = 0x830EF6F0; continue 'dispatch;
	}
	// 830EF740: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830EF744: 419A0028  beq cr6, 0x830ef76c
	if ctx.cr[6].eq {
	pc = 0x830EF76C; continue 'dispatch;
	}
	// 830EF748: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 830EF74C: 4B5271DD  bl 0x82616928
	ctx.lr = 0x830EF750;
	sub_82616928(ctx, base);
	// 830EF750: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF754: 41820010  beq 0x830ef764
	if ctx.cr[0].eq {
	pc = 0x830EF764; continue 'dispatch;
	}
	// 830EF758: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830EF75C: 4BD9DAD5  bl 0x82e8d230
	ctx.lr = 0x830EF760;
	sub_82E8D230(ctx, base);
	// 830EF760: 48000008  b 0x830ef768
	pc = 0x830EF768; continue 'dispatch;
            }
            0x830EF764 => {
    //   block [0x830EF764..0x830EF768)
	// 830EF764: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830EF768; continue 'dispatch;
            }
            0x830EF768 => {
    //   block [0x830EF768..0x830EF76C)
	// 830EF768: 907A0004  stw r3, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x830EF76C; continue 'dispatch;
            }
            0x830EF76C => {
    //   block [0x830EF76C..0x830EF780)
	// 830EF76C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EF770: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830EF774: 4BD95C35  bl 0x82e853a8
	ctx.lr = 0x830EF778;
	sub_82E853A8(ctx, base);
	// 830EF778: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EF77C: 4BBB9CD4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF780 size=88
    let mut pc: u32 = 0x830EF780;
    'dispatch: loop {
        match pc {
            0x830EF780 => {
    //   block [0x830EF780..0x830EF7A4)
	// 830EF780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EF788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EF78C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF790: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF794: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF798: 4182002C  beq 0x830ef7c4
	if ctx.cr[0].eq {
	pc = 0x830EF7C4; continue 'dispatch;
	}
	// 830EF79C: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF7A0: 4800001C  b 0x830ef7bc
	pc = 0x830EF7BC; continue 'dispatch;
            }
            0x830EF7A4 => {
    //   block [0x830EF7A4..0x830EF7BC)
	// 830EF7A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF7A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF7AC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF7B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EF7B4: 4E800421  bctrl
	ctx.lr = 0x830EF7B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EF7B8: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x830EF7BC => {
    //   block [0x830EF7BC..0x830EF7C4)
	// 830EF7BC: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF7C0: 4082FFE4  bne 0x830ef7a4
	if !ctx.cr[0].eq {
	pc = 0x830EF7A4; continue 'dispatch;
	}
	pc = 0x830EF7C4; continue 'dispatch;
            }
            0x830EF7C4 => {
    //   block [0x830EF7C4..0x830EF7D8)
	// 830EF7C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EF7C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EF7CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EF7D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EF7D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF7D8 size=72
    let mut pc: u32 = 0x830EF7D8;
    'dispatch: loop {
        match pc {
            0x830EF7D8 => {
    //   block [0x830EF7D8..0x830EF80C)
	// 830EF7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF7DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EF7E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF7E4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 830EF7E8: 4B527141  bl 0x82616928
	ctx.lr = 0x830EF7EC;
	sub_82616928(ctx, base);
	// 830EF7EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF7F0: 4182001C  beq 0x830ef80c
	if ctx.cr[0].eq {
	pc = 0x830EF80C; continue 'dispatch;
	}
	// 830EF7F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EF7F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EF7FC: 396BA694  addi r11, r11, -0x596c
	ctx.r[11].s64 = ctx.r[11].s64 + -22892;
	// 830EF800: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EF804: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EF808: 48000008  b 0x830ef810
	pc = 0x830EF810; continue 'dispatch;
            }
            0x830EF80C => {
    //   block [0x830EF80C..0x830EF810)
	// 830EF80C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830EF810; continue 'dispatch;
            }
            0x830EF810 => {
    //   block [0x830EF810..0x830EF820)
	// 830EF810: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EF814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EF818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EF81C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF820 size=88
    let mut pc: u32 = 0x830EF820;
    'dispatch: loop {
        match pc {
            0x830EF820 => {
    //   block [0x830EF820..0x830EF85C)
	// 830EF820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EF828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EF82C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EF830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF838: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EF83C: 4BFFFDDD  bl 0x830ef618
	ctx.lr = 0x830EF840;
	sub_830EF618(ctx, base);
	// 830EF840: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF844: 41820018  beq 0x830ef85c
	if ctx.cr[0].eq {
	pc = 0x830EF85C; continue 'dispatch;
	}
	// 830EF848: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EF84C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF850: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830EF854: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EF858: 4E800421  bctrl
	ctx.lr = 0x830EF85C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EF85C => {
    //   block [0x830EF85C..0x830EF878)
	// 830EF85C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF860: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EF864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EF868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EF86C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EF870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EF874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF878 size=160
    let mut pc: u32 = 0x830EF878;
    'dispatch: loop {
        match pc {
            0x830EF878 => {
    //   block [0x830EF878..0x830EF8AC)
	// 830EF878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EF880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EF884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF88C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830EF890: 419A0064  beq cr6, 0x830ef8f4
	if ctx.cr[6].eq {
	pc = 0x830EF8F4; continue 'dispatch;
	}
	// 830EF894: 4BDBA9A5  bl 0x82eaa238
	ctx.lr = 0x830EF898;
	sub_82EAA238(ctx, base);
	// 830EF898: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 830EF89C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EF8A0: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EF8A4: 40810050  ble 0x830ef8f4
	if !ctx.cr[0].gt {
	pc = 0x830EF8F4; continue 'dispatch;
	}
	// 830EF8A8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x830EF8AC; continue 'dispatch;
            }
            0x830EF8AC => {
    //   block [0x830EF8AC..0x830EF8B8)
	// 830EF8AC: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF8B0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 830EF8B4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x830EF8B8; continue 'dispatch;
            }
            0x830EF8B8 => {
    //   block [0x830EF8B8..0x830EF8DC)
	// 830EF8B8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF8BC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF8C0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EF8C4: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 830EF8C8: 41820014  beq 0x830ef8dc
	if ctx.cr[0].eq {
	pc = 0x830EF8DC; continue 'dispatch;
	}
	// 830EF8CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EF8D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830EF8D4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EF8D8: 419AFFE0  beq cr6, 0x830ef8b8
	if ctx.cr[6].eq {
	pc = 0x830EF8B8; continue 'dispatch;
	}
	pc = 0x830EF8DC; continue 'dispatch;
            }
            0x830EF8DC => {
    //   block [0x830EF8DC..0x830EF8F4)
	// 830EF8DC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EF8E0: 4182002C  beq 0x830ef90c
	if ctx.cr[0].eq {
	pc = 0x830EF90C; continue 'dispatch;
	}
	// 830EF8E4: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 830EF8E8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 830EF8EC: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830EF8F0: 4198FFBC  blt cr6, 0x830ef8ac
	if ctx.cr[6].lt {
	pc = 0x830EF8AC; continue 'dispatch;
	}
	pc = 0x830EF8F4; continue 'dispatch;
            }
            0x830EF8F4 => {
    //   block [0x830EF8F4..0x830EF8F8)
	// 830EF8F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830EF8F8; continue 'dispatch;
            }
            0x830EF8F8 => {
    //   block [0x830EF8F8..0x830EF90C)
	// 830EF8F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EF8FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EF900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EF904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EF908: 4E800020  blr
	return;
            }
            0x830EF90C => {
    //   block [0x830EF90C..0x830EF918)
	// 830EF90C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EF910: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 830EF914: 4BFFFFE4  b 0x830ef8f8
	pc = 0x830EF8F8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF918 size=328
    let mut pc: u32 = 0x830EF918;
    'dispatch: loop {
        match pc {
            0x830EF918 => {
    //   block [0x830EF918..0x830EF93C)
	// 830EF918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF91C: 4BBB9AF1  bl 0x82ca940c
	ctx.lr = 0x830EF920;
	sub_82CA93D0(ctx, base);
	// 830EF920: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF924: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EF928: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EF92C: 4B529D0D  bl 0x82619638
	ctx.lr = 0x830EF930;
	sub_82619638(ctx, base);
	// 830EF930: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830EF934: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EF938: 409A000C  bne cr6, 0x830ef944
	if !ctx.cr[6].eq {
	pc = 0x830EF944; continue 'dispatch;
	}
	pc = 0x830EF93C; continue 'dispatch;
            }
            0x830EF93C => {
    //   block [0x830EF93C..0x830EF944)
	// 830EF93C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830EF940: 4800009C  b 0x830ef9dc
	pc = 0x830EF9DC; continue 'dispatch;
            }
            0x830EF944 => {
    //   block [0x830EF944..0x830EF9C4)
	// 830EF944: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EF948: 480CC719  bl 0x831bc060
	ctx.lr = 0x830EF94C;
	sub_831BC060(ctx, base);
	// 830EF94C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF950: 41820088  beq 0x830ef9d8
	if ctx.cr[0].eq {
	pc = 0x830EF9D8; continue 'dispatch;
	}
	// 830EF954: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830EF958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EF95C: 3BEB2304  addi r31, r11, 0x2304
	ctx.r[31].s64 = ctx.r[11].s64 + 8964;
	// 830EF960: 480CC701  bl 0x831bc060
	ctx.lr = 0x830EF964;
	sub_831BC060(ctx, base);
	// 830EF964: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EF968: 4BBBD1E9  bl 0x82cacb50
	ctx.lr = 0x830EF96C;
	sub_82CACB50(ctx, base);
	// 830EF96C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EF970: 40820068  bne 0x830ef9d8
	if !ctx.cr[0].eq {
	pc = 0x830EF9D8; continue 'dispatch;
	}
	// 830EF974: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF978: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF97C: 4182005C  beq 0x830ef9d8
	if ctx.cr[0].eq {
	pc = 0x830EF9D8; continue 'dispatch;
	}
	// 830EF980: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EF984: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EF988: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 830EF98C: 4BD9458D  bl 0x82e83f18
	ctx.lr = 0x830EF990;
	sub_82E83F18(ctx, base);
	// 830EF990: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF994: 41820044  beq 0x830ef9d8
	if ctx.cr[0].eq {
	pc = 0x830EF9D8; continue 'dispatch;
	}
	// 830EF998: 4B81E371  bl 0x8290dd08
	ctx.lr = 0x830EF99C;
	sub_8290DD08(ctx, base);
	// 830EF99C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF9A0: 41820038  beq 0x830ef9d8
	if ctx.cr[0].eq {
	pc = 0x830EF9D8; continue 'dispatch;
	}
	// 830EF9A4: 4BFFFED5  bl 0x830ef878
	ctx.lr = 0x830EF9A8;
	sub_830EF878(ctx, base);
	// 830EF9A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF9AC: 40820038  bne 0x830ef9e4
	if !ctx.cr[0].eq {
	pc = 0x830EF9E4; continue 'dispatch;
	}
	// 830EF9B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830EF9B4: 4BDBA885  bl 0x82eaa238
	ctx.lr = 0x830EF9B8;
	sub_82EAA238(ctx, base);
	// 830EF9B8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 830EF9BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF9C0: 40990018  ble cr6, 0x830ef9d8
	if !ctx.cr[6].gt {
	pc = 0x830EF9D8; continue 'dispatch;
	}
	pc = 0x830EF9C4; continue 'dispatch;
            }
            0x830EF9C4 => {
    //   block [0x830EF9C4..0x830EF9D8)
	// 830EF9C4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830EF9C8: 4BDBA871  bl 0x82eaa238
	ctx.lr = 0x830EF9CC;
	sub_82EAA238(ctx, base);
	// 830EF9CC: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 830EF9D0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EF9D4: 4198FFF0  blt cr6, 0x830ef9c4
	if ctx.cr[6].lt {
	pc = 0x830EF9C4; continue 'dispatch;
	}
	pc = 0x830EF9D8; continue 'dispatch;
            }
            0x830EF9D8 => {
    //   block [0x830EF9D8..0x830EF9DC)
	// 830EF9D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830EF9DC; continue 'dispatch;
            }
            0x830EF9DC => {
    //   block [0x830EF9DC..0x830EF9E4)
	// 830EF9DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EF9E0: 4BBB9A7C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830EF9E4 => {
    //   block [0x830EF9E4..0x830EFA34)
	// 830EF9E4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF9E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF9EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EF9F0: 4E800421  bctrl
	ctx.lr = 0x830EF9F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EF9F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF9F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EF9FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFA00: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830EFA04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFA08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFA0C: 4E800421  bctrl
	ctx.lr = 0x830EFA10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFA10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFA14: 40820020  bne 0x830efa34
	if !ctx.cr[0].eq {
	pc = 0x830EFA34; continue 'dispatch;
	}
	// 830EFA18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFA1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EFA20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFA24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFA28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFA2C: 4E800421  bctrl
	ctx.lr = 0x830EFA30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFA30: 4BFFFFA8  b 0x830ef9d8
	pc = 0x830EF9D8; continue 'dispatch;
            }
            0x830EFA34 => {
    //   block [0x830EFA34..0x830EFA60)
	// 830EFA34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EFA38: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFA3C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 830EFA40: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 830EFA44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EFA48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EFA4C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830EFA50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EFA54: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830EFA58: 4BD90119  bl 0x82e7fb70
	ctx.lr = 0x830EFA5C;
	sub_82E7FB70(ctx, base);
	// 830EFA5C: 4BFFFEE0  b 0x830ef93c
	pc = 0x830EF93C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830EFA60 size=104
    let mut pc: u32 = 0x830EFA60;
    'dispatch: loop {
        match pc {
            0x830EFA60 => {
    //   block [0x830EFA60..0x830EFA98)
	// 830EFA60: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EFA64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EFA68: 396BA6E8  addi r11, r11, -0x5918
	ctx.r[11].s64 = ctx.r[11].s64 + -22808;
	// 830EFA6C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830EFA70: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EFA74: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EFA78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830EFA7C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EFA80: C0090C14  lfs f0, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EFA84: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 830EFA88: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFA8C: 4182000C  beq 0x830efa98
	if ctx.cr[0].eq {
	pc = 0x830EFA98; continue 'dispatch;
	}
	// 830EFA90: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EFA94: 48000008  b 0x830efa9c
	pc = 0x830EFA9C; continue 'dispatch;
            }
            0x830EFA98 => {
    //   block [0x830EFA98..0x830EFA9C)
	// 830EFA98: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x830EFA9C; continue 'dispatch;
            }
            0x830EFA9C => {
    //   block [0x830EFA9C..0x830EFABC)
	// 830EFA9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EFAA0: C18A0A98  lfs f12, 0xa98(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EFAA4: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 830EFAA8: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EFAAC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 830EFAB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFAB4: 41820008  beq 0x830efabc
	if ctx.cr[0].eq {
	pc = 0x830EFABC; continue 'dispatch;
	}
	// 830EFAB8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x830EFABC; continue 'dispatch;
            }
            0x830EFABC => {
    //   block [0x830EFABC..0x830EFAC8)
	// 830EFABC: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830EFAC0: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830EFAC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EFAC8 size=112
    let mut pc: u32 = 0x830EFAC8;
    'dispatch: loop {
        match pc {
            0x830EFAC8 => {
    //   block [0x830EFAC8..0x830EFB14)
	// 830EFAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EFACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EFAD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EFAD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EFAD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EFADC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFAE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFAE4: 41820034  beq 0x830efb18
	if ctx.cr[0].eq {
	pc = 0x830EFB18; continue 'dispatch;
	}
	// 830EFAE8: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830EFAEC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830EFAF0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EFAF4: 419A0020  beq cr6, 0x830efb14
	if ctx.cr[6].eq {
	pc = 0x830EFB14; continue 'dispatch;
	}
	// 830EFAF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFAFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830EFB00: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830EFB04: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFB08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFB0C: 4E800421  bctrl
	ctx.lr = 0x830EFB10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFB10: 48000008  b 0x830efb18
	pc = 0x830EFB18; continue 'dispatch;
            }
            0x830EFB14 => {
    //   block [0x830EFB14..0x830EFB18)
	// 830EFB14: 4B755C9D  bl 0x828457b0
	ctx.lr = 0x830EFB18;
	sub_828457B0(ctx, base);
	pc = 0x830EFB18; continue 'dispatch;
            }
            0x830EFB18 => {
    //   block [0x830EFB18..0x830EFB38)
	// 830EFB18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EFB1C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EFB20: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EFB24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EFB28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EFB2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EFB30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EFB34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EFB38 size=60
    let mut pc: u32 = 0x830EFB38;
    'dispatch: loop {
        match pc {
            0x830EFB38 => {
    //   block [0x830EFB38..0x830EFB74)
	// 830EFB38: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFB3C: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFB40: 418200B0  beq 0x830efbf0
	if ctx.cr[0].eq {
		sub_830EFBA0(ctx, base);
		return;
	}
	// 830EFB44: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFB48: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFB4C: 418200A4  beq 0x830efbf0
	if ctx.cr[0].eq {
		sub_830EFBA0(ctx, base);
		return;
	}
	// 830EFB50: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFB54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EFB58: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830EFB5C: 409A0018  bne cr6, 0x830efb74
	if !ctx.cr[6].eq {
		sub_830EFB74(ctx, base);
		return;
	}
	// 830EFB60: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFB64: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830EFB68: 409A000C  bne cr6, 0x830efb74
	if !ctx.cr[6].eq {
		sub_830EFB74(ctx, base);
		return;
	}
	// 830EFB6C: 8067000C  lwz r3, 0xc(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFB70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFB74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EFB74 size=44
    let mut pc: u32 = 0x830EFB74;
    'dispatch: loop {
        match pc {
            0x830EFB74 => {
    //   block [0x830EFB74..0x830EFBA0)
	// 830EFB74: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830EFB78: 550B2036  slwi r11, r8, 4
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EFB7C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830EFB80: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFB84: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830EFB88: 409A0018  bne cr6, 0x830efba0
	if !ctx.cr[6].eq {
		sub_830EFBA0(ctx, base);
		return;
	}
	// 830EFB8C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFB90: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830EFB94: 409A000C  bne cr6, 0x830efba0
	if !ctx.cr[6].eq {
		sub_830EFBA0(ctx, base);
		return;
	}
	// 830EFB98: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFB9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EFBA0 size=88
    let mut pc: u32 = 0x830EFBA0;
    'dispatch: loop {
        match pc {
            0x830EFBA0 => {
    //   block [0x830EFBA0..0x830EFBA8)
	// 830EFBA0: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 830EFBA4: 4099004C  ble cr6, 0x830efbf0
	if !ctx.cr[6].gt {
	pc = 0x830EFBF0; continue 'dispatch;
	}
	pc = 0x830EFBA8; continue 'dispatch;
            }
            0x830EFBA8 => {
    //   block [0x830EFBA8..0x830EFBD4)
	// 830EFBA8: 7D683214  add r11, r8, r6
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 830EFBAC: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EFBB0: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EFBB4: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830EFBB8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFBBC: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830EFBC0: 41990014  bgt cr6, 0x830efbd4
	if ctx.cr[6].gt {
	pc = 0x830EFBD4; continue 'dispatch;
	}
	// 830EFBC4: 4198001C  blt cr6, 0x830efbe0
	if ctx.cr[6].lt {
	pc = 0x830EFBE0; continue 'dispatch;
	}
	// 830EFBC8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFBCC: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830EFBD0: 4099000C  ble cr6, 0x830efbdc
	if !ctx.cr[6].gt {
	pc = 0x830EFBDC; continue 'dispatch;
	}
	pc = 0x830EFBD4; continue 'dispatch;
            }
            0x830EFBD4 => {
    //   block [0x830EFBD4..0x830EFBDC)
	// 830EFBD4: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 830EFBD8: 4800000C  b 0x830efbe4
	pc = 0x830EFBE4; continue 'dispatch;
            }
            0x830EFBDC => {
    //   block [0x830EFBDC..0x830EFBE0)
	// 830EFBDC: 4098001C  bge cr6, 0x830efbf8
	if !ctx.cr[6].lt {
		sub_830EFBF8(ctx, base);
		return;
	}
	pc = 0x830EFBE0; continue 'dispatch;
            }
            0x830EFBE0 => {
    //   block [0x830EFBE0..0x830EFBE4)
	// 830EFBE0: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	pc = 0x830EFBE4; continue 'dispatch;
            }
            0x830EFBE4 => {
    //   block [0x830EFBE4..0x830EFBF0)
	// 830EFBE4: 7D664050  subf r11, r6, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 830EFBE8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EFBEC: 4199FFBC  bgt cr6, 0x830efba8
	if ctx.cr[6].gt {
	pc = 0x830EFBA8; continue 'dispatch;
	}
	pc = 0x830EFBF0; continue 'dispatch;
            }
            0x830EFBF0 => {
    //   block [0x830EFBF0..0x830EFBF8)
	// 830EFBF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EFBF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EFBF8 size=8
    let mut pc: u32 = 0x830EFBF8;
    'dispatch: loop {
        match pc {
            0x830EFBF8 => {
    //   block [0x830EFBF8..0x830EFC00)
	// 830EFBF8: 8069000C  lwz r3, 0xc(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EFC00 size=96
    let mut pc: u32 = 0x830EFC00;
    'dispatch: loop {
        match pc {
            0x830EFC00 => {
    //   block [0x830EFC00..0x830EFC40)
	// 830EFC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EFC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EFC08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EFC0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EFC10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EFC14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EFC18: 396BA6EC  addi r11, r11, -0x5914
	ctx.r[11].s64 = ctx.r[11].s64 + -22804;
	// 830EFC1C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFC20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFC24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EFC28: 41820018  beq 0x830efc40
	if ctx.cr[0].eq {
	pc = 0x830EFC40; continue 'dispatch;
	}
	// 830EFC2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFC30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EFC34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFC38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFC3C: 4E800421  bctrl
	ctx.lr = 0x830EFC40;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EFC40 => {
    //   block [0x830EFC40..0x830EFC60)
	// 830EFC40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830EFC44: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830EFC48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EFC4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EFC50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EFC54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EFC58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EFC5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EFC60 size=68
    let mut pc: u32 = 0x830EFC60;
    'dispatch: loop {
        match pc {
            0x830EFC60 => {
    //   block [0x830EFC60..0x830EFCA4)
	// 830EFC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EFC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EFC68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EFC6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EFC70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EFC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EFC78: 396BA6E8  addi r11, r11, -0x5918
	ctx.r[11].s64 = ctx.r[11].s64 + -22808;
	// 830EFC7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EFC80: 4BFFFE49  bl 0x830efac8
	ctx.lr = 0x830EFC84;
	sub_830EFAC8(ctx, base);
	// 830EFC84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830EFC88: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830EFC8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EFC90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EFC94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EFC98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EFC9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EFCA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EFCA8 size=156
    let mut pc: u32 = 0x830EFCA8;
    'dispatch: loop {
        match pc {
            0x830EFCA8 => {
    //   block [0x830EFCA8..0x830EFCDC)
	// 830EFCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EFCAC: 4BBB975D  bl 0x82ca9408
	ctx.lr = 0x830EFCB0;
	sub_82CA93D0(ctx, base);
	// 830EFCB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EFCB4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830EFCB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EFCBC: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFCC0: 41820054  beq 0x830efd14
	if ctx.cr[0].eq {
	pc = 0x830EFD14; continue 'dispatch;
	}
	// 830EFCC4: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830EFCC8: 3BBFFFFC  addi r29, r31, -4
	ctx.r[29].s64 = ctx.r[31].s64 + -4;
	// 830EFCCC: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EFCD0: 37CBFFFF  addic. r30, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EFCD4: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830EFCD8: 41800018  blt 0x830efcf0
	if ctx.cr[0].lt {
	pc = 0x830EFCF0; continue 'dispatch;
	}
	pc = 0x830EFCDC; continue 'dispatch;
            }
            0x830EFCDC => {
    //   block [0x830EFCDC..0x830EFCF0)
	// 830EFCDC: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 830EFCE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFCE4: 4BFFFF1D  bl 0x830efc00
	ctx.lr = 0x830EFCE8;
	sub_830EFC00(ctx, base);
	// 830EFCE8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EFCEC: 4080FFF0  bge 0x830efcdc
	if !ctx.cr[0].lt {
	pc = 0x830EFCDC; continue 'dispatch;
	}
	pc = 0x830EFCF0; continue 'dispatch;
            }
            0x830EFCF0 => {
    //   block [0x830EFCF0..0x830EFD0C)
	// 830EFCF0: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFCF4: 41820018  beq 0x830efd0c
	if ctx.cr[0].eq {
	pc = 0x830EFD0C; continue 'dispatch;
	}
	// 830EFCF8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EFCFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EFD00: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830EFD04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFD08: 4E800421  bctrl
	ctx.lr = 0x830EFD0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EFD0C => {
    //   block [0x830EFD0C..0x830EFD14)
	// 830EFD0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EFD10: 4800002C  b 0x830efd3c
	pc = 0x830EFD3C; continue 'dispatch;
            }
            0x830EFD14 => {
    //   block [0x830EFD14..0x830EFD38)
	// 830EFD14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFD18: 4BFFFEE9  bl 0x830efc00
	ctx.lr = 0x830EFD1C;
	sub_830EFC00(ctx, base);
	// 830EFD1C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFD20: 41820018  beq 0x830efd38
	if ctx.cr[0].eq {
	pc = 0x830EFD38; continue 'dispatch;
	}
	// 830EFD24: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EFD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFD2C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830EFD30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFD34: 4E800421  bctrl
	ctx.lr = 0x830EFD38;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EFD38 => {
    //   block [0x830EFD38..0x830EFD3C)
	// 830EFD38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830EFD3C; continue 'dispatch;
            }
            0x830EFD3C => {
    //   block [0x830EFD3C..0x830EFD44)
	// 830EFD3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EFD40: 4BBB9718  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EFD48 size=800
    let mut pc: u32 = 0x830EFD48;
    'dispatch: loop {
        match pc {
            0x830EFD48 => {
    //   block [0x830EFD48..0x830EFE9C)
	// 830EFD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EFD4C: 4BBB96A5  bl 0x82ca93f0
	ctx.lr = 0x830EFD50;
	sub_82CA93D0(ctx, base);
	// 830EFD50: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EFD54: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 830EFD58: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830EFD5C: 4BFFFD6D  bl 0x830efac8
	ctx.lr = 0x830EFD60;
	sub_830EFAC8(ctx, base);
	// 830EFD60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830EFD64: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830EFD68: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 830EFD6C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFD74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFD7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFD80: 4E800421  bctrl
	ctx.lr = 0x830EFD84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFD84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFD88: 418202D4  beq 0x830f005c
	if ctx.cr[0].eq {
	pc = 0x830F005C; continue 'dispatch;
	}
	// 830EFD8C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830EFD90: 38C0001D  li r6, 0x1d
	ctx.r[6].s64 = 29;
	// 830EFD94: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830EFD98: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830EFD9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFDA0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 830EFDA4: 9AC10060  stb r22, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u8 ) };
	// 830EFDA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFDAC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFDB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFDB4: 4E800421  bctrl
	ctx.lr = 0x830EFDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFDB8: 2B03001D  cmplwi cr6, r3, 0x1d
	ctx.cr[6].compare_u32(ctx.r[3].u32, 29 as u32, &mut ctx.xer);
	// 830EFDBC: 409A0288  bne cr6, 0x830f0044
	if !ctx.cr[6].eq {
	pc = 0x830F0044; continue 'dispatch;
	}
	// 830EFDC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFDC4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830EFDC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EFDCC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830EFDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFDD4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFDD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFDDC: 4E800421  bctrl
	ctx.lr = 0x830EFDE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFDE0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830EFDE4: 409A0260  bne cr6, 0x830f0044
	if !ctx.cr[6].eq {
	pc = 0x830F0044; continue 'dispatch;
	}
	// 830EFDE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EFDEC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EFDF0: 9AC1007D  stb r22, 0x7d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(125 as u32), ctx.r[22].u8 ) };
	// 830EFDF4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830EFDF8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830EFDFC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830EFE00: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830EFE04: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EFE08: 386BA6C4  addi r3, r11, -0x593c
	ctx.r[3].s64 = ctx.r[11].s64 + -22844;
	// 830EFE0C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830EFE10: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830EFE14: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830EFE18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EFE1C: 4BBBCD35  bl 0x82cacb50
	ctx.lr = 0x830EFE20;
	sub_82CACB50(ctx, base);
	// 830EFE20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EFE24: 40820220  bne 0x830f0044
	if !ctx.cr[0].eq {
	pc = 0x830F0044; continue 'dispatch;
	}
	// 830EFE28: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EFE2C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EFE30: 41990214  bgt cr6, 0x830f0044
	if ctx.cr[6].gt {
	pc = 0x830F0044; continue 'dispatch;
	}
	// 830EFE34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFE38: 3B170008  addi r24, r23, 8
	ctx.r[24].s64 = ctx.r[23].s64 + 8;
	// 830EFE3C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830EFE40: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830EFE44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFE48: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830EFE4C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFE54: 4E800421  bctrl
	ctx.lr = 0x830EFE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFE58: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830EFE5C: 409A01E8  bne cr6, 0x830f0044
	if !ctx.cr[6].eq {
	pc = 0x830F0044; continue 'dispatch;
	}
	// 830EFE60: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFE64: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830EFE68: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830EFE6C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830EFE70: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830EFE74: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830EFE78: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830EFE7C: 7D7E5379  or. r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EFE80: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830EFE84: 418201A0  beq 0x830f0024
	if ctx.cr[0].eq {
	pc = 0x830F0024; continue 'dispatch;
	}
	// 830EFE88: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 830EFE8C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFE90: 4082000C  bne 0x830efe9c
	if !ctx.cr[0].eq {
	pc = 0x830EFE9C; continue 'dispatch;
	}
	// 830EFE94: 4B1FA325  bl 0x822ea1b8
	ctx.lr = 0x830EFE98;
	sub_822EA1B8(ctx, base);
	// 830EFE98: 48000034  b 0x830efecc
	pc = 0x830EFECC; continue 'dispatch;
            }
            0x830EFE9C => {
    //   block [0x830EFE9C..0x830EFEB4)
	// 830EFE9C: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 830EFEA0: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830EFEA4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EFEA8: 57CB2036  slwi r11, r30, 4
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EFEAC: 40990008  ble cr6, 0x830efeb4
	if !ctx.cr[6].gt {
	pc = 0x830EFEB4; continue 'dispatch;
	}
	// 830EFEB0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830EFEB4; continue 'dispatch;
            }
            0x830EFEB4 => {
    //   block [0x830EFEB4..0x830EFEC8)
	// 830EFEB4: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 830EFEB8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830EFEBC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EFEC0: 40990008  ble cr6, 0x830efec8
	if !ctx.cr[6].gt {
	pc = 0x830EFEC8; continue 'dispatch;
	}
	// 830EFEC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x830EFEC8; continue 'dispatch;
            }
            0x830EFEC8 => {
    //   block [0x830EFEC8..0x830EFECC)
	// 830EFEC8: 4B526A61  bl 0x82616928
	ctx.lr = 0x830EFECC;
	sub_82616928(ctx, base);
	pc = 0x830EFECC; continue 'dispatch;
            }
            0x830EFECC => {
    //   block [0x830EFECC..0x830EFEF0)
	// 830EFECC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EFED0: 419A0044  beq cr6, 0x830eff14
	if ctx.cr[6].eq {
	pc = 0x830EFF14; continue 'dispatch;
	}
	// 830EFED4: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 830EFED8: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830EFEDC: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EFEE0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 830EFEE4: 41800028  blt 0x830eff0c
	if ctx.cr[0].lt {
	pc = 0x830EFF0C; continue 'dispatch;
	}
	// 830EFEE8: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830EFEEC: 3929A6EC  addi r9, r9, -0x5914
	ctx.r[9].s64 = ctx.r[9].s64 + -22804;
	pc = 0x830EFEF0; continue 'dispatch;
            }
            0x830EFEF0 => {
    //   block [0x830EFEF0..0x830EFF0C)
	// 830EFEF0: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830EFEF4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EFEF8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EFEFC: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 830EFF00: 92CB000C  stw r22, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 830EFF04: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830EFF08: 4080FFE8  bge 0x830efef0
	if !ctx.cr[0].lt {
	pc = 0x830EFEF0; continue 'dispatch;
	}
	pc = 0x830EFF0C; continue 'dispatch;
            }
            0x830EFF0C => {
    //   block [0x830EFF0C..0x830EFF14)
	// 830EFF0C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 830EFF10: 48000008  b 0x830eff18
	pc = 0x830EFF18; continue 'dispatch;
            }
            0x830EFF14 => {
    //   block [0x830EFF14..0x830EFF18)
	// 830EFF14: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x830EFF18; continue 'dispatch;
            }
            0x830EFF18 => {
    //   block [0x830EFF18..0x830EFF30)
	// 830EFF18: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFF1C: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 830EFF20: 91770004  stw r11, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EFF24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EFF28: 409900FC  ble cr6, 0x830f0024
	if !ctx.cr[6].gt {
	pc = 0x830F0024; continue 'dispatch;
	}
	// 830EFF2C: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	pc = 0x830EFF30; continue 'dispatch;
            }
            0x830EFF30 => {
    //   block [0x830EFF30..0x830EFFF0)
	// 830EFF30: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFF34: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830EFF38: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFF3C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830EFF40: 7F9B5A14  add r28, r27, r11
	ctx.r[28].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 830EFF44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFF48: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 830EFF4C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFF50: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EFF54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFF58: 4E800421  bctrl
	ctx.lr = 0x830EFF5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFF5C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830EFF60: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830EFF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFF68: 409A00E4  bne cr6, 0x830f004c
	if !ctx.cr[6].eq {
	pc = 0x830F004C; continue 'dispatch;
	}
	// 830EFF6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFF70: 3BBC0008  addi r29, r28, 8
	ctx.r[29].s64 = ctx.r[28].s64 + 8;
	// 830EFF74: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830EFF78: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830EFF7C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830EFF80: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830EFF84: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830EFF88: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830EFF8C: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830EFF90: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EFF94: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830EFF98: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EFF9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFFA0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFFA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EFFA8: 4E800421  bctrl
	ctx.lr = 0x830EFFAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EFFAC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830EFFB0: 409A0094  bne cr6, 0x830f0044
	if !ctx.cr[6].eq {
	pc = 0x830F0044; continue 'dispatch;
	}
	// 830EFFB4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFFB8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 830EFFBC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830EFFC0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830EFFC4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830EFFC8: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830EFFCC: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830EFFD0: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830EFFD4: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830EFFD8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EFFDC: 4B52694D  bl 0x82616928
	ctx.lr = 0x830EFFE0;
	sub_82616928(ctx, base);
	// 830EFFE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFFE4: 4182000C  beq 0x830efff0
	if ctx.cr[0].eq {
	pc = 0x830EFFF0; continue 'dispatch;
	}
	// 830EFFE8: 48000D81  bl 0x830f0d68
	ctx.lr = 0x830EFFEC;
	sub_830F0D68(ctx, base);
	// 830EFFEC: 48000008  b 0x830efff4
	pc = 0x830EFFF4; continue 'dispatch;
            }
            0x830EFFF0 => {
    //   block [0x830EFFF0..0x830EFFF4)
	// 830EFFF0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	pc = 0x830EFFF4; continue 'dispatch;
            }
            0x830EFFF4 => {
    //   block [0x830EFFF4..0x830F0024)
	// 830EFFF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EFFF8: 907C000C  stw r3, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 830EFFFC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F0000: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F0004: 48001145  bl 0x830f1148
	ctx.lr = 0x830F0008;
	sub_830F1148(ctx, base);
	// 830F0008: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F000C: 41820038  beq 0x830f0044
	if ctx.cr[0].eq {
	pc = 0x830F0044; continue 'dispatch;
	}
	// 830F0010: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0014: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830F0018: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 830F001C: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F0020: 4198FF10  blt cr6, 0x830eff30
	if ctx.cr[6].lt {
	pc = 0x830EFF30; continue 'dispatch;
	}
	pc = 0x830F0024; continue 'dispatch;
            }
            0x830F0024 => {
    //   block [0x830F0024..0x830F0044)
	// 830F0024: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0028: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F002C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0030: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F0034: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0038: 4E800421  bctrl
	ctx.lr = 0x830F003C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F003C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F0040: 48000020  b 0x830f0060
	pc = 0x830F0060; continue 'dispatch;
            }
            0x830F0044 => {
    //   block [0x830F0044..0x830F004C)
	// 830F0044: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F0048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F004C; continue 'dispatch;
            }
            0x830F004C => {
    //   block [0x830F004C..0x830F005C)
	// 830F004C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0050: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F0054: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0058: 4E800421  bctrl
	ctx.lr = 0x830F005C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F005C => {
    //   block [0x830F005C..0x830F0060)
	// 830F005C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F0060; continue 'dispatch;
            }
            0x830F0060 => {
    //   block [0x830F0060..0x830F0068)
	// 830F0060: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830F0064: 4BBB93DC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0068 size=192
    let mut pc: u32 = 0x830F0068;
    'dispatch: loop {
        match pc {
            0x830F0068 => {
    //   block [0x830F0068..0x830F00D0)
	// 830F0068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F006C: 4BBB9395  bl 0x82ca9400
	ctx.lr = 0x830F0070;
	sub_82CA93D0(ctx, base);
	// 830F0070: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0074: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830F0078: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 830F007C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F0080: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830F0084: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F0088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F008C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830F0090: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 830F0094: 4BFFFAA5  bl 0x830efb38
	ctx.lr = 0x830F0098;
	sub_830EFB38(ctx, base);
	// 830F0098: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F009C: 40820054  bne 0x830f00f0
	if !ctx.cr[0].eq {
	pc = 0x830F00F0; continue 'dispatch;
	}
	// 830F00A0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F00A4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F00A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F00AC: 4BFFFA8D  bl 0x830efb38
	ctx.lr = 0x830F00B0;
	sub_830EFB38(ctx, base);
	// 830F00B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F00B4: 41820068  beq 0x830f011c
	if ctx.cr[0].eq {
	pc = 0x830F011C; continue 'dispatch;
	}
	// 830F00B8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830F00BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F00C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F00C4: 48000E8D  bl 0x830f0f50
	ctx.lr = 0x830F00C8;
	sub_830F0F50(ctx, base);
	// 830F00C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F00CC: 4082000C  bne 0x830f00d8
	if !ctx.cr[0].eq {
	pc = 0x830F00D8; continue 'dispatch;
	}
	pc = 0x830F00D0; continue 'dispatch;
            }
            0x830F00D0 => {
    //   block [0x830F00D0..0x830F00D8)
	// 830F00D0: 3860FFFE  li r3, -2
	ctx.r[3].s64 = -2;
	// 830F00D4: 4800004C  b 0x830f0120
	pc = 0x830F0120; continue 'dispatch;
            }
            0x830F00D8 => {
    //   block [0x830F00D8..0x830F00E0)
	// 830F00D8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F00DC: 409A000C  bne cr6, 0x830f00e8
	if !ctx.cr[6].eq {
	pc = 0x830F00E8; continue 'dispatch;
	}
	pc = 0x830F00E0; continue 'dispatch;
            }
            0x830F00E0 => {
    //   block [0x830F00E0..0x830F00E8)
	// 830F00E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F00E4: 4800003C  b 0x830f0120
	pc = 0x830F0120; continue 'dispatch;
            }
            0x830F00E8 => {
    //   block [0x830F00E8..0x830F00F0)
	// 830F00E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F00EC: 48000028  b 0x830f0114
	pc = 0x830F0114; continue 'dispatch;
            }
            0x830F00F0 => {
    //   block [0x830F00F0..0x830F0114)
	// 830F00F0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830F00F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F00F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F00FC: 48000E55  bl 0x830f0f50
	ctx.lr = 0x830F0100;
	sub_830F0F50(ctx, base);
	// 830F0100: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F0104: 4182FFCC  beq 0x830f00d0
	if ctx.cr[0].eq {
	pc = 0x830F00D0; continue 'dispatch;
	}
	// 830F0108: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F010C: 419AFFD4  beq cr6, 0x830f00e0
	if ctx.cr[6].eq {
	pc = 0x830F00E0; continue 'dispatch;
	}
	// 830F0110: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	pc = 0x830F0114; continue 'dispatch;
            }
            0x830F0114 => {
    //   block [0x830F0114..0x830F011C)
	// 830F0114: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830F0118: 419A0008  beq cr6, 0x830f0120
	if ctx.cr[6].eq {
	pc = 0x830F0120; continue 'dispatch;
	}
	pc = 0x830F011C; continue 'dispatch;
            }
            0x830F011C => {
    //   block [0x830F011C..0x830F0120)
	// 830F011C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x830F0120; continue 'dispatch;
            }
            0x830F0120 => {
    //   block [0x830F0120..0x830F0128)
	// 830F0120: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F0124: 4BBB932C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0128 size=88
    let mut pc: u32 = 0x830F0128;
    'dispatch: loop {
        match pc {
            0x830F0128 => {
    //   block [0x830F0128..0x830F0164)
	// 830F0128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F012C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F0134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F013C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0140: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F0144: 4BFFFB1D  bl 0x830efc60
	ctx.lr = 0x830F0148;
	sub_830EFC60(ctx, base);
	// 830F0148: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F014C: 41820018  beq 0x830f0164
	if ctx.cr[0].eq {
	pc = 0x830F0164; continue 'dispatch;
	}
	// 830F0150: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F0154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0158: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F015C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0160: 4E800421  bctrl
	ctx.lr = 0x830F0164;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F0164 => {
    //   block [0x830F0164..0x830F0180)
	// 830F0164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0168: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F016C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0170: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0174: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F0178: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F017C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0180 size=212
    let mut pc: u32 = 0x830F0180;
    'dispatch: loop {
        match pc {
            0x830F0180 => {
    //   block [0x830F0180..0x830F01DC)
	// 830F0180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0184: 4BBB9281  bl 0x82ca9404
	ctx.lr = 0x830F0188;
	sub_82CA93D0(ctx, base);
	// 830F0188: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 830F018C: 9421EF50  stwu r1, -0x10b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-4272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0190: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 830F0194: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F0198: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F019C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F01A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F01A4: 38A01000  li r5, 0x1000
	ctx.r[5].s64 = 4096;
	// 830F01A8: 837FFEF0  lwz r27, -0x110(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-272 as u32) ) } as u64;
	// 830F01AC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830F01B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F01B4: 4BD95175  bl 0x82e85328
	ctx.lr = 0x830F01B8;
	sub_82E85328(ctx, base);
	// 830F01B8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830F01BC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 830F01C0: 917FFEF0  stw r11, -0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-272 as u32), ctx.r[11].u32 ) };
	// 830F01C4: 4B526765  bl 0x82616928
	ctx.lr = 0x830F01C8;
	sub_82616928(ctx, base);
	// 830F01C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F01CC: 41820010  beq 0x830f01dc
	if ctx.cr[0].eq {
	pc = 0x830F01DC; continue 'dispatch;
	}
	// 830F01D0: 4BD94039  bl 0x82e84208
	ctx.lr = 0x830F01D4;
	sub_82E84208(ctx, base);
	// 830F01D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F01D8: 48000008  b 0x830f01e0
	pc = 0x830F01E0; continue 'dispatch;
            }
            0x830F01DC => {
    //   block [0x830F01DC..0x830F01E0)
	// 830F01DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830F01E0; continue 'dispatch;
            }
            0x830F01E0 => {
    //   block [0x830F01E0..0x830F0254)
	// 830F01E0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 830F01E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F01E8: 388B4DAC  addi r4, r11, 0x4dac
	ctx.r[4].s64 = ctx.r[11].s64 + 19884;
	// 830F01EC: 4BD93F45  bl 0x82e84130
	ctx.lr = 0x830F01F0;
	sub_82E84130(ctx, base);
	// 830F01F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F01F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F01F8: 4BD93F71  bl 0x82e84168
	ctx.lr = 0x830F01FC;
	sub_82E84168(ctx, base);
	// 830F01FC: 937FFEF0  stw r27, -0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-272 as u32), ctx.r[27].u32 ) };
	// 830F0200: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 830F0204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F0208: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 830F020C: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F0210: 4BD99B39  bl 0x82e89d48
	ctx.lr = 0x830F0214;
	sub_82E89D48(ctx, base);
	// 830F0214: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 830F0218: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830F021C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F0220: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F0224: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830F0228: 4BFFFB21  bl 0x830efd48
	ctx.lr = 0x830F022C;
	sub_830EFD48(ctx, base);
	// 830F022C: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 830F0230: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F0234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F0238: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830F023C: 4BD99B1D  bl 0x82e89d58
	ctx.lr = 0x830F0240;
	sub_82E89D58(ctx, base);
	// 830F0240: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F0244: 4BD94AC5  bl 0x82e84d08
	ctx.lr = 0x830F0248;
	sub_82E84D08(ctx, base);
	// 830F0248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F024C: 382110B0  addi r1, r1, 0x10b0
	ctx.r[1].s64 = ctx.r[1].s64 + 4272;
	// 830F0250: 4BBB9204  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F0258 size=108
    let mut pc: u32 = 0x830F0258;
    'dispatch: loop {
        match pc {
            0x830F0258 => {
    //   block [0x830F0258..0x830F02BC)
	// 830F0258: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F025C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F0260: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F0264: 409A0058  bne cr6, 0x830f02bc
	if !ctx.cr[6].eq {
	pc = 0x830F02BC; continue 'dispatch;
	}
	// 830F0268: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F026C: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0270: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F0274: 409A0048  bne cr6, 0x830f02bc
	if !ctx.cr[6].eq {
	pc = 0x830F02BC; continue 'dispatch;
	}
	// 830F0278: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F027C: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0280: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F0284: 409A0038  bne cr6, 0x830f02bc
	if !ctx.cr[6].eq {
	pc = 0x830F02BC; continue 'dispatch;
	}
	// 830F0288: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F028C: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F0290: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F0294: 409A0028  bne cr6, 0x830f02bc
	if !ctx.cr[6].eq {
	pc = 0x830F02BC; continue 'dispatch;
	}
	// 830F0298: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F029C: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F02A0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F02A4: 409A0018  bne cr6, 0x830f02bc
	if !ctx.cr[6].eq {
	pc = 0x830F02BC; continue 'dispatch;
	}
	// 830F02A8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F02AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F02B0: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F02B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F02B8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x830F02BC; continue 'dispatch;
            }
            0x830F02BC => {
    //   block [0x830F02BC..0x830F02C4)
	// 830F02BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F02C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F02C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F02C8 size=80
    let mut pc: u32 = 0x830F02C8;
    'dispatch: loop {
        match pc {
            0x830F02C8 => {
    //   block [0x830F02C8..0x830F0304)
	// 830F02C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F02CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F02D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F02D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F02D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F02DC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F02E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F02E4: 41820020  beq 0x830f0304
	if ctx.cr[0].eq {
	pc = 0x830F0304; continue 'dispatch;
	}
	// 830F02E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F02EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F02F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F02F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F02F8: 4E800421  bctrl
	ctx.lr = 0x830F02FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F02FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F0300: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
            }
            0x830F0304 => {
    //   block [0x830F0304..0x830F0318)
	// 830F0304: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F0308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F030C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F0318 size=20
    let mut pc: u32 = 0x830F0318;
    'dispatch: loop {
        match pc {
            0x830F0318 => {
    //   block [0x830F0318..0x830F032C)
	// 830F0318: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F031C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F0320: 4082000C  bne 0x830f032c
	if !ctx.cr[0].eq {
		sub_830F032C(ctx, base);
		return;
	}
	// 830F0324: 386000FF  li r3, 0xff
	ctx.r[3].s64 = 255;
	// 830F0328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F032C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830F032C size=116
    let mut pc: u32 = 0x830F032C;
    'dispatch: loop {
        match pc {
            0x830F032C => {
    //   block [0x830F032C..0x830F0334)
	// 830F032C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F0330: 48000048  b 0x830f0378
	pc = 0x830F0378; continue 'dispatch;
            }
            0x830F0334 => {
    //   block [0x830F0334..0x830F034C)
	// 830F0334: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F0338: 41820020  beq 0x830f0358
	if ctx.cr[0].eq {
	pc = 0x830F0358; continue 'dispatch;
	}
	// 830F033C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F0340: 409A000C  bne cr6, 0x830f034c
	if !ctx.cr[6].eq {
	pc = 0x830F034C; continue 'dispatch;
	}
	// 830F0344: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 830F0348: 48000014  b 0x830f035c
	pc = 0x830F035C; continue 'dispatch;
            }
            0x830F034C => {
    //   block [0x830F034C..0x830F0358)
	// 830F034C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830F0350: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 830F0354: 419A0008  beq cr6, 0x830f035c
	if ctx.cr[6].eq {
	pc = 0x830F035C; continue 'dispatch;
	}
	pc = 0x830F0358; continue 'dispatch;
            }
            0x830F0358 => {
    //   block [0x830F0358..0x830F035C)
	// 830F0358: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x830F035C; continue 'dispatch;
            }
            0x830F035C => {
    //   block [0x830F035C..0x830F0374)
	// 830F035C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0360: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F0364: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F0368: 4199000C  bgt cr6, 0x830f0374
	if ctx.cr[6].gt {
	pc = 0x830F0374; continue 'dispatch;
	}
	// 830F036C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0370: 48000008  b 0x830f0378
	pc = 0x830F0378; continue 'dispatch;
            }
            0x830F0374 => {
    //   block [0x830F0374..0x830F0378)
	// 830F0374: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x830F0378; continue 'dispatch;
            }
            0x830F0378 => {
    //   block [0x830F0378..0x830F03A0)
	// 830F0378: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F037C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830F0380: 4198FFB4  blt cr6, 0x830f0334
	if ctx.cr[6].lt {
	pc = 0x830F0334; continue 'dispatch;
	}
	// 830F0384: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F0388: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 830F038C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F0390: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F0394: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830F0398: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 830F039C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F03A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F03A0 size=128
    let mut pc: u32 = 0x830F03A0;
    'dispatch: loop {
        match pc {
            0x830F03A0 => {
    //   block [0x830F03A0..0x830F03E0)
	// 830F03A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F03A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F03A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F03AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F03B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F03B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F03B8: 396BA700  addi r11, r11, -0x5900
	ctx.r[11].s64 = ctx.r[11].s64 + -22784;
	// 830F03BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F03C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F03C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F03C8: 41820018  beq 0x830f03e0
	if ctx.cr[0].eq {
	pc = 0x830F03E0; continue 'dispatch;
	}
	// 830F03CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F03D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F03D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F03D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F03DC: 4E800421  bctrl
	ctx.lr = 0x830F03E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F03E0 => {
    //   block [0x830F03E0..0x830F0400)
	// 830F03E0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F03E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F03E8: 41820018  beq 0x830f0400
	if ctx.cr[0].eq {
	pc = 0x830F0400; continue 'dispatch;
	}
	// 830F03EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F03F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F03F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F03F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F03FC: 4E800421  bctrl
	ctx.lr = 0x830F0400;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F0400 => {
    //   block [0x830F0400..0x830F0420)
	// 830F0400: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830F0404: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830F0408: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F040C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F0410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F041C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0420 size=116
    let mut pc: u32 = 0x830F0420;
    'dispatch: loop {
        match pc {
            0x830F0420 => {
    //   block [0x830F0420..0x830F0448)
	// 830F0420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0424: 4BBB8FE5  bl 0x82ca9408
	ctx.lr = 0x830F0428;
	sub_82CA93D0(ctx, base);
	// 830F0428: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F042C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0430: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F0434: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F0438: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F043C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F0440: 40990040  ble cr6, 0x830f0480
	if !ctx.cr[6].gt {
	pc = 0x830F0480; continue 'dispatch;
	}
	// 830F0444: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830F0448; continue 'dispatch;
            }
            0x830F0448 => {
    //   block [0x830F0448..0x830F0480)
	// 830F0448: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F044C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F0450: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F0454: 7CABF02E  lwzx r5, r11, r30
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F0458: 7C8AF02E  lwzx r4, r10, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F045C: 4B19846D  bl 0x822888c8
	ctx.lr = 0x830F0460;
	sub_822888C8(ctx, base);
	// 830F0460: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830F0464: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F0468: 419A0024  beq cr6, 0x830f048c
	if ctx.cr[6].eq {
	pc = 0x830F048C; continue 'dispatch;
	}
	// 830F046C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F0470: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F0474: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F0478: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F047C: 4198FFCC  blt cr6, 0x830f0448
	if ctx.cr[6].lt {
	pc = 0x830F0448; continue 'dispatch;
	}
	pc = 0x830F0480; continue 'dispatch;
            }
            0x830F0480 => {
    //   block [0x830F0480..0x830F0484)
	// 830F0480: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F0484; continue 'dispatch;
            }
            0x830F0484 => {
    //   block [0x830F0484..0x830F048C)
	// 830F0484: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F0488: 4BBB8FD0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x830F048C => {
    //   block [0x830F048C..0x830F0494)
	// 830F048C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F0490: 4BFFFFF4  b 0x830f0484
	pc = 0x830F0484; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0498 size=196
    let mut pc: u32 = 0x830F0498;
    'dispatch: loop {
        match pc {
            0x830F0498 => {
    //   block [0x830F0498..0x830F04E8)
	// 830F0498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F049C: 4BBB8F69  bl 0x82ca9404
	ctx.lr = 0x830F04A0;
	sub_82CA93D0(ctx, base);
	// 830F04A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F04A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F04A8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830F04AC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830F04B0: 3F808330  lis r28, -0x7cd0
	ctx.r[28].s64 = -2094006272;
	// 830F04B4: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F04B8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F04BC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F04C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F04C4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F04C8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830F04CC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830F04D0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830F04D4: 41820014  beq 0x830f04e8
	if ctx.cr[0].eq {
	pc = 0x830F04E8; continue 'dispatch;
	}
	// 830F04D8: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F04DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F04E0: 4E800421  bctrl
	ctx.lr = 0x830F04E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F04E4: 937F0020  stw r27, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
            }
            0x830F04E8 => {
    //   block [0x830F04E8..0x830F0508)
	// 830F04E8: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F04EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F04F0: 419A0060  beq cr6, 0x830f0550
	if ctx.cr[6].eq {
	pc = 0x830F0550; continue 'dispatch;
	}
	// 830F04F4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F04F8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830F04FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F0500: 4099003C  ble cr6, 0x830f053c
	if !ctx.cr[6].gt {
	pc = 0x830F053C; continue 'dispatch;
	}
	// 830F0504: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x830F0508; continue 'dispatch;
            }
            0x830F0508 => {
    //   block [0x830F0508..0x830F0528)
	// 830F0508: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F050C: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F0510: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F0514: 419A0014  beq cr6, 0x830f0528
	if ctx.cr[6].eq {
	pc = 0x830F0528; continue 'dispatch;
	}
	// 830F0518: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F051C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830F0520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0524: 4E800421  bctrl
	ctx.lr = 0x830F0528;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F0528 => {
    //   block [0x830F0528..0x830F053C)
	// 830F0528: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F052C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F0530: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F0534: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F0538: 4198FFD0  blt cr6, 0x830f0508
	if ctx.cr[6].lt {
	pc = 0x830F0508; continue 'dispatch;
	}
	pc = 0x830F053C; continue 'dispatch;
            }
            0x830F053C => {
    //   block [0x830F053C..0x830F0550)
	// 830F053C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F0540: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F0544: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0548: 4E800421  bctrl
	ctx.lr = 0x830F054C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F054C: 937F0024  stw r27, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[27].u32 ) };
            }
            0x830F0550 => {
    //   block [0x830F0550..0x830F055C)
	// 830F0550: 937F001C  stw r27, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 830F0554: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F0558: 4BBB8EFC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F0560 size=1340
    let mut pc: u32 = 0x830F0560;
    'dispatch: loop {
        match pc {
            0x830F0560 => {
    //   block [0x830F0560..0x830F05AC)
	// 830F0560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0564: 4BBB8E8D  bl 0x82ca93f0
	ctx.lr = 0x830F0568;
	sub_82CA93D0(ctx, base);
	// 830F0568: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 830F056C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0574: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830F0578: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F057C: 4BFFFF1D  bl 0x830f0498
	ctx.lr = 0x830F0580;
	sub_830F0498(ctx, base);
	// 830F0580: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0584: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 830F0588: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F058C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F0590: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0594: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F0598: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F059C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F05A0: 4E800421  bctrl
	ctx.lr = 0x830F05A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F05A4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F05A8: 419A000C  beq cr6, 0x830f05b4
	if ctx.cr[6].eq {
	pc = 0x830F05B4; continue 'dispatch;
	}
            }
            0x830F05AC => {
    //   block [0x830F05AC..0x830F05B4)
	// 830F05AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F05B0: 480004E0  b 0x830f0a90
	pc = 0x830F0A90; continue 'dispatch;
            }
            0x830F05B4 => {
    //   block [0x830F05B4..0x830F07CC)
	// 830F05B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F05B8: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 830F05BC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F05C0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F05C4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F05C8: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F05CC: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F05D0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F05D4: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F05D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F05DC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830F05E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F05E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F05E8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F05EC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F05F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F05F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F05F8: 4E800421  bctrl
	ctx.lr = 0x830F05FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F05FC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0600: 409AFFAC  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F0604: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0608: 3B9F000C  addi r28, r31, 0xc
	ctx.r[28].s64 = ctx.r[31].s64 + 12;
	// 830F060C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0610: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F0614: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F0618: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F061C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0620: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F0624: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F0628: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F062C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830F0630: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0634: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F0638: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F063C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0640: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0644: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0648: 4E800421  bctrl
	ctx.lr = 0x830F064C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F064C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0650: 409AFF5C  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F0654: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0658: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 830F065C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0660: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F0664: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F0668: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F066C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0670: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F0674: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F0678: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F067C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830F0680: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0684: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F0688: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F068C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0690: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0694: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0698: 4E800421  bctrl
	ctx.lr = 0x830F069C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F069C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F06A0: 409AFF0C  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F06A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F06A8: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 830F06AC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F06B0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F06B4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F06B8: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F06BC: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F06C0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F06C4: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F06C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F06CC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830F06D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F06D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F06D8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F06DC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F06E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F06E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F06E8: 4E800421  bctrl
	ctx.lr = 0x830F06EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F06EC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F06F0: 409AFEBC  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F06F4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F06F8: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 830F06FC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0700: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F0704: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F0708: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F070C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0710: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F0714: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F0718: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F071C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830F0720: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0724: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F0728: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F072C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0730: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0734: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0738: 4E800421  bctrl
	ctx.lr = 0x830F073C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F073C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0740: 409AFE6C  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F0744: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0748: 3B3F001C  addi r25, r31, 0x1c
	ctx.r[25].s64 = ctx.r[31].s64 + 28;
	// 830F074C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0750: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F0754: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F0758: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F075C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0760: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F0764: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F0768: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F076C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830F0770: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0774: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830F0778: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F077C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0780: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0788: 4E800421  bctrl
	ctx.lr = 0x830F078C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F078C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0790: 409AFE1C  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F0794: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0798: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F079C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F07A0: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F07A4: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F07A8: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F07AC: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F07B0: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F07B4: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F07B8: 40820014  bne 0x830f07cc
	if !ctx.cr[0].eq {
	pc = 0x830F07CC; continue 'dispatch;
	}
	// 830F07BC: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830F07C0: 92FF0020  stw r23, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[23].u32 ) };
	// 830F07C4: 92FF0024  stw r23, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[23].u32 ) };
	// 830F07C8: 480002C4  b 0x830f0a8c
	pc = 0x830F0A8C; continue 'dispatch;
            }
            0x830F07CC => {
    //   block [0x830F07CC..0x830F07E8)
	// 830F07CC: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 830F07D0: 3AC0FFFF  li r22, -1
	ctx.r[22].s64 = -1;
	// 830F07D4: 615AFFFF  ori r26, r10, 0xffff
	ctx.r[26].u64 = ctx.r[10].u64 | 65535;
	// 830F07D8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830F07DC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830F07E0: 40990008  ble cr6, 0x830f07e8
	if !ctx.cr[6].gt {
	pc = 0x830F07E8; continue 'dispatch;
	}
	// 830F07E4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	pc = 0x830F07E8; continue 'dispatch;
            }
            0x830F07E8 => {
    //   block [0x830F07E8..0x830F0808)
	// 830F07E8: 4B526141  bl 0x82616928
	ctx.lr = 0x830F07EC;
	sub_82616928(ctx, base);
	// 830F07EC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F07F0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830F07F4: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 830F07F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F07FC: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 830F0800: 40990074  ble cr6, 0x830f0874
	if !ctx.cr[6].gt {
	pc = 0x830F0874; continue 'dispatch;
	}
	// 830F0804: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	pc = 0x830F0808; continue 'dispatch;
            }
            0x830F0808 => {
    //   block [0x830F0808..0x830F0874)
	// 830F0808: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F080C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0810: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F0814: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F0818: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F081C: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830F0820: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0824: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0828: 4E800421  bctrl
	ctx.lr = 0x830F082C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F082C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0830: 409AFD7C  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F0834: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F0838: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830F083C: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830F0840: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F0844: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0848: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F084C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830F0850: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0854: 5168843E  rlwimi r8, r11, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 830F0858: 552B401E  rlwinm r11, r9, 8, 0, 0xf
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F085C: 5509C43E  rlwinm r9, r8, 0x18, 0x10, 0x1f
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 830F0860: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 830F0864: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0868: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F086C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F0870: 4198FF98  blt cr6, 0x830f0808
	if ctx.cr[6].lt {
	pc = 0x830F0808; continue 'dispatch;
	}
            }
            0x830F0874 => {
    //   block [0x830F0874..0x830F0888)
	// 830F0874: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0878: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830F087C: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830F0880: 40990008  ble cr6, 0x830f0888
	if !ctx.cr[6].gt {
	pc = 0x830F0888; continue 'dispatch;
	}
	// 830F0884: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	pc = 0x830F0888; continue 'dispatch;
            }
            0x830F0888 => {
    //   block [0x830F0888..0x830F08AC)
	// 830F0888: 4B5260A1  bl 0x82616928
	ctx.lr = 0x830F088C;
	sub_82616928(ctx, base);
	// 830F088C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0890: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 830F0894: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 830F0898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F089C: 409901F0  ble cr6, 0x830f0a8c
	if !ctx.cr[6].gt {
	pc = 0x830F0A8C; continue 'dispatch;
	}
	// 830F08A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F08A4: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 830F08A8: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x830F08AC; continue 'dispatch;
            }
            0x830F08AC => {
    //   block [0x830F08AC..0x830F08C8)
	// 830F08AC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F08B0: 7FCBE02E  lwzx r30, r11, r28
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F08B4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F08B8: 40820010  bne 0x830f08c8
	if !ctx.cr[0].eq {
	pc = 0x830F08C8; continue 'dispatch;
	}
	// 830F08BC: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F08C0: 7EEBE12E  stwx r23, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[23].u32) };
	// 830F08C4: 480001B4  b 0x830f0a78
	pc = 0x830F0A78; continue 'dispatch;
            }
            0x830F08C8 => {
    //   block [0x830F08C8..0x830F08E0)
	// 830F08C8: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 830F08CC: 1C7E000C  mulli r3, r30, 0xc
	ctx.r[3].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 830F08D0: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 830F08D4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F08D8: 40990008  ble cr6, 0x830f08e0
	if !ctx.cr[6].gt {
	pc = 0x830F08E0; continue 'dispatch;
	}
	// 830F08DC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	pc = 0x830F08E0; continue 'dispatch;
            }
            0x830F08E0 => {
    //   block [0x830F08E0..0x830F08F8)
	// 830F08E0: 4B526049  bl 0x82616928
	ctx.lr = 0x830F08E4;
	sub_82616928(ctx, base);
	// 830F08E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F08E8: 41820030  beq 0x830f0918
	if ctx.cr[0].eq {
	pc = 0x830F0918; continue 'dispatch;
	}
	// 830F08EC: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F08F0: 41800020  blt 0x830f0910
	if ctx.cr[0].lt {
	pc = 0x830F0910; continue 'dispatch;
	}
	// 830F08F4: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x830F08F8; continue 'dispatch;
            }
            0x830F08F8 => {
    //   block [0x830F08F8..0x830F0910)
	// 830F08F8: D3EBFFF8  stfs f31, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 830F08FC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F0900: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830F0904: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830F0908: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 830F090C: 4080FFEC  bge 0x830f08f8
	if !ctx.cr[0].lt {
	pc = 0x830F08F8; continue 'dispatch;
	}
	pc = 0x830F0910; continue 'dispatch;
            }
            0x830F0910 => {
    //   block [0x830F0910..0x830F0918)
	// 830F0910: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830F0914: 48000008  b 0x830f091c
	pc = 0x830F091C; continue 'dispatch;
            }
            0x830F0918 => {
    //   block [0x830F0918..0x830F091C)
	// 830F0918: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x830F091C; continue 'dispatch;
            }
            0x830F091C => {
    //   block [0x830F091C..0x830F093C)
	// 830F091C: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F0920: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 830F0924: 7D6AE12E  stwx r11, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u32) };
	// 830F0928: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F092C: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F0930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F0934: 40990144  ble cr6, 0x830f0a78
	if !ctx.cr[6].gt {
	pc = 0x830F0A78; continue 'dispatch;
	}
	// 830F0938: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	pc = 0x830F093C; continue 'dispatch;
            }
            0x830F093C => {
    //   block [0x830F093C..0x830F0A78)
	// 830F093C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F0940: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0944: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0948: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F094C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0950: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F0954: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0958: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F095C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F0960: 4E800421  bctrl
	ctx.lr = 0x830F0964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F0964: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0968: 409AFC44  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F096C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F0970: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0974: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F0978: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F097C: 7D4BE02E  lwzx r10, r11, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F0980: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F0984: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F0988: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830F098C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 830F0990: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0994: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 830F0998: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 830F099C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 830F09A0: 7D6AF12E  stwx r11, r10, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 830F09A4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F09A8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F09AC: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F09B0: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F09B4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F09B8: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 830F09BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F09C0: 4E800421  bctrl
	ctx.lr = 0x830F09C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F09C4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F09C8: 409AFBE4  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F09CC: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F09D0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F09D4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F09D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F09DC: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F09E0: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F09E4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F09E8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F09EC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830F09F0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 830F09F4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 830F09F8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 830F09FC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 830F0A00: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 830F0A04: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F0A08: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F0A0C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0A10: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F0A14: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0A18: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F0A1C: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 830F0A20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F0A24: 4E800421  bctrl
	ctx.lr = 0x830F0A28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F0A28: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0A2C: 409AFB80  bne cr6, 0x830f05ac
	if !ctx.cr[6].eq {
	pc = 0x830F05AC; continue 'dispatch;
	}
	// 830F0A30: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F0A34: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 830F0A38: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F0A3C: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F0A40: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830F0A44: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0A48: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F0A4C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830F0A50: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 830F0A54: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0A58: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 830F0A5C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 830F0A60: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 830F0A64: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F0A68: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F0A6C: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830F0A70: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F0A74: 4198FEC8  blt cr6, 0x830f093c
	if ctx.cr[6].lt {
	pc = 0x830F093C; continue 'dispatch;
	}
            }
            0x830F0A78 => {
    //   block [0x830F0A78..0x830F0A8C)
	// 830F0A78: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0A7C: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830F0A80: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830F0A84: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F0A88: 4198FE24  blt cr6, 0x830f08ac
	if ctx.cr[6].lt {
	pc = 0x830F08AC; continue 'dispatch;
	}
	pc = 0x830F0A8C; continue 'dispatch;
            }
            0x830F0A8C => {
    //   block [0x830F0A8C..0x830F0A90)
	// 830F0A8C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830F0A90; continue 'dispatch;
            }
            0x830F0A90 => {
    //   block [0x830F0A90..0x830F0A9C)
	// 830F0A90: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F0A94: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 830F0A98: 4BBB89A8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0AA0 size=112
    let mut pc: u32 = 0x830F0AA0;
    'dispatch: loop {
        match pc {
            0x830F0AA0 => {
    //   block [0x830F0AA0..0x830F0ACC)
	// 830F0AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0AA4: 4BBB895D  bl 0x82ca9400
	ctx.lr = 0x830F0AA8;
	sub_82CA93D0(ctx, base);
	// 830F0AA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0AAC: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F0AB0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F0AB4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F0AB8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830F0ABC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F0AC0: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F0AC4: 41820030  beq 0x830f0af4
	if ctx.cr[0].eq {
	pc = 0x830F0AF4; continue 'dispatch;
	}
	// 830F0AC8: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830F0ACC; continue 'dispatch;
            }
            0x830F0ACC => {
    //   block [0x830F0ACC..0x830F0AF4)
	// 830F0ACC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F0AD0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F0AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0AD8: 4BFFF781  bl 0x830f0258
	ctx.lr = 0x830F0ADC;
	sub_830F0258(ctx, base);
	// 830F0ADC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F0AE0: 40820020  bne 0x830f0b00
	if !ctx.cr[0].eq {
	pc = 0x830F0B00; continue 'dispatch;
	}
	// 830F0AE4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F0AE8: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 830F0AEC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830F0AF0: 4198FFDC  blt cr6, 0x830f0acc
	if ctx.cr[6].lt {
	pc = 0x830F0ACC; continue 'dispatch;
	}
	pc = 0x830F0AF4; continue 'dispatch;
            }
            0x830F0AF4 => {
    //   block [0x830F0AF4..0x830F0AF8)
	// 830F0AF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F0AF8; continue 'dispatch;
            }
            0x830F0AF8 => {
    //   block [0x830F0AF8..0x830F0B00)
	// 830F0AF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F0AFC: 4BBB8954  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830F0B00 => {
    //   block [0x830F0B00..0x830F0B10)
	// 830F0B00: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F0B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0B08: 4BFFF919  bl 0x830f0420
	ctx.lr = 0x830F0B0C;
	sub_830F0420(ctx, base);
	// 830F0B0C: 4BFFFFEC  b 0x830f0af8
	pc = 0x830F0AF8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0B10 size=120
    let mut pc: u32 = 0x830F0B10;
    'dispatch: loop {
        match pc {
            0x830F0B10 => {
    //   block [0x830F0B10..0x830F0B64)
	// 830F0B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0B18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F0B1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0B20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0B24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0B28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F0B2C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0B30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F0B34: 41820038  beq 0x830f0b6c
	if ctx.cr[0].eq {
	pc = 0x830F0B6C; continue 'dispatch;
	}
	// 830F0B38: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830F0B3C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830F0B40: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F0B44: 419A0020  beq cr6, 0x830f0b64
	if ctx.cr[6].eq {
	pc = 0x830F0B64; continue 'dispatch;
	}
	// 830F0B48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0B4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F0B50: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830F0B54: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0B58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0B5C: 4E800421  bctrl
	ctx.lr = 0x830F0B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F0B60: 48000008  b 0x830f0b68
	pc = 0x830F0B68; continue 'dispatch;
            }
            0x830F0B64 => {
    //   block [0x830F0B64..0x830F0B68)
	// 830F0B64: 4B754C4D  bl 0x828457b0
	ctx.lr = 0x830F0B68;
	sub_828457B0(ctx, base);
	pc = 0x830F0B68; continue 'dispatch;
            }
            0x830F0B68 => {
    //   block [0x830F0B68..0x830F0B6C)
	// 830F0B68: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x830F0B6C; continue 'dispatch;
            }
            0x830F0B6C => {
    //   block [0x830F0B6C..0x830F0B88)
	// 830F0B6C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830F0B70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F0B74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0B78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0B7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F0B80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0B84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0B88 size=364
    let mut pc: u32 = 0x830F0B88;
    'dispatch: loop {
        match pc {
            0x830F0B88 => {
    //   block [0x830F0B88..0x830F0BD8)
	// 830F0B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0B8C: 4BBB8875  bl 0x82ca9400
	ctx.lr = 0x830F0B90;
	sub_82CA93D0(ctx, base);
	// 830F0B90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0B94: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F0B98: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F0B9C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830F0BA0: 4BFFFF71  bl 0x830f0b10
	ctx.lr = 0x830F0BA4;
	sub_830F0B10(ctx, base);
	// 830F0BA4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0BA8: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 830F0BAC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0BB0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F0BB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F0BB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F0BBC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0BC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0BC4: 4E800421  bctrl
	ctx.lr = 0x830F0BC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F0BC8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0BCC: 419A000C  beq cr6, 0x830f0bd8
	if ctx.cr[6].eq {
	pc = 0x830F0BD8; continue 'dispatch;
	}
	// 830F0BD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F0BD4: 48000118  b 0x830f0cec
	pc = 0x830F0CEC; continue 'dispatch;
            }
            0x830F0BD8 => {
    //   block [0x830F0BD8..0x830F0C0C)
	// 830F0BD8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0BDC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F0BE0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F0BE4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F0BE8: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0BEC: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F0BF0: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F0BF4: 7D7E5379  or. r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F0BF8: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830F0BFC: 40820010  bne 0x830f0c0c
	if !ctx.cr[0].eq {
	pc = 0x830F0C0C; continue 'dispatch;
	}
	// 830F0C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F0C04: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F0C08: 480000E0  b 0x830f0ce8
	pc = 0x830F0CE8; continue 'dispatch;
            }
            0x830F0C0C => {
    //   block [0x830F0C0C..0x830F0C28)
	// 830F0C0C: 3D600666  lis r11, 0x666
	ctx.r[11].s64 = 107347968;
	// 830F0C10: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F0C14: 616B6666  ori r11, r11, 0x6666
	ctx.r[11].u64 = ctx.r[11].u64 | 26214;
	// 830F0C18: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F0C1C: 1D7E0028  mulli r11, r30, 0x28
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 40 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830F0C20: 40990008  ble cr6, 0x830f0c28
	if !ctx.cr[6].gt {
	pc = 0x830F0C28; continue 'dispatch;
	}
	// 830F0C24: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830F0C28; continue 'dispatch;
            }
            0x830F0C28 => {
    //   block [0x830F0C28..0x830F0C3C)
	// 830F0C28: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 830F0C2C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830F0C30: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F0C34: 40990008  ble cr6, 0x830f0c3c
	if !ctx.cr[6].gt {
	pc = 0x830F0C3C; continue 'dispatch;
	}
	// 830F0C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F0C3C; continue 'dispatch;
            }
            0x830F0C3C => {
    //   block [0x830F0C3C..0x830F0C68)
	// 830F0C3C: 4B525CED  bl 0x82616928
	ctx.lr = 0x830F0C40;
	sub_82616928(ctx, base);
	// 830F0C40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F0C44: 41820060  beq 0x830f0ca4
	if ctx.cr[0].eq {
	pc = 0x830F0CA4; continue 'dispatch;
	}
	// 830F0C48: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 830F0C4C: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830F0C50: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F0C54: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 830F0C58: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F0C5C: 41800040  blt 0x830f0c9c
	if ctx.cr[0].lt {
	pc = 0x830F0C9C; continue 'dispatch;
	}
	// 830F0C60: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830F0C64: 3929A6F8  addi r9, r9, -0x5908
	ctx.r[9].s64 = ctx.r[9].s64 + -22792;
	pc = 0x830F0C68; continue 'dispatch;
            }
            0x830F0C68 => {
    //   block [0x830F0C68..0x830F0C9C)
	// 830F0C68: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830F0C6C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F0C70: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F0C74: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 830F0C78: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 830F0C7C: 93EB0010  stw r31, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 830F0C80: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 830F0C84: 93EB0018  stw r31, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 830F0C88: 93CB001C  stw r30, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830F0C8C: 93CB0020  stw r30, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 830F0C90: 93CB0024  stw r30, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 830F0C94: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 830F0C98: 4080FFD0  bge 0x830f0c68
	if !ctx.cr[0].lt {
	pc = 0x830F0C68; continue 'dispatch;
	}
	pc = 0x830F0C9C; continue 'dispatch;
            }
            0x830F0C9C => {
    //   block [0x830F0C9C..0x830F0CA4)
	// 830F0C9C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 830F0CA0: 4800000C  b 0x830f0cac
	pc = 0x830F0CAC; continue 'dispatch;
            }
            0x830F0CA4 => {
    //   block [0x830F0CA4..0x830F0CAC)
	// 830F0CA4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F0CA8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x830F0CAC; continue 'dispatch;
            }
            0x830F0CAC => {
    //   block [0x830F0CAC..0x830F0CC0)
	// 830F0CAC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0CB0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830F0CB4: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F0CB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F0CBC: 4099002C  ble cr6, 0x830f0ce8
	if !ctx.cr[6].gt {
	pc = 0x830F0CE8; continue 'dispatch;
	}
	pc = 0x830F0CC0; continue 'dispatch;
            }
            0x830F0CC0 => {
    //   block [0x830F0CC0..0x830F0CE8)
	// 830F0CC0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0CC4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F0CC8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F0CCC: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F0CD0: 4BFFF891  bl 0x830f0560
	ctx.lr = 0x830F0CD4;
	sub_830F0560(ctx, base);
	// 830F0CD4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0CD8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830F0CDC: 3BDE0028  addi r30, r30, 0x28
	ctx.r[30].s64 = ctx.r[30].s64 + 40;
	// 830F0CE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F0CE4: 4198FFDC  blt cr6, 0x830f0cc0
	if ctx.cr[6].lt {
	pc = 0x830F0CC0; continue 'dispatch;
	}
	pc = 0x830F0CE8; continue 'dispatch;
            }
            0x830F0CE8 => {
    //   block [0x830F0CE8..0x830F0CEC)
	// 830F0CE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830F0CEC; continue 'dispatch;
            }
            0x830F0CEC => {
    //   block [0x830F0CEC..0x830F0CF4)
	// 830F0CEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F0CF0: 4BBB8760  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0CF8 size=112
    let mut pc: u32 = 0x830F0CF8;
    'dispatch: loop {
        match pc {
            0x830F0CF8 => {
    //   block [0x830F0CF8..0x830F0D4C)
	// 830F0CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F0D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0D0C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F0D10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0D14: 396BA6FC  addi r11, r11, -0x5904
	ctx.r[11].s64 = ctx.r[11].s64 + -22788;
	// 830F0D18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F0D1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0D20: 4BFFFDF1  bl 0x830f0b10
	ctx.lr = 0x830F0D24;
	sub_830F0B10(ctx, base);
	// 830F0D24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830F0D28: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830F0D2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0D30: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F0D34: 41820018  beq 0x830f0d4c
	if ctx.cr[0].eq {
	pc = 0x830F0D4C; continue 'dispatch;
	}
	// 830F0D38: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F0D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0D40: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F0D44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0D48: 4E800421  bctrl
	ctx.lr = 0x830F0D4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F0D4C => {
    //   block [0x830F0D4C..0x830F0D68)
	// 830F0D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0D50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F0D54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0D58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0D5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F0D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F0D68 size=44
    let mut pc: u32 = 0x830F0D68;
    'dispatch: loop {
        match pc {
            0x830F0D68 => {
    //   block [0x830F0D68..0x830F0D94)
	// 830F0D68: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F0D6C: 394BA704  addi r10, r11, -0x58fc
	ctx.r[10].s64 = ctx.r[11].s64 + -22780;
	// 830F0D70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F0D74: 392BA6FC  addi r9, r11, -0x5904
	ctx.r[9].s64 = ctx.r[11].s64 + -22788;
	// 830F0D78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F0D7C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F0D80: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F0D84: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F0D88: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830F0D8C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F0D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0D98 size=104
    let mut pc: u32 = 0x830F0D98;
    'dispatch: loop {
        match pc {
            0x830F0D98 => {
    //   block [0x830F0D98..0x830F0E00)
	// 830F0D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0DA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F0DA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0DA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0DAC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F0DB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0DB4: 396BA704  addi r11, r11, -0x58fc
	ctx.r[11].s64 = ctx.r[11].s64 + -22780;
	// 830F0DB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0DBC: 4BFFF50D  bl 0x830f02c8
	ctx.lr = 0x830F0DC0;
	sub_830F02C8(ctx, base);
	// 830F0DC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F0DC4: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 830F0DC8: 396BA6FC  addi r11, r11, -0x5904
	ctx.r[11].s64 = ctx.r[11].s64 + -22788;
	// 830F0DCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F0DD0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0DD4: 4BFFFD3D  bl 0x830f0b10
	ctx.lr = 0x830F0DD8;
	sub_830F0B10(ctx, base);
	// 830F0DD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830F0DDC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830F0DE0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0DE4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0DE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F0DEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0DF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0DF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F0DF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F0E00 size=332
    let mut pc: u32 = 0x830F0E00;
    'dispatch: loop {
        match pc {
            0x830F0E00 => {
    //   block [0x830F0E00..0x830F0E58)
	// 830F0E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0E04: 4BBB8601  bl 0x82ca9404
	ctx.lr = 0x830F0E08;
	sub_82CA93D0(ctx, base);
	// 830F0E08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0E0C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830F0E10: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 830F0E14: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F0E18: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F0E1C: 4B525B0D  bl 0x82616928
	ctx.lr = 0x830F0E20;
	sub_82616928(ctx, base);
	// 830F0E20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F0E24: 41820034  beq 0x830f0e58
	if ctx.cr[0].eq {
	pc = 0x830F0E58; continue 'dispatch;
	}
	// 830F0E28: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F0E2C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830F0E30: 394BA700  addi r10, r11, -0x5900
	ctx.r[10].s64 = ctx.r[11].s64 + -22784;
	// 830F0E34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F0E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0E3C: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0E40: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F0E44: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F0E48: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F0E4C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F0E50: 99630010  stb r11, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 830F0E54: 48000008  b 0x830f0e5c
	pc = 0x830F0E5C; continue 'dispatch;
            }
            0x830F0E58 => {
    //   block [0x830F0E58..0x830F0E5C)
	// 830F0E58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x830F0E5C; continue 'dispatch;
            }
            0x830F0E5C => {
    //   block [0x830F0E5C..0x830F0E88)
	// 830F0E5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0E60: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 830F0E64: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830F0E68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F0E6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F0E70: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F0E74: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0E78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0E7C: 4E800421  bctrl
	ctx.lr = 0x830F0E80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F0E80: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 830F0E84: 419A000C  beq cr6, 0x830f0e90
	if ctx.cr[6].eq {
	pc = 0x830F0E90; continue 'dispatch;
	}
            }
            0x830F0E88 => {
    //   block [0x830F0E88..0x830F0E90)
	// 830F0E88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F0E8C: 480000B8  b 0x830f0f44
	pc = 0x830F0F44; continue 'dispatch;
            }
            0x830F0E90 => {
    //   block [0x830F0E90..0x830F0F08)
	// 830F0E90: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0E94: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F0E98: 419900A8  bgt cr6, 0x830f0f40
	if ctx.cr[6].gt {
	pc = 0x830F0F40; continue 'dispatch;
	}
	// 830F0E9C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0EA0: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 830F0EA4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830F0EA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F0EAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F0EB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F0EB4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0EBC: 4E800421  bctrl
	ctx.lr = 0x830F0EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F0EC0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 830F0EC4: 409AFFC4  bne cr6, 0x830f0e88
	if !ctx.cr[6].eq {
	pc = 0x830F0E88; continue 'dispatch;
	}
	// 830F0EC8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0ECC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F0ED0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F0ED4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F0ED8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F0EDC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 830F0EE0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830F0EE4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830F0EE8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830F0EEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F0EF0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830F0EF4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0EF8: 4BFFFF09  bl 0x830f0e00
	ctx.lr = 0x830F0EFC;
	sub_830F0E00(ctx, base);
	// 830F0EFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F0F00: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830F0F04: 40820020  bne 0x830f0f24
	if !ctx.cr[0].eq {
	pc = 0x830F0F24; continue 'dispatch;
	}
            }
            0x830F0F08 => {
    //   block [0x830F0F08..0x830F0F24)
	// 830F0F08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0F0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F0F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0F14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0F18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F0F1C: 4E800421  bctrl
	ctx.lr = 0x830F0F20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F0F20: 4BFFFF68  b 0x830f0e88
	pc = 0x830F0E88; continue 'dispatch;
            }
            0x830F0F24 => {
    //   block [0x830F0F24..0x830F0F40)
	// 830F0F24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F0F28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F0F2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F0F30: 4BFFFED1  bl 0x830f0e00
	ctx.lr = 0x830F0F34;
	sub_830F0E00(ctx, base);
	// 830F0F34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F0F38: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 830F0F3C: 4182FFCC  beq 0x830f0f08
	if ctx.cr[0].eq {
	pc = 0x830F0F08; continue 'dispatch;
	}
	pc = 0x830F0F40; continue 'dispatch;
            }
            0x830F0F40 => {
    //   block [0x830F0F40..0x830F0F44)
	// 830F0F40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F0F44; continue 'dispatch;
            }
            0x830F0F44 => {
    //   block [0x830F0F44..0x830F0F4C)
	// 830F0F44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F0F48: 4BBB850C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0F50 size=116
    let mut pc: u32 = 0x830F0F50;
    'dispatch: loop {
        match pc {
            0x830F0F50 => {
    //   block [0x830F0F50..0x830F0F80)
	// 830F0F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0F58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F0F5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0F60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0F64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0F68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F0F6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F0F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F0F74: 409A000C  bne cr6, 0x830f0f80
	if !ctx.cr[6].eq {
	pc = 0x830F0F80; continue 'dispatch;
	}
	// 830F0F78: 386000FF  li r3, 0xff
	ctx.r[3].s64 = 255;
	// 830F0F7C: 48000030  b 0x830f0fac
	pc = 0x830F0FAC; continue 'dispatch;
            }
            0x830F0F80 => {
    //   block [0x830F0F80..0x830F0FA0)
	// 830F0F80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F0F84: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 830F0F88: 4BFFFB19  bl 0x830f0aa0
	ctx.lr = 0x830F0F8C;
	sub_830F0AA0(ctx, base);
	// 830F0F8C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830F0F90: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F0F94: 409A000C  bne cr6, 0x830f0fa0
	if !ctx.cr[6].eq {
	pc = 0x830F0FA0; continue 'dispatch;
	}
	// 830F0F98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F0F9C: 48000010  b 0x830f0fac
	pc = 0x830F0FAC; continue 'dispatch;
            }
            0x830F0FA0 => {
    //   block [0x830F0FA0..0x830F0FAC)
	// 830F0FA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F0FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0FA8: 4BFFF371  bl 0x830f0318
	ctx.lr = 0x830F0FAC;
	sub_830F0318(ctx, base);
	pc = 0x830F0FAC; continue 'dispatch;
            }
            0x830F0FAC => {
    //   block [0x830F0FAC..0x830F0FC4)
	// 830F0FAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F0FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0FB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F0FBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0FC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0FC8 size=88
    let mut pc: u32 = 0x830F0FC8;
    'dispatch: loop {
        match pc {
            0x830F0FC8 => {
    //   block [0x830F0FC8..0x830F1004)
	// 830F0FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0FD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F0FD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0FD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0FDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0FE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F0FE4: 4BFFF3BD  bl 0x830f03a0
	ctx.lr = 0x830F0FE8;
	sub_830F03A0(ctx, base);
	// 830F0FE8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F0FEC: 41820018  beq 0x830f1004
	if ctx.cr[0].eq {
	pc = 0x830F1004; continue 'dispatch;
	}
	// 830F0FF0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F0FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0FF8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F0FFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F1000: 4E800421  bctrl
	ctx.lr = 0x830F1004;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F1004 => {
    //   block [0x830F1004..0x830F1020)
	// 830F1004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F100C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1014: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F1018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F101C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1020 size=204
    let mut pc: u32 = 0x830F1020;
    'dispatch: loop {
        match pc {
            0x830F1020 => {
    //   block [0x830F1020..0x830F1064)
	// 830F1020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1024: 4BBB83DD  bl 0x82ca9400
	ctx.lr = 0x830F1028;
	sub_82CA93D0(ctx, base);
	// 830F1028: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F102C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F1030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1034: 574B07BD  rlwinm. r11, r26, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1038: 4182006C  beq 0x830f10a4
	if ctx.cr[0].eq {
	pc = 0x830F10A4; continue 'dispatch;
	}
	// 830F103C: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830F1040: 3B7FFFFC  addi r27, r31, -4
	ctx.r[27].s64 = ctx.r[31].s64 + -4;
	// 830F1044: 1D4B0028  mulli r10, r11, 0x28
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 40 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 830F1048: 37CBFFFF  addic. r30, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F104C: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F1050: 41800030  blt 0x830f1080
	if ctx.cr[0].lt {
	pc = 0x830F1080; continue 'dispatch;
	}
	// 830F1054: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830F1058: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 830F105C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1060: 3B8BA6F8  addi r28, r11, -0x5908
	ctx.r[28].s64 = ctx.r[11].s64 + -22792;
	pc = 0x830F1064; continue 'dispatch;
            }
            0x830F1064 => {
    //   block [0x830F1064..0x830F1080)
	// 830F1064: 3BFFFFD8  addi r31, r31, -0x28
	ctx.r[31].s64 = ctx.r[31].s64 + -40;
	// 830F1068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F106C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830F1070: 4BFFF429  bl 0x830f0498
	ctx.lr = 0x830F1074;
	sub_830F0498(ctx, base);
	// 830F1074: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F1078: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830F107C: 4080FFE8  bge 0x830f1064
	if !ctx.cr[0].lt {
	pc = 0x830F1064; continue 'dispatch;
	}
	pc = 0x830F1080; continue 'dispatch;
            }
            0x830F1080 => {
    //   block [0x830F1080..0x830F109C)
	// 830F1080: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1084: 41820018  beq 0x830f109c
	if ctx.cr[0].eq {
	pc = 0x830F109C; continue 'dispatch;
	}
	// 830F1088: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F108C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F1090: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F1094: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F1098: 4E800421  bctrl
	ctx.lr = 0x830F109C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F109C => {
    //   block [0x830F109C..0x830F10A4)
	// 830F109C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F10A0: 48000044  b 0x830f10e4
	pc = 0x830F10E4; continue 'dispatch;
            }
            0x830F10A4 => {
    //   block [0x830F10A4..0x830F10E0)
	// 830F10A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F10A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F10AC: 396BA6F8  addi r11, r11, -0x5908
	ctx.r[11].s64 = ctx.r[11].s64 + -22792;
	// 830F10B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F10B4: 4BFFF3E5  bl 0x830f0498
	ctx.lr = 0x830F10B8;
	sub_830F0498(ctx, base);
	// 830F10B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830F10BC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830F10C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F10C4: 574A07FF  clrlwi. r10, r26, 0x1f
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F10C8: 41820018  beq 0x830f10e0
	if ctx.cr[0].eq {
	pc = 0x830F10E0; continue 'dispatch;
	}
	// 830F10CC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F10D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F10D4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F10D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F10DC: 4E800421  bctrl
	ctx.lr = 0x830F10E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F10E0 => {
    //   block [0x830F10E0..0x830F10E4)
	// 830F10E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F10E4; continue 'dispatch;
            }
            0x830F10E4 => {
    //   block [0x830F10E4..0x830F10EC)
	// 830F10E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F10E8: 4BBB8368  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F10F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F10F0 size=88
    let mut pc: u32 = 0x830F10F0;
    'dispatch: loop {
        match pc {
            0x830F10F0 => {
    //   block [0x830F10F0..0x830F112C)
	// 830F10F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F10F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F10F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F10FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1100: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1108: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F110C: 4BFFFC8D  bl 0x830f0d98
	ctx.lr = 0x830F1110;
	sub_830F0D98(ctx, base);
	// 830F1110: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1114: 41820018  beq 0x830f112c
	if ctx.cr[0].eq {
	pc = 0x830F112C; continue 'dispatch;
	}
	// 830F1118: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F111C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1120: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830F1124: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F1128: 4E800421  bctrl
	ctx.lr = 0x830F112C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F112C => {
    //   block [0x830F112C..0x830F1148)
	// 830F112C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F1134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F113C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F1140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F1144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1148 size=96
    let mut pc: u32 = 0x830F1148;
    'dispatch: loop {
        match pc {
            0x830F1148 => {
    //   block [0x830F1148..0x830F1190)
	// 830F1148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F114C: 4BBB82B9  bl 0x82ca9404
	ctx.lr = 0x830F1150;
	sub_82CA93D0(ctx, base);
	// 830F1150: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1158: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F115C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F1160: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830F1164: 4BFFFC9D  bl 0x830f0e00
	ctx.lr = 0x830F1168;
	sub_830F0E00(ctx, base);
	// 830F1168: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	// 830F116C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830F1170: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F1174: 4BFFF99D  bl 0x830f0b10
	ctx.lr = 0x830F1178;
	sub_830F0B10(ctx, base);
	// 830F1178: 2B1B0002  cmplwi cr6, r27, 2
	ctx.cr[6].compare_u32(ctx.r[27].u32, 2 as u32, &mut ctx.xer);
	// 830F117C: 41980014  blt cr6, 0x830f1190
	if ctx.cr[6].lt {
	pc = 0x830F1190; continue 'dispatch;
	}
	// 830F1180: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F1184: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F1188: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F118C: 4BFFF9FD  bl 0x830f0b88
	ctx.lr = 0x830F1190;
	sub_830F0B88(ctx, base);
	pc = 0x830F1190; continue 'dispatch;
            }
            0x830F1190 => {
    //   block [0x830F1190..0x830F11A8)
	// 830F1190: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1194: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F1198: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F119C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 830F11A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F11A4: 4BBB82B0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F11A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F11A8 size=88
    let mut pc: u32 = 0x830F11A8;
    'dispatch: loop {
        match pc {
            0x830F11A8 => {
    //   block [0x830F11A8..0x830F11E0)
	// 830F11A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F11AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F11B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F11B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F11B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F11BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F11C0: 419A002C  beq cr6, 0x830f11ec
	if ctx.cr[6].eq {
	pc = 0x830F11EC; continue 'dispatch;
	}
	// 830F11C4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830F11C8: 409A0018  bne cr6, 0x830f11e0
	if !ctx.cr[6].eq {
	pc = 0x830F11E0; continue 'dispatch;
	}
	// 830F11CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F11D0: 419A0018  beq cr6, 0x830f11e8
	if ctx.cr[6].eq {
	pc = 0x830F11E8; continue 'dispatch;
	}
	// 830F11D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F11D8: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830F11DC: 4800000C  b 0x830f11e8
	pc = 0x830F11E8; continue 'dispatch;
            }
            0x830F11E0 => {
    //   block [0x830F11E0..0x830F11E8)
	// 830F11E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F11E4: 4BBB9605  bl 0x82caa7e8
	ctx.lr = 0x830F11E8;
	sub_82CAA7E8(ctx, base);
	pc = 0x830F11E8; continue 'dispatch;
            }
            0x830F11E8 => {
    //   block [0x830F11E8..0x830F11EC)
	// 830F11E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F11EC; continue 'dispatch;
            }
            0x830F11EC => {
    //   block [0x830F11EC..0x830F1200)
	// 830F11EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F11F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F11F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F11F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F11FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1200 size=100
    let mut pc: u32 = 0x830F1200;
    'dispatch: loop {
        match pc {
            0x830F1200 => {
    //   block [0x830F1200..0x830F123C)
	// 830F1200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F120C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1214: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830F1218: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F121C: 419A0034  beq cr6, 0x830f1250
	if ctx.cr[6].eq {
	pc = 0x830F1250; continue 'dispatch;
	}
	// 830F1220: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 830F1224: 409A0018  bne cr6, 0x830f123c
	if !ctx.cr[6].eq {
	pc = 0x830F123C; continue 'dispatch;
	}
	// 830F1228: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F122C: 419A0020  beq cr6, 0x830f124c
	if ctx.cr[6].eq {
	pc = 0x830F124C; continue 'dispatch;
	}
	// 830F1230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F1234: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830F1238: 48000014  b 0x830f124c
	pc = 0x830F124C; continue 'dispatch;
            }
            0x830F123C => {
    //   block [0x830F123C..0x830F124C)
	// 830F123C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1244: 38ABA70C  addi r5, r11, -0x58f4
	ctx.r[5].s64 = ctx.r[11].s64 + -22772;
	// 830F1248: 4BBB9309  bl 0x82caa550
	ctx.lr = 0x830F124C;
	sub_82CAA550(ctx, base);
	pc = 0x830F124C; continue 'dispatch;
            }
            0x830F124C => {
    //   block [0x830F124C..0x830F1250)
	// 830F124C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F1250; continue 'dispatch;
            }
            0x830F1250 => {
    //   block [0x830F1250..0x830F1264)
	// 830F1250: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F125C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F1260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1268 size=96
    let mut pc: u32 = 0x830F1268;
    'dispatch: loop {
        match pc {
            0x830F1268 => {
    //   block [0x830F1268..0x830F12A0)
	// 830F1268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F126C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1270: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1274: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F127C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F1280: 419A0034  beq cr6, 0x830f12b4
	if ctx.cr[6].eq {
	pc = 0x830F12B4; continue 'dispatch;
	}
	// 830F1284: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830F1288: 419A0018  beq cr6, 0x830f12a0
	if ctx.cr[6].eq {
	pc = 0x830F12A0; continue 'dispatch;
	}
	// 830F128C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 830F1290: 419A0010  beq cr6, 0x830f12a0
	if ctx.cr[6].eq {
	pc = 0x830F12A0; continue 'dispatch;
	}
	// 830F1294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1298: 4BBBD939  bl 0x82caebd0
	ctx.lr = 0x830F129C;
	sub_82CAEBD0(ctx, base);
	// 830F129C: 48000014  b 0x830f12b0
	pc = 0x830F12B0; continue 'dispatch;
            }
            0x830F12A0 => {
    //   block [0x830F12A0..0x830F12B0)
	// 830F12A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F12A4: 419A000C  beq cr6, 0x830f12b0
	if ctx.cr[6].eq {
	pc = 0x830F12B0; continue 'dispatch;
	}
	// 830F12A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F12AC: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x830F12B0; continue 'dispatch;
            }
            0x830F12B0 => {
    //   block [0x830F12B0..0x830F12B4)
	// 830F12B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F12B4; continue 'dispatch;
            }
            0x830F12B4 => {
    //   block [0x830F12B4..0x830F12C8)
	// 830F12B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F12B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F12BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F12C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F12C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F12C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F12C8 size=80
    let mut pc: u32 = 0x830F12C8;
    'dispatch: loop {
        match pc {
            0x830F12C8 => {
    //   block [0x830F12C8..0x830F12FC)
	// 830F12C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F12CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F12D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F12D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F12D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F12DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F12E0: 419A0024  beq cr6, 0x830f1304
	if ctx.cr[6].eq {
	pc = 0x830F1304; continue 'dispatch;
	}
	// 830F12E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F12E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F12EC: 409A0010  bne cr6, 0x830f12fc
	if !ctx.cr[6].eq {
	pc = 0x830F12FC; continue 'dispatch;
	}
	// 830F12F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F12F4: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830F12F8: 4800000C  b 0x830f1304
	pc = 0x830F1304; continue 'dispatch;
            }
            0x830F12FC => {
    //   block [0x830F12FC..0x830F1304)
	// 830F12FC: 4BBBF9ED  bl 0x82cb0ce8
	ctx.lr = 0x830F1300;
	sub_82CB0CE8(ctx, base);
	// 830F1300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F1304; continue 'dispatch;
            }
            0x830F1304 => {
    //   block [0x830F1304..0x830F1318)
	// 830F1304: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F130C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F1314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1318 size=4
    let mut pc: u32 = 0x830F1318;
    'dispatch: loop {
        match pc {
            0x830F1318 => {
    //   block [0x830F1318..0x830F131C)
	// 830F1318: 4BFFFE90  b 0x830f11a8
	sub_830F11A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1320 size=4
    let mut pc: u32 = 0x830F1320;
    'dispatch: loop {
        match pc {
            0x830F1320 => {
    //   block [0x830F1320..0x830F1324)
	// 830F1320: 4BFFFEE0  b 0x830f1200
	sub_830F1200(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1328 size=4
    let mut pc: u32 = 0x830F1328;
    'dispatch: loop {
        match pc {
            0x830F1328 => {
    //   block [0x830F1328..0x830F132C)
	// 830F1328: 4BFFFF40  b 0x830f1268
	sub_830F1268(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1330 size=28
    let mut pc: u32 = 0x830F1330;
    'dispatch: loop {
        match pc {
            0x830F1330 => {
    //   block [0x830F1330..0x830F134C)
	// 830F1330: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830F1334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F1338: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 830F133C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F1340: 409A000C  bne cr6, 0x830f134c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x830F134C);
		return;
	}
	// 830F1344: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830F1348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1368 size=4
    let mut pc: u32 = 0x830F1368;
    'dispatch: loop {
        match pc {
            0x830F1368 => {
    //   block [0x830F1368..0x830F136C)
	// 830F1368: 4BFFFF60  b 0x830f12c8
	sub_830F12C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1370 size=224
    let mut pc: u32 = 0x830F1370;
    'dispatch: loop {
        match pc {
            0x830F1370 => {
    //   block [0x830F1370..0x830F13B0)
	// 830F1370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F137C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1380: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1384: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F1388: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F138C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F1390: 419A0094  beq cr6, 0x830f1424
	if ctx.cr[6].eq {
	pc = 0x830F1424; continue 'dispatch;
	}
	// 830F1394: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1398: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F139C: 41820088  beq 0x830f1424
	if ctx.cr[0].eq {
	pc = 0x830F1424; continue 'dispatch;
	}
	// 830F13A0: 2B0BFFFE  cmplwi cr6, r11, 0xfffe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65534 as u32, &mut ctx.xer);
	// 830F13A4: 419A000C  beq cr6, 0x830f13b0
	if ctx.cr[6].eq {
	pc = 0x830F13B0; continue 'dispatch;
	}
	// 830F13A8: 2B0BFEFF  cmplwi cr6, r11, 0xfeff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65279 as u32, &mut ctx.xer);
	// 830F13AC: 409A0008  bne cr6, 0x830f13b4
	if !ctx.cr[6].eq {
	pc = 0x830F13B4; continue 'dispatch;
	}
	pc = 0x830F13B0; continue 'dispatch;
            }
            0x830F13B0 => {
    //   block [0x830F13B0..0x830F13B4)
	// 830F13B0: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	pc = 0x830F13B4; continue 'dispatch;
            }
            0x830F13B4 => {
    //   block [0x830F13B4..0x830F13C4)
	// 830F13B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F13B8: 419A000C  beq cr6, 0x830f13c4
	if ctx.cr[6].eq {
	pc = 0x830F13C4; continue 'dispatch;
	}
	// 830F13BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F13C0: 4B089CC1  bl 0x8217b080
	ctx.lr = 0x830F13C4;
	sub_8217B080(ctx, base);
	pc = 0x830F13C4; continue 'dispatch;
            }
            0x830F13C4 => {
    //   block [0x830F13C4..0x830F1424)
	// 830F13C4: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F13C8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830F13CC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 830F13D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F13D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F13D8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830F13DC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 830F13E0: 480011F9  bl 0x830f25d8
	ctx.lr = 0x830F13E4;
	sub_830F25D8(ctx, base);
	// 830F13E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F13E8: 815E1024  lwz r10, 0x1024(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4132 as u32) ) } as u64;
	// 830F13EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F13F0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830F13F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F13F8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F13FC: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 830F1400: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830F1404: 480047E5  bl 0x830f5be8
	ctx.lr = 0x830F1408;
	sub_830F5BE8(ctx, base);
	// 830F1408: 907E1020  stw r3, 0x1020(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4128 as u32), ctx.r[3].u32 ) };
	// 830F140C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F1410: 40820024  bne 0x830f1434
	if !ctx.cr[0].eq {
	pc = 0x830F1434; continue 'dispatch;
	}
	// 830F1414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1418: 48004B29  bl 0x830f5f40
	ctx.lr = 0x830F141C;
	sub_830F5F40(ctx, base);
	// 830F141C: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1420: 48000018  b 0x830f1438
	pc = 0x830F1438; continue 'dispatch;
            }
            0x830F1424 => {
    //   block [0x830F1424..0x830F1434)
	// 830F1424: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1428: 48004B19  bl 0x830f5f40
	ctx.lr = 0x830F142C;
	sub_830F5F40(ctx, base);
	// 830F142C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F1430: 917E1020  stw r11, 0x1020(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4128 as u32), ctx.r[11].u32 ) };
	pc = 0x830F1434; continue 'dispatch;
            }
            0x830F1434 => {
    //   block [0x830F1434..0x830F1438)
	// 830F1434: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F1438; continue 'dispatch;
            }
            0x830F1438 => {
    //   block [0x830F1438..0x830F1450)
	// 830F1438: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F143C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1440: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1444: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F1448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F144C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1450 size=8
    let mut pc: u32 = 0x830F1450;
    'dispatch: loop {
        match pc {
            0x830F1450 => {
    //   block [0x830F1450..0x830F1458)
	// 830F1450: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1454: 4BFFFF1C  b 0x830f1370
	sub_830F1370(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1458 size=36
    let mut pc: u32 = 0x830F1458;
    'dispatch: loop {
        match pc {
            0x830F1458 => {
    //   block [0x830F1458..0x830F1474)
	// 830F1458: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F145C: 816B1020  lwz r11, 0x1020(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4128 as u32) ) } as u64;
	// 830F1460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F1464: 419A0010  beq cr6, 0x830f1474
	if ctx.cr[6].eq {
	pc = 0x830F1474; continue 'dispatch;
	}
	// 830F1468: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F146C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 830F1470: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	pc = 0x830F1474; continue 'dispatch;
            }
            0x830F1474 => {
    //   block [0x830F1474..0x830F147C)
	// 830F1474: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F1478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1480 size=116
    let mut pc: u32 = 0x830F1480;
    'dispatch: loop {
        match pc {
            0x830F1480 => {
    //   block [0x830F1480..0x830F14AC)
	// 830F1480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F148C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1494: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F1498: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F149C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F14A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F14A4: 419A0008  beq cr6, 0x830f14ac
	if ctx.cr[6].eq {
	pc = 0x830F14AC; continue 'dispatch;
	}
	// 830F14A8: 4B754309  bl 0x828457b0
	ctx.lr = 0x830F14AC;
	sub_828457B0(ctx, base);
	pc = 0x830F14AC; continue 'dispatch;
            }
            0x830F14AC => {
    //   block [0x830F14AC..0x830F14C8)
	// 830F14AC: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 830F14B0: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 830F14B4: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 830F14B8: 5563083C  slwi r3, r11, 1
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830F14BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F14C0: 40990008  ble cr6, 0x830f14c8
	if !ctx.cr[6].gt {
	pc = 0x830F14C8; continue 'dispatch;
	}
	// 830F14C4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x830F14C8; continue 'dispatch;
            }
            0x830F14C8 => {
    //   block [0x830F14C8..0x830F14F4)
	// 830F14C8: 4B1F8CF1  bl 0x822ea1b8
	ctx.lr = 0x830F14CC;
	sub_822EA1B8(ctx, base);
	// 830F14CC: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830F14D0: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F14D4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F14D8: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 830F14DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F14E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F14E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F14E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F14EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F14F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F14F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F14F8 size=204
    let mut pc: u32 = 0x830F14F8;
    'dispatch: loop {
        match pc {
            0x830F14F8 => {
    //   block [0x830F14F8..0x830F155C)
	// 830F14F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F14FC: 4BBB7F11  bl 0x82ca940c
	ctx.lr = 0x830F1500;
	sub_82CA93D0(ctx, base);
	// 830F1500: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1504: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F1508: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F150C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F1510: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F1514: 3BCBA730  addi r30, r11, -0x58d0
	ctx.r[30].s64 = ctx.r[11].s64 + -22736;
	// 830F1518: 409A0044  bne cr6, 0x830f155c
	if !ctx.cr[6].eq {
	pc = 0x830F155C; continue 'dispatch;
	}
	// 830F151C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F1520: 388BBBA1  addi r4, r11, -0x445f
	ctx.r[4].s64 = ctx.r[11].s64 + -17503;
	// 830F1524: 896BBBA1  lbz r11, -0x445f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-17503 as u32) ) } as u64;
	// 830F1528: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F152C: 40820030  bne 0x830f155c
	if !ctx.cr[0].eq {
	pc = 0x830F155C; continue 'dispatch;
	}
	// 830F1530: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1534: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830F1538: 39400016  li r10, 0x16
	ctx.r[10].s64 = 22;
	// 830F153C: 396BA720  addi r11, r11, -0x58e0
	ctx.r[11].s64 = ctx.r[11].s64 + -22752;
	// 830F1540: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830F1544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F1548: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830F154C: 4800086D  bl 0x830f1db8
	ctx.lr = 0x830F1550;
	sub_830F1DB8(ctx, base);
	// 830F1550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1554: 40820008  bne 0x830f155c
	if !ctx.cr[0].eq {
	pc = 0x830F155C; continue 'dispatch;
	}
	// 830F1558: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F155C; continue 'dispatch;
            }
            0x830F155C => {
    //   block [0x830F155C..0x830F15A4)
	// 830F155C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F1560: 409A0044  bne cr6, 0x830f15a4
	if !ctx.cr[6].eq {
	pc = 0x830F15A4; continue 'dispatch;
	}
	// 830F1564: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F1568: 388BBBA0  addi r4, r11, -0x4460
	ctx.r[4].s64 = ctx.r[11].s64 + -17504;
	// 830F156C: 896BBBA0  lbz r11, -0x4460(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-17504 as u32) ) } as u64;
	// 830F1570: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F1574: 40820030  bne 0x830f15a4
	if !ctx.cr[0].eq {
	pc = 0x830F15A4; continue 'dispatch;
	}
	// 830F1578: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F157C: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 830F1580: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 830F1584: 396BA714  addi r11, r11, -0x58ec
	ctx.r[11].s64 = ctx.r[11].s64 + -22764;
	// 830F1588: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830F158C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F1590: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830F1594: 48000825  bl 0x830f1db8
	ctx.lr = 0x830F1598;
	sub_830F1DB8(ctx, base);
	// 830F1598: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F159C: 40820008  bne 0x830f15a4
	if !ctx.cr[0].eq {
	pc = 0x830F15A4; continue 'dispatch;
	}
	// 830F15A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F15A4; continue 'dispatch;
            }
            0x830F15A4 => {
    //   block [0x830F15A4..0x830F15C4)
	// 830F15A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F15A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F15AC: 388BA708  addi r4, r11, -0x58f8
	ctx.r[4].s64 = ctx.r[11].s64 + -22776;
	// 830F15B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F15B4: 4B14E2ED  bl 0x8223f8a0
	ctx.lr = 0x830F15B8;
	sub_8223F8A0(ctx, base);
	// 830F15B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F15BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F15C0: 4BBB7E9C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F15C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F15C8 size=88
    let mut pc: u32 = 0x830F15C8;
    'dispatch: loop {
        match pc {
            0x830F15C8 => {
    //   block [0x830F15C8..0x830F1620)
	// 830F15C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F15CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F15D0: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 830F15D4: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 830F15D8: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 830F15DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F15E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830F15E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830F15E8: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 830F15EC: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 830F15F0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 830F15F4: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 830F15F8: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830F15FC: 90CB0010  stw r6, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 830F1600: 39610098  addi r11, r1, 0x98
	ctx.r[11].s64 = ctx.r[1].s64 + 152;
	// 830F1604: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F1608: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F160C: 4BF1A325  bl 0x8300b930
	ctx.lr = 0x830F1610;
	sub_8300B930(ctx, base);
	// 830F1610: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F161C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1620 size=80
    let mut pc: u32 = 0x830F1620;
    'dispatch: loop {
        match pc {
            0x830F1620 => {
    //   block [0x830F1620..0x830F1670)
	// 830F1620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1628: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F162C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1630: 38800800  li r4, 0x800
	ctx.r[4].s64 = 2048;
	// 830F1634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1638: 48004961  bl 0x830f5f98
	ctx.lr = 0x830F163C;
	sub_830F5F98(ctx, base);
	// 830F163C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1640: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F1644: 396BA788  addi r11, r11, -0x5878
	ctx.r[11].s64 = ctx.r[11].s64 + -22648;
	// 830F1648: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 830F164C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F1650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1654: 915F1020  stw r10, 0x1020(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4128 as u32), ctx.r[10].u32 ) };
	// 830F1658: 913F1024  stw r9, 0x1024(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4132 as u32), ctx.r[9].u32 ) };
	// 830F165C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1668: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F166C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1670 size=540
    let mut pc: u32 = 0x830F1670;
    'dispatch: loop {
        match pc {
            0x830F1670 => {
    //   block [0x830F1670..0x830F16CC)
	// 830F1670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1674: 4BBB7D8D  bl 0x82ca9400
	ctx.lr = 0x830F1678;
	sub_82CA93D0(ctx, base);
	// 830F1678: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F167C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F1680: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830F1684: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830F1688: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F168C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F1690: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F1694: 4BFFFE65  bl 0x830f14f8
	ctx.lr = 0x830F1698;
	sub_830F14F8(ctx, base);
	// 830F1698: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F169C: 3D000800  lis r8, 0x800
	ctx.r[8].s64 = 134217728;
	// 830F16A0: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 830F16A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F16A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830F16AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F16B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F16B4: 4BBD1DDD  bl 0x82cc3490
	ctx.lr = 0x830F16B8;
	sub_82CC3490(ctx, base);
	// 830F16B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F16BC: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 830F16C0: 409A0038  bne cr6, 0x830f16f8
	if !ctx.cr[6].eq {
	pc = 0x830F16F8; continue 'dispatch;
	}
	// 830F16C4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F16C8: 38EAA89C  addi r7, r10, -0x5764
	ctx.r[7].s64 = ctx.r[10].s64 + -22372;
	pc = 0x830F16CC; continue 'dispatch;
            }
            0x830F16CC => {
    //   block [0x830F16CC..0x830F16EC)
	// 830F16CC: 817A000C  lwz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F16D0: 387A000C  addi r3, r26, 0xc
	ctx.r[3].s64 = ctx.r[26].s64 + 12;
	// 830F16D4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 830F16D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F16DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F16E0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 830F16E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F16E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x830F16EC; continue 'dispatch;
            }
            0x830F16EC => {
    //   block [0x830F16EC..0x830F16F8)
	// 830F16EC: 4E800421  bctrl
	ctx.lr = 0x830F16F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F16F0: 3860D8F0  li r3, -0x2710
	ctx.r[3].s64 = -10000;
	// 830F16F4: 48000190  b 0x830f1884
	pc = 0x830F1884; continue 'dispatch;
            }
            0x830F16F8 => {
    //   block [0x830F16F8..0x830F1734)
	// 830F16F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F16FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1700: 4BBD5711  bl 0x82cc6e10
	ctx.lr = 0x830F1704;
	sub_82CC6E10(ctx, base);
	// 830F1704: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F1708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F170C: 4BBD10A5  bl 0x82cc27b0
	ctx.lr = 0x830F1710;
	sub_82CC27B0(ctx, base);
	// 830F1710: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1718: 388BA894  addi r4, r11, -0x576c
	ctx.r[4].s64 = ctx.r[11].s64 + -22380;
	// 830F171C: 48005A2D  bl 0x830f7148
	ctx.lr = 0x830F1720;
	sub_830F7148(ctx, base);
	// 830F1720: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F1724: 40820010  bne 0x830f1734
	if !ctx.cr[0].eq {
	pc = 0x830F1734; continue 'dispatch;
	}
	// 830F1728: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F172C: 38EAA848  addi r7, r10, -0x57b8
	ctx.r[7].s64 = ctx.r[10].s64 + -22456;
	// 830F1730: 4BFFFF9C  b 0x830f16cc
	pc = 0x830F16CC; continue 'dispatch;
            }
            0x830F1734 => {
    //   block [0x830F1734..0x830F1790)
	// 830F1734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1738: 4BF199A1  bl 0x8300b0d8
	ctx.lr = 0x830F173C;
	sub_8300B0D8(ctx, base);
	// 830F173C: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F1740: 2B0BFFFE  cmplwi cr6, r11, 0xfffe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65534 as u32, &mut ctx.xer);
	// 830F1744: 419A004C  beq cr6, 0x830f1790
	if ctx.cr[6].eq {
	pc = 0x830F1790; continue 'dispatch;
	}
	// 830F1748: 2B0BFEFF  cmplwi cr6, r11, 0xfeff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65279 as u32, &mut ctx.xer);
	// 830F174C: 419A0044  beq cr6, 0x830f1790
	if ctx.cr[6].eq {
	pc = 0x830F1790; continue 'dispatch;
	}
	// 830F1750: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F1754: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F1758: 4BFFFD29  bl 0x830f1480
	ctx.lr = 0x830F175C;
	sub_830F1480(ctx, base);
	// 830F175C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1760: 41820048  beq 0x830f17a8
	if ctx.cr[0].eq {
	pc = 0x830F17A8; continue 'dispatch;
	}
	// 830F1764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1768: 4BBB9481  bl 0x82caabe8
	ctx.lr = 0x830F176C;
	sub_82CAABE8(ctx, base);
	// 830F176C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1770: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1774: 388BA83C  addi r4, r11, -0x57c4
	ctx.r[4].s64 = ctx.r[11].s64 + -22468;
	// 830F1778: 480059D1  bl 0x830f7148
	ctx.lr = 0x830F177C;
	sub_830F7148(ctx, base);
	// 830F177C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F1780: 40820060  bne 0x830f17e0
	if !ctx.cr[0].eq {
	pc = 0x830F17E0; continue 'dispatch;
	}
	// 830F1784: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F1788: 38EAA7D0  addi r7, r10, -0x5830
	ctx.r[7].s64 = ctx.r[10].s64 + -22576;
	// 830F178C: 4BFFFF40  b 0x830f16cc
	pc = 0x830F16CC; continue 'dispatch;
            }
            0x830F1790 => {
    //   block [0x830F1790..0x830F17A8)
	// 830F1790: 57ABF87E  srwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1794: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F1798: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 830F179C: 4BFFFCE5  bl 0x830f1480
	ctx.lr = 0x830F17A0;
	sub_830F1480(ctx, base);
	// 830F17A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F17A4: 4082003C  bne 0x830f17e0
	if !ctx.cr[0].eq {
	pc = 0x830F17E0; continue 'dispatch;
	}
	pc = 0x830F17A8; continue 'dispatch;
            }
            0x830F17A8 => {
    //   block [0x830F17A8..0x830F17E0)
	// 830F17A8: 817A000C  lwz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F17AC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F17B0: 387A000C  addi r3, r26, 0xc
	ctx.r[3].s64 = ctx.r[26].s64 + 12;
	// 830F17B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F17B8: 38EAA7B0  addi r7, r10, -0x5850
	ctx.r[7].s64 = ctx.r[10].s64 + -22608;
	// 830F17BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F17C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F17C4: 3880D8F1  li r4, -0x270f
	ctx.r[4].s64 = -9999;
	// 830F17C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F17CC: 4E800421  bctrl
	ctx.lr = 0x830F17D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F17D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F17D4: 4BBB9415  bl 0x82caabe8
	ctx.lr = 0x830F17D8;
	sub_82CAABE8(ctx, base);
	// 830F17D8: 3860D8F1  li r3, -0x270f
	ctx.r[3].s64 = -9999;
	// 830F17DC: 480000A8  b 0x830f1884
	pc = 0x830F1884; continue 'dispatch;
            }
            0x830F17E0 => {
    //   block [0x830F17E0..0x830F17F8)
	// 830F17E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F17E4: 4BF198F5  bl 0x8300b0d8
	ctx.lr = 0x830F17E8;
	sub_8300B0D8(ctx, base);
	// 830F17E8: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F17EC: 547C043E  clrlwi r28, r3, 0x10
	ctx.r[28].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F17F0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F17F4: 4800002C  b 0x830f1820
	pc = 0x830F1820; continue 'dispatch;
            }
            0x830F17F8 => {
    //   block [0x830F17F8..0x830F1820)
	// 830F17F8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F17FC: 409A0034  bne cr6, 0x830f1830
	if !ctx.cr[6].eq {
	pc = 0x830F1830; continue 'dispatch;
	}
	// 830F1800: B39E0000  sth r28, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u16 ) };
	// 830F1804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1808: 4BF198D1  bl 0x8300b0d8
	ctx.lr = 0x830F180C;
	sub_8300B0D8(ctx, base);
	// 830F180C: 547C043E  clrlwi r28, r3, 0x10
	ctx.r[28].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F1810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1814: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 830F1818: 4BF166C1  bl 0x83007ed8
	ctx.lr = 0x830F181C;
	sub_83007ED8(ctx, base);
	// 830F181C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	pc = 0x830F1820; continue 'dispatch;
            }
            0x830F1820 => {
    //   block [0x830F1820..0x830F1830)
	// 830F1820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1824: 4BF1665D  bl 0x83007e80
	ctx.lr = 0x830F1828;
	sub_83007E80(ctx, base);
	// 830F1828: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F182C: 4182FFCC  beq 0x830f17f8
	if ctx.cr[0].eq {
	pc = 0x830F17F8; continue 'dispatch;
	}
	pc = 0x830F1830; continue 'dispatch;
            }
            0x830F1830 => {
    //   block [0x830F1830..0x830F1880)
	// 830F1830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F1834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1838: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830F183C: 4BBB93AD  bl 0x82caabe8
	ctx.lr = 0x830F1840;
	sub_82CAABE8(ctx, base);
	// 830F1840: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F1844: 419A003C  beq cr6, 0x830f1880
	if ctx.cr[6].eq {
	pc = 0x830F1880; continue 'dispatch;
	}
	// 830F1848: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F184C: 83DA000C  lwz r30, 0xc(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1850: 3BFA000C  addi r31, r26, 0xc
	ctx.r[31].s64 = ctx.r[26].s64 + 12;
	// 830F1854: 4BF1616D  bl 0x830079c0
	ctx.lr = 0x830F1858;
	sub_830079C0(ctx, base);
	// 830F1858: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F185C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 830F1860: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1864: 38EBA78C  addi r7, r11, -0x5874
	ctx.r[7].s64 = ctx.r[11].s64 + -22644;
	// 830F1868: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F186C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F1870: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 830F1874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1878: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F187C: 4BFFFE70  b 0x830f16ec
	pc = 0x830F16EC; continue 'dispatch;
            }
            0x830F1880 => {
    //   block [0x830F1880..0x830F1884)
	// 830F1880: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F1884; continue 'dispatch;
            }
            0x830F1884 => {
    //   block [0x830F1884..0x830F188C)
	// 830F1884: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 830F1888: 4BBB7BC8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1890 size=152
    let mut pc: u32 = 0x830F1890;
    'dispatch: loop {
        match pc {
            0x830F1890 => {
    //   block [0x830F1890..0x830F18E0)
	// 830F1890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F189C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F18A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F18A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F18A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F18AC: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 830F18B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F18B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F18B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830F18BC: B17F0020  sth r11, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 830F18C0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830F18C4: 4BFFFDAD  bl 0x830f1670
	ctx.lr = 0x830F18C8;
	sub_830F1670(ctx, base);
	// 830F18C8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F18CC: 4080001C  bge 0x830f18e8
	if !ctx.cr[0].lt {
	pc = 0x830F18E8; continue 'dispatch;
	}
	// 830F18D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F18D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F18D8: 419A0008  beq cr6, 0x830f18e0
	if ctx.cr[6].eq {
	pc = 0x830F18E0; continue 'dispatch;
	}
	// 830F18DC: 4B753ED5  bl 0x828457b0
	ctx.lr = 0x830F18E0;
	sub_828457B0(ctx, base);
	pc = 0x830F18E0; continue 'dispatch;
            }
            0x830F18E0 => {
    //   block [0x830F18E0..0x830F18E8)
	// 830F18E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F18E4: 4800002C  b 0x830f1910
	pc = 0x830F1910; continue 'dispatch;
            }
            0x830F18E8 => {
    //   block [0x830F18E8..0x830F190C)
	// 830F18E8: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F18EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F18F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F18F4: 4BFFFA7D  bl 0x830f1370
	ctx.lr = 0x830F18F8;
	sub_830F1370(ctx, base);
	// 830F18F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F18FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F1900: 419A000C  beq cr6, 0x830f190c
	if ctx.cr[6].eq {
	pc = 0x830F190C; continue 'dispatch;
	}
	// 830F1904: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1908: 4B753EA9  bl 0x828457b0
	ctx.lr = 0x830F190C;
	sub_828457B0(ctx, base);
	pc = 0x830F190C; continue 'dispatch;
            }
            0x830F190C => {
    //   block [0x830F190C..0x830F1910)
	// 830F190C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830F1910; continue 'dispatch;
            }
            0x830F1910 => {
    //   block [0x830F1910..0x830F1928)
	// 830F1910: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F1914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F191C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F1920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F1924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1928 size=132
    let mut pc: u32 = 0x830F1928;
    'dispatch: loop {
        match pc {
            0x830F1928 => {
    //   block [0x830F1928..0x830F1964)
	// 830F1928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F192C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1934: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F193C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1940: 38601028  li r3, 0x1028
	ctx.r[3].s64 = 4136;
	// 830F1944: 396BA8F0  addi r11, r11, -0x5710
	ctx.r[11].s64 = ctx.r[11].s64 + -22288;
	// 830F1948: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F194C: 4B1F886D  bl 0x822ea1b8
	ctx.lr = 0x830F1950;
	sub_822EA1B8(ctx, base);
	// 830F1950: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F1954: 41820010  beq 0x830f1964
	if ctx.cr[0].eq {
	pc = 0x830F1964; continue 'dispatch;
	}
	// 830F1958: 4BFFFCC9  bl 0x830f1620
	ctx.lr = 0x830F195C;
	sub_830F1620(ctx, base);
	// 830F195C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830F1960: 48000008  b 0x830f1968
	pc = 0x830F1968; continue 'dispatch;
            }
            0x830F1964 => {
    //   block [0x830F1964..0x830F1968)
	// 830F1964: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F1968; continue 'dispatch;
            }
            0x830F1968 => {
    //   block [0x830F1968..0x830F19AC)
	// 830F1968: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F196C: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 830F1970: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1974: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F1978: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F197C: 38EAA8D0  addi r7, r10, -0x5730
	ctx.r[7].s64 = ctx.r[10].s64 + -22320;
	// 830F1980: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F1984: 3880D8F3  li r4, -0x270d
	ctx.r[4].s64 = -9997;
	// 830F1988: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F198C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F1990: 4E800421  bctrl
	ctx.lr = 0x830F1994;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F1994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1998: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F199C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F19A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F19A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F19A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F19B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F19B0 size=76
    let mut pc: u32 = 0x830F19B0;
    'dispatch: loop {
        match pc {
            0x830F19B0 => {
    //   block [0x830F19B0..0x830F19E8)
	// 830F19B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F19B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F19B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F19BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F19C0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F19C4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F19C8: 396BA8F0  addi r11, r11, -0x5710
	ctx.r[11].s64 = ctx.r[11].s64 + -22288;
	// 830F19CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F19D0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F19D4: 419A0014  beq cr6, 0x830f19e8
	if ctx.cr[6].eq {
	pc = 0x830F19E8; continue 'dispatch;
	}
	// 830F19D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F19DC: 480045DD  bl 0x830f5fb8
	ctx.lr = 0x830F19E0;
	sub_830F5FB8(ctx, base);
	// 830F19E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F19E4: 4B753DCD  bl 0x828457b0
	ctx.lr = 0x830F19E8;
	sub_828457B0(ctx, base);
	pc = 0x830F19E8; continue 'dispatch;
            }
            0x830F19E8 => {
    //   block [0x830F19E8..0x830F19FC)
	// 830F19E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F19EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F19F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F19F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F19F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1A00 size=8
    let mut pc: u32 = 0x830F1A00;
    'dispatch: loop {
        match pc {
            0x830F1A00 => {
    //   block [0x830F1A00..0x830F1A08)
	// 830F1A00: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1A04: 4BFFFE8C  b 0x830f1890
	sub_830F1890(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1A08 size=76
    let mut pc: u32 = 0x830F1A08;
    'dispatch: loop {
        match pc {
            0x830F1A08 => {
    //   block [0x830F1A08..0x830F1A38)
	// 830F1A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1A10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F1A14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1A18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1A20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F1A24: 4BFFFF8D  bl 0x830f19b0
	ctx.lr = 0x830F1A28;
	sub_830F19B0(ctx, base);
	// 830F1A28: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1A2C: 4182000C  beq 0x830f1a38
	if ctx.cr[0].eq {
	pc = 0x830F1A38; continue 'dispatch;
	}
	// 830F1A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1A34: 4B753D7D  bl 0x828457b0
	ctx.lr = 0x830F1A38;
	sub_828457B0(ctx, base);
	pc = 0x830F1A38; continue 'dispatch;
            }
            0x830F1A38 => {
    //   block [0x830F1A38..0x830F1A54)
	// 830F1A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1A3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F1A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1A48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F1A4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F1A50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1A58 size=68
    let mut pc: u32 = 0x830F1A58;
    'dispatch: loop {
        match pc {
            0x830F1A58 => {
    //   block [0x830F1A58..0x830F1A9C)
	// 830F1A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1A60: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 830F1A64: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 830F1A68: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 830F1A6C: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 830F1A70: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 830F1A74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1A78: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830F1A7C: 39410088  addi r10, r1, 0x88
	ctx.r[10].s64 = ctx.r[1].s64 + 136;
	// 830F1A80: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F1A84: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F1A88: 48000A59  bl 0x830f24e0
	ctx.lr = 0x830F1A8C;
	sub_830F24E0(ctx, base);
	// 830F1A8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1A90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1A94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1AA0 size=84
    let mut pc: u32 = 0x830F1AA0;
    'dispatch: loop {
        match pc {
            0x830F1AA0 => {
    //   block [0x830F1AA0..0x830F1AE4)
	// 830F1AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1AA8: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 830F1AAC: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 830F1AB0: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 830F1AB4: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 830F1AB8: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 830F1ABC: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 830F1AC0: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 830F1AC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1AC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F1ACC: 419A0018  beq cr6, 0x830f1ae4
	if ctx.cr[6].eq {
	pc = 0x830F1AE4; continue 'dispatch;
	}
	// 830F1AD0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830F1AD4: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 830F1AD8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F1ADC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F1AE0: 4BBBF039  bl 0x82cb0b18
	ctx.lr = 0x830F1AE4;
	sub_82CB0B18(ctx, base);
	pc = 0x830F1AE4; continue 'dispatch;
            }
            0x830F1AE4 => {
    //   block [0x830F1AE4..0x830F1AF4)
	// 830F1AE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1AF8 size=68
    let mut pc: u32 = 0x830F1AF8;
    'dispatch: loop {
        match pc {
            0x830F1AF8 => {
    //   block [0x830F1AF8..0x830F1B3C)
	// 830F1AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1B00: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 830F1B04: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 830F1B08: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 830F1B0C: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 830F1B10: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 830F1B14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1B18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830F1B1C: 39410088  addi r10, r1, 0x88
	ctx.r[10].s64 = ctx.r[1].s64 + 136;
	// 830F1B20: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F1B24: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F1B28: 4BBCCEE1  bl 0x82cbea08
	ctx.lr = 0x830F1B2C;
	sub_82CBEA08(ctx, base);
	// 830F1B2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1B30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1B34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1B38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F1B40 size=80
    let mut pc: u32 = 0x830F1B40;
    'dispatch: loop {
        match pc {
            0x830F1B40 => {
    //   block [0x830F1B40..0x830F1B54)
	// 830F1B40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F1B44: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 830F1B48: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1B4C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830F1B50: 4800000C  b 0x830f1b5c
	pc = 0x830F1B5C; continue 'dispatch;
            }
            0x830F1B54 => {
    //   block [0x830F1B54..0x830F1B5C)
	// 830F1B54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F1B58: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830F1B5C; continue 'dispatch;
            }
            0x830F1B5C => {
    //   block [0x830F1B5C..0x830F1B68)
	// 830F1B5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F1B60: 409AFFF4  bne cr6, 0x830f1b54
	if !ctx.cr[6].eq {
	pc = 0x830F1B54; continue 'dispatch;
	}
	// 830F1B64: 4800001C  b 0x830f1b80
	pc = 0x830F1B80; continue 'dispatch;
            }
            0x830F1B68 => {
    //   block [0x830F1B68..0x830F1B80)
	// 830F1B68: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1B6C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830F1B70: 2F0A005C  cmpwi cr6, r10, 0x5c
	ctx.cr[6].compare_i32(ctx.r[10].s32, 92, &mut ctx.xer);
	// 830F1B74: 419A001C  beq cr6, 0x830f1b90
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x830F1B90);
		return;
	}
	// 830F1B78: 2F0A002F  cmpwi cr6, r10, 0x2f
	ctx.cr[6].compare_i32(ctx.r[10].s32, 47, &mut ctx.xer);
	// 830F1B7C: 419A0014  beq cr6, 0x830f1b90
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x830F1B90);
		return;
	}
	pc = 0x830F1B80; continue 'dispatch;
            }
            0x830F1B80 => {
    //   block [0x830F1B80..0x830F1B90)
	// 830F1B80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1B84: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F1B88: 4098FFE0  bge cr6, 0x830f1b68
	if !ctx.cr[6].lt {
	pc = 0x830F1B68; continue 'dispatch;
	}
	// 830F1B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1B98 size=544
    let mut pc: u32 = 0x830F1B98;
    'dispatch: loop {
        match pc {
            0x830F1B98 => {
    //   block [0x830F1B98..0x830F1BE4)
	// 830F1B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1B9C: 4BBB7855  bl 0x82ca93f0
	ctx.lr = 0x830F1BA0;
	sub_82CA93D0(ctx, base);
	// 830F1BA0: 3BE1FEF0  addi r31, r1, -0x110
	ctx.r[31].s64 = ctx.r[1].s64 + -272;
	// 830F1BA4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1BA8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F1BAC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F1BB0: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 830F1BB4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830F1BB8: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 830F1BBC: 896B1F94  lbz r11, 0x1f94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8084 as u32) ) } as u64;
	// 830F1BC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F1BC4: 408201E8  bne 0x830f1dac
	if !ctx.cr[0].eq {
	pc = 0x830F1DAC; continue 'dispatch;
	}
	// 830F1BC8: 3EE08336  lis r23, -0x7cca
	ctx.r[23].s64 = -2093613056;
	// 830F1BCC: 8177BBA4  lwz r11, -0x445c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-17500 as u32) ) } as u64;
	// 830F1BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F1BD4: 419A01D8  beq cr6, 0x830f1dac
	if ctx.cr[6].eq {
	pc = 0x830F1DAC; continue 'dispatch;
	}
	// 830F1BD8: 572B077F  clrlwi. r11, r25, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1BDC: 40820008  bne 0x830f1be4
	if !ctx.cr[0].eq {
	pc = 0x830F1BE4; continue 'dispatch;
	}
	// 830F1BE0: 3B200007  li r25, 7
	ctx.r[25].s64 = 7;
	pc = 0x830F1BE4; continue 'dispatch;
            }
            0x830F1BE4 => {
    //   block [0x830F1BE4..0x830F1C04)
	// 830F1BE4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1BE8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830F1BEC: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1BF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F1BF4: 419A0010  beq cr6, 0x830f1c04
	if ctx.cr[6].eq {
	pc = 0x830F1C04; continue 'dispatch;
	}
	// 830F1BF8: 4BFFFF49  bl 0x830f1b40
	ctx.lr = 0x830F1BFC;
	sub_830F1B40(ctx, base);
	// 830F1BFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830F1C00: 48000008  b 0x830f1c08
	pc = 0x830F1C08; continue 'dispatch;
            }
            0x830F1C04 => {
    //   block [0x830F1C04..0x830F1C08)
	// 830F1C04: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	pc = 0x830F1C08; continue 'dispatch;
            }
            0x830F1C08 => {
    //   block [0x830F1C08..0x830F1C5C)
	// 830F1C08: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1C0C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F1C10: 3BCBA93C  addi r30, r11, -0x56c4
	ctx.r[30].s64 = ctx.r[11].s64 + -22212;
	// 830F1C14: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F1C18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1C1C: 4BFFFE85  bl 0x830f1aa0
	ctx.lr = 0x830F1C20;
	sub_830F1AA0(ctx, base);
	// 830F1C20: 3BA30001  addi r29, r3, 1
	ctx.r[29].s64 = ctx.r[3].s64 + 1;
	// 830F1C24: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1C28: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 830F1C2C: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F1C30: 4BBBEA25  bl 0x82cb0654
	ctx.lr = 0x830F1C34;
	sub_82CB0654(ctx, base);
	// 830F1C34: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1C38: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1C3C: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1C40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F1C44: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 830F1C48: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 830F1C4C: 419A0010  beq cr6, 0x830f1c5c
	if ctx.cr[6].eq {
	pc = 0x830F1C5C; continue 'dispatch;
	}
	// 830F1C50: 4BFFFEF1  bl 0x830f1b40
	ctx.lr = 0x830F1C54;
	sub_830F1B40(ctx, base);
	// 830F1C54: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830F1C58: 48000008  b 0x830f1c60
	pc = 0x830F1C60; continue 'dispatch;
            }
            0x830F1C5C => {
    //   block [0x830F1C5C..0x830F1C60)
	// 830F1C5C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	pc = 0x830F1C60; continue 'dispatch;
            }
            0x830F1C60 => {
    //   block [0x830F1C60..0x830F1CA0)
	// 830F1C60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F1C64: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 830F1C68: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830F1C6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F1C70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830F1C74: 4BFFFE85  bl 0x830f1af8
	ctx.lr = 0x830F1C78;
	sub_830F1AF8(ctx, base);
	// 830F1C78: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1C7C: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 830F1C80: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 830F1C84: 4182001C  beq 0x830f1ca0
	if ctx.cr[0].eq {
	pc = 0x830F1CA0; continue 'dispatch;
	}
	// 830F1C88: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1C8C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 830F1C90: 396BA928  addi r11, r11, -0x56d8
	ctx.r[11].s64 = ctx.r[11].s64 + -22232;
	// 830F1C94: 915F0080  stw r10, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 830F1C98: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F1C9C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	pc = 0x830F1CA0; continue 'dispatch;
            }
            0x830F1CA0 => {
    //   block [0x830F1CA0..0x830F1CD0)
	// 830F1CA0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1CA4: 572A077B  rlwinm. r10, r25, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F1CA8: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 830F1CAC: 3B8BA91C  addi r28, r11, -0x56e4
	ctx.r[28].s64 = ctx.r[11].s64 + -22244;
	// 830F1CB0: 41820020  beq 0x830f1cd0
	if ctx.cr[0].eq {
	pc = 0x830F1CD0; continue 'dispatch;
	}
	// 830F1CB4: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1CB8: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 830F1CBC: 393F0070  addi r9, r31, 0x70
	ctx.r[9].s64 = ctx.r[31].s64 + 112;
	// 830F1CC0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F1CC4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830F1CC8: 7F6B512E  stwx r27, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[27].u32) };
	// 830F1CCC: 7F8B492E  stwx r28, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[28].u32) };
	pc = 0x830F1CD0; continue 'dispatch;
            }
            0x830F1CD0 => {
    //   block [0x830F1CD0..0x830F1CFC)
	// 830F1CD0: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1CD4: 41820028  beq 0x830f1cfc
	if ctx.cr[0].eq {
	pc = 0x830F1CFC; continue 'dispatch;
	}
	// 830F1CD8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1CDC: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 830F1CE0: 393F0070  addi r9, r31, 0x70
	ctx.r[9].s64 = ctx.r[31].s64 + 112;
	// 830F1CE4: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 830F1CE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830F1CEC: 3908A900  addi r8, r8, -0x5700
	ctx.r[8].s64 = ctx.r[8].s64 + -22272;
	// 830F1CF0: 7CEB512E  stwx r7, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 830F1CF4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F1CF8: 7D0B492E  stwx r8, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	pc = 0x830F1CFC; continue 'dispatch;
            }
            0x830F1CFC => {
    //   block [0x830F1CFC..0x830F1D40)
	// 830F1CFC: 397F0090  addi r11, r31, 0x90
	ctx.r[11].s64 = ctx.r[31].s64 + 144;
	// 830F1D00: 8097BBA4  lwz r4, -0x445c(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-17500 as u32) ) } as u64;
	// 830F1D04: 395F0068  addi r10, r31, 0x68
	ctx.r[10].s64 = ctx.r[31].s64 + 104;
	// 830F1D08: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 830F1D0C: FB0B0000  std r24, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u64 ) };
	// 830F1D10: FB0B0008  std r24, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[24].u64 ) };
	// 830F1D14: FB0B0010  std r24, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[24].u64 ) };
	// 830F1D18: FB0A0000  std r24, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u64 ) };
	// 830F1D1C: 930B0018  stw r24, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 830F1D20: 480042A9  bl 0x830f5fc8
	ctx.lr = 0x830F1D24;
	sub_830F5FC8(ctx, base);
	// 830F1D24: 897F0064  lbz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830F1D28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F1D2C: 41820014  beq 0x830f1d40
	if ctx.cr[0].eq {
	pc = 0x830F1D40; continue 'dispatch;
	}
	// 830F1D30: 939F0070  stw r28, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 830F1D34: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 830F1D38: 937F0080  stw r27, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 830F1D3C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x830F1D40; continue 'dispatch;
            }
            0x830F1D40 => {
    //   block [0x830F1D40..0x830F1D74)
	// 830F1D40: 397F0090  addi r11, r31, 0x90
	ctx.r[11].s64 = ctx.r[31].s64 + 144;
	// 830F1D44: 395F0068  addi r10, r31, 0x68
	ctx.r[10].s64 = ctx.r[31].s64 + 104;
	// 830F1D48: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F1D4C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F1D50: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 830F1D54: 38FF0070  addi r7, r31, 0x70
	ctx.r[7].s64 = ctx.r[31].s64 + 112;
	// 830F1D58: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F1D5C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830F1D60: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 830F1D64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F1D68: 4BBD1159  bl 0x82cc2ec0
	ctx.lr = 0x830F1D6C;
	sub_82CC2EC0(ctx, base);
	// 830F1D6C: 2B0303E5  cmplwi cr6, r3, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 997 as u32, &mut ctx.xer);
	// 830F1D70: 409AFFD0  bne cr6, 0x830f1d40
	if !ctx.cr[6].eq {
	pc = 0x830F1D40; continue 'dispatch;
	}
	pc = 0x830F1D74; continue 'dispatch;
            }
            0x830F1D74 => {
    //   block [0x830F1D74..0x830F1DA4)
	// 830F1D74: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830F1D78: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 830F1D7C: 419AFFF8  beq cr6, 0x830f1d74
	if ctx.cr[6].eq {
	pc = 0x830F1D74; continue 'dispatch;
	}
	// 830F1D80: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 830F1D84: 48004305  bl 0x830f6088
	ctx.lr = 0x830F1D88;
	sub_830F6088(ctx, base);
	// 830F1D88: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830F1D8C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830F1D90: 40980014  bge cr6, 0x830f1da4
	if !ctx.cr[6].lt {
	pc = 0x830F1DA4; continue 'dispatch;
	}
	// 830F1D94: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1D98: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 830F1D9C: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830F1DA0: 48000010  b 0x830f1db0
	pc = 0x830F1DB0; continue 'dispatch;
            }
            0x830F1DA4 => {
    //   block [0x830F1DA4..0x830F1DAC)
	// 830F1DA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F1DA8: 48000008  b 0x830f1db0
	pc = 0x830F1DB0; continue 'dispatch;
            }
            0x830F1DAC => {
    //   block [0x830F1DAC..0x830F1DB0)
	// 830F1DAC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	pc = 0x830F1DB0; continue 'dispatch;
            }
            0x830F1DB0 => {
    //   block [0x830F1DB0..0x830F1DB8)
	// 830F1DB0: 383F0110  addi r1, r31, 0x110
	ctx.r[1].s64 = ctx.r[31].s64 + 272;
	// 830F1DB4: 4BBB768C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1DB8 size=212
    let mut pc: u32 = 0x830F1DB8;
    'dispatch: loop {
        match pc {
            0x830F1DB8 => {
    //   block [0x830F1DB8..0x830F1DE4)
	// 830F1DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1DBC: 4BBB764D  bl 0x82ca9408
	ctx.lr = 0x830F1DC0;
	sub_82CA93D0(ctx, base);
	// 830F1DC0: 3BE1FF80  addi r31, r1, -0x80
	ctx.r[31].s64 = ctx.r[1].s64 + -128;
	// 830F1DC4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1DC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F1DCC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F1DD0: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F1DD4: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F1DD8: 4082000C  bne 0x830f1de4
	if !ctx.cr[0].eq {
	pc = 0x830F1DE4; continue 'dispatch;
	}
	// 830F1DDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F1DE0: 48000024  b 0x830f1e04
	pc = 0x830F1E04; continue 'dispatch;
            }
            0x830F1DE4 => {
    //   block [0x830F1DE4..0x830F1DE8)
	// 830F1DE4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x830F1DE8; continue 'dispatch;
            }
            0x830F1DE8 => {
    //   block [0x830F1DE8..0x830F1E04)
	// 830F1DE8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1DEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F1DF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F1DF4: 409AFFF4  bne cr6, 0x830f1de8
	if !ctx.cr[6].eq {
	pc = 0x830F1DE8; continue 'dispatch;
	}
	// 830F1DF8: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 830F1DFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1E00: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x830F1E04; continue 'dispatch;
            }
            0x830F1E04 => {
    //   block [0x830F1E04..0x830F1E74)
	// 830F1E04: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 830F1E08: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1E0C: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 830F1E10: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F1E14: 4BBBE841  bl 0x82cb0654
	ctx.lr = 0x830F1E18;
	sub_82CB0654(ctx, base);
	// 830F1E18: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1E1C: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 830F1E20: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 830F1E24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F1E28: 4BFFF4F9  bl 0x830f1320
	ctx.lr = 0x830F1E2C;
	sub_830F1320(ctx, base);
	// 830F1E2C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1E30: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830F1E34: 38ABA964  addi r5, r11, -0x569c
	ctx.r[5].s64 = ctx.r[11].s64 + -22172;
	// 830F1E38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F1E3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F1E40: 4BFFFC19  bl 0x830f1a58
	ctx.lr = 0x830F1E44;
	sub_830F1A58(ctx, base);
	// 830F1E44: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1E48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1E4C: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 830F1E50: 388BA954  addi r4, r11, -0x56ac
	ctx.r[4].s64 = ctx.r[11].s64 + -22188;
	// 830F1E54: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F1E58: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F1E5C: 4BFFFD3D  bl 0x830f1b98
	ctx.lr = 0x830F1E60;
	sub_830F1B98(ctx, base);
	// 830F1E60: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830F1E64: 419A0010  beq cr6, 0x830f1e74
	if ctx.cr[6].eq {
	pc = 0x830F1E74; continue 'dispatch;
	}
	// 830F1E68: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 830F1E6C: 419A0010  beq cr6, 0x830f1e7c
	if ctx.cr[6].eq {
	pc = 0x830F1E7C; continue 'dispatch;
	}
	// 830F1E70: 48000010  b 0x830f1e80
	pc = 0x830F1E80; continue 'dispatch;
            }
            0x830F1E74 => {
    //   block [0x830F1E74..0x830F1E7C)
	// 830F1E74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F1E78: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x830F1E7C; continue 'dispatch;
            }
            0x830F1E7C => {
    //   block [0x830F1E7C..0x830F1E80)
	// 830F1E7C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x830F1E80; continue 'dispatch;
            }
            0x830F1E80 => {
    //   block [0x830F1E80..0x830F1E8C)
	// 830F1E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1E84: 383F0080  addi r1, r31, 0x80
	ctx.r[1].s64 = ctx.r[31].s64 + 128;
	// 830F1E88: 4BBB75D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1E90 size=272
    let mut pc: u32 = 0x830F1E90;
    'dispatch: loop {
        match pc {
            0x830F1E90 => {
    //   block [0x830F1E90..0x830F1F88)
	// 830F1E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1E94: 4BBB756D  bl 0x82ca9400
	ctx.lr = 0x830F1E98;
	sub_82CA93D0(ctx, base);
	// 830F1E98: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 830F1E9C: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 830F1EA0: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 830F1EA4: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 830F1EA8: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 830F1EAC: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 830F1EB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1EB4: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 830F1EB8: 395F00B8  addi r10, r31, 0xb8
	ctx.r[10].s64 = ctx.r[31].s64 + 184;
	// 830F1EBC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830F1EC0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830F1EC4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F1EC8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F1ECC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830F1ED0: 83BF0050  lwz r29, 0x50(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F1ED4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F1ED8: 4BBBB781  bl 0x82cad658
	ctx.lr = 0x830F1EDC;
	sub_82CAD658(ctx, base);
	// 830F1EDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F1EE0: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 830F1EE4: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 830F1EE8: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F1EEC: 4BBBE769  bl 0x82cb0654
	ctx.lr = 0x830F1EF0;
	sub_82CB0654(ctx, base);
	// 830F1EF0: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1EF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F1EF8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F1EFC: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 830F1F00: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 830F1F04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F1F08: 4B0D4949  bl 0x821c6850
	ctx.lr = 0x830F1F0C;
	sub_821C6850(ctx, base);
	// 830F1F0C: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 830F1F10: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1F14: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 830F1F18: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F1F1C: 4BBBE739  bl 0x82cb0654
	ctx.lr = 0x830F1F20;
	sub_82CB0654(ctx, base);
	// 830F1F20: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1F24: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F1F28: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F1F2C: 388AA70C  addi r4, r10, -0x58f4
	ctx.r[4].s64 = ctx.r[10].s64 + -22772;
	// 830F1F30: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 830F1F34: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 830F1F38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1F3C: 4BE036ED  bl 0x82ef5628
	ctx.lr = 0x830F1F40;
	sub_82EF5628(ctx, base);
	// 830F1F40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1F44: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F1F48: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F1F4C: 38ABA964  addi r5, r11, -0x569c
	ctx.r[5].s64 = ctx.r[11].s64 + -22172;
	// 830F1F50: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F1F54: 4BFFFB05  bl 0x830f1a58
	ctx.lr = 0x830F1F58;
	sub_830F1A58(ctx, base);
	// 830F1F58: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F1F5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F1F60: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 830F1F64: 388BA954  addi r4, r11, -0x56ac
	ctx.r[4].s64 = ctx.r[11].s64 + -22188;
	// 830F1F68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F1F6C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F1F70: 4BFFFC29  bl 0x830f1b98
	ctx.lr = 0x830F1F74;
	sub_830F1B98(ctx, base);
	// 830F1F74: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830F1F78: 419A0010  beq cr6, 0x830f1f88
	if ctx.cr[6].eq {
	pc = 0x830F1F88; continue 'dispatch;
	}
	// 830F1F7C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 830F1F80: 419A0010  beq cr6, 0x830f1f90
	if ctx.cr[6].eq {
	pc = 0x830F1F90; continue 'dispatch;
	}
	// 830F1F84: 48000010  b 0x830f1f94
	pc = 0x830F1F94; continue 'dispatch;
            }
            0x830F1F88 => {
    //   block [0x830F1F88..0x830F1F90)
	// 830F1F88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F1F8C: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x830F1F90; continue 'dispatch;
            }
            0x830F1F90 => {
    //   block [0x830F1F90..0x830F1F94)
	// 830F1F90: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x830F1F94; continue 'dispatch;
            }
            0x830F1F94 => {
    //   block [0x830F1F94..0x830F1FA0)
	// 830F1F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1F98: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 830F1F9C: 4BBB74B4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1FA0 size=128
    let mut pc: u32 = 0x830F1FA0;
    'dispatch: loop {
        match pc {
            0x830F1FA0 => {
    //   block [0x830F1FA0..0x830F1FE4)
	// 830F1FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1FA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F1FAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1FB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1FB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F1FB8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F1FC0: 419A0048  beq cr6, 0x830f2008
	if ctx.cr[6].eq {
	pc = 0x830F2008; continue 'dispatch;
	}
	// 830F1FC4: 4B12CD45  bl 0x8221ed08
	ctx.lr = 0x830F1FC8;
	sub_8221ED08(ctx, base);
	// 830F1FC8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1FD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F1FD4: 4BAB02ED  bl 0x82ba22c0
	ctx.lr = 0x830F1FD8;
	sub_82BA22C0(ctx, base);
	// 830F1FD8: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F1FDC: 419A0008  beq cr6, 0x830f1fe4
	if ctx.cr[6].eq {
	pc = 0x830F1FE4; continue 'dispatch;
	}
	// 830F1FE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F1FE4; continue 'dispatch;
            }
            0x830F1FE4 => {
    //   block [0x830F1FE4..0x830F2004)
	// 830F1FE4: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 830F1FE8: 807FBBAC  lwz r3, -0x4454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17492 as u32) ) } as u64;
	// 830F1FEC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F1FF0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F1FF4: 409A0010  bne cr6, 0x830f2004
	if !ctx.cr[6].eq {
	pc = 0x830F2004; continue 'dispatch;
	}
	// 830F1FF8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1FFC: 4BAB02B5  bl 0x82ba22b0
	ctx.lr = 0x830F2000;
	sub_82BA22B0(ctx, base);
	// 830F2000: 807FBBAC  lwz r3, -0x4454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17492 as u32) ) } as u64;
	pc = 0x830F2004; continue 'dispatch;
            }
            0x830F2004 => {
    //   block [0x830F2004..0x830F2008)
	// 830F2004: 481C7951  bl 0x832b9954
	ctx.lr = 0x830F2008;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x830F2008; continue 'dispatch;
            }
            0x830F2008 => {
    //   block [0x830F2008..0x830F2020)
	// 830F2008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F200C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2014: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F2018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F201C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2020 size=92
    let mut pc: u32 = 0x830F2020;
    'dispatch: loop {
        match pc {
            0x830F2020 => {
    //   block [0x830F2020..0x830F2064)
	// 830F2020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2028: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F202C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2030: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 830F2034: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F2038: 3BEBBBB0  addi r31, r11, -0x4450
	ctx.r[31].s64 = ctx.r[11].s64 + -17488;
	// 830F203C: 816ABBCC  lwz r11, -0x4434(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17460 as u32) ) } as u64;
	// 830F2040: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F2044: 40820020  bne 0x830f2064
	if !ctx.cr[0].eq {
	pc = 0x830F2064; continue 'dispatch;
	}
	// 830F2048: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830F204C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2050: 916ABBCC  stw r11, -0x4434(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17460 as u32), ctx.r[11].u32 ) };
	// 830F2054: 481C7C31  bl 0x832b9c84
	ctx.lr = 0x830F2058;
	// extern call 0x832B9C84  crate::xboxkrnl::RtlInitializeCriticalSection
	crate::xboxkrnl::RtlInitializeCriticalSection(ctx, base);
	// 830F2058: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 830F205C: 386B98E0  addi r3, r11, -0x6720
	ctx.r[3].s64 = ctx.r[11].s64 + -26400;
	// 830F2060: 4BBB7EC1  bl 0x82ca9f20
	ctx.lr = 0x830F2064;
	sub_82CA9F20(ctx, base);
	pc = 0x830F2064; continue 'dispatch;
            }
            0x830F2064 => {
    //   block [0x830F2064..0x830F207C)
	// 830F2064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2068: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F206C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2070: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2080 size=108
    let mut pc: u32 = 0x830F2080;
    'dispatch: loop {
        match pc {
            0x830F2080 => {
    //   block [0x830F2080..0x830F20B0)
	// 830F2080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F208C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2090: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 830F2094: 817FBBAC  lwz r11, -0x4454(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17492 as u32) ) } as u64;
	// 830F2098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F209C: 419A0020  beq cr6, 0x830f20bc
	if ctx.cr[6].eq {
	pc = 0x830F20BC; continue 'dispatch;
	}
	// 830F20A0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F20A4: 409A000C  bne cr6, 0x830f20b0
	if !ctx.cr[6].eq {
	pc = 0x830F20B0; continue 'dispatch;
	}
	// 830F20A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F20AC: 4800002C  b 0x830f20d8
	pc = 0x830F20D8; continue 'dispatch;
            }
            0x830F20B0 => {
    //   block [0x830F20B0..0x830F20BC)
	// 830F20B0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F20B4: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 830F20B8: 48000020  b 0x830f20d8
	pc = 0x830F20D8; continue 'dispatch;
            }
            0x830F20BC => {
    //   block [0x830F20BC..0x830F20D0)
	// 830F20BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F20C0: 409A0010  bne cr6, 0x830f20d0
	if !ctx.cr[6].eq {
	pc = 0x830F20D0; continue 'dispatch;
	}
	// 830F20C4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F20C8: 386BBBA8  addi r3, r11, -0x4458
	ctx.r[3].s64 = ctx.r[11].s64 + -17496;
	// 830F20CC: 4BFFFF55  bl 0x830f2020
	ctx.lr = 0x830F20D0;
	sub_830F2020(ctx, base);
	pc = 0x830F20D0; continue 'dispatch;
            }
            0x830F20D0 => {
    //   block [0x830F20D0..0x830F20D8)
	// 830F20D0: 907FBBAC  stw r3, -0x4454(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-17492 as u32), ctx.r[3].u32 ) };
	// 830F20D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F20D8; continue 'dispatch;
            }
            0x830F20D8 => {
    //   block [0x830F20D8..0x830F20EC)
	// 830F20D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F20DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F20E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F20E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F20E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F20F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F20F0 size=132
    let mut pc: u32 = 0x830F20F0;
    'dispatch: loop {
        match pc {
            0x830F20F0 => {
    //   block [0x830F20F0..0x830F2118)
	// 830F20F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F20F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F20F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F20FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F2100: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2104: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F2108: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F210C: 909E0000  stw r4, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 830F2110: 409A0008  bne cr6, 0x830f2118
	if !ctx.cr[6].eq {
	pc = 0x830F2118; continue 'dispatch;
	}
	// 830F2114: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F2118; continue 'dispatch;
            }
            0x830F2118 => {
    //   block [0x830F2118..0x830F2130)
	// 830F2118: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 830F211C: 807FBBAC  lwz r3, -0x4454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17492 as u32) ) } as u64;
	// 830F2120: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F2124: 409A000C  bne cr6, 0x830f2130
	if !ctx.cr[6].eq {
	pc = 0x830F2130; continue 'dispatch;
	}
	// 830F2128: 4BFFFF59  bl 0x830f2080
	ctx.lr = 0x830F212C;
	sub_830F2080(ctx, base);
	// 830F212C: 807FBBAC  lwz r3, -0x4454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17492 as u32) ) } as u64;
	pc = 0x830F2130; continue 'dispatch;
            }
            0x830F2130 => {
    //   block [0x830F2130..0x830F2158)
	// 830F2130: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2138: 419A0020  beq cr6, 0x830f2158
	if ctx.cr[6].eq {
	pc = 0x830F2158; continue 'dispatch;
	}
	// 830F213C: 481C7829  bl 0x832b9964
	ctx.lr = 0x830F2140;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830F2140: 817FBBAC  lwz r11, -0x4454(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17492 as u32) ) } as u64;
	// 830F2144: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F2148: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F214C: 409A000C  bne cr6, 0x830f2158
	if !ctx.cr[6].eq {
	pc = 0x830F2158; continue 'dispatch;
	}
	// 830F2150: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2154: 4BAB011D  bl 0x82ba2270
	ctx.lr = 0x830F2158;
	sub_82BA2270(ctx, base);
	pc = 0x830F2158; continue 'dispatch;
            }
            0x830F2158 => {
    //   block [0x830F2158..0x830F2174)
	// 830F2158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F215C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F2160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2168: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F216C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830F2178 size=240
    let mut pc: u32 = 0x830F2178;
    'dispatch: loop {
        match pc {
            0x830F2178 => {
    //   block [0x830F2178..0x830F219C)
	// 830F2178: 7CCB0734  extsh r11, r6
	ctx.r[11].s64 = ctx.r[6].s16 as i64;
	// 830F217C: 7C880734  extsh r8, r4
	ctx.r[8].s64 = ctx.r[4].s16 as i64;
	// 830F2180: 7D4B00D0  neg r10, r11
	ctx.r[10].s64 = -ctx.r[11].s64;
	// 830F2184: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 830F2188: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830F218C: 41990010  bgt cr6, 0x830f219c
	if ctx.cr[6].gt {
	pc = 0x830F219C; continue 'dispatch;
	}
	// 830F2190: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F2194: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F2198: 40990008  ble cr6, 0x830f21a0
	if !ctx.cr[6].gt {
	pc = 0x830F21A0; continue 'dispatch;
	}
	pc = 0x830F219C; continue 'dispatch;
            }
            0x830F219C => {
    //   block [0x830F219C..0x830F21A0)
	// 830F219C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x830F21A0; continue 'dispatch;
            }
            0x830F21A0 => {
    //   block [0x830F21A0..0x830F21C0)
	// 830F21A0: 5529063F  clrlwi. r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F21A4: 41820038  beq 0x830f21dc
	if ctx.cr[0].eq {
	pc = 0x830F21DC; continue 'dispatch;
	}
	// 830F21A8: 7CA90734  extsh r9, r5
	ctx.r[9].s64 = ctx.r[5].s16 as i64;
	// 830F21AC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830F21B0: 41990010  bgt cr6, 0x830f21c0
	if ctx.cr[6].gt {
	pc = 0x830F21C0; continue 'dispatch;
	}
	// 830F21B4: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F21B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F21BC: 40990008  ble cr6, 0x830f21c4
	if !ctx.cr[6].gt {
	pc = 0x830F21C4; continue 'dispatch;
	}
	pc = 0x830F21C0; continue 'dispatch;
            }
            0x830F21C0 => {
    //   block [0x830F21C0..0x830F21C4)
	// 830F21C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F21C4; continue 'dispatch;
            }
            0x830F21C4 => {
    //   block [0x830F21C4..0x830F21DC)
	// 830F21C4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F21C8: 41820014  beq 0x830f21dc
	if ctx.cr[0].eq {
	pc = 0x830F21DC; continue 'dispatch;
	}
	// 830F21CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F21D0: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F21D4: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830F21D8: 48000088  b 0x830f2260
	pc = 0x830F2260; continue 'dispatch;
            }
            0x830F21DC => {
    //   block [0x830F21DC..0x830F2210)
	// 830F21DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F21E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F21E4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830F21E8: C18B0C58  lfs f12, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F21EC: 7D0B07B4  extsw r11, r8
	ctx.r[11].s64 = ctx.r[8].s32 as i64;
	// 830F21F0: C1AA0C20  lfs f13, 0xc20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F21F4: 4098001C  bge cr6, 0x830f2210
	if !ctx.cr[6].lt {
	pc = 0x830F2210; continue 'dispatch;
	}
	// 830F21F8: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 830F21FC: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2200: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F2204: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F2208: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830F220C: 48000018  b 0x830f2224
	pc = 0x830F2224; continue 'dispatch;
            }
            0x830F2210 => {
    //   block [0x830F2210..0x830F2224)
	// 830F2210: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 830F2214: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2218: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F221C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F2220: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x830F2224; continue 'dispatch;
            }
            0x830F2224 => {
    //   block [0x830F2224..0x830F224C)
	// 830F2224: 7CAB0735  extsh. r11, r5
	ctx.r[11].s64 = ctx.r[5].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2228: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830F222C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830F2230: 4080001C  bge 0x830f224c
	if !ctx.cr[0].lt {
	pc = 0x830F224C; continue 'dispatch;
	}
	// 830F2234: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 830F2238: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F223C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F2240: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F2244: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830F2248: 48000018  b 0x830f2260
	pc = 0x830F2260; continue 'dispatch;
            }
            0x830F224C => {
    //   block [0x830F224C..0x830F2260)
	// 830F224C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 830F2250: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2254: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F2258: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F225C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x830F2260; continue 'dispatch;
            }
            0x830F2260 => {
    //   block [0x830F2260..0x830F2268)
	// 830F2260: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F2264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F2268 size=80
    let mut pc: u32 = 0x830F2268;
    'dispatch: loop {
        match pc {
            0x830F2268 => {
    //   block [0x830F2268..0x830F22B8)
	// 830F2268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F226C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2270: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F2274: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2278: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F227C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F2280: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 830F2284: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F2288: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F228C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830F2290: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830F2294: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830F2298: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830F229C: 4BBB7715  bl 0x82ca99b0
	ctx.lr = 0x830F22A0;
	sub_82CA99B0(ctx, base);
	// 830F22A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F22A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F22A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F22AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F22B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F22B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F22B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F22B8 size=364
    let mut pc: u32 = 0x830F22B8;
    'dispatch: loop {
        match pc {
            0x830F22B8 => {
    //   block [0x830F22B8..0x830F22FC)
	// 830F22B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F22BC: 4BBB7151  bl 0x82ca940c
	ctx.lr = 0x830F22C0;
	sub_82CA93D0(ctx, base);
	// 830F22C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F22C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F22C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F22CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F22D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F22D4: 8BBF003C  lbz r29, 0x3c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830F22D8: 4B1C0C51  bl 0x822b2f28
	ctx.lr = 0x830F22DC;
	sub_822B2F28(ctx, base);
	// 830F22DC: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830F22E0: 7FABEB79  or. r11, r29, r29
	ctx.r[11].u64 = ctx.r[29].u64 | ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F22E4: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 830F22E8: 993F003C  stb r9, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u8 ) };
	// 830F22EC: 41820010  beq 0x830f22fc
	if ctx.cr[0].eq {
	pc = 0x830F22FC; continue 'dispatch;
	}
	// 830F22F0: 552A063F  clrlwi. r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F22F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F22F8: 41820008  beq 0x830f2300
	if ctx.cr[0].eq {
	pc = 0x830F2300; continue 'dispatch;
	}
	pc = 0x830F22FC; continue 'dispatch;
            }
            0x830F22FC => {
    //   block [0x830F22FC..0x830F2300)
	// 830F22FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F2300; continue 'dispatch;
            }
            0x830F2300 => {
    //   block [0x830F2300..0x830F2318)
	// 830F2300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2304: 995F003E  stb r10, 0x3e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(62 as u32), ctx.r[10].u8 ) };
	// 830F2308: 409A0010  bne cr6, 0x830f2318
	if !ctx.cr[6].eq {
	pc = 0x830F2318; continue 'dispatch;
	}
	// 830F230C: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2314: 40820008  bne 0x830f231c
	if !ctx.cr[0].eq {
	pc = 0x830F231C; continue 'dispatch;
	}
	pc = 0x830F2318; continue 'dispatch;
            }
            0x830F2318 => {
    //   block [0x830F2318..0x830F231C)
	// 830F2318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F231C; continue 'dispatch;
            }
            0x830F231C => {
    //   block [0x830F231C..0x830F2334)
	// 830F231C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F2320: 552A063F  clrlwi. r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2324: 997F003D  stb r11, 0x3d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(61 as u32), ctx.r[11].u8 ) };
	// 830F2328: 4082000C  bne 0x830f2334
	if !ctx.cr[0].eq {
	pc = 0x830F2334; continue 'dispatch;
	}
	// 830F232C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F2330: 480000EC  b 0x830f241c
	pc = 0x830F241C; continue 'dispatch;
            }
            0x830F2334 => {
    //   block [0x830F2334..0x830F234C)
	// 830F2334: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2338: 41820014  beq 0x830f234c
	if ctx.cr[0].eq {
	pc = 0x830F234C; continue 'dispatch;
	}
	// 830F233C: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 830F2340: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F2344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F2348: 4B0B6979  bl 0x821a8cc0
	ctx.lr = 0x830F234C;
	sub_821A8CC0(ctx, base);
	pc = 0x830F234C; continue 'dispatch;
            }
            0x830F234C => {
    //   block [0x830F234C..0x830F23D4)
	// 830F234C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F2350: 38C01EA9  li r6, 0x1ea9
	ctx.r[6].s64 = 7849;
	// 830F2354: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F2358: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830F235C: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F2360: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F2364: A0BF0006  lhz r5, 6(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 830F2368: A09F0004  lhz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F236C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F2370: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F2374: 4BFFFE05  bl 0x830f2178
	ctx.lr = 0x830F2378;
	sub_830F2178(ctx, base);
	// 830F2378: 38C021F1  li r6, 0x21f1
	ctx.r[6].s64 = 8689;
	// 830F237C: A0BF000A  lhz r5, 0xa(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 830F2380: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 830F2384: A09F0008  lhz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F2388: 4BFFFDF1  bl 0x830f2178
	ctx.lr = 0x830F238C;
	sub_830F2178(ctx, base);
	// 830F238C: A15F0000  lhz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2390: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 830F2394: 3920001E  li r9, 0x1e
	ctx.r[9].s64 = 30;
	// 830F2398: A11F0020  lhz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F239C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 830F23A0: 7D695810  subfc r11, r9, r11
	ctx.xer.ca = ctx.r[11].u32 >= ctx.r[9].u32;
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 830F23A4: 7D083A78  xor r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[7].u64;
	// 830F23A8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830F23AC: B15F0020  sth r10, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u16 ) };
	// 830F23B0: 7D0A3838  and r10, r8, r7
	ctx.r[10].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 830F23B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F23B8: B15F0024  sth r10, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u16 ) };
	// 830F23BC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F23C0: 41820014  beq 0x830f23d4
	if ctx.cr[0].eq {
	pc = 0x830F23D4; continue 'dispatch;
	}
	// 830F23C4: 895F0022  lbz r10, 0x22(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(34 as u32) ) } as u64;
	// 830F23C8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F23CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F23D0: 41820008  beq 0x830f23d8
	if ctx.cr[0].eq {
	pc = 0x830F23D8; continue 'dispatch;
	}
	pc = 0x830F23D4; continue 'dispatch;
            }
            0x830F23D4 => {
    //   block [0x830F23D4..0x830F23D8)
	// 830F23D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F23D8; continue 'dispatch;
            }
            0x830F23D8 => {
    //   block [0x830F23D8..0x830F2408)
	// 830F23D8: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 830F23DC: 997F0022  stb r11, 0x22(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(34 as u32), ctx.r[11].u8 ) };
	// 830F23E0: 7D694010  subfc r11, r9, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[9].u32;
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 830F23E4: 995F0026  stb r10, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[10].u8 ) };
	// 830F23E8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830F23EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F23F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F23F4: 41820014  beq 0x830f2408
	if ctx.cr[0].eq {
	pc = 0x830F2408; continue 'dispatch;
	}
	// 830F23F8: 895F0023  lbz r10, 0x23(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(35 as u32) ) } as u64;
	// 830F23FC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F2400: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F2404: 41820008  beq 0x830f240c
	if ctx.cr[0].eq {
	pc = 0x830F240C; continue 'dispatch;
	}
	pc = 0x830F2408; continue 'dispatch;
            }
            0x830F2408 => {
    //   block [0x830F2408..0x830F240C)
	// 830F2408: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F240C; continue 'dispatch;
            }
            0x830F240C => {
    //   block [0x830F240C..0x830F241C)
	// 830F240C: 997F0023  stb r11, 0x23(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(35 as u32), ctx.r[11].u8 ) };
	// 830F2410: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F2414: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830F2418: 995F0027  stb r10, 0x27(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(39 as u32), ctx.r[10].u8 ) };
	pc = 0x830F241C; continue 'dispatch;
            }
            0x830F241C => {
    //   block [0x830F241C..0x830F2424)
	// 830F241C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F2420: 4BBB703C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2428 size=180
    let mut pc: u32 = 0x830F2428;
    'dispatch: loop {
        match pc {
            0x830F2428 => {
    //   block [0x830F2428..0x830F246C)
	// 830F2428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F242C: 4BBB6FE1  bl 0x82ca940c
	ctx.lr = 0x830F2430;
	sub_82CA93D0(ctx, base);
	// 830F2430: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 830F2434: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2438: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F243C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F2440: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F2444: 896BBBD0  lbz r11, -0x4430(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-17456 as u32) ) } as u64;
	// 830F2448: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F244C: 41820088  beq 0x830f24d4
	if ctx.cr[0].eq {
	pc = 0x830F24D4; continue 'dispatch;
	}
	// 830F2450: 2B230000  cmpldi cr6, r3, 0
	ctx.cr[6].compare_u64(ctx.r[3].u64, 0, &mut ctx.xer);
	// 830F2454: 419A0018  beq cr6, 0x830f246c
	if ctx.cr[6].eq {
	pc = 0x830F246C; continue 'dispatch;
	}
	// 830F2458: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F245C: E96B1F98  ld r11, 0x1f98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8088 as u32) ) };
	// 830F2460: 7D6B1838  and r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[3].u64;
	// 830F2464: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 830F2468: 419A006C  beq cr6, 0x830f24d4
	if ctx.cr[6].eq {
	pc = 0x830F24D4; continue 'dispatch;
	}
	pc = 0x830F246C; continue 'dispatch;
            }
            0x830F246C => {
    //   block [0x830F246C..0x830F24D4)
	// 830F246C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F2470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F2474: 4BBBB1E5  bl 0x82cad658
	ctx.lr = 0x830F2478;
	sub_82CAD658(ctx, base);
	// 830F2478: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F247C: 40810058  ble 0x830f24d4
	if !ctx.cr[0].gt {
	pc = 0x830F24D4; continue 'dispatch;
	}
	// 830F2480: 38830001  addi r4, r3, 1
	ctx.r[4].s64 = ctx.r[3].s64 + 1;
	// 830F2484: 7D6400D0  neg r11, r4
	ctx.r[11].s64 = -ctx.r[4].s64;
	// 830F2488: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F248C: 4BBBE1C9  bl 0x82cb0654
	ctx.lr = 0x830F2490;
	sub_82CB0654(ctx, base);
	// 830F2490: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2494: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F2498: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830F249C: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 830F24A0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 830F24A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F24A8: 4BBBF069  bl 0x82cb1510
	ctx.lr = 0x830F24AC;
	sub_82CB1510(ctx, base);
	// 830F24AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F24B0: 4B07DB61  bl 0x82170010
	ctx.lr = 0x830F24B4;
	sub_82170010(ctx, base);
	// 830F24B4: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 830F24B8: 809DBBD4  lwz r4, -0x442c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17452 as u32) ) } as u64;
	// 830F24BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F24C0: 419A0014  beq cr6, 0x830f24d4
	if ctx.cr[6].eq {
	pc = 0x830F24D4; continue 'dispatch;
	}
	// 830F24C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F24C8: 4BBBCCA9  bl 0x82caf170
	ctx.lr = 0x830F24CC;
	sub_82CAF170(ctx, base);
	// 830F24CC: 807DBBD4  lwz r3, -0x442c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17452 as u32) ) } as u64;
	// 830F24D0: 4BBB8EA1  bl 0x82cab370
	ctx.lr = 0x830F24D4;
	sub_82CAB370(ctx, base);
	pc = 0x830F24D4; continue 'dispatch;
            }
            0x830F24D4 => {
    //   block [0x830F24D4..0x830F24DC)
	// 830F24D4: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 830F24D8: 4BBB6F84  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F24E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F24E0 size=248
    let mut pc: u32 = 0x830F24E0;
    'dispatch: loop {
        match pc {
            0x830F24E0 => {
    //   block [0x830F24E0..0x830F2528)
	// 830F24E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F24E4: 4BBB6F19  bl 0x82ca93fc
	ctx.lr = 0x830F24E8;
	sub_82CA93D0(ctx, base);
	// 830F24E8: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 830F24EC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F24F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F24F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F24F8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830F24FC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830F2500: 896BBBD0  lbz r11, -0x4430(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-17456 as u32) ) } as u64;
	// 830F2504: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F2508: 418200C8  beq 0x830f25d0
	if ctx.cr[0].eq {
	pc = 0x830F25D0; continue 'dispatch;
	}
	// 830F250C: 2B230000  cmpldi cr6, r3, 0
	ctx.cr[6].compare_u64(ctx.r[3].u64, 0, &mut ctx.xer);
	// 830F2510: 419A0018  beq cr6, 0x830f2528
	if ctx.cr[6].eq {
	pc = 0x830F2528; continue 'dispatch;
	}
	// 830F2514: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F2518: E96B1F98  ld r11, 0x1f98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8088 as u32) ) };
	// 830F251C: 7D6B1838  and r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[3].u64;
	// 830F2520: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 830F2524: 419A00AC  beq cr6, 0x830f25d0
	if ctx.cr[6].eq {
	pc = 0x830F25D0; continue 'dispatch;
	}
	pc = 0x830F2528; continue 'dispatch;
            }
            0x830F2528 => {
    //   block [0x830F2528..0x830F25A8)
	// 830F2528: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F252C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2530: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2534: 3B2BA96C  addi r25, r11, -0x5694
	ctx.r[25].s64 = ctx.r[11].s64 + -22164;
	// 830F2538: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830F253C: 4BFFF565  bl 0x830f1aa0
	ctx.lr = 0x830F2540;
	sub_830F1AA0(ctx, base);
	// 830F2540: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F2544: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F2548: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F254C: 4BBBE5CD  bl 0x82cb0b18
	ctx.lr = 0x830F2550;
	sub_82CB0B18(ctx, base);
	// 830F2550: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F2554: 7D7DE214  add r11, r29, r28
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	// 830F2558: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F255C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F2560: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 830F2564: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F2568: 4BBBE0ED  bl 0x82cb0654
	ctx.lr = 0x830F256C;
	sub_82CB0654(ctx, base);
	// 830F256C: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2570: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2574: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830F2578: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F257C: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 830F2580: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 830F2584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F2588: 4BE030A1  bl 0x82ef5628
	ctx.lr = 0x830F258C;
	sub_82EF5628(ctx, base);
	// 830F258C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F2590: 40990018  ble cr6, 0x830f25a8
	if !ctx.cr[6].gt {
	pc = 0x830F25A8; continue 'dispatch;
	}
	// 830F2594: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F2598: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830F259C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F25A0: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F25A4: 4BF1938D  bl 0x8300b930
	ctx.lr = 0x830F25A8;
	sub_8300B930(ctx, base);
	pc = 0x830F25A8; continue 'dispatch;
            }
            0x830F25A8 => {
    //   block [0x830F25A8..0x830F25D0)
	// 830F25A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F25AC: 4BBD5A45  bl 0x82cc7ff0
	ctx.lr = 0x830F25B0;
	sub_82CC7FF0(ctx, base);
	// 830F25B0: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 830F25B4: 809DBBD4  lwz r4, -0x442c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17452 as u32) ) } as u64;
	// 830F25B8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F25BC: 419A0014  beq cr6, 0x830f25d0
	if ctx.cr[6].eq {
	pc = 0x830F25D0; continue 'dispatch;
	}
	// 830F25C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F25C4: 48004B95  bl 0x830f7158
	ctx.lr = 0x830F25C8;
	sub_830F7158(ctx, base);
	// 830F25C8: 807DBBD4  lwz r3, -0x442c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17452 as u32) ) } as u64;
	// 830F25CC: 4BBB8DA5  bl 0x82cab370
	ctx.lr = 0x830F25D0;
	sub_82CAB370(ctx, base);
	pc = 0x830F25D0; continue 'dispatch;
            }
            0x830F25D0 => {
    //   block [0x830F25D0..0x830F25D8)
	// 830F25D0: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 830F25D4: 4BBB6E78  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F25D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F25D8 size=20
    let mut pc: u32 = 0x830F25D8;
    'dispatch: loop {
        match pc {
            0x830F25D8 => {
    //   block [0x830F25D8..0x830F25EC)
	// 830F25D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F25DC: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 830F25E0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F25E4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F25E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F25F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F25F0 size=80
    let mut pc: u32 = 0x830F25F0;
    'dispatch: loop {
        match pc {
            0x830F25F0 => {
    //   block [0x830F25F0..0x830F25F8)
	// 830F25F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F25F4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x830F25F8; continue 'dispatch;
            }
            0x830F25F8 => {
    //   block [0x830F25F8..0x830F2620)
	// 830F25F8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F25FC: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2600: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F2604: 409A001C  bne cr6, 0x830f2620
	if !ctx.cr[6].eq {
	pc = 0x830F2620; continue 'dispatch;
	}
	// 830F2608: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F260C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F2610: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F2614: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830F2618: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F261C: 48000010  b 0x830f262c
	pc = 0x830F262C; continue 'dispatch;
            }
            0x830F2620 => {
    //   block [0x830F2620..0x830F262C)
	// 830F2620: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2624: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F2628: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830F262C; continue 'dispatch;
            }
            0x830F262C => {
    //   block [0x830F262C..0x830F2640)
	// 830F262C: 396A0002  addi r11, r10, 2
	ctx.r[11].s64 = ctx.r[10].s64 + 2;
	// 830F2630: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830F2634: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F2638: 4082FFC0  bne 0x830f25f8
	if !ctx.cr[0].eq {
	pc = 0x830F25F8; continue 'dispatch;
	}
	// 830F263C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2640 size=108
    let mut pc: u32 = 0x830F2640;
    'dispatch: loop {
        match pc {
            0x830F2640 => {
    //   block [0x830F2640..0x830F26AC)
	// 830F2640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F264C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F2650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F2658: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F265C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2660: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2664: 83C3004C  lwz r30, 0x4c(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 830F2668: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F266C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F2670: 4E800421  bctrl
	ctx.lr = 0x830F2674;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F2674: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2678: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F267C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F2680: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F2688: 4E800421  bctrl
	ctx.lr = 0x830F268C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F268C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F2690: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F2694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F2698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F269C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F26A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F26A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F26A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F26B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F26B0 size=40
    let mut pc: u32 = 0x830F26B0;
    'dispatch: loop {
        match pc {
            0x830F26B0 => {
    //   block [0x830F26B0..0x830F26B8)
	// 830F26B0: 8163FFFC  lwz r11, -4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830F26B4: 48000014  b 0x830f26c8
	pc = 0x830F26C8; continue 'dispatch;
            }
            0x830F26B8 => {
    //   block [0x830F26B8..0x830F26C8)
	// 830F26B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F26BC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F26C0: 419A0018  beq cr6, 0x830f26d8
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x830F26D8);
		return;
	}
	// 830F26C4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830F26C8; continue 'dispatch;
            }
            0x830F26C8 => {
    //   block [0x830F26C8..0x830F26D8)
	// 830F26C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F26CC: 409AFFEC  bne cr6, 0x830f26b8
	if !ctx.cr[6].eq {
	pc = 0x830F26B8; continue 'dispatch;
	}
	// 830F26D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F26D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F26E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F26E0 size=76
    let mut pc: u32 = 0x830F26E0;
    'dispatch: loop {
        match pc {
            0x830F26E0 => {
    //   block [0x830F26E0..0x830F2718)
	// 830F26E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F26E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F26E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F26EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F26F0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F26F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F26F8: 4E800421  bctrl
	ctx.lr = 0x830F26FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F26FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F2700: 41820018  beq 0x830f2718
	if ctx.cr[0].eq {
	pc = 0x830F2718; continue 'dispatch;
	}
	// 830F2704: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2708: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F270C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F2710: 4E800421  bctrl
	ctx.lr = 0x830F2714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F2714: 48000008  b 0x830f271c
	pc = 0x830F271C; continue 'dispatch;
            }
            0x830F2718 => {
    //   block [0x830F2718..0x830F271C)
	// 830F2718: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F271C; continue 'dispatch;
            }
            0x830F271C => {
    //   block [0x830F271C..0x830F272C)
	// 830F271C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F2720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2730 size=92
    let mut pc: u32 = 0x830F2730;
    'dispatch: loop {
        match pc {
            0x830F2730 => {
    //   block [0x830F2730..0x830F278C)
	// 830F2730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2738: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F273C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2740: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2744: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 830F2748: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 830F274C: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F2750: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 830F2754: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2758: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 830F275C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F2760: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2764: 38E7A9D8  addi r7, r7, -0x5628
	ctx.r[7].s64 = ctx.r[7].s64 + -22056;
	// 830F2768: 3880D8F4  li r4, -0x270c
	ctx.r[4].s64 = -9996;
	// 830F276C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F2774: 4E800421  bctrl
	ctx.lr = 0x830F2778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F2778: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F277C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2780: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2784: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2790 size=96
    let mut pc: u32 = 0x830F2790;
    'dispatch: loop {
        match pc {
            0x830F2790 => {
    //   block [0x830F2790..0x830F27AC)
	// 830F2790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2798: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F279C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F27A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F27A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F27A8: 48000024  b 0x830f27cc
	pc = 0x830F27CC; continue 'dispatch;
            }
            0x830F27AC => {
    //   block [0x830F27AC..0x830F27CC)
	// 830F27AC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F27B0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F27B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F27B8: 83C40008  lwz r30, 8(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F27BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F27C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F27C4: 4E800421  bctrl
	ctx.lr = 0x830F27C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F27C8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            0x830F27CC => {
    //   block [0x830F27CC..0x830F27F0)
	// 830F27CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F27D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F27D4: 409AFFD8  bne cr6, 0x830f27ac
	if !ctx.cr[6].eq {
	pc = 0x830F27AC; continue 'dispatch;
	}
	// 830F27D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F27DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F27E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F27E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F27E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F27EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F27F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F27F0 size=164
    let mut pc: u32 = 0x830F27F0;
    'dispatch: loop {
        match pc {
            0x830F27F0 => {
    //   block [0x830F27F0..0x830F2858)
	// 830F27F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F27F4: 4BBB6C19  bl 0x82ca940c
	ctx.lr = 0x830F27F8;
	sub_82CA93D0(ctx, base);
	// 830F27F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F27FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F2800: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F2804: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F2808: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F280C: 409A004C  bne cr6, 0x830f2858
	if !ctx.cr[6].eq {
	pc = 0x830F2858; continue 'dispatch;
	}
	// 830F2810: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F2814: 388BBBD8  addi r4, r11, -0x4428
	ctx.r[4].s64 = ctx.r[11].s64 + -17448;
	// 830F2818: 896BBBD8  lbz r11, -0x4428(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-17448 as u32) ) } as u64;
	// 830F281C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F2820: 40820038  bne 0x830f2858
	if !ctx.cr[0].eq {
	pc = 0x830F2858; continue 'dispatch;
	}
	// 830F2824: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F2828: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F282C: 396BAAC8  addi r11, r11, -0x5538
	ctx.r[11].s64 = ctx.r[11].s64 + -21816;
	// 830F2830: 394AAAC0  addi r10, r10, -0x5540
	ctx.r[10].s64 = ctx.r[10].s64 + -21824;
	// 830F2834: 39200051  li r9, 0x51
	ctx.r[9].s64 = 81;
	// 830F2838: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F283C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830F2840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F2844: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 830F2848: 4BFFF571  bl 0x830f1db8
	ctx.lr = 0x830F284C;
	sub_830F1DB8(ctx, base);
	// 830F284C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2850: 40820008  bne 0x830f2858
	if !ctx.cr[0].eq {
	pc = 0x830F2858; continue 'dispatch;
	}
	// 830F2854: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F2858; continue 'dispatch;
            }
            0x830F2858 => {
    //   block [0x830F2858..0x830F286C)
	// 830F2858: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F285C: 409A0010  bne cr6, 0x830f286c
	if !ctx.cr[6].eq {
	pc = 0x830F286C; continue 'dispatch;
	}
	// 830F2860: 217F0000  subfic r11, r31, 0
	ctx.xer.ca = ctx.r[31].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[31].s64;
	// 830F2864: 7C6B5910  subfe r3, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[3].u32 = res;
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830F2868: 48000024  b 0x830f288c
	pc = 0x830F288C; continue 'dispatch;
            }
            0x830F286C => {
    //   block [0x830F286C..0x830F287C)
	// 830F286C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F2870: 409A000C  bne cr6, 0x830f287c
	if !ctx.cr[6].eq {
	pc = 0x830F287C; continue 'dispatch;
	}
	// 830F2874: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F2878: 48000014  b 0x830f288c
	pc = 0x830F288C; continue 'dispatch;
            }
            0x830F287C => {
    //   block [0x830F287C..0x830F288C)
	// 830F287C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F2880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F2884: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F2888: 4BBBE481  bl 0x82cb0d08
	ctx.lr = 0x830F288C;
	sub_82CB0D08(ctx, base);
	pc = 0x830F288C; continue 'dispatch;
            }
            0x830F288C => {
    //   block [0x830F288C..0x830F2894)
	// 830F288C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F2890: 4BBB6BCC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2898 size=116
    let mut pc: u32 = 0x830F2898;
    'dispatch: loop {
        match pc {
            0x830F2898 => {
    //   block [0x830F2898..0x830F28B0)
	// 830F2898: 546A043E  clrlwi r10, r3, 0x10
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F289C: 2B0A0030  cmplwi cr6, r10, 0x30
	ctx.cr[6].compare_u32(ctx.r[10].u32, 48 as u32, &mut ctx.xer);
	// 830F28A0: 41980010  blt cr6, 0x830f28b0
	if ctx.cr[6].lt {
	pc = 0x830F28B0; continue 'dispatch;
	}
	// 830F28A4: 2B0A0039  cmplwi cr6, r10, 0x39
	ctx.cr[6].compare_u32(ctx.r[10].u32, 57 as u32, &mut ctx.xer);
	// 830F28A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F28AC: 40990008  ble cr6, 0x830f28b4
	if !ctx.cr[6].gt {
	pc = 0x830F28B4; continue 'dispatch;
	}
	pc = 0x830F28B0; continue 'dispatch;
            }
            0x830F28B0 => {
    //   block [0x830F28B0..0x830F28B4)
	// 830F28B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F28B4; continue 'dispatch;
            }
            0x830F28B4 => {
    //   block [0x830F28B4..0x830F28D0)
	// 830F28B4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F28B8: 40820048  bne 0x830f2900
	if !ctx.cr[0].eq {
	pc = 0x830F2900; continue 'dispatch;
	}
	// 830F28BC: 2B0A0041  cmplwi cr6, r10, 0x41
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65 as u32, &mut ctx.xer);
	// 830F28C0: 41980010  blt cr6, 0x830f28d0
	if ctx.cr[6].lt {
	pc = 0x830F28D0; continue 'dispatch;
	}
	// 830F28C4: 2B0A0046  cmplwi cr6, r10, 0x46
	ctx.cr[6].compare_u32(ctx.r[10].u32, 70 as u32, &mut ctx.xer);
	// 830F28C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F28CC: 40990008  ble cr6, 0x830f28d4
	if !ctx.cr[6].gt {
	pc = 0x830F28D4; continue 'dispatch;
	}
	pc = 0x830F28D0; continue 'dispatch;
            }
            0x830F28D0 => {
    //   block [0x830F28D0..0x830F28D4)
	// 830F28D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F28D4; continue 'dispatch;
            }
            0x830F28D4 => {
    //   block [0x830F28D4..0x830F28F0)
	// 830F28D4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F28D8: 40820028  bne 0x830f2900
	if !ctx.cr[0].eq {
	pc = 0x830F2900; continue 'dispatch;
	}
	// 830F28DC: 2B0A0061  cmplwi cr6, r10, 0x61
	ctx.cr[6].compare_u32(ctx.r[10].u32, 97 as u32, &mut ctx.xer);
	// 830F28E0: 41980010  blt cr6, 0x830f28f0
	if ctx.cr[6].lt {
	pc = 0x830F28F0; continue 'dispatch;
	}
	// 830F28E4: 2B0A0066  cmplwi cr6, r10, 0x66
	ctx.cr[6].compare_u32(ctx.r[10].u32, 102 as u32, &mut ctx.xer);
	// 830F28E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F28EC: 40990008  ble cr6, 0x830f28f4
	if !ctx.cr[6].gt {
	pc = 0x830F28F4; continue 'dispatch;
	}
	pc = 0x830F28F0; continue 'dispatch;
            }
            0x830F28F0 => {
    //   block [0x830F28F0..0x830F28F4)
	// 830F28F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F28F4; continue 'dispatch;
            }
            0x830F28F4 => {
    //   block [0x830F28F4..0x830F2900)
	// 830F28F4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F28F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F28FC: 41820008  beq 0x830f2904
	if ctx.cr[0].eq {
	pc = 0x830F2904; continue 'dispatch;
	}
	pc = 0x830F2900; continue 'dispatch;
            }
            0x830F2900 => {
    //   block [0x830F2900..0x830F2904)
	// 830F2900: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F2904; continue 'dispatch;
            }
            0x830F2904 => {
    //   block [0x830F2904..0x830F290C)
	// 830F2904: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F2908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2910 size=160
    let mut pc: u32 = 0x830F2910;
    'dispatch: loop {
        match pc {
            0x830F2910 => {
    //   block [0x830F2910..0x830F2960)
	// 830F2910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F291C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F2920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F2928: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F292C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2930: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F2934: 419A0064  beq cr6, 0x830f2998
	if ctx.cr[6].eq {
	pc = 0x830F2998; continue 'dispatch;
	}
	// 830F2938: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F293C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F2940: 41980058  blt cr6, 0x830f2998
	if ctx.cr[6].lt {
	pc = 0x830F2998; continue 'dispatch;
	}
	// 830F2944: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2948: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F294C: 419A0014  beq cr6, 0x830f2960
	if ctx.cr[6].eq {
	pc = 0x830F2960; continue 'dispatch;
	}
	// 830F2950: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2954: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2958: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F295C: 4E800421  bctrl
	ctx.lr = 0x830F2960;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F2960 => {
    //   block [0x830F2960..0x830F2998)
	// 830F2960: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2964: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 830F2968: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F296C: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830F2970: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2974: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F297C: 4E800421  bctrl
	ctx.lr = 0x830F2980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F2980: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830F2984: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F2988: 41820010  beq 0x830f2998
	if ctx.cr[0].eq {
	pc = 0x830F2998; continue 'dispatch;
	}
	// 830F298C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F2990: B1630000  sth r11, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830F2994: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
            }
            0x830F2998 => {
    //   block [0x830F2998..0x830F29B0)
	// 830F2998: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F299C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F29A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F29A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F29A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F29AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F29B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F29B0 size=92
    let mut pc: u32 = 0x830F29B0;
    'dispatch: loop {
        match pc {
            0x830F29B0 => {
    //   block [0x830F29B0..0x830F29C8)
	// 830F29B0: 546A043E  clrlwi r10, r3, 0x10
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F29B4: 2B0A4E00  cmplwi cr6, r10, 0x4e00
	ctx.cr[6].compare_u32(ctx.r[10].u32, 19968 as u32, &mut ctx.xer);
	// 830F29B8: 41980010  blt cr6, 0x830f29c8
	if ctx.cr[6].lt {
	pc = 0x830F29C8; continue 'dispatch;
	}
	// 830F29BC: 2B0A9FA5  cmplwi cr6, r10, 0x9fa5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40869 as u32, &mut ctx.xer);
	// 830F29C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F29C4: 40990008  ble cr6, 0x830f29cc
	if !ctx.cr[6].gt {
	pc = 0x830F29CC; continue 'dispatch;
	}
	pc = 0x830F29C8; continue 'dispatch;
            }
            0x830F29C8 => {
    //   block [0x830F29C8..0x830F29CC)
	// 830F29C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F29CC; continue 'dispatch;
            }
            0x830F29CC => {
    //   block [0x830F29CC..0x830F29F0)
	// 830F29CC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F29D0: 40820030  bne 0x830f2a00
	if !ctx.cr[0].eq {
	pc = 0x830F2A00; continue 'dispatch;
	}
	// 830F29D4: 2B0A3007  cmplwi cr6, r10, 0x3007
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12295 as u32, &mut ctx.xer);
	// 830F29D8: 419A0028  beq cr6, 0x830f2a00
	if ctx.cr[6].eq {
	pc = 0x830F2A00; continue 'dispatch;
	}
	// 830F29DC: 2B0A3021  cmplwi cr6, r10, 0x3021
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12321 as u32, &mut ctx.xer);
	// 830F29E0: 41980010  blt cr6, 0x830f29f0
	if ctx.cr[6].lt {
	pc = 0x830F29F0; continue 'dispatch;
	}
	// 830F29E4: 2B0A3029  cmplwi cr6, r10, 0x3029
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12329 as u32, &mut ctx.xer);
	// 830F29E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F29EC: 40990008  ble cr6, 0x830f29f4
	if !ctx.cr[6].gt {
	pc = 0x830F29F4; continue 'dispatch;
	}
	pc = 0x830F29F0; continue 'dispatch;
            }
            0x830F29F0 => {
    //   block [0x830F29F0..0x830F29F4)
	// 830F29F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F29F4; continue 'dispatch;
            }
            0x830F29F4 => {
    //   block [0x830F29F4..0x830F2A00)
	// 830F29F4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F29F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F29FC: 41820008  beq 0x830f2a04
	if ctx.cr[0].eq {
	pc = 0x830F2A04; continue 'dispatch;
	}
	pc = 0x830F2A00; continue 'dispatch;
            }
            0x830F2A00 => {
    //   block [0x830F2A00..0x830F2A04)
	// 830F2A00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F2A04; continue 'dispatch;
            }
            0x830F2A04 => {
    //   block [0x830F2A04..0x830F2A0C)
	// 830F2A04: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F2A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2A10 size=108
    let mut pc: u32 = 0x830F2A10;
    'dispatch: loop {
        match pc {
            0x830F2A10 => {
    //   block [0x830F2A10..0x830F2A28)
	// 830F2A10: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F2A14: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F2A18: 41980010  blt cr6, 0x830f2a28
	if ctx.cr[6].lt {
	pc = 0x830F2A28; continue 'dispatch;
	}
	// 830F2A1C: 2B0BD7FF  cmplwi cr6, r11, 0xd7ff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 55295 as u32, &mut ctx.xer);
	// 830F2A20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F2A24: 40990008  ble cr6, 0x830f2a2c
	if !ctx.cr[6].gt {
	pc = 0x830F2A2C; continue 'dispatch;
	}
	pc = 0x830F2A28; continue 'dispatch;
            }
            0x830F2A28 => {
    //   block [0x830F2A28..0x830F2A2C)
	// 830F2A28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F2A2C; continue 'dispatch;
            }
            0x830F2A2C => {
    //   block [0x830F2A2C..0x830F2A60)
	// 830F2A2C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2A30: 40820040  bne 0x830f2a70
	if !ctx.cr[0].eq {
	pc = 0x830F2A70; continue 'dispatch;
	}
	// 830F2A34: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F2A38: 419A0038  beq cr6, 0x830f2a70
	if ctx.cr[6].eq {
	pc = 0x830F2A70; continue 'dispatch;
	}
	// 830F2A3C: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F2A40: 419A0030  beq cr6, 0x830f2a70
	if ctx.cr[6].eq {
	pc = 0x830F2A70; continue 'dispatch;
	}
	// 830F2A44: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F2A48: 419A0028  beq cr6, 0x830f2a70
	if ctx.cr[6].eq {
	pc = 0x830F2A70; continue 'dispatch;
	}
	// 830F2A4C: 2B0BE000  cmplwi cr6, r11, 0xe000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 57344 as u32, &mut ctx.xer);
	// 830F2A50: 41980010  blt cr6, 0x830f2a60
	if ctx.cr[6].lt {
	pc = 0x830F2A60; continue 'dispatch;
	}
	// 830F2A54: 2B0BFFFD  cmplwi cr6, r11, 0xfffd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65533 as u32, &mut ctx.xer);
	// 830F2A58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2A5C: 40990008  ble cr6, 0x830f2a64
	if !ctx.cr[6].gt {
	pc = 0x830F2A64; continue 'dispatch;
	}
	pc = 0x830F2A60; continue 'dispatch;
            }
            0x830F2A60 => {
    //   block [0x830F2A60..0x830F2A64)
	// 830F2A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2A64; continue 'dispatch;
            }
            0x830F2A64 => {
    //   block [0x830F2A64..0x830F2A70)
	// 830F2A64: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F2A6C: 41820008  beq 0x830f2a74
	if ctx.cr[0].eq {
	pc = 0x830F2A74; continue 'dispatch;
	}
	pc = 0x830F2A70; continue 'dispatch;
            }
            0x830F2A70 => {
    //   block [0x830F2A70..0x830F2A74)
	// 830F2A70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F2A74; continue 'dispatch;
            }
            0x830F2A74 => {
    //   block [0x830F2A74..0x830F2A7C)
	// 830F2A74: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F2A78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2A80 size=148
    let mut pc: u32 = 0x830F2A80;
    'dispatch: loop {
        match pc {
            0x830F2A80 => {
    //   block [0x830F2A80..0x830F2A98)
	// 830F2A80: 546A043E  clrlwi r10, r3, 0x10
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F2A84: 2B0A0041  cmplwi cr6, r10, 0x41
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65 as u32, &mut ctx.xer);
	// 830F2A88: 41980010  blt cr6, 0x830f2a98
	if ctx.cr[6].lt {
	pc = 0x830F2A98; continue 'dispatch;
	}
	// 830F2A8C: 2B0A005A  cmplwi cr6, r10, 0x5a
	ctx.cr[6].compare_u32(ctx.r[10].u32, 90 as u32, &mut ctx.xer);
	// 830F2A90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2A94: 40990008  ble cr6, 0x830f2a9c
	if !ctx.cr[6].gt {
	pc = 0x830F2A9C; continue 'dispatch;
	}
	pc = 0x830F2A98; continue 'dispatch;
            }
            0x830F2A98 => {
    //   block [0x830F2A98..0x830F2A9C)
	// 830F2A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2A9C; continue 'dispatch;
            }
            0x830F2A9C => {
    //   block [0x830F2A9C..0x830F2AB8)
	// 830F2A9C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2AA0: 40820068  bne 0x830f2b08
	if !ctx.cr[0].eq {
	pc = 0x830F2B08; continue 'dispatch;
	}
	// 830F2AA4: 2B0A0061  cmplwi cr6, r10, 0x61
	ctx.cr[6].compare_u32(ctx.r[10].u32, 97 as u32, &mut ctx.xer);
	// 830F2AA8: 41980010  blt cr6, 0x830f2ab8
	if ctx.cr[6].lt {
	pc = 0x830F2AB8; continue 'dispatch;
	}
	// 830F2AAC: 2B0A007A  cmplwi cr6, r10, 0x7a
	ctx.cr[6].compare_u32(ctx.r[10].u32, 122 as u32, &mut ctx.xer);
	// 830F2AB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2AB4: 40990008  ble cr6, 0x830f2abc
	if !ctx.cr[6].gt {
	pc = 0x830F2ABC; continue 'dispatch;
	}
	pc = 0x830F2AB8; continue 'dispatch;
            }
            0x830F2AB8 => {
    //   block [0x830F2AB8..0x830F2ABC)
	// 830F2AB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2ABC; continue 'dispatch;
            }
            0x830F2ABC => {
    //   block [0x830F2ABC..0x830F2AD8)
	// 830F2ABC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2AC0: 40820048  bne 0x830f2b08
	if !ctx.cr[0].eq {
	pc = 0x830F2B08; continue 'dispatch;
	}
	// 830F2AC4: 2B0A0030  cmplwi cr6, r10, 0x30
	ctx.cr[6].compare_u32(ctx.r[10].u32, 48 as u32, &mut ctx.xer);
	// 830F2AC8: 41980010  blt cr6, 0x830f2ad8
	if ctx.cr[6].lt {
	pc = 0x830F2AD8; continue 'dispatch;
	}
	// 830F2ACC: 2B0A0039  cmplwi cr6, r10, 0x39
	ctx.cr[6].compare_u32(ctx.r[10].u32, 57 as u32, &mut ctx.xer);
	// 830F2AD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2AD4: 40990008  ble cr6, 0x830f2adc
	if !ctx.cr[6].gt {
	pc = 0x830F2ADC; continue 'dispatch;
	}
	pc = 0x830F2AD8; continue 'dispatch;
            }
            0x830F2AD8 => {
    //   block [0x830F2AD8..0x830F2ADC)
	// 830F2AD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2ADC; continue 'dispatch;
            }
            0x830F2ADC => {
    //   block [0x830F2ADC..0x830F2B08)
	// 830F2ADC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2AE0: 40820028  bne 0x830f2b08
	if !ctx.cr[0].eq {
	pc = 0x830F2B08; continue 'dispatch;
	}
	// 830F2AE4: 2B0A005F  cmplwi cr6, r10, 0x5f
	ctx.cr[6].compare_u32(ctx.r[10].u32, 95 as u32, &mut ctx.xer);
	// 830F2AE8: 419A0020  beq cr6, 0x830f2b08
	if ctx.cr[6].eq {
	pc = 0x830F2B08; continue 'dispatch;
	}
	// 830F2AEC: 2B0A002E  cmplwi cr6, r10, 0x2e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 46 as u32, &mut ctx.xer);
	// 830F2AF0: 419A0018  beq cr6, 0x830f2b08
	if ctx.cr[6].eq {
	pc = 0x830F2B08; continue 'dispatch;
	}
	// 830F2AF4: 2B0A003A  cmplwi cr6, r10, 0x3a
	ctx.cr[6].compare_u32(ctx.r[10].u32, 58 as u32, &mut ctx.xer);
	// 830F2AF8: 419A0010  beq cr6, 0x830f2b08
	if ctx.cr[6].eq {
	pc = 0x830F2B08; continue 'dispatch;
	}
	// 830F2AFC: 2B0A002D  cmplwi cr6, r10, 0x2d
	ctx.cr[6].compare_u32(ctx.r[10].u32, 45 as u32, &mut ctx.xer);
	// 830F2B00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F2B04: 409A0008  bne cr6, 0x830f2b0c
	if !ctx.cr[6].eq {
	pc = 0x830F2B0C; continue 'dispatch;
	}
	pc = 0x830F2B08; continue 'dispatch;
            }
            0x830F2B08 => {
    //   block [0x830F2B08..0x830F2B0C)
	// 830F2B08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F2B0C; continue 'dispatch;
            }
            0x830F2B0C => {
    //   block [0x830F2B0C..0x830F2B14)
	// 830F2B0C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F2B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2B18 size=92
    let mut pc: u32 = 0x830F2B18;
    'dispatch: loop {
        match pc {
            0x830F2B18 => {
    //   block [0x830F2B18..0x830F2B34)
	// 830F2B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F2B24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2B28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F2B2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F2B30: 409A000C  bne cr6, 0x830f2b3c
	if !ctx.cr[6].eq {
	pc = 0x830F2B3C; continue 'dispatch;
	}
	pc = 0x830F2B34; continue 'dispatch;
            }
            0x830F2B34 => {
    //   block [0x830F2B34..0x830F2B3C)
	// 830F2B34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F2B38: 48000028  b 0x830f2b60
	pc = 0x830F2B60; continue 'dispatch;
            }
            0x830F2B3C => {
    //   block [0x830F2B3C..0x830F2B40)
	// 830F2B3C: A07F0000  lhz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830F2B40; continue 'dispatch;
            }
            0x830F2B40 => {
    //   block [0x830F2B40..0x830F2B60)
	// 830F2B40: 4BFFFF41  bl 0x830f2a80
	ctx.lr = 0x830F2B44;
	sub_830F2A80(ctx, base);
	// 830F2B44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2B48: 4182FFEC  beq 0x830f2b34
	if ctx.cr[0].eq {
	pc = 0x830F2B34; continue 'dispatch;
	}
	// 830F2B4C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 830F2B50: A07F0000  lhz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2B54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F2B58: 4082FFE8  bne 0x830f2b40
	if !ctx.cr[0].eq {
	pc = 0x830F2B40; continue 'dispatch;
	}
	// 830F2B5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830F2B60; continue 'dispatch;
            }
            0x830F2B60 => {
    //   block [0x830F2B60..0x830F2B74)
	// 830F2B60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F2B64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2B68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2B6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2B70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2B78 size=140
    let mut pc: u32 = 0x830F2B78;
    'dispatch: loop {
        match pc {
            0x830F2B78 => {
    //   block [0x830F2B78..0x830F2B90)
	// 830F2B78: 546A043E  clrlwi r10, r3, 0x10
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F2B7C: 2B0A0041  cmplwi cr6, r10, 0x41
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65 as u32, &mut ctx.xer);
	// 830F2B80: 41980010  blt cr6, 0x830f2b90
	if ctx.cr[6].lt {
	pc = 0x830F2B90; continue 'dispatch;
	}
	// 830F2B84: 2B0A005A  cmplwi cr6, r10, 0x5a
	ctx.cr[6].compare_u32(ctx.r[10].u32, 90 as u32, &mut ctx.xer);
	// 830F2B88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2B8C: 40990008  ble cr6, 0x830f2b94
	if !ctx.cr[6].gt {
	pc = 0x830F2B94; continue 'dispatch;
	}
	pc = 0x830F2B90; continue 'dispatch;
            }
            0x830F2B90 => {
    //   block [0x830F2B90..0x830F2B94)
	// 830F2B90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2B94; continue 'dispatch;
            }
            0x830F2B94 => {
    //   block [0x830F2B94..0x830F2BB0)
	// 830F2B94: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2B98: 40820060  bne 0x830f2bf8
	if !ctx.cr[0].eq {
	pc = 0x830F2BF8; continue 'dispatch;
	}
	// 830F2B9C: 2B0A0061  cmplwi cr6, r10, 0x61
	ctx.cr[6].compare_u32(ctx.r[10].u32, 97 as u32, &mut ctx.xer);
	// 830F2BA0: 41980010  blt cr6, 0x830f2bb0
	if ctx.cr[6].lt {
	pc = 0x830F2BB0; continue 'dispatch;
	}
	// 830F2BA4: 2B0A007A  cmplwi cr6, r10, 0x7a
	ctx.cr[6].compare_u32(ctx.r[10].u32, 122 as u32, &mut ctx.xer);
	// 830F2BA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2BAC: 40990008  ble cr6, 0x830f2bb4
	if !ctx.cr[6].gt {
	pc = 0x830F2BB4; continue 'dispatch;
	}
	pc = 0x830F2BB0; continue 'dispatch;
            }
            0x830F2BB0 => {
    //   block [0x830F2BB0..0x830F2BB4)
	// 830F2BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2BB4; continue 'dispatch;
            }
            0x830F2BB4 => {
    //   block [0x830F2BB4..0x830F2BD0)
	// 830F2BB4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2BB8: 40820040  bne 0x830f2bf8
	if !ctx.cr[0].eq {
	pc = 0x830F2BF8; continue 'dispatch;
	}
	// 830F2BBC: 2B0A0030  cmplwi cr6, r10, 0x30
	ctx.cr[6].compare_u32(ctx.r[10].u32, 48 as u32, &mut ctx.xer);
	// 830F2BC0: 41980010  blt cr6, 0x830f2bd0
	if ctx.cr[6].lt {
	pc = 0x830F2BD0; continue 'dispatch;
	}
	// 830F2BC4: 2B0A0039  cmplwi cr6, r10, 0x39
	ctx.cr[6].compare_u32(ctx.r[10].u32, 57 as u32, &mut ctx.xer);
	// 830F2BC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2BCC: 40990008  ble cr6, 0x830f2bd4
	if !ctx.cr[6].gt {
	pc = 0x830F2BD4; continue 'dispatch;
	}
	pc = 0x830F2BD0; continue 'dispatch;
            }
            0x830F2BD0 => {
    //   block [0x830F2BD0..0x830F2BD4)
	// 830F2BD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2BD4; continue 'dispatch;
            }
            0x830F2BD4 => {
    //   block [0x830F2BD4..0x830F2BF8)
	// 830F2BD4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2BD8: 40820020  bne 0x830f2bf8
	if !ctx.cr[0].eq {
	pc = 0x830F2BF8; continue 'dispatch;
	}
	// 830F2BDC: 2B0A005F  cmplwi cr6, r10, 0x5f
	ctx.cr[6].compare_u32(ctx.r[10].u32, 95 as u32, &mut ctx.xer);
	// 830F2BE0: 419A0018  beq cr6, 0x830f2bf8
	if ctx.cr[6].eq {
	pc = 0x830F2BF8; continue 'dispatch;
	}
	// 830F2BE4: 2B0A002E  cmplwi cr6, r10, 0x2e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 46 as u32, &mut ctx.xer);
	// 830F2BE8: 419A0010  beq cr6, 0x830f2bf8
	if ctx.cr[6].eq {
	pc = 0x830F2BF8; continue 'dispatch;
	}
	// 830F2BEC: 2B0A002D  cmplwi cr6, r10, 0x2d
	ctx.cr[6].compare_u32(ctx.r[10].u32, 45 as u32, &mut ctx.xer);
	// 830F2BF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F2BF4: 409A0008  bne cr6, 0x830f2bfc
	if !ctx.cr[6].eq {
	pc = 0x830F2BFC; continue 'dispatch;
	}
	pc = 0x830F2BF8; continue 'dispatch;
            }
            0x830F2BF8 => {
    //   block [0x830F2BF8..0x830F2BFC)
	// 830F2BF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F2BFC; continue 'dispatch;
            }
            0x830F2BFC => {
    //   block [0x830F2BFC..0x830F2C04)
	// 830F2BFC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F2C00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2C08 size=92
    let mut pc: u32 = 0x830F2C08;
    'dispatch: loop {
        match pc {
            0x830F2C08 => {
    //   block [0x830F2C08..0x830F2C24)
	// 830F2C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2C10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F2C14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2C18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F2C1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F2C20: 409A000C  bne cr6, 0x830f2c2c
	if !ctx.cr[6].eq {
	pc = 0x830F2C2C; continue 'dispatch;
	}
	pc = 0x830F2C24; continue 'dispatch;
            }
            0x830F2C24 => {
    //   block [0x830F2C24..0x830F2C2C)
	// 830F2C24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F2C28: 48000028  b 0x830f2c50
	pc = 0x830F2C50; continue 'dispatch;
            }
            0x830F2C2C => {
    //   block [0x830F2C2C..0x830F2C30)
	// 830F2C2C: A07F0000  lhz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830F2C30; continue 'dispatch;
            }
            0x830F2C30 => {
    //   block [0x830F2C30..0x830F2C50)
	// 830F2C30: 4BFFFF49  bl 0x830f2b78
	ctx.lr = 0x830F2C34;
	sub_830F2B78(ctx, base);
	// 830F2C34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2C38: 4182FFEC  beq 0x830f2c24
	if ctx.cr[0].eq {
	pc = 0x830F2C24; continue 'dispatch;
	}
	// 830F2C3C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 830F2C40: A07F0000  lhz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2C44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F2C48: 4082FFE8  bne 0x830f2c30
	if !ctx.cr[0].eq {
	pc = 0x830F2C30; continue 'dispatch;
	}
	// 830F2C4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830F2C50; continue 'dispatch;
            }
            0x830F2C50 => {
    //   block [0x830F2C50..0x830F2C64)
	// 830F2C50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F2C54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2C58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2C5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2C60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2C68 size=44
    let mut pc: u32 = 0x830F2C68;
    'dispatch: loop {
        match pc {
            0x830F2C68 => {
    //   block [0x830F2C68..0x830F2C80)
	// 830F2C68: 546A043E  clrlwi r10, r3, 0x10
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F2C6C: 2B0A0030  cmplwi cr6, r10, 0x30
	ctx.cr[6].compare_u32(ctx.r[10].u32, 48 as u32, &mut ctx.xer);
	// 830F2C70: 41980010  blt cr6, 0x830f2c80
	if ctx.cr[6].lt {
	pc = 0x830F2C80; continue 'dispatch;
	}
	// 830F2C74: 2B0A0039  cmplwi cr6, r10, 0x39
	ctx.cr[6].compare_u32(ctx.r[10].u32, 57 as u32, &mut ctx.xer);
	// 830F2C78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2C7C: 40990008  ble cr6, 0x830f2c84
	if !ctx.cr[6].gt {
	pc = 0x830F2C84; continue 'dispatch;
	}
	pc = 0x830F2C80; continue 'dispatch;
            }
            0x830F2C80 => {
    //   block [0x830F2C80..0x830F2C84)
	// 830F2C80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2C84; continue 'dispatch;
            }
            0x830F2C84 => {
    //   block [0x830F2C84..0x830F2C94)
	// 830F2C84: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2C88: 4182000C  beq 0x830f2c94
	if ctx.cr[0].eq {
		sub_830F2C94(ctx, base);
		return;
	}
	// 830F2C8C: 386AFFD0  addi r3, r10, -0x30
	ctx.r[3].s64 = ctx.r[10].s64 + -48;
	// 830F2C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2C94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2C94 size=40
    let mut pc: u32 = 0x830F2C94;
    'dispatch: loop {
        match pc {
            0x830F2C94 => {
    //   block [0x830F2C94..0x830F2CA8)
	// 830F2C94: 2B0A0041  cmplwi cr6, r10, 0x41
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65 as u32, &mut ctx.xer);
	// 830F2C98: 41980010  blt cr6, 0x830f2ca8
	if ctx.cr[6].lt {
	pc = 0x830F2CA8; continue 'dispatch;
	}
	// 830F2C9C: 2B0A0046  cmplwi cr6, r10, 0x46
	ctx.cr[6].compare_u32(ctx.r[10].u32, 70 as u32, &mut ctx.xer);
	// 830F2CA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2CA4: 40990008  ble cr6, 0x830f2cac
	if !ctx.cr[6].gt {
	pc = 0x830F2CAC; continue 'dispatch;
	}
	pc = 0x830F2CA8; continue 'dispatch;
            }
            0x830F2CA8 => {
    //   block [0x830F2CA8..0x830F2CAC)
	// 830F2CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2CAC; continue 'dispatch;
            }
            0x830F2CAC => {
    //   block [0x830F2CAC..0x830F2CBC)
	// 830F2CAC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2CB0: 4182000C  beq 0x830f2cbc
	if ctx.cr[0].eq {
		sub_830F2CBC(ctx, base);
		return;
	}
	// 830F2CB4: 386AFFC9  addi r3, r10, -0x37
	ctx.r[3].s64 = ctx.r[10].s64 + -55;
	// 830F2CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2CBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2CBC size=44
    let mut pc: u32 = 0x830F2CBC;
    'dispatch: loop {
        match pc {
            0x830F2CBC => {
    //   block [0x830F2CBC..0x830F2CD0)
	// 830F2CBC: 2B0A0061  cmplwi cr6, r10, 0x61
	ctx.cr[6].compare_u32(ctx.r[10].u32, 97 as u32, &mut ctx.xer);
	// 830F2CC0: 41980010  blt cr6, 0x830f2cd0
	if ctx.cr[6].lt {
	pc = 0x830F2CD0; continue 'dispatch;
	}
	// 830F2CC4: 2B0A0066  cmplwi cr6, r10, 0x66
	ctx.cr[6].compare_u32(ctx.r[10].u32, 102 as u32, &mut ctx.xer);
	// 830F2CC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F2CCC: 40990008  ble cr6, 0x830f2cd4
	if !ctx.cr[6].gt {
	pc = 0x830F2CD4; continue 'dispatch;
	}
	pc = 0x830F2CD0; continue 'dispatch;
            }
            0x830F2CD0 => {
    //   block [0x830F2CD0..0x830F2CD4)
	// 830F2CD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2CD4; continue 'dispatch;
            }
            0x830F2CD4 => {
    //   block [0x830F2CD4..0x830F2CE8)
	// 830F2CD4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2CD8: 386AFFA9  addi r3, r10, -0x57
	ctx.r[3].s64 = ctx.r[10].s64 + -87;
	// 830F2CDC: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 830F2CE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F2CE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2CE8 size=128
    let mut pc: u32 = 0x830F2CE8;
    'dispatch: loop {
        match pc {
            0x830F2CE8 => {
    //   block [0x830F2CE8..0x830F2CF4)
	// 830F2CE8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2CEC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F2CF0: 48000030  b 0x830f2d20
	pc = 0x830F2D20; continue 'dispatch;
            }
            0x830F2CF4 => {
    //   block [0x830F2CF4..0x830F2D08)
	// 830F2CF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2CF8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830F2CFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F2D00: 419A0008  beq cr6, 0x830f2d08
	if ctx.cr[6].eq {
	pc = 0x830F2D08; continue 'dispatch;
	}
	// 830F2D04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F2D08; continue 'dispatch;
            }
            0x830F2D08 => {
    //   block [0x830F2D08..0x830F2D1C)
	// 830F2D08: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2D0C: 41820010  beq 0x830f2d1c
	if ctx.cr[0].eq {
	pc = 0x830F2D1C; continue 'dispatch;
	}
	// 830F2D10: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F2D14: 419A0018  beq cr6, 0x830f2d2c
	if ctx.cr[6].eq {
	pc = 0x830F2D2C; continue 'dispatch;
	}
	// 830F2D18: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	pc = 0x830F2D1C; continue 'dispatch;
            }
            0x830F2D1C => {
    //   block [0x830F2D1C..0x830F2D20)
	// 830F2D1C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830F2D20; continue 'dispatch;
            }
            0x830F2D20 => {
    //   block [0x830F2D20..0x830F2D2C)
	// 830F2D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2D24: 409AFFD0  bne cr6, 0x830f2cf4
	if !ctx.cr[6].eq {
	pc = 0x830F2CF4; continue 'dispatch;
	}
	// 830F2D28: 48000038  b 0x830f2d60
	pc = 0x830F2D60; continue 'dispatch;
            }
            0x830F2D2C => {
    //   block [0x830F2D2C..0x830F2D44)
	// 830F2D2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2D30: 419A0014  beq cr6, 0x830f2d44
	if ctx.cr[6].eq {
	pc = 0x830F2D44; continue 'dispatch;
	}
	// 830F2D34: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2D38: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830F2D3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F2D40: 419A0008  beq cr6, 0x830f2d48
	if ctx.cr[6].eq {
	pc = 0x830F2D48; continue 'dispatch;
	}
	pc = 0x830F2D44; continue 'dispatch;
            }
            0x830F2D44 => {
    //   block [0x830F2D44..0x830F2D48)
	// 830F2D44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F2D48; continue 'dispatch;
            }
            0x830F2D48 => {
    //   block [0x830F2D48..0x830F2D54)
	// 830F2D48: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2D4C: 40820008  bne 0x830f2d54
	if !ctx.cr[0].eq {
	pc = 0x830F2D54; continue 'dispatch;
	}
	// 830F2D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2D54; continue 'dispatch;
            }
            0x830F2D54 => {
    //   block [0x830F2D54..0x830F2D60)
	// 830F2D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2D58: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 830F2D5C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x830F2D60; continue 'dispatch;
            }
            0x830F2D60 => {
    //   block [0x830F2D60..0x830F2D68)
	// 830F2D60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F2D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2D68 size=128
    let mut pc: u32 = 0x830F2D68;
    'dispatch: loop {
        match pc {
            0x830F2D68 => {
    //   block [0x830F2D68..0x830F2D74)
	// 830F2D68: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2D6C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F2D70: 48000030  b 0x830f2da0
	pc = 0x830F2DA0; continue 'dispatch;
            }
            0x830F2D74 => {
    //   block [0x830F2D74..0x830F2D88)
	// 830F2D74: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2D78: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2D7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F2D80: 419A0008  beq cr6, 0x830f2d88
	if ctx.cr[6].eq {
	pc = 0x830F2D88; continue 'dispatch;
	}
	// 830F2D84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F2D88; continue 'dispatch;
            }
            0x830F2D88 => {
    //   block [0x830F2D88..0x830F2D9C)
	// 830F2D88: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2D8C: 41820010  beq 0x830f2d9c
	if ctx.cr[0].eq {
	pc = 0x830F2D9C; continue 'dispatch;
	}
	// 830F2D90: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F2D94: 419A0018  beq cr6, 0x830f2dac
	if ctx.cr[6].eq {
	pc = 0x830F2DAC; continue 'dispatch;
	}
	// 830F2D98: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	pc = 0x830F2D9C; continue 'dispatch;
            }
            0x830F2D9C => {
    //   block [0x830F2D9C..0x830F2DA0)
	// 830F2D9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830F2DA0; continue 'dispatch;
            }
            0x830F2DA0 => {
    //   block [0x830F2DA0..0x830F2DAC)
	// 830F2DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2DA4: 409AFFD0  bne cr6, 0x830f2d74
	if !ctx.cr[6].eq {
	pc = 0x830F2D74; continue 'dispatch;
	}
	// 830F2DA8: 48000038  b 0x830f2de0
	pc = 0x830F2DE0; continue 'dispatch;
            }
            0x830F2DAC => {
    //   block [0x830F2DAC..0x830F2DC4)
	// 830F2DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2DB0: 419A0014  beq cr6, 0x830f2dc4
	if ctx.cr[6].eq {
	pc = 0x830F2DC4; continue 'dispatch;
	}
	// 830F2DB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2DB8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2DBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F2DC0: 419A0008  beq cr6, 0x830f2dc8
	if ctx.cr[6].eq {
	pc = 0x830F2DC8; continue 'dispatch;
	}
	pc = 0x830F2DC4; continue 'dispatch;
            }
            0x830F2DC4 => {
    //   block [0x830F2DC4..0x830F2DC8)
	// 830F2DC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F2DC8; continue 'dispatch;
            }
            0x830F2DC8 => {
    //   block [0x830F2DC8..0x830F2DD4)
	// 830F2DC8: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2DCC: 40820008  bne 0x830f2dd4
	if !ctx.cr[0].eq {
	pc = 0x830F2DD4; continue 'dispatch;
	}
	// 830F2DD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F2DD4; continue 'dispatch;
            }
            0x830F2DD4 => {
    //   block [0x830F2DD4..0x830F2DE0)
	// 830F2DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2DD8: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 830F2DDC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x830F2DE0; continue 'dispatch;
            }
            0x830F2DE0 => {
    //   block [0x830F2DE0..0x830F2DE8)
	// 830F2DE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F2DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2DE8 size=60
    let mut pc: u32 = 0x830F2DE8;
    'dispatch: loop {
        match pc {
            0x830F2DE8 => {
    //   block [0x830F2DE8..0x830F2DF4)
	// 830F2DE8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2DEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F2DF0: 48000028  b 0x830f2e18
	pc = 0x830F2E18; continue 'dispatch;
            }
            0x830F2DF4 => {
    //   block [0x830F2DF4..0x830F2E08)
	// 830F2DF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2DF8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2DFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F2E00: 419A0008  beq cr6, 0x830f2e08
	if ctx.cr[6].eq {
	pc = 0x830F2E08; continue 'dispatch;
	}
	// 830F2E04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F2E08; continue 'dispatch;
            }
            0x830F2E08 => {
    //   block [0x830F2E08..0x830F2E14)
	// 830F2E08: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2E0C: 41820008  beq 0x830f2e14
	if ctx.cr[0].eq {
	pc = 0x830F2E14; continue 'dispatch;
	}
	// 830F2E10: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	pc = 0x830F2E14; continue 'dispatch;
            }
            0x830F2E14 => {
    //   block [0x830F2E14..0x830F2E18)
	// 830F2E14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830F2E18; continue 'dispatch;
            }
            0x830F2E18 => {
    //   block [0x830F2E18..0x830F2E24)
	// 830F2E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F2E1C: 409AFFD8  bne cr6, 0x830f2df4
	if !ctx.cr[6].eq {
	pc = 0x830F2DF4; continue 'dispatch;
	}
	// 830F2E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2E28 size=84
    let mut pc: u32 = 0x830F2E28;
    'dispatch: loop {
        match pc {
            0x830F2E28 => {
    //   block [0x830F2E28..0x830F2E7C)
	// 830F2E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2E2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2E30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2E34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2E38: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F2E3C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830F2E40: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F2E44: 390AAB58  addi r8, r10, -0x54a8
	ctx.r[8].s64 = ctx.r[10].s64 + -21672;
	// 830F2E48: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2E4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F2E50: 38E9AA40  addi r7, r9, -0x55c0
	ctx.r[7].s64 = ctx.r[9].s64 + -21952;
	// 830F2E54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2E58: 3880D8F5  li r4, -0x270b
	ctx.r[4].s64 = -9995;
	// 830F2E5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F2E64: 4E800421  bctrl
	ctx.lr = 0x830F2E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F2E68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F2E6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F2E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2E78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F2E80 size=140
    let mut pc: u32 = 0x830F2E80;
    'dispatch: loop {
        match pc {
            0x830F2E80 => {
    //   block [0x830F2E80..0x830F2E88)
	// 830F2E80: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F2E84: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830F2E88; continue 'dispatch;
            }
            0x830F2E88 => {
    //   block [0x830F2E88..0x830F2EB0)
	// 830F2E88: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830F2E8C: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F2E90: 419A0020  beq cr6, 0x830f2eb0
	if ctx.cr[6].eq {
	pc = 0x830F2EB0; continue 'dispatch;
	}
	// 830F2E94: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F2E98: 419A0018  beq cr6, 0x830f2eb0
	if ctx.cr[6].eq {
	pc = 0x830F2EB0; continue 'dispatch;
	}
	// 830F2E9C: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F2EA0: 419A0010  beq cr6, 0x830f2eb0
	if ctx.cr[6].eq {
	pc = 0x830F2EB0; continue 'dispatch;
	}
	// 830F2EA4: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F2EA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F2EAC: 409A0008  bne cr6, 0x830f2eb4
	if !ctx.cr[6].eq {
	pc = 0x830F2EB4; continue 'dispatch;
	}
	pc = 0x830F2EB0; continue 'dispatch;
            }
            0x830F2EB0 => {
    //   block [0x830F2EB0..0x830F2EB4)
	// 830F2EB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F2EB4; continue 'dispatch;
            }
            0x830F2EB4 => {
    //   block [0x830F2EB4..0x830F2EE8)
	// 830F2EB4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2EB8: 4182004C  beq 0x830f2f04
	if ctx.cr[0].eq {
	pc = 0x830F2F04; continue 'dispatch;
	}
	// 830F2EBC: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F2EC0: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 830F2EC4: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2EC8: 2B09000A  cmplwi cr6, r9, 0xa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 10 as u32, &mut ctx.xer);
	// 830F2ECC: 409A001C  bne cr6, 0x830f2ee8
	if !ctx.cr[6].eq {
	pc = 0x830F2EE8; continue 'dispatch;
	}
	// 830F2ED0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2ED4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F2ED8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F2EDC: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830F2EE0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F2EE4: 48000010  b 0x830f2ef4
	pc = 0x830F2EF4; continue 'dispatch;
            }
            0x830F2EE8 => {
    //   block [0x830F2EE8..0x830F2EF4)
	// 830F2EE8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2EEC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F2EF0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x830F2EF4; continue 'dispatch;
            }
            0x830F2EF4 => {
    //   block [0x830F2EF4..0x830F2F04)
	// 830F2EF4: 392A0002  addi r9, r10, 2
	ctx.r[9].s64 = ctx.r[10].s64 + 2;
	// 830F2EF8: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F2EFC: A16A0002  lhz r11, 2(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 830F2F00: 4BFFFF88  b 0x830f2e88
	pc = 0x830F2E88; continue 'dispatch;
            }
            0x830F2F04 => {
    //   block [0x830F2F04..0x830F2F0C)
	// 830F2F04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F2F08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2F10 size=192
    let mut pc: u32 = 0x830F2F10;
    'dispatch: loop {
        match pc {
            0x830F2F10 => {
    //   block [0x830F2F10..0x830F2F68)
	// 830F2F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F2F18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F2F1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2F20: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830F2F24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F2F28: 4BFFFF59  bl 0x830f2e80
	ctx.lr = 0x830F2F2C;
	sub_830F2E80(ctx, base);
	// 830F2F2C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F2F30: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2F34: 2B0B003D  cmplwi cr6, r11, 0x3d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 61 as u32, &mut ctx.xer);
	// 830F2F38: 409A0050  bne cr6, 0x830f2f88
	if !ctx.cr[6].eq {
	pc = 0x830F2F88; continue 'dispatch;
	}
	// 830F2F3C: 81470014  lwz r10, 0x14(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F2F40: 3967000C  addi r11, r7, 0xc
	ctx.r[11].s64 = ctx.r[7].s64 + 12;
	// 830F2F44: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 830F2F48: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2F4C: 2B09000A  cmplwi cr6, r9, 0xa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 10 as u32, &mut ctx.xer);
	// 830F2F50: 409A0018  bne cr6, 0x830f2f68
	if !ctx.cr[6].eq {
	pc = 0x830F2F68; continue 'dispatch;
	}
	// 830F2F54: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2F58: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830F2F5C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F2F60: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F2F64: 48000010  b 0x830f2f74
	pc = 0x830F2F74; continue 'dispatch;
            }
            0x830F2F68 => {
    //   block [0x830F2F68..0x830F2F74)
	// 830F2F68: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2F6C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F2F70: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x830F2F74; continue 'dispatch;
            }
            0x830F2F74 => {
    //   block [0x830F2F74..0x830F2F88)
	// 830F2F74: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830F2F78: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 830F2F7C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F2F80: 4BFFFF01  bl 0x830f2e80
	ctx.lr = 0x830F2F84;
	sub_830F2E80(ctx, base);
	// 830F2F84: 48000034  b 0x830f2fb8
	pc = 0x830F2FB8; continue 'dispatch;
            }
            0x830F2F88 => {
    //   block [0x830F2F88..0x830F2FB8)
	// 830F2F88: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2F8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F2F90: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F2F94: 80C70010  lwz r6, 0x10(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F2F98: 390BAB70  addi r8, r11, -0x5490
	ctx.r[8].s64 = ctx.r[11].s64 + -21648;
	// 830F2F9C: 80A7000C  lwz r5, 0xc(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2FA0: 38EAA9BC  addi r7, r10, -0x5644
	ctx.r[7].s64 = ctx.r[10].s64 + -22084;
	// 830F2FA4: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F2FA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2FAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2FB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F2FB4: 4E800421  bctrl
	ctx.lr = 0x830F2FB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F2FB8 => {
    //   block [0x830F2FB8..0x830F2FD0)
	// 830F2FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2FBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F2FC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F2FC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F2FC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F2FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F2FD0 size=1108
    let mut pc: u32 = 0x830F2FD0;
    'dispatch: loop {
        match pc {
            0x830F2FD0 => {
    //   block [0x830F2FD0..0x830F2FFC)
	// 830F2FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2FD4: 4BBB6429  bl 0x82ca93fc
	ctx.lr = 0x830F2FD8;
	sub_82CA93D0(ctx, base);
	// 830F2FD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2FDC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F2FE0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F2FE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F2FE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F2FEC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F2FF0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830F2FF4: 3B4BA9BC  addi r26, r11, -0x5644
	ctx.r[26].s64 = ctx.r[11].s64 + -22084;
	// 830F2FF8: 3B2AAC48  addi r25, r10, -0x53b8
	ctx.r[25].s64 = ctx.r[10].s64 + -21432;
	pc = 0x830F2FFC; continue 'dispatch;
            }
            0x830F2FFC => {
    //   block [0x830F2FFC..0x830F3070)
	// 830F2FFC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3000: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 830F3004: A3AB0000  lhz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3008: 41980260  blt cr6, 0x830f3268
	if ctx.cr[6].lt {
	pc = 0x830F3268; continue 'dispatch;
	}
	// 830F300C: 419A0210  beq cr6, 0x830f321c
	if ctx.cr[6].eq {
	pc = 0x830F321C; continue 'dispatch;
	}
	// 830F3010: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 830F3014: 4198015C  blt cr6, 0x830f3170
	if ctx.cr[6].lt {
	pc = 0x830F3170; continue 'dispatch;
	}
	// 830F3018: 419A00DC  beq cr6, 0x830f30f4
	if ctx.cr[6].eq {
	pc = 0x830F30F4; continue 'dispatch;
	}
	// 830F301C: 2B1F0005  cmplwi cr6, r31, 5
	ctx.cr[6].compare_u32(ctx.r[31].u32, 5 as u32, &mut ctx.xer);
	// 830F3020: 41980074  blt cr6, 0x830f3094
	if ctx.cr[6].lt {
	pc = 0x830F3094; continue 'dispatch;
	}
	// 830F3024: 409A02BC  bne cr6, 0x830f32e0
	if !ctx.cr[6].eq {
	pc = 0x830F32E0; continue 'dispatch;
	}
	// 830F3028: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F302C: 4BFFF86D  bl 0x830f2898
	ctx.lr = 0x830F3030;
	sub_830F2898(ctx, base);
	// 830F3030: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3034: 41820350  beq 0x830f3384
	if ctx.cr[0].eq {
	pc = 0x830F3384; continue 'dispatch;
	}
	// 830F3038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F303C: 4BFFFC2D  bl 0x830f2c68
	ctx.lr = 0x830F3040;
	sub_830F2C68(ctx, base);
	// 830F3040: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3044: 57892036  slwi r9, r28, 4
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F3048: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F304C: 7F834A14  add r28, r3, r9
	ctx.r[28].u64 = ctx.r[3].u64 + ctx.r[9].u64;
	// 830F3050: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3054: 2B09000A  cmplwi cr6, r9, 0xa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 10 as u32, &mut ctx.xer);
	// 830F3058: 409A0018  bne cr6, 0x830f3070
	if !ctx.cr[6].eq {
	pc = 0x830F3070; continue 'dispatch;
	}
	// 830F305C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3060: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F3064: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F3068: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F306C: 48000010  b 0x830f307c
	pc = 0x830F307C; continue 'dispatch;
            }
            0x830F3070 => {
    //   block [0x830F3070..0x830F307C)
	// 830F3070: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3074: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F3078: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x830F307C; continue 'dispatch;
            }
            0x830F307C => {
    //   block [0x830F307C..0x830F3094)
	// 830F307C: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830F3080: 2B1CFFFF  cmplwi cr6, r28, 0xffff
	ctx.cr[6].compare_u32(ctx.r[28].u32, 65535 as u32, &mut ctx.xer);
	// 830F3084: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F3088: 419902C4  bgt cr6, 0x830f334c
	if ctx.cr[6].gt {
	pc = 0x830F334C; continue 'dispatch;
	}
	// 830F308C: 3BE00005  li r31, 5
	ctx.r[31].s64 = 5;
	// 830F3090: 4BFFFF6C  b 0x830f2ffc
	pc = 0x830F2FFC; continue 'dispatch;
            }
            0x830F3094 => {
    //   block [0x830F3094..0x830F30D8)
	// 830F3094: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F3098: 4BFFF801  bl 0x830f2898
	ctx.lr = 0x830F309C;
	sub_830F2898(ctx, base);
	// 830F309C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F30A0: 41820348  beq 0x830f33e8
	if ctx.cr[0].eq {
	pc = 0x830F33E8; continue 'dispatch;
	}
	// 830F30A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F30A8: 4BFFFBC1  bl 0x830f2c68
	ctx.lr = 0x830F30AC;
	sub_830F2C68(ctx, base);
	// 830F30AC: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F30B0: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F30B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F30B8: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F30BC: 2B09000A  cmplwi cr6, r9, 0xa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 10 as u32, &mut ctx.xer);
	// 830F30C0: 409A0018  bne cr6, 0x830f30d8
	if !ctx.cr[6].eq {
	pc = 0x830F30D8; continue 'dispatch;
	}
	// 830F30C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F30C8: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F30CC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F30D0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F30D4: 48000010  b 0x830f30e4
	pc = 0x830F30E4; continue 'dispatch;
            }
            0x830F30D8 => {
    //   block [0x830F30D8..0x830F30E4)
	// 830F30D8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F30DC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F30E0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x830F30E4; continue 'dispatch;
            }
            0x830F30E4 => {
    //   block [0x830F30E4..0x830F30E8)
	// 830F30E4: 3BE00005  li r31, 5
	ctx.r[31].s64 = 5;
	pc = 0x830F30E8; continue 'dispatch;
            }
            0x830F30E8 => {
    //   block [0x830F30E8..0x830F30EC)
	// 830F30E8: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	pc = 0x830F30EC; continue 'dispatch;
            }
            0x830F30EC => {
    //   block [0x830F30EC..0x830F30F4)
	// 830F30EC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F30F0: 4BFFFF0C  b 0x830f2ffc
	pc = 0x830F2FFC; continue 'dispatch;
            }
            0x830F30F4 => {
    //   block [0x830F30F4..0x830F310C)
	// 830F30F4: 57A9043E  clrlwi r9, r29, 0x10
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 830F30F8: 2B090030  cmplwi cr6, r9, 0x30
	ctx.cr[6].compare_u32(ctx.r[9].u32, 48 as u32, &mut ctx.xer);
	// 830F30FC: 41980010  blt cr6, 0x830f310c
	if ctx.cr[6].lt {
	pc = 0x830F310C; continue 'dispatch;
	}
	// 830F3100: 2B090039  cmplwi cr6, r9, 0x39
	ctx.cr[6].compare_u32(ctx.r[9].u32, 57 as u32, &mut ctx.xer);
	// 830F3104: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830F3108: 40990008  ble cr6, 0x830f3110
	if !ctx.cr[6].gt {
	pc = 0x830F3110; continue 'dispatch;
	}
	pc = 0x830F310C; continue 'dispatch;
            }
            0x830F310C => {
    //   block [0x830F310C..0x830F3110)
	// 830F310C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F3110; continue 'dispatch;
            }
            0x830F3110 => {
    //   block [0x830F3110..0x830F314C)
	// 830F3110: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3114: 418202E0  beq 0x830f33f4
	if ctx.cr[0].eq {
	pc = 0x830F33F4; continue 'dispatch;
	}
	// 830F3118: 1D5C000A  mulli r10, r28, 0xa
	ctx.r[10].s32 = ((ctx.r[28].s32 as i64 * 10 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 830F311C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F3120: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F3124: 3B8AFFD0  addi r28, r10, -0x30
	ctx.r[28].s64 = ctx.r[10].s64 + -48;
	// 830F3128: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F312C: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3130: 2B09000A  cmplwi cr6, r9, 0xa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 10 as u32, &mut ctx.xer);
	// 830F3134: 409A0018  bne cr6, 0x830f314c
	if !ctx.cr[6].eq {
	pc = 0x830F314C; continue 'dispatch;
	}
	// 830F3138: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F313C: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F3140: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F3144: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F3148: 48000010  b 0x830f3158
	pc = 0x830F3158; continue 'dispatch;
            }
            0x830F314C => {
    //   block [0x830F314C..0x830F3158)
	// 830F314C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3150: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F3154: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x830F3158; continue 'dispatch;
            }
            0x830F3158 => {
    //   block [0x830F3158..0x830F3170)
	// 830F3158: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830F315C: 2B1CFFFF  cmplwi cr6, r28, 0xffff
	ctx.cr[6].compare_u32(ctx.r[28].u32, 65535 as u32, &mut ctx.xer);
	// 830F3160: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F3164: 419901E8  bgt cr6, 0x830f334c
	if ctx.cr[6].gt {
	pc = 0x830F334C; continue 'dispatch;
	}
	// 830F3168: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 830F316C: 4BFFFE90  b 0x830f2ffc
	pc = 0x830F2FFC; continue 'dispatch;
            }
            0x830F3170 => {
    //   block [0x830F3170..0x830F31A4)
	// 830F3170: 57AA043E  clrlwi r10, r29, 0x10
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 830F3174: 2B0A0078  cmplwi cr6, r10, 0x78
	ctx.cr[6].compare_u32(ctx.r[10].u32, 120 as u32, &mut ctx.xer);
	// 830F3178: 409A0044  bne cr6, 0x830f31bc
	if !ctx.cr[6].eq {
	pc = 0x830F31BC; continue 'dispatch;
	}
	// 830F317C: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3180: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F3184: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3188: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F318C: 409A0018  bne cr6, 0x830f31a4
	if !ctx.cr[6].eq {
	pc = 0x830F31A4; continue 'dispatch;
	}
	// 830F3190: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3194: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F3198: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F319C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F31A0: 48000010  b 0x830f31b0
	pc = 0x830F31B0; continue 'dispatch;
            }
            0x830F31A4 => {
    //   block [0x830F31A4..0x830F31B0)
	// 830F31A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F31A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F31AC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F31B0; continue 'dispatch;
            }
            0x830F31B0 => {
    //   block [0x830F31B0..0x830F31BC)
	// 830F31B0: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F31B4: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 830F31B8: 4BFFFF34  b 0x830f30ec
	pc = 0x830F30EC; continue 'dispatch;
            }
            0x830F31BC => {
    //   block [0x830F31BC..0x830F31D0)
	// 830F31BC: 2B0A0030  cmplwi cr6, r10, 0x30
	ctx.cr[6].compare_u32(ctx.r[10].u32, 48 as u32, &mut ctx.xer);
	// 830F31C0: 41980010  blt cr6, 0x830f31d0
	if ctx.cr[6].lt {
	pc = 0x830F31D0; continue 'dispatch;
	}
	// 830F31C4: 2B0A0039  cmplwi cr6, r10, 0x39
	ctx.cr[6].compare_u32(ctx.r[10].u32, 57 as u32, &mut ctx.xer);
	// 830F31C8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830F31CC: 40990008  ble cr6, 0x830f31d4
	if !ctx.cr[6].gt {
	pc = 0x830F31D4; continue 'dispatch;
	}
	pc = 0x830F31D0; continue 'dispatch;
            }
            0x830F31D0 => {
    //   block [0x830F31D0..0x830F31D4)
	// 830F31D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F31D4; continue 'dispatch;
            }
            0x830F31D4 => {
    //   block [0x830F31D4..0x830F3208)
	// 830F31D4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F31D8: 41820234  beq 0x830f340c
	if ctx.cr[0].eq {
	pc = 0x830F340C; continue 'dispatch;
	}
	// 830F31DC: 3B8AFFD0  addi r28, r10, -0x30
	ctx.r[28].s64 = ctx.r[10].s64 + -48;
	// 830F31E0: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F31E4: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F31E8: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F31EC: 2B09000A  cmplwi cr6, r9, 0xa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 10 as u32, &mut ctx.xer);
	// 830F31F0: 409A0018  bne cr6, 0x830f3208
	if !ctx.cr[6].eq {
	pc = 0x830F3208; continue 'dispatch;
	}
	// 830F31F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F31F8: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F31FC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F3200: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F3204: 48000010  b 0x830f3214
	pc = 0x830F3214; continue 'dispatch;
            }
            0x830F3208 => {
    //   block [0x830F3208..0x830F3214)
	// 830F3208: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F320C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F3210: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x830F3214; continue 'dispatch;
            }
            0x830F3214 => {
    //   block [0x830F3214..0x830F321C)
	// 830F3214: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 830F3218: 4BFFFED0  b 0x830f30e8
	pc = 0x830F30E8; continue 'dispatch;
            }
            0x830F321C => {
    //   block [0x830F321C..0x830F3250)
	// 830F321C: 57AB043E  clrlwi r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 830F3220: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 830F3224: 409A01F4  bne cr6, 0x830f3418
	if !ctx.cr[6].eq {
	pc = 0x830F3418; continue 'dispatch;
	}
	// 830F3228: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F322C: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F3230: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3234: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F3238: 409A0018  bne cr6, 0x830f3250
	if !ctx.cr[6].eq {
	pc = 0x830F3250; continue 'dispatch;
	}
	// 830F323C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3240: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F3244: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F3248: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F324C: 48000010  b 0x830f325c
	pc = 0x830F325C; continue 'dispatch;
            }
            0x830F3250 => {
    //   block [0x830F3250..0x830F325C)
	// 830F3250: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3254: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F3258: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F325C; continue 'dispatch;
            }
            0x830F325C => {
    //   block [0x830F325C..0x830F3268)
	// 830F325C: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F3260: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 830F3264: 4BFFFE88  b 0x830f30ec
	pc = 0x830F30EC; continue 'dispatch;
            }
            0x830F3268 => {
    //   block [0x830F3268..0x830F329C)
	// 830F3268: 57AB043E  clrlwi r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 830F326C: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 830F3270: 409A0044  bne cr6, 0x830f32b4
	if !ctx.cr[6].eq {
	pc = 0x830F32B4; continue 'dispatch;
	}
	// 830F3274: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3278: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F327C: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3280: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F3284: 409A0018  bne cr6, 0x830f329c
	if !ctx.cr[6].eq {
	pc = 0x830F329C; continue 'dispatch;
	}
	// 830F3288: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F328C: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F3290: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F3294: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F3298: 48000010  b 0x830f32a8
	pc = 0x830F32A8; continue 'dispatch;
            }
            0x830F329C => {
    //   block [0x830F329C..0x830F32A8)
	// 830F329C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F32A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F32A4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F32A8; continue 'dispatch;
            }
            0x830F32A8 => {
    //   block [0x830F32A8..0x830F32B4)
	// 830F32A8: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F32AC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 830F32B0: 4BFFFE3C  b 0x830f30ec
	pc = 0x830F30EC; continue 'dispatch;
            }
            0x830F32B4 => {
    //   block [0x830F32B4..0x830F32E0)
	// 830F32B4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F32B8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 830F32BC: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F32C0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830F32C4: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F32C8: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F32CC: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F32D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F32D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F32D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F32DC: 4E800421  bctrl
	ctx.lr = 0x830F32E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F32E0 => {
    //   block [0x830F32E0..0x830F32F0)
	// 830F32E0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F32E4: 4098FD18  bge cr6, 0x830f2ffc
	if !ctx.cr[6].lt {
	pc = 0x830F2FFC; continue 'dispatch;
	}
	// 830F32E8: 2F1FFFFE  cmpwi cr6, r31, -2
	ctx.cr[6].compare_i32(ctx.r[31].s32, -2, &mut ctx.xer);
	// 830F32EC: 409A0048  bne cr6, 0x830f3334
	if !ctx.cr[6].eq {
	pc = 0x830F3334; continue 'dispatch;
	}
	pc = 0x830F32F0; continue 'dispatch;
            }
            0x830F32F0 => {
    //   block [0x830F32F0..0x830F3334)
	// 830F32F0: 5783043E  clrlwi r3, r28, 0x10
	ctx.r[3].u64 = ctx.r[28].u32 as u64 & 0x0000FFFFu64;
	// 830F32F4: 4BFFF71D  bl 0x830f2a10
	ctx.lr = 0x830F32F8;
	sub_830F2A10(ctx, base);
	// 830F32F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F32FC: 40820038  bne 0x830f3334
	if !ctx.cr[0].eq {
	pc = 0x830F3334; continue 'dispatch;
	}
	// 830F3300: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3304: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F3308: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F330C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 830F3310: 38EBABF0  addi r7, r11, -0x5410
	ctx.r[7].s64 = ctx.r[11].s64 + -21520;
	// 830F3314: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3318: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 830F331C: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F3320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3324: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F332C: 4E800421  bctrl
	ctx.lr = 0x830F3330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F3330: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
            }
            0x830F3334 => {
    //   block [0x830F3334..0x830F334C)
	// 830F3334: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 830F3338: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F333C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F3340: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 830F3344: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F3348: 4BBB6104  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830F334C => {
    //   block [0x830F334C..0x830F3360)
	// 830F334C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F3350: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F3354: 390BABCC  addi r8, r11, -0x5434
	ctx.r[8].s64 = ctx.r[11].s64 + -21556;
	// 830F3358: 38EAA70C  addi r7, r10, -0x58f4
	ctx.r[7].s64 = ctx.r[10].s64 + -22772;
	// 830F335C: 3880D8F3  li r4, -0x270d
	ctx.r[4].s64 = -9997;
	pc = 0x830F3360; continue 'dispatch;
            }
            0x830F3360 => {
    //   block [0x830F3360..0x830F3384)
	// 830F3360: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3364: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F3368: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F336C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F3370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3374: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3378: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F337C: 4E800421  bctrl
	ctx.lr = 0x830F3380;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F3380: 4BFFFFB4  b 0x830f3334
	pc = 0x830F3334; continue 'dispatch;
            }
            0x830F3384 => {
    //   block [0x830F3384..0x830F3390)
	// 830F3384: 57AB043E  clrlwi r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 830F3388: 2B0B003B  cmplwi cr6, r11, 0x3b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 59 as u32, &mut ctx.xer);
	// 830F338C: 409A0048  bne cr6, 0x830f33d4
	if !ctx.cr[6].eq {
	pc = 0x830F33D4; continue 'dispatch;
	}
	pc = 0x830F3390; continue 'dispatch;
            }
            0x830F3390 => {
    //   block [0x830F3390..0x830F33B8)
	// 830F3390: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3394: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F3398: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F339C: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F33A0: 409A0018  bne cr6, 0x830f33b8
	if !ctx.cr[6].eq {
	pc = 0x830F33B8; continue 'dispatch;
	}
	// 830F33A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F33A8: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F33AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F33B0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F33B4: 48000010  b 0x830f33c4
	pc = 0x830F33C4; continue 'dispatch;
            }
            0x830F33B8 => {
    //   block [0x830F33B8..0x830F33C4)
	// 830F33B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F33BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F33C0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F33C4; continue 'dispatch;
            }
            0x830F33C4 => {
    //   block [0x830F33C4..0x830F33D4)
	// 830F33C4: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F33C8: 3BE0FFFE  li r31, -2
	ctx.r[31].s64 = -2;
	// 830F33CC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F33D0: 4BFFFF20  b 0x830f32f0
	pc = 0x830F32F0; continue 'dispatch;
            }
            0x830F33D4 => {
    //   block [0x830F33D4..0x830F33DC)
	// 830F33D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F33D8: 390BABB8  addi r8, r11, -0x5448
	ctx.r[8].s64 = ctx.r[11].s64 + -21576;
	pc = 0x830F33DC; continue 'dispatch;
            }
            0x830F33DC => {
    //   block [0x830F33DC..0x830F33E8)
	// 830F33DC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830F33E0: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F33E4: 4BFFFF7C  b 0x830f3360
	pc = 0x830F3360; continue 'dispatch;
            }
            0x830F33E8 => {
    //   block [0x830F33E8..0x830F33F4)
	// 830F33E8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F33EC: 390BAB98  addi r8, r11, -0x5468
	ctx.r[8].s64 = ctx.r[11].s64 + -21608;
	// 830F33F0: 4BFFFFEC  b 0x830f33dc
	pc = 0x830F33DC; continue 'dispatch;
            }
            0x830F33F4 => {
    //   block [0x830F33F4..0x830F340C)
	// 830F33F4: 57AB043E  clrlwi r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 830F33F8: 2B0B003B  cmplwi cr6, r11, 0x3b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 59 as u32, &mut ctx.xer);
	// 830F33FC: 419AFF94  beq cr6, 0x830f3390
	if ctx.cr[6].eq {
	pc = 0x830F3390; continue 'dispatch;
	}
	// 830F3400: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F3404: 390BAB88  addi r8, r11, -0x5478
	ctx.r[8].s64 = ctx.r[11].s64 + -21624;
	// 830F3408: 4BFFFFD4  b 0x830f33dc
	pc = 0x830F33DC; continue 'dispatch;
            }
            0x830F340C => {
    //   block [0x830F340C..0x830F3418)
	// 830F340C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F3410: 390BAB78  addi r8, r11, -0x5488
	ctx.r[8].s64 = ctx.r[11].s64 + -21640;
	// 830F3414: 4BFFFFC8  b 0x830f33dc
	pc = 0x830F33DC; continue 'dispatch;
            }
            0x830F3418 => {
    //   block [0x830F3418..0x830F3424)
	// 830F3418: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F341C: 390BAB74  addi r8, r11, -0x548c
	ctx.r[8].s64 = ctx.r[11].s64 + -21644;
	// 830F3420: 4BFFFFBC  b 0x830f33dc
	pc = 0x830F33DC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3428 size=472
    let mut pc: u32 = 0x830F3428;
    'dispatch: loop {
        match pc {
            0x830F3428 => {
    //   block [0x830F3428..0x830F344C)
	// 830F3428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F342C: 4BBB5FDD  bl 0x82ca9408
	ctx.lr = 0x830F3430;
	sub_82CA93D0(ctx, base);
	// 830F3430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3434: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F3438: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 830F343C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3440: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F3444: 3BABA9BC  addi r29, r11, -0x5644
	ctx.r[29].s64 = ctx.r[11].s64 + -22084;
	// 830F3448: 3B8AF604  addi r28, r10, -0x9fc
	ctx.r[28].s64 = ctx.r[10].s64 + -2556;
	pc = 0x830F344C; continue 'dispatch;
            }
            0x830F344C => {
    //   block [0x830F344C..0x830F3494)
	// 830F344C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3450: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 830F3454: A06B0000  lhz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3458: 419800B8  blt cr6, 0x830f3510
	if ctx.cr[6].lt {
	pc = 0x830F3510; continue 'dispatch;
	}
	// 830F345C: 419A00A0  beq cr6, 0x830f34fc
	if ctx.cr[6].eq {
	pc = 0x830F34FC; continue 'dispatch;
	}
	// 830F3460: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 830F3464: 41980084  blt cr6, 0x830f34e8
	if ctx.cr[6].lt {
	pc = 0x830F34E8; continue 'dispatch;
	}
	// 830F3468: 419A0068  beq cr6, 0x830f34d0
	if ctx.cr[6].eq {
	pc = 0x830F34D0; continue 'dispatch;
	}
	// 830F346C: 2B1E0005  cmplwi cr6, r30, 5
	ctx.cr[6].compare_u32(ctx.r[30].u32, 5 as u32, &mut ctx.xer);
	// 830F3470: 4198004C  blt cr6, 0x830f34bc
	if ctx.cr[6].lt {
	pc = 0x830F34BC; continue 'dispatch;
	}
	// 830F3474: 419A0020  beq cr6, 0x830f3494
	if ctx.cr[6].eq {
	pc = 0x830F3494; continue 'dispatch;
	}
	// 830F3478: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 830F347C: 409800D4  bge cr6, 0x830f3550
	if !ctx.cr[6].lt {
	pc = 0x830F3550; continue 'dispatch;
	}
	// 830F3480: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F3484: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 830F3488: 409A011C  bne cr6, 0x830f35a4
	if !ctx.cr[6].eq {
	pc = 0x830F35A4; continue 'dispatch;
	}
	// 830F348C: 3BC0FFFE  li r30, -2
	ctx.r[30].s64 = -2;
	// 830F3490: 480000C8  b 0x830f3558
	pc = 0x830F3558; continue 'dispatch;
            }
            0x830F3494 => {
    //   block [0x830F3494..0x830F34A8)
	// 830F3494: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F3498: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 830F349C: 409A000C  bne cr6, 0x830f34a8
	if !ctx.cr[6].eq {
	pc = 0x830F34A8; continue 'dispatch;
	}
	// 830F34A0: 3BC00006  li r30, 6
	ctx.r[30].s64 = 6;
	// 830F34A4: 480000B4  b 0x830f3558
	pc = 0x830F3558; continue 'dispatch;
            }
            0x830F34A8 => {
    //   block [0x830F34A8..0x830F34B4)
	// 830F34A8: 4BFFF569  bl 0x830f2a10
	ctx.lr = 0x830F34AC;
	sub_830F2A10(ctx, base);
	// 830F34AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F34B0: 41820100  beq 0x830f35b0
	if ctx.cr[0].eq {
	pc = 0x830F35B0; continue 'dispatch;
	}
	pc = 0x830F34B4; continue 'dispatch;
            }
            0x830F34B4 => {
    //   block [0x830F34B4..0x830F34BC)
	// 830F34B4: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 830F34B8: 480000A0  b 0x830f3558
	pc = 0x830F3558; continue 'dispatch;
            }
            0x830F34BC => {
    //   block [0x830F34BC..0x830F34D0)
	// 830F34BC: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F34C0: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 830F34C4: 409AFFE4  bne cr6, 0x830f34a8
	if !ctx.cr[6].eq {
	pc = 0x830F34A8; continue 'dispatch;
	}
	// 830F34C8: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 830F34CC: 4800008C  b 0x830f3558
	pc = 0x830F3558; continue 'dispatch;
            }
            0x830F34D0 => {
    //   block [0x830F34D0..0x830F34DC)
	// 830F34D0: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F34D4: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 830F34D8: 419AFFDC  beq cr6, 0x830f34b4
	if ctx.cr[6].eq {
	pc = 0x830F34B4; continue 'dispatch;
	}
	pc = 0x830F34DC; continue 'dispatch;
            }
            0x830F34DC => {
    //   block [0x830F34DC..0x830F34E8)
	// 830F34DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830F34E0: 390B9350  addi r8, r11, -0x6cb0
	ctx.r[8].s64 = ctx.r[11].s64 + -27824;
	// 830F34E4: 480000E0  b 0x830f35c4
	pc = 0x830F35C4; continue 'dispatch;
            }
            0x830F34E8 => {
    //   block [0x830F34E8..0x830F34FC)
	// 830F34E8: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F34EC: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 830F34F0: 409AFFEC  bne cr6, 0x830f34dc
	if !ctx.cr[6].eq {
	pc = 0x830F34DC; continue 'dispatch;
	}
	// 830F34F4: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 830F34F8: 48000060  b 0x830f3558
	pc = 0x830F3558; continue 'dispatch;
            }
            0x830F34FC => {
    //   block [0x830F34FC..0x830F3510)
	// 830F34FC: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F3500: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 830F3504: 409A00B8  bne cr6, 0x830f35bc
	if !ctx.cr[6].eq {
	pc = 0x830F35BC; continue 'dispatch;
	}
	// 830F3508: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 830F350C: 4800004C  b 0x830f3558
	pc = 0x830F3558; continue 'dispatch;
            }
            0x830F3510 => {
    //   block [0x830F3510..0x830F3524)
	// 830F3510: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F3514: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 830F3518: 409A000C  bne cr6, 0x830f3524
	if !ctx.cr[6].eq {
	pc = 0x830F3524; continue 'dispatch;
	}
	// 830F351C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F3520: 48000038  b 0x830f3558
	pc = 0x830F3558; continue 'dispatch;
            }
            0x830F3524 => {
    //   block [0x830F3524..0x830F3550)
	// 830F3524: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3528: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 830F352C: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F3530: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830F3534: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3538: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830F353C: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F3540: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3544: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3548: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F354C: 4E800421  bctrl
	ctx.lr = 0x830F3550;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F3550 => {
    //   block [0x830F3550..0x830F3558)
	// 830F3550: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 830F3554: 419A0044  beq cr6, 0x830f3598
	if ctx.cr[6].eq {
	pc = 0x830F3598; continue 'dispatch;
	}
	pc = 0x830F3558; continue 'dispatch;
            }
            0x830F3558 => {
    //   block [0x830F3558..0x830F3584)
	// 830F3558: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F355C: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 830F3560: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3564: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F3568: 409A001C  bne cr6, 0x830f3584
	if !ctx.cr[6].eq {
	pc = 0x830F3584; continue 'dispatch;
	}
	// 830F356C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3570: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F3574: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F3578: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830F357C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F3580: 48000010  b 0x830f3590
	pc = 0x830F3590; continue 'dispatch;
            }
            0x830F3584 => {
    //   block [0x830F3584..0x830F3590)
	// 830F3584: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3588: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F358C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F3590; continue 'dispatch;
            }
            0x830F3590 => {
    //   block [0x830F3590..0x830F3598)
	// 830F3590: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F3594: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x830F3598; continue 'dispatch;
            }
            0x830F3598 => {
    //   block [0x830F3598..0x830F35A4)
	// 830F3598: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F359C: 4098FEB0  bge cr6, 0x830f344c
	if !ctx.cr[6].lt {
	pc = 0x830F344C; continue 'dispatch;
	}
	// 830F35A0: 4800004C  b 0x830f35ec
	pc = 0x830F35EC; continue 'dispatch;
            }
            0x830F35A4 => {
    //   block [0x830F35A4..0x830F35B0)
	// 830F35A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 830F35A8: 390BF608  addi r8, r11, -0x9f8
	ctx.r[8].s64 = ctx.r[11].s64 + -2552;
	// 830F35AC: 48000018  b 0x830f35c4
	pc = 0x830F35C4; continue 'dispatch;
            }
            0x830F35B0 => {
    //   block [0x830F35B0..0x830F35BC)
	// 830F35B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F35B4: 390BAC4C  addi r8, r11, -0x53b4
	ctx.r[8].s64 = ctx.r[11].s64 + -21428;
	// 830F35B8: 4800000C  b 0x830f35c4
	pc = 0x830F35C4; continue 'dispatch;
            }
            0x830F35BC => {
    //   block [0x830F35BC..0x830F35C4)
	// 830F35BC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 830F35C0: 390B0C64  addi r8, r11, 0xc64
	ctx.r[8].s64 = ctx.r[11].s64 + 3172;
	pc = 0x830F35C4; continue 'dispatch;
            }
            0x830F35C4 => {
    //   block [0x830F35C4..0x830F35EC)
	// 830F35C4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F35C8: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F35CC: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F35D0: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830F35D4: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F35D8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830F35DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F35E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F35E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F35E8: 4E800421  bctrl
	ctx.lr = 0x830F35EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F35EC => {
    //   block [0x830F35EC..0x830F3600)
	// 830F35EC: 397E0002  addi r11, r30, 2
	ctx.r[11].s64 = ctx.r[30].s64 + 2;
	// 830F35F0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F35F4: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F35F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F35FC: 4BBB5E5C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3600 size=120
    let mut pc: u32 = 0x830F3600;
    'dispatch: loop {
        match pc {
            0x830F3600 => {
    //   block [0x830F3600..0x830F363C)
	// 830F3600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3608: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F360C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3610: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3614: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F3618: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F361C: 419A0020  beq cr6, 0x830f363c
	if ctx.cr[6].eq {
	pc = 0x830F363C; continue 'dispatch;
	}
	// 830F3620: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3624: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3628: 419A0014  beq cr6, 0x830f363c
	if ctx.cr[6].eq {
	pc = 0x830F363C; continue 'dispatch;
	}
	// 830F362C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3630: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3634: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F3638: 4E800421  bctrl
	ctx.lr = 0x830F363C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F363C => {
    //   block [0x830F363C..0x830F3664)
	// 830F363C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3640: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F3644: 419A0020  beq cr6, 0x830f3664
	if ctx.cr[6].eq {
	pc = 0x830F3664; continue 'dispatch;
	}
	// 830F3648: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F364C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3650: 419A0014  beq cr6, 0x830f3664
	if ctx.cr[6].eq {
	pc = 0x830F3664; continue 'dispatch;
	}
	// 830F3654: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3658: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F365C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F3660: 4E800421  bctrl
	ctx.lr = 0x830F3664;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F3664 => {
    //   block [0x830F3664..0x830F3678)
	// 830F3664: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F3668: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F366C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3678 size=148
    let mut pc: u32 = 0x830F3678;
    'dispatch: loop {
        match pc {
            0x830F3678 => {
    //   block [0x830F3678..0x830F36EC)
	// 830F3678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F367C: 4BBB5D91  bl 0x82ca940c
	ctx.lr = 0x830F3680;
	sub_82CA93D0(ctx, base);
	// 830F3680: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3684: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F3688: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F368C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F3690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3694: 4BFFF27D  bl 0x830f2910
	ctx.lr = 0x830F3698;
	sub_830F2910(ctx, base);
	// 830F3698: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F369C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830F36A0: 4098004C  bge cr6, 0x830f36ec
	if !ctx.cr[6].lt {
	pc = 0x830F36EC; continue 'dispatch;
	}
	// 830F36A4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F36A8: 388BBBD9  addi r4, r11, -0x4427
	ctx.r[4].s64 = ctx.r[11].s64 + -17447;
	// 830F36AC: 896BBBD9  lbz r11, -0x4427(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-17447 as u32) ) } as u64;
	// 830F36B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F36B4: 40820038  bne 0x830f36ec
	if !ctx.cr[0].eq {
	pc = 0x830F36EC; continue 'dispatch;
	}
	// 830F36B8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F36BC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F36C0: 396BAC68  addi r11, r11, -0x5398
	ctx.r[11].s64 = ctx.r[11].s64 + -21400;
	// 830F36C4: 394AAC58  addi r10, r10, -0x53a8
	ctx.r[10].s64 = ctx.r[10].s64 + -21416;
	// 830F36C8: 39200057  li r9, 0x57
	ctx.r[9].s64 = 87;
	// 830F36CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F36D0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830F36D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F36D8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 830F36DC: 4BFFE6DD  bl 0x830f1db8
	ctx.lr = 0x830F36E0;
	sub_830F1DB8(ctx, base);
	// 830F36E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F36E4: 40820008  bne 0x830f36ec
	if !ctx.cr[0].eq {
	pc = 0x830F36EC; continue 'dispatch;
	}
	// 830F36E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F36EC; continue 'dispatch;
            }
            0x830F36EC => {
    //   block [0x830F36EC..0x830F370C)
	// 830F36EC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F36F0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F36F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F36F8: 389E0001  addi r4, r30, 1
	ctx.r[4].s64 = ctx.r[30].s64 + 1;
	// 830F36FC: 4BFFDC2D  bl 0x830f1328
	ctx.lr = 0x830F3700;
	sub_830F1328(ctx, base);
	// 830F3700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3704: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F3708: 4BBB5D54  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F3710 size=108
    let mut pc: u32 = 0x830F3710;
    'dispatch: loop {
        match pc {
            0x830F3710 => {
    //   block [0x830F3710..0x830F372C)
	// 830F3710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3718: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F371C: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3720: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3724: 4182002C  beq 0x830f3750
	if ctx.cr[0].eq {
	pc = 0x830F3750; continue 'dispatch;
	}
	// 830F3728: 409A0010  bne cr6, 0x830f3738
	if !ctx.cr[6].eq {
	pc = 0x830F3738; continue 'dispatch;
	}
	pc = 0x830F372C; continue 'dispatch;
            }
            0x830F372C => {
    //   block [0x830F372C..0x830F3738)
	// 830F372C: 21640000  subfic r11, r4, 0
	ctx.xer.ca = ctx.r[4].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[4].s64;
	// 830F3730: 7C6B5910  subfe r3, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[3].u32 = res;
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830F3734: 4800002C  b 0x830f3760
	pc = 0x830F3760; continue 'dispatch;
            }
            0x830F3738 => {
    //   block [0x830F3738..0x830F3740)
	// 830F3738: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F373C: 409A000C  bne cr6, 0x830f3748
	if !ctx.cr[6].eq {
	pc = 0x830F3748; continue 'dispatch;
	}
	pc = 0x830F3740; continue 'dispatch;
            }
            0x830F3740 => {
    //   block [0x830F3740..0x830F3748)
	// 830F3740: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F3744: 4800001C  b 0x830f3760
	pc = 0x830F3760; continue 'dispatch;
            }
            0x830F3748 => {
    //   block [0x830F3748..0x830F3750)
	// 830F3748: 4BBBCAA1  bl 0x82cb01e8
	ctx.lr = 0x830F374C;
	sub_82CB01E8(ctx, base);
	// 830F374C: 48000014  b 0x830f3760
	pc = 0x830F3760; continue 'dispatch;
            }
            0x830F3750 => {
    //   block [0x830F3750..0x830F3760)
	// 830F3750: 419AFFDC  beq cr6, 0x830f372c
	if ctx.cr[6].eq {
	pc = 0x830F372C; continue 'dispatch;
	}
	// 830F3754: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F3758: 419AFFE8  beq cr6, 0x830f3740
	if ctx.cr[6].eq {
	pc = 0x830F3740; continue 'dispatch;
	}
	// 830F375C: 4BF15A45  bl 0x830091a0
	ctx.lr = 0x830F3760;
	sub_830091A0(ctx, base);
	pc = 0x830F3760; continue 'dispatch;
            }
            0x830F3760 => {
    //   block [0x830F3760..0x830F377C)
	// 830F3760: 39630000  addi r11, r3, 0
	ctx.r[11].s64 = ctx.r[3].s64 + 0;
	// 830F3764: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F3768: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F376C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F3770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3780 size=192
    let mut pc: u32 = 0x830F3780;
    'dispatch: loop {
        match pc {
            0x830F3780 => {
    //   block [0x830F3780..0x830F37F0)
	// 830F3780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F378C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3798: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F379C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F37A0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830F37A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F37A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F37AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F37B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F37B4: 4E800421  bctrl
	ctx.lr = 0x830F37B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F37B8: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F37BC: 40820034  bne 0x830f37f0
	if !ctx.cr[0].eq {
	pc = 0x830F37F0; continue 'dispatch;
	}
	// 830F37C0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F37C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F37C8: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F37CC: 3880D8F1  li r4, -0x270f
	ctx.r[4].s64 = -9999;
	// 830F37D0: 38EBA7B0  addi r7, r11, -0x5850
	ctx.r[7].s64 = ctx.r[11].s64 + -22608;
	// 830F37D4: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F37D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F37DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F37E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F37E4: 4E800421  bctrl
	ctx.lr = 0x830F37E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F37E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F37EC: 4800003C  b 0x830f3828
	pc = 0x830F3828; continue 'dispatch;
            }
            0x830F37F0 => {
    //   block [0x830F37F0..0x830F3828)
	// 830F37F0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830F37F4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F37F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F37FC: 3929AB24  addi r9, r9, -0x54dc
	ctx.r[9].s64 = ctx.r[9].s64 + -21724;
	// 830F3800: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830F3804: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F3808: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F380C: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830F3810: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830F3814: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830F3818: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 830F381C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 830F3820: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830F3824: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x830F3828; continue 'dispatch;
            }
            0x830F3828 => {
    //   block [0x830F3828..0x830F3840)
	// 830F3828: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F382C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F3838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F383C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F3840 size=80
    let mut pc: u32 = 0x830F3840;
    'dispatch: loop {
        match pc {
            0x830F3840 => {
    //   block [0x830F3840..0x830F3860)
	// 830F3840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3848: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F384C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3850: 409A0010  bne cr6, 0x830f3860
	if !ctx.cr[6].eq {
	pc = 0x830F3860; continue 'dispatch;
	}
	// 830F3854: 21640000  subfic r11, r4, 0
	ctx.xer.ca = ctx.r[4].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[4].s64;
	// 830F3858: 7C6B5910  subfe r3, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[3].u32 = res;
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830F385C: 48000018  b 0x830f3874
	pc = 0x830F3874; continue 'dispatch;
            }
            0x830F3860 => {
    //   block [0x830F3860..0x830F3870)
	// 830F3860: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F3864: 409A000C  bne cr6, 0x830f3870
	if !ctx.cr[6].eq {
	pc = 0x830F3870; continue 'dispatch;
	}
	// 830F3868: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F386C: 48000008  b 0x830f3874
	pc = 0x830F3874; continue 'dispatch;
            }
            0x830F3870 => {
    //   block [0x830F3870..0x830F3874)
	// 830F3870: 4BBBC979  bl 0x82cb01e8
	ctx.lr = 0x830F3874;
	sub_82CB01E8(ctx, base);
	pc = 0x830F3874; continue 'dispatch;
            }
            0x830F3874 => {
    //   block [0x830F3874..0x830F3890)
	// 830F3874: 39630000  addi r11, r3, 0
	ctx.r[11].s64 = ctx.r[3].s64 + 0;
	// 830F3878: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F387C: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F3880: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F3884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F388C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3890 size=80
    let mut pc: u32 = 0x830F3890;
    'dispatch: loop {
        match pc {
            0x830F3890 => {
    //   block [0x830F3890..0x830F38C4)
	// 830F3890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3898: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F389C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F38A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F38A4: 480028B5  bl 0x830f6158
	ctx.lr = 0x830F38A8;
	sub_830F6158(ctx, base);
	// 830F38A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F38AC: 40820018  bne 0x830f38c4
	if !ctx.cr[0].eq {
	pc = 0x830F38C4; continue 'dispatch;
	}
	// 830F38B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F38B4: 4BFFF0FD  bl 0x830f29b0
	ctx.lr = 0x830F38B8;
	sub_830F29B0(ctx, base);
	// 830F38B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F38BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F38C0: 41820008  beq 0x830f38c8
	if ctx.cr[0].eq {
	pc = 0x830F38C8; continue 'dispatch;
	}
	pc = 0x830F38C4; continue 'dispatch;
            }
            0x830F38C4 => {
    //   block [0x830F38C4..0x830F38C8)
	// 830F38C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F38C8; continue 'dispatch;
            }
            0x830F38C8 => {
    //   block [0x830F38C8..0x830F38E0)
	// 830F38C8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F38CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F38D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F38D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F38D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F38DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F38E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F38E0 size=20
    let mut pc: u32 = 0x830F38E0;
    'dispatch: loop {
        match pc {
            0x830F38E0 => {
    //   block [0x830F38E0..0x830F38F4)
	// 830F38E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F38E4: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 830F38E8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 830F38EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F38F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F38F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F38F8 size=20
    let mut pc: u32 = 0x830F38F8;
    'dispatch: loop {
        match pc {
            0x830F38F8 => {
    //   block [0x830F38F8..0x830F390C)
	// 830F38F8: 8163FFF8  lwz r11, -8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F38FC: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 830F3900: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F3904: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F3908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F3910 size=8
    let mut pc: u32 = 0x830F3910;
    'dispatch: loop {
        match pc {
            0x830F3910 => {
    //   block [0x830F3910..0x830F3918)
	// 830F3910: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F3914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3918 size=120
    let mut pc: u32 = 0x830F3918;
    'dispatch: loop {
        match pc {
            0x830F3918 => {
    //   block [0x830F3918..0x830F3970)
	// 830F3918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F391C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F3924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F392C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3934: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F3938: 419A0038  beq cr6, 0x830f3970
	if ctx.cr[6].eq {
	pc = 0x830F3970; continue 'dispatch;
	}
	// 830F393C: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3940: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3944: 88BF0008  lbz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F3948: 4BFFFDC9  bl 0x830f3710
	ctx.lr = 0x830F394C;
	sub_830F3710(ctx, base);
	// 830F394C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3950: 41820020  beq 0x830f3970
	if ctx.cr[0].eq {
	pc = 0x830F3970; continue 'dispatch;
	}
	// 830F3954: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F3958: 88BF0008  lbz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F395C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3960: 4BFFFDB1  bl 0x830f3710
	ctx.lr = 0x830F3964;
	sub_830F3710(ctx, base);
	// 830F3964: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3968: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F396C: 40820008  bne 0x830f3974
	if !ctx.cr[0].eq {
	pc = 0x830F3974; continue 'dispatch;
	}
	pc = 0x830F3970; continue 'dispatch;
            }
            0x830F3970 => {
    //   block [0x830F3970..0x830F3974)
	// 830F3970: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F3974; continue 'dispatch;
            }
            0x830F3974 => {
    //   block [0x830F3974..0x830F3990)
	// 830F3974: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F3978: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F397C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3980: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3984: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F3988: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F398C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3990 size=128
    let mut pc: u32 = 0x830F3990;
    'dispatch: loop {
        match pc {
            0x830F3990 => {
    //   block [0x830F3990..0x830F39D8)
	// 830F3990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3998: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F399C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F39A0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830F39A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F39A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F39AC: 419A0048  beq cr6, 0x830f39f4
	if ctx.cr[6].eq {
	pc = 0x830F39F4; continue 'dispatch;
	}
	// 830F39B0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F39B4: 7D3F5850  subf r9, r31, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 830F39B8: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 830F39BC: 5529DFFF  rlwinm. r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F39C0: 41820034  beq 0x830f39f4
	if ctx.cr[0].eq {
	pc = 0x830F39F4; continue 'dispatch;
	}
	// 830F39C4: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 830F39C8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F39CC: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F39D0: 40820008  bne 0x830f39d8
	if !ctx.cr[0].eq {
	pc = 0x830F39D8; continue 'dispatch;
	}
	// 830F39D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x830F39D8; continue 'dispatch;
            }
            0x830F39D8 => {
    //   block [0x830F39D8..0x830F39F4)
	// 830F39D8: 80640014  lwz r3, 0x14(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F39DC: 88AA0004  lbz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F39E0: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F39E4: 4BFFFD2D  bl 0x830f3710
	ctx.lr = 0x830F39E8;
	sub_830F3710(ctx, base);
	// 830F39E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F39EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F39F0: 40820008  bne 0x830f39f8
	if !ctx.cr[0].eq {
	pc = 0x830F39F8; continue 'dispatch;
	}
	pc = 0x830F39F4; continue 'dispatch;
            }
            0x830F39F4 => {
    //   block [0x830F39F4..0x830F39F8)
	// 830F39F4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830F39F8; continue 'dispatch;
            }
            0x830F39F8 => {
    //   block [0x830F39F8..0x830F3A10)
	// 830F39F8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F39FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F3A00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3A04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3A08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3A0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F3A10 size=48
    let mut pc: u32 = 0x830F3A10;
    'dispatch: loop {
        match pc {
            0x830F3A10 => {
    //   block [0x830F3A10..0x830F3A1C)
	// 830F3A10: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3A14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F3A18: 4800001C  b 0x830f3a34
	pc = 0x830F3A34; continue 'dispatch;
            }
            0x830F3A1C => {
    //   block [0x830F3A1C..0x830F3A30)
	// 830F3A1C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F3A20: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 830F3A24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3A28: 419A0008  beq cr6, 0x830f3a30
	if ctx.cr[6].eq {
	pc = 0x830F3A30; continue 'dispatch;
	}
	// 830F3A2C: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830F3A30; continue 'dispatch;
            }
            0x830F3A30 => {
    //   block [0x830F3A30..0x830F3A34)
	// 830F3A30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x830F3A34; continue 'dispatch;
            }
            0x830F3A34 => {
    //   block [0x830F3A34..0x830F3A40)
	// 830F3A34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3A38: 409AFFE4  bne cr6, 0x830f3a1c
	if !ctx.cr[6].eq {
	pc = 0x830F3A1C; continue 'dispatch;
	}
	// 830F3A3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3A40 size=84
    let mut pc: u32 = 0x830F3A40;
    'dispatch: loop {
        match pc {
            0x830F3A40 => {
    //   block [0x830F3A40..0x830F3A64)
	// 830F3A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3A44: 4BBB59C9  bl 0x82ca940c
	ctx.lr = 0x830F3A48;
	sub_82CA93D0(ctx, base);
	// 830F3A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3A4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3A50: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3A54: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F3A58: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F3A5C: 419A002C  beq cr6, 0x830f3a88
	if ctx.cr[6].eq {
	pc = 0x830F3A88; continue 'dispatch;
	}
	// 830F3A60: 48000020  b 0x830f3a80
	pc = 0x830F3A80; continue 'dispatch;
            }
            0x830F3A64 => {
    //   block [0x830F3A64..0x830F3A80)
	// 830F3A64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F3A68: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3A6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F3A70: 4BFFFCA1  bl 0x830f3710
	ctx.lr = 0x830F3A74;
	sub_830F3710(ctx, base);
	// 830F3A74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3A78: 40820010  bne 0x830f3a88
	if !ctx.cr[0].eq {
	pc = 0x830F3A88; continue 'dispatch;
	}
	// 830F3A7C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830F3A80; continue 'dispatch;
            }
            0x830F3A80 => {
    //   block [0x830F3A80..0x830F3A88)
	// 830F3A80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F3A84: 409AFFE0  bne cr6, 0x830f3a64
	if !ctx.cr[6].eq {
	pc = 0x830F3A64; continue 'dispatch;
	}
	pc = 0x830F3A88; continue 'dispatch;
            }
            0x830F3A88 => {
    //   block [0x830F3A88..0x830F3A94)
	// 830F3A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3A8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F3A90: 4BBB59CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3A98 size=112
    let mut pc: u32 = 0x830F3A98;
    'dispatch: loop {
        match pc {
            0x830F3A98 => {
    //   block [0x830F3A98..0x830F3AC0)
	// 830F3A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3A9C: 4BBB596D  bl 0x82ca9408
	ctx.lr = 0x830F3AA0;
	sub_82CA93D0(ctx, base);
	// 830F3AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3AA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F3AA8: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3AAC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F3AB0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830F3AB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F3AB8: 419A0044  beq cr6, 0x830f3afc
	if ctx.cr[6].eq {
	pc = 0x830F3AFC; continue 'dispatch;
	}
	// 830F3ABC: 48000038  b 0x830f3af4
	pc = 0x830F3AF4; continue 'dispatch;
            }
            0x830F3AC0 => {
    //   block [0x830F3AC0..0x830F3AF4)
	// 830F3AC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F3AC4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3AC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F3ACC: 4BFFFC45  bl 0x830f3710
	ctx.lr = 0x830F3AD0;
	sub_830F3710(ctx, base);
	// 830F3AD0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3AD4: 40820028  bne 0x830f3afc
	if !ctx.cr[0].eq {
	pc = 0x830F3AFC; continue 'dispatch;
	}
	// 830F3AD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F3ADC: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F3AE0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F3AE4: 4BFFFC2D  bl 0x830f3710
	ctx.lr = 0x830F3AE8;
	sub_830F3710(ctx, base);
	// 830F3AE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3AEC: 40820010  bne 0x830f3afc
	if !ctx.cr[0].eq {
	pc = 0x830F3AFC; continue 'dispatch;
	}
	// 830F3AF0: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830F3AF4; continue 'dispatch;
            }
            0x830F3AF4 => {
    //   block [0x830F3AF4..0x830F3AFC)
	// 830F3AF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F3AF8: 409AFFC8  bne cr6, 0x830f3ac0
	if !ctx.cr[6].eq {
	pc = 0x830F3AC0; continue 'dispatch;
	}
	pc = 0x830F3AFC; continue 'dispatch;
            }
            0x830F3AFC => {
    //   block [0x830F3AFC..0x830F3B08)
	// 830F3AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3B00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F3B04: 4BBB5954  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F3B08 size=72
    let mut pc: u32 = 0x830F3B08;
    'dispatch: loop {
        match pc {
            0x830F3B08 => {
    //   block [0x830F3B08..0x830F3B18)
	// 830F3B08: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3B0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F3B10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3B14: 419A003C  beq cr6, 0x830f3b50
	if ctx.cr[6].eq {
		sub_830F3B50(ctx, base);
		return;
	}
	pc = 0x830F3B18; continue 'dispatch;
            }
            0x830F3B18 => {
    //   block [0x830F3B18..0x830F3B2C)
	// 830F3B18: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F3B1C: 4098001C  bge cr6, 0x830f3b38
	if !ctx.cr[6].lt {
	pc = 0x830F3B38; continue 'dispatch;
	}
	// 830F3B20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3B24: 419A0008  beq cr6, 0x830f3b2c
	if ctx.cr[6].eq {
	pc = 0x830F3B2C; continue 'dispatch;
	}
	// 830F3B28: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830F3B2C; continue 'dispatch;
            }
            0x830F3B2C => {
    //   block [0x830F3B2C..0x830F3B38)
	// 830F3B2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F3B30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3B34: 409AFFE4  bne cr6, 0x830f3b18
	if !ctx.cr[6].eq {
	pc = 0x830F3B18; continue 'dispatch;
	}
	pc = 0x830F3B38; continue 'dispatch;
            }
            0x830F3B38 => {
    //   block [0x830F3B38..0x830F3B50)
	// 830F3B38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3B3C: 419A0014  beq cr6, 0x830f3b50
	if ctx.cr[6].eq {
		sub_830F3B50(ctx, base);
		return;
	}
	// 830F3B40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3B44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3B48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F3B4C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F3B50 size=8
    let mut pc: u32 = 0x830F3B50;
    'dispatch: loop {
        match pc {
            0x830F3B50 => {
    //   block [0x830F3B50..0x830F3B58)
	// 830F3B50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F3B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3B58 size=104
    let mut pc: u32 = 0x830F3B58;
    'dispatch: loop {
        match pc {
            0x830F3B58 => {
    //   block [0x830F3B58..0x830F3B74)
	// 830F3B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3B5C: 4BBB58B1  bl 0x82ca940c
	ctx.lr = 0x830F3B60;
	sub_82CA93D0(ctx, base);
	// 830F3B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3B64: 83E3FFFC  lwz r31, -4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830F3B68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3B6C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F3B70: 48000034  b 0x830f3ba4
	pc = 0x830F3BA4; continue 'dispatch;
            }
            0x830F3B74 => {
    //   block [0x830F3B74..0x830F3BA0)
	// 830F3B74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3B78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3B7C: 409A0024  bne cr6, 0x830f3ba0
	if !ctx.cr[6].eq {
	pc = 0x830F3BA0; continue 'dispatch;
	}
	// 830F3B80: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F3B84: 419A0034  beq cr6, 0x830f3bb8
	if ctx.cr[6].eq {
	pc = 0x830F3BB8; continue 'dispatch;
	}
	// 830F3B88: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F3B8C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3B90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F3B94: 4BFFFB7D  bl 0x830f3710
	ctx.lr = 0x830F3B98;
	sub_830F3710(ctx, base);
	// 830F3B98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3B9C: 4082001C  bne 0x830f3bb8
	if !ctx.cr[0].eq {
	pc = 0x830F3BB8; continue 'dispatch;
	}
	pc = 0x830F3BA0; continue 'dispatch;
            }
            0x830F3BA0 => {
    //   block [0x830F3BA0..0x830F3BA4)
	// 830F3BA0: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830F3BA4; continue 'dispatch;
            }
            0x830F3BA4 => {
    //   block [0x830F3BA4..0x830F3BB0)
	// 830F3BA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F3BA8: 409AFFCC  bne cr6, 0x830f3b74
	if !ctx.cr[6].eq {
	pc = 0x830F3B74; continue 'dispatch;
	}
	// 830F3BAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F3BB0; continue 'dispatch;
            }
            0x830F3BB0 => {
    //   block [0x830F3BB0..0x830F3BB8)
	// 830F3BB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F3BB4: 4BBB58A8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830F3BB8 => {
    //   block [0x830F3BB8..0x830F3BC0)
	// 830F3BB8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830F3BBC: 4BFFFFF4  b 0x830f3bb0
	pc = 0x830F3BB0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3BC0 size=208
    let mut pc: u32 = 0x830F3BC0;
    'dispatch: loop {
        match pc {
            0x830F3BC0 => {
    //   block [0x830F3BC0..0x830F3BE0)
	// 830F3BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3BC4: 4BBB5849  bl 0x82ca940c
	ctx.lr = 0x830F3BC8;
	sub_82CA93D0(ctx, base);
	// 830F3BC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3BCC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F3BD0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F3BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3BD8: 3BCBACD8  addi r30, r11, -0x5328
	ctx.r[30].s64 = ctx.r[11].s64 + -21288;
	// 830F3BDC: 3BAAACCC  addi r29, r10, -0x5334
	ctx.r[29].s64 = ctx.r[10].s64 + -21300;
	pc = 0x830F3BE0; continue 'dispatch;
            }
            0x830F3BE0 => {
    //   block [0x830F3BE0..0x830F3C0C)
	// 830F3BE0: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3BE4: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3BE8: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F3BEC: 419A0020  beq cr6, 0x830f3c0c
	if ctx.cr[6].eq {
	pc = 0x830F3C0C; continue 'dispatch;
	}
	// 830F3BF0: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F3BF4: 419A0018  beq cr6, 0x830f3c0c
	if ctx.cr[6].eq {
	pc = 0x830F3C0C; continue 'dispatch;
	}
	// 830F3BF8: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F3BFC: 419A0010  beq cr6, 0x830f3c0c
	if ctx.cr[6].eq {
	pc = 0x830F3C0C; continue 'dispatch;
	}
	// 830F3C00: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F3C04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F3C08: 409A0008  bne cr6, 0x830f3c10
	if !ctx.cr[6].eq {
	pc = 0x830F3C10; continue 'dispatch;
	}
	pc = 0x830F3C0C; continue 'dispatch;
            }
            0x830F3C0C => {
    //   block [0x830F3C0C..0x830F3C10)
	// 830F3C0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F3C10; continue 'dispatch;
            }
            0x830F3C10 => {
    //   block [0x830F3C10..0x830F3C24)
	// 830F3C10: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3C14: 41820010  beq 0x830f3c24
	if ctx.cr[0].eq {
	pc = 0x830F3C24; continue 'dispatch;
	}
	// 830F3C18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3C1C: 4BFFF265  bl 0x830f2e80
	ctx.lr = 0x830F3C20;
	sub_830F2E80(ctx, base);
	// 830F3C20: 4BFFFFC0  b 0x830f3be0
	pc = 0x830F3BE0; continue 'dispatch;
            }
            0x830F3C24 => {
    //   block [0x830F3C24..0x830F3C4C)
	// 830F3C24: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F3C28: 41820024  beq 0x830f3c4c
	if ctx.cr[0].eq {
	pc = 0x830F3C4C; continue 'dispatch;
	}
	// 830F3C2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F3C30: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830F3C34: 4BBBD0D5  bl 0x82cb0d08
	ctx.lr = 0x830F3C38;
	sub_82CB0D08(ctx, base);
	// 830F3C38: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F3C3C: 40820010  bne 0x830f3c4c
	if !ctx.cr[0].eq {
	pc = 0x830F3C4C; continue 'dispatch;
	}
	// 830F3C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3C44: 4BFFF7E5  bl 0x830f3428
	ctx.lr = 0x830F3C48;
	sub_830F3428(ctx, base);
	// 830F3C48: 4800002C  b 0x830f3c74
	pc = 0x830F3C74; continue 'dispatch;
            }
            0x830F3C4C => {
    //   block [0x830F3C4C..0x830F3C74)
	// 830F3C4C: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3C50: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F3C54: 419A0030  beq cr6, 0x830f3c84
	if ctx.cr[6].eq {
	pc = 0x830F3C84; continue 'dispatch;
	}
	// 830F3C58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F3C5C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830F3C60: 4BBBD0A9  bl 0x82cb0d08
	ctx.lr = 0x830F3C64;
	sub_82CB0D08(ctx, base);
	// 830F3C64: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F3C68: 4082001C  bne 0x830f3c84
	if !ctx.cr[0].eq {
	pc = 0x830F3C84; continue 'dispatch;
	}
	// 830F3C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3C70: 4BFFF1B9  bl 0x830f2e28
	ctx.lr = 0x830F3C74;
	sub_830F2E28(ctx, base);
	pc = 0x830F3C74; continue 'dispatch;
            }
            0x830F3C74 => {
    //   block [0x830F3C74..0x830F3C84)
	// 830F3C74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3C78: 4082FF68  bne 0x830f3be0
	if !ctx.cr[0].eq {
	pc = 0x830F3BE0; continue 'dispatch;
	}
	// 830F3C7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F3C80: 48000008  b 0x830f3c88
	pc = 0x830F3C88; continue 'dispatch;
            }
            0x830F3C84 => {
    //   block [0x830F3C84..0x830F3C88)
	// 830F3C84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830F3C88; continue 'dispatch;
            }
            0x830F3C88 => {
    //   block [0x830F3C88..0x830F3C90)
	// 830F3C88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F3C8C: 4BBB57D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3C90 size=132
    let mut pc: u32 = 0x830F3C90;
    'dispatch: loop {
        match pc {
            0x830F3C90 => {
    //   block [0x830F3C90..0x830F3CBC)
	// 830F3C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3C98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F3C9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3CA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3CA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3CA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3CAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3CB0: 419A0040  beq cr6, 0x830f3cf0
	if ctx.cr[6].eq {
	pc = 0x830F3CF0; continue 'dispatch;
	}
	// 830F3CB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F3CB8: 419A0020  beq cr6, 0x830f3cd8
	if ctx.cr[6].eq {
	pc = 0x830F3CD8; continue 'dispatch;
	}
	pc = 0x830F3CBC; continue 'dispatch;
            }
            0x830F3CBC => {
    //   block [0x830F3CBC..0x830F3CD8)
	// 830F3CBC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3CC0: 88BE0004  lbz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3CC4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3CC8: 4BFFFA49  bl 0x830f3710
	ctx.lr = 0x830F3CCC;
	sub_830F3710(ctx, base);
	// 830F3CCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3CD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F3CD4: 40820008  bne 0x830f3cdc
	if !ctx.cr[0].eq {
	pc = 0x830F3CDC; continue 'dispatch;
	}
	pc = 0x830F3CD8; continue 'dispatch;
            }
            0x830F3CD8 => {
    //   block [0x830F3CD8..0x830F3CDC)
	// 830F3CD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F3CDC; continue 'dispatch;
            }
            0x830F3CDC => {
    //   block [0x830F3CDC..0x830F3CF0)
	// 830F3CDC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3CE0: 4082002C  bne 0x830f3d0c
	if !ctx.cr[0].eq {
	pc = 0x830F3D0C; continue 'dispatch;
	}
	// 830F3CE4: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3CE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F3CEC: 409AFFD0  bne cr6, 0x830f3cbc
	if !ctx.cr[6].eq {
	pc = 0x830F3CBC; continue 'dispatch;
	}
	pc = 0x830F3CF0; continue 'dispatch;
            }
            0x830F3CF0 => {
    //   block [0x830F3CF0..0x830F3CF4)
	// 830F3CF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F3CF4; continue 'dispatch;
            }
            0x830F3CF4 => {
    //   block [0x830F3CF4..0x830F3D0C)
	// 830F3CF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F3CF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3CFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3D00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F3D04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3D08: 4E800020  blr
	return;
            }
            0x830F3D0C => {
    //   block [0x830F3D0C..0x830F3D14)
	// 830F3D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3D10: 4BFFFFE4  b 0x830f3cf4
	pc = 0x830F3CF4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3D18 size=104
    let mut pc: u32 = 0x830F3D18;
    'dispatch: loop {
        match pc {
            0x830F3D18 => {
    //   block [0x830F3D18..0x830F3D3C)
	// 830F3D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3D20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F3D24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3D28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3D2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3D34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3D38: 419A0024  beq cr6, 0x830f3d5c
	if ctx.cr[6].eq {
	pc = 0x830F3D5C; continue 'dispatch;
	}
	pc = 0x830F3D3C; continue 'dispatch;
            }
            0x830F3D3C => {
    //   block [0x830F3D3C..0x830F3D5C)
	// 830F3D3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F3D40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F3D44: 4BFFFBD5  bl 0x830f3918
	ctx.lr = 0x830F3D48;
	sub_830F3918(ctx, base);
	// 830F3D48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3D4C: 4082002C  bne 0x830f3d78
	if !ctx.cr[0].eq {
	pc = 0x830F3D78; continue 'dispatch;
	}
	// 830F3D50: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3D54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F3D58: 409AFFE4  bne cr6, 0x830f3d3c
	if !ctx.cr[6].eq {
	pc = 0x830F3D3C; continue 'dispatch;
	}
	pc = 0x830F3D5C; continue 'dispatch;
            }
            0x830F3D5C => {
    //   block [0x830F3D5C..0x830F3D60)
	// 830F3D5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F3D60; continue 'dispatch;
            }
            0x830F3D60 => {
    //   block [0x830F3D60..0x830F3D78)
	// 830F3D60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F3D64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3D68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3D6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F3D70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3D74: 4E800020  blr
	return;
            }
            0x830F3D78 => {
    //   block [0x830F3D78..0x830F3D80)
	// 830F3D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3D7C: 4BFFFFE4  b 0x830f3d60
	pc = 0x830F3D60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3D80 size=104
    let mut pc: u32 = 0x830F3D80;
    'dispatch: loop {
        match pc {
            0x830F3D80 => {
    //   block [0x830F3D80..0x830F3DA4)
	// 830F3D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3D88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F3D8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3D90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3D94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3D9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3DA0: 419A0024  beq cr6, 0x830f3dc4
	if ctx.cr[6].eq {
	pc = 0x830F3DC4; continue 'dispatch;
	}
	pc = 0x830F3DA4; continue 'dispatch;
            }
            0x830F3DA4 => {
    //   block [0x830F3DA4..0x830F3DC4)
	// 830F3DA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F3DA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F3DAC: 4BFFFBE5  bl 0x830f3990
	ctx.lr = 0x830F3DB0;
	sub_830F3990(ctx, base);
	// 830F3DB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3DB4: 4082002C  bne 0x830f3de0
	if !ctx.cr[0].eq {
	pc = 0x830F3DE0; continue 'dispatch;
	}
	// 830F3DB8: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F3DBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F3DC0: 409AFFE4  bne cr6, 0x830f3da4
	if !ctx.cr[6].eq {
	pc = 0x830F3DA4; continue 'dispatch;
	}
	pc = 0x830F3DC4; continue 'dispatch;
            }
            0x830F3DC4 => {
    //   block [0x830F3DC4..0x830F3DC8)
	// 830F3DC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F3DC8; continue 'dispatch;
            }
            0x830F3DC8 => {
    //   block [0x830F3DC8..0x830F3DE0)
	// 830F3DC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F3DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3DD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F3DD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3DDC: 4E800020  blr
	return;
            }
            0x830F3DE0 => {
    //   block [0x830F3DE0..0x830F3DE8)
	// 830F3DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3DE4: 4BFFFFE4  b 0x830f3dc8
	pc = 0x830F3DC8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3DE8 size=84
    let mut pc: u32 = 0x830F3DE8;
    'dispatch: loop {
        match pc {
            0x830F3DE8 => {
    //   block [0x830F3DE8..0x830F3E20)
	// 830F3DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3DF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3DF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3DFC: 4BFFFA95  bl 0x830f3890
	ctx.lr = 0x830F3E00;
	sub_830F3890(ctx, base);
	// 830F3E00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3E04: 4082001C  bne 0x830f3e20
	if !ctx.cr[0].eq {
	pc = 0x830F3E20; continue 'dispatch;
	}
	// 830F3E08: 57EB043E  clrlwi r11, r31, 0x10
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000FFFFu64;
	// 830F3E0C: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 830F3E10: 419A0010  beq cr6, 0x830f3e20
	if ctx.cr[6].eq {
	pc = 0x830F3E20; continue 'dispatch;
	}
	// 830F3E14: 2B0B003A  cmplwi cr6, r11, 0x3a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 58 as u32, &mut ctx.xer);
	// 830F3E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F3E1C: 409A0008  bne cr6, 0x830f3e24
	if !ctx.cr[6].eq {
	pc = 0x830F3E24; continue 'dispatch;
	}
	pc = 0x830F3E20; continue 'dispatch;
            }
            0x830F3E20 => {
    //   block [0x830F3E20..0x830F3E24)
	// 830F3E20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F3E24; continue 'dispatch;
            }
            0x830F3E24 => {
    //   block [0x830F3E24..0x830F3E3C)
	// 830F3E24: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F3E28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F3E2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3E30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3E34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3E38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3E40 size=148
    let mut pc: u32 = 0x830F3E40;
    'dispatch: loop {
        match pc {
            0x830F3E40 => {
    //   block [0x830F3E40..0x830F3EB8)
	// 830F3E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3E44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3E48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3E4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3E50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3E54: 4BFFFA3D  bl 0x830f3890
	ctx.lr = 0x830F3E58;
	sub_830F3890(ctx, base);
	// 830F3E58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3E5C: 4082005C  bne 0x830f3eb8
	if !ctx.cr[0].eq {
	pc = 0x830F3EB8; continue 'dispatch;
	}
	// 830F3E60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3E64: 48002315  bl 0x830f6178
	ctx.lr = 0x830F3E68;
	sub_830F6178(ctx, base);
	// 830F3E68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3E6C: 4082004C  bne 0x830f3eb8
	if !ctx.cr[0].eq {
	pc = 0x830F3EB8; continue 'dispatch;
	}
	// 830F3E70: 57EB043E  clrlwi r11, r31, 0x10
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000FFFFu64;
	// 830F3E74: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 830F3E78: 419A0040  beq cr6, 0x830f3eb8
	if ctx.cr[6].eq {
	pc = 0x830F3EB8; continue 'dispatch;
	}
	// 830F3E7C: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 830F3E80: 419A0038  beq cr6, 0x830f3eb8
	if ctx.cr[6].eq {
	pc = 0x830F3EB8; continue 'dispatch;
	}
	// 830F3E84: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 830F3E88: 419A0030  beq cr6, 0x830f3eb8
	if ctx.cr[6].eq {
	pc = 0x830F3EB8; continue 'dispatch;
	}
	// 830F3E8C: 2B0B003A  cmplwi cr6, r11, 0x3a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 58 as u32, &mut ctx.xer);
	// 830F3E90: 419A0028  beq cr6, 0x830f3eb8
	if ctx.cr[6].eq {
	pc = 0x830F3EB8; continue 'dispatch;
	}
	// 830F3E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3E98: 480022D1  bl 0x830f6168
	ctx.lr = 0x830F3E9C;
	sub_830F6168(ctx, base);
	// 830F3E9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3EA0: 40820018  bne 0x830f3eb8
	if !ctx.cr[0].eq {
	pc = 0x830F3EB8; continue 'dispatch;
	}
	// 830F3EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3EA8: 480022E1  bl 0x830f6188
	ctx.lr = 0x830F3EAC;
	sub_830F6188(ctx, base);
	// 830F3EAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3EB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F3EB4: 41820008  beq 0x830f3ebc
	if ctx.cr[0].eq {
	pc = 0x830F3EBC; continue 'dispatch;
	}
	pc = 0x830F3EB8; continue 'dispatch;
            }
            0x830F3EB8 => {
    //   block [0x830F3EB8..0x830F3EBC)
	// 830F3EB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F3EBC; continue 'dispatch;
            }
            0x830F3EBC => {
    //   block [0x830F3EBC..0x830F3ED4)
	// 830F3EBC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F3EC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F3EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3ED8 size=216
    let mut pc: u32 = 0x830F3ED8;
    'dispatch: loop {
        match pc {
            0x830F3ED8 => {
    //   block [0x830F3ED8..0x830F3F48)
	// 830F3ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F3EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3EE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3EEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3EF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3EF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F3EF8: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 830F3EFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F3F0C: 4E800421  bctrl
	ctx.lr = 0x830F3F10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F3F10: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3F14: 40820034  bne 0x830f3f48
	if !ctx.cr[0].eq {
	pc = 0x830F3F48; continue 'dispatch;
	}
	// 830F3F18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3F1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F3F20: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F3F24: 3880D8F1  li r4, -0x270f
	ctx.r[4].s64 = -9999;
	// 830F3F28: 38EBA7B0  addi r7, r11, -0x5850
	ctx.r[7].s64 = ctx.r[11].s64 + -22608;
	// 830F3F2C: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3F30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F3F3C: 4E800421  bctrl
	ctx.lr = 0x830F3F40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F3F40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F3F44: 48000054  b 0x830f3f98
	pc = 0x830F3F98; continue 'dispatch;
            }
            0x830F3F48 => {
    //   block [0x830F3F48..0x830F3F98)
	// 830F3F48: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830F3F4C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F50: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 830F3F54: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 830F3F58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F3F5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830F3F60: 3929AB50  addi r9, r9, -0x54b0
	ctx.r[9].s64 = ctx.r[9].s64 + -21680;
	// 830F3F64: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F3F68: 38E7ADE4  addi r7, r7, -0x521c
	ctx.r[7].s64 = ctx.r[7].s64 + -21020;
	// 830F3F6C: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 830F3F70: 38C6ACC4  addi r6, r6, -0x533c
	ctx.r[6].s64 = ctx.r[6].s64 + -21308;
	// 830F3F74: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830F3F78: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 830F3F7C: 392B000C  addi r9, r11, 0xc
	ctx.r[9].s64 = ctx.r[11].s64 + 12;
	// 830F3F80: 90CB000C  stw r6, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 830F3F84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F3F88: 910B0010  stw r8, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 830F3F8C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 830F3F90: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 830F3F94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x830F3F98; continue 'dispatch;
            }
            0x830F3F98 => {
    //   block [0x830F3F98..0x830F3FB0)
	// 830F3F98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F3F9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3FA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3FA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F3FA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3FB0 size=64
    let mut pc: u32 = 0x830F3FB0;
    'dispatch: loop {
        match pc {
            0x830F3FB0 => {
    //   block [0x830F3FB0..0x830F3FE0)
	// 830F3FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3FB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3FBC: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 830F3FC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F3FC4: 98A10054  stb r5, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u8 ) };
	// 830F3FC8: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3FCC: 4BFFFDB5  bl 0x830f3d80
	ctx.lr = 0x830F3FD0;
	sub_830F3D80(ctx, base);
	// 830F3FD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F3FD4: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 830F3FD8: 40820008  bne 0x830f3fe0
	if !ctx.cr[0].eq {
	pc = 0x830F3FE0; continue 'dispatch;
	}
	// 830F3FDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F3FE0; continue 'dispatch;
            }
            0x830F3FE0 => {
    //   block [0x830F3FE0..0x830F3FF0)
	// 830F3FE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F3FE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3FE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3FF0 size=212
    let mut pc: u32 = 0x830F3FF0;
    'dispatch: loop {
        match pc {
            0x830F3FF0 => {
    //   block [0x830F3FF0..0x830F4020)
	// 830F3FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F3FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F4000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F4008: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F400C: A06B0000  lhz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4010: 4BFFFDD9  bl 0x830f3de8
	ctx.lr = 0x830F4014;
	sub_830F3DE8(ctx, base);
	// 830F4014: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4018: 41820060  beq 0x830f4078
	if ctx.cr[0].eq {
	pc = 0x830F4078; continue 'dispatch;
	}
	// 830F401C: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	pc = 0x830F4020; continue 'dispatch;
            }
            0x830F4020 => {
    //   block [0x830F4020..0x830F4048)
	// 830F4020: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F4024: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4028: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F402C: 409A001C  bne cr6, 0x830f4048
	if !ctx.cr[6].eq {
	pc = 0x830F4048; continue 'dispatch;
	}
	// 830F4030: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4034: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F4038: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F403C: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830F4040: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F4044: 48000010  b 0x830f4054
	pc = 0x830F4054; continue 'dispatch;
            }
            0x830F4048 => {
    //   block [0x830F4048..0x830F4054)
	// 830F4048: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F404C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F4050: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830F4054; continue 'dispatch;
            }
            0x830F4054 => {
    //   block [0x830F4054..0x830F4078)
	// 830F4054: 396A0002  addi r11, r10, 2
	ctx.r[11].s64 = ctx.r[10].s64 + 2;
	// 830F4058: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F405C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4060: A06B0000  lhz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4064: 4BFFFDDD  bl 0x830f3e40
	ctx.lr = 0x830F4068;
	sub_830F3E40(ctx, base);
	// 830F4068: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F406C: 4082FFB4  bne 0x830f4020
	if !ctx.cr[0].eq {
	pc = 0x830F4020; continue 'dispatch;
	}
	// 830F4070: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F4074: 48000038  b 0x830f40ac
	pc = 0x830F40AC; continue 'dispatch;
            }
            0x830F4078 => {
    //   block [0x830F4078..0x830F40AC)
	// 830F4078: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F407C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4080: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F4084: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4088: 390BACE0  addi r8, r11, -0x5320
	ctx.r[8].s64 = ctx.r[11].s64 + -21280;
	// 830F408C: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4090: 38EAA9BC  addi r7, r10, -0x5644
	ctx.r[7].s64 = ctx.r[10].s64 + -22084;
	// 830F4094: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F4098: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F409C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F40A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F40A4: 4E800421  bctrl
	ctx.lr = 0x830F40A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F40A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            0x830F40AC => {
    //   block [0x830F40AC..0x830F40C4)
	// 830F40AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F40B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F40B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F40B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F40BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F40C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F40C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F40C8 size=80
    let mut pc: u32 = 0x830F40C8;
    'dispatch: loop {
        match pc {
            0x830F40C8 => {
    //   block [0x830F40C8..0x830F40F4)
	// 830F40C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F40CC: 4BBB5341  bl 0x82ca940c
	ctx.lr = 0x830F40D0;
	sub_82CA93D0(ctx, base);
	// 830F40D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F40D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F40D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F40DC: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F40E0: 4BFFFF11  bl 0x830f3ff0
	ctx.lr = 0x830F40E4;
	sub_830F3FF0(ctx, base);
	// 830F40E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F40E8: 4082000C  bne 0x830f40f4
	if !ctx.cr[0].eq {
	pc = 0x830F40F4; continue 'dispatch;
	}
	// 830F40EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F40F0: 48000020  b 0x830f4110
	pc = 0x830F4110; continue 'dispatch;
            }
            0x830F40F4 => {
    //   block [0x830F40F4..0x830F4110)
	// 830F40F4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F40F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F40FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F4100: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830F4104: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 830F4108: 4BFFF571  bl 0x830f3678
	ctx.lr = 0x830F410C;
	sub_830F3678(ctx, base);
	// 830F410C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830F4110; continue 'dispatch;
            }
            0x830F4110 => {
    //   block [0x830F4110..0x830F4118)
	// 830F4110: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F4114: 4BBB5348  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4118 size=284
    let mut pc: u32 = 0x830F4118;
    'dispatch: loop {
        match pc {
            0x830F4118 => {
    //   block [0x830F4118..0x830F4164)
	// 830F4118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F411C: 4BBB52F1  bl 0x82ca940c
	ctx.lr = 0x830F4120;
	sub_82CA93D0(ctx, base);
	// 830F4120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4124: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F4128: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830F412C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4130: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4134: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 830F4138: 409A00BC  bne cr6, 0x830f41f4
	if !ctx.cr[6].eq {
	pc = 0x830F41F4; continue 'dispatch;
	}
	// 830F413C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4140: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 830F4144: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4148: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F414C: 409A0018  bne cr6, 0x830f4164
	if !ctx.cr[6].eq {
	pc = 0x830F4164; continue 'dispatch;
	}
	// 830F4150: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4154: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830F4158: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F415C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F4160: 48000010  b 0x830f4170
	pc = 0x830F4170; continue 'dispatch;
            }
            0x830F4164 => {
    //   block [0x830F4164..0x830F4170)
	// 830F4164: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4168: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F416C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830F4170; continue 'dispatch;
            }
            0x830F4170 => {
    //   block [0x830F4170..0x830F41BC)
	// 830F4170: 396A0002  addi r11, r10, 2
	ctx.r[11].s64 = ctx.r[10].s64 + 2;
	// 830F4174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F4178: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F417C: 4BFFFE75  bl 0x830f3ff0
	ctx.lr = 0x830F4180;
	sub_830F3FF0(ctx, base);
	// 830F4180: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4184: 41820060  beq 0x830f41e4
	if ctx.cr[0].eq {
	pc = 0x830F41E4; continue 'dispatch;
	}
	// 830F4188: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F418C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4190: 2B0B003B  cmplwi cr6, r11, 0x3b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 59 as u32, &mut ctx.xer);
	// 830F4194: 409A0040  bne cr6, 0x830f41d4
	if !ctx.cr[6].eq {
	pc = 0x830F41D4; continue 'dispatch;
	}
	// 830F4198: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F419C: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F41A0: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F41A4: 409A0018  bne cr6, 0x830f41bc
	if !ctx.cr[6].eq {
	pc = 0x830F41BC; continue 'dispatch;
	}
	// 830F41A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F41AC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830F41B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F41B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F41B8: 48000010  b 0x830f41c8
	pc = 0x830F41C8; continue 'dispatch;
            }
            0x830F41BC => {
    //   block [0x830F41BC..0x830F41C8)
	// 830F41BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F41C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F41C4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830F41C8; continue 'dispatch;
            }
            0x830F41C8 => {
    //   block [0x830F41C8..0x830F41D4)
	// 830F41C8: 396A0002  addi r11, r10, 2
	ctx.r[11].s64 = ctx.r[10].s64 + 2;
	// 830F41CC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F41D0: 48000058  b 0x830f4228
	pc = 0x830F4228; continue 'dispatch;
            }
            0x830F41D4 => {
    //   block [0x830F41D4..0x830F41E4)
	// 830F41D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F41D8: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F41DC: 390BAD0C  addi r8, r11, -0x52f4
	ctx.r[8].s64 = ctx.r[11].s64 + -21236;
	// 830F41E0: 48000020  b 0x830f4200
	pc = 0x830F4200; continue 'dispatch;
            }
            0x830F41E4 => {
    //   block [0x830F41E4..0x830F41F4)
	// 830F41E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830F41E8: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F41EC: 390B2DF8  addi r8, r11, 0x2df8
	ctx.r[8].s64 = ctx.r[11].s64 + 11768;
	// 830F41F0: 48000010  b 0x830f4200
	pc = 0x830F4200; continue 'dispatch;
            }
            0x830F41F4 => {
    //   block [0x830F41F4..0x830F4200)
	// 830F41F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F41F8: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F41FC: 390BAC48  addi r8, r11, -0x53b8
	ctx.r[8].s64 = ctx.r[11].s64 + -21432;
	pc = 0x830F4200; continue 'dispatch;
            }
            0x830F4200 => {
    //   block [0x830F4200..0x830F4228)
	// 830F4200: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4204: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F4208: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F420C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F4210: 38EAA9BC  addi r7, r10, -0x5644
	ctx.r[7].s64 = ctx.r[10].s64 + -22084;
	// 830F4214: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F4218: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F421C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4224: 4E800421  bctrl
	ctx.lr = 0x830F4228;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4228 => {
    //   block [0x830F4228..0x830F4234)
	// 830F4228: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F422C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F4230: 4BBB522C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4238 size=128
    let mut pc: u32 = 0x830F4238;
    'dispatch: loop {
        match pc {
            0x830F4238 => {
    //   block [0x830F4238..0x830F4268)
	// 830F4238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F423C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F4240: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4244: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4248: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F424C: 2B0A0026  cmplwi cr6, r10, 0x26
	ctx.cr[6].compare_u32(ctx.r[10].u32, 38 as u32, &mut ctx.xer);
	// 830F4250: 409A0020  bne cr6, 0x830f4270
	if !ctx.cr[6].eq {
	pc = 0x830F4270; continue 'dispatch;
	}
	// 830F4254: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830F4258: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 830F425C: 409A000C  bne cr6, 0x830f4268
	if !ctx.cr[6].eq {
	pc = 0x830F4268; continue 'dispatch;
	}
	// 830F4260: 4BFFED71  bl 0x830f2fd0
	ctx.lr = 0x830F4264;
	sub_830F2FD0(ctx, base);
	// 830F4264: 48000044  b 0x830f42a8
	pc = 0x830F42A8; continue 'dispatch;
            }
            0x830F4268 => {
    //   block [0x830F4268..0x830F4270)
	// 830F4268: 4BFFFEB1  bl 0x830f4118
	ctx.lr = 0x830F426C;
	sub_830F4118(ctx, base);
	// 830F426C: 4800003C  b 0x830f42a8
	pc = 0x830F42A8; continue 'dispatch;
            }
            0x830F4270 => {
    //   block [0x830F4270..0x830F42A8)
	// 830F4270: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4274: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F4278: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830F427C: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4280: 390AAD30  addi r8, r10, -0x52d0
	ctx.r[8].s64 = ctx.r[10].s64 + -21200;
	// 830F4284: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4288: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F428C: 38E9A9BC  addi r7, r9, -0x5644
	ctx.r[7].s64 = ctx.r[9].s64 + -22084;
	// 830F4290: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4294: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F4298: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F429C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F42A0: 4E800421  bctrl
	ctx.lr = 0x830F42A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F42A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            0x830F42A8 => {
    //   block [0x830F42A8..0x830F42B8)
	// 830F42A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F42AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F42B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F42B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F42B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F42B8 size=432
    let mut pc: u32 = 0x830F42B8;
    'dispatch: loop {
        match pc {
            0x830F42B8 => {
    //   block [0x830F42B8..0x830F42E4)
	// 830F42B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F42BC: 4BBB5145  bl 0x82ca9400
	ctx.lr = 0x830F42C0;
	sub_82CA93D0(ctx, base);
	// 830F42C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F42C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F42C8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830F42CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F42D0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830F42D4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830F42D8: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F42DC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830F42E0: A17C0000  lhz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830F42E4; continue 'dispatch;
            }
            0x830F42E4 => {
    //   block [0x830F42E4..0x830F430C)
	// 830F42E4: 5568043F  clrlwi. r8, r11, 0x10
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830F42E8: 418200B0  beq 0x830f4398
	if ctx.cr[0].eq {
	pc = 0x830F4398; continue 'dispatch;
	}
	// 830F42EC: 2B08003C  cmplwi cr6, r8, 0x3c
	ctx.cr[6].compare_u32(ctx.r[8].u32, 60 as u32, &mut ctx.xer);
	// 830F42F0: 419A00A8  beq cr6, 0x830f4398
	if ctx.cr[6].eq {
	pc = 0x830F4398; continue 'dispatch;
	}
	// 830F42F4: 2B080026  cmplwi cr6, r8, 0x26
	ctx.cr[6].compare_u32(ctx.r[8].u32, 38 as u32, &mut ctx.xer);
	// 830F42F8: 409A0014  bne cr6, 0x830f430c
	if !ctx.cr[6].eq {
	pc = 0x830F430C; continue 'dispatch;
	}
	// 830F42FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4300: 4BFFFF39  bl 0x830f4238
	ctx.lr = 0x830F4304;
	sub_830F4238(ctx, base);
	// 830F4304: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830F4308: 48000078  b 0x830f4380
	pc = 0x830F4380; continue 'dispatch;
            }
            0x830F430C => {
    //   block [0x830F430C..0x830F4338)
	// 830F430C: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4310: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 830F4314: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4318: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F431C: 409A001C  bne cr6, 0x830f4338
	if !ctx.cr[6].eq {
	pc = 0x830F4338; continue 'dispatch;
	}
	// 830F4320: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4324: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830F4328: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F432C: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 830F4330: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F4334: 48000010  b 0x830f4344
	pc = 0x830F4344; continue 'dispatch;
            }
            0x830F4338 => {
    //   block [0x830F4338..0x830F4344)
	// 830F4338: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F433C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F4340: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F4344; continue 'dispatch;
            }
            0x830F4344 => {
    //   block [0x830F4344..0x830F4370)
	// 830F4344: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F4348: 2B080020  cmplwi cr6, r8, 0x20
	ctx.cr[6].compare_u32(ctx.r[8].u32, 32 as u32, &mut ctx.xer);
	// 830F434C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F4350: 419A0020  beq cr6, 0x830f4370
	if ctx.cr[6].eq {
	pc = 0x830F4370; continue 'dispatch;
	}
	// 830F4354: 2B080009  cmplwi cr6, r8, 9
	ctx.cr[6].compare_u32(ctx.r[8].u32, 9 as u32, &mut ctx.xer);
	// 830F4358: 419A0018  beq cr6, 0x830f4370
	if ctx.cr[6].eq {
	pc = 0x830F4370; continue 'dispatch;
	}
	// 830F435C: 2B08000D  cmplwi cr6, r8, 0xd
	ctx.cr[6].compare_u32(ctx.r[8].u32, 13 as u32, &mut ctx.xer);
	// 830F4360: 419A0010  beq cr6, 0x830f4370
	if ctx.cr[6].eq {
	pc = 0x830F4370; continue 'dispatch;
	}
	// 830F4364: 2B08000A  cmplwi cr6, r8, 0xa
	ctx.cr[6].compare_u32(ctx.r[8].u32, 10 as u32, &mut ctx.xer);
	// 830F4368: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830F436C: 409A0008  bne cr6, 0x830f4374
	if !ctx.cr[6].eq {
	pc = 0x830F4374; continue 'dispatch;
	}
	pc = 0x830F4370; continue 'dispatch;
            }
            0x830F4370 => {
    //   block [0x830F4370..0x830F4374)
	// 830F4370: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F4374; continue 'dispatch;
            }
            0x830F4374 => {
    //   block [0x830F4374..0x830F4380)
	// 830F4374: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4378: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 830F437C: 40820008  bne 0x830f4384
	if !ctx.cr[0].eq {
	pc = 0x830F4384; continue 'dispatch;
	}
	pc = 0x830F4380; continue 'dispatch;
            }
            0x830F4380 => {
    //   block [0x830F4380..0x830F4384)
	// 830F4380: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x830F4384; continue 'dispatch;
            }
            0x830F4384 => {
    //   block [0x830F4384..0x830F4398)
	// 830F4384: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4388: 576A063F  clrlwi. r10, r27, 0x18
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F438C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4390: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F4394: 4082FF50  bne 0x830f42e4
	if !ctx.cr[0].eq {
	pc = 0x830F42E4; continue 'dispatch;
	}
	pc = 0x830F4398; continue 'dispatch;
            }
            0x830F4398 => {
    //   block [0x830F4398..0x830F43A0)
	// 830F4398: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F439C: 4082000C  bne 0x830f43a8
	if !ctx.cr[0].eq {
	pc = 0x830F43A8; continue 'dispatch;
	}
	pc = 0x830F43A0; continue 'dispatch;
            }
            0x830F43A0 => {
    //   block [0x830F43A0..0x830F43A8)
	// 830F43A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F43A4: 480000BC  b 0x830f4460
	pc = 0x830F4460; continue 'dispatch;
            }
            0x830F43A8 => {
    //   block [0x830F43A8..0x830F43C0)
	// 830F43A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F43AC: 419A007C  beq cr6, 0x830f4428
	if ctx.cr[6].eq {
	pc = 0x830F4428; continue 'dispatch;
	}
	// 830F43B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F43B4: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F43B8: 41820008  beq 0x830f43c0
	if ctx.cr[0].eq {
	pc = 0x830F43C0; continue 'dispatch;
	}
	// 830F43BC: 7FA7E850  subf r29, r7, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[7].s64;
	pc = 0x830F43C0; continue 'dispatch;
            }
            0x830F43C0 => {
    //   block [0x830F43C0..0x830F4428)
	// 830F43C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F43C4: 419A0098  beq cr6, 0x830f445c
	if ctx.cr[6].eq {
	pc = 0x830F445C; continue 'dispatch;
	}
	// 830F43C8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830F43CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F43D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F43D4: 4BFFFB05  bl 0x830f3ed8
	ctx.lr = 0x830F43D8;
	sub_830F3ED8(ctx, base);
	// 830F43D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F43DC: 4182FFC4  beq 0x830f43a0
	if ctx.cr[0].eq {
	pc = 0x830F43A0; continue 'dispatch;
	}
	// 830F43E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F43E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F43E8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F43EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F43F0: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 830F43F4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 830F43F8: 5566F7FE  rlwinm r6, r11, 0x1e, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 830F43FC: 48001E35  bl 0x830f6230
	ctx.lr = 0x830F4400;
	sub_830F6230(ctx, base);
	// 830F4400: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 830F4404: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 830F4408: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F440C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830F4410: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830F4414: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4418: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F441C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F4420: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F4424: 48000038  b 0x830f445c
	pc = 0x830F445C; continue 'dispatch;
            }
            0x830F4428 => {
    //   block [0x830F4428..0x830F445C)
	// 830F4428: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F442C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4430: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F4434: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4438: 390BAD58  addi r8, r11, -0x52a8
	ctx.r[8].s64 = ctx.r[11].s64 + -21160;
	// 830F443C: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4440: 38EAA9BC  addi r7, r10, -0x5644
	ctx.r[7].s64 = ctx.r[10].s64 + -22084;
	// 830F4444: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F4448: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F444C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4450: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4454: 4E800421  bctrl
	ctx.lr = 0x830F4458;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F4458: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
            }
            0x830F445C => {
    //   block [0x830F445C..0x830F4460)
	// 830F445C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x830F4460; continue 'dispatch;
            }
            0x830F4460 => {
    //   block [0x830F4460..0x830F4468)
	// 830F4460: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F4464: 4BBB4FEC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4468 size=428
    let mut pc: u32 = 0x830F4468;
    'dispatch: loop {
        match pc {
            0x830F4468 => {
    //   block [0x830F4468..0x830F4490)
	// 830F4468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F446C: 4BBB4F95  bl 0x82ca9400
	ctx.lr = 0x830F4470;
	sub_82CA93D0(ctx, base);
	// 830F4470: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4474: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F4478: A3A10050  lhz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F447C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F4480: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F4484: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 830F4488: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 830F448C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x830F4490; continue 'dispatch;
            }
            0x830F4490 => {
    //   block [0x830F4490..0x830F44C8)
	// 830F4490: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4494: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 830F4498: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F449C: 419800A8  blt cr6, 0x830f4544
	if ctx.cr[6].lt {
	pc = 0x830F4544; continue 'dispatch;
	}
	// 830F44A0: 419A0028  beq cr6, 0x830f44c8
	if ctx.cr[6].eq {
	pc = 0x830F44C8; continue 'dispatch;
	}
	// 830F44A4: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 830F44A8: 409800F4  bge cr6, 0x830f459c
	if !ctx.cr[6].lt {
	pc = 0x830F459C; continue 'dispatch;
	}
	// 830F44AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F44B0: 4BFFFD89  bl 0x830f4238
	ctx.lr = 0x830F44B4;
	sub_830F4238(ctx, base);
	// 830F44B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F44B8: 418200F0  beq 0x830f45a8
	if ctx.cr[0].eq {
	pc = 0x830F45A8; continue 'dispatch;
	}
	// 830F44BC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830F44C0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830F44C4: 4BFFFFCC  b 0x830f4490
	pc = 0x830F4490; continue 'dispatch;
            }
            0x830F44C8 => {
    //   block [0x830F44C8..0x830F44F4)
	// 830F44C8: 5548043E  clrlwi r8, r10, 0x10
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 830F44CC: 2B08003C  cmplwi cr6, r8, 0x3c
	ctx.cr[6].compare_u32(ctx.r[8].u32, 60 as u32, &mut ctx.xer);
	// 830F44D0: 419A00E0  beq cr6, 0x830f45b0
	if ctx.cr[6].eq {
	pc = 0x830F45B0; continue 'dispatch;
	}
	// 830F44D4: 2B080026  cmplwi cr6, r8, 0x26
	ctx.cr[6].compare_u32(ctx.r[8].u32, 38 as u32, &mut ctx.xer);
	// 830F44D8: 409A001C  bne cr6, 0x830f44f4
	if !ctx.cr[6].eq {
	pc = 0x830F44F4; continue 'dispatch;
	}
	// 830F44DC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F44E0: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 830F44E4: 556BF7FF  rlwinm. r11, r11, 0x1e, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F44E8: 4182000C  beq 0x830f44f4
	if ctx.cr[0].eq {
	pc = 0x830F44F4; continue 'dispatch;
	}
	// 830F44EC: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 830F44F0: 4BFFFFA0  b 0x830f4490
	pc = 0x830F4490; continue 'dispatch;
            }
            0x830F44F4 => {
    //   block [0x830F44F4..0x830F451C)
	// 830F44F4: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F44F8: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F44FC: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4500: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F4504: 409A0018  bne cr6, 0x830f451c
	if !ctx.cr[6].eq {
	pc = 0x830F451C; continue 'dispatch;
	}
	// 830F4508: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F450C: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830F4510: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F4514: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F4518: 48000010  b 0x830f4528
	pc = 0x830F4528; continue 'dispatch;
            }
            0x830F451C => {
    //   block [0x830F451C..0x830F4528)
	// 830F451C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4520: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F4524: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F4528; continue 'dispatch;
            }
            0x830F4528 => {
    //   block [0x830F4528..0x830F4544)
	// 830F4528: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F452C: 57A9043E  clrlwi r9, r29, 0x10
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 830F4530: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F4534: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830F4538: 419A0084  beq cr6, 0x830f45bc
	if ctx.cr[6].eq {
	pc = 0x830F45BC; continue 'dispatch;
	}
	// 830F453C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830F4540: 4BFFFF50  b 0x830f4490
	pc = 0x830F4490; continue 'dispatch;
            }
            0x830F4544 => {
    //   block [0x830F4544..0x830F4558)
	// 830F4544: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 830F4548: 2B0B0022  cmplwi cr6, r11, 0x22
	ctx.cr[6].compare_u32(ctx.r[11].u32, 34 as u32, &mut ctx.xer);
	// 830F454C: 419A000C  beq cr6, 0x830f4558
	if ctx.cr[6].eq {
	pc = 0x830F4558; continue 'dispatch;
	}
	// 830F4550: 2B0B0027  cmplwi cr6, r11, 0x27
	ctx.cr[6].compare_u32(ctx.r[11].u32, 39 as u32, &mut ctx.xer);
	// 830F4554: 409A0070  bne cr6, 0x830f45c4
	if !ctx.cr[6].eq {
	pc = 0x830F45C4; continue 'dispatch;
	}
	pc = 0x830F4558; continue 'dispatch;
            }
            0x830F4558 => {
    //   block [0x830F4558..0x830F4584)
	// 830F4558: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 830F455C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4560: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F4564: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4568: 2B09000A  cmplwi cr6, r9, 0xa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 10 as u32, &mut ctx.xer);
	// 830F456C: 409A0018  bne cr6, 0x830f4584
	if !ctx.cr[6].eq {
	pc = 0x830F4584; continue 'dispatch;
	}
	// 830F4570: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4574: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830F4578: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F457C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F4580: 48000010  b 0x830f4590
	pc = 0x830F4590; continue 'dispatch;
            }
            0x830F4584 => {
    //   block [0x830F4584..0x830F4590)
	// 830F4584: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4588: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F458C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x830F4590; continue 'dispatch;
            }
            0x830F4590 => {
    //   block [0x830F4590..0x830F459C)
	// 830F4590: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830F4594: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830F4598: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x830F459C; continue 'dispatch;
            }
            0x830F459C => {
    //   block [0x830F459C..0x830F45A8)
	// 830F459C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F45A0: 4098FEF0  bge cr6, 0x830f4490
	if !ctx.cr[6].lt {
	pc = 0x830F4490; continue 'dispatch;
	}
	// 830F45A4: 48000054  b 0x830f45f8
	pc = 0x830F45F8; continue 'dispatch;
            }
            0x830F45A8 => {
    //   block [0x830F45A8..0x830F45B0)
	// 830F45A8: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F45AC: 4800004C  b 0x830f45f8
	pc = 0x830F45F8; continue 'dispatch;
            }
            0x830F45B0 => {
    //   block [0x830F45B0..0x830F45BC)
	// 830F45B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F45B4: 390BAD84  addi r8, r11, -0x527c
	ctx.r[8].s64 = ctx.r[11].s64 + -21116;
	// 830F45B8: 48000014  b 0x830f45cc
	pc = 0x830F45CC; continue 'dispatch;
            }
            0x830F45BC => {
    //   block [0x830F45BC..0x830F45C4)
	// 830F45BC: 3BE0FFFE  li r31, -2
	ctx.r[31].s64 = -2;
	// 830F45C0: 48000038  b 0x830f45f8
	pc = 0x830F45F8; continue 'dispatch;
            }
            0x830F45C4 => {
    //   block [0x830F45C4..0x830F45CC)
	// 830F45C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F45C8: 390BAD78  addi r8, r11, -0x5288
	ctx.r[8].s64 = ctx.r[11].s64 + -21128;
	pc = 0x830F45CC; continue 'dispatch;
            }
            0x830F45CC => {
    //   block [0x830F45CC..0x830F45F8)
	// 830F45CC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F45D0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F45D4: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F45D8: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F45DC: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F45E0: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F45E4: 38EAA9BC  addi r7, r10, -0x5644
	ctx.r[7].s64 = ctx.r[10].s64 + -22084;
	// 830F45E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F45EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F45F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F45F4: 4E800421  bctrl
	ctx.lr = 0x830F45F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F45F8 => {
    //   block [0x830F45F8..0x830F460C)
	// 830F45F8: 397F0002  addi r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 2;
	// 830F45FC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F4600: 5563DFFF  rlwinm. r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F4604: 41820008  beq 0x830f460c
	if ctx.cr[0].eq {
	pc = 0x830F460C; continue 'dispatch;
	}
	// 830F4608: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x830F460C; continue 'dispatch;
            }
            0x830F460C => {
    //   block [0x830F460C..0x830F4614)
	// 830F460C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F4610: 4BBB4E40  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4618 size=96
    let mut pc: u32 = 0x830F4618;
    'dispatch: loop {
        match pc {
            0x830F4618 => {
    //   block [0x830F4618..0x830F4650)
	// 830F4618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F461C: 4BBB4DF1  bl 0x82ca940c
	ctx.lr = 0x830F4620;
	sub_82CA93D0(ctx, base);
	// 830F4620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F462C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F4630: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F4634: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F4638: 83BF0014  lwz r29, 0x14(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F463C: 4BFFFE2D  bl 0x830f4468
	ctx.lr = 0x830F4640;
	sub_830F4468(ctx, base);
	// 830F4640: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4644: 4082000C  bne 0x830f4650
	if !ctx.cr[0].eq {
	pc = 0x830F4650; continue 'dispatch;
	}
	// 830F4648: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F464C: 48000024  b 0x830f4670
	pc = 0x830F4670; continue 'dispatch;
            }
            0x830F4650 => {
    //   block [0x830F4650..0x830F4670)
	// 830F4650: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F4654: 389D0002  addi r4, r29, 2
	ctx.r[4].s64 = ctx.r[29].s64 + 2;
	// 830F4658: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F465C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F4660: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 830F4664: 5566F7FE  rlwinm r6, r11, 0x1e, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 830F4668: 48001BC9  bl 0x830f6230
	ctx.lr = 0x830F466C;
	sub_830F6230(ctx, base);
	// 830F466C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830F4670; continue 'dispatch;
            }
            0x830F4670 => {
    //   block [0x830F4670..0x830F4678)
	// 830F4670: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F4674: 4BBB4DE8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4678 size=112
    let mut pc: u32 = 0x830F4678;
    'dispatch: loop {
        match pc {
            0x830F4678 => {
    //   block [0x830F4678..0x830F46C8)
	// 830F4678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F467C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F4680: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F4684: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F4688: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F468C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4690: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F4694: 4BFFFA35  bl 0x830f40c8
	ctx.lr = 0x830F4698;
	sub_830F40C8(ctx, base);
	// 830F4698: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F469C: 4182002C  beq 0x830f46c8
	if ctx.cr[0].eq {
	pc = 0x830F46C8; continue 'dispatch;
	}
	// 830F46A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F46A4: 4BFFE86D  bl 0x830f2f10
	ctx.lr = 0x830F46A8;
	sub_830F2F10(ctx, base);
	// 830F46A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F46AC: 4182001C  beq 0x830f46c8
	if ctx.cr[0].eq {
	pc = 0x830F46C8; continue 'dispatch;
	}
	// 830F46B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F46B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F46B8: 4BFFFF61  bl 0x830f4618
	ctx.lr = 0x830F46BC;
	sub_830F4618(ctx, base);
	// 830F46BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F46C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F46C4: 40820008  bne 0x830f46cc
	if !ctx.cr[0].eq {
	pc = 0x830F46CC; continue 'dispatch;
	}
	pc = 0x830F46C8; continue 'dispatch;
            }
            0x830F46C8 => {
    //   block [0x830F46C8..0x830F46CC)
	// 830F46C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F46CC; continue 'dispatch;
            }
            0x830F46CC => {
    //   block [0x830F46CC..0x830F46E8)
	// 830F46CC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F46D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F46D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F46D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F46DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F46E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F46E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F46E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F46E8 size=104
    let mut pc: u32 = 0x830F46E8;
    'dispatch: loop {
        match pc {
            0x830F46E8 => {
    //   block [0x830F46E8..0x830F4704)
	// 830F46E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F46EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F46F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F46F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F46F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F46FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4700: 4800002C  b 0x830f472c
	pc = 0x830F472C; continue 'dispatch;
            }
            0x830F4704 => {
    //   block [0x830F4704..0x830F472C)
	// 830F4704: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4708: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F470C: 4BFFEEF5  bl 0x830f3600
	ctx.lr = 0x830F4710;
	sub_830F3600(ctx, base);
	// 830F4710: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4714: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F471C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4720: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4724: 4E800421  bctrl
	ctx.lr = 0x830F4728;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F4728: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            0x830F472C => {
    //   block [0x830F472C..0x830F4750)
	// 830F472C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F4734: 409AFFD0  bne cr6, 0x830f4704
	if !ctx.cr[6].eq {
	pc = 0x830F4704; continue 'dispatch;
	}
	// 830F4738: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F473C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F4740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F4744: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F4748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F474C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F4750 size=144
    let mut pc: u32 = 0x830F4750;
    'dispatch: loop {
        match pc {
            0x830F4750 => {
    //   block [0x830F4750..0x830F47E0)
	// 830F4750: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830F4754: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 830F4758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F475C: 3929A980  addi r9, r9, -0x5680
	ctx.r[9].s64 = ctx.r[9].s64 + -22144;
	// 830F4760: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 830F4764: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F4768: 3908ADE4  addi r8, r8, -0x521c
	ctx.r[8].s64 = ctx.r[8].s64 + -21020;
	// 830F476C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F4770: 3943001C  addi r10, r3, 0x1c
	ctx.r[10].s64 = ctx.r[3].s64 + 28;
	// 830F4774: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830F4778: 38E7ADA8  addi r7, r7, -0x5258
	ctx.r[7].s64 = ctx.r[7].s64 + -21080;
	// 830F477C: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830F4780: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830F4784: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 830F4788: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 830F478C: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 830F4790: 90830010  stw r4, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 830F4794: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830F4798: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 830F479C: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830F47A0: 3908AD98  addi r8, r8, -0x5268
	ctx.r[8].s64 = ctx.r[8].s64 + -21096;
	// 830F47A4: 91430024  stw r10, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830F47A8: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 830F47AC: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830F47B0: 3927AB34  addi r9, r7, -0x54cc
	ctx.r[9].s64 = ctx.r[7].s64 + -21708;
	// 830F47B4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830F47B8: 9083002C  stw r4, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 830F47BC: 9103001C  stw r8, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 830F47C0: 91430038  stw r10, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 830F47C4: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 830F47C8: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 830F47CC: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830F47D0: 90830040  stw r4, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[4].u32 ) };
	// 830F47D4: 91230030  stw r9, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 830F47D8: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 830F47DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F47E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F47E0 size=8
    let mut pc: u32 = 0x830F47E0;
    'dispatch: loop {
        match pc {
            0x830F47E0 => {
    //   block [0x830F47E0..0x830F47E8)
	// 830F47E0: 38630024  addi r3, r3, 0x24
	ctx.r[3].s64 = ctx.r[3].s64 + 36;
	// 830F47E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F47E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F47E8 size=20
    let mut pc: u32 = 0x830F47E8;
    'dispatch: loop {
        match pc {
            0x830F47E8 => {
    //   block [0x830F47E8..0x830F47FC)
	// 830F47E8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F47EC: 38630024  addi r3, r3, 0x24
	ctx.r[3].s64 = ctx.r[3].s64 + 36;
	// 830F47F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F47F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F47F8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F4800 size=20
    let mut pc: u32 = 0x830F4800;
    'dispatch: loop {
        match pc {
            0x830F4800 => {
    //   block [0x830F4800..0x830F4814)
	// 830F4800: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F4804: 38630024  addi r3, r3, 0x24
	ctx.r[3].s64 = ctx.r[3].s64 + 36;
	// 830F4808: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F480C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4810: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F4818 size=20
    let mut pc: u32 = 0x830F4818;
    'dispatch: loop {
        match pc {
            0x830F4818 => {
    //   block [0x830F4818..0x830F482C)
	// 830F4818: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F481C: 38630024  addi r3, r3, 0x24
	ctx.r[3].s64 = ctx.r[3].s64 + 36;
	// 830F4820: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4824: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4828: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F4830 size=20
    let mut pc: u32 = 0x830F4830;
    'dispatch: loop {
        match pc {
            0x830F4830 => {
    //   block [0x830F4830..0x830F4844)
	// 830F4830: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F4834: 38630024  addi r3, r3, 0x24
	ctx.r[3].s64 = ctx.r[3].s64 + 36;
	// 830F4838: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F483C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4840: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F4848 size=20
    let mut pc: u32 = 0x830F4848;
    'dispatch: loop {
        match pc {
            0x830F4848 => {
    //   block [0x830F4848..0x830F485C)
	// 830F4848: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F484C: 38630024  addi r3, r3, 0x24
	ctx.r[3].s64 = ctx.r[3].s64 + 36;
	// 830F4850: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F4854: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4858: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F4860 size=8
    let mut pc: u32 = 0x830F4860;
    'dispatch: loop {
        match pc {
            0x830F4860 => {
    //   block [0x830F4860..0x830F4868)
	// 830F4860: 80630030  lwz r3, 0x30(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 830F4864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F4868 size=60
    let mut pc: u32 = 0x830F4868;
    'dispatch: loop {
        match pc {
            0x830F4868 => {
    //   block [0x830F4868..0x830F4874)
	// 830F4868: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F486C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F4870: 48000028  b 0x830f4898
	pc = 0x830F4898; continue 'dispatch;
            }
            0x830F4874 => {
    //   block [0x830F4874..0x830F4888)
	// 830F4874: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4878: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F487C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F4880: 419A0008  beq cr6, 0x830f4888
	if ctx.cr[6].eq {
	pc = 0x830F4888; continue 'dispatch;
	}
	// 830F4884: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830F4888; continue 'dispatch;
            }
            0x830F4888 => {
    //   block [0x830F4888..0x830F4894)
	// 830F4888: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F488C: 41820008  beq 0x830f4894
	if ctx.cr[0].eq {
	pc = 0x830F4894; continue 'dispatch;
	}
	// 830F4890: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	pc = 0x830F4894; continue 'dispatch;
            }
            0x830F4894 => {
    //   block [0x830F4894..0x830F4898)
	// 830F4894: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830F4898; continue 'dispatch;
            }
            0x830F4898 => {
    //   block [0x830F4898..0x830F48A4)
	// 830F4898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F489C: 409AFFD8  bne cr6, 0x830f4874
	if !ctx.cr[6].eq {
	pc = 0x830F4874; continue 'dispatch;
	}
	// 830F48A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F48A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F48A8 size=60
    let mut pc: u32 = 0x830F48A8;
    'dispatch: loop {
        match pc {
            0x830F48A8 => {
    //   block [0x830F48A8..0x830F48D4)
	// 830F48A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F48AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F48B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F48B4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 830F48B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F48BC: 98A10054  stb r5, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u8 ) };
	// 830F48C0: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F48C4: 4BFFF3CD  bl 0x830f3c90
	ctx.lr = 0x830F48C8;
	sub_830F3C90(ctx, base);
	// 830F48C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F48CC: 41820008  beq 0x830f48d4
	if ctx.cr[0].eq {
	pc = 0x830F48D4; continue 'dispatch;
	}
	// 830F48D0: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x830F48D4; continue 'dispatch;
            }
            0x830F48D4 => {
    //   block [0x830F48D4..0x830F48E4)
	// 830F48D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F48D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F48DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F48E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F48E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F48E8 size=176
    let mut pc: u32 = 0x830F48E8;
    'dispatch: loop {
        match pc {
            0x830F48E8 => {
    //   block [0x830F48E8..0x830F4934)
	// 830F48E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F48EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F48F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F48F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F48F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F48FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F4900: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F4904: 419A0078  beq cr6, 0x830f497c
	if ctx.cr[6].eq {
	pc = 0x830F497C; continue 'dispatch;
	}
	// 830F4908: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F490C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F4910: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 830F4914: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 830F4918: 554ADFFF  rlwinm. r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F491C: 41820060  beq 0x830f497c
	if ctx.cr[0].eq {
	pc = 0x830F497C; continue 'dispatch;
	}
	// 830F4920: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 830F4924: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F4928: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F492C: 41820008  beq 0x830f4934
	if ctx.cr[0].eq {
	pc = 0x830F4934; continue 'dispatch;
	}
	// 830F4930: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	pc = 0x830F4934; continue 'dispatch;
            }
            0x830F4934 => {
    //   block [0x830F4934..0x830F497C)
	// 830F4934: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4938: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F493C: 88BE000C  lbz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4940: 4BFFEDD1  bl 0x830f3710
	ctx.lr = 0x830F4944;
	sub_830F3710(ctx, base);
	// 830F4944: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4948: 41820034  beq 0x830f497c
	if ctx.cr[0].eq {
	pc = 0x830F497C; continue 'dispatch;
	}
	// 830F494C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4950: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F4954: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F4958: 893E000C  lbz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F495C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F4960: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F4964: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830F4968: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 830F496C: 4BFFF3AD  bl 0x830f3d18
	ctx.lr = 0x830F4970;
	sub_830F3D18(ctx, base);
	// 830F4970: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F4974: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F4978: 40820008  bne 0x830f4980
	if !ctx.cr[0].eq {
	pc = 0x830F4980; continue 'dispatch;
	}
	pc = 0x830F497C; continue 'dispatch;
            }
            0x830F497C => {
    //   block [0x830F497C..0x830F4980)
	// 830F497C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F4980; continue 'dispatch;
            }
            0x830F4980 => {
    //   block [0x830F4980..0x830F4998)
	// 830F4980: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F4984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F4988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F498C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F4990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F4994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4998 size=48
    let mut pc: u32 = 0x830F4998;
    'dispatch: loop {
        match pc {
            0x830F4998 => {
    //   block [0x830F4998..0x830F49C8)
	// 830F4998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F499C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F49A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F49A4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 830F49A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F49AC: 98A10054  stb r5, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u8 ) };
	// 830F49B0: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F49B4: 4BFFF2DD  bl 0x830f3c90
	ctx.lr = 0x830F49B8;
	sub_830F3C90(ctx, base);
	// 830F49B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F49BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F49C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F49C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F49C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F49C8 size=52
    let mut pc: u32 = 0x830F49C8;
    'dispatch: loop {
        match pc {
            0x830F49C8 => {
    //   block [0x830F49C8..0x830F49FC)
	// 830F49C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F49CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F49D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F49D4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 830F49D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F49DC: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 830F49E0: 98C10058  stb r6, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u8 ) };
	// 830F49E4: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F49E8: 4BFFF331  bl 0x830f3d18
	ctx.lr = 0x830F49EC;
	sub_830F3D18(ctx, base);
	// 830F49EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F49F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F49F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F49F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4A00 size=280
    let mut pc: u32 = 0x830F4A00;
    'dispatch: loop {
        match pc {
            0x830F4A00 => {
    //   block [0x830F4A00..0x830F4AA0)
	// 830F4A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4A04: 4BBB4A05  bl 0x82ca9408
	ctx.lr = 0x830F4A08;
	sub_82CA93D0(ctx, base);
	// 830F4A08: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 830F4A0C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4A10: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4A14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F4A18: 39200400  li r9, 0x400
	ctx.r[9].s64 = 1024;
	// 830F4A1C: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830F4A20: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F4A24: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 830F4A28: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 830F4A2C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F4A30: 9561F7A0  stwu r11, -0x860(r1)
	ea = ctx.r[1].u32.wrapping_add(-2144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 830F4A34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F4A38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830F4A3C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F4A40: 4BFFFC39  bl 0x830f4678
	ctx.lr = 0x830F4A44;
	sub_830F4678(ctx, base);
	// 830F4A44: 839F0054  lwz r28, 0x54(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4A48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4A4C: 41820098  beq 0x830f4ae4
	if ctx.cr[0].eq {
	pc = 0x830F4AE4; continue 'dispatch;
	}
	// 830F4A50: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4A54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F4A58: 388BAE28  addi r4, r11, -0x51d8
	ctx.r[4].s64 = ctx.r[11].s64 + -20952;
	// 830F4A5C: 4BFFEDE5  bl 0x830f3840
	ctx.lr = 0x830F4A60;
	sub_830F3840(ctx, base);
	// 830F4A60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4A64: 41820050  beq 0x830f4ab4
	if ctx.cr[0].eq {
	pc = 0x830F4AB4; continue 'dispatch;
	}
	// 830F4A68: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4A6C: 4BFFE0AD  bl 0x830f2b18
	ctx.lr = 0x830F4A70;
	sub_830F2B18(ctx, base);
	// 830F4A70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4A74: 41820034  beq 0x830f4aa8
	if ctx.cr[0].eq {
	pc = 0x830F4AA8; continue 'dispatch;
	}
	// 830F4A78: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F4A7C: 419A0024  beq cr6, 0x830f4aa0
	if ctx.cr[6].eq {
	pc = 0x830F4AA0; continue 'dispatch;
	}
	// 830F4A80: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F4A84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4A88: 419A0018  beq cr6, 0x830f4aa0
	if ctx.cr[6].eq {
	pc = 0x830F4AA0; continue 'dispatch;
	}
	// 830F4A8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4A90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F4A94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4A98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4A9C: 4E800421  bctrl
	ctx.lr = 0x830F4AA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4AA0 => {
    //   block [0x830F4AA0..0x830F4AA8)
	// 830F4AA0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F4AA4: 4800006C  b 0x830f4b10
	pc = 0x830F4B10; continue 'dispatch;
            }
            0x830F4AA8 => {
    //   block [0x830F4AA8..0x830F4AB4)
	// 830F4AA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4AAC: 390BAE08  addi r8, r11, -0x51f8
	ctx.r[8].s64 = ctx.r[11].s64 + -20984;
	// 830F4AB0: 4800000C  b 0x830f4abc
	pc = 0x830F4ABC; continue 'dispatch;
            }
            0x830F4AB4 => {
    //   block [0x830F4AB4..0x830F4ABC)
	// 830F4AB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4AB8: 390BADE8  addi r8, r11, -0x5218
	ctx.r[8].s64 = ctx.r[11].s64 + -21016;
	pc = 0x830F4ABC; continue 'dispatch;
            }
            0x830F4ABC => {
    //   block [0x830F4ABC..0x830F4AE4)
	// 830F4ABC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4AC0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F4AC4: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4AC8: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F4ACC: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4AD0: 38EAA9BC  addi r7, r10, -0x5644
	ctx.r[7].s64 = ctx.r[10].s64 + -22084;
	// 830F4AD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4AD8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4AE0: 4E800421  bctrl
	ctx.lr = 0x830F4AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4AE4 => {
    //   block [0x830F4AE4..0x830F4B0C)
	// 830F4AE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F4AE8: 419A0024  beq cr6, 0x830f4b0c
	if ctx.cr[6].eq {
	pc = 0x830F4B0C; continue 'dispatch;
	}
	// 830F4AEC: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F4AF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4AF4: 419A0018  beq cr6, 0x830f4b0c
	if ctx.cr[6].eq {
	pc = 0x830F4B0C; continue 'dispatch;
	}
	// 830F4AF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4AFC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F4B00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4B04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4B08: 4E800421  bctrl
	ctx.lr = 0x830F4B0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4B0C => {
    //   block [0x830F4B0C..0x830F4B10)
	// 830F4B0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F4B10; continue 'dispatch;
            }
            0x830F4B10 => {
    //   block [0x830F4B10..0x830F4B18)
	// 830F4B10: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 830F4B14: 4BBB4944  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4B18 size=280
    let mut pc: u32 = 0x830F4B18;
    'dispatch: loop {
        match pc {
            0x830F4B18 => {
    //   block [0x830F4B18..0x830F4BB8)
	// 830F4B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4B1C: 4BBB48ED  bl 0x82ca9408
	ctx.lr = 0x830F4B20;
	sub_82CA93D0(ctx, base);
	// 830F4B20: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 830F4B24: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4B28: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4B2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F4B30: 39200400  li r9, 0x400
	ctx.r[9].s64 = 1024;
	// 830F4B34: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830F4B38: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F4B3C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 830F4B40: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 830F4B44: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F4B48: 9561F7A0  stwu r11, -0x860(r1)
	ea = ctx.r[1].u32.wrapping_add(-2144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 830F4B4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F4B50: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830F4B54: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F4B58: 4BFFFB21  bl 0x830f4678
	ctx.lr = 0x830F4B5C;
	sub_830F4678(ctx, base);
	// 830F4B5C: 839F0054  lwz r28, 0x54(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4B60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4B64: 41820098  beq 0x830f4bfc
	if ctx.cr[0].eq {
	pc = 0x830F4BFC; continue 'dispatch;
	}
	// 830F4B68: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4B6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F4B70: 388BAE80  addi r4, r11, -0x5180
	ctx.r[4].s64 = ctx.r[11].s64 + -20864;
	// 830F4B74: 4BFFECCD  bl 0x830f3840
	ctx.lr = 0x830F4B78;
	sub_830F3840(ctx, base);
	// 830F4B78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4B7C: 41820050  beq 0x830f4bcc
	if ctx.cr[0].eq {
	pc = 0x830F4BCC; continue 'dispatch;
	}
	// 830F4B80: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4B84: 4BFFE085  bl 0x830f2c08
	ctx.lr = 0x830F4B88;
	sub_830F2C08(ctx, base);
	// 830F4B88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4B8C: 41820034  beq 0x830f4bc0
	if ctx.cr[0].eq {
	pc = 0x830F4BC0; continue 'dispatch;
	}
	// 830F4B90: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F4B94: 419A0024  beq cr6, 0x830f4bb8
	if ctx.cr[6].eq {
	pc = 0x830F4BB8; continue 'dispatch;
	}
	// 830F4B98: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F4B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4BA0: 419A0018  beq cr6, 0x830f4bb8
	if ctx.cr[6].eq {
	pc = 0x830F4BB8; continue 'dispatch;
	}
	// 830F4BA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4BA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F4BAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4BB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4BB4: 4E800421  bctrl
	ctx.lr = 0x830F4BB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4BB8 => {
    //   block [0x830F4BB8..0x830F4BC0)
	// 830F4BB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F4BBC: 4800006C  b 0x830f4c28
	pc = 0x830F4C28; continue 'dispatch;
            }
            0x830F4BC0 => {
    //   block [0x830F4BC0..0x830F4BCC)
	// 830F4BC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4BC4: 390BAE58  addi r8, r11, -0x51a8
	ctx.r[8].s64 = ctx.r[11].s64 + -20904;
	// 830F4BC8: 4800000C  b 0x830f4bd4
	pc = 0x830F4BD4; continue 'dispatch;
            }
            0x830F4BCC => {
    //   block [0x830F4BCC..0x830F4BD4)
	// 830F4BCC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4BD0: 390BAE38  addi r8, r11, -0x51c8
	ctx.r[8].s64 = ctx.r[11].s64 + -20936;
	pc = 0x830F4BD4; continue 'dispatch;
            }
            0x830F4BD4 => {
    //   block [0x830F4BD4..0x830F4BFC)
	// 830F4BD4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4BD8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F4BDC: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4BE0: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F4BE4: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4BE8: 38EAA9BC  addi r7, r10, -0x5644
	ctx.r[7].s64 = ctx.r[10].s64 + -22084;
	// 830F4BEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4BF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4BF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4BF8: 4E800421  bctrl
	ctx.lr = 0x830F4BFC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4BFC => {
    //   block [0x830F4BFC..0x830F4C24)
	// 830F4BFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F4C00: 419A0024  beq cr6, 0x830f4c24
	if ctx.cr[6].eq {
	pc = 0x830F4C24; continue 'dispatch;
	}
	// 830F4C04: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F4C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4C0C: 419A0018  beq cr6, 0x830f4c24
	if ctx.cr[6].eq {
	pc = 0x830F4C24; continue 'dispatch;
	}
	// 830F4C10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4C14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F4C18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4C1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4C20: 4E800421  bctrl
	ctx.lr = 0x830F4C24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4C24 => {
    //   block [0x830F4C24..0x830F4C28)
	// 830F4C24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F4C28; continue 'dispatch;
            }
            0x830F4C28 => {
    //   block [0x830F4C28..0x830F4C30)
	// 830F4C28: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 830F4C2C: 4BBB482C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4C30 size=432
    let mut pc: u32 = 0x830F4C30;
    'dispatch: loop {
        match pc {
            0x830F4C30 => {
    //   block [0x830F4C30..0x830F4CD0)
	// 830F4C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4C34: 4BBB47D1  bl 0x82ca9404
	ctx.lr = 0x830F4C38;
	sub_82CA93D0(ctx, base);
	// 830F4C38: 3BE1FF60  addi r31, r1, -0xa0
	ctx.r[31].s64 = ctx.r[1].s64 + -160;
	// 830F4C3C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4C40: 81410000  lwz r10, 0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4C44: 39600400  li r11, 0x400
	ctx.r[11].s64 = 1024;
	// 830F4C48: 9541F7A0  stwu r10, -0x860(r1)
	ea = ctx.r[1].u32.wrapping_add(-2144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[1].u32 = ea;
	// 830F4C4C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F4C50: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830F4C54: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F4C58: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830F4C5C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830F4C60: 93BF0060  stw r29, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 830F4C64: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 830F4C68: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 830F4C6C: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 830F4C70: 81410000  lwz r10, 0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4C74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F4C78: 93BF0050  stw r29, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830F4C7C: 9541F7A0  stwu r10, -0x860(r1)
	ea = ctx.r[1].u32.wrapping_add(-2144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[1].u32 = ea;
	// 830F4C80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830F4C84: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F4C88: 4BFFF9F1  bl 0x830f4678
	ctx.lr = 0x830F4C8C;
	sub_830F4678(ctx, base);
	// 830F4C8C: 837F0064  lwz r27, 0x64(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830F4C90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4C94: 418200F0  beq 0x830f4d84
	if ctx.cr[0].eq {
	pc = 0x830F4D84; continue 'dispatch;
	}
	// 830F4C98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4C9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F4CA0: 388BAEFC  addi r4, r11, -0x5104
	ctx.r[4].s64 = ctx.r[11].s64 + -20740;
	// 830F4CA4: 4BFFEB9D  bl 0x830f3840
	ctx.lr = 0x830F4CA8;
	sub_830F3840(ctx, base);
	// 830F4CA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4CAC: 418200A8  beq 0x830f4d54
	if ctx.cr[0].eq {
	pc = 0x830F4D54; continue 'dispatch;
	}
	// 830F4CB0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4CB4: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4CB8: 388BAEF4  addi r4, r11, -0x510c
	ctx.r[4].s64 = ctx.r[11].s64 + -20748;
	// 830F4CBC: 4BFFEB85  bl 0x830f3840
	ctx.lr = 0x830F4CC0;
	sub_830F3840(ctx, base);
	// 830F4CC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4CC4: 41820064  beq 0x830f4d28
	if ctx.cr[0].eq {
	pc = 0x830F4D28; continue 'dispatch;
	}
	// 830F4CC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4CCC: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x830F4CD0; continue 'dispatch;
            }
            0x830F4CD0 => {
    //   block [0x830F4CD0..0x830F4CF8)
	// 830F4CD0: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4CD4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F4CD8: 419A0020  beq cr6, 0x830f4cf8
	if ctx.cr[6].eq {
	pc = 0x830F4CF8; continue 'dispatch;
	}
	// 830F4CDC: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F4CE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4CE4: 419A0014  beq cr6, 0x830f4cf8
	if ctx.cr[6].eq {
	pc = 0x830F4CF8; continue 'dispatch;
	}
	// 830F4CE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4CEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4CF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4CF4: 4E800421  bctrl
	ctx.lr = 0x830F4CF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4CF8 => {
    //   block [0x830F4CF8..0x830F4D20)
	// 830F4CF8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830F4CFC: 419A0024  beq cr6, 0x830f4d20
	if ctx.cr[6].eq {
	pc = 0x830F4D20; continue 'dispatch;
	}
	// 830F4D00: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F4D04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4D08: 419A0018  beq cr6, 0x830f4d20
	if ctx.cr[6].eq {
	pc = 0x830F4D20; continue 'dispatch;
	}
	// 830F4D0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4D10: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F4D14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4D18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4D1C: 4E800421  bctrl
	ctx.lr = 0x830F4D20;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4D20 => {
    //   block [0x830F4D20..0x830F4D28)
	// 830F4D20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F4D24: 480000B4  b 0x830f4dd8
	pc = 0x830F4DD8; continue 'dispatch;
            }
            0x830F4D28 => {
    //   block [0x830F4D28..0x830F4D48)
	// 830F4D28: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4D2C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4D30: 388BAEEC  addi r4, r11, -0x5114
	ctx.r[4].s64 = ctx.r[11].s64 + -20756;
	// 830F4D34: 4BFFEB0D  bl 0x830f3840
	ctx.lr = 0x830F4D38;
	sub_830F3840(ctx, base);
	// 830F4D38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4D3C: 4182000C  beq 0x830f4d48
	if ctx.cr[0].eq {
	pc = 0x830F4D48; continue 'dispatch;
	}
	// 830F4D40: 9BBC0000  stb r29, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830F4D44: 4BFFFF8C  b 0x830f4cd0
	pc = 0x830F4CD0; continue 'dispatch;
            }
            0x830F4D48 => {
    //   block [0x830F4D48..0x830F4D54)
	// 830F4D48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4D4C: 390BAEB4  addi r8, r11, -0x514c
	ctx.r[8].s64 = ctx.r[11].s64 + -20812;
	// 830F4D50: 4800000C  b 0x830f4d5c
	pc = 0x830F4D5C; continue 'dispatch;
            }
            0x830F4D54 => {
    //   block [0x830F4D54..0x830F4D5C)
	// 830F4D54: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4D58: 390BAE94  addi r8, r11, -0x516c
	ctx.r[8].s64 = ctx.r[11].s64 + -20844;
	pc = 0x830F4D5C; continue 'dispatch;
            }
            0x830F4D5C => {
    //   block [0x830F4D5C..0x830F4D84)
	// 830F4D5C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4D60: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F4D64: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4D68: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F4D6C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4D70: 38EAA9BC  addi r7, r10, -0x5644
	ctx.r[7].s64 = ctx.r[10].s64 + -22084;
	// 830F4D74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4D78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4D7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4D80: 4E800421  bctrl
	ctx.lr = 0x830F4D84;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4D84 => {
    //   block [0x830F4D84..0x830F4DAC)
	// 830F4D84: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4D88: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F4D8C: 419A0020  beq cr6, 0x830f4dac
	if ctx.cr[6].eq {
	pc = 0x830F4DAC; continue 'dispatch;
	}
	// 830F4D90: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F4D94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4D98: 419A0014  beq cr6, 0x830f4dac
	if ctx.cr[6].eq {
	pc = 0x830F4DAC; continue 'dispatch;
	}
	// 830F4D9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4DA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4DA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4DA8: 4E800421  bctrl
	ctx.lr = 0x830F4DAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4DAC => {
    //   block [0x830F4DAC..0x830F4DD4)
	// 830F4DAC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830F4DB0: 419A0024  beq cr6, 0x830f4dd4
	if ctx.cr[6].eq {
	pc = 0x830F4DD4; continue 'dispatch;
	}
	// 830F4DB4: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F4DB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4DBC: 419A0018  beq cr6, 0x830f4dd4
	if ctx.cr[6].eq {
	pc = 0x830F4DD4; continue 'dispatch;
	}
	// 830F4DC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4DC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F4DC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4DCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F4DD0: 4E800421  bctrl
	ctx.lr = 0x830F4DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F4DD4 => {
    //   block [0x830F4DD4..0x830F4DD8)
	// 830F4DD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F4DD8; continue 'dispatch;
            }
            0x830F4DD8 => {
    //   block [0x830F4DD8..0x830F4DE0)
	// 830F4DD8: 383F00A0  addi r1, r31, 0xa0
	ctx.r[1].s64 = ctx.r[31].s64 + 160;
	// 830F4DDC: 4BBB4678  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4DE0 size=852
    let mut pc: u32 = 0x830F4DE0;
    'dispatch: loop {
        match pc {
            0x830F4DE0 => {
    //   block [0x830F4DE0..0x830F4E1C)
	// 830F4DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4DE4: 4BBB4615  bl 0x82ca93f8
	ctx.lr = 0x830F4DE8;
	sub_82CA93D0(ctx, base);
	// 830F4DE8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4DEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4DF0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F4DF4: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830F4DF8: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 830F4DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4E00: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830F4E04: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 830F4E08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F4E0C: 3BABA9BC  addi r29, r11, -0x5644
	ctx.r[29].s64 = ctx.r[11].s64 + -22084;
	// 830F4E10: 3B8AAFBC  addi r28, r10, -0x5044
	ctx.r[28].s64 = ctx.r[10].s64 + -20548;
	// 830F4E14: 3B69AFB4  addi r27, r9, -0x504c
	ctx.r[27].s64 = ctx.r[9].s64 + -20556;
	// 830F4E18: 3B48AFA8  addi r26, r8, -0x5058
	ctx.r[26].s64 = ctx.r[8].s64 + -20568;
	pc = 0x830F4E1C; continue 'dispatch;
            }
            0x830F4E1C => {
    //   block [0x830F4E1C..0x830F4EAC)
	// 830F4E1C: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4E20: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 830F4E24: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4E28: 41990228  bgt cr6, 0x830f5050
	if ctx.cr[6].gt {
	pc = 0x830F5050; continue 'dispatch;
	}
	// 830F4E2C: 3D808208  lis r12, -0x7df8
	ctx.r[12].s64 = -2113404928;
	// 830F4E30: 398CAF18  addi r12, r12, -0x50e8
	ctx.r[12].s64 = ctx.r[12].s64 + -20712;
	// 830F4E34: 7C0CF0AE  lbzx r0, r12, r30
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F4E38: 5400103A  slwi r0, r0, 2
	ctx.r[0].u32 = ctx.r[0].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830F4E3C: 3D80830F  lis r12, -0x7cf1
	ctx.r[12].s64 = -2096168960;
	// 830F4E40: 398C4E54  addi r12, r12, 0x4e54
	ctx.r[12].s64 = ctx.r[12].s64 + 20052;
	// 830F4E44: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 830F4E48: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 830F4E4C: 60000000  nop
	// 830F4E50: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 830F4E54: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F4E58: 41820204  beq 0x830f505c
	if ctx.cr[0].eq {
	pc = 0x830F505C; continue 'dispatch;
	}
	// 830F4E5C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830F4E60: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 830F4E64: 4BBBBEA5  bl 0x82cb0d08
	ctx.lr = 0x830F4E68;
	sub_82CB0D08(ctx, base);
	// 830F4E68: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4E6C: 408201F0  bne 0x830f505c
	if !ctx.cr[0].eq {
	pc = 0x830F505C; continue 'dispatch;
	}
	// 830F4E70: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 830F4E74: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830F4E78: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F4E7C: 4BFFD775  bl 0x830f25f0
	ctx.lr = 0x830F4E80;
	sub_830F25F0(ctx, base);
	// 830F4E80: 4BFFFF9C  b 0x830f4e1c
	pc = 0x830F4E1C; continue 'dispatch;
	// 830F4E84: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830F4E88: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F4E8C: 419A0020  beq cr6, 0x830f4eac
	if ctx.cr[6].eq {
	pc = 0x830F4EAC; continue 'dispatch;
	}
	// 830F4E90: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F4E94: 419A0018  beq cr6, 0x830f4eac
	if ctx.cr[6].eq {
	pc = 0x830F4EAC; continue 'dispatch;
	}
	// 830F4E98: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F4E9C: 419A0010  beq cr6, 0x830f4eac
	if ctx.cr[6].eq {
	pc = 0x830F4EAC; continue 'dispatch;
	}
	// 830F4EA0: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F4EA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F4EA8: 409A0008  bne cr6, 0x830f4eb0
	if !ctx.cr[6].eq {
	pc = 0x830F4EB0; continue 'dispatch;
	}
            }
            0x830F4EAC => {
    //   block [0x830F4EAC..0x830F4EB0)
	// 830F4EAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F4EB0; continue 'dispatch;
            }
            0x830F4EB0 => {
    //   block [0x830F4EB0..0x830F4F18)
	// 830F4EB0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4EB4: 418201E4  beq 0x830f5098
	if ctx.cr[0].eq {
	pc = 0x830F5098; continue 'dispatch;
	}
	// 830F4EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4EBC: 4BFFDFC5  bl 0x830f2e80
	ctx.lr = 0x830F4EC0;
	sub_830F2E80(ctx, base);
	// 830F4EC0: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 830F4EC4: 4BFFFF58  b 0x830f4e1c
	pc = 0x830F4E1C; continue 'dispatch;
	// 830F4EC8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830F4ECC: 2B0B0076  cmplwi cr6, r11, 0x76
	ctx.cr[6].compare_u32(ctx.r[11].u32, 118 as u32, &mut ctx.xer);
	// 830F4ED0: 409A01DC  bne cr6, 0x830f50ac
	if !ctx.cr[6].eq {
	pc = 0x830F50AC; continue 'dispatch;
	}
	// 830F4ED4: 38990050  addi r4, r25, 0x50
	ctx.r[4].s64 = ctx.r[25].s64 + 80;
	// 830F4ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4EDC: 4BFFFB25  bl 0x830f4a00
	ctx.lr = 0x830F4EE0;
	sub_830F4A00(ctx, base);
	// 830F4EE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4EE4: 418201C0  beq 0x830f50a4
	if ctx.cr[0].eq {
	pc = 0x830F50A4; continue 'dispatch;
	}
	// 830F4EE8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 830F4EEC: 4BFFFF30  b 0x830f4e1c
	pc = 0x830F4E1C; continue 'dispatch;
	// 830F4EF0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830F4EF4: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F4EF8: 419A0020  beq cr6, 0x830f4f18
	if ctx.cr[6].eq {
	pc = 0x830F4F18; continue 'dispatch;
	}
	// 830F4EFC: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F4F00: 419A0018  beq cr6, 0x830f4f18
	if ctx.cr[6].eq {
	pc = 0x830F4F18; continue 'dispatch;
	}
	// 830F4F04: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F4F08: 419A0010  beq cr6, 0x830f4f18
	if ctx.cr[6].eq {
	pc = 0x830F4F18; continue 'dispatch;
	}
	// 830F4F0C: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F4F10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F4F14: 409A0008  bne cr6, 0x830f4f1c
	if !ctx.cr[6].eq {
	pc = 0x830F4F1C; continue 'dispatch;
	}
            }
            0x830F4F18 => {
    //   block [0x830F4F18..0x830F4F1C)
	// 830F4F18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F4F1C; continue 'dispatch;
            }
            0x830F4F1C => {
    //   block [0x830F4F1C..0x830F4F5C)
	// 830F4F1C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4F20: 41820198  beq 0x830f50b8
	if ctx.cr[0].eq {
	pc = 0x830F50B8; continue 'dispatch;
	}
	// 830F4F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4F28: 4BFFDF59  bl 0x830f2e80
	ctx.lr = 0x830F4F2C;
	sub_830F2E80(ctx, base);
	// 830F4F2C: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 830F4F30: 4BFFFEEC  b 0x830f4e1c
	pc = 0x830F4E1C; continue 'dispatch;
	// 830F4F34: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830F4F38: 2B0B0065  cmplwi cr6, r11, 0x65
	ctx.cr[6].compare_u32(ctx.r[11].u32, 101 as u32, &mut ctx.xer);
	// 830F4F3C: 409A0020  bne cr6, 0x830f4f5c
	if !ctx.cr[6].eq {
	pc = 0x830F4F5C; continue 'dispatch;
	}
	// 830F4F40: 3899005C  addi r4, r25, 0x5c
	ctx.r[4].s64 = ctx.r[25].s64 + 92;
	// 830F4F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4F48: 4BFFFBD1  bl 0x830f4b18
	ctx.lr = 0x830F4F4C;
	sub_830F4B18(ctx, base);
	// 830F4F4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4F50: 41820154  beq 0x830f50a4
	if ctx.cr[0].eq {
	pc = 0x830F50A4; continue 'dispatch;
	}
	// 830F4F54: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 830F4F58: 4BFFFEC4  b 0x830f4e1c
	pc = 0x830F4E1C; continue 'dispatch;
            }
            0x830F4F5C => {
    //   block [0x830F4F5C..0x830F4F64)
	// 830F4F5C: 2B0B0073  cmplwi cr6, r11, 0x73
	ctx.cr[6].compare_u32(ctx.r[11].u32, 115 as u32, &mut ctx.xer);
	// 830F4F60: 409A0184  bne cr6, 0x830f50e4
	if !ctx.cr[6].eq {
	pc = 0x830F50E4; continue 'dispatch;
	}
	pc = 0x830F4F64; continue 'dispatch;
            }
            0x830F4F64 => {
    //   block [0x830F4F64..0x830F4FA8)
	// 830F4F64: 38990068  addi r4, r25, 0x68
	ctx.r[4].s64 = ctx.r[25].s64 + 104;
	// 830F4F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4F6C: 4BFFFCC5  bl 0x830f4c30
	ctx.lr = 0x830F4F70;
	sub_830F4C30(ctx, base);
	// 830F4F70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4F74: 41820130  beq 0x830f50a4
	if ctx.cr[0].eq {
	pc = 0x830F50A4; continue 'dispatch;
	}
	// 830F4F78: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 830F4F7C: 4BFFFEA0  b 0x830f4e1c
	pc = 0x830F4E1C; continue 'dispatch;
	// 830F4F80: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830F4F84: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F4F88: 419A0020  beq cr6, 0x830f4fa8
	if ctx.cr[6].eq {
	pc = 0x830F4FA8; continue 'dispatch;
	}
	// 830F4F8C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F4F90: 419A0018  beq cr6, 0x830f4fa8
	if ctx.cr[6].eq {
	pc = 0x830F4FA8; continue 'dispatch;
	}
	// 830F4F94: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F4F98: 419A0010  beq cr6, 0x830f4fa8
	if ctx.cr[6].eq {
	pc = 0x830F4FA8; continue 'dispatch;
	}
	// 830F4F9C: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F4FA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F4FA4: 409A0008  bne cr6, 0x830f4fac
	if !ctx.cr[6].eq {
	pc = 0x830F4FAC; continue 'dispatch;
	}
            }
            0x830F4FA8 => {
    //   block [0x830F4FA8..0x830F4FAC)
	// 830F4FA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F4FAC; continue 'dispatch;
            }
            0x830F4FAC => {
    //   block [0x830F4FAC..0x830F4FF0)
	// 830F4FAC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4FB0: 41820108  beq 0x830f50b8
	if ctx.cr[0].eq {
	pc = 0x830F50B8; continue 'dispatch;
	}
	// 830F4FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4FB8: 4BFFDEC9  bl 0x830f2e80
	ctx.lr = 0x830F4FBC;
	sub_830F2E80(ctx, base);
	// 830F4FBC: 3BC00006  li r30, 6
	ctx.r[30].s64 = 6;
	// 830F4FC0: 4BFFFE5C  b 0x830f4e1c
	pc = 0x830F4E1C; continue 'dispatch;
	// 830F4FC4: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830F4FC8: 2B0B0073  cmplwi cr6, r11, 0x73
	ctx.cr[6].compare_u32(ctx.r[11].u32, 115 as u32, &mut ctx.xer);
	// 830F4FCC: 419AFF98  beq cr6, 0x830f4f64
	if ctx.cr[6].eq {
	pc = 0x830F4F64; continue 'dispatch;
	}
	// 830F4FD0: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4FD4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F4FD8: 419A0018  beq cr6, 0x830f4ff0
	if ctx.cr[6].eq {
	pc = 0x830F4FF0; continue 'dispatch;
	}
	// 830F4FDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F4FE0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830F4FE4: 4BBBBD25  bl 0x82cb0d08
	ctx.lr = 0x830F4FE8;
	sub_82CB0D08(ctx, base);
	// 830F4FE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4FEC: 41820124  beq 0x830f5110
	if ctx.cr[0].eq {
	pc = 0x830F5110; continue 'dispatch;
	}
            }
            0x830F4FF0 => {
    //   block [0x830F4FF0..0x830F5024)
	// 830F4FF0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F4FF4: 390BAF84  addi r8, r11, -0x507c
	ctx.r[8].s64 = ctx.r[11].s64 + -20604;
	// 830F4FF8: 48000074  b 0x830f506c
	pc = 0x830F506C; continue 'dispatch;
	// 830F4FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5000: 4BFFDE81  bl 0x830f2e80
	ctx.lr = 0x830F5004;
	sub_830F2E80(ctx, base);
	// 830F5004: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5008: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F500C: 419A0018  beq cr6, 0x830f5024
	if ctx.cr[6].eq {
	pc = 0x830F5024; continue 'dispatch;
	}
	// 830F5010: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F5014: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830F5018: 4BBBBCF1  bl 0x82cb0d08
	ctx.lr = 0x830F501C;
	sub_82CB0D08(ctx, base);
	// 830F501C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F5020: 418200F0  beq 0x830f5110
	if ctx.cr[0].eq {
	pc = 0x830F5110; continue 'dispatch;
	}
            }
            0x830F5024 => {
    //   block [0x830F5024..0x830F5050)
	// 830F5024: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5028: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 830F502C: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5030: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830F5034: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F5038: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830F503C: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F5040: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5044: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5048: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F504C: 4E800421  bctrl
	ctx.lr = 0x830F5050;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F5050 => {
    //   block [0x830F5050..0x830F505C)
	// 830F5050: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F5054: 4098FDC8  bge cr6, 0x830f4e1c
	if !ctx.cr[6].lt {
	pc = 0x830F4E1C; continue 'dispatch;
	}
	// 830F5058: 480000C8  b 0x830f5120
	pc = 0x830F5120; continue 'dispatch;
            }
            0x830F505C => {
    //   block [0x830F505C..0x830F506C)
	// 830F505C: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5060: 408200BC  bne 0x830f511c
	if !ctx.cr[0].eq {
	pc = 0x830F511C; continue 'dispatch;
	}
	// 830F5064: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5068: 390BAF7C  addi r8, r11, -0x5084
	ctx.r[8].s64 = ctx.r[11].s64 + -20612;
	pc = 0x830F506C; continue 'dispatch;
            }
            0x830F506C => {
    //   block [0x830F506C..0x830F5098)
	// 830F506C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5070: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830F5074: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F5078: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830F507C: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5080: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F5084: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5088: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F508C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F5090: 4E800421  bctrl
	ctx.lr = 0x830F5094;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F5094: 4800008C  b 0x830f5120
	pc = 0x830F5120; continue 'dispatch;
            }
            0x830F5098 => {
    //   block [0x830F5098..0x830F50A4)
	// 830F5098: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F509C: 390BAF70  addi r8, r11, -0x5090
	ctx.r[8].s64 = ctx.r[11].s64 + -20624;
	// 830F50A0: 4BFFFFCC  b 0x830f506c
	pc = 0x830F506C; continue 'dispatch;
            }
            0x830F50A4 => {
    //   block [0x830F50A4..0x830F50AC)
	// 830F50A4: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830F50A8: 48000078  b 0x830f5120
	pc = 0x830F5120; continue 'dispatch;
            }
            0x830F50AC => {
    //   block [0x830F50AC..0x830F50B8)
	// 830F50AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F50B0: 390BADE8  addi r8, r11, -0x5218
	ctx.r[8].s64 = ctx.r[11].s64 + -21016;
	// 830F50B4: 4BFFFFB8  b 0x830f506c
	pc = 0x830F506C; continue 'dispatch;
            }
            0x830F50B8 => {
    //   block [0x830F50B8..0x830F50D8)
	// 830F50B8: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F50BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F50C0: 419A0018  beq cr6, 0x830f50d8
	if ctx.cr[6].eq {
	pc = 0x830F50D8; continue 'dispatch;
	}
	// 830F50C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F50C8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830F50CC: 4BBBBC3D  bl 0x82cb0d08
	ctx.lr = 0x830F50D0;
	sub_82CB0D08(ctx, base);
	// 830F50D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F50D4: 4182003C  beq 0x830f5110
	if ctx.cr[0].eq {
	pc = 0x830F5110; continue 'dispatch;
	}
	pc = 0x830F50D8; continue 'dispatch;
            }
            0x830F50D8 => {
    //   block [0x830F50D8..0x830F50E4)
	// 830F50D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F50DC: 390BAF5C  addi r8, r11, -0x50a4
	ctx.r[8].s64 = ctx.r[11].s64 + -20644;
	// 830F50E0: 4BFFFF8C  b 0x830f506c
	pc = 0x830F506C; continue 'dispatch;
            }
            0x830F50E4 => {
    //   block [0x830F50E4..0x830F5104)
	// 830F50E4: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F50E8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F50EC: 419A0018  beq cr6, 0x830f5104
	if ctx.cr[6].eq {
	pc = 0x830F5104; continue 'dispatch;
	}
	// 830F50F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F50F4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830F50F8: 4BBBBC11  bl 0x82cb0d08
	ctx.lr = 0x830F50FC;
	sub_82CB0D08(ctx, base);
	// 830F50FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F5100: 41820010  beq 0x830f5110
	if ctx.cr[0].eq {
	pc = 0x830F5110; continue 'dispatch;
	}
	pc = 0x830F5104; continue 'dispatch;
            }
            0x830F5104 => {
    //   block [0x830F5104..0x830F5110)
	// 830F5104: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5108: 390BAF2C  addi r8, r11, -0x50d4
	ctx.r[8].s64 = ctx.r[11].s64 + -20692;
	// 830F510C: 4BFFFF60  b 0x830f506c
	pc = 0x830F506C; continue 'dispatch;
            }
            0x830F5110 => {
    //   block [0x830F5110..0x830F511C)
	// 830F5110: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 830F5114: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830F5118: 4BFFD4D9  bl 0x830f25f0
	ctx.lr = 0x830F511C;
	sub_830F25F0(ctx, base);
	pc = 0x830F511C; continue 'dispatch;
            }
            0x830F511C => {
    //   block [0x830F511C..0x830F5120)
	// 830F511C: 3BC0FFFE  li r30, -2
	ctx.r[30].s64 = -2;
	pc = 0x830F5120; continue 'dispatch;
            }
            0x830F5120 => {
    //   block [0x830F5120..0x830F5134)
	// 830F5120: 397E0002  addi r11, r30, 2
	ctx.r[11].s64 = ctx.r[30].s64 + 2;
	// 830F5124: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F5128: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F512C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F5130: 4BBB4318  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5138 size=84
    let mut pc: u32 = 0x830F5138;
    'dispatch: loop {
        match pc {
            0x830F5138 => {
    //   block [0x830F5138..0x830F5170)
	// 830F5138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F513C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5144: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5148: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830F514C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5150: 4BFFFC91  bl 0x830f4de0
	ctx.lr = 0x830F5154;
	sub_830F4DE0(ctx, base);
	// 830F5154: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5158: 41820018  beq 0x830f5170
	if ctx.cr[0].eq {
	pc = 0x830F5170; continue 'dispatch;
	}
	// 830F515C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5160: 4BFFEA61  bl 0x830f3bc0
	ctx.lr = 0x830F5164;
	sub_830F3BC0(ctx, base);
	// 830F5164: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5168: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F516C: 40820008  bne 0x830f5174
	if !ctx.cr[0].eq {
	pc = 0x830F5174; continue 'dispatch;
	}
	pc = 0x830F5170; continue 'dispatch;
            }
            0x830F5170 => {
    //   block [0x830F5170..0x830F5174)
	// 830F5170: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830F5174; continue 'dispatch;
            }
            0x830F5174 => {
    //   block [0x830F5174..0x830F518C)
	// 830F5174: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F5178: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F517C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5184: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5190 size=104
    let mut pc: u32 = 0x830F5190;
    'dispatch: loop {
        match pc {
            0x830F5190 => {
    //   block [0x830F5190..0x830F51B4)
	// 830F5190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F519C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F51A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F51A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F51A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F51AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F51B0: 419A0024  beq cr6, 0x830f51d4
	if ctx.cr[6].eq {
	pc = 0x830F51D4; continue 'dispatch;
	}
	pc = 0x830F51B4; continue 'dispatch;
            }
            0x830F51B4 => {
    //   block [0x830F51B4..0x830F51D4)
	// 830F51B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F51B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F51BC: 4BFFF72D  bl 0x830f48e8
	ctx.lr = 0x830F51C0;
	sub_830F48E8(ctx, base);
	// 830F51C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F51C4: 4082002C  bne 0x830f51f0
	if !ctx.cr[0].eq {
	pc = 0x830F51F0; continue 'dispatch;
	}
	// 830F51C8: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F51CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F51D0: 409AFFE4  bne cr6, 0x830f51b4
	if !ctx.cr[6].eq {
	pc = 0x830F51B4; continue 'dispatch;
	}
	pc = 0x830F51D4; continue 'dispatch;
            }
            0x830F51D4 => {
    //   block [0x830F51D4..0x830F51D8)
	// 830F51D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F51D8; continue 'dispatch;
            }
            0x830F51D8 => {
    //   block [0x830F51D8..0x830F51F0)
	// 830F51D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F51DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F51E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F51E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F51E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F51EC: 4E800020  blr
	return;
            }
            0x830F51F0 => {
    //   block [0x830F51F0..0x830F51F8)
	// 830F51F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F51F4: 4BFFFFE4  b 0x830f51d8
	pc = 0x830F51D8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F51F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F51F8 size=160
    let mut pc: u32 = 0x830F51F8;
    'dispatch: loop {
        match pc {
            0x830F51F8 => {
    //   block [0x830F51F8..0x830F5268)
	// 830F51F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F51FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F520C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5210: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F5214: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F5218: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 830F521C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5220: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5224: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F522C: 4E800421  bctrl
	ctx.lr = 0x830F5230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F5230: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F5234: 40820034  bne 0x830f5268
	if !ctx.cr[0].eq {
	pc = 0x830F5268; continue 'dispatch;
	}
	// 830F5238: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F523C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5240: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5244: 3880D8F1  li r4, -0x270f
	ctx.r[4].s64 = -9999;
	// 830F5248: 38EBA7B0  addi r7, r11, -0x5850
	ctx.r[7].s64 = ctx.r[11].s64 + -22608;
	// 830F524C: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F5250: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5254: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5258: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F525C: 4E800421  bctrl
	ctx.lr = 0x830F5260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F5260: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5264: 4800001C  b 0x830f5280
	pc = 0x830F5280; continue 'dispatch;
            }
            0x830F5268 => {
    //   block [0x830F5268..0x830F5280)
	// 830F5268: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F526C: 4BFFF4E5  bl 0x830f4750
	ctx.lr = 0x830F5270;
	sub_830F4750(ctx, base);
	// 830F5270: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830F5274: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F5278: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F527C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x830F5280; continue 'dispatch;
            }
            0x830F5280 => {
    //   block [0x830F5280..0x830F5298)
	// 830F5280: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F5284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F528C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F5290: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5298 size=120
    let mut pc: u32 = 0x830F5298;
    'dispatch: loop {
        match pc {
            0x830F5298 => {
    //   block [0x830F5298..0x830F52BC)
	// 830F5298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F529C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F52A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F52A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F52A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F52AC: 357F0030  addic. r11, r31, 0x30
	ctx.xer.ca = (ctx.r[31].u32 > (!(48 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F52B0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830F52B4: 40820008  bne 0x830f52bc
	if !ctx.cr[0].eq {
	pc = 0x830F52BC; continue 'dispatch;
	}
	// 830F52B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F52BC; continue 'dispatch;
            }
            0x830F52BC => {
    //   block [0x830F52BC..0x830F52D0)
	// 830F52BC: 4BFFD4D5  bl 0x830f2790
	ctx.lr = 0x830F52C0;
	sub_830F2790(ctx, base);
	// 830F52C0: 357F001C  addic. r11, r31, 0x1c
	ctx.xer.ca = (ctx.r[31].u32 > (!(28 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F52C4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830F52C8: 40820008  bne 0x830f52d0
	if !ctx.cr[0].eq {
	pc = 0x830F52D0; continue 'dispatch;
	}
	// 830F52CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F52D0; continue 'dispatch;
            }
            0x830F52D0 => {
    //   block [0x830F52D0..0x830F52FC)
	// 830F52D0: 4BFFF419  bl 0x830f46e8
	ctx.lr = 0x830F52D4;
	sub_830F46E8(ctx, base);
	// 830F52D4: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F52D8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F52DC: 419A0020  beq cr6, 0x830f52fc
	if ctx.cr[6].eq {
	pc = 0x830F52FC; continue 'dispatch;
	}
	// 830F52E0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F52E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F52E8: 419A0014  beq cr6, 0x830f52fc
	if ctx.cr[6].eq {
	pc = 0x830F52FC; continue 'dispatch;
	}
	// 830F52EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F52F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F52F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F52F8: 4E800421  bctrl
	ctx.lr = 0x830F52FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F52FC => {
    //   block [0x830F52FC..0x830F5310)
	// 830F52FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F5300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5308: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F530C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5310 size=72
    let mut pc: u32 = 0x830F5310;
    'dispatch: loop {
        match pc {
            0x830F5310 => {
    //   block [0x830F5310..0x830F5348)
	// 830F5310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5318: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F531C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 830F5320: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F5324: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 830F5328: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 830F532C: 98E1005C  stb r7, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u8 ) };
	// 830F5330: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5334: 4BFFFE5D  bl 0x830f5190
	ctx.lr = 0x830F5338;
	sub_830F5190(ctx, base);
	// 830F5338: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F533C: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 830F5340: 40820008  bne 0x830f5348
	if !ctx.cr[0].eq {
	pc = 0x830F5348; continue 'dispatch;
	}
	// 830F5344: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F5348; continue 'dispatch;
            }
            0x830F5348 => {
    //   block [0x830F5348..0x830F5358)
	// 830F5348: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F534C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5350: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5358 size=560
    let mut pc: u32 = 0x830F5358;
    'dispatch: loop {
        match pc {
            0x830F5358 => {
    //   block [0x830F5358..0x830F53A4)
	// 830F5358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F535C: 4BBB4095  bl 0x82ca93f0
	ctx.lr = 0x830F5360;
	sub_82CA93D0(ctx, base);
	// 830F5360: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5364: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5368: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F536C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830F5370: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 830F5374: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 830F5378: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 830F537C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5380: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F5384: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 830F5388: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F538C: 3AEBAA90  addi r23, r11, -0x5570
	ctx.r[23].s64 = ctx.r[11].s64 + -21872;
	// 830F5390: 3B6AA9BC  addi r27, r10, -0x5644
	ctx.r[27].s64 = ctx.r[10].s64 + -22084;
	// 830F5394: 3B89AA40  addi r28, r9, -0x55c0
	ctx.r[28].s64 = ctx.r[9].s64 + -21952;
	// 830F5398: 3B48AFEC  addi r26, r8, -0x5014
	ctx.r[26].s64 = ctx.r[8].s64 + -20500;
	// 830F539C: 3B27AFDC  addi r25, r7, -0x5024
	ctx.r[25].s64 = ctx.r[7].s64 + -20516;
	// 830F53A0: 3B06AFC4  addi r24, r6, -0x503c
	ctx.r[24].s64 = ctx.r[6].s64 + -20540;
	pc = 0x830F53A4; continue 'dispatch;
            }
            0x830F53A4 => {
    //   block [0x830F53A4..0x830F53D4)
	// 830F53A4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F53A8: 418201CC  beq 0x830f5574
	if ctx.cr[0].eq {
	pc = 0x830F5574; continue 'dispatch;
	}
	// 830F53AC: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F53B0: A1690000  lhz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F53B4: A1490002  lhz r10, 2(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 830F53B8: A1290004  lhz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F53BC: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 830F53C0: 409A00E4  bne cr6, 0x830f54a4
	if !ctx.cr[6].eq {
	pc = 0x830F54A4; continue 'dispatch;
	}
	// 830F53C4: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 830F53C8: 2B0B003F  cmplwi cr6, r11, 0x3f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 63 as u32, &mut ctx.xer);
	// 830F53CC: 409A0014  bne cr6, 0x830f53e0
	if !ctx.cr[6].eq {
	pc = 0x830F53E0; continue 'dispatch;
	}
	// 830F53D0: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	pc = 0x830F53D4; continue 'dispatch;
            }
            0x830F53D4 => {
    //   block [0x830F53D4..0x830F53E0)
	// 830F53D4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 830F53D8: 3880D8F5  li r4, -0x270b
	ctx.r[4].s64 = -9995;
	// 830F53DC: 48000040  b 0x830f541c
	pc = 0x830F541C; continue 'dispatch;
            }
            0x830F53E0 => {
    //   block [0x830F53E0..0x830F53FC)
	// 830F53E0: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 830F53E4: 409A0058  bne cr6, 0x830f543c
	if !ctx.cr[6].eq {
	pc = 0x830F543C; continue 'dispatch;
	}
	// 830F53E8: 552B043E  clrlwi r11, r9, 0x10
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 830F53EC: 2B0B005B  cmplwi cr6, r11, 0x5b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 91 as u32, &mut ctx.xer);
	// 830F53F0: 409A000C  bne cr6, 0x830f53fc
	if !ctx.cr[6].eq {
	pc = 0x830F53FC; continue 'dispatch;
	}
	// 830F53F4: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 830F53F8: 4BFFFFDC  b 0x830f53d4
	pc = 0x830F53D4; continue 'dispatch;
            }
            0x830F53FC => {
    //   block [0x830F53FC..0x830F5410)
	// 830F53FC: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 830F5400: 409A0010  bne cr6, 0x830f5410
	if !ctx.cr[6].eq {
	pc = 0x830F5410; continue 'dispatch;
	}
	// 830F5404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5408: 4BFFE021  bl 0x830f3428
	ctx.lr = 0x830F540C;
	sub_830F3428(ctx, base);
	// 830F540C: 4800008C  b 0x830f5498
	pc = 0x830F5498; continue 'dispatch;
            }
            0x830F5410 => {
    //   block [0x830F5410..0x830F541C)
	// 830F5410: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 830F5414: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830F5418: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	pc = 0x830F541C; continue 'dispatch;
            }
            0x830F541C => {
    //   block [0x830F541C..0x830F543C)
	// 830F541C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5420: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5424: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F5428: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F542C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5430: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F5434: 4E800421  bctrl
	ctx.lr = 0x830F5438;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F5438: 48000098  b 0x830f54d0
	pc = 0x830F54D0; continue 'dispatch;
            }
            0x830F543C => {
    //   block [0x830F543C..0x830F544C)
	// 830F543C: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 830F5440: 409A000C  bne cr6, 0x830f544c
	if !ctx.cr[6].eq {
	pc = 0x830F544C; continue 'dispatch;
	}
	// 830F5444: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830F5448: 48000124  b 0x830f556c
	pc = 0x830F556C; continue 'dispatch;
            }
            0x830F544C => {
    //   block [0x830F544C..0x830F5498)
	// 830F544C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F5450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5454: 4BFFFDA5  bl 0x830f51f8
	ctx.lr = 0x830F5458;
	sub_830F51F8(ctx, base);
	// 830F5458: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F545C: 41820074  beq 0x830f54d0
	if ctx.cr[0].eq {
	pc = 0x830F54D0; continue 'dispatch;
	}
	// 830F5460: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F5464: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F5468: 395D0034  addi r10, r29, 0x34
	ctx.r[10].s64 = ctx.r[29].s64 + 52;
	// 830F546C: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 830F5470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5474: 93A40044  stw r29, 0x44(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(68 as u32), ctx.r[29].u32 ) };
	// 830F5478: 815D0038  lwz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F547C: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 830F5480: 91240008  stw r9, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F5484: 813D003C  lwz r9, 0x3c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 830F5488: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 830F548C: 917D0038  stw r11, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830F5490: 915D003C  stw r10, 0x3c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 830F5494: 4800025D  bl 0x830f56f0
	ctx.lr = 0x830F5498;
	sub_830F56F0(ctx, base);
	pc = 0x830F5498; continue 'dispatch;
            }
            0x830F5498 => {
    //   block [0x830F5498..0x830F54A4)
	// 830F5498: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F549C: 408200D0  bne 0x830f556c
	if !ctx.cr[0].eq {
	pc = 0x830F556C; continue 'dispatch;
	}
	// 830F54A0: 48000030  b 0x830f54d0
	pc = 0x830F54D0; continue 'dispatch;
            }
            0x830F54A4 => {
    //   block [0x830F54A4..0x830F54D0)
	// 830F54A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F54A8: 409A0030  bne cr6, 0x830f54d8
	if !ctx.cr[6].eq {
	pc = 0x830F54D8; continue 'dispatch;
	}
	// 830F54AC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F54B0: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 830F54B4: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F54B8: 3880D8F6  li r4, -0x270a
	ctx.r[4].s64 = -9994;
	// 830F54BC: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F54C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F54C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F54C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F54CC: 4E800421  bctrl
	ctx.lr = 0x830F54D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F54D0 => {
    //   block [0x830F54D0..0x830F54D8)
	// 830F54D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F54D4: 48000098  b 0x830f556c
	pc = 0x830F556C; continue 'dispatch;
            }
            0x830F54D8 => {
    //   block [0x830F54D8..0x830F5508)
	// 830F54D8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F54DC: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F54E0: 41820078  beq 0x830f5558
	if ctx.cr[0].eq {
	pc = 0x830F5558; continue 'dispatch;
	}
	// 830F54E4: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F54E8: 419A0020  beq cr6, 0x830f5508
	if ctx.cr[6].eq {
	pc = 0x830F5508; continue 'dispatch;
	}
	// 830F54EC: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F54F0: 419A0018  beq cr6, 0x830f5508
	if ctx.cr[6].eq {
	pc = 0x830F5508; continue 'dispatch;
	}
	// 830F54F4: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F54F8: 419A0010  beq cr6, 0x830f5508
	if ctx.cr[6].eq {
	pc = 0x830F5508; continue 'dispatch;
	}
	// 830F54FC: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F5500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F5504: 409A0008  bne cr6, 0x830f550c
	if !ctx.cr[6].eq {
	pc = 0x830F550C; continue 'dispatch;
	}
	pc = 0x830F5508; continue 'dispatch;
            }
            0x830F5508 => {
    //   block [0x830F5508..0x830F550C)
	// 830F5508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830F550C; continue 'dispatch;
            }
            0x830F550C => {
    //   block [0x830F550C..0x830F5540)
	// 830F550C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5510: 41820048  beq 0x830f5558
	if ctx.cr[0].eq {
	pc = 0x830F5558; continue 'dispatch;
	}
	// 830F5514: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5518: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 830F551C: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5520: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F5524: 409A001C  bne cr6, 0x830f5540
	if !ctx.cr[6].eq {
	pc = 0x830F5540; continue 'dispatch;
	}
	// 830F5528: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F552C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F5530: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5534: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830F5538: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F553C: 48000010  b 0x830f554c
	pc = 0x830F554C; continue 'dispatch;
            }
            0x830F5540 => {
    //   block [0x830F5540..0x830F554C)
	// 830F5540: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5544: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5548: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F554C; continue 'dispatch;
            }
            0x830F554C => {
    //   block [0x830F554C..0x830F5558)
	// 830F554C: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F5550: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F5554: 48000018  b 0x830f556c
	pc = 0x830F556C; continue 'dispatch;
            }
            0x830F5558 => {
    //   block [0x830F5558..0x830F556C)
	// 830F5558: 389D0030  addi r4, r29, 0x30
	ctx.r[4].s64 = ctx.r[29].s64 + 48;
	// 830F555C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5560: 4BFFED59  bl 0x830f42b8
	ctx.lr = 0x830F5564;
	sub_830F42B8(ctx, base);
	// 830F5564: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5568: 41820018  beq 0x830f5580
	if ctx.cr[0].eq {
	pc = 0x830F5580; continue 'dispatch;
	}
	pc = 0x830F556C; continue 'dispatch;
            }
            0x830F556C => {
    //   block [0x830F556C..0x830F5574)
	// 830F556C: 56CB063F  clrlwi. r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5570: 4082FE34  bne 0x830f53a4
	if !ctx.cr[0].eq {
	pc = 0x830F53A4; continue 'dispatch;
	}
	pc = 0x830F5574; continue 'dispatch;
            }
            0x830F5574 => {
    //   block [0x830F5574..0x830F5578)
	// 830F5574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x830F5578; continue 'dispatch;
            }
            0x830F5578 => {
    //   block [0x830F5578..0x830F5580)
	// 830F5578: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F557C: 4BBB3EC4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x830F5580 => {
    //   block [0x830F5580..0x830F5588)
	// 830F5580: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5584: 4BFFFFF4  b 0x830f5578
	pc = 0x830F5578; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5588 size=112
    let mut pc: u32 = 0x830F5588;
    'dispatch: loop {
        match pc {
            0x830F5588 => {
    //   block [0x830F5588..0x830F55F8)
	// 830F5588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F558C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5598: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F559C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F55A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F55A4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F55A8: 396BB008  addi r11, r11, -0x4ff8
	ctx.r[11].s64 = ctx.r[11].s64 + -20472;
	// 830F55AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F55B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F55B4: 4BFFF19D  bl 0x830f4750
	ctx.lr = 0x830F55B8;
	sub_830F4750(ctx, base);
	// 830F55B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F55BC: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 830F55C0: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830F55C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F55C8: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F55CC: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830F55D0: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 830F55D4: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830F55D8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830F55DC: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 830F55E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F55E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F55E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F55EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F55F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F55F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F55F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F55F8 size=20
    let mut pc: u32 = 0x830F55F8;
    'dispatch: loop {
        match pc {
            0x830F55F8 => {
    //   block [0x830F55F8..0x830F560C)
	// 830F55F8: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F55FC: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 830F5600: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 830F5604: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5610 size=140
    let mut pc: u32 = 0x830F5610;
    'dispatch: loop {
        match pc {
            0x830F5610 => {
    //   block [0x830F5610..0x830F5658)
	// 830F5610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F561C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5624: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5628: 396BB008  addi r11, r11, -0x4ff8
	ctx.r[11].s64 = ctx.r[11].s64 + -20472;
	// 830F562C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F5630: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F5634: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F5638: 419A0020  beq cr6, 0x830f5658
	if ctx.cr[6].eq {
	pc = 0x830F5658; continue 'dispatch;
	}
	// 830F563C: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F5640: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F5644: 419A0014  beq cr6, 0x830f5658
	if ctx.cr[6].eq {
	pc = 0x830F5658; continue 'dispatch;
	}
	// 830F5648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F564C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F5654: 4E800421  bctrl
	ctx.lr = 0x830F5658;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F5658 => {
    //   block [0x830F5658..0x830F5680)
	// 830F5658: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F565C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F5660: 419A0020  beq cr6, 0x830f5680
	if ctx.cr[6].eq {
	pc = 0x830F5680; continue 'dispatch;
	}
	// 830F5664: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F5668: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F566C: 419A0014  beq cr6, 0x830f5680
	if ctx.cr[6].eq {
	pc = 0x830F5680; continue 'dispatch;
	}
	// 830F5670: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5674: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F567C: 4E800421  bctrl
	ctx.lr = 0x830F5680;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F5680 => {
    //   block [0x830F5680..0x830F569C)
	// 830F5680: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F5684: 4BFFFC15  bl 0x830f5298
	ctx.lr = 0x830F5688;
	sub_830F5298(ctx, base);
	// 830F5688: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F568C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5690: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5694: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F56A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F56A0 size=76
    let mut pc: u32 = 0x830F56A0;
    'dispatch: loop {
        match pc {
            0x830F56A0 => {
    //   block [0x830F56A0..0x830F56D0)
	// 830F56A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F56A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F56A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F56AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F56B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F56B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F56B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F56BC: 4BFFFF55  bl 0x830f5610
	ctx.lr = 0x830F56C0;
	sub_830F5610(ctx, base);
	// 830F56C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F56C4: 4182000C  beq 0x830f56d0
	if ctx.cr[0].eq {
	pc = 0x830F56D0; continue 'dispatch;
	}
	// 830F56C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F56CC: 4B7500E5  bl 0x828457b0
	ctx.lr = 0x830F56D0;
	sub_828457B0(ctx, base);
	pc = 0x830F56D0; continue 'dispatch;
            }
            0x830F56D0 => {
    //   block [0x830F56D0..0x830F56EC)
	// 830F56D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F56D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F56D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F56DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F56E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F56E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F56E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F56F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F56F0 size=1112
    let mut pc: u32 = 0x830F56F0;
    'dispatch: loop {
        match pc {
            0x830F56F0 => {
    //   block [0x830F56F0..0x830F571C)
	// 830F56F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F56F4: 4BBB3D09  bl 0x82ca93fc
	ctx.lr = 0x830F56F8;
	sub_82CA93D0(ctx, base);
	// 830F56F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F56FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5700: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F5704: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F5708: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F570C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F5710: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830F5714: 3B4BA9BC  addi r26, r11, -0x5644
	ctx.r[26].s64 = ctx.r[11].s64 + -22084;
	// 830F5718: 3B2AB044  addi r25, r10, -0x4fbc
	ctx.r[25].s64 = ctx.r[10].s64 + -20412;
	pc = 0x830F571C; continue 'dispatch;
            }
            0x830F571C => {
    //   block [0x830F571C..0x830F5788)
	// 830F571C: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5720: 2B1F000B  cmplwi cr6, r31, 0xb
	ctx.cr[6].compare_u32(ctx.r[31].u32, 11 as u32, &mut ctx.xer);
	// 830F5724: A07D0000  lhz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5728: 41990328  bgt cr6, 0x830f5a50
	if ctx.cr[6].gt {
	pc = 0x830F5A50; continue 'dispatch;
	}
	// 830F572C: 3D808208  lis r12, -0x7df8
	ctx.r[12].s64 = -2113404928;
	// 830F5730: 398CAF20  addi r12, r12, -0x50e0
	ctx.r[12].s64 = ctx.r[12].s64 + -20704;
	// 830F5734: 7C0CF8AE  lbzx r0, r12, r31
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830F5738: 5400103A  slwi r0, r0, 2
	ctx.r[0].u32 = ctx.r[0].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830F573C: 3D80830F  lis r12, -0x7cf1
	ctx.r[12].s64 = -2096168960;
	// 830F5740: 398C5754  addi r12, r12, 0x5754
	ctx.r[12].s64 = ctx.r[12].s64 + 22356;
	// 830F5744: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 830F5748: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 830F574C: 60000000  nop
	// 830F5750: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 830F5754: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F5758: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 830F575C: 409A0310  bne cr6, 0x830f5a6c
	if !ctx.cr[6].eq {
	pc = 0x830F5A6C; continue 'dispatch;
	}
	// 830F5760: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5764: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F5768: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F576C: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F5770: 409A0018  bne cr6, 0x830f5788
	if !ctx.cr[6].eq {
	pc = 0x830F5788; continue 'dispatch;
	}
	// 830F5774: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5778: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F577C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5780: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F5784: 48000010  b 0x830f5794
	pc = 0x830F5794; continue 'dispatch;
            }
            0x830F5788 => {
    //   block [0x830F5788..0x830F5794)
	// 830F5788: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F578C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5790: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F5794; continue 'dispatch;
            }
            0x830F5794 => {
    //   block [0x830F5794..0x830F5798)
	// 830F5794: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	pc = 0x830F5798; continue 'dispatch;
            }
            0x830F5798 => {
    //   block [0x830F5798..0x830F57B0)
	// 830F5798: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F579C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F57A0: 4BFFFF7C  b 0x830f571c
	pc = 0x830F571C; continue 'dispatch;
	// 830F57A4: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 830F57A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F57AC: 4BFFE91D  bl 0x830f40c8
	ctx.lr = 0x830F57B0;
	sub_830F40C8(ctx, base);
            }
            0x830F57B0 => {
    //   block [0x830F57B0..0x830F57CC)
	// 830F57B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F57B4: 418202EC  beq 0x830f5aa0
	if ctx.cr[0].eq {
	pc = 0x830F5AA0; continue 'dispatch;
	}
	// 830F57B8: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 830F57BC: 4BFFFF60  b 0x830f571c
	pc = 0x830F571C; continue 'dispatch;
	// 830F57C0: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F57C4: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 830F57C8: 409A0040  bne cr6, 0x830f5808
	if !ctx.cr[6].eq {
	pc = 0x830F5808; continue 'dispatch;
	}
            }
            0x830F57CC => {
    //   block [0x830F57CC..0x830F57F4)
	// 830F57CC: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F57D0: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F57D4: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F57D8: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F57DC: 409A0018  bne cr6, 0x830f57f4
	if !ctx.cr[6].eq {
	pc = 0x830F57F4; continue 'dispatch;
	}
	// 830F57E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F57E4: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F57E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F57EC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F57F0: 48000010  b 0x830f5800
	pc = 0x830F5800; continue 'dispatch;
            }
            0x830F57F4 => {
    //   block [0x830F57F4..0x830F5800)
	// 830F57F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F57F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F57FC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F5800; continue 'dispatch;
            }
            0x830F5800 => {
    //   block [0x830F5800..0x830F5808)
	// 830F5800: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 830F5804: 4BFFFF94  b 0x830f5798
	pc = 0x830F5798; continue 'dispatch;
            }
            0x830F5808 => {
    //   block [0x830F5808..0x830F5810)
	// 830F5808: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 830F580C: 409A0040  bne cr6, 0x830f584c
	if !ctx.cr[6].eq {
	pc = 0x830F584C; continue 'dispatch;
	}
	pc = 0x830F5810; continue 'dispatch;
            }
            0x830F5810 => {
    //   block [0x830F5810..0x830F5838)
	// 830F5810: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5814: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F5818: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F581C: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F5820: 409A0018  bne cr6, 0x830f5838
	if !ctx.cr[6].eq {
	pc = 0x830F5838; continue 'dispatch;
	}
	// 830F5824: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5828: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F582C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5830: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F5834: 48000010  b 0x830f5844
	pc = 0x830F5844; continue 'dispatch;
            }
            0x830F5838 => {
    //   block [0x830F5838..0x830F5844)
	// 830F5838: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F583C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5840: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F5844; continue 'dispatch;
            }
            0x830F5844 => {
    //   block [0x830F5844..0x830F584C)
	// 830F5844: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	// 830F5848: 4BFFFF50  b 0x830f5798
	pc = 0x830F5798; continue 'dispatch;
            }
            0x830F584C => {
    //   block [0x830F584C..0x830F5870)
	// 830F584C: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F5850: 419A0020  beq cr6, 0x830f5870
	if ctx.cr[6].eq {
	pc = 0x830F5870; continue 'dispatch;
	}
	// 830F5854: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F5858: 419A0018  beq cr6, 0x830f5870
	if ctx.cr[6].eq {
	pc = 0x830F5870; continue 'dispatch;
	}
	// 830F585C: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F5860: 419A0010  beq cr6, 0x830f5870
	if ctx.cr[6].eq {
	pc = 0x830F5870; continue 'dispatch;
	}
	// 830F5864: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F5868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F586C: 409A0008  bne cr6, 0x830f5874
	if !ctx.cr[6].eq {
	pc = 0x830F5874; continue 'dispatch;
	}
	pc = 0x830F5870; continue 'dispatch;
            }
            0x830F5870 => {
    //   block [0x830F5870..0x830F5874)
	// 830F5870: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x830F5874; continue 'dispatch;
            }
            0x830F5874 => {
    //   block [0x830F5874..0x830F5960)
	// 830F5874: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5878: 41820230  beq 0x830f5aa8
	if ctx.cr[0].eq {
	pc = 0x830F5AA8; continue 'dispatch;
	}
	// 830F587C: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 830F5880: 4BFFFE9C  b 0x830f571c
	pc = 0x830F571C; continue 'dispatch;
	// 830F5884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F5888: 4BFFD5F9  bl 0x830f2e80
	ctx.lr = 0x830F588C;
	sub_830F2E80(ctx, base);
	// 830F588C: 3BE0000B  li r31, 0xb
	ctx.r[31].s64 = 11;
	// 830F5890: 4BFFFE8C  b 0x830f571c
	pc = 0x830F571C; continue 'dispatch;
	// 830F5894: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F5898: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 830F589C: 419AFF30  beq cr6, 0x830f57cc
	if ctx.cr[6].eq {
	pc = 0x830F57CC; continue 'dispatch;
	}
	// 830F58A0: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 830F58A4: 419AFF6C  beq cr6, 0x830f5810
	if ctx.cr[6].eq {
	pc = 0x830F5810; continue 'dispatch;
	}
	// 830F58A8: 4BFFE541  bl 0x830f3de8
	ctx.lr = 0x830F58AC;
	sub_830F3DE8(ctx, base);
	// 830F58AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F58B0: 41820204  beq 0x830f5ab4
	if ctx.cr[0].eq {
	pc = 0x830F5AB4; continue 'dispatch;
	}
	// 830F58B4: 3BE00005  li r31, 5
	ctx.r[31].s64 = 5;
	// 830F58B8: 4BFFFE64  b 0x830f571c
	pc = 0x830F571C; continue 'dispatch;
	// 830F58BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F58C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F58C4: 4BFFFA95  bl 0x830f5358
	ctx.lr = 0x830F58C8;
	sub_830F5358(ctx, base);
	// 830F58C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F58CC: 418201D4  beq 0x830f5aa0
	if ctx.cr[0].eq {
	pc = 0x830F5AA0; continue 'dispatch;
	}
	// 830F58D0: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 830F58D4: 4BFFFE48  b 0x830f571c
	pc = 0x830F571C; continue 'dispatch;
	// 830F58D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F58DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F58E0: 4BFFDEA1  bl 0x830f3780
	ctx.lr = 0x830F58E4;
	sub_830F3780(ctx, base);
	// 830F58E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F58E8: 41820258  beq 0x830f5b40
	if ctx.cr[0].eq {
	pc = 0x830F5B40; continue 'dispatch;
	}
	// 830F58EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F58F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830F58F4: 80FC0024  lwz r7, 0x24(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F58F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F58FC: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 830F5900: 38AB0014  addi r5, r11, 0x14
	ctx.r[5].s64 = ctx.r[11].s64 + 20;
	// 830F5904: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 830F5908: 393C0020  addi r9, r28, 0x20
	ctx.r[9].s64 = ctx.r[28].s64 + 32;
	// 830F590C: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F5910: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830F5914: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F5918: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F591C: 915C0024  stw r10, 0x24(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830F5920: 917C0028  stw r11, 0x28(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830F5924: 4BFFED55  bl 0x830f4678
	ctx.lr = 0x830F5928;
	sub_830F4678(ctx, base);
	// 830F5928: 4BFFFE88  b 0x830f57b0
	pc = 0x830F57B0; continue 'dispatch;
	// 830F592C: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F5930: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 830F5934: 409A0138  bne cr6, 0x830f5a6c
	if !ctx.cr[6].eq {
	pc = 0x830F5A6C; continue 'dispatch;
	}
	// 830F5938: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F593C: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F5940: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5944: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F5948: 409A0018  bne cr6, 0x830f5960
	if !ctx.cr[6].eq {
	pc = 0x830F5960; continue 'dispatch;
	}
	// 830F594C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5950: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F5954: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5958: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F595C: 48000010  b 0x830f596c
	pc = 0x830F596C; continue 'dispatch;
            }
            0x830F5960 => {
    //   block [0x830F5960..0x830F596C)
	// 830F5960: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5964: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5968: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F596C; continue 'dispatch;
            }
            0x830F596C => {
    //   block [0x830F596C..0x830F59A8)
	// 830F596C: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 830F5970: 4BFFFE28  b 0x830f5798
	pc = 0x830F5798; continue 'dispatch;
	// 830F5974: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F5978: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 830F597C: 409A0158  bne cr6, 0x830f5ad4
	if !ctx.cr[6].eq {
	pc = 0x830F5AD4; continue 'dispatch;
	}
	// 830F5980: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5984: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F5988: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F598C: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F5990: 409A0018  bne cr6, 0x830f59a8
	if !ctx.cr[6].eq {
	pc = 0x830F59A8; continue 'dispatch;
	}
	// 830F5994: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5998: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F599C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F59A0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F59A4: 48000010  b 0x830f59b4
	pc = 0x830F59B4; continue 'dispatch;
            }
            0x830F59A8 => {
    //   block [0x830F59A8..0x830F59B4)
	// 830F59A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F59AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F59B0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F59B4; continue 'dispatch;
            }
            0x830F59B4 => {
    //   block [0x830F59B4..0x830F59EC)
	// 830F59B4: 3BE00009  li r31, 9
	ctx.r[31].s64 = 9;
	// 830F59B8: 4BFFFDE0  b 0x830f5798
	pc = 0x830F5798; continue 'dispatch;
	// 830F59BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F59C0: 4BFFE631  bl 0x830f3ff0
	ctx.lr = 0x830F59C4;
	sub_830F3FF0(ctx, base);
	// 830F59C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F59C8: 418200D8  beq 0x830f5aa0
	if ctx.cr[0].eq {
	pc = 0x830F5AA0; continue 'dispatch;
	}
	// 830F59CC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F59D0: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F59D4: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 830F59D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F59DC: 7D7F0E70  srawi r31, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 830F59E0: 409A000C  bne cr6, 0x830f59ec
	if !ctx.cr[6].eq {
	pc = 0x830F59EC; continue 'dispatch;
	}
	// 830F59E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F59E8: 48000008  b 0x830f59f0
	pc = 0x830F59F0; continue 'dispatch;
            }
            0x830F59EC => {
    //   block [0x830F59EC..0x830F59F0)
	// 830F59EC: 4B085695  bl 0x8217b080
	ctx.lr = 0x830F59F0;
	sub_8217B080(ctx, base);
	pc = 0x830F59F0; continue 'dispatch;
            }
            0x830F59F0 => {
    //   block [0x830F59F0..0x830F5A50)
	// 830F59F0: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F59F4: 409A00EC  bne cr6, 0x830f5ae0
	if !ctx.cr[6].eq {
	pc = 0x830F5AE0; continue 'dispatch;
	}
	// 830F59F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830F59FC: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5A00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F5A04: 4BFFCDED  bl 0x830f27f0
	ctx.lr = 0x830F5A08;
	sub_830F27F0(ctx, base);
	// 830F5A08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F5A0C: 408200D4  bne 0x830f5ae0
	if !ctx.cr[0].eq {
	pc = 0x830F5AE0; continue 'dispatch;
	}
	// 830F5A10: 3BE0000A  li r31, 0xa
	ctx.r[31].s64 = 10;
	// 830F5A14: 4BFFFD08  b 0x830f571c
	pc = 0x830F571C; continue 'dispatch;
	// 830F5A18: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F5A1C: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 830F5A20: 419A00DC  beq cr6, 0x830f5afc
	if ctx.cr[6].eq {
	pc = 0x830F5AFC; continue 'dispatch;
	}
	// 830F5A24: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5A28: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 830F5A2C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5A30: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830F5A34: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F5A38: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F5A3C: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F5A40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5A44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5A48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F5A4C: 4E800421  bctrl
	ctx.lr = 0x830F5A50;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F5A50 => {
    //   block [0x830F5A50..0x830F5A58)
	// 830F5A50: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F5A54: 4098FCC8  bge cr6, 0x830f571c
	if !ctx.cr[6].lt {
	pc = 0x830F571C; continue 'dispatch;
	}
	pc = 0x830F5A58; continue 'dispatch;
            }
            0x830F5A58 => {
    //   block [0x830F5A58..0x830F5A64)
	// 830F5A58: 397F0002  addi r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 2;
	// 830F5A5C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F5A60: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	pc = 0x830F5A64; continue 'dispatch;
            }
            0x830F5A64 => {
    //   block [0x830F5A64..0x830F5A6C)
	// 830F5A64: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F5A68: 4BBB39E4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830F5A6C => {
    //   block [0x830F5A6C..0x830F5A74)
	// 830F5A6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5A70: 390BB040  addi r8, r11, -0x4fc0
	ctx.r[8].s64 = ctx.r[11].s64 + -20416;
	pc = 0x830F5A74; continue 'dispatch;
            }
            0x830F5A74 => {
    //   block [0x830F5A74..0x830F5AA0)
	// 830F5A74: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5A78: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830F5A7C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5A80: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F5A84: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F5A88: 3880D8F2  li r4, -0x270e
	ctx.r[4].s64 = -9998;
	// 830F5A8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5A90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5A94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F5A98: 4E800421  bctrl
	ctx.lr = 0x830F5A9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F5A9C: 4BFFFFBC  b 0x830f5a58
	pc = 0x830F5A58; continue 'dispatch;
            }
            0x830F5AA0 => {
    //   block [0x830F5AA0..0x830F5AA8)
	// 830F5AA0: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F5AA4: 4BFFFFB4  b 0x830f5a58
	pc = 0x830F5A58; continue 'dispatch;
            }
            0x830F5AA8 => {
    //   block [0x830F5AA8..0x830F5AB4)
	// 830F5AA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5AAC: 390BB028  addi r8, r11, -0x4fd8
	ctx.r[8].s64 = ctx.r[11].s64 + -20440;
	// 830F5AB0: 4BFFFFC4  b 0x830f5a74
	pc = 0x830F5A74; continue 'dispatch;
            }
            0x830F5AB4 => {
    //   block [0x830F5AB4..0x830F5AD4)
	// 830F5AB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5AB8: 390BB014  addi r8, r11, -0x4fec
	ctx.r[8].s64 = ctx.r[11].s64 + -20460;
	// 830F5ABC: 4BFFFFB8  b 0x830f5a74
	pc = 0x830F5A74; continue 'dispatch;
	// 830F5AC0: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F5AC4: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 830F5AC8: 419A0034  beq cr6, 0x830f5afc
	if ctx.cr[6].eq {
	pc = 0x830F5AFC; continue 'dispatch;
	}
	// 830F5ACC: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 830F5AD0: 4BFFFFA4  b 0x830f5a74
	pc = 0x830F5A74; continue 'dispatch;
            }
            0x830F5AD4 => {
    //   block [0x830F5AD4..0x830F5AE0)
	// 830F5AD4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5AD8: 390BB010  addi r8, r11, -0x4ff0
	ctx.r[8].s64 = ctx.r[11].s64 + -20464;
	// 830F5ADC: 4BFFFF98  b 0x830f5a74
	pc = 0x830F5A74; continue 'dispatch;
            }
            0x830F5AE0 => {
    //   block [0x830F5AE0..0x830F5AFC)
	// 830F5AE0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830F5AE4: 809C0014  lwz r4, 0x14(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5AE8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F5AEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F5AF0: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 830F5AF4: 4BFFCC3D  bl 0x830f2730
	ctx.lr = 0x830F5AF8;
	sub_830F2730(ctx, base);
	// 830F5AF8: 4BFFFF60  b 0x830f5a58
	pc = 0x830F5A58; continue 'dispatch;
            }
            0x830F5AFC => {
    //   block [0x830F5AFC..0x830F5B24)
	// 830F5AFC: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5B00: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830F5B04: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5B08: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830F5B0C: 409A0018  bne cr6, 0x830f5b24
	if !ctx.cr[6].eq {
	pc = 0x830F5B24; continue 'dispatch;
	}
	// 830F5B10: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5B14: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830F5B18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5B1C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F5B20: 48000010  b 0x830f5b30
	pc = 0x830F5B30; continue 'dispatch;
            }
            0x830F5B24 => {
    //   block [0x830F5B24..0x830F5B30)
	// 830F5B24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5B28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5B2C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F5B30; continue 'dispatch;
            }
            0x830F5B30 => {
    //   block [0x830F5B30..0x830F5B40)
	// 830F5B30: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 830F5B34: 3BE0FFFE  li r31, -2
	ctx.r[31].s64 = -2;
	// 830F5B38: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F5B3C: 4BFFFF1C  b 0x830f5a58
	pc = 0x830F5A58; continue 'dispatch;
            }
            0x830F5B40 => {
    //   block [0x830F5B40..0x830F5B48)
	// 830F5B40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5B44: 4BFFFF20  b 0x830f5a64
	pc = 0x830F5A64; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5B48 size=160
    let mut pc: u32 = 0x830F5B48;
    'dispatch: loop {
        match pc {
            0x830F5B48 => {
    //   block [0x830F5B48..0x830F5BB8)
	// 830F5B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5B50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5B54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5B5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5B60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F5B64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F5B68: 3880006C  li r4, 0x6c
	ctx.r[4].s64 = 108;
	// 830F5B6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5B70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5B74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5B78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F5B7C: 4E800421  bctrl
	ctx.lr = 0x830F5B80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F5B80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F5B84: 40820034  bne 0x830f5bb8
	if !ctx.cr[0].eq {
	pc = 0x830F5BB8; continue 'dispatch;
	}
	// 830F5B88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5B8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5B90: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5B94: 3880D8F1  li r4, -0x270f
	ctx.r[4].s64 = -9999;
	// 830F5B98: 38EBA7B0  addi r7, r11, -0x5850
	ctx.r[7].s64 = ctx.r[11].s64 + -22608;
	// 830F5B9C: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F5BA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5BA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5BA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F5BAC: 4E800421  bctrl
	ctx.lr = 0x830F5BB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F5BB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5BB4: 4800001C  b 0x830f5bd0
	pc = 0x830F5BD0; continue 'dispatch;
            }
            0x830F5BB8 => {
    //   block [0x830F5BB8..0x830F5BD0)
	// 830F5BB8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5BBC: 4BFFF9CD  bl 0x830f5588
	ctx.lr = 0x830F5BC0;
	sub_830F5588(ctx, base);
	// 830F5BC0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830F5BC4: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F5BC8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F5BCC: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x830F5BD0; continue 'dispatch;
            }
            0x830F5BD0 => {
    //   block [0x830F5BD0..0x830F5BE8)
	// 830F5BD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F5BD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5BD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5BDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F5BE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5BE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5BE8 size=304
    let mut pc: u32 = 0x830F5BE8;
    'dispatch: loop {
        match pc {
            0x830F5BE8 => {
    //   block [0x830F5BE8..0x830F5C04)
	// 830F5BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5BEC: 4BBB381D  bl 0x82ca9408
	ctx.lr = 0x830F5BF0;
	sub_82CA93D0(ctx, base);
	// 830F5BF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5BF4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830F5BF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F5BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F5C00: 409A000C  bne cr6, 0x830f5c0c
	if !ctx.cr[6].eq {
	pc = 0x830F5C0C; continue 'dispatch;
	}
	pc = 0x830F5C04; continue 'dispatch;
            }
            0x830F5C04 => {
    //   block [0x830F5C04..0x830F5C0C)
	// 830F5C04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5C08: 48000108  b 0x830f5d10
	pc = 0x830F5D10; continue 'dispatch;
            }
            0x830F5C0C => {
    //   block [0x830F5C0C..0x830F5C4C)
	// 830F5C0C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830F5C10: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830F5C14: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830F5C18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F5C1C: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 830F5C20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F5C24: 93BE0010  stw r29, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 830F5C28: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 830F5C2C: 4BFFFF1D  bl 0x830f5b48
	ctx.lr = 0x830F5C30;
	sub_830F5B48(ctx, base);
	// 830F5C30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5C34: 4182FFD0  beq 0x830f5c04
	if ctx.cr[0].eq {
	pc = 0x830F5C04; continue 'dispatch;
	}
	// 830F5C38: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F5C3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F5C40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F5C44: 4BFFF4F5  bl 0x830f5138
	ctx.lr = 0x830F5C48;
	sub_830F5138(ctx, base);
	// 830F5C48: 4800009C  b 0x830f5ce4
	pc = 0x830F5CE4; continue 'dispatch;
            }
            0x830F5C4C => {
    //   block [0x830F5C4C..0x830F5C80)
	// 830F5C4C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F5C50: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5C54: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830F5C58: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830F5C5C: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F5C60: 419A0020  beq cr6, 0x830f5c80
	if ctx.cr[6].eq {
	pc = 0x830F5C80; continue 'dispatch;
	}
	// 830F5C64: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F5C68: 419A0018  beq cr6, 0x830f5c80
	if ctx.cr[6].eq {
	pc = 0x830F5C80; continue 'dispatch;
	}
	// 830F5C6C: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F5C70: 419A0010  beq cr6, 0x830f5c80
	if ctx.cr[6].eq {
	pc = 0x830F5C80; continue 'dispatch;
	}
	// 830F5C74: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F5C78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F5C7C: 409A0008  bne cr6, 0x830f5c84
	if !ctx.cr[6].eq {
	pc = 0x830F5C84; continue 'dispatch;
	}
	pc = 0x830F5C80; continue 'dispatch;
            }
            0x830F5C80 => {
    //   block [0x830F5C80..0x830F5C84)
	// 830F5C80: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x830F5C84; continue 'dispatch;
            }
            0x830F5C84 => {
    //   block [0x830F5C84..0x830F5CB0)
	// 830F5C84: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F5C88: 41820040  beq 0x830f5cc8
	if ctx.cr[0].eq {
	pc = 0x830F5CC8; continue 'dispatch;
	}
	// 830F5C8C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F5C90: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5C94: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F5C98: 409A0018  bne cr6, 0x830f5cb0
	if !ctx.cr[6].eq {
	pc = 0x830F5CB0; continue 'dispatch;
	}
	// 830F5C9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5CA0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830F5CA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F5CA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F5CAC: 48000010  b 0x830f5cbc
	pc = 0x830F5CBC; continue 'dispatch;
            }
            0x830F5CB0 => {
    //   block [0x830F5CB0..0x830F5CBC)
	// 830F5CB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5CB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F5CB8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830F5CBC; continue 'dispatch;
            }
            0x830F5CBC => {
    //   block [0x830F5CBC..0x830F5CC8)
	// 830F5CBC: 396A0002  addi r11, r10, 2
	ctx.r[11].s64 = ctx.r[10].s64 + 2;
	// 830F5CC0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F5CC4: 4BFFFF88  b 0x830f5c4c
	pc = 0x830F5C4C; continue 'dispatch;
            }
            0x830F5CC8 => {
    //   block [0x830F5CC8..0x830F5CE4)
	// 830F5CC8: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 830F5CCC: 409A0034  bne cr6, 0x830f5d00
	if !ctx.cr[6].eq {
	pc = 0x830F5D00; continue 'dispatch;
	}
	// 830F5CD0: 552B043E  clrlwi r11, r9, 0x10
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 830F5CD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F5CD8: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 830F5CDC: 409A0014  bne cr6, 0x830f5cf0
	if !ctx.cr[6].eq {
	pc = 0x830F5CF0; continue 'dispatch;
	}
	// 830F5CE0: 4BFFD749  bl 0x830f3428
	ctx.lr = 0x830F5CE4;
	sub_830F3428(ctx, base);
	pc = 0x830F5CE4; continue 'dispatch;
            }
            0x830F5CE4 => {
    //   block [0x830F5CE4..0x830F5CF0)
	// 830F5CE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5CE8: 4082FF64  bne 0x830f5c4c
	if !ctx.cr[0].eq {
	pc = 0x830F5C4C; continue 'dispatch;
	}
	// 830F5CEC: 48000014  b 0x830f5d00
	pc = 0x830F5D00; continue 'dispatch;
            }
            0x830F5CF0 => {
    //   block [0x830F5CF0..0x830F5D00)
	// 830F5CF0: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 830F5CF4: 4BFFF9FD  bl 0x830f56f0
	ctx.lr = 0x830F5CF8;
	sub_830F56F0(ctx, base);
	// 830F5CF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5CFC: 40820010  bne 0x830f5d0c
	if !ctx.cr[0].eq {
	pc = 0x830F5D0C; continue 'dispatch;
	}
	pc = 0x830F5D00; continue 'dispatch;
            }
            0x830F5D00 => {
    //   block [0x830F5D00..0x830F5D0C)
	// 830F5D00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F5D04: 4BFFC93D  bl 0x830f2640
	ctx.lr = 0x830F5D08;
	sub_830F2640(ctx, base);
	// 830F5D08: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x830F5D0C; continue 'dispatch;
            }
            0x830F5D0C => {
    //   block [0x830F5D0C..0x830F5D10)
	// 830F5D0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x830F5D10; continue 'dispatch;
            }
            0x830F5D10 => {
    //   block [0x830F5D10..0x830F5D18)
	// 830F5D10: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F5D14: 4BBB3744  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5D18 size=96
    let mut pc: u32 = 0x830F5D18;
    'dispatch: loop {
        match pc {
            0x830F5D18 => {
    //   block [0x830F5D18..0x830F5D5C)
	// 830F5D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5D20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5D24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5D28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5D2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F5D30: 4B1F4489  bl 0x822ea1b8
	ctx.lr = 0x830F5D34;
	sub_822EA1B8(ctx, base);
	// 830F5D34: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F5D38: 41820024  beq 0x830f5d5c
	if ctx.cr[0].eq {
	pc = 0x830F5D5C; continue 'dispatch;
	}
	// 830F5D3C: 38BEFFF4  addi r5, r30, -0xc
	ctx.r[5].s64 = ctx.r[30].s64 + -12;
	// 830F5D40: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830F5D44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F5D48: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 830F5D4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F5D50: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830F5D54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F5D58: 4BBB3C59  bl 0x82ca99b0
	ctx.lr = 0x830F5D5C;
	sub_82CA99B0(ctx, base);
	pc = 0x830F5D5C; continue 'dispatch;
            }
            0x830F5D5C => {
    //   block [0x830F5D5C..0x830F5D78)
	// 830F5D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5D60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F5D64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5D68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5D6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F5D70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5D74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5D78 size=268
    let mut pc: u32 = 0x830F5D78;
    'dispatch: loop {
        match pc {
            0x830F5D78 => {
    //   block [0x830F5D78..0x830F5DA8)
	// 830F5D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5D80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5D84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5D88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5D8C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F5D90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F5D94: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5D98: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 830F5D9C: 3909FFF4  addi r8, r9, -0xc
	ctx.r[8].s64 = ctx.r[9].s64 + -12;
	// 830F5DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F5DA4: 419A0028  beq cr6, 0x830f5dcc
	if ctx.cr[6].eq {
	pc = 0x830F5DCC; continue 'dispatch;
	}
	pc = 0x830F5DA8; continue 'dispatch;
            }
            0x830F5DA8 => {
    //   block [0x830F5DA8..0x830F5DC4)
	// 830F5DA8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5DAC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830F5DB0: 40980014  bge cr6, 0x830f5dc4
	if !ctx.cr[6].lt {
	pc = 0x830F5DC4; continue 'dispatch;
	}
	// 830F5DB4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 830F5DB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F5DC0: 409AFFE8  bne cr6, 0x830f5da8
	if !ctx.cr[6].eq {
	pc = 0x830F5DA8; continue 'dispatch;
	}
	pc = 0x830F5DC4; continue 'dispatch;
            }
            0x830F5DC4 => {
    //   block [0x830F5DC4..0x830F5DCC)
	// 830F5DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F5DC8: 409A0074  bne cr6, 0x830f5e3c
	if !ctx.cr[6].eq {
	pc = 0x830F5E3C; continue 'dispatch;
	}
	pc = 0x830F5DCC; continue 'dispatch;
            }
            0x830F5DCC => {
    //   block [0x830F5DCC..0x830F5DD8)
	// 830F5DCC: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830F5DD0: 40990008  ble cr6, 0x830f5dd8
	if !ctx.cr[6].gt {
	pc = 0x830F5DD8; continue 'dispatch;
	}
	// 830F5DD4: 393F000C  addi r9, r31, 0xc
	ctx.r[9].s64 = ctx.r[31].s64 + 12;
	pc = 0x830F5DD8; continue 'dispatch;
            }
            0x830F5DD8 => {
    //   block [0x830F5DD8..0x830F5E30)
	// 830F5DD8: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 830F5DDC: 4BFFFF3D  bl 0x830f5d18
	ctx.lr = 0x830F5DE0;
	sub_830F5D18(ctx, base);
	// 830F5DE0: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5DE4: 40820054  bne 0x830f5e38
	if !ctx.cr[0].eq {
	pc = 0x830F5E38; continue 'dispatch;
	}
	// 830F5DE8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F5DEC: 388BBBDA  addi r4, r11, -0x4426
	ctx.r[4].s64 = ctx.r[11].s64 + -17446;
	// 830F5DF0: 896BBBDA  lbz r11, -0x4426(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-17446 as u32) ) } as u64;
	// 830F5DF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F5DF8: 40820038  bne 0x830f5e30
	if !ctx.cr[0].eq {
	pc = 0x830F5E30; continue 'dispatch;
	}
	// 830F5DFC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5E00: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F5E04: 396BB054  addi r11, r11, -0x4fac
	ctx.r[11].s64 = ctx.r[11].s64 + -20396;
	// 830F5E08: 394AB048  addi r10, r10, -0x4fb8
	ctx.r[10].s64 = ctx.r[10].s64 + -20408;
	// 830F5E0C: 39200046  li r9, 0x46
	ctx.r[9].s64 = 70;
	// 830F5E10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F5E14: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830F5E18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F5E1C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 830F5E20: 4BFFBF99  bl 0x830f1db8
	ctx.lr = 0x830F5E24;
	sub_830F1DB8(ctx, base);
	// 830F5E24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5E28: 40820008  bne 0x830f5e30
	if !ctx.cr[0].eq {
	pc = 0x830F5E30; continue 'dispatch;
	}
	// 830F5E2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F5E30; continue 'dispatch;
            }
            0x830F5E30 => {
    //   block [0x830F5E30..0x830F5E38)
	// 830F5E30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5E34: 48000038  b 0x830f5e6c
	pc = 0x830F5E6C; continue 'dispatch;
            }
            0x830F5E38 => {
    //   block [0x830F5E38..0x830F5E3C)
	// 830F5E38: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x830F5E3C; continue 'dispatch;
            }
            0x830F5E3C => {
    //   block [0x830F5E3C..0x830F5E64)
	// 830F5E3C: 395F0003  addi r10, r31, 3
	ctx.r[10].s64 = ctx.r[31].s64 + 3;
	// 830F5E40: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F5E44: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5E48: 554A003A  rlwinm r10, r10, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830F5E4C: 7D035214  add r8, r3, r10
	ctx.r[8].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 830F5E50: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830F5E54: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830F5E58: 4198000C  blt cr6, 0x830f5e64
	if ctx.cr[6].lt {
	pc = 0x830F5E64; continue 'dispatch;
	}
	// 830F5E5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F5E60: 48000008  b 0x830f5e68
	pc = 0x830F5E68; continue 'dispatch;
            }
            0x830F5E64 => {
    //   block [0x830F5E64..0x830F5E68)
	// 830F5E64: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	pc = 0x830F5E68; continue 'dispatch;
            }
            0x830F5E68 => {
    //   block [0x830F5E68..0x830F5E6C)
	// 830F5E68: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830F5E6C; continue 'dispatch;
            }
            0x830F5E6C => {
    //   block [0x830F5E6C..0x830F5E84)
	// 830F5E6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F5E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5E78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F5E7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5E88 size=180
    let mut pc: u32 = 0x830F5E88;
    'dispatch: loop {
        match pc {
            0x830F5E88 => {
    //   block [0x830F5E88..0x830F5EF4)
	// 830F5E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5E8C: 4BBB357D  bl 0x82ca9408
	ctx.lr = 0x830F5E90;
	sub_82CA93D0(ctx, base);
	// 830F5E90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5E94: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F5E98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5E9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F5EA0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830F5EA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F5EA8: 409A004C  bne cr6, 0x830f5ef4
	if !ctx.cr[6].eq {
	pc = 0x830F5EF4; continue 'dispatch;
	}
	// 830F5EAC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830F5EB0: 388BBBDB  addi r4, r11, -0x4425
	ctx.r[4].s64 = ctx.r[11].s64 + -17445;
	// 830F5EB4: 896BBBDB  lbz r11, -0x4425(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-17445 as u32) ) } as u64;
	// 830F5EB8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F5EBC: 40820038  bne 0x830f5ef4
	if !ctx.cr[0].eq {
	pc = 0x830F5EF4; continue 'dispatch;
	}
	// 830F5EC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5EC4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F5EC8: 396BB054  addi r11, r11, -0x4fac
	ctx.r[11].s64 = ctx.r[11].s64 + -20396;
	// 830F5ECC: 394AB070  addi r10, r10, -0x4f90
	ctx.r[10].s64 = ctx.r[10].s64 + -20368;
	// 830F5ED0: 39200056  li r9, 0x56
	ctx.r[9].s64 = 86;
	// 830F5ED4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F5ED8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830F5EDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F5EE0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 830F5EE4: 4BFFBED5  bl 0x830f1db8
	ctx.lr = 0x830F5EE8;
	sub_830F1DB8(ctx, base);
	// 830F5EE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5EEC: 40820008  bne 0x830f5ef4
	if !ctx.cr[0].eq {
	pc = 0x830F5EF4; continue 'dispatch;
	}
	// 830F5EF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F5EF4; continue 'dispatch;
            }
            0x830F5EF4 => {
    //   block [0x830F5EF4..0x830F5F04)
	// 830F5EF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F5EF8: 409A000C  bne cr6, 0x830f5f04
	if !ctx.cr[6].eq {
	pc = 0x830F5F04; continue 'dispatch;
	}
	// 830F5EFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5F00: 48000034  b 0x830f5f34
	pc = 0x830F5F34; continue 'dispatch;
            }
            0x830F5F04 => {
    //   block [0x830F5F04..0x830F5F34)
	// 830F5F04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5F08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F5F0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F5F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5F14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5F18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F5F1C: 4E800421  bctrl
	ctx.lr = 0x830F5F20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F5F20: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F5F24: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F5F28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5F2C: 41820008  beq 0x830f5f34
	if ctx.cr[0].eq {
	pc = 0x830F5F34; continue 'dispatch;
	}
	// 830F5F30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            0x830F5F34 => {
    //   block [0x830F5F34..0x830F5F3C)
	// 830F5F34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F5F38: 4BBB3520  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5F40 size=84
    let mut pc: u32 = 0x830F5F40;
    'dispatch: loop {
        match pc {
            0x830F5F40 => {
    //   block [0x830F5F40..0x830F5F60)
	// 830F5F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5F54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F5F58: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5F5C: 48000010  b 0x830f5f6c
	pc = 0x830F5F6C; continue 'dispatch;
            }
            0x830F5F60 => {
    //   block [0x830F5F60..0x830F5F6C)
	// 830F5F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5F64: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5F68: 4B74F849  bl 0x828457b0
	ctx.lr = 0x830F5F6C;
	sub_828457B0(ctx, base);
	pc = 0x830F5F6C; continue 'dispatch;
            }
            0x830F5F6C => {
    //   block [0x830F5F6C..0x830F5F94)
	// 830F5F6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F5F70: 409AFFF0  bne cr6, 0x830f5f60
	if !ctx.cr[6].eq {
	pc = 0x830F5F60; continue 'dispatch;
	}
	// 830F5F74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F5F78: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F5F7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F5F80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5F84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5F88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F5F8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5F90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F5F98 size=28
    let mut pc: u32 = 0x830F5F98;
    'dispatch: loop {
        match pc {
            0x830F5F98 => {
    //   block [0x830F5F98..0x830F5FB4)
	// 830F5F98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5F9C: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 830F5FA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F5FA4: 396BB080  addi r11, r11, -0x4f80
	ctx.r[11].s64 = ctx.r[11].s64 + -20352;
	// 830F5FA8: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830F5FAC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F5FB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F5FB8 size=16
    let mut pc: u32 = 0x830F5FB8;
    'dispatch: loop {
        match pc {
            0x830F5FB8 => {
    //   block [0x830F5FB8..0x830F5FC8)
	// 830F5FB8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F5FBC: 396BB080  addi r11, r11, -0x4f80
	ctx.r[11].s64 = ctx.r[11].s64 + -20352;
	// 830F5FC0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F5FC4: 4BFFFF7C  b 0x830f5f40
	sub_830F5F40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F5FC8 size=188
    let mut pc: u32 = 0x830F5FC8;
    'dispatch: loop {
        match pc {
            0x830F5FC8 => {
    //   block [0x830F5FC8..0x830F5FFC)
	// 830F5FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5FD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5FD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5FD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F5FE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F5FE4: 4BFFC10D  bl 0x830f20f0
	ctx.lr = 0x830F5FE8;
	sub_830F20F0(ctx, base);
	// 830F5FE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F5FEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F5FF0: 997E0004  stb r11, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 830F5FF4: 409A0008  bne cr6, 0x830f5ffc
	if !ctx.cr[6].eq {
	pc = 0x830F5FFC; continue 'dispatch;
	}
	// 830F5FF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F5FFC; continue 'dispatch;
            }
            0x830F5FFC => {
    //   block [0x830F5FFC..0x830F6054)
	// 830F5FFC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6000: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6004: 419A0064  beq cr6, 0x830f6068
	if ctx.cr[6].eq {
	pc = 0x830F6068; continue 'dispatch;
	}
	// 830F6008: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 830F600C: 817FBBDC  lwz r11, -0x4424(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17444 as u32) ) } as u64;
	// 830F6010: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6014: 409A004C  bne cr6, 0x830f6060
	if !ctx.cr[6].eq {
	pc = 0x830F6060; continue 'dispatch;
	}
	// 830F6018: 4BAAC4E9  bl 0x82ba2500
	ctx.lr = 0x830F601C;
	sub_82BA2500(ctx, base);
	// 830F601C: 546B07FF  clrlwi. r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6020: 41820034  beq 0x830f6054
	if ctx.cr[0].eq {
	pc = 0x830F6054; continue 'dispatch;
	}
	// 830F6024: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F6028: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F602C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F6030: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F6034: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F6038: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F603C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F6040: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6044: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6048: 4B189369  bl 0x8227f3b0
	ctx.lr = 0x830F604C;
	sub_8227F3B0(ctx, base);
	// 830F604C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F6050: 997E0004  stb r11, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	pc = 0x830F6054; continue 'dispatch;
            }
            0x830F6054 => {
    //   block [0x830F6054..0x830F6060)
	// 830F6054: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6058: 4BAAC271  bl 0x82ba22c8
	ctx.lr = 0x830F605C;
	sub_82BA22C8(ctx, base);
	// 830F605C: 817FBBDC  lwz r11, -0x4424(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17444 as u32) ) } as u64;
	pc = 0x830F6060; continue 'dispatch;
            }
            0x830F6060 => {
    //   block [0x830F6060..0x830F6068)
	// 830F6060: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F6064: 917FBBDC  stw r11, -0x4424(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-17444 as u32), ctx.r[11].u32 ) };
	pc = 0x830F6068; continue 'dispatch;
            }
            0x830F6068 => {
    //   block [0x830F6068..0x830F6084)
	// 830F6068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F606C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6078: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F607C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6088 size=120
    let mut pc: u32 = 0x830F6088;
    'dispatch: loop {
        match pc {
            0x830F6088 => {
    //   block [0x830F6088..0x830F60B8)
	// 830F6088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F608C: 4BBB3381  bl 0x82ca940c
	ctx.lr = 0x830F6090;
	sub_82CA93D0(ctx, base);
	// 830F6090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6094: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F6098: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F609C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F60A0: 419A0050  beq cr6, 0x830f60f0
	if ctx.cr[6].eq {
	pc = 0x830F60F0; continue 'dispatch;
	}
	// 830F60A4: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 830F60A8: 817FBBDC  lwz r11, -0x4424(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17444 as u32) ) } as u64;
	// 830F60AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F60B0: 41990008  bgt cr6, 0x830f60b8
	if ctx.cr[6].gt {
	pc = 0x830F60B8; continue 'dispatch;
	}
	// 830F60B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F60B8; continue 'dispatch;
            }
            0x830F60B8 => {
    //   block [0x830F60B8..0x830F60C4)
	// 830F60B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F60BC: 409A0008  bne cr6, 0x830f60c4
	if !ctx.cr[6].eq {
	pc = 0x830F60C4; continue 'dispatch;
	}
	// 830F60C0: 4BAAC2A1  bl 0x82ba2360
	ctx.lr = 0x830F60C4;
	sub_82BA2360(ctx, base);
	pc = 0x830F60C4; continue 'dispatch;
            }
            0x830F60C4 => {
    //   block [0x830F60C4..0x830F60E4)
	// 830F60C4: 4B128C45  bl 0x8221ed08
	ctx.lr = 0x830F60C8;
	sub_8221ED08(ctx, base);
	// 830F60C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F60CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F60D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F60D4: 4BAAC1ED  bl 0x82ba22c0
	ctx.lr = 0x830F60D8;
	sub_82BA22C0(ctx, base);
	// 830F60D8: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F60DC: 419A0008  beq cr6, 0x830f60e4
	if ctx.cr[6].eq {
	pc = 0x830F60E4; continue 'dispatch;
	}
	// 830F60E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x830F60E4; continue 'dispatch;
            }
            0x830F60E4 => {
    //   block [0x830F60E4..0x830F60F0)
	// 830F60E4: 817FBBDC  lwz r11, -0x4424(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17444 as u32) ) } as u64;
	// 830F60E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F60EC: 917FBBDC  stw r11, -0x4424(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-17444 as u32), ctx.r[11].u32 ) };
	pc = 0x830F60F0; continue 'dispatch;
            }
            0x830F60F0 => {
    //   block [0x830F60F0..0x830F6100)
	// 830F60F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F60F4: 4BFFBEAD  bl 0x830f1fa0
	ctx.lr = 0x830F60F8;
	sub_830F1FA0(ctx, base);
	// 830F60F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F60FC: 4BBB3360  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6100 size=80
    let mut pc: u32 = 0x830F6100;
    'dispatch: loop {
        match pc {
            0x830F6100 => {
    //   block [0x830F6100..0x830F610C)
	// 830F6100: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830F6104: 41990044  bgt cr6, 0x830f6148
	if ctx.cr[6].gt {
	pc = 0x830F6148; continue 'dispatch;
	}
	// 830F6108: 546A043E  clrlwi r10, r3, 0x10
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	pc = 0x830F610C; continue 'dispatch;
            }
            0x830F610C => {
    //   block [0x830F610C..0x830F6130)
	// 830F610C: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 830F6110: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 830F6114: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F6118: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830F611C: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6120: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830F6124: 4098000C  bge cr6, 0x830f6130
	if !ctx.cr[6].lt {
	pc = 0x830F6130; continue 'dispatch;
	}
	// 830F6128: 38ABFFFC  addi r5, r11, -4
	ctx.r[5].s64 = ctx.r[11].s64 + -4;
	// 830F612C: 48000014  b 0x830f6140
	pc = 0x830F6140; continue 'dispatch;
            }
            0x830F6130 => {
    //   block [0x830F6130..0x830F6140)
	// 830F6130: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830F6134: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830F6138: 40990018  ble cr6, 0x830f6150
	if !ctx.cr[6].gt {
		sub_830F6150(ctx, base);
		return;
	}
	// 830F613C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	pc = 0x830F6140; continue 'dispatch;
            }
            0x830F6140 => {
    //   block [0x830F6140..0x830F6148)
	// 830F6140: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830F6144: 4099FFC8  ble cr6, 0x830f610c
	if !ctx.cr[6].gt {
	pc = 0x830F610C; continue 'dispatch;
	}
	pc = 0x830F6148; continue 'dispatch;
            }
            0x830F6148 => {
    //   block [0x830F6148..0x830F6150)
	// 830F6148: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F614C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6150 size=8
    let mut pc: u32 = 0x830F6150;
    'dispatch: loop {
        match pc {
            0x830F6150 => {
    //   block [0x830F6150..0x830F6158)
	// 830F6150: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F6154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6158 size=16
    let mut pc: u32 = 0x830F6158;
    'dispatch: loop {
        match pc {
            0x830F6158 => {
    //   block [0x830F6158..0x830F6168)
	// 830F6158: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F615C: 388B1FA0  addi r4, r11, 0x1fa0
	ctx.r[4].s64 = ctx.r[11].s64 + 8096;
	// 830F6160: 38A40324  addi r5, r4, 0x324
	ctx.r[5].s64 = ctx.r[4].s64 + 804;
	// 830F6164: 4BFFFF9C  b 0x830f6100
	sub_830F6100(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6168 size=16
    let mut pc: u32 = 0x830F6168;
    'dispatch: loop {
        match pc {
            0x830F6168 => {
    //   block [0x830F6168..0x830F6178)
	// 830F6168: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F616C: 388B22C8  addi r4, r11, 0x22c8
	ctx.r[4].s64 = ctx.r[11].s64 + 8904;
	// 830F6170: 38A40178  addi r5, r4, 0x178
	ctx.r[5].s64 = ctx.r[4].s64 + 376;
	// 830F6174: 4BFFFF8C  b 0x830f6100
	sub_830F6100(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6178 size=16
    let mut pc: u32 = 0x830F6178;
    'dispatch: loop {
        match pc {
            0x830F6178 => {
    //   block [0x830F6178..0x830F6188)
	// 830F6178: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F617C: 388B2444  addi r4, r11, 0x2444
	ctx.r[4].s64 = ctx.r[11].s64 + 9284;
	// 830F6180: 38A40038  addi r5, r4, 0x38
	ctx.r[5].s64 = ctx.r[4].s64 + 56;
	// 830F6184: 4BFFFF7C  b 0x830f6100
	sub_830F6100(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6188 size=16
    let mut pc: u32 = 0x830F6188;
    'dispatch: loop {
        match pc {
            0x830F6188 => {
    //   block [0x830F6188..0x830F6198)
	// 830F6188: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F618C: 388B2480  addi r4, r11, 0x2480
	ctx.r[4].s64 = ctx.r[11].s64 + 9344;
	// 830F6190: 38A40028  addi r5, r4, 0x28
	ctx.r[5].s64 = ctx.r[4].s64 + 40;
	// 830F6194: 4BFFFF6C  b 0x830f6100
	sub_830F6100(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6198 size=148
    let mut pc: u32 = 0x830F6198;
    'dispatch: loop {
        match pc {
            0x830F6198 => {
    //   block [0x830F6198..0x830F61C4)
	// 830F6198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F619C: 4BBB326D  bl 0x82ca9408
	ctx.lr = 0x830F61A0;
	sub_82CA93D0(ctx, base);
	// 830F61A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F61A4: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 830F61A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F61AC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830F61B0: 3BEB24AC  addi r31, r11, 0x24ac
	ctx.r[31].s64 = ctx.r[11].s64 + 9388;
	// 830F61B4: 83CA24E8  lwz r30, 0x24e8(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9448 as u32) ) } as u64;
	// 830F61B8: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F61BC: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F61C0: 4182004C  beq 0x830f620c
	if ctx.cr[0].eq {
	pc = 0x830F620C; continue 'dispatch;
	}
	pc = 0x830F61C4; continue 'dispatch;
            }
            0x830F61C4 => {
    //   block [0x830F61C4..0x830F61EC)
	// 830F61C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F61C8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F61CC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F61D0: 4BFFC621  bl 0x830f27f0
	ctx.lr = 0x830F61D4;
	sub_830F27F0(ctx, base);
	// 830F61D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F61D8: 41820014  beq 0x830f61ec
	if ctx.cr[0].eq {
	pc = 0x830F61EC; continue 'dispatch;
	}
	// 830F61DC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F61E0: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830F61E4: 4082FFE0  bne 0x830f61c4
	if !ctx.cr[0].eq {
	pc = 0x830F61C4; continue 'dispatch;
	}
	// 830F61E8: 48000024  b 0x830f620c
	pc = 0x830F620C; continue 'dispatch;
            }
            0x830F61EC => {
    //   block [0x830F61EC..0x830F6208)
	// 830F61EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F61F0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F61F4: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F61F8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F61FC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F6200: A07F0008  lhz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6204: 48000020  b 0x830f6224
	pc = 0x830F6224; continue 'dispatch;
            }
            0x830F6208 => {
    //   block [0x830F6208..0x830F620C)
	// 830F6208: 3B9C0002  addi r28, r28, 2
	ctx.r[28].s64 = ctx.r[28].s64 + 2;
	pc = 0x830F620C; continue 'dispatch;
            }
            0x830F620C => {
    //   block [0x830F620C..0x830F6224)
	// 830F620C: A17C0000  lhz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6210: 2B0B003B  cmplwi cr6, r11, 0x3b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 59 as u32, &mut ctx.xer);
	// 830F6214: 409AFFF4  bne cr6, 0x830f6208
	if !ctx.cr[6].eq {
	pc = 0x830F6208; continue 'dispatch;
	}
	// 830F6218: 397C0002  addi r11, r28, 2
	ctx.r[11].s64 = ctx.r[28].s64 + 2;
	// 830F621C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 830F6220: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x830F6224; continue 'dispatch;
            }
            0x830F6224 => {
    //   block [0x830F6224..0x830F622C)
	// 830F6224: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F6228: 4BBB3230  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6230 size=136
    let mut pc: u32 = 0x830F6230;
    'dispatch: loop {
        match pc {
            0x830F6230 => {
    //   block [0x830F6230..0x830F6264)
	// 830F6230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6234: 4BBB31D1  bl 0x82ca9404
	ctx.lr = 0x830F6238;
	sub_82CA93D0(ctx, base);
	// 830F6238: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F623C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830F6240: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F6244: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F6248: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F624C: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 830F6250: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830F6254: 4BFFC6BD  bl 0x830f2910
	ctx.lr = 0x830F6258;
	sub_830F2910(ctx, base);
	// 830F6258: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F625C: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6260: 419A0044  beq cr6, 0x830f62a4
	if ctx.cr[6].eq {
	pc = 0x830F62A4; continue 'dispatch;
	}
	pc = 0x830F6264; continue 'dispatch;
            }
            0x830F6264 => {
    //   block [0x830F6264..0x830F628C)
	// 830F6264: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6268: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 830F626C: 409A0020  bne cr6, 0x830f628c
	if !ctx.cr[6].eq {
	pc = 0x830F628C; continue 'dispatch;
	}
	// 830F6270: 576A063F  clrlwi. r10, r27, 0x18
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F6274: 41820018  beq 0x830f628c
	if ctx.cr[0].eq {
	pc = 0x830F628C; continue 'dispatch;
	}
	// 830F6278: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 830F627C: 4BFFFF1D  bl 0x830f6198
	ctx.lr = 0x830F6280;
	sub_830F6198(ctx, base);
	// 830F6280: 83A1009C  lwz r29, 0x9c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 830F6284: B07E0000  sth r3, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u16 ) };
	// 830F6288: 48000010  b 0x830f6298
	pc = 0x830F6298; continue 'dispatch;
            }
            0x830F628C => {
    //   block [0x830F628C..0x830F6298)
	// 830F628C: 3BBD0002  addi r29, r29, 2
	ctx.r[29].s64 = ctx.r[29].s64 + 2;
	// 830F6290: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830F6294: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	pc = 0x830F6298; continue 'dispatch;
            }
            0x830F6298 => {
    //   block [0x830F6298..0x830F62A4)
	// 830F6298: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F629C: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 830F62A0: 4082FFC4  bne 0x830f6264
	if !ctx.cr[0].eq {
	pc = 0x830F6264; continue 'dispatch;
	}
	pc = 0x830F62A4; continue 'dispatch;
            }
            0x830F62A4 => {
    //   block [0x830F62A4..0x830F62B8)
	// 830F62A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F62A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F62AC: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830F62B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F62B4: 4BBB31A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F62B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F62B8 size=180
    let mut pc: u32 = 0x830F62B8;
    'dispatch: loop {
        match pc {
            0x830F62B8 => {
    //   block [0x830F62B8..0x830F62E0)
	// 830F62B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F62BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F62C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F62C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F62C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F62CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F62D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F62D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F62D8: 409A0020  bne cr6, 0x830f62f8
	if !ctx.cr[6].eq {
	pc = 0x830F62F8; continue 'dispatch;
	}
	// 830F62DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F62E0; continue 'dispatch;
            }
            0x830F62E0 => {
    //   block [0x830F62E0..0x830F62F8)
	// 830F62E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F62E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F62E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F62EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F62F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F62F4: 4E800020  blr
	return;
            }
            0x830F62F8 => {
    //   block [0x830F62F8..0x830F6318)
	// 830F62F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F62FC: 481C3669  bl 0x832b9964
	ctx.lr = 0x830F6300;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830F6300: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F6304: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F6308: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830F630C: 419A0028  beq cr6, 0x830f6334
	if ctx.cr[6].eq {
	pc = 0x830F6334; continue 'dispatch;
	}
	// 830F6310: 811E001C  lwz r8, 0x1c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F6314: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x830F6318; continue 'dispatch;
            }
            0x830F6318 => {
    //   block [0x830F6318..0x830F6334)
	// 830F6318: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F631C: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830F6320: 419A001C  beq cr6, 0x830f633c
	if ctx.cr[6].eq {
	pc = 0x830F633C; continue 'dispatch;
	}
	// 830F6324: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F6328: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830F632C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830F6330: 4198FFE8  blt cr6, 0x830f6318
	if ctx.cr[6].lt {
	pc = 0x830F6318; continue 'dispatch;
	}
	pc = 0x830F6334; continue 'dispatch;
            }
            0x830F6334 => {
    //   block [0x830F6334..0x830F633C)
	// 830F6334: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F6338: 48000024  b 0x830f635c
	pc = 0x830F635C; continue 'dispatch;
            }
            0x830F633C => {
    //   block [0x830F633C..0x830F635C)
	// 830F633C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F6340: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F6344: 7C6B402E  lwzx r3, r11, r8
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830F6348: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F634C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6350: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6354: 4E800421  bctrl
	ctx.lr = 0x830F6358;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F6358: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
            }
            0x830F635C => {
    //   block [0x830F635C..0x830F636C)
	// 830F635C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6360: 481C35F5  bl 0x832b9954
	ctx.lr = 0x830F6364;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830F6364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6368: 4BFFFF78  b 0x830f62e0
	pc = 0x830F62E0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6370 size=104
    let mut pc: u32 = 0x830F6370;
    'dispatch: loop {
        match pc {
            0x830F6370 => {
    //   block [0x830F6370..0x830F6398)
	// 830F6370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6374: 4BBB3099  bl 0x82ca940c
	ctx.lr = 0x830F6378;
	sub_82CA93D0(ctx, base);
	// 830F6378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F637C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6380: 481C35E5  bl 0x832b9964
	ctx.lr = 0x830F6384;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830F6384: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F6388: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F638C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F6390: 40990038  ble cr6, 0x830f63c8
	if !ctx.cr[6].gt {
	pc = 0x830F63C8; continue 'dispatch;
	}
	// 830F6394: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830F6398; continue 'dispatch;
            }
            0x830F6398 => {
    //   block [0x830F6398..0x830F63C8)
	// 830F6398: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F639C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F63A0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F63A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F63A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F63AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F63B0: 4E800421  bctrl
	ctx.lr = 0x830F63B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F63B4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F63B8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F63BC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F63C0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F63C4: 4198FFD4  blt cr6, 0x830f6398
	if ctx.cr[6].lt {
	pc = 0x830F6398; continue 'dispatch;
	}
            }
            0x830F63C8 => {
    //   block [0x830F63C8..0x830F63D8)
	// 830F63C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F63CC: 481C3589  bl 0x832b9954
	ctx.lr = 0x830F63D0;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830F63D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F63D4: 4BBB3088  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F63D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F63D8 size=136
    let mut pc: u32 = 0x830F63D8;
    'dispatch: loop {
        match pc {
            0x830F63D8 => {
    //   block [0x830F63D8..0x830F6430)
	// 830F63D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F63DC: 4BBB3031  bl 0x82ca940c
	ctx.lr = 0x830F63E0;
	sub_82CA93D0(ctx, base);
	// 830F63E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F63E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F63E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F63EC: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 830F63F0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 830F63F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F63F8: 4BE05409  bl 0x82efb800
	ctx.lr = 0x830F63FC;
	sub_82EFB800(ctx, base);
	// 830F63FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F6400: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F6404: 396BB0E4  addi r11, r11, -0x4f1c
	ctx.r[11].s64 = ctx.r[11].s64 + -20252;
	// 830F6408: 394AB0D0  addi r10, r10, -0x4f30
	ctx.r[10].s64 = ctx.r[10].s64 + -20272;
	// 830F640C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F6410: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F6414: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 830F6418: 419A0018  beq cr6, 0x830f6430
	if ctx.cr[6].eq {
	pc = 0x830F6430; continue 'dispatch;
	}
	// 830F641C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6424: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F642C: 4E800421  bctrl
	ctx.lr = 0x830F6430;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F6430 => {
    //   block [0x830F6430..0x830F6450)
	// 830F6430: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 830F6434: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F6438: 419A0018  beq cr6, 0x830f6450
	if ctx.cr[6].eq {
	pc = 0x830F6450; continue 'dispatch;
	}
	// 830F643C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6440: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6444: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F644C: 4E800421  bctrl
	ctx.lr = 0x830F6450;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F6450 => {
    //   block [0x830F6450..0x830F6460)
	// 830F6450: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 830F6454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6458: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F645C: 4BBB3000  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6460 size=8
    let mut pc: u32 = 0x830F6460;
    'dispatch: loop {
        match pc {
            0x830F6460 => {
    //   block [0x830F6460..0x830F6468)
	// 830F6460: 3863FFEC  addi r3, r3, -0x14
	ctx.r[3].s64 = ctx.r[3].s64 + -20;
	// 830F6464: 480008A4  b 0x830f6d08
	sub_830F6D08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6468 size=112
    let mut pc: u32 = 0x830F6468;
    'dispatch: loop {
        match pc {
            0x830F6468 => {
    //   block [0x830F6468..0x830F6494)
	// 830F6468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F646C: 4BBB2FA1  bl 0x82ca940c
	ctx.lr = 0x830F6470;
	sub_82CA93D0(ctx, base);
	// 830F6470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6478: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F647C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6480: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6484: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F6488: 409A000C  bne cr6, 0x830f6494
	if !ctx.cr[6].eq {
	pc = 0x830F6494; continue 'dispatch;
	}
	// 830F648C: 4BE4601D  bl 0x82f3c4a8
	ctx.lr = 0x830F6490;
	sub_82F3C4A8(ctx, base);
	// 830F6490: 48000040  b 0x830f64d0
	pc = 0x830F64D0; continue 'dispatch;
            }
            0x830F6494 => {
    //   block [0x830F6494..0x830F64D0)
	// 830F6494: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6498: 57BE103A  slwi r30, r29, 2
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F649C: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830F64A0: 4BE25439  bl 0x82f1b8d8
	ctx.lr = 0x830F64A4;
	sub_82F1B8D8(ctx, base);
	// 830F64A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F64A8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F64AC: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 830F64B0: 7C7E5214  add r3, r30, r10
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 830F64B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F64B8: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 830F64BC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830F64C0: 4BBBA671  bl 0x82cb0b30
	ctx.lr = 0x830F64C4;
	sub_82CB0B30(ctx, base);
	// 830F64C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F64C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F64CC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830F64D0; continue 'dispatch;
            }
            0x830F64D0 => {
    //   block [0x830F64D0..0x830F64D8)
	// 830F64D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F64D4: 4BBB2F88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F64D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F64D8 size=84
    let mut pc: u32 = 0x830F64D8;
    'dispatch: loop {
        match pc {
            0x830F64D8 => {
    //   block [0x830F64D8..0x830F6524)
	// 830F64D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F64DC: 4BBB2F31  bl 0x82ca940c
	ctx.lr = 0x830F64E0;
	sub_82CA93D0(ctx, base);
	// 830F64E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F64E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F64E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F64EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F64F0: 419A0034  beq cr6, 0x830f6524
	if ctx.cr[6].eq {
	pc = 0x830F6524; continue 'dispatch;
	}
	// 830F64F4: 481C3471  bl 0x832b9964
	ctx.lr = 0x830F64F8;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830F64F8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F64FC: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 830F6500: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 830F6504: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F6508: 4BE25499  bl 0x82f1b9a0
	ctx.lr = 0x830F650C;
	sub_82F1B9A0(ctx, base);
	// 830F650C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F6510: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F6514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6518: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F651C: 93ABFFFC  stw r29, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[29].u32 ) };
	// 830F6520: 481C3435  bl 0x832b9954
	ctx.lr = 0x830F6524;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x830F6524; continue 'dispatch;
            }
            0x830F6524 => {
    //   block [0x830F6524..0x830F652C)
	// 830F6524: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6528: 4BBB2F34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6530 size=252
    let mut pc: u32 = 0x830F6530;
    'dispatch: loop {
        match pc {
            0x830F6530 => {
    //   block [0x830F6530..0x830F6550)
	// 830F6530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6534: 4BBB2ED9  bl 0x82ca940c
	ctx.lr = 0x830F6538;
	sub_82CA93D0(ctx, base);
	// 830F6538: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F653C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6540: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F6544: 897F0054  lbz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F6548: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F654C: 4182000C  beq 0x830f6558
	if ctx.cr[0].eq {
	pc = 0x830F6558; continue 'dispatch;
	}
	pc = 0x830F6550; continue 'dispatch;
            }
            0x830F6550 => {
    //   block [0x830F6550..0x830F6558)
	// 830F6550: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F6554: 480000D0  b 0x830f6624
	pc = 0x830F6624; continue 'dispatch;
            }
            0x830F6558 => {
    //   block [0x830F6558..0x830F6580)
	// 830F6558: 3BBF0034  addi r29, r31, 0x34
	ctx.r[29].s64 = ctx.r[31].s64 + 52;
	// 830F655C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6560: 481C3405  bl 0x832b9964
	ctx.lr = 0x830F6564;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830F6564: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F6568: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F656C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830F6570: 419A0030  beq cr6, 0x830f65a0
	if ctx.cr[6].eq {
	pc = 0x830F65A0; continue 'dispatch;
	}
	// 830F6574: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F6578: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F657C: 5508021E  rlwinm r8, r8, 0, 8, 0xf
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x830F6580; continue 'dispatch;
            }
            0x830F6580 => {
    //   block [0x830F6580..0x830F65A0)
	// 830F6580: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6584: 80E70040  lwz r7, 0x40(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
	// 830F6588: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 830F658C: 419A0014  beq cr6, 0x830f65a0
	if ctx.cr[6].eq {
	pc = 0x830F65A0; continue 'dispatch;
	}
	// 830F6590: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F6594: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F6598: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830F659C: 4198FFE4  blt cr6, 0x830f6580
	if ctx.cr[6].lt {
	pc = 0x830F6580; continue 'dispatch;
	}
	pc = 0x830F65A0; continue 'dispatch;
            }
            0x830F65A0 => {
    //   block [0x830F65A0..0x830F65B4)
	// 830F65A0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830F65A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F65A8: 409A000C  bne cr6, 0x830f65b4
	if !ctx.cr[6].eq {
	pc = 0x830F65B4; continue 'dispatch;
	}
	// 830F65AC: 481C33A9  bl 0x832b9954
	ctx.lr = 0x830F65B0;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830F65B0: 4BFFFFA0  b 0x830f6550
	pc = 0x830F6550; continue 'dispatch;
            }
            0x830F65B4 => {
    //   block [0x830F65B4..0x830F65E0)
	// 830F65B4: 481C33A1  bl 0x832b9954
	ctx.lr = 0x830F65B8;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830F65B8: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	// 830F65BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F65C0: 4BE04599  bl 0x82efab58
	ctx.lr = 0x830F65C4;
	sub_82EFAB58(ctx, base);
	// 830F65C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F65C8: 419A0018  beq cr6, 0x830f65e0
	if ctx.cr[6].eq {
	pc = 0x830F65E0; continue 'dispatch;
	}
	// 830F65CC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F65D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F65D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F65D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F65DC: 4E800421  bctrl
	ctx.lr = 0x830F65E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F65E0 => {
    //   block [0x830F65E0..0x830F6610)
	// 830F65E0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830F65E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F65E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F65EC: 4BE64395  bl 0x82f5a980
	ctx.lr = 0x830F65F0;
	sub_82F5A980(ctx, base);
	// 830F65F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F65F4: 419A001C  beq cr6, 0x830f6610
	if ctx.cr[6].eq {
	pc = 0x830F6610; continue 'dispatch;
	}
	// 830F65F8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F65FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6604: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6608: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F660C: 4E800421  bctrl
	ctx.lr = 0x830F6610;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F6610 => {
    //   block [0x830F6610..0x830F6624)
	// 830F6610: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 830F6614: 4BE049FD  bl 0x82efb010
	ctx.lr = 0x830F6618;
	sub_82EFB010(ctx, base);
	// 830F6618: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F661C: 4BE05485  bl 0x82efbaa0
	ctx.lr = 0x830F6620;
	sub_82EFBAA0(ctx, base);
	// 830F6620: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830F6624; continue 'dispatch;
            }
            0x830F6624 => {
    //   block [0x830F6624..0x830F662C)
	// 830F6624: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F6628: 4BBB2E34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6630 size=152
    let mut pc: u32 = 0x830F6630;
    'dispatch: loop {
        match pc {
            0x830F6630 => {
    //   block [0x830F6630..0x830F6674)
	// 830F6630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6634: 4BBB2DD5  bl 0x82ca9408
	ctx.lr = 0x830F6638;
	sub_82CA93D0(ctx, base);
	// 830F6638: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F663C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6640: 3B9F0018  addi r28, r31, 0x18
	ctx.r[28].s64 = ctx.r[31].s64 + 24;
	// 830F6644: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F6648: 4BE04511  bl 0x82efab58
	ctx.lr = 0x830F664C;
	sub_82EFAB58(ctx, base);
	// 830F664C: 897F0054  lbz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F6650: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F6654: 40820064  bne 0x830f66b8
	if !ctx.cr[0].eq {
	pc = 0x830F66B8; continue 'dispatch;
	}
	// 830F6658: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F665C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F6660: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F6664: 995F0054  stb r10, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 830F6668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F666C: 40990038  ble cr6, 0x830f66a4
	if !ctx.cr[6].gt {
	pc = 0x830F66A4; continue 'dispatch;
	}
	// 830F6670: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830F6674; continue 'dispatch;
            }
            0x830F6674 => {
    //   block [0x830F6674..0x830F66A4)
	// 830F6674: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6678: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F667C: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F6680: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6684: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F668C: 4E800421  bctrl
	ctx.lr = 0x830F6690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F6690: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6694: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F6698: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F669C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F66A0: 4198FFD4  blt cr6, 0x830f6674
	if ctx.cr[6].lt {
	pc = 0x830F6674; continue 'dispatch;
	}
            }
            0x830F66A4 => {
    //   block [0x830F66A4..0x830F66B8)
	// 830F66A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F66A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F66AC: 4BE45DFD  bl 0x82f3c4a8
	ctx.lr = 0x830F66B0;
	sub_82F3C4A8(ctx, base);
	// 830F66B0: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 830F66B4: 4BE0495D  bl 0x82efb010
	ctx.lr = 0x830F66B8;
	sub_82EFB010(ctx, base);
	pc = 0x830F66B8; continue 'dispatch;
            }
            0x830F66B8 => {
    //   block [0x830F66B8..0x830F66C8)
	// 830F66B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F66BC: 4BE053E5  bl 0x82efbaa0
	ctx.lr = 0x830F66C0;
	sub_82EFBAA0(ctx, base);
	// 830F66C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F66C4: 4BBB2D94  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F66C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F66C8 size=188
    let mut pc: u32 = 0x830F66C8;
    'dispatch: loop {
        match pc {
            0x830F66C8 => {
    //   block [0x830F66C8..0x830F66E8)
	// 830F66C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F66CC: 4BBB2D3D  bl 0x82ca9408
	ctx.lr = 0x830F66D0;
	sub_82CA93D0(ctx, base);
	// 830F66D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F66D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F66D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F66DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F66E0: 409A0010  bne cr6, 0x830f66f0
	if !ctx.cr[6].eq {
	pc = 0x830F66F0; continue 'dispatch;
	}
	// 830F66E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F66E8; continue 'dispatch;
            }
            0x830F66E8 => {
    //   block [0x830F66E8..0x830F66F0)
	// 830F66E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F66EC: 4BBB2D6C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x830F66F0 => {
    //   block [0x830F66F0..0x830F6714)
	// 830F66F0: 3B9F0018  addi r28, r31, 0x18
	ctx.r[28].s64 = ctx.r[31].s64 + 24;
	// 830F66F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F66F8: 4BE04461  bl 0x82efab58
	ctx.lr = 0x830F66FC;
	sub_82EFAB58(ctx, base);
	// 830F66FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6700: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F6704: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F6708: 419A0028  beq cr6, 0x830f6730
	if ctx.cr[6].eq {
	pc = 0x830F6730; continue 'dispatch;
	}
	// 830F670C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6710: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x830F6714; continue 'dispatch;
            }
            0x830F6714 => {
    //   block [0x830F6714..0x830F6730)
	// 830F6714: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6718: 7F08E840  cmplw cr6, r8, r29
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830F671C: 419A002C  beq cr6, 0x830f6748
	if ctx.cr[6].eq {
	pc = 0x830F6748; continue 'dispatch;
	}
	// 830F6720: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F6724: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F6728: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F672C: 4198FFE8  blt cr6, 0x830f6714
	if ctx.cr[6].lt {
	pc = 0x830F6714; continue 'dispatch;
	}
	pc = 0x830F6730; continue 'dispatch;
            }
            0x830F6730 => {
    //   block [0x830F6730..0x830F6748)
	// 830F6730: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F6734: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F6738: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 830F673C: 4BFFFB7D  bl 0x830f62b8
	ctx.lr = 0x830F6740;
	sub_830F62B8(ctx, base);
	// 830F6740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6744: 48000030  b 0x830f6774
	pc = 0x830F6774; continue 'dispatch;
            }
            0x830F6748 => {
    //   block [0x830F6748..0x830F6774)
	// 830F6748: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F674C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6750: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830F6754: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6758: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F675C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6760: 4E800421  bctrl
	ctx.lr = 0x830F6764;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F6764: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F6768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F676C: 4BFFFCFD  bl 0x830f6468
	ctx.lr = 0x830F6770;
	sub_830F6468(ctx, base);
	// 830F6770: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
            }
            0x830F6774 => {
    //   block [0x830F6774..0x830F6784)
	// 830F6774: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F6778: 4BE05329  bl 0x82efbaa0
	ctx.lr = 0x830F677C;
	sub_82EFBAA0(ctx, base);
	// 830F677C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6780: 4BFFFF68  b 0x830f66e8
	pc = 0x830F66E8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6788 size=224
    let mut pc: u32 = 0x830F6788;
    'dispatch: loop {
        match pc {
            0x830F6788 => {
    //   block [0x830F6788..0x830F67C0)
	// 830F6788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F678C: 4BBB2C81  bl 0x82ca940c
	ctx.lr = 0x830F6790;
	sub_82CA93D0(ctx, base);
	// 830F6790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6794: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F6798: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F679C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F67A0: 419A00BC  beq cr6, 0x830f685c
	if ctx.cr[6].eq {
	pc = 0x830F685C; continue 'dispatch;
	}
	// 830F67A4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F67A8: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F67AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F67B0: 419A0018  beq cr6, 0x830f67c8
	if ctx.cr[6].eq {
	pc = 0x830F67C8; continue 'dispatch;
	}
	// 830F67B4: 4BFFFD7D  bl 0x830f6530
	ctx.lr = 0x830F67B8;
	sub_830F6530(ctx, base);
	// 830F67B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F67BC: 4182000C  beq 0x830f67c8
	if ctx.cr[0].eq {
	pc = 0x830F67C8; continue 'dispatch;
	}
	pc = 0x830F67C0; continue 'dispatch;
            }
            0x830F67C0 => {
    //   block [0x830F67C0..0x830F67C8)
	// 830F67C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F67C4: 4800009C  b 0x830f6860
	pc = 0x830F6860; continue 'dispatch;
            }
            0x830F67C8 => {
    //   block [0x830F67C8..0x830F680C)
	// 830F67C8: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 830F67CC: 4BE07095  bl 0x82efd860
	ctx.lr = 0x830F67D0;
	sub_82EFD860(ctx, base);
	// 830F67D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F67D4: 41820038  beq 0x830f680c
	if ctx.cr[0].eq {
	pc = 0x830F680C; continue 'dispatch;
	}
	// 830F67D8: 3D605647  lis r11, 0x5647
	ctx.r[11].s64 = 1447493632;
	// 830F67DC: 3D409FE1  lis r10, -0x601f
	ctx.r[10].s64 = -1612644352;
	// 830F67E0: 616B1E89  ori r11, r11, 0x1e89
	ctx.r[11].u64 = ctx.r[11].u64 | 7817;
	// 830F67E4: 614A234A  ori r10, r10, 0x234a
	ctx.r[10].u64 = ctx.r[10].u64 | 9034;
	// 830F67E8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F67EC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 830F67F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F67F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F67F8: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F67FC: 80BE0014  lwz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F6800: 4BFFFBD9  bl 0x830f63d8
	ctx.lr = 0x830F6804;
	sub_830F63D8(ctx, base);
	// 830F6804: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6808: 48000008  b 0x830f6810
	pc = 0x830F6810; continue 'dispatch;
            }
            0x830F680C => {
    //   block [0x830F680C..0x830F6810)
	// 830F680C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x830F6810; continue 'dispatch;
            }
            0x830F6810 => {
    //   block [0x830F6810..0x830F685C)
	// 830F6810: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F6814: 419A0048  beq cr6, 0x830f685c
	if ctx.cr[6].eq {
	pc = 0x830F685C; continue 'dispatch;
	}
	// 830F6818: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F681C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F6820: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 830F6824: 4BFFFCB5  bl 0x830f64d8
	ctx.lr = 0x830F6828;
	sub_830F64D8(ctx, base);
	// 830F6828: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F682C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F6830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6834: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F6838: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F683C: 4E800421  bctrl
	ctx.lr = 0x830F6840;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F6840: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6844: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F684C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6854: 4E800421  bctrl
	ctx.lr = 0x830F6858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F6858: 4BFFFF68  b 0x830f67c0
	pc = 0x830F67C0; continue 'dispatch;
            }
            0x830F685C => {
    //   block [0x830F685C..0x830F6860)
	// 830F685C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F6860; continue 'dispatch;
            }
            0x830F6860 => {
    //   block [0x830F6860..0x830F6868)
	// 830F6860: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6864: 4BBB2BF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6868 size=156
    let mut pc: u32 = 0x830F6868;
    'dispatch: loop {
        match pc {
            0x830F6868 => {
    //   block [0x830F6868..0x830F6890)
	// 830F6868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F686C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F6874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F687C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F6880: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F6884: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F6888: 409A0020  bne cr6, 0x830f68a8
	if !ctx.cr[6].eq {
	pc = 0x830F68A8; continue 'dispatch;
	}
	// 830F688C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F6890; continue 'dispatch;
            }
            0x830F6890 => {
    //   block [0x830F6890..0x830F68A8)
	// 830F6890: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F689C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F68A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F68A4: 4E800020  blr
	return;
            }
            0x830F68A8 => {
    //   block [0x830F68A8..0x830F68C8)
	// 830F68A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F68AC: 481C30B9  bl 0x832b9964
	ctx.lr = 0x830F68B0;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830F68B0: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F68B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F68B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F68BC: 419A0028  beq cr6, 0x830f68e4
	if ctx.cr[6].eq {
	pc = 0x830F68E4; continue 'dispatch;
	}
	// 830F68C0: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F68C4: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	pc = 0x830F68C8; continue 'dispatch;
            }
            0x830F68C8 => {
    //   block [0x830F68C8..0x830F68E4)
	// 830F68C8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F68CC: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830F68D0: 419A001C  beq cr6, 0x830f68ec
	if ctx.cr[6].eq {
	pc = 0x830F68EC; continue 'dispatch;
	}
	// 830F68D4: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 830F68D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F68DC: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F68E0: 4198FFE8  blt cr6, 0x830f68c8
	if ctx.cr[6].lt {
	pc = 0x830F68C8; continue 'dispatch;
	}
	pc = 0x830F68E4; continue 'dispatch;
            }
            0x830F68E4 => {
    //   block [0x830F68E4..0x830F68EC)
	// 830F68E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F68E8: 4800000C  b 0x830f68f4
	pc = 0x830F68F4; continue 'dispatch;
            }
            0x830F68EC => {
    //   block [0x830F68EC..0x830F68F4)
	// 830F68EC: 4BE29F3D  bl 0x82f20828
	ctx.lr = 0x830F68F0;
	sub_82F20828(ctx, base);
	// 830F68F0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x830F68F4; continue 'dispatch;
            }
            0x830F68F4 => {
    //   block [0x830F68F4..0x830F6904)
	// 830F68F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F68F8: 481C305D  bl 0x832b9954
	ctx.lr = 0x830F68FC;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830F68FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6900: 4BFFFF90  b 0x830f6890
	pc = 0x830F6890; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6908 size=128
    let mut pc: u32 = 0x830F6908;
    'dispatch: loop {
        match pc {
            0x830F6908 => {
    //   block [0x830F6908..0x830F6968)
	// 830F6908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F690C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6914: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F691C: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6920: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F6924: 419A004C  beq cr6, 0x830f6970
	if ctx.cr[6].eq {
	pc = 0x830F6970; continue 'dispatch;
	}
	// 830F6928: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F692C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6934: 4E800421  bctrl
	ctx.lr = 0x830F6938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F6938: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830F693C: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6940: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 830F6944: 4BFFFF25  bl 0x830f6868
	ctx.lr = 0x830F6948;
	sub_830F6868(ctx, base);
	// 830F6948: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F694C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6950: 419A0018  beq cr6, 0x830f6968
	if ctx.cr[6].eq {
	pc = 0x830F6968; continue 'dispatch;
	}
	// 830F6954: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6958: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F695C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6964: 4E800421  bctrl
	ctx.lr = 0x830F6968;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F6968 => {
    //   block [0x830F6968..0x830F6970)
	// 830F6968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F696C: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	pc = 0x830F6970; continue 'dispatch;
            }
            0x830F6970 => {
    //   block [0x830F6970..0x830F6988)
	// 830F6970: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F6974: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F6978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F697C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6988 size=120
    let mut pc: u32 = 0x830F6988;
    'dispatch: loop {
        match pc {
            0x830F6988 => {
    //   block [0x830F6988..0x830F69C0)
	// 830F6988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F698C: 4BBB2A81  bl 0x82ca940c
	ctx.lr = 0x830F6990;
	sub_82CA93D0(ctx, base);
	// 830F6990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6998: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F699C: 3BBF0034  addi r29, r31, 0x34
	ctx.r[29].s64 = ctx.r[31].s64 + 52;
	// 830F69A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F69A4: 481C2FC1  bl 0x832b9964
	ctx.lr = 0x830F69A8;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830F69A8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F69AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F69B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F69B4: 419A0028  beq cr6, 0x830f69dc
	if ctx.cr[6].eq {
	pc = 0x830F69DC; continue 'dispatch;
	}
	// 830F69B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F69BC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	pc = 0x830F69C0; continue 'dispatch;
            }
            0x830F69C0 => {
    //   block [0x830F69C0..0x830F69DC)
	// 830F69C0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F69C4: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830F69C8: 419A001C  beq cr6, 0x830f69e4
	if ctx.cr[6].eq {
	pc = 0x830F69E4; continue 'dispatch;
	}
	// 830F69CC: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 830F69D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F69D4: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F69D8: 4198FFE8  blt cr6, 0x830f69c0
	if ctx.cr[6].lt {
	pc = 0x830F69C0; continue 'dispatch;
	}
	pc = 0x830F69DC; continue 'dispatch;
            }
            0x830F69DC => {
    //   block [0x830F69DC..0x830F69E4)
	// 830F69DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F69E0: 4800000C  b 0x830f69ec
	pc = 0x830F69EC; continue 'dispatch;
            }
            0x830F69E4 => {
    //   block [0x830F69E4..0x830F69EC)
	// 830F69E4: 4BE29E45  bl 0x82f20828
	ctx.lr = 0x830F69E8;
	sub_82F20828(ctx, base);
	// 830F69E8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x830F69EC; continue 'dispatch;
            }
            0x830F69EC => {
    //   block [0x830F69EC..0x830F6A00)
	// 830F69EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F69F0: 481C2F65  bl 0x832b9954
	ctx.lr = 0x830F69F4;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830F69F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F69F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F69FC: 4BBB2A60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6A00 size=140
    let mut pc: u32 = 0x830F6A00;
    'dispatch: loop {
        match pc {
            0x830F6A00 => {
    //   block [0x830F6A00..0x830F6A48)
	// 830F6A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6A08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F6A0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6A14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F6A18: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F6A1C: 396BB108  addi r11, r11, -0x4ef8
	ctx.r[11].s64 = ctx.r[11].s64 + -20216;
	// 830F6A20: 83FE0014  lwz r31, 0x14(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F6A24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F6A28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F6A2C: 419A0034  beq cr6, 0x830f6a60
	if ctx.cr[6].eq {
	pc = 0x830F6A60; continue 'dispatch;
	}
	// 830F6A30: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 830F6A34: 4BFFF93D  bl 0x830f6370
	ctx.lr = 0x830F6A38;
	sub_830F6370(ctx, base);
	// 830F6A38: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6A3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6A40: 419A0008  beq cr6, 0x830f6a48
	if ctx.cr[6].eq {
	pc = 0x830F6A48; continue 'dispatch;
	}
	// 830F6A44: 4BFFFBED  bl 0x830f6630
	ctx.lr = 0x830F6A48;
	sub_830F6630(ctx, base);
	pc = 0x830F6A48; continue 'dispatch;
            }
            0x830F6A48 => {
    //   block [0x830F6A48..0x830F6A60)
	// 830F6A48: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F6A4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6A50: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6A54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6A58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6A5C: 4E800421  bctrl
	ctx.lr = 0x830F6A60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F6A60 => {
    //   block [0x830F6A60..0x830F6A8C)
	// 830F6A60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830F6A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6A68: 396BD140  addi r11, r11, -0x2ec0
	ctx.r[11].s64 = ctx.r[11].s64 + -11968;
	// 830F6A6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F6A70: 4BE06FA9  bl 0x82efda18
	ctx.lr = 0x830F6A74;
	sub_82EFDA18(ctx, base);
	// 830F6A74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6A78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6A7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6A80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F6A84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6A90 size=20
    let mut pc: u32 = 0x830F6A90;
    'dispatch: loop {
        match pc {
            0x830F6A90 => {
    //   block [0x830F6A90..0x830F6AA4)
	// 830F6A90: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F6A94: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6A98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6A9C: 419A0008  beq cr6, 0x830f6aa4
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x830F6AA4);
		return;
	}
	// 830F6AA0: 4BFFFC28  b 0x830f66c8
	sub_830F66C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6AB0 size=64
    let mut pc: u32 = 0x830F6AB0;
    'dispatch: loop {
        match pc {
            0x830F6AB0 => {
    //   block [0x830F6AB0..0x830F6ADC)
	// 830F6AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6AB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6ABC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6AC0: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F6AC4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 830F6AC8: 4BFFF8A9  bl 0x830f6370
	ctx.lr = 0x830F6ACC;
	sub_830F6370(ctx, base);
	// 830F6ACC: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6AD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6AD4: 419A0008  beq cr6, 0x830f6adc
	if ctx.cr[6].eq {
	pc = 0x830F6ADC; continue 'dispatch;
	}
	// 830F6AD8: 4BFFFB59  bl 0x830f6630
	ctx.lr = 0x830F6ADC;
	sub_830F6630(ctx, base);
	pc = 0x830F6ADC; continue 'dispatch;
            }
            0x830F6ADC => {
    //   block [0x830F6ADC..0x830F6AF0)
	// 830F6ADC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F6AE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6AE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6AE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6AEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6AF0 size=80
    let mut pc: u32 = 0x830F6AF0;
    'dispatch: loop {
        match pc {
            0x830F6AF0 => {
    //   block [0x830F6AF0..0x830F6B24)
	// 830F6AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6AF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6AFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6B00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6B04: 4BFFF86D  bl 0x830f6370
	ctx.lr = 0x830F6B08;
	sub_830F6370(ctx, base);
	// 830F6B08: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 830F6B0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6B10: 4BE24E91  bl 0x82f1b9a0
	ctx.lr = 0x830F6B14;
	sub_82F1B9A0(ctx, base);
	// 830F6B14: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F6B18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6B1C: 419A0008  beq cr6, 0x830f6b24
	if ctx.cr[6].eq {
	pc = 0x830F6B24; continue 'dispatch;
	}
	// 830F6B20: 4BE06D81  bl 0x82efd8a0
	ctx.lr = 0x830F6B24;
	sub_82EFD8A0(ctx, base);
	pc = 0x830F6B24; continue 'dispatch;
            }
            0x830F6B24 => {
    //   block [0x830F6B24..0x830F6B40)
	// 830F6B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6B28: 4BE04511  bl 0x82efb038
	ctx.lr = 0x830F6B2C;
	sub_82EFB038(ctx, base);
	// 830F6B2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F6B30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6B34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6B40 size=208
    let mut pc: u32 = 0x830F6B40;
    'dispatch: loop {
        match pc {
            0x830F6B40 => {
    //   block [0x830F6B40..0x830F6B9C)
	// 830F6B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6B48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6B4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6B50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6B54: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F6B58: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F6B5C: 396BB0E4  addi r11, r11, -0x4f1c
	ctx.r[11].s64 = ctx.r[11].s64 + -20252;
	// 830F6B60: 394AB0D0  addi r10, r10, -0x4f30
	ctx.r[10].s64 = ctx.r[10].s64 + -20272;
	// 830F6B64: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6B68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F6B6C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F6B70: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 830F6B74: 419A0028  beq cr6, 0x830f6b9c
	if ctx.cr[6].eq {
	pc = 0x830F6B9C; continue 'dispatch;
	}
	// 830F6B78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6B7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F6B80: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6B84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6B88: 4E800421  bctrl
	ctx.lr = 0x830F6B8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F6B8C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830F6B90: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6B94: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 830F6B98: 4BFFFCD1  bl 0x830f6868
	ctx.lr = 0x830F6B9C;
	sub_830F6868(ctx, base);
            }
            0x830F6B9C => {
    //   block [0x830F6B9C..0x830F6BB4)
	// 830F6B9C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830F6BA0: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6BA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6BA8: 419A000C  beq cr6, 0x830f6bb4
	if ctx.cr[6].eq {
	pc = 0x830F6BB4; continue 'dispatch;
	}
	// 830F6BAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F6BB0: 4BFFFDD9  bl 0x830f6988
	ctx.lr = 0x830F6BB4;
	sub_830F6988(ctx, base);
	pc = 0x830F6BB4; continue 'dispatch;
            }
            0x830F6BB4 => {
    //   block [0x830F6BB4..0x830F6BD4)
	// 830F6BB4: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830F6BB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6BBC: 419A0018  beq cr6, 0x830f6bd4
	if ctx.cr[6].eq {
	pc = 0x830F6BD4; continue 'dispatch;
	}
	// 830F6BC0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6BC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6BC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6BCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6BD0: 4E800421  bctrl
	ctx.lr = 0x830F6BD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F6BD4 => {
    //   block [0x830F6BD4..0x830F6BF4)
	// 830F6BD4: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6BD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6BDC: 419A0018  beq cr6, 0x830f6bf4
	if ctx.cr[6].eq {
	pc = 0x830F6BF4; continue 'dispatch;
	}
	// 830F6BE0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6BE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6BE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F6BF0: 4E800421  bctrl
	ctx.lr = 0x830F6BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830F6BF4 => {
    //   block [0x830F6BF4..0x830F6C10)
	// 830F6BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6BF8: 4BE04589  bl 0x82efb180
	ctx.lr = 0x830F6BFC;
	sub_82EFB180(ctx, base);
	// 830F6BFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F6C00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6C04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6C08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6C0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6C10 size=164
    let mut pc: u32 = 0x830F6C10;
    'dispatch: loop {
        match pc {
            0x830F6C10 => {
    //   block [0x830F6C10..0x830F6C38)
	// 830F6C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6C14: 4BBB27F9  bl 0x82ca940c
	ctx.lr = 0x830F6C18;
	sub_82CA93D0(ctx, base);
	// 830F6C18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6C1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6C20: 4BFFFA11  bl 0x830f6630
	ctx.lr = 0x830F6C24;
	sub_830F6630(ctx, base);
	// 830F6C24: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F6C28: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F6C2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F6C30: 4099002C  ble cr6, 0x830f6c5c
	if !ctx.cr[6].gt {
	pc = 0x830F6C5C; continue 'dispatch;
	}
	// 830F6C34: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830F6C38; continue 'dispatch;
            }
            0x830F6C38 => {
    //   block [0x830F6C38..0x830F6C5C)
	// 830F6C38: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F6C3C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830F6C40: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F6C44: 4BE036DD  bl 0x82efa320
	ctx.lr = 0x830F6C48;
	sub_82EFA320(ctx, base);
	// 830F6C48: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F6C4C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F6C50: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F6C54: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F6C58: 4198FFE0  blt cr6, 0x830f6c38
	if ctx.cr[6].lt {
	pc = 0x830F6C38; continue 'dispatch;
	}
	pc = 0x830F6C5C; continue 'dispatch;
            }
            0x830F6C5C => {
    //   block [0x830F6C5C..0x830F6C90)
	// 830F6C5C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 830F6C60: 4BE044E1  bl 0x82efb140
	ctx.lr = 0x830F6C64;
	sub_82EFB140(ctx, base);
	// 830F6C64: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 830F6C68: 4BE043D1  bl 0x82efb038
	ctx.lr = 0x830F6C6C;
	sub_82EFB038(ctx, base);
	// 830F6C6C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 830F6C70: 4BE04469  bl 0x82efb0d8
	ctx.lr = 0x830F6C74;
	sub_82EFB0D8(ctx, base);
	// 830F6C74: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830F6C78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6C7C: 4BE24D25  bl 0x82f1b9a0
	ctx.lr = 0x830F6C80;
	sub_82F1B9A0(ctx, base);
	// 830F6C80: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F6C84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6C88: 419A0008  beq cr6, 0x830f6c90
	if ctx.cr[6].eq {
	pc = 0x830F6C90; continue 'dispatch;
	}
	// 830F6C8C: 4BE06C15  bl 0x82efd8a0
	ctx.lr = 0x830F6C90;
	sub_82EFD8A0(ctx, base);
	pc = 0x830F6C90; continue 'dispatch;
            }
            0x830F6C90 => {
    //   block [0x830F6C90..0x830F6CAC)
	// 830F6C90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6C98: 4BE45811  bl 0x82f3c4a8
	ctx.lr = 0x830F6C9C;
	sub_82F3C4A8(ctx, base);
	// 830F6C9C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6CA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6CA4: 419A0008  beq cr6, 0x830f6cac
	if ctx.cr[6].eq {
	pc = 0x830F6CAC; continue 'dispatch;
	}
	// 830F6CA8: 4BE06BF9  bl 0x82efd8a0
	ctx.lr = 0x830F6CAC;
	sub_82EFD8A0(ctx, base);
	pc = 0x830F6CAC; continue 'dispatch;
            }
            0x830F6CAC => {
    //   block [0x830F6CAC..0x830F6CB4)
	// 830F6CAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6CB0: 4BBB27AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6CB8 size=76
    let mut pc: u32 = 0x830F6CB8;
    'dispatch: loop {
        match pc {
            0x830F6CB8 => {
    //   block [0x830F6CB8..0x830F6CE8)
	// 830F6CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6CC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F6CC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6CC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6CCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6CD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F6CD4: 4BFFFD2D  bl 0x830f6a00
	ctx.lr = 0x830F6CD8;
	sub_830F6A00(ctx, base);
	// 830F6CD8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6CDC: 4182000C  beq 0x830f6ce8
	if ctx.cr[0].eq {
	pc = 0x830F6CE8; continue 'dispatch;
	}
	// 830F6CE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6CE4: 4BE06BBD  bl 0x82efd8a0
	ctx.lr = 0x830F6CE8;
	sub_82EFD8A0(ctx, base);
	pc = 0x830F6CE8; continue 'dispatch;
            }
            0x830F6CE8 => {
    //   block [0x830F6CE8..0x830F6D04)
	// 830F6CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6CEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6CF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6CF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6CF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F6CFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6D08 size=76
    let mut pc: u32 = 0x830F6D08;
    'dispatch: loop {
        match pc {
            0x830F6D08 => {
    //   block [0x830F6D08..0x830F6D38)
	// 830F6D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6D10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F6D14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6D18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6D20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F6D24: 4BFFFE1D  bl 0x830f6b40
	ctx.lr = 0x830F6D28;
	sub_830F6B40(ctx, base);
	// 830F6D28: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6D2C: 4182000C  beq 0x830f6d38
	if ctx.cr[0].eq {
	pc = 0x830F6D38; continue 'dispatch;
	}
	// 830F6D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6D34: 4BE06B6D  bl 0x82efd8a0
	ctx.lr = 0x830F6D38;
	sub_82EFD8A0(ctx, base);
	pc = 0x830F6D38; continue 'dispatch;
            }
            0x830F6D38 => {
    //   block [0x830F6D38..0x830F6D54)
	// 830F6D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6D3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6D40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6D44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6D48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F6D4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6D50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6D58 size=104
    let mut pc: u32 = 0x830F6D58;
    'dispatch: loop {
        match pc {
            0x830F6D58 => {
    //   block [0x830F6D58..0x830F6DC0)
	// 830F6D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6D60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6D64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6D68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6D6C: 4BE06BDD  bl 0x82efd948
	ctx.lr = 0x830F6D70;
	sub_82EFD948(ctx, base);
	// 830F6D70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F6D74: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 830F6D78: 396BB118  addi r11, r11, -0x4ee8
	ctx.r[11].s64 = ctx.r[11].s64 + -20200;
	// 830F6D7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6D80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F6D84: 4BE01FBD  bl 0x82ef8d40
	ctx.lr = 0x830F6D88;
	sub_82EF8D40(ctx, base);
	// 830F6D88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F6D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6D90: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830F6D94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F6D98: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830F6D9C: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 830F6DA0: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830F6DA4: 4BE06CB5  bl 0x82efda58
	ctx.lr = 0x830F6DA8;
	sub_82EFDA58(ctx, base);
	// 830F6DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6DAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F6DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6DB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6DBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6DC0 size=136
    let mut pc: u32 = 0x830F6DC0;
    'dispatch: loop {
        match pc {
            0x830F6DC0 => {
    //   block [0x830F6DC0..0x830F6E24)
	// 830F6DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F6DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6DD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F6DD8: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 830F6DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6DE0: 4BE06231  bl 0x82efd010
	ctx.lr = 0x830F6DE4;
	sub_82EFD010(ctx, base);
	// 830F6DE4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F6DE8: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 830F6DEC: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830F6DF0: 396BB108  addi r11, r11, -0x4ef8
	ctx.r[11].s64 = ctx.r[11].s64 + -20216;
	// 830F6DF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F6DF8: 4BE06A69  bl 0x82efd860
	ctx.lr = 0x830F6DFC;
	sub_82EFD860(ctx, base);
	// 830F6DFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F6E00: 41820024  beq 0x830f6e24
	if ctx.cr[0].eq {
	pc = 0x830F6E24; continue 'dispatch;
	}
	// 830F6E04: 3D605647  lis r11, 0x5647
	ctx.r[11].s64 = 1447493632;
	// 830F6E08: 3D409FE1  lis r10, -0x601f
	ctx.r[10].s64 = -1612644352;
	// 830F6E0C: 616B1E89  ori r11, r11, 0x1e89
	ctx.r[11].u64 = ctx.r[11].u64 | 7817;
	// 830F6E10: 614A234A  ori r10, r10, 0x234a
	ctx.r[10].u64 = ctx.r[10].u64 | 9034;
	// 830F6E14: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F6E18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F6E1C: 4BFFFF3D  bl 0x830f6d58
	ctx.lr = 0x830F6E20;
	sub_830F6D58(ctx, base);
	// 830F6E20: 48000008  b 0x830f6e28
	pc = 0x830F6E28; continue 'dispatch;
            }
            0x830F6E24 => {
    //   block [0x830F6E24..0x830F6E28)
	// 830F6E24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830F6E28; continue 'dispatch;
            }
            0x830F6E28 => {
    //   block [0x830F6E28..0x830F6E48)
	// 830F6E28: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 830F6E2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6E30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6E3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F6E40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6E44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6E48 size=92
    let mut pc: u32 = 0x830F6E48;
    'dispatch: loop {
        match pc {
            0x830F6E48 => {
    //   block [0x830F6E48..0x830F6E8C)
	// 830F6E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6E4C: 4BBB25C1  bl 0x82ca940c
	ctx.lr = 0x830F6E50;
	sub_82CA93D0(ctx, base);
	// 830F6E50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6E54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6E58: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F6E5C: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 830F6E60: 396BB118  addi r11, r11, -0x4ee8
	ctx.r[11].s64 = ctx.r[11].s64 + -20200;
	// 830F6E64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6E68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F6E6C: 4BFFF505  bl 0x830f6370
	ctx.lr = 0x830F6E70;
	sub_830F6370(ctx, base);
	// 830F6E70: 83DF0038  lwz r30, 0x38(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F6E74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F6E78: 419A0014  beq cr6, 0x830f6e8c
	if ctx.cr[6].eq {
	pc = 0x830F6E8C; continue 'dispatch;
	}
	// 830F6E7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6E80: 4BFFFD91  bl 0x830f6c10
	ctx.lr = 0x830F6E84;
	sub_830F6C10(ctx, base);
	// 830F6E84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6E88: 4BE06A19  bl 0x82efd8a0
	ctx.lr = 0x830F6E8C;
	sub_82EFD8A0(ctx, base);
	pc = 0x830F6E8C; continue 'dispatch;
            }
            0x830F6E8C => {
    //   block [0x830F6E8C..0x830F6EA4)
	// 830F6E8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6E90: 4BFFFC61  bl 0x830f6af0
	ctx.lr = 0x830F6E94;
	sub_830F6AF0(ctx, base);
	// 830F6E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6E98: 4BE06B81  bl 0x82efda18
	ctx.lr = 0x830F6E9C;
	sub_82EFDA18(ctx, base);
	// 830F6E9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6EA0: 4BBB25BC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6EA8 size=76
    let mut pc: u32 = 0x830F6EA8;
    'dispatch: loop {
        match pc {
            0x830F6EA8 => {
    //   block [0x830F6EA8..0x830F6ED8)
	// 830F6EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6EB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F6EB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6EB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6EC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F6EC4: 4BFFFF85  bl 0x830f6e48
	ctx.lr = 0x830F6EC8;
	sub_830F6E48(ctx, base);
	// 830F6EC8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6ECC: 4182000C  beq 0x830f6ed8
	if ctx.cr[0].eq {
	pc = 0x830F6ED8; continue 'dispatch;
	}
	// 830F6ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6ED4: 4BE069CD  bl 0x82efd8a0
	ctx.lr = 0x830F6ED8;
	sub_82EFD8A0(ctx, base);
	pc = 0x830F6ED8; continue 'dispatch;
            }
            0x830F6ED8 => {
    //   block [0x830F6ED8..0x830F6EF4)
	// 830F6ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6EDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F6EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6EE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F6EEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F6EF8 size=140
    let mut pc: u32 = 0x830F6EF8;
    'dispatch: loop {
        match pc {
            0x830F6EF8 => {
    //   block [0x830F6EF8..0x830F6F14)
	// 830F6EF8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830F6EFC: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830F6F00: 419A0014  beq cr6, 0x830f6f14
	if ctx.cr[6].eq {
	pc = 0x830F6F14; continue 'dispatch;
	}
	// 830F6F04: 3940002D  li r10, 0x2d
	ctx.r[10].s64 = 45;
	// 830F6F08: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 830F6F0C: 99440000  stb r10, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830F6F10: 7C6300D0  neg r3, r3
	ctx.r[3].s64 = -ctx.r[3].s64;
	pc = 0x830F6F14; continue 'dispatch;
            }
            0x830F6F14 => {
    //   block [0x830F6F14..0x830F6F18)
	// 830F6F14: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x830F6F18; continue 'dispatch;
            }
            0x830F6F18 => {
    //   block [0x830F6F18..0x830F6F40)
	// 830F6F18: 7D432B96  divwu r10, r3, r5
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[5].u32;
	// 830F6F1C: 0CC50000  twi 6, r5, 0
	// 830F6F20: 7D4A29D6  mullw r10, r10, r5
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 830F6F24: 7D4A1850  subf r10, r10, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 830F6F28: 7C632B96  divwu r3, r3, r5
	ctx.r[3].u32 = ctx.r[3].u32 / ctx.r[5].u32;
	// 830F6F2C: 0CC50000  twi 6, r5, 0
	// 830F6F30: 2B0A0009  cmplwi cr6, r10, 9
	ctx.cr[6].compare_u32(ctx.r[10].u32, 9 as u32, &mut ctx.xer);
	// 830F6F34: 4099000C  ble cr6, 0x830f6f40
	if !ctx.cr[6].gt {
	pc = 0x830F6F40; continue 'dispatch;
	}
	// 830F6F38: 394A0057  addi r10, r10, 0x57
	ctx.r[10].s64 = ctx.r[10].s64 + 87;
	// 830F6F3C: 48000008  b 0x830f6f44
	pc = 0x830F6F44; continue 'dispatch;
            }
            0x830F6F40 => {
    //   block [0x830F6F40..0x830F6F44)
	// 830F6F40: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	pc = 0x830F6F44; continue 'dispatch;
            }
            0x830F6F44 => {
    //   block [0x830F6F44..0x830F6F60)
	// 830F6F44: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830F6F48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F6F4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F6F50: 409AFFC8  bne cr6, 0x830f6f18
	if !ctx.cr[6].eq {
	pc = 0x830F6F18; continue 'dispatch;
	}
	// 830F6F54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F6F58: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830F6F5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x830F6F60; continue 'dispatch;
            }
            0x830F6F60 => {
    //   block [0x830F6F60..0x830F6F84)
	// 830F6F60: 89490000  lbz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6F64: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6F68: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830F6F6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F6F70: 99090000  stb r8, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 830F6F74: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F6F78: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F6F7C: 4198FFE4  blt cr6, 0x830f6f60
	if ctx.cr[6].lt {
	pc = 0x830F6F60; continue 'dispatch;
	}
	// 830F6F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6F88 size=44
    let mut pc: u32 = 0x830F6F88;
    'dispatch: loop {
        match pc {
            0x830F6F88 => {
    //   block [0x830F6F88..0x830F6FB4)
	// 830F6F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6F90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6F94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F6F98: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 830F6F9C: 4BFFFF5D  bl 0x830f6ef8
	ctx.lr = 0x830F6FA0;
	sub_830F6EF8(ctx, base);
	// 830F6FA0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 830F6FA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F6FA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6FAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6FB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6FB8 size=312
    let mut pc: u32 = 0x830F6FB8;
    'dispatch: loop {
        match pc {
            0x830F6FB8 => {
    //   block [0x830F6FB8..0x830F6FF8)
	// 830F6FB8: 832B9CA4  lwz r25, -0x635c(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25436 as u32) ) } as u64;
	// 830F6FBC: 8210B3B0  lwz r16, -0x4c50(r16)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-19536 as u32) ) } as u64;
	// 830F6FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6FC4: 4BBB243D  bl 0x82ca9400
	ctx.lr = 0x830F6FC8;
	sub_82CA93D0(ctx, base);
	// 830F6FC8: 3BE1FF60  addi r31, r1, -0xa0
	ctx.r[31].s64 = ctx.r[1].s64 + -160;
	// 830F6FCC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6FD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F6FD4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F6FD8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830F6FDC: 7FCB0034  cntlzw r11, r30
	ctx.r[11].u64 = if ctx.r[30].u32 == 0 { 32 } else { ctx.r[30].u32.leading_zeros() as u64 };
	// 830F6FE0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F6FE4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830F6FE8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830F6FEC: 935F0050  stw r26, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830F6FF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6FF4: 409A0030  bne cr6, 0x830f7024
	if !ctx.cr[6].eq {
	pc = 0x830F7024; continue 'dispatch;
	}
	pc = 0x830F6FF8; continue 'dispatch;
            }
            0x830F6FF8 => {
    //   block [0x830F6FF8..0x830F7024)
	// 830F6FF8: 4BBBB061  bl 0x82cb2058
	ctx.lr = 0x830F6FFC;
	sub_82CB2058(ctx, base);
	// 830F6FFC: 39600016  li r11, 0x16
	ctx.r[11].s64 = 22;
	// 830F7000: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F7004: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F7008: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F700C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F7010: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F7014: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F7018: 4BBBAF01  bl 0x82cb1f18
	ctx.lr = 0x830F701C;
	sub_82CB1F18(ctx, base);
	// 830F701C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F7020: 480000C8  b 0x830f70e8
	pc = 0x830F70E8; continue 'dispatch;
            }
            0x830F7024 => {
    //   block [0x830F7024..0x830F7078)
	// 830F7024: 7FAB0034  cntlzw r11, r29
	ctx.r[11].u64 = if ctx.r[29].u32 == 0 { 32 } else { ctx.r[29].u32.leading_zeros() as u64 };
	// 830F7028: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F702C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830F7030: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7034: 419AFFC4  beq cr6, 0x830f6ff8
	if ctx.cr[6].eq {
	pc = 0x830F6FF8; continue 'dispatch;
	}
	// 830F7038: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F703C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F7040: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F7044: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830F7048: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F704C: 419AFFAC  beq cr6, 0x830f6ff8
	if ctx.cr[6].eq {
	pc = 0x830F6FF8; continue 'dispatch;
	}
	// 830F7050: 4BBBDE79  bl 0x82cb4ec8
	ctx.lr = 0x830F7054;
	sub_82CB4EC8(ctx, base);
	// 830F7054: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F7058: 939F0054  stw r28, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 830F705C: 4082001C  bne 0x830f7078
	if !ctx.cr[0].eq {
	pc = 0x830F7078; continue 'dispatch;
	}
	// 830F7060: 4BBBAFF9  bl 0x82cb2058
	ctx.lr = 0x830F7064;
	sub_82CB2058(ctx, base);
	// 830F7064: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830F7068: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 830F706C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F7070: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F7074: 48000074  b 0x830f70e8
	pc = 0x830F70E8; continue 'dispatch;
            }
            0x830F7078 => {
    //   block [0x830F7078..0x830F70B8)
	// 830F7078: 60000000  nop
	// 830F707C: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 830F7080: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7084: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F7088: 40820030  bne 0x830f70b8
	if !ctx.cr[0].eq {
	pc = 0x830F70B8; continue 'dispatch;
	}
	// 830F708C: 4BBBAFCD  bl 0x82cb2058
	ctx.lr = 0x830F7090;
	sub_82CB2058(ctx, base);
	// 830F7090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830F7094: 3D40830F  lis r10, -0x7cf1
	ctx.r[10].s64 = -2096168960;
	// 830F7098: 39200016  li r9, 0x16
	ctx.r[9].s64 = 22;
	// 830F709C: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 830F70A0: 388A70E4  addi r4, r10, 0x70e4
	ctx.r[4].s64 = ctx.r[10].s64 + 28900;
	// 830F70A4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F70A8: 935F0058  stw r26, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 830F70AC: 4BBBDFD5  bl 0x82cb5080
	ctx.lr = 0x830F70B0;
	sub_82CB5080(ctx, base);
	// 830F70B0: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 830F70B4: 48000030  b 0x830f70e4
	pc = 0x830F70E4; continue 'dispatch;
            }
            0x830F70B8 => {
    //   block [0x830F70B8..0x830F70E4)
	// 830F70B8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830F70BC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F70C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F70C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F70C8: 48000201  bl 0x830f72c8
	ctx.lr = 0x830F70CC;
	sub_830F72C8(ctx, base);
	// 830F70CC: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830F70D0: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 830F70D4: 399F00A0  addi r12, r31, 0xa0
	ctx.r[12].s64 = ctx.r[31].s64 + 160;
	// 830F70D8: 48000039  bl 0x830f7110
	ctx.lr = 0x830F70DC;
	crate::recompiler::externs::call(ctx, base, 0x830F7110);
	// 830F70DC: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F70E0: 48000008  b 0x830f70e8
	pc = 0x830F70E8; continue 'dispatch;
            }
            0x830F70E4 => {
    //   block [0x830F70E4..0x830F70E8)
	// 830F70E4: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x830F70E8; continue 'dispatch;
            }
            0x830F70E8 => {
    //   block [0x830F70E8..0x830F70F0)
	// 830F70E8: 383F00A0  addi r1, r31, 0xa0
	ctx.r[1].s64 = ctx.r[31].s64 + 160;
	// 830F70EC: 4BBB2364  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F7148 size=8
    let mut pc: u32 = 0x830F7148;
    'dispatch: loop {
        match pc {
            0x830F7148 => {
    //   block [0x830F7148..0x830F7150)
	// 830F7148: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 830F714C: 4BFFFE74  b 0x830f6fc0
	sub_830F6FB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7158 size=368
    let mut pc: u32 = 0x830F7158;
    'dispatch: loop {
        match pc {
            0x830F7158 => {
    //   block [0x830F7158..0x830F7190)
	// 830F7158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F715C: 4BBB22AD  bl 0x82ca9408
	ctx.lr = 0x830F7160;
	sub_82CA93D0(ctx, base);
	// 830F7160: 3BE1FF80  addi r31, r1, -0x80
	ctx.r[31].s64 = ctx.r[1].s64 + -128;
	// 830F7164: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7168: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F716C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F7170: 93BF009C  stw r29, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 830F7174: 7FCB0034  cntlzw r11, r30
	ctx.r[11].u64 = if ctx.r[30].u32 == 0 { 32 } else { ctx.r[30].u32.leading_zeros() as u64 };
	// 830F7178: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F717C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F7180: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830F7184: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830F7188: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F718C: 409A0034  bne cr6, 0x830f71c0
	if !ctx.cr[6].eq {
	pc = 0x830F71C0; continue 'dispatch;
	}
	pc = 0x830F7190; continue 'dispatch;
            }
            0x830F7190 => {
    //   block [0x830F7190..0x830F71C0)
	// 830F7190: 4BBBAEC9  bl 0x82cb2058
	ctx.lr = 0x830F7194;
	sub_82CB2058(ctx, base);
	// 830F7194: 39600016  li r11, 0x16
	ctx.r[11].s64 = 22;
	// 830F7198: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F719C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F71A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F71A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F71A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F71AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F71B0: 4BBBAD69  bl 0x82cb1f18
	ctx.lr = 0x830F71B4;
	sub_82CB1F18(ctx, base);
	// 830F71B4: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 830F71B8: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830F71BC: 480000AC  b 0x830f7268
	pc = 0x830F7268; continue 'dispatch;
            }
            0x830F71C0 => {
    //   block [0x830F71C0..0x830F720C)
	// 830F71C0: 7FAB0034  cntlzw r11, r29
	ctx.r[11].u64 = if ctx.r[29].u32 == 0 { 32 } else { ctx.r[29].u32.leading_zeros() as u64 };
	// 830F71C4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F71C8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830F71CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F71D0: 419AFFC0  beq cr6, 0x830f7190
	if ctx.cr[6].eq {
	pc = 0x830F7190; continue 'dispatch;
	}
	// 830F71D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F71D8: 4B083EA9  bl 0x8217b080
	ctx.lr = 0x830F71DC;
	sub_8217B080(ctx, base);
	// 830F71DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F71E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F71E4: 4BBB7CBD  bl 0x82caeea0
	ctx.lr = 0x830F71E8;
	sub_82CAEEA0(ctx, base);
	// 830F71E8: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 830F71EC: 4B149385  bl 0x82240570
	ctx.lr = 0x830F71F0;
	sub_82240570(ctx, base);
	// 830F71F0: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 830F71F4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F71F8: 419A0058  beq cr6, 0x830f7250
	if ctx.cr[6].eq {
	pc = 0x830F7250; continue 'dispatch;
	}
	// 830F71FC: 4B149375  bl 0x82240570
	ctx.lr = 0x830F7200;
	sub_82240570(ctx, base);
	// 830F7200: 39630040  addi r11, r3, 0x40
	ctx.r[11].s64 = ctx.r[3].s64 + 64;
	// 830F7204: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F7208: 419A0048  beq cr6, 0x830f7250
	if ctx.cr[6].eq {
	pc = 0x830F7250; continue 'dispatch;
	}
	pc = 0x830F720C; continue 'dispatch;
            }
            0x830F720C => {
    //   block [0x830F720C..0x830F7244)
	// 830F720C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F7210: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 830F7214: 939F0054  stw r28, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 830F7218: 419A0040  beq cr6, 0x830f7258
	if ctx.cr[6].eq {
	pc = 0x830F7258; continue 'dispatch;
	}
	// 830F721C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F7220: A07E0000  lhz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7224: 4BBC73CD  bl 0x82cbe5f0
	ctx.lr = 0x830F7228;
	sub_82CBE5F0(ctx, base);
	// 830F7228: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 830F722C: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 830F7230: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 830F7234: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 830F7238: 419A000C  beq cr6, 0x830f7244
	if ctx.cr[6].eq {
	pc = 0x830F7244; continue 'dispatch;
	}
	// 830F723C: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 830F7240: 4BFFFFCC  b 0x830f720c
	pc = 0x830F720C; continue 'dispatch;
            }
            0x830F7244 => {
    //   block [0x830F7244..0x830F7250)
	// 830F7244: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830F7248: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F724C: 4800000C  b 0x830f7258
	pc = 0x830F7258; continue 'dispatch;
            }
            0x830F7250 => {
    //   block [0x830F7250..0x830F7258)
	// 830F7250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F7254: 4BBD0D9D  bl 0x82cc7ff0
	ctx.lr = 0x830F7258;
	sub_82CC7FF0(ctx, base);
	pc = 0x830F7258; continue 'dispatch;
            }
            0x830F7258 => {
    //   block [0x830F7258..0x830F7268)
	// 830F7258: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 830F725C: 399F0080  addi r12, r31, 0x80
	ctx.r[12].s64 = ctx.r[31].s64 + 128;
	// 830F7260: 48000031  bl 0x830f7290
	ctx.lr = 0x830F7264;
	sub_830F7158(ctx, base);
	// 830F7264: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x830F7268; continue 'dispatch;
            }
            0x830F7268 => {
    //   block [0x830F7268..0x830F7290)
	// 830F7268: 383F0080  addi r1, r31, 0x80
	ctx.r[1].s64 = ctx.r[31].s64 + 128;
	// 830F726C: 4BBB21EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 830F7270: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 830F7274: 3BECFF80  addi r31, r12, -0x80
	ctx.r[31].s64 = ctx.r[12].s64 + -128;
	// 830F7278: FBA1FFF0  std r29, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[29].u64 ) };
	// 830F727C: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7280: 9181FFE8  stw r12, -0x18(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[12].u32 ) };
	// 830F7284: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7288: 83BF009C  lwz r29, 0x9c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 830F728C: 4800001C  b 0x830f72a8
	pc = 0x830F72A8; continue 'dispatch;
            }
            0x830F7290 => {
    //   block [0x830F7290..0x830F72A8)
	// 830F7290: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 830F7294: 3BECFF80  addi r31, r12, -0x80
	ctx.r[31].s64 = ctx.r[12].s64 + -128;
	// 830F7298: FBA1FFF0  std r29, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[29].u64 ) };
	// 830F729C: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F72A0: 9181FFE8  stw r12, -0x18(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[12].u32 ) };
	// 830F72A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	pc = 0x830F72A8; continue 'dispatch;
            }
            0x830F72A8 => {
    //   block [0x830F72A8..0x830F72C8)
	// 830F72A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F72AC: 4BBB7CB5  bl 0x82caef60
	ctx.lr = 0x830F72B0;
	sub_82CAEF60(ctx, base);
	// 830F72B0: 80210000  lwz r1, 0(r1)
	ctx.r[1].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F72B4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 830F72B8: EBA1FFF0  ld r29, -0x10(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F72BC: 8181FFE8  lwz r12, -0x18(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) } as u64;
	// 830F72C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F72C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F72C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F72C8 size=600
    let mut pc: u32 = 0x830F72C8;
    'dispatch: loop {
        match pc {
            0x830F72C8 => {
    //   block [0x830F72C8..0x830F72F0)
	// 830F72C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F72CC: 4BBB2141  bl 0x82ca940c
	ctx.lr = 0x830F72D0;
	sub_82CA93D0(ctx, base);
	// 830F72D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F72D4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830F72D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F72DC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830F72E0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 830F72E4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F72E8: 816B6CC0  lwz r11, 0x6cc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27840 as u32) ) } as u64;
	// 830F72EC: 48000008  b 0x830f72f4
	pc = 0x830F72F4; continue 'dispatch;
            }
            0x830F72F0 => {
    //   block [0x830F72F0..0x830F72F4)
	// 830F72F0: 38840002  addi r4, r4, 2
	ctx.r[4].s64 = ctx.r[4].s64 + 2;
	pc = 0x830F72F4; continue 'dispatch;
            }
            0x830F72F4 => {
    //   block [0x830F72F4..0x830F731C)
	// 830F72F4: A1440000  lhz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F72F8: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 830F72FC: 419AFFF4  beq cr6, 0x830f72f0
	if ctx.cr[6].eq {
	pc = 0x830F72F0; continue 'dispatch;
	}
	// 830F7300: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 830F7304: 2F0A0061  cmpwi cr6, r10, 0x61
	ctx.cr[6].compare_i32(ctx.r[10].s32, 97, &mut ctx.xer);
	// 830F7308: 419A0054  beq cr6, 0x830f735c
	if ctx.cr[6].eq {
	pc = 0x830F735C; continue 'dispatch;
	}
	// 830F730C: 2F0A0072  cmpwi cr6, r10, 0x72
	ctx.cr[6].compare_i32(ctx.r[10].s32, 114, &mut ctx.xer);
	// 830F7310: 419A0040  beq cr6, 0x830f7350
	if ctx.cr[6].eq {
	pc = 0x830F7350; continue 'dispatch;
	}
	// 830F7314: 2F0A0077  cmpwi cr6, r10, 0x77
	ctx.cr[6].compare_i32(ctx.r[10].s32, 119, &mut ctx.xer);
	// 830F7318: 419A0030  beq cr6, 0x830f7348
	if ctx.cr[6].eq {
	pc = 0x830F7348; continue 'dispatch;
	}
	pc = 0x830F731C; continue 'dispatch;
            }
            0x830F731C => {
    //   block [0x830F731C..0x830F7340)
	// 830F731C: 4BBBAD3D  bl 0x82cb2058
	ctx.lr = 0x830F7320;
	sub_82CB2058(ctx, base);
	// 830F7320: 39600016  li r11, 0x16
	ctx.r[11].s64 = 22;
	// 830F7324: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F7328: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F732C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F7330: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F7334: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F7338: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F733C: 4BBBABDD  bl 0x82cb1f18
	ctx.lr = 0x830F7340;
	sub_82CB1F18(ctx, base);
	pc = 0x830F7340; continue 'dispatch;
            }
            0x830F7340 => {
    //   block [0x830F7340..0x830F7348)
	// 830F7340: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F7344: 480001D4  b 0x830f7518
	pc = 0x830F7518; continue 'dispatch;
            }
            0x830F7348 => {
    //   block [0x830F7348..0x830F7350)
	// 830F7348: 39400301  li r10, 0x301
	ctx.r[10].s64 = 769;
	// 830F734C: 48000014  b 0x830f7360
	pc = 0x830F7360; continue 'dispatch;
            }
            0x830F7350 => {
    //   block [0x830F7350..0x830F735C)
	// 830F7350: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830F7354: 617F0001  ori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 | 1;
	// 830F7358: 4800000C  b 0x830f7364
	pc = 0x830F7364; continue 'dispatch;
            }
            0x830F735C => {
    //   block [0x830F735C..0x830F7360)
	// 830F735C: 39400109  li r10, 0x109
	ctx.r[10].s64 = 265;
	pc = 0x830F7360; continue 'dispatch;
            }
            0x830F7360 => {
    //   block [0x830F7360..0x830F7364)
	// 830F7360: 617F0002  ori r31, r11, 2
	ctx.r[31].u64 = ctx.r[11].u64 | 2;
	pc = 0x830F7364; continue 'dispatch;
            }
            0x830F7364 => {
    //   block [0x830F7364..0x830F7374)
	// 830F7364: A1640002  lhz r11, 2(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 830F7368: 39040002  addi r8, r4, 2
	ctx.r[8].s64 = ctx.r[4].s64 + 2;
	// 830F736C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F7370: 48000130  b 0x830f74a0
	pc = 0x830F74A0; continue 'dispatch;
            }
            0x830F7374 => {
    //   block [0x830F7374..0x830F73CC)
	// 830F7374: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F7378: 419A0138  beq cr6, 0x830f74b0
	if ctx.cr[6].eq {
	pc = 0x830F74B0; continue 'dispatch;
	}
	// 830F737C: 2F0B0053  cmpwi cr6, r11, 0x53
	ctx.cr[6].compare_i32(ctx.r[11].s32, 83, &mut ctx.xer);
	// 830F7380: 41990094  bgt cr6, 0x830f7414
	if ctx.cr[6].gt {
	pc = 0x830F7414; continue 'dispatch;
	}
	// 830F7384: 419A007C  beq cr6, 0x830f7400
	if ctx.cr[6].eq {
	pc = 0x830F7400; continue 'dispatch;
	}
	// 830F7388: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830F738C: 419A010C  beq cr6, 0x830f7498
	if ctx.cr[6].eq {
	pc = 0x830F7498; continue 'dispatch;
	}
	// 830F7390: 2F0B002B  cmpwi cr6, r11, 0x2b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 43, &mut ctx.xer);
	// 830F7394: 419A0050  beq cr6, 0x830f73e4
	if ctx.cr[6].eq {
	pc = 0x830F73E4; continue 'dispatch;
	}
	// 830F7398: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 830F739C: 419A00F0  beq cr6, 0x830f748c
	if ctx.cr[6].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F73A0: 2F0B0044  cmpwi cr6, r11, 0x44
	ctx.cr[6].compare_i32(ctx.r[11].s32, 68, &mut ctx.xer);
	// 830F73A4: 419A0030  beq cr6, 0x830f73d4
	if ctx.cr[6].eq {
	pc = 0x830F73D4; continue 'dispatch;
	}
	// 830F73A8: 2F0B004E  cmpwi cr6, r11, 0x4e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 78, &mut ctx.xer);
	// 830F73AC: 419A0020  beq cr6, 0x830f73cc
	if ctx.cr[6].eq {
	pc = 0x830F73CC; continue 'dispatch;
	}
	// 830F73B0: 2F0B0052  cmpwi cr6, r11, 0x52
	ctx.cr[6].compare_i32(ctx.r[11].s32, 82, &mut ctx.xer);
	// 830F73B4: 409AFF68  bne cr6, 0x830f731c
	if !ctx.cr[6].eq {
	pc = 0x830F731C; continue 'dispatch;
	}
	// 830F73B8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830F73BC: 409A00D0  bne cr6, 0x830f748c
	if !ctx.cr[6].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F73C0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830F73C4: 614A0010  ori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 16;
	// 830F73C8: 480000D0  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F73CC => {
    //   block [0x830F73CC..0x830F73D4)
	// 830F73CC: 614A0080  ori r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 128;
	// 830F73D0: 480000C8  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F73D4 => {
    //   block [0x830F73D4..0x830F73E4)
	// 830F73D4: 554B0673  rlwinm. r11, r10, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F73D8: 408200B4  bne 0x830f748c
	if !ctx.cr[0].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F73DC: 614A0040  ori r10, r10, 0x40
	ctx.r[10].u64 = ctx.r[10].u64 | 64;
	// 830F73E0: 480000B8  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F73E4 => {
    //   block [0x830F73E4..0x830F7400)
	// 830F73E4: 554B07BD  rlwinm. r11, r10, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F73E8: 408200A4  bne 0x830f748c
	if !ctx.cr[0].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F73EC: 554B003C  rlwinm r11, r10, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830F73F0: 57E4003A  rlwinm r4, r31, 0, 0, 0x1d
	ctx.r[4].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 830F73F4: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	// 830F73F8: 609F0080  ori r31, r4, 0x80
	ctx.r[31].u64 = ctx.r[4].u64 | 128;
	// 830F73FC: 4800009C  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F7400 => {
    //   block [0x830F7400..0x830F7414)
	// 830F7400: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830F7404: 409A0088  bne cr6, 0x830f748c
	if !ctx.cr[6].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F7408: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830F740C: 614A0020  ori r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 32;
	// 830F7410: 48000088  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F7414 => {
    //   block [0x830F7414..0x830F744C)
	// 830F7414: 2F0B0054  cmpwi cr6, r11, 0x54
	ctx.cr[6].compare_i32(ctx.r[11].s32, 84, &mut ctx.xer);
	// 830F7418: 419A006C  beq cr6, 0x830f7484
	if ctx.cr[6].eq {
	pc = 0x830F7484; continue 'dispatch;
	}
	// 830F741C: 2F0B0062  cmpwi cr6, r11, 0x62
	ctx.cr[6].compare_i32(ctx.r[11].s32, 98, &mut ctx.xer);
	// 830F7420: 419A0054  beq cr6, 0x830f7474
	if ctx.cr[6].eq {
	pc = 0x830F7474; continue 'dispatch;
	}
	// 830F7424: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 830F7428: 419A0038  beq cr6, 0x830f7460
	if ctx.cr[6].eq {
	pc = 0x830F7460; continue 'dispatch;
	}
	// 830F742C: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 830F7430: 419A001C  beq cr6, 0x830f744c
	if ctx.cr[6].eq {
	pc = 0x830F744C; continue 'dispatch;
	}
	// 830F7434: 2F0B0074  cmpwi cr6, r11, 0x74
	ctx.cr[6].compare_i32(ctx.r[11].s32, 116, &mut ctx.xer);
	// 830F7438: 409AFEE4  bne cr6, 0x830f731c
	if !ctx.cr[6].eq {
	pc = 0x830F731C; continue 'dispatch;
	}
	// 830F743C: 554B0423  rlwinm. r11, r10, 0, 0x10, 0x11
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7440: 4082004C  bne 0x830f748c
	if !ctx.cr[0].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F7444: 614A4000  ori r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 16384;
	// 830F7448: 48000050  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F744C => {
    //   block [0x830F744C..0x830F7460)
	// 830F744C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830F7450: 409A003C  bne cr6, 0x830f748c
	if !ctx.cr[6].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F7454: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830F7458: 57FF04A0  rlwinm r31, r31, 0, 0x12, 0x10
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 830F745C: 4800003C  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F7460 => {
    //   block [0x830F7460..0x830F7474)
	// 830F7460: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830F7464: 409A0028  bne cr6, 0x830f748c
	if !ctx.cr[6].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F7468: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830F746C: 63FF4000  ori r31, r31, 0x4000
	ctx.r[31].u64 = ctx.r[31].u64 | 16384;
	// 830F7470: 48000028  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F7474 => {
    //   block [0x830F7474..0x830F7484)
	// 830F7474: 554B0423  rlwinm. r11, r10, 0, 0x10, 0x11
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7478: 40820014  bne 0x830f748c
	if !ctx.cr[0].eq {
	pc = 0x830F748C; continue 'dispatch;
	}
	// 830F747C: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 830F7480: 48000018  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F7484 => {
    //   block [0x830F7484..0x830F748C)
	// 830F7484: 554B04E7  rlwinm. r11, r10, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7488: 4182000C  beq 0x830f7494
	if ctx.cr[0].eq {
	pc = 0x830F7494; continue 'dispatch;
	}
	pc = 0x830F748C; continue 'dispatch;
            }
            0x830F748C => {
    //   block [0x830F748C..0x830F7494)
	// 830F748C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 830F7490: 48000008  b 0x830f7498
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F7494 => {
    //   block [0x830F7494..0x830F7498)
	// 830F7494: 614A1000  ori r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 4096;
	pc = 0x830F7498; continue 'dispatch;
            }
            0x830F7498 => {
    //   block [0x830F7498..0x830F74A0)
	// 830F7498: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 830F749C: A1680000  lhz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830F74A0; continue 'dispatch;
            }
            0x830F74A0 => {
    //   block [0x830F74A0..0x830F74AC)
	// 830F74A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F74A4: 4082FED0  bne 0x830f7374
	if !ctx.cr[0].eq {
	pc = 0x830F7374; continue 'dispatch;
	}
	// 830F74A8: 48000008  b 0x830f74b0
	pc = 0x830F74B0; continue 'dispatch;
            }
            0x830F74AC => {
    //   block [0x830F74AC..0x830F74B0)
	// 830F74AC: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	pc = 0x830F74B0; continue 'dispatch;
            }
            0x830F74B0 => {
    //   block [0x830F74B0..0x830F7518)
	// 830F74B0: A1680000  lhz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F74B4: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830F74B8: 419AFFF4  beq cr6, 0x830f74ac
	if ctx.cr[6].eq {
	pc = 0x830F74AC; continue 'dispatch;
	}
	// 830F74BC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830F74C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F74C4: 4082FE58  bne 0x830f731c
	if !ctx.cr[0].eq {
	pc = 0x830F731C; continue 'dispatch;
	}
	// 830F74C8: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830F74CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830F74D0: 38E00180  li r7, 0x180
	ctx.r[7].s64 = 384;
	// 830F74D4: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 830F74D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F74DC: 48000705  bl 0x830f7be0
	ctx.lr = 0x830F74E0;
	sub_830F7BE0(ctx, base);
	// 830F74E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F74E4: 4082FE5C  bne 0x830f7340
	if !ctx.cr[0].eq {
	pc = 0x830F7340; continue 'dispatch;
	}
	// 830F74E8: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 830F74EC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F74F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F74F4: 816A6A94  lwz r11, 0x6a94(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27284 as u32) ) } as u64;
	// 830F74F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F74FC: 916A6A94  stw r11, 0x6a94(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(27284 as u32), ctx.r[11].u32 ) };
	// 830F7500: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 830F7504: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830F7508: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830F750C: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F7510: 93DD001C  stw r30, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830F7514: 913D0010  stw r9, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x830F7518; continue 'dispatch;
            }
            0x830F7518 => {
    //   block [0x830F7518..0x830F7520)
	// 830F7518: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F751C: 4BBB1F40  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7520 size=1296
    let mut pc: u32 = 0x830F7520;
    'dispatch: loop {
        match pc {
            0x830F7520 => {
    //   block [0x830F7520..0x830F7578)
	// 830F7520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7524: 4BBB1EC5  bl 0x82ca93e8
	ctx.lr = 0x830F7528;
	sub_82CA93D0(ctx, base);
	// 830F7528: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F752C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830F7530: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F7534: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 830F7538: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830F753C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F7540: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 830F7544: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 830F7548: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 830F754C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 830F7550: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 830F7554: 4BBCA805  bl 0x82cc1d58
	ctx.lr = 0x830F7558;
	sub_82CC1D58(ctx, base);
	// 830F7558: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F755C: 4182001C  beq 0x830f7578
	if ctx.cr[0].eq {
	pc = 0x830F7578; continue 'dispatch;
	}
	// 830F7560: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F7564: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F7568: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F756C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F7570: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F7574: 4BBBA9ED  bl 0x82cb1f60
	ctx.lr = 0x830F7578;
	sub_82CB1F60(ctx, base);
	pc = 0x830F7578; continue 'dispatch;
            }
            0x830F7578 => {
    //   block [0x830F7578..0x830F7584)
	// 830F7578: 56AB0421  rlwinm. r11, r21, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F757C: 40820008  bne 0x830f7584
	if !ctx.cr[0].eq {
	pc = 0x830F7584; continue 'dispatch;
	}
	// 830F7580: 3B60FF80  li r27, -0x80
	ctx.r[27].s64 = -128;
	pc = 0x830F7584; continue 'dispatch;
            }
            0x830F7584 => {
    //   block [0x830F7584..0x830F75A4)
	// 830F7584: 56AB07BE  clrlwi r11, r21, 0x1e
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x00000003u64;
	// 830F7588: 3E80C000  lis r20, -0x4000
	ctx.r[20].s64 = -1073741824;
	// 830F758C: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830F7590: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F7594: 4198005C  blt cr6, 0x830f75f0
	if ctx.cr[6].lt {
	pc = 0x830F75F0; continue 'dispatch;
	}
	// 830F7598: 419A0050  beq cr6, 0x830f75e8
	if ctx.cr[6].eq {
	pc = 0x830F75E8; continue 'dispatch;
	}
	// 830F759C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830F75A0: 41980040  blt cr6, 0x830f75e0
	if ctx.cr[6].lt {
	pc = 0x830F75E0; continue 'dispatch;
	}
	pc = 0x830F75A4; continue 'dispatch;
            }
            0x830F75A4 => {
    //   block [0x830F75A4..0x830F75E0)
	// 830F75A4: 4BBBAAED  bl 0x82cb2090
	ctx.lr = 0x830F75A8;
	sub_82CB2090(ctx, base);
	// 830F75A8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830F75AC: 92E30000  stw r23, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 830F75B0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F75B4: 4BBBAAA5  bl 0x82cb2058
	ctx.lr = 0x830F75B8;
	sub_82CB2058(ctx, base);
	// 830F75B8: 39600016  li r11, 0x16
	ctx.r[11].s64 = 22;
	// 830F75BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F75C0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F75C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F75C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F75CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F75D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F75D4: 4BBBA945  bl 0x82cb1f18
	ctx.lr = 0x830F75D8;
	sub_82CB1F18(ctx, base);
	// 830F75D8: 38600016  li r3, 0x16
	ctx.r[3].s64 = 22;
	// 830F75DC: 4800044C  b 0x830f7a28
	pc = 0x830F7A28; continue 'dispatch;
            }
            0x830F75E0 => {
    //   block [0x830F75E0..0x830F75E8)
	// 830F75E0: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 830F75E4: 48000010  b 0x830f75f4
	pc = 0x830F75F4; continue 'dispatch;
            }
            0x830F75E8 => {
    //   block [0x830F75E8..0x830F75F0)
	// 830F75E8: 3F204000  lis r25, 0x4000
	ctx.r[25].s64 = 1073741824;
	// 830F75EC: 48000008  b 0x830f75f4
	pc = 0x830F75F4; continue 'dispatch;
            }
            0x830F75F0 => {
    //   block [0x830F75F0..0x830F75F4)
	// 830F75F0: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	pc = 0x830F75F4; continue 'dispatch;
            }
            0x830F75F4 => {
    //   block [0x830F75F4..0x830F762C)
	// 830F75F4: 2F1F0010  cmpwi cr6, r31, 0x10
	ctx.cr[6].compare_i32(ctx.r[31].s32, 16, &mut ctx.xer);
	// 830F75F8: 419A004C  beq cr6, 0x830f7644
	if ctx.cr[6].eq {
	pc = 0x830F7644; continue 'dispatch;
	}
	// 830F75FC: 2F1F0020  cmpwi cr6, r31, 0x20
	ctx.cr[6].compare_i32(ctx.r[31].s32, 32, &mut ctx.xer);
	// 830F7600: 419A003C  beq cr6, 0x830f763c
	if ctx.cr[6].eq {
	pc = 0x830F763C; continue 'dispatch;
	}
	// 830F7604: 2F1F0030  cmpwi cr6, r31, 0x30
	ctx.cr[6].compare_i32(ctx.r[31].s32, 48, &mut ctx.xer);
	// 830F7608: 419A002C  beq cr6, 0x830f7634
	if ctx.cr[6].eq {
	pc = 0x830F7634; continue 'dispatch;
	}
	// 830F760C: 2F1F0040  cmpwi cr6, r31, 0x40
	ctx.cr[6].compare_i32(ctx.r[31].s32, 64, &mut ctx.xer);
	// 830F7610: 419A001C  beq cr6, 0x830f762c
	if ctx.cr[6].eq {
	pc = 0x830F762C; continue 'dispatch;
	}
	// 830F7614: 2F1F0080  cmpwi cr6, r31, 0x80
	ctx.cr[6].compare_i32(ctx.r[31].s32, 128, &mut ctx.xer);
	// 830F7618: 409AFF8C  bne cr6, 0x830f75a4
	if !ctx.cr[6].eq {
	pc = 0x830F75A4; continue 'dispatch;
	}
	// 830F761C: 7D795050  subf r11, r25, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[25].s64;
	// 830F7620: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F7624: 5578DFFE  rlwinm r24, r11, 0x1b, 0x1f, 0x1f
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F7628: 48000020  b 0x830f7648
	pc = 0x830F7648; continue 'dispatch;
            }
            0x830F762C => {
    //   block [0x830F762C..0x830F7634)
	// 830F762C: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 830F7630: 48000018  b 0x830f7648
	pc = 0x830F7648; continue 'dispatch;
            }
            0x830F7634 => {
    //   block [0x830F7634..0x830F763C)
	// 830F7634: 3B000002  li r24, 2
	ctx.r[24].s64 = 2;
	// 830F7638: 48000010  b 0x830f7648
	pc = 0x830F7648; continue 'dispatch;
            }
            0x830F763C => {
    //   block [0x830F763C..0x830F7644)
	// 830F763C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 830F7640: 48000008  b 0x830f7648
	pc = 0x830F7648; continue 'dispatch;
            }
            0x830F7644 => {
    //   block [0x830F7644..0x830F7648)
	// 830F7644: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	pc = 0x830F7648; continue 'dispatch;
            }
            0x830F7648 => {
    //   block [0x830F7648..0x830F7680)
	// 830F7648: 56AB056E  rlwinm r11, r21, 0, 0x15, 0x17
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 830F764C: 2F0B0400  cmpwi cr6, r11, 0x400
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1024, &mut ctx.xer);
	// 830F7650: 41990040  bgt cr6, 0x830f7690
	if ctx.cr[6].gt {
	pc = 0x830F7690; continue 'dispatch;
	}
	// 830F7654: 419A0034  beq cr6, 0x830f7688
	if ctx.cr[6].eq {
	pc = 0x830F7688; continue 'dispatch;
	}
	// 830F7658: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F765C: 419A002C  beq cr6, 0x830f7688
	if ctx.cr[6].eq {
	pc = 0x830F7688; continue 'dispatch;
	}
	// 830F7660: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 830F7664: 419A001C  beq cr6, 0x830f7680
	if ctx.cr[6].eq {
	pc = 0x830F7680; continue 'dispatch;
	}
	// 830F7668: 2F0B0200  cmpwi cr6, r11, 0x200
	ctx.cr[6].compare_i32(ctx.r[11].s32, 512, &mut ctx.xer);
	// 830F766C: 419A0094  beq cr6, 0x830f7700
	if ctx.cr[6].eq {
	pc = 0x830F7700; continue 'dispatch;
	}
	// 830F7670: 2F0B0300  cmpwi cr6, r11, 0x300
	ctx.cr[6].compare_i32(ctx.r[11].s32, 768, &mut ctx.xer);
	// 830F7674: 409AFF30  bne cr6, 0x830f75a4
	if !ctx.cr[6].eq {
	pc = 0x830F75A4; continue 'dispatch;
	}
	// 830F7678: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 830F767C: 48000030  b 0x830f76ac
	pc = 0x830F76AC; continue 'dispatch;
            }
            0x830F7680 => {
    //   block [0x830F7680..0x830F7688)
	// 830F7680: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 830F7684: 48000028  b 0x830f76ac
	pc = 0x830F76AC; continue 'dispatch;
            }
            0x830F7688 => {
    //   block [0x830F7688..0x830F7690)
	// 830F7688: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 830F768C: 48000020  b 0x830f76ac
	pc = 0x830F76AC; continue 'dispatch;
            }
            0x830F7690 => {
    //   block [0x830F7690..0x830F76A8)
	// 830F7690: 2F0B0500  cmpwi cr6, r11, 0x500
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1280, &mut ctx.xer);
	// 830F7694: 419A0014  beq cr6, 0x830f76a8
	if ctx.cr[6].eq {
	pc = 0x830F76A8; continue 'dispatch;
	}
	// 830F7698: 2F0B0600  cmpwi cr6, r11, 0x600
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1536, &mut ctx.xer);
	// 830F769C: 419A0064  beq cr6, 0x830f7700
	if ctx.cr[6].eq {
	pc = 0x830F7700; continue 'dispatch;
	}
	// 830F76A0: 2F0B0700  cmpwi cr6, r11, 0x700
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1792, &mut ctx.xer);
	// 830F76A4: 409AFF00  bne cr6, 0x830f75a4
	if !ctx.cr[6].eq {
	pc = 0x830F75A4; continue 'dispatch;
	}
	pc = 0x830F76A8; continue 'dispatch;
            }
            0x830F76A8 => {
    //   block [0x830F76A8..0x830F76AC)
	// 830F76A8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x830F76AC; continue 'dispatch;
            }
            0x830F76AC => {
    //   block [0x830F76AC..0x830F76D0)
	// 830F76AC: 56AB05EF  rlwinm. r11, r21, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F76B0: 3B400080  li r26, 0x80
	ctx.r[26].s64 = 128;
	// 830F76B4: 4182001C  beq 0x830f76d0
	if ctx.cr[0].eq {
	pc = 0x830F76D0; continue 'dispatch;
	}
	// 830F76B8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830F76BC: 816B6A98  lwz r11, 0x6a98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27288 as u32) ) } as u64;
	// 830F76C0: 7FCB5878  andc r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 & !ctx.r[11].u64;
	// 830F76C4: 556B0631  rlwinm. r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F76C8: 40820008  bne 0x830f76d0
	if !ctx.cr[0].eq {
	pc = 0x830F76D0; continue 'dispatch;
	}
	// 830F76CC: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	pc = 0x830F76D0; continue 'dispatch;
            }
            0x830F76D0 => {
    //   block [0x830F76D0..0x830F76E4)
	// 830F76D0: 56AB0673  rlwinm. r11, r21, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F76D4: 41820010  beq 0x830f76e4
	if ctx.cr[0].eq {
	pc = 0x830F76E4; continue 'dispatch;
	}
	// 830F76D8: 675A0400  oris r26, r26, 0x400
	ctx.r[26].u64 = ctx.r[26].u64 | 67108864;
	// 830F76DC: 67390001  oris r25, r25, 1
	ctx.r[25].u64 = ctx.r[25].u64 | 65536;
	// 830F76E0: 63180004  ori r24, r24, 4
	ctx.r[24].u64 = ctx.r[24].u64 | 4;
	pc = 0x830F76E4; continue 'dispatch;
            }
            0x830F76E4 => {
    //   block [0x830F76E4..0x830F76F0)
	// 830F76E4: 56AB04E7  rlwinm. r11, r21, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F76E8: 41820008  beq 0x830f76f0
	if ctx.cr[0].eq {
	pc = 0x830F76F0; continue 'dispatch;
	}
	// 830F76EC: 635A0100  ori r26, r26, 0x100
	ctx.r[26].u64 = ctx.r[26].u64 | 256;
	pc = 0x830F76F0; continue 'dispatch;
            }
            0x830F76F0 => {
    //   block [0x830F76F0..0x830F7700)
	// 830F76F0: 56AB06B5  rlwinm. r11, r21, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F76F4: 41820014  beq 0x830f7708
	if ctx.cr[0].eq {
	pc = 0x830F7708; continue 'dispatch;
	}
	// 830F76F8: 675A0800  oris r26, r26, 0x800
	ctx.r[26].u64 = ctx.r[26].u64 | 134217728;
	// 830F76FC: 48000018  b 0x830f7714
	pc = 0x830F7714; continue 'dispatch;
            }
            0x830F7700 => {
    //   block [0x830F7700..0x830F7708)
	// 830F7700: 3BE00005  li r31, 5
	ctx.r[31].s64 = 5;
	// 830F7704: 4BFFFFA8  b 0x830f76ac
	pc = 0x830F76AC; continue 'dispatch;
            }
            0x830F7708 => {
    //   block [0x830F7708..0x830F7714)
	// 830F7708: 56AB06F7  rlwinm. r11, r21, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F770C: 41820008  beq 0x830f7714
	if ctx.cr[0].eq {
	pc = 0x830F7714; continue 'dispatch;
	}
	// 830F7710: 675A1000  oris r26, r26, 0x1000
	ctx.r[26].u64 = ctx.r[26].u64 | 268435456;
	pc = 0x830F7714; continue 'dispatch;
            }
            0x830F7714 => {
    //   block [0x830F7714..0x830F774C)
	// 830F7714: 4BBC7F5D  bl 0x82cbf670
	ctx.lr = 0x830F7718;
	sub_82CBF670(ctx, base);
	// 830F7718: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F771C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830F7720: 409A002C  bne cr6, 0x830f774c
	if !ctx.cr[6].eq {
	pc = 0x830F774C; continue 'dispatch;
	}
	// 830F7724: 4BBBA96D  bl 0x82cb2090
	ctx.lr = 0x830F7728;
	sub_82CB2090(ctx, base);
	// 830F7728: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830F772C: 92E30000  stw r23, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 830F7730: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F7734: 4BBBA925  bl 0x82cb2058
	ctx.lr = 0x830F7738;
	sub_82CB2058(ctx, base);
	// 830F7738: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 830F773C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F7740: 4BBBA919  bl 0x82cb2058
	ctx.lr = 0x830F7744;
	sub_82CB2058(ctx, base);
	// 830F7744: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7748: 480002E0  b 0x830f7a28
	pc = 0x830F7A28; continue 'dispatch;
            }
            0x830F774C => {
    //   block [0x830F774C..0x830F77C4)
	// 830F774C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F7750: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F7754: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F7758: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 830F775C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830F7760: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F7764: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830F7768: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830F776C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830F7770: 48000491  bl 0x830f7c00
	ctx.lr = 0x830F7774;
	sub_830F7C00(ctx, base);
	// 830F7774: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F7778: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 830F777C: 409A008C  bne cr6, 0x830f7808
	if !ctx.cr[6].eq {
	pc = 0x830F7808; continue 'dispatch;
	}
	// 830F7780: 572B0002  rlwinm r11, r25, 0, 0, 1
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7784: 7F0BA040  cmplw cr6, r11, r20
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[20].u32, &mut ctx.xer);
	// 830F7788: 409A003C  bne cr6, 0x830f77c4
	if !ctx.cr[6].eq {
	pc = 0x830F77C4; continue 'dispatch;
	}
	// 830F778C: 56AB07FF  clrlwi. r11, r21, 0x1f
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7790: 41820034  beq 0x830f77c4
	if ctx.cr[0].eq {
	pc = 0x830F77C4; continue 'dispatch;
	}
	// 830F7794: 5739007E  clrlwi r25, r25, 1
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0x7FFFFFFFu64;
	// 830F7798: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F779C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 830F77A0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830F77A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F77A8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830F77AC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830F77B0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830F77B4: 4800044D  bl 0x830f7c00
	ctx.lr = 0x830F77B8;
	sub_830F7C00(ctx, base);
	// 830F77B8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F77BC: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 830F77C0: 409A0048  bne cr6, 0x830f7808
	if !ctx.cr[6].eq {
	pc = 0x830F7808; continue 'dispatch;
	}
	pc = 0x830F77C4; continue 'dispatch;
            }
            0x830F77C4 => {
    //   block [0x830F77C4..0x830F77FC)
	// 830F77C4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F77C8: 3D40834F  lis r10, -0x7cb1
	ctx.r[10].s64 = -2091974656;
	// 830F77CC: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 830F77D0: 394A7760  addi r10, r10, 0x7760
	ctx.r[10].s64 = ctx.r[10].s64 + 30560;
	// 830F77D4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F77D8: 556B3572  rlwinm r11, r11, 6, 0x15, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 830F77DC: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830F77E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F77E4: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F77E8: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830F77EC: 554A003C  rlwinm r10, r10, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830F77F0: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 830F77F4: 4BBCF7BD  bl 0x82cc6fb0
	ctx.lr = 0x830F77F8;
	sub_82CC6FB0(ctx, base);
	// 830F77F8: 4B148D09  bl 0x82240500
	ctx.lr = 0x830F77FC;
	sub_82240500(ctx, base);
	pc = 0x830F77FC; continue 'dispatch;
            }
            0x830F77FC => {
    //   block [0x830F77FC..0x830F7808)
	// 830F77FC: 4BBBA85D  bl 0x82cb2058
	ctx.lr = 0x830F7800;
	sub_82CB2058(ctx, base);
	// 830F7800: 82E30000  lwz r23, 0(r3)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7804: 48000220  b 0x830f7a24
	pc = 0x830F7A24; continue 'dispatch;
            }
            0x830F7808 => {
    //   block [0x830F7808..0x830F78AC)
	// 830F7808: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F780C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7810: 4BBC7B49  bl 0x82cbf358
	ctx.lr = 0x830F7814;
	sub_82CBF358(ctx, base);
	// 830F7814: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7818: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 830F781C: 7D492E70  srawi r9, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 830F7820: 3BEB7760  addi r31, r11, 0x7760
	ctx.r[31].s64 = ctx.r[11].s64 + 30560;
	// 830F7824: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F7828: 554A3572  rlwinm r10, r10, 6, 0x15, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 830F782C: 636B0001  ori r11, r27, 1
	ctx.r[11].u64 = ctx.r[27].u64 | 1;
	// 830F7830: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830F7834: 717E0048  andi. r30, r11, 0x48
	ctx.r[30].u64 = ctx.r[11].u64 & 72;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F7838: 7D29F82E  lwzx r9, r9, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830F783C: 2C1E0000  cmpwi r30, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F7840: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830F7844: 996A0004  stb r11, 4(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 830F7848: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F784C: 7D492E70  srawi r9, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 830F7850: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F7854: 554A3572  rlwinm r10, r10, 6, 0x15, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 830F7858: 7D29F82E  lwzx r9, r9, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830F785C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830F7860: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F7864: 552907FE  clrlwi r9, r9, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 830F7868: 992A0028  stb r9, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[9].u8 ) };
	// 830F786C: 408200A0  bne 0x830f790c
	if !ctx.cr[0].eq {
	pc = 0x830F790C; continue 'dispatch;
	}
	// 830F7870: 556B0631  rlwinm. r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7874: 41820098  beq 0x830f790c
	if ctx.cr[0].eq {
	pc = 0x830F790C; continue 'dispatch;
	}
	// 830F7878: 56AB07BD  rlwinm. r11, r21, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F787C: 41820090  beq 0x830f790c
	if ctx.cr[0].eq {
	pc = 0x830F790C; continue 'dispatch;
	}
	// 830F7880: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830F7884: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7888: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830F788C: 4BBBE34D  bl 0x82cb5bd8
	ctx.lr = 0x830F7890;
	sub_82CB5BD8(ctx, base);
	// 830F7890: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830F7894: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 830F7898: 409A0020  bne cr6, 0x830f78b8
	if !ctx.cr[6].eq {
	pc = 0x830F78B8; continue 'dispatch;
	}
	// 830F789C: 4BBBA7F5  bl 0x82cb2090
	ctx.lr = 0x830F78A0;
	sub_82CB2090(ctx, base);
	// 830F78A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F78A4: 2B0B0083  cmplwi cr6, r11, 0x83
	ctx.cr[6].compare_u32(ctx.r[11].u32, 131 as u32, &mut ctx.xer);
	// 830F78A8: 419A0064  beq cr6, 0x830f790c
	if ctx.cr[6].eq {
	pc = 0x830F790C; continue 'dispatch;
	}
	pc = 0x830F78AC; continue 'dispatch;
            }
            0x830F78AC => {
    //   block [0x830F78AC..0x830F78B8)
	// 830F78AC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F78B0: 4BBBD7F9  bl 0x82cb50a8
	ctx.lr = 0x830F78B4;
	sub_82CB50A8(ctx, base);
	// 830F78B4: 4BFFFF48  b 0x830f77fc
	pc = 0x830F77FC; continue 'dispatch;
            }
            0x830F78B8 => {
    //   block [0x830F78B8..0x830F78F4)
	// 830F78B8: B2E10050  sth r23, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u16 ) };
	// 830F78BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830F78C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F78C4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F78C8: 4BBC50F1  bl 0x82cbc9b8
	ctx.lr = 0x830F78CC;
	sub_82CBC9B8(ctx, base);
	// 830F78CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F78D0: 40820024  bne 0x830f78f4
	if !ctx.cr[0].eq {
	pc = 0x830F78F4; continue 'dispatch;
	}
	// 830F78D4: A1610050  lhz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F78D8: 2B0B001A  cmplwi cr6, r11, 0x1a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 26 as u32, &mut ctx.xer);
	// 830F78DC: 409A0018  bne cr6, 0x830f78f4
	if !ctx.cr[6].eq {
	pc = 0x830F78F4; continue 'dispatch;
	}
	// 830F78E0: 7F6407B4  extsw r4, r27
	ctx.r[4].s64 = ctx.r[27].s32 as i64;
	// 830F78E4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F78E8: 4BBCA251  bl 0x82cc1b38
	ctx.lr = 0x830F78EC;
	sub_82CC1B38(ctx, base);
	// 830F78EC: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830F78F0: 419AFFBC  beq cr6, 0x830f78ac
	if ctx.cr[6].eq {
	pc = 0x830F78AC; continue 'dispatch;
	}
	pc = 0x830F78F4; continue 'dispatch;
            }
            0x830F78F4 => {
    //   block [0x830F78F4..0x830F790C)
	// 830F78F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F78F8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F78FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F7900: 4BBBE2D9  bl 0x82cb5bd8
	ctx.lr = 0x830F7904;
	sub_82CB5BD8(ctx, base);
	// 830F7904: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830F7908: 419AFFA4  beq cr6, 0x830f78ac
	if ctx.cr[6].eq {
	pc = 0x830F78AC; continue 'dispatch;
	}
	pc = 0x830F790C; continue 'dispatch;
            }
            0x830F790C => {
    //   block [0x830F790C..0x830F798C)
	// 830F790C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7910: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F7914: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 830F7918: 556B3572  rlwinm r11, r11, 6, 0x15, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 830F791C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F7920: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830F7924: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F7928: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F792C: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 830F7930: 994B0028  stb r10, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 830F7934: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7938: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 830F793C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F7940: 556B3572  rlwinm r11, r11, 6, 0x15, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 830F7944: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830F7948: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F794C: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F7950: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830F7954: 554A003C  rlwinm r10, r10, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7958: 994B0028  stb r10, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 830F795C: 409A0030  bne cr6, 0x830f798c
	if !ctx.cr[6].eq {
	pc = 0x830F798C; continue 'dispatch;
	}
	// 830F7960: 56AB0739  rlwinm. r11, r21, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7964: 41820028  beq 0x830f798c
	if ctx.cr[0].eq {
	pc = 0x830F798C; continue 'dispatch;
	}
	// 830F7968: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F796C: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 830F7970: 556B3572  rlwinm r11, r11, 6, 0x15, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 830F7974: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F7978: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830F797C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F7980: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F7984: 614A0020  ori r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 32;
	// 830F7988: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	pc = 0x830F798C; continue 'dispatch;
            }
            0x830F798C => {
    //   block [0x830F798C..0x830F7A0C)
	// 830F798C: 572B0002  rlwinm r11, r25, 0, 0, 1
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7990: 7F0BA040  cmplw cr6, r11, r20
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[20].u32, &mut ctx.xer);
	// 830F7994: 409A0090  bne cr6, 0x830f7a24
	if !ctx.cr[6].eq {
	pc = 0x830F7A24; continue 'dispatch;
	}
	// 830F7998: 56AB07FF  clrlwi. r11, r21, 0x1f
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F799C: 41820088  beq 0x830f7a24
	if ctx.cr[0].eq {
	pc = 0x830F7A24; continue 'dispatch;
	}
	// 830F79A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F79A4: 4BBCAE0D  bl 0x82cc27b0
	ctx.lr = 0x830F79A8;
	sub_82CC27B0(ctx, base);
	// 830F79A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F79AC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 830F79B0: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 830F79B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F79B8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830F79BC: 5724007E  clrlwi r4, r25, 1
	ctx.r[4].u64 = ctx.r[25].u32 as u64 & 0x7FFFFFFFu64;
	// 830F79C0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830F79C4: 4800023D  bl 0x830f7c00
	ctx.lr = 0x830F79C8;
	sub_830F7C00(ctx, base);
	// 830F79C8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830F79CC: 409A0040  bne cr6, 0x830f7a0c
	if !ctx.cr[6].eq {
	pc = 0x830F7A0C; continue 'dispatch;
	}
	// 830F79D0: 4BBCF5E1  bl 0x82cc6fb0
	ctx.lr = 0x830F79D4;
	sub_82CC6FB0(ctx, base);
	// 830F79D4: 4B148B2D  bl 0x82240500
	ctx.lr = 0x830F79D8;
	sub_82240500(ctx, base);
	// 830F79D8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F79DC: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 830F79E0: 556B3572  rlwinm r11, r11, 6, 0x15, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 830F79E4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F79E8: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830F79EC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F79F0: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F79F4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830F79F8: 554A003C  rlwinm r10, r10, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830F79FC: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 830F7A00: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7A04: 4BBC79DD  bl 0x82cbf3e0
	ctx.lr = 0x830F7A08;
	sub_82CBF3E0(ctx, base);
	// 830F7A08: 4BFFFDF4  b 0x830f77fc
	pc = 0x830F77FC; continue 'dispatch;
            }
            0x830F7A0C => {
    //   block [0x830F7A0C..0x830F7A24)
	// 830F7A0C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7A10: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 830F7A14: 556B3572  rlwinm r11, r11, 6, 0x15, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 830F7A18: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F7A1C: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830F7A20: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	pc = 0x830F7A24; continue 'dispatch;
            }
            0x830F7A24 => {
    //   block [0x830F7A24..0x830F7A28)
	// 830F7A24: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	pc = 0x830F7A28; continue 'dispatch;
            }
            0x830F7A28 => {
    //   block [0x830F7A28..0x830F7A30)
	// 830F7A28: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830F7A2C: 4BBB1A0C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7A30 size=268
    let mut pc: u32 = 0x830F7A30;
    'dispatch: loop {
        match pc {
            0x830F7A30 => {
    //   block [0x830F7A30..0x830F7A78)
	// 830F7A30: 832B9CA4  lwz r25, -0x635c(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25436 as u32) ) } as u64;
	// 830F7A34: 8210B3E0  lwz r16, -0x4c20(r16)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-19488 as u32) ) } as u64;
	// 830F7A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7A40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F7A44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7A48: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 830F7A4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7A50: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 830F7A54: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 830F7A58: 7FCB0034  cntlzw r11, r30
	ctx.r[11].u64 = if ctx.r[30].u32 == 0 { 32 } else { ctx.r[30].u32.leading_zeros() as u64 };
	// 830F7A5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F7A60: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F7A64: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 830F7A68: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830F7A6C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830F7A70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7A74: 409A0030  bne cr6, 0x830f7aa4
	if !ctx.cr[6].eq {
	pc = 0x830F7AA4; continue 'dispatch;
	}
	pc = 0x830F7A78; continue 'dispatch;
            }
            0x830F7A78 => {
    //   block [0x830F7A78..0x830F7AA4)
	// 830F7A78: 4BBBA5E1  bl 0x82cb2058
	ctx.lr = 0x830F7A7C;
	sub_82CB2058(ctx, base);
	// 830F7A7C: 39600016  li r11, 0x16
	ctx.r[11].s64 = 22;
	// 830F7A80: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F7A84: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F7A88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F7A8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F7A90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F7A94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F7A98: 4BBBA481  bl 0x82cb1f18
	ctx.lr = 0x830F7A9C;
	sub_82CB1F18(ctx, base);
	// 830F7A9C: 38600016  li r3, 0x16
	ctx.r[3].s64 = 22;
	// 830F7AA0: 48000084  b 0x830f7b24
	pc = 0x830F7B24; continue 'dispatch;
            }
            0x830F7AA4 => {
    //   block [0x830F7AA4..0x830F7AD8)
	// 830F7AA4: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830F7AA8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 830F7AAC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F7AB0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F7AB4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830F7AB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7ABC: 419AFFBC  beq cr6, 0x830f7a78
	if ctx.cr[6].eq {
	pc = 0x830F7A78; continue 'dispatch;
	}
	// 830F7AC0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F7AC4: 419A0014  beq cr6, 0x830f7ad8
	if ctx.cr[6].eq {
	pc = 0x830F7AD8; continue 'dispatch;
	}
	// 830F7AC8: 54CB066C  rlwinm r11, r6, 0, 0x19, 0x16
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7ACC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F7AD0: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7AD4: 4182FFA4  beq 0x830f7a78
	if ctx.cr[0].eq {
	pc = 0x830F7A78; continue 'dispatch;
	}
	pc = 0x830F7AD8; continue 'dispatch;
            }
            0x830F7AD8 => {
    //   block [0x830F7AD8..0x830F7B24)
	// 830F7AD8: 60000000  nop
	// 830F7ADC: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 830F7AE0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 830F7AE4: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 830F7AE8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830F7AEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830F7AF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F7AF4: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 830F7AF8: 4BFFFA29  bl 0x830f7520
	ctx.lr = 0x830F7AFC;
	sub_830F7520(ctx, base);
	// 830F7AFC: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 830F7B00: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 830F7B04: 399F0070  addi r12, r31, 0x70
	ctx.r[12].s64 = ctx.r[31].s64 + 112;
	// 830F7B08: 48000055  bl 0x830f7b5c
	ctx.lr = 0x830F7B0C;
	crate::recompiler::externs::call(ctx, base, 0x830F7B5C);
	// 830F7B0C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F7B10: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F7B14: 419A0010  beq cr6, 0x830f7b24
	if ctx.cr[6].eq {
	pc = 0x830F7B24; continue 'dispatch;
	}
	// 830F7B18: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830F7B1C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 830F7B20: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x830F7B24; continue 'dispatch;
            }
            0x830F7B24 => {
    //   block [0x830F7B24..0x830F7B3C)
	// 830F7B24: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 830F7B28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7B2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7B30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F7B34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7B38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F7BE0 size=32
    let mut pc: u32 = 0x830F7BE0;
    'dispatch: loop {
        match pc {
            0x830F7BE0 => {
    //   block [0x830F7BE0..0x830F7C00)
	// 830F7BE0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830F7BE4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830F7BE8: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830F7BEC: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 830F7BF0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830F7BF4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F7BF8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F7BFC: 4BFFFE3C  b 0x830f7a38
	sub_830F7A30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7C00 size=104
    let mut pc: u32 = 0x830F7C00;
    'dispatch: loop {
        match pc {
            0x830F7C00 => {
    //   block [0x830F7C00..0x830F7C68)
	// 830F7C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7C04: 4BBB17F9  bl 0x82ca93fc
	ctx.lr = 0x830F7C08;
	sub_82CA93D0(ctx, base);
	// 830F7C08: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7C0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F7C10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F7C14: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 830F7C18: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830F7C1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830F7C20: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 830F7C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F7C28: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830F7C2C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830F7C30: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 830F7C34: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 830F7C38: 4BBB88C9  bl 0x82cb0500
	ctx.lr = 0x830F7C3C;
	sub_82CB0500(ctx, base);
	// 830F7C3C: 9BE10153  stb r31, 0x153(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(339 as u32), ctx.r[31].u8 ) };
	// 830F7C40: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 830F7C44: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 830F7C48: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830F7C4C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830F7C50: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F7C54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F7C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F7C5C: 4BBCB835  bl 0x82cc3490
	ctx.lr = 0x830F7C60;
	sub_82CC3490(ctx, base);
	// 830F7C60: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 830F7C64: 4BBB17E8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7C68 size=84
    let mut pc: u32 = 0x830F7C68;
    'dispatch: loop {
        match pc {
            0x830F7C68 => {
    //   block [0x830F7C68..0x830F7CBC)
	// 830F7C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7C70: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 830F7C74: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 830F7C78: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 830F7C7C: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 830F7C80: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 830F7C84: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 830F7C88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7C8C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830F7C90: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7C94: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 830F7C98: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F7C9C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7CA0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F7CA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F7CA8: 4E800421  bctrl
	ctx.lr = 0x830F7CAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F7CAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F7CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7CC0 size=92
    let mut pc: u32 = 0x830F7CC0;
    'dispatch: loop {
        match pc {
            0x830F7CC0 => {
    //   block [0x830F7CC0..0x830F7CF8)
	// 830F7CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7CC4: 4BBB1749  bl 0x82ca940c
	ctx.lr = 0x830F7CC8;
	sub_82CA93D0(ctx, base);
	// 830F7CC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7CCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7CD0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F7CD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7CD8: 419A003C  beq cr6, 0x830f7d14
	if ctx.cr[6].eq {
	pc = 0x830F7D14; continue 'dispatch;
	}
	// 830F7CDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F7CE0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F7CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F7CE8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F7CEC: 40990028  ble cr6, 0x830f7d14
	if !ctx.cr[6].gt {
	pc = 0x830F7D14; continue 'dispatch;
	}
	// 830F7CF0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830F7CF4: 3BAB4A00  addi r29, r11, 0x4a00
	ctx.r[29].s64 = ctx.r[11].s64 + 18944;
	pc = 0x830F7CF8; continue 'dispatch;
            }
            0x830F7CF8 => {
    //   block [0x830F7CF8..0x830F7D14)
	// 830F7CF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F7CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7D00: 4BFFFF69  bl 0x830f7c68
	ctx.lr = 0x830F7D04;
	sub_830F7C68(ctx, base);
	// 830F7D04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F7D08: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F7D0C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F7D10: 4198FFE8  blt cr6, 0x830f7cf8
	if ctx.cr[6].lt {
	pc = 0x830F7CF8; continue 'dispatch;
	}
	pc = 0x830F7D14; continue 'dispatch;
            }
            0x830F7D14 => {
    //   block [0x830F7D14..0x830F7D1C)
	// 830F7D14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7D18: 4BBB1744  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7D20 size=112
    let mut pc: u32 = 0x830F7D20;
    'dispatch: loop {
        match pc {
            0x830F7D20 => {
    //   block [0x830F7D20..0x830F7D90)
	// 830F7D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F7D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7D38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F7D3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F7D40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F7D44: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F7D48: 4BFFFF79  bl 0x830f7cc0
	ctx.lr = 0x830F7D4C;
	sub_830F7CC0(ctx, base);
	// 830F7D4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830F7D50: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F7D54: 388B96C4  addi r4, r11, -0x693c
	ctx.r[4].s64 = ctx.r[11].s64 + -26940;
	// 830F7D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7D5C: 4BFFFF0D  bl 0x830f7c68
	ctx.lr = 0x830F7D60;
	sub_830F7C68(ctx, base);
	// 830F7D60: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830F7D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7D68: 388BD400  addi r4, r11, -0x2c00
	ctx.r[4].s64 = ctx.r[11].s64 + -11264;
	// 830F7D6C: 4BFFFEFD  bl 0x830f7c68
	ctx.lr = 0x830F7D70;
	sub_830F7C68(ctx, base);
	// 830F7D70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F7D74: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F7D78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7D7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7D80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7D84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F7D88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7D8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7D90 size=92
    let mut pc: u32 = 0x830F7D90;
    'dispatch: loop {
        match pc {
            0x830F7D90 => {
    //   block [0x830F7D90..0x830F7DEC)
	// 830F7D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7D98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7D9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7DA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7DA4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 830F7DA8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830F7DAC: 388A96C4  addi r4, r10, -0x693c
	ctx.r[4].s64 = ctx.r[10].s64 + -26940;
	// 830F7DB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F7DB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F7DB8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F7DBC: 4BFFFEAD  bl 0x830f7c68
	ctx.lr = 0x830F7DC0;
	sub_830F7C68(ctx, base);
	// 830F7DC0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830F7DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7DC8: 388BD400  addi r4, r11, -0x2c00
	ctx.r[4].s64 = ctx.r[11].s64 + -11264;
	// 830F7DCC: 4BFFFE9D  bl 0x830f7c68
	ctx.lr = 0x830F7DD0;
	sub_830F7C68(ctx, base);
	// 830F7DD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F7DD4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F7DD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F7DDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7DE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F7DF0 size=140
    let mut pc: u32 = 0x830F7DF0;
    'dispatch: loop {
        match pc {
            0x830F7DF0 => {
    //   block [0x830F7DF0..0x830F7E20)
	// 830F7DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7DF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7DFC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830F7E00: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830F7E04: 419A001C  beq cr6, 0x830f7e20
	if ctx.cr[6].eq {
	pc = 0x830F7E20; continue 'dispatch;
	}
	// 830F7E08: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F7E0C: 7CC53A14  add r6, r5, r7
	ctx.r[6].u64 = ctx.r[5].u64 + ctx.r[7].u64;
	// 830F7E10: 388AB128  addi r4, r10, -0x4ed8
	ctx.r[4].s64 = ctx.r[10].s64 + -20184;
	// 830F7E14: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 830F7E18: 4BFFFE51  bl 0x830f7c68
	ctx.lr = 0x830F7E1C;
	sub_830F7C68(ctx, base);
	// 830F7E1C: 48000050  b 0x830f7e6c
	pc = 0x830F7E6C; continue 'dispatch;
            }
            0x830F7E20 => {
    //   block [0x830F7E20..0x830F7E6C)
	// 830F7E20: 54EAF87E  srwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F7E24: 54E907FE  clrlwi r9, r7, 0x1f
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 830F7E28: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830F7E2C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F7E30: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 830F7E34: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F7E38: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 830F7E3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F7E40: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F7E44: C00A0BF8  lfs f0, 0xbf8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7E48: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830F7E4C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830F7E50: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 830F7E54: 388AB134  addi r4, r10, -0x4ecc
	ctx.r[4].s64 = ctx.r[10].s64 + -20172;
	// 830F7E58: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F7E5C: EC2D603A  fmadds f1, f13, f0, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 830F7E60: D8210028  stfd f1, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[1].u64 ) };
	// 830F7E64: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830F7E68: 4BFFFE01  bl 0x830f7c68
	ctx.lr = 0x830F7E6C;
	sub_830F7C68(ctx, base);
	pc = 0x830F7E6C; continue 'dispatch;
            }
            0x830F7E6C => {
    //   block [0x830F7E6C..0x830F7E7C)
	// 830F7E6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F7E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7E78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7E80 size=252
    let mut pc: u32 = 0x830F7E80;
    'dispatch: loop {
        match pc {
            0x830F7E80 => {
    //   block [0x830F7E80..0x830F7EE4)
	// 830F7E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7E84: 4BBB1575  bl 0x82ca93f8
	ctx.lr = 0x830F7E88;
	sub_82CA93D0(ctx, base);
	// 830F7E88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7E8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830F7E90: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830F7E94: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830F7E98: 388BB150  addi r4, r11, -0x4eb0
	ctx.r[4].s64 = ctx.r[11].s64 + -20144;
	// 830F7E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F7EA0: 4BFFFDC9  bl 0x830f7c68
	ctx.lr = 0x830F7EA4;
	sub_830F7C68(ctx, base);
	// 830F7EA4: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7EA8: 7FF8FB78  mr r24, r31
	ctx.r[24].u64 = ctx.r[31].u64;
	// 830F7EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F7EB0: 419A00B4  beq cr6, 0x830f7f64
	if ctx.cr[6].eq {
	pc = 0x830F7F64; continue 'dispatch;
	}
	// 830F7EB4: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 830F7EB8: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 830F7EBC: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 830F7EC0: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 830F7EC4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 830F7EC8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830F7ECC: 3BE93F10  addi r31, r9, 0x3f10
	ctx.r[31].s64 = ctx.r[9].s64 + 16144;
	// 830F7ED0: 3BA8EF84  addi r29, r8, -0x107c
	ctx.r[29].s64 = ctx.r[8].s64 + -4220;
	// 830F7ED4: 3B87D1F4  addi r28, r7, -0x2e0c
	ctx.r[28].s64 = ctx.r[7].s64 + -11788;
	// 830F7ED8: 3B66EF9C  addi r27, r6, -0x1064
	ctx.r[27].s64 = ctx.r[6].s64 + -4196;
	// 830F7EDC: 3B4AEF8C  addi r26, r10, -0x1074
	ctx.r[26].s64 = ctx.r[10].s64 + -4212;
	// 830F7EE0: 3B2BEF94  addi r25, r11, -0x106c
	ctx.r[25].s64 = ctx.r[11].s64 + -4204;
	pc = 0x830F7EE4; continue 'dispatch;
            }
            0x830F7EE4 => {
    //   block [0x830F7EE4..0x830F7F20)
	// 830F7EE4: 89780000  lbz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7EE8: 7D650774  extsb r5, r11
	ctx.r[5].s64 = ctx.r[11].s8 as i64;
	// 830F7EEC: 2F050022  cmpwi cr6, r5, 0x22
	ctx.cr[6].compare_i32(ctx.r[5].s32, 34, &mut ctx.xer);
	// 830F7EF0: 419A0058  beq cr6, 0x830f7f48
	if ctx.cr[6].eq {
	pc = 0x830F7F48; continue 'dispatch;
	}
	// 830F7EF4: 2F050026  cmpwi cr6, r5, 0x26
	ctx.cr[6].compare_i32(ctx.r[5].s32, 38, &mut ctx.xer);
	// 830F7EF8: 419A0048  beq cr6, 0x830f7f40
	if ctx.cr[6].eq {
	pc = 0x830F7F40; continue 'dispatch;
	}
	// 830F7EFC: 2F050027  cmpwi cr6, r5, 0x27
	ctx.cr[6].compare_i32(ctx.r[5].s32, 39, &mut ctx.xer);
	// 830F7F00: 419A0038  beq cr6, 0x830f7f38
	if ctx.cr[6].eq {
	pc = 0x830F7F38; continue 'dispatch;
	}
	// 830F7F04: 2F05003C  cmpwi cr6, r5, 0x3c
	ctx.cr[6].compare_i32(ctx.r[5].s32, 60, &mut ctx.xer);
	// 830F7F08: 419A0020  beq cr6, 0x830f7f28
	if ctx.cr[6].eq {
	pc = 0x830F7F28; continue 'dispatch;
	}
	// 830F7F0C: 2F05003E  cmpwi cr6, r5, 0x3e
	ctx.cr[6].compare_i32(ctx.r[5].s32, 62, &mut ctx.xer);
	// 830F7F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F7F14: 419A000C  beq cr6, 0x830f7f20
	if ctx.cr[6].eq {
	pc = 0x830F7F20; continue 'dispatch;
	}
	// 830F7F18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F7F1C: 48000034  b 0x830f7f50
	pc = 0x830F7F50; continue 'dispatch;
            }
            0x830F7F20 => {
    //   block [0x830F7F20..0x830F7F28)
	// 830F7F20: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F7F24: 4800000C  b 0x830f7f30
	pc = 0x830F7F30; continue 'dispatch;
            }
            0x830F7F28 => {
    //   block [0x830F7F28..0x830F7F2C)
	// 830F7F28: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x830F7F2C; continue 'dispatch;
            }
            0x830F7F2C => {
    //   block [0x830F7F2C..0x830F7F30)
	// 830F7F2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x830F7F30; continue 'dispatch;
            }
            0x830F7F30 => {
    //   block [0x830F7F30..0x830F7F38)
	// 830F7F30: 4BFFFD39  bl 0x830f7c68
	ctx.lr = 0x830F7F34;
	sub_830F7C68(ctx, base);
	// 830F7F34: 48000020  b 0x830f7f54
	pc = 0x830F7F54; continue 'dispatch;
            }
            0x830F7F38 => {
    //   block [0x830F7F38..0x830F7F40)
	// 830F7F38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F7F3C: 4BFFFFF0  b 0x830f7f2c
	pc = 0x830F7F2C; continue 'dispatch;
            }
            0x830F7F40 => {
    //   block [0x830F7F40..0x830F7F48)
	// 830F7F40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F7F44: 4BFFFFE8  b 0x830f7f2c
	pc = 0x830F7F2C; continue 'dispatch;
            }
            0x830F7F48 => {
    //   block [0x830F7F48..0x830F7F50)
	// 830F7F48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F7F4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x830F7F50; continue 'dispatch;
            }
            0x830F7F50 => {
    //   block [0x830F7F50..0x830F7F54)
	// 830F7F50: 4BFFFD19  bl 0x830f7c68
	ctx.lr = 0x830F7F54;
	sub_830F7C68(ctx, base);
	pc = 0x830F7F54; continue 'dispatch;
            }
            0x830F7F54 => {
    //   block [0x830F7F54..0x830F7F64)
	// 830F7F54: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830F7F58: 89780000  lbz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F7F60: 409AFF84  bne cr6, 0x830f7ee4
	if !ctx.cr[6].eq {
	pc = 0x830F7EE4; continue 'dispatch;
	}
	pc = 0x830F7F64; continue 'dispatch;
            }
            0x830F7F64 => {
    //   block [0x830F7F64..0x830F7F7C)
	// 830F7F64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830F7F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F7F6C: 388B4A60  addi r4, r11, 0x4a60
	ctx.r[4].s64 = ctx.r[11].s64 + 19040;
	// 830F7F70: 4BFFFCF9  bl 0x830f7c68
	ctx.lr = 0x830F7F74;
	sub_830F7C68(ctx, base);
	// 830F7F74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F7F78: 4BBB14D0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F7F80 size=48
    let mut pc: u32 = 0x830F7F80;
    'dispatch: loop {
        match pc {
            0x830F7F80 => {
    //   block [0x830F7F80..0x830F7F84)
	// 830F7F80: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x830F7F84; continue 'dispatch;
            }
            0x830F7F84 => {
    //   block [0x830F7F84..0x830F7FB0)
	// 830F7F84: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7F88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F7F8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F7F90: 409AFFF4  bne cr6, 0x830f7f84
	if !ctx.cr[6].eq {
	pc = 0x830F7F84; continue 'dispatch;
	}
	// 830F7F94: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 830F7F98: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7F9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F7FA0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F7FA4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F7FA8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830F7FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F7FB0 size=16
    let mut pc: u32 = 0x830F7FB0;
    'dispatch: loop {
        match pc {
            0x830F7FB0 => {
    //   block [0x830F7FB0..0x830F7FC0)
	// 830F7FB0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7FB4: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 830F7FB8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830F7FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F7FC0 size=100
    let mut pc: u32 = 0x830F7FC0;
    'dispatch: loop {
        match pc {
            0x830F7FC0 => {
    //   block [0x830F7FC0..0x830F7FD4)
	// 830F7FC0: 7D042A14  add r8, r4, r5
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[5].u64;
	// 830F7FC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F7FC8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 830F7FCC: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830F7FD0: 40980044  bge cr6, 0x830f8014
	if !ctx.cr[6].lt {
	pc = 0x830F8014; continue 'dispatch;
	}
	pc = 0x830F7FD4; continue 'dispatch;
            }
            0x830F7FD4 => {
    //   block [0x830F7FD4..0x830F7FEC)
	// 830F7FD4: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7FD8: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 830F7FDC: 2F09003C  cmpwi cr6, r9, 0x3c
	ctx.cr[6].compare_i32(ctx.r[9].s32, 60, &mut ctx.xer);
	// 830F7FE0: 419A000C  beq cr6, 0x830f7fec
	if ctx.cr[6].eq {
	pc = 0x830F7FEC; continue 'dispatch;
	}
	// 830F7FE4: 2F09003E  cmpwi cr6, r9, 0x3e
	ctx.cr[6].compare_i32(ctx.r[9].s32, 62, &mut ctx.xer);
	// 830F7FE8: 409A000C  bne cr6, 0x830f7ff4
	if !ctx.cr[6].eq {
	pc = 0x830F7FF4; continue 'dispatch;
	}
	pc = 0x830F7FEC; continue 'dispatch;
            }
            0x830F7FEC => {
    //   block [0x830F7FEC..0x830F7FF4)
	// 830F7FEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F7FF0: 48000018  b 0x830f8008
	pc = 0x830F8008; continue 'dispatch;
            }
            0x830F7FF4 => {
    //   block [0x830F7FF4..0x830F8004)
	// 830F7FF4: 2F090026  cmpwi cr6, r9, 0x26
	ctx.cr[6].compare_i32(ctx.r[9].s32, 38, &mut ctx.xer);
	// 830F7FF8: 409A000C  bne cr6, 0x830f8004
	if !ctx.cr[6].eq {
	pc = 0x830F8004; continue 'dispatch;
	}
	// 830F7FFC: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 830F8000: 48000008  b 0x830f8008
	pc = 0x830F8008; continue 'dispatch;
            }
            0x830F8004 => {
    //   block [0x830F8004..0x830F8008)
	// 830F8004: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x830F8008; continue 'dispatch;
            }
            0x830F8008 => {
    //   block [0x830F8008..0x830F8014)
	// 830F8008: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F800C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830F8010: 4198FFC4  blt cr6, 0x830f7fd4
	if ctx.cr[6].lt {
	pc = 0x830F7FD4; continue 'dispatch;
	}
	pc = 0x830F8014; continue 'dispatch;
            }
            0x830F8014 => {
    //   block [0x830F8014..0x830F8024)
	// 830F8014: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8018: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F801C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830F8020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8028 size=96
    let mut pc: u32 = 0x830F8028;
    'dispatch: loop {
        match pc {
            0x830F8028 => {
    //   block [0x830F8028..0x830F8068)
	// 830F8028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F802C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F8030: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F8034: 9421FBA0  stwu r1, -0x460(r1)
	ea = ctx.r[1].u32.wrapping_add(-1120 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8038: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830F803C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8040: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830F8044: 38800400  li r4, 0x400
	ctx.r[4].s64 = 1024;
	// 830F8048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F804C: 4BBB94C5  bl 0x82cb1510
	ctx.lr = 0x830F8050;
	sub_82CB1510(ctx, base);
	// 830F8050: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8054: 40800014  bge 0x830f8068
	if !ctx.cr[0].lt {
	pc = 0x830F8068; continue 'dispatch;
	}
	// 830F8058: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830F805C: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 830F8060: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F8064: 48000010  b 0x830f8074
	pc = 0x830F8074; continue 'dispatch;
            }
            0x830F8068 => {
    //   block [0x830F8068..0x830F8074)
	// 830F8068: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F806C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 830F8070: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x830F8074; continue 'dispatch;
            }
            0x830F8074 => {
    //   block [0x830F8074..0x830F8088)
	// 830F8074: 38210460  addi r1, r1, 0x460
	ctx.r[1].s64 = ctx.r[1].s64 + 1120;
	// 830F8078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F807C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F8080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F8084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F8088 size=84
    let mut pc: u32 = 0x830F8088;
    'dispatch: loop {
        match pc {
            0x830F8088 => {
    //   block [0x830F8088..0x830F8098)
	// 830F8088: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F808C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F8090: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 830F8094: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x830F8098; continue 'dispatch;
            }
            0x830F8098 => {
    //   block [0x830F8098..0x830F80DC)
	// 830F8098: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F809C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F80A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F80A4: 409AFFF4  bne cr6, 0x830f8098
	if !ctx.cr[6].eq {
	pc = 0x830F8098; continue 'dispatch;
	}
	// 830F80A8: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 830F80AC: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F80B0: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 830F80B4: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F80B8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F80BC: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F80C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F80C4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F80C8: 40980014  bge cr6, 0x830f80dc
	if !ctx.cr[6].lt {
		sub_830F80DC(ctx, base);
		return;
	}
	// 830F80CC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830F80D0: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 830F80D4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F80D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F80DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F80DC size=84
    let mut pc: u32 = 0x830F80DC;
    'dispatch: loop {
        match pc {
            0x830F80DC => {
    //   block [0x830F80DC..0x830F80E8)
	// 830F80DC: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F80E0: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 830F80E4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	pc = 0x830F80E8; continue 'dispatch;
            }
            0x830F80E8 => {
    //   block [0x830F80E8..0x830F8104)
	// 830F80E8: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F80EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F80F0: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F80F4: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 830F80F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F80FC: 4082FFEC  bne 0x830f80e8
	if !ctx.cr[0].eq {
	pc = 0x830F80E8; continue 'dispatch;
	}
	// 830F8100: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x830F8104; continue 'dispatch;
            }
            0x830F8104 => {
    //   block [0x830F8104..0x830F8130)
	// 830F8104: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8108: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F810C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F8110: 409AFFF4  bne cr6, 0x830f8104
	if !ctx.cr[6].eq {
	pc = 0x830F8104; continue 'dispatch;
	}
	// 830F8114: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 830F8118: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F811C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F8120: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F8124: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F8128: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830F812C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8130 size=124
    let mut pc: u32 = 0x830F8130;
    'dispatch: loop {
        match pc {
            0x830F8130 => {
    //   block [0x830F8130..0x830F817C)
	// 830F8130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F8134: 4BBB12D9  bl 0x82ca940c
	ctx.lr = 0x830F8138;
	sub_82CA93D0(ctx, base);
	// 830F8138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F813C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F8140: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F8144: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8148: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F814C: 41980058  blt cr6, 0x830f81a4
	if ctx.cr[6].lt {
	pc = 0x830F81A4; continue 'dispatch;
	}
	// 830F8150: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F8154: 813D0014  lwz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F8158: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F815C: 7FEB4850  subf r31, r11, r9
	ctx.r[31].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F8160: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F8164: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830F8168: 40990014  ble cr6, 0x830f817c
	if !ctx.cr[6].gt {
	pc = 0x830F817C; continue 'dispatch;
	}
	// 830F816C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830F8170: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 830F8174: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F8178: 4800002C  b 0x830f81a4
	pc = 0x830F81A4; continue 'dispatch;
            }
            0x830F817C => {
    //   block [0x830F817C..0x830F8188)
	// 830F817C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F8180: 41980008  blt cr6, 0x830f8188
	if ctx.cr[6].lt {
	pc = 0x830F8188; continue 'dispatch;
	}
	// 830F8184: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	pc = 0x830F8188; continue 'dispatch;
            }
            0x830F8188 => {
    //   block [0x830F8188..0x830F8198)
	// 830F8188: 4BBB12F9  bl 0x82ca9480
	ctx.lr = 0x830F818C;
	sub_82CA9480(ctx, base);
	// 830F818C: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830F8190: 40980008  bge cr6, 0x830f8198
	if !ctx.cr[6].lt {
	pc = 0x830F8198; continue 'dispatch;
	}
	// 830F8194: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x830F8198; continue 'dispatch;
            }
            0x830F8198 => {
    //   block [0x830F8198..0x830F81A4)
	// 830F8198: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F819C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830F81A0: 917D0018  stw r11, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x830F81A4; continue 'dispatch;
            }
            0x830F81A4 => {
    //   block [0x830F81A4..0x830F81AC)
	// 830F81A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F81A8: 4BBB12B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F81B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F81B0 size=288
    let mut pc: u32 = 0x830F81B0;
    'dispatch: loop {
        match pc {
            0x830F81B0 => {
    //   block [0x830F81B0..0x830F81F0)
	// 830F81B0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 830F81B4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 830F81B8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F81BC: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F81C0: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F81C4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830F81C8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F81CC: 419800DC  blt cr6, 0x830f82a8
	if ctx.cr[6].lt {
	pc = 0x830F82A8; continue 'dispatch;
	}
	// 830F81D0: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F81D4: 7FE42A14  add r31, r4, r5
	ctx.r[31].u64 = ctx.r[4].u64 + ctx.r[5].u64;
	// 830F81D8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830F81DC: 7F04F840  cmplw cr6, r4, r31
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830F81E0: 409800C8  bge cr6, 0x830f82a8
	if !ctx.cr[6].lt {
	pc = 0x830F82A8; continue 'dispatch;
	}
	// 830F81E4: 39000026  li r8, 0x26
	ctx.r[8].s64 = 38;
	// 830F81E8: 38A00074  li r5, 0x74
	ctx.r[5].s64 = 116;
	// 830F81EC: 3920003B  li r9, 0x3b
	ctx.r[9].s64 = 59;
	pc = 0x830F81F0; continue 'dispatch;
            }
            0x830F81F0 => {
    //   block [0x830F81F0..0x830F820C)
	// 830F81F0: 88C40000  lbz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F81F4: 7CC70774  extsb r7, r6
	ctx.r[7].s64 = ctx.r[6].s8 as i64;
	// 830F81F8: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 830F81FC: 409A0034  bne cr6, 0x830f8230
	if !ctx.cr[6].eq {
	pc = 0x830F8230; continue 'dispatch;
	}
	// 830F8200: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 830F8204: 419800BC  blt cr6, 0x830f82c0
	if ctx.cr[6].lt {
	pc = 0x830F82C0; continue 'dispatch;
	}
	// 830F8208: 38E0006C  li r7, 0x6c
	ctx.r[7].s64 = 108;
	pc = 0x830F820C; continue 'dispatch;
            }
            0x830F820C => {
    //   block [0x830F820C..0x830F8224)
	// 830F820C: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 830F8210: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F8214: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 830F8218: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 830F821C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F8220: 98AB0000  stb r5, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	pc = 0x830F8224; continue 'dispatch;
            }
            0x830F8224 => {
    //   block [0x830F8224..0x830F8230)
	// 830F8224: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F8228: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 830F822C: 4800006C  b 0x830f8298
	pc = 0x830F8298; continue 'dispatch;
            }
            0x830F8230 => {
    //   block [0x830F8230..0x830F8248)
	// 830F8230: 2F07003E  cmpwi cr6, r7, 0x3e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 62, &mut ctx.xer);
	// 830F8234: 409A0014  bne cr6, 0x830f8248
	if !ctx.cr[6].eq {
	pc = 0x830F8248; continue 'dispatch;
	}
	// 830F8238: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 830F823C: 41980084  blt cr6, 0x830f82c0
	if ctx.cr[6].lt {
	pc = 0x830F82C0; continue 'dispatch;
	}
	// 830F8240: 38E00067  li r7, 0x67
	ctx.r[7].s64 = 103;
	// 830F8244: 4BFFFFC8  b 0x830f820c
	pc = 0x830F820C; continue 'dispatch;
            }
            0x830F8248 => {
    //   block [0x830F8248..0x830F8288)
	// 830F8248: 2F070026  cmpwi cr6, r7, 0x26
	ctx.cr[6].compare_i32(ctx.r[7].s32, 38, &mut ctx.xer);
	// 830F824C: 409A003C  bne cr6, 0x830f8288
	if !ctx.cr[6].eq {
	pc = 0x830F8288; continue 'dispatch;
	}
	// 830F8250: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 830F8254: 4198006C  blt cr6, 0x830f82c0
	if ctx.cr[6].lt {
	pc = 0x830F82C0; continue 'dispatch;
	}
	// 830F8258: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 830F825C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F8260: 38E00061  li r7, 0x61
	ctx.r[7].s64 = 97;
	// 830F8264: 38C0006D  li r6, 0x6d
	ctx.r[6].s64 = 109;
	// 830F8268: 3BC00070  li r30, 0x70
	ctx.r[30].s64 = 112;
	// 830F826C: 394AFFFB  addi r10, r10, -5
	ctx.r[10].s64 = ctx.r[10].s64 + -5;
	// 830F8270: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 830F8274: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F8278: 98CB0000  stb r6, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 830F827C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F8280: 9BCB0000  stb r30, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 830F8284: 4BFFFFA0  b 0x830f8224
	pc = 0x830F8224; continue 'dispatch;
            }
            0x830F8288 => {
    //   block [0x830F8288..0x830F8298)
	// 830F8288: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830F828C: 41980034  blt cr6, 0x830f82c0
	if ctx.cr[6].lt {
	pc = 0x830F82C0; continue 'dispatch;
	}
	// 830F8290: 98CB0000  stb r6, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 830F8294: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	pc = 0x830F8298; continue 'dispatch;
            }
            0x830F8298 => {
    //   block [0x830F8298..0x830F82A8)
	// 830F8298: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 830F829C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F82A0: 7F04F840  cmplw cr6, r4, r31
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830F82A4: 4198FF4C  blt cr6, 0x830f81f0
	if ctx.cr[6].lt {
	pc = 0x830F81F0; continue 'dispatch;
	}
	pc = 0x830F82A8; continue 'dispatch;
            }
            0x830F82A8 => {
    //   block [0x830F82A8..0x830F82B4)
	// 830F82A8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F82AC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F82B0: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x830F82B4; continue 'dispatch;
            }
            0x830F82B4 => {
    //   block [0x830F82B4..0x830F82C0)
	// 830F82B4: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F82B8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 830F82BC: 4E800020  blr
	return;
            }
            0x830F82C0 => {
    //   block [0x830F82C0..0x830F82D0)
	// 830F82C0: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830F82C4: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 830F82C8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F82CC: 4BFFFFE8  b 0x830f82b4
	pc = 0x830F82B4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F82D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F82D0 size=120
    let mut pc: u32 = 0x830F82D0;
    'dispatch: loop {
        match pc {
            0x830F82D0 => {
    //   block [0x830F82D0..0x830F8328)
	// 830F82D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F82D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F82D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F82DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F82E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F82E4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830F82E8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F82EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F82F0: 41980044  blt cr6, 0x830f8334
	if ctx.cr[6].lt {
	pc = 0x830F8334; continue 'dispatch;
	}
	// 830F82F4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F82F8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830F82FC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8300: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F8304: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F8308: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F830C: 4BBB9205  bl 0x82cb1510
	ctx.lr = 0x830F8310;
	sub_82CB1510(ctx, base);
	// 830F8310: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8314: 40800014  bge 0x830f8328
	if !ctx.cr[0].lt {
	pc = 0x830F8328; continue 'dispatch;
	}
	// 830F8318: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830F831C: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 830F8320: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F8324: 48000010  b 0x830f8334
	pc = 0x830F8334; continue 'dispatch;
            }
            0x830F8328 => {
    //   block [0x830F8328..0x830F8334)
	// 830F8328: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F832C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 830F8330: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x830F8334; continue 'dispatch;
            }
            0x830F8334 => {
    //   block [0x830F8334..0x830F8348)
	// 830F8334: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F8338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F833C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F8340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F8344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F8348 size=16
    let mut pc: u32 = 0x830F8348;
    'dispatch: loop {
        match pc {
            0x830F8348 => {
    //   block [0x830F8348..0x830F8358)
	// 830F8348: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F834C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8350: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F8354: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F8358 size=32
    let mut pc: u32 = 0x830F8358;
    'dispatch: loop {
        match pc {
            0x830F8358 => {
    //   block [0x830F8358..0x830F8378)
	// 830F8358: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F835C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 830F8360: 91430094  stw r10, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 830F8364: 814B0110  lwz r10, 0x110(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) } as u64;
	// 830F8368: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 830F836C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 830F8370: 908B0110  stw r4, 0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[4].u32 ) };
	// 830F8374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F8378 size=16
    let mut pc: u32 = 0x830F8378;
    'dispatch: loop {
        match pc {
            0x830F8378 => {
    //   block [0x830F8378..0x830F8388)
	// 830F8378: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F837C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8380: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F8384: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F8388 size=16
    let mut pc: u32 = 0x830F8388;
    'dispatch: loop {
        match pc {
            0x830F8388 => {
    //   block [0x830F8388..0x830F8398)
	// 830F8388: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F838C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8390: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830F8394: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F8398 size=12
    let mut pc: u32 = 0x830F8398;
    'dispatch: loop {
        match pc {
            0x830F8398 => {
    //   block [0x830F8398..0x830F83A4)
	// 830F8398: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F839C: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830F83A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F83A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F83A8 size=12
    let mut pc: u32 = 0x830F83A8;
    'dispatch: loop {
        match pc {
            0x830F83A8 => {
    //   block [0x830F83A8..0x830F83B4)
	// 830F83A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F83AC: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830F83B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F83B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F83B8 size=140
    let mut pc: u32 = 0x830F83B8;
    'dispatch: loop {
        match pc {
            0x830F83B8 => {
    //   block [0x830F83B8..0x830F83E8)
	// 830F83B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F83BC: 4BBB104D  bl 0x82ca9408
	ctx.lr = 0x830F83C0;
	sub_82CA93D0(ctx, base);
	// 830F83C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F83C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F83C8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F83CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F83D0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F83D4: 40990068  ble cr6, 0x830f843c
	if !ctx.cr[6].gt {
	pc = 0x830F843C; continue 'dispatch;
	}
	// 830F83D8: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F83DC: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F83E0: 40980008  bge cr6, 0x830f83e8
	if !ctx.cr[6].lt {
	pc = 0x830F83E8; continue 'dispatch;
	}
	// 830F83E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x830F83E8; continue 'dispatch;
            }
            0x830F83E8 => {
    //   block [0x830F83E8..0x830F840C)
	// 830F83E8: 1C9E001C  mulli r4, r30, 0x1c
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 830F83EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F83F0: 4800C8B9  bl 0x83104ca8
	ctx.lr = 0x830F83F4;
	sub_83104CA8(ctx, base);
	// 830F83F4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F83F8: 40820014  bne 0x830f840c
	if !ctx.cr[0].eq {
	pc = 0x830F840C; continue 'dispatch;
	}
	// 830F83FC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 830F8400: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 830F8404: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F8408: 48000034  b 0x830f843c
	pc = 0x830F843C; continue 'dispatch;
            }
            0x830F840C => {
    //   block [0x830F840C..0x830F8438)
	// 830F840C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8410: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F8414: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F8418: 419A0020  beq cr6, 0x830f8438
	if ctx.cr[6].eq {
	pc = 0x830F8438; continue 'dispatch;
	}
	// 830F841C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F8424: 1CAB001C  mulli r5, r11, 0x1c
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 830F8428: 4BBB1059  bl 0x82ca9480
	ctx.lr = 0x830F842C;
	sub_82CA9480(ctx, base);
	// 830F842C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8434: 4800C885  bl 0x83104cb8
	ctx.lr = 0x830F8438;
	sub_83104CB8(ctx, base);
	pc = 0x830F8438; continue 'dispatch;
            }
            0x830F8438 => {
    //   block [0x830F8438..0x830F843C)
	// 830F8438: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x830F843C; continue 'dispatch;
            }
            0x830F843C => {
    //   block [0x830F843C..0x830F8444)
	// 830F843C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F8440: 4BBB1018  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8448 size=140
    let mut pc: u32 = 0x830F8448;
    'dispatch: loop {
        match pc {
            0x830F8448 => {
    //   block [0x830F8448..0x830F8478)
	// 830F8448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F844C: 4BBB0FBD  bl 0x82ca9408
	ctx.lr = 0x830F8450;
	sub_82CA93D0(ctx, base);
	// 830F8450: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8458: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F845C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8460: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8464: 40990068  ble cr6, 0x830f84cc
	if !ctx.cr[6].gt {
	pc = 0x830F84CC; continue 'dispatch;
	}
	// 830F8468: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F846C: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F8470: 40980008  bge cr6, 0x830f8478
	if !ctx.cr[6].lt {
	pc = 0x830F8478; continue 'dispatch;
	}
	// 830F8474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x830F8478; continue 'dispatch;
            }
            0x830F8478 => {
    //   block [0x830F8478..0x830F849C)
	// 830F8478: 1C9E0018  mulli r4, r30, 0x18
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 24 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 830F847C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8480: 4800C829  bl 0x83104ca8
	ctx.lr = 0x830F8484;
	sub_83104CA8(ctx, base);
	// 830F8484: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F8488: 40820014  bne 0x830f849c
	if !ctx.cr[0].eq {
	pc = 0x830F849C; continue 'dispatch;
	}
	// 830F848C: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 830F8490: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 830F8494: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F8498: 48000034  b 0x830f84cc
	pc = 0x830F84CC; continue 'dispatch;
            }
            0x830F849C => {
    //   block [0x830F849C..0x830F84C8)
	// 830F849C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F84A0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F84A4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F84A8: 419A0020  beq cr6, 0x830f84c8
	if ctx.cr[6].eq {
	pc = 0x830F84C8; continue 'dispatch;
	}
	// 830F84AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F84B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F84B4: 1CAB0018  mulli r5, r11, 0x18
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 830F84B8: 4BBB0FC9  bl 0x82ca9480
	ctx.lr = 0x830F84BC;
	sub_82CA9480(ctx, base);
	// 830F84BC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F84C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F84C4: 4800C7F5  bl 0x83104cb8
	ctx.lr = 0x830F84C8;
	sub_83104CB8(ctx, base);
	pc = 0x830F84C8; continue 'dispatch;
            }
            0x830F84C8 => {
    //   block [0x830F84C8..0x830F84CC)
	// 830F84C8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x830F84CC; continue 'dispatch;
            }
            0x830F84CC => {
    //   block [0x830F84CC..0x830F84D4)
	// 830F84CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F84D0: 4BBB0F88  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F84D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F84D8 size=140
    let mut pc: u32 = 0x830F84D8;
    'dispatch: loop {
        match pc {
            0x830F84D8 => {
    //   block [0x830F84D8..0x830F8508)
	// 830F84D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F84DC: 4BBB0F2D  bl 0x82ca9408
	ctx.lr = 0x830F84E0;
	sub_82CA93D0(ctx, base);
	// 830F84E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F84E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F84E8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F84EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F84F0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F84F4: 40990068  ble cr6, 0x830f855c
	if !ctx.cr[6].gt {
	pc = 0x830F855C; continue 'dispatch;
	}
	// 830F84F8: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F84FC: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F8500: 40980008  bge cr6, 0x830f8508
	if !ctx.cr[6].lt {
	pc = 0x830F8508; continue 'dispatch;
	}
	// 830F8504: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x830F8508; continue 'dispatch;
            }
            0x830F8508 => {
    //   block [0x830F8508..0x830F852C)
	// 830F8508: 57C42036  slwi r4, r30, 4
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830F850C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8510: 4800C799  bl 0x83104ca8
	ctx.lr = 0x830F8514;
	sub_83104CA8(ctx, base);
	// 830F8514: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F8518: 40820014  bne 0x830f852c
	if !ctx.cr[0].eq {
	pc = 0x830F852C; continue 'dispatch;
	}
	// 830F851C: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 830F8520: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 830F8524: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F8528: 48000034  b 0x830f855c
	pc = 0x830F855C; continue 'dispatch;
            }
            0x830F852C => {
    //   block [0x830F852C..0x830F8558)
	// 830F852C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8530: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F8534: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F8538: 419A0020  beq cr6, 0x830f8558
	if ctx.cr[6].eq {
	pc = 0x830F8558; continue 'dispatch;
	}
	// 830F853C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8540: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F8544: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830F8548: 4BBB0F39  bl 0x82ca9480
	ctx.lr = 0x830F854C;
	sub_82CA9480(ctx, base);
	// 830F854C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8550: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8554: 4800C765  bl 0x83104cb8
	ctx.lr = 0x830F8558;
	sub_83104CB8(ctx, base);
	pc = 0x830F8558; continue 'dispatch;
            }
            0x830F8558 => {
    //   block [0x830F8558..0x830F855C)
	// 830F8558: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x830F855C; continue 'dispatch;
            }
            0x830F855C => {
    //   block [0x830F855C..0x830F8564)
	// 830F855C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F8560: 4BBB0EF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8568 size=140
    let mut pc: u32 = 0x830F8568;
    'dispatch: loop {
        match pc {
            0x830F8568 => {
    //   block [0x830F8568..0x830F8598)
	// 830F8568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F856C: 4BBB0E9D  bl 0x82ca9408
	ctx.lr = 0x830F8570;
	sub_82CA93D0(ctx, base);
	// 830F8570: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8578: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F857C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8580: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8584: 40990068  ble cr6, 0x830f85ec
	if !ctx.cr[6].gt {
	pc = 0x830F85EC; continue 'dispatch;
	}
	// 830F8588: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F858C: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F8590: 40980008  bge cr6, 0x830f8598
	if !ctx.cr[6].lt {
	pc = 0x830F8598; continue 'dispatch;
	}
	// 830F8594: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x830F8598; continue 'dispatch;
            }
            0x830F8598 => {
    //   block [0x830F8598..0x830F85BC)
	// 830F8598: 1C9E000C  mulli r4, r30, 0xc
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 830F859C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F85A0: 4800C709  bl 0x83104ca8
	ctx.lr = 0x830F85A4;
	sub_83104CA8(ctx, base);
	// 830F85A4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F85A8: 40820014  bne 0x830f85bc
	if !ctx.cr[0].eq {
	pc = 0x830F85BC; continue 'dispatch;
	}
	// 830F85AC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 830F85B0: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 830F85B4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F85B8: 48000034  b 0x830f85ec
	pc = 0x830F85EC; continue 'dispatch;
            }
            0x830F85BC => {
    //   block [0x830F85BC..0x830F85E8)
	// 830F85BC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F85C0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F85C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F85C8: 419A0020  beq cr6, 0x830f85e8
	if ctx.cr[6].eq {
	pc = 0x830F85E8; continue 'dispatch;
	}
	// 830F85CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F85D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F85D4: 1CAB000C  mulli r5, r11, 0xc
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 830F85D8: 4BBB0EA9  bl 0x82ca9480
	ctx.lr = 0x830F85DC;
	sub_82CA9480(ctx, base);
	// 830F85DC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F85E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F85E4: 4800C6D5  bl 0x83104cb8
	ctx.lr = 0x830F85E8;
	sub_83104CB8(ctx, base);
	pc = 0x830F85E8; continue 'dispatch;
            }
            0x830F85E8 => {
    //   block [0x830F85E8..0x830F85EC)
	// 830F85E8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x830F85EC; continue 'dispatch;
            }
            0x830F85EC => {
    //   block [0x830F85EC..0x830F85F4)
	// 830F85EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F85F0: 4BBB0E68  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F85F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F85F8 size=140
    let mut pc: u32 = 0x830F85F8;
    'dispatch: loop {
        match pc {
            0x830F85F8 => {
    //   block [0x830F85F8..0x830F8628)
	// 830F85F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F85FC: 4BBB0E0D  bl 0x82ca9408
	ctx.lr = 0x830F8600;
	sub_82CA93D0(ctx, base);
	// 830F8600: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8604: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8608: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F860C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8610: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8614: 40990068  ble cr6, 0x830f867c
	if !ctx.cr[6].gt {
	pc = 0x830F867C; continue 'dispatch;
	}
	// 830F8618: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F861C: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F8620: 40980008  bge cr6, 0x830f8628
	if !ctx.cr[6].lt {
	pc = 0x830F8628; continue 'dispatch;
	}
	// 830F8624: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x830F8628; continue 'dispatch;
            }
            0x830F8628 => {
    //   block [0x830F8628..0x830F864C)
	// 830F8628: 1C9E0014  mulli r4, r30, 0x14
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 20 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 830F862C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8630: 4800C679  bl 0x83104ca8
	ctx.lr = 0x830F8634;
	sub_83104CA8(ctx, base);
	// 830F8634: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F8638: 40820014  bne 0x830f864c
	if !ctx.cr[0].eq {
	pc = 0x830F864C; continue 'dispatch;
	}
	// 830F863C: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 830F8640: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 830F8644: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F8648: 48000034  b 0x830f867c
	pc = 0x830F867C; continue 'dispatch;
            }
            0x830F864C => {
    //   block [0x830F864C..0x830F8678)
	// 830F864C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8650: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F8654: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F8658: 419A0020  beq cr6, 0x830f8678
	if ctx.cr[6].eq {
	pc = 0x830F8678; continue 'dispatch;
	}
	// 830F865C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8660: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F8664: 1CAB0014  mulli r5, r11, 0x14
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 830F8668: 4BBB0E19  bl 0x82ca9480
	ctx.lr = 0x830F866C;
	sub_82CA9480(ctx, base);
	// 830F866C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8674: 4800C645  bl 0x83104cb8
	ctx.lr = 0x830F8678;
	sub_83104CB8(ctx, base);
	pc = 0x830F8678; continue 'dispatch;
            }
            0x830F8678 => {
    //   block [0x830F8678..0x830F867C)
	// 830F8678: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x830F867C; continue 'dispatch;
            }
            0x830F867C => {
    //   block [0x830F867C..0x830F8684)
	// 830F867C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F8680: 4BBB0DD8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8688 size=140
    let mut pc: u32 = 0x830F8688;
    'dispatch: loop {
        match pc {
            0x830F8688 => {
    //   block [0x830F8688..0x830F86B8)
	// 830F8688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F868C: 4BBB0D7D  bl 0x82ca9408
	ctx.lr = 0x830F8690;
	sub_82CA93D0(ctx, base);
	// 830F8690: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8694: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8698: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F869C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F86A0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F86A4: 40990068  ble cr6, 0x830f870c
	if !ctx.cr[6].gt {
	pc = 0x830F870C; continue 'dispatch;
	}
	// 830F86A8: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F86AC: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F86B0: 40980008  bge cr6, 0x830f86b8
	if !ctx.cr[6].lt {
	pc = 0x830F86B8; continue 'dispatch;
	}
	// 830F86B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x830F86B8; continue 'dispatch;
            }
            0x830F86B8 => {
    //   block [0x830F86B8..0x830F86DC)
	// 830F86B8: 57C4083C  slwi r4, r30, 1
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830F86BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F86C0: 4800C5E9  bl 0x83104ca8
	ctx.lr = 0x830F86C4;
	sub_83104CA8(ctx, base);
	// 830F86C4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F86C8: 40820014  bne 0x830f86dc
	if !ctx.cr[0].eq {
	pc = 0x830F86DC; continue 'dispatch;
	}
	// 830F86CC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 830F86D0: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 830F86D4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F86D8: 48000034  b 0x830f870c
	pc = 0x830F870C; continue 'dispatch;
            }
            0x830F86DC => {
    //   block [0x830F86DC..0x830F8708)
	// 830F86DC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F86E0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F86E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F86E8: 419A0020  beq cr6, 0x830f8708
	if ctx.cr[6].eq {
	pc = 0x830F8708; continue 'dispatch;
	}
	// 830F86EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F86F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F86F4: 5565083C  slwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830F86F8: 4BBB0D89  bl 0x82ca9480
	ctx.lr = 0x830F86FC;
	sub_82CA9480(ctx, base);
	// 830F86FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8700: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8704: 4800C5B5  bl 0x83104cb8
	ctx.lr = 0x830F8708;
	sub_83104CB8(ctx, base);
	pc = 0x830F8708; continue 'dispatch;
            }
            0x830F8708 => {
    //   block [0x830F8708..0x830F870C)
	// 830F8708: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x830F870C; continue 'dispatch;
            }
            0x830F870C => {
    //   block [0x830F870C..0x830F8714)
	// 830F870C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F8710: 4BBB0D48  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8718 size=140
    let mut pc: u32 = 0x830F8718;
    'dispatch: loop {
        match pc {
            0x830F8718 => {
    //   block [0x830F8718..0x830F8748)
	// 830F8718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F871C: 4BBB0CED  bl 0x82ca9408
	ctx.lr = 0x830F8720;
	sub_82CA93D0(ctx, base);
	// 830F8720: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8728: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F872C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8730: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8734: 40990068  ble cr6, 0x830f879c
	if !ctx.cr[6].gt {
	pc = 0x830F879C; continue 'dispatch;
	}
	// 830F8738: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F873C: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F8740: 40980008  bge cr6, 0x830f8748
	if !ctx.cr[6].lt {
	pc = 0x830F8748; continue 'dispatch;
	}
	// 830F8744: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x830F8748; continue 'dispatch;
            }
            0x830F8748 => {
    //   block [0x830F8748..0x830F876C)
	// 830F8748: 1C9E0114  mulli r4, r30, 0x114
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 276 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 830F874C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8750: 4800C559  bl 0x83104ca8
	ctx.lr = 0x830F8754;
	sub_83104CA8(ctx, base);
	// 830F8754: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F8758: 40820014  bne 0x830f876c
	if !ctx.cr[0].eq {
	pc = 0x830F876C; continue 'dispatch;
	}
	// 830F875C: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 830F8760: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 830F8764: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F8768: 48000034  b 0x830f879c
	pc = 0x830F879C; continue 'dispatch;
            }
            0x830F876C => {
    //   block [0x830F876C..0x830F8798)
	// 830F876C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8770: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F8774: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F8778: 419A0020  beq cr6, 0x830f8798
	if ctx.cr[6].eq {
	pc = 0x830F8798; continue 'dispatch;
	}
	// 830F877C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8780: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F8784: 1CAB0114  mulli r5, r11, 0x114
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 276 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 830F8788: 4BBB0CF9  bl 0x82ca9480
	ctx.lr = 0x830F878C;
	sub_82CA9480(ctx, base);
	// 830F878C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8794: 4800C525  bl 0x83104cb8
	ctx.lr = 0x830F8798;
	sub_83104CB8(ctx, base);
	pc = 0x830F8798; continue 'dispatch;
            }
            0x830F8798 => {
    //   block [0x830F8798..0x830F879C)
	// 830F8798: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x830F879C; continue 'dispatch;
            }
            0x830F879C => {
    //   block [0x830F879C..0x830F87A4)
	// 830F879C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F87A0: 4BBB0CB8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F87A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F87A8 size=140
    let mut pc: u32 = 0x830F87A8;
    'dispatch: loop {
        match pc {
            0x830F87A8 => {
    //   block [0x830F87A8..0x830F87D8)
	// 830F87A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F87AC: 4BBB0C5D  bl 0x82ca9408
	ctx.lr = 0x830F87B0;
	sub_82CA93D0(ctx, base);
	// 830F87B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F87B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F87B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F87BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F87C0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F87C4: 40990068  ble cr6, 0x830f882c
	if !ctx.cr[6].gt {
	pc = 0x830F882C; continue 'dispatch;
	}
	// 830F87C8: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830F87CC: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830F87D0: 40980008  bge cr6, 0x830f87d8
	if !ctx.cr[6].lt {
	pc = 0x830F87D8; continue 'dispatch;
	}
	// 830F87D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x830F87D8; continue 'dispatch;
            }
            0x830F87D8 => {
    //   block [0x830F87D8..0x830F87FC)
	// 830F87D8: 1C9E01DC  mulli r4, r30, 0x1dc
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 476 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 830F87DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F87E0: 4800C4C9  bl 0x83104ca8
	ctx.lr = 0x830F87E4;
	sub_83104CA8(ctx, base);
	// 830F87E4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F87E8: 40820014  bne 0x830f87fc
	if !ctx.cr[0].eq {
	pc = 0x830F87FC; continue 'dispatch;
	}
	// 830F87EC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 830F87F0: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 830F87F4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F87F8: 48000034  b 0x830f882c
	pc = 0x830F882C; continue 'dispatch;
            }
            0x830F87FC => {
    //   block [0x830F87FC..0x830F8828)
	// 830F87FC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8800: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F8804: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F8808: 419A0020  beq cr6, 0x830f8828
	if ctx.cr[6].eq {
	pc = 0x830F8828; continue 'dispatch;
	}
	// 830F880C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8810: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F8814: 1CAB01DC  mulli r5, r11, 0x1dc
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 476 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 830F8818: 4BBB0C69  bl 0x82ca9480
	ctx.lr = 0x830F881C;
	sub_82CA9480(ctx, base);
	// 830F881C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8824: 4800C495  bl 0x83104cb8
	ctx.lr = 0x830F8828;
	sub_83104CB8(ctx, base);
	pc = 0x830F8828; continue 'dispatch;
            }
            0x830F8828 => {
    //   block [0x830F8828..0x830F882C)
	// 830F8828: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x830F882C; continue 'dispatch;
            }
            0x830F882C => {
    //   block [0x830F882C..0x830F8834)
	// 830F882C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F8830: 4BBB0C28  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


