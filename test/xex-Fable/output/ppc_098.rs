pub fn sub_82A9E048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A9E048 size=80
    let mut pc: u32 = 0x82A9E048;
    'dispatch: loop {
        match pc {
            0x82A9E048 => {
    //   block [0x82A9E048..0x82A9E068)
	// 82A9E048: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E04C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A9E050: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A9E054: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A9E058: 892A001D  lbz r9, 0x1d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(29 as u32) ) } as u64;
	// 82A9E05C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A9E060: 409A0008  bne cr6, 0x82a9e068
	if !ctx.cr[6].eq {
	pc = 0x82A9E068; continue 'dispatch;
	}
	// 82A9E064: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A9E068; continue 'dispatch;
            }
            0x82A9E068 => {
    //   block [0x82A9E068..0x82A9E098)
	// 82A9E068: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A9E06C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E070: 390A5188  addi r8, r10, 0x5188
	ctx.r[8].s64 = ctx.r[10].s64 + 20872;
	// 82A9E074: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A9E078: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E07C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E080: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A9E084: 409A0014  bne cr6, 0x82a9e098
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A9E098);
		return;
	}
	// 82A9E088: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A9E08C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A9E090: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A9E094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9E0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9E0C8 size=372
    let mut pc: u32 = 0x82A9E0C8;
    'dispatch: loop {
        match pc {
            0x82A9E0C8 => {
    //   block [0x82A9E0C8..0x82A9E0F4)
	// 82A9E0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9E0CC: 4820B325  bl 0x82ca93f0
	ctx.lr = 0x82A9E0D0;
	sub_82CA93D0(ctx, base);
	// 82A9E0D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9E0D4: F86100C0  std r3, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[3].u64 ) };
	// 82A9E0D8: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82A9E0DC: F8A100D0  std r5, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[5].u64 ) };
	// 82A9E0E0: F8C100D8  std r6, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[6].u64 ) };
	// 82A9E0E4: 82C100DC  lwz r22, 0xdc(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A9E0E8: 82E100D8  lwz r23, 0xd8(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 82A9E0EC: 832100CC  lwz r25, 0xcc(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A9E0F0: 830100C8  lwz r24, 0xc8(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	pc = 0x82A9E0F4; continue 'dispatch;
            }
            0x82A9E0F4 => {
    //   block [0x82A9E0F4..0x82A9E108)
	// 82A9E0F4: 814100C0  lwz r10, 0xc0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A9E0F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A9E0FC: 419A000C  beq cr6, 0x82a9e108
	if ctx.cr[6].eq {
	pc = 0x82A9E108; continue 'dispatch;
	}
	// 82A9E100: 7F0AC040  cmplw cr6, r10, r24
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A9E104: 419A0008  beq cr6, 0x82a9e10c
	if ctx.cr[6].eq {
	pc = 0x82A9E10C; continue 'dispatch;
	}
	pc = 0x82A9E108; continue 'dispatch;
            }
            0x82A9E108 => {
    //   block [0x82A9E108..0x82A9E10C)
	// 82A9E108: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E10C; continue 'dispatch;
            }
            0x82A9E10C => {
    //   block [0x82A9E10C..0x82A9E130)
	// 82A9E10C: 838100C4  lwz r28, 0xc4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A9E110: 834100D4  lwz r26, 0xd4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A9E114: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A9E118: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A9E11C: 419A00D4  beq cr6, 0x82a9e1f0
	if ctx.cr[6].eq {
	pc = 0x82A9E1F0; continue 'dispatch;
	}
	// 82A9E120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E124: 419A000C  beq cr6, 0x82a9e130
	if ctx.cr[6].eq {
	pc = 0x82A9E130; continue 'dispatch;
	}
	// 82A9E128: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82A9E12C: 419A0008  beq cr6, 0x82a9e134
	if ctx.cr[6].eq {
	pc = 0x82A9E134; continue 'dispatch;
	}
	pc = 0x82A9E130; continue 'dispatch;
            }
            0x82A9E130 => {
    //   block [0x82A9E130..0x82A9E134)
	// 82A9E130: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E134; continue 'dispatch;
            }
            0x82A9E134 => {
    //   block [0x82A9E134..0x82A9E148)
	// 82A9E134: 7F1AB040  cmplw cr6, r26, r22
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82A9E138: 419A00B8  beq cr6, 0x82a9e1f0
	if ctx.cr[6].eq {
	pc = 0x82A9E1F0; continue 'dispatch;
	}
	// 82A9E13C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E140: 409A0008  bne cr6, 0x82a9e148
	if !ctx.cr[6].eq {
	pc = 0x82A9E148; continue 'dispatch;
	}
	// 82A9E144: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E148; continue 'dispatch;
            }
            0x82A9E148 => {
    //   block [0x82A9E148..0x82A9E158)
	// 82A9E148: 836B0004  lwz r27, 4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E14C: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A9E150: 409A0008  bne cr6, 0x82a9e158
	if !ctx.cr[6].eq {
	pc = 0x82A9E158; continue 'dispatch;
	}
	// 82A9E154: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E158; continue 'dispatch;
            }
            0x82A9E158 => {
    //   block [0x82A9E158..0x82A9E168)
	// 82A9E158: 3BBA000C  addi r29, r26, 0xc
	ctx.r[29].s64 = ctx.r[26].s64 + 12;
	// 82A9E15C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A9E160: 409A0008  bne cr6, 0x82a9e168
	if !ctx.cr[6].eq {
	pc = 0x82A9E168; continue 'dispatch;
	}
	// 82A9E164: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E168; continue 'dispatch;
            }
            0x82A9E168 => {
    //   block [0x82A9E168..0x82A9E178)
	// 82A9E168: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E16C: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A9E170: 409A0008  bne cr6, 0x82a9e178
	if !ctx.cr[6].eq {
	pc = 0x82A9E178; continue 'dispatch;
	}
	// 82A9E174: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E178; continue 'dispatch;
            }
            0x82A9E178 => {
    //   block [0x82A9E178..0x82A9E1A0)
	// 82A9E178: 3BDC000C  addi r30, r28, 0xc
	ctx.r[30].s64 = ctx.r[28].s64 + 12;
	// 82A9E17C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9E180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9E184: 480000BD  bl 0x82a9e240
	ctx.lr = 0x82A9E188;
	sub_82A9E240(ctx, base);
	// 82A9E188: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A9E18C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E190: 409A0048  bne cr6, 0x82a9e1d8
	if !ctx.cr[6].eq {
	pc = 0x82A9E1D8; continue 'dispatch;
	}
	// 82A9E194: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A9E198: 409A0008  bne cr6, 0x82a9e1a0
	if !ctx.cr[6].eq {
	pc = 0x82A9E1A0; continue 'dispatch;
	}
	// 82A9E19C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E1A0; continue 'dispatch;
            }
            0x82A9E1A0 => {
    //   block [0x82A9E1A0..0x82A9E1AC)
	// 82A9E1A0: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A9E1A4: 409A0008  bne cr6, 0x82a9e1ac
	if !ctx.cr[6].eq {
	pc = 0x82A9E1AC; continue 'dispatch;
	}
	// 82A9E1A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E1AC; continue 'dispatch;
            }
            0x82A9E1AC => {
    //   block [0x82A9E1AC..0x82A9E1D8)
	// 82A9E1AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A9E1B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A9E1B4: 4800008D  bl 0x82a9e240
	ctx.lr = 0x82A9E1B8;
	sub_82A9E240(ctx, base);
	// 82A9E1B8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A9E1BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E1C0: 409A0024  bne cr6, 0x82a9e1e4
	if !ctx.cr[6].eq {
	pc = 0x82A9E1E4; continue 'dispatch;
	}
	// 82A9E1C4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A9E1C8: 4BAB8691  bl 0x82556858
	ctx.lr = 0x82A9E1CC;
	sub_82556858(ctx, base);
	// 82A9E1CC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A9E1D0: 4BAB8689  bl 0x82556858
	ctx.lr = 0x82A9E1D4;
	sub_82556858(ctx, base);
	// 82A9E1D4: 4BFFFF20  b 0x82a9e0f4
	pc = 0x82A9E0F4; continue 'dispatch;
            }
            0x82A9E1D8 => {
    //   block [0x82A9E1D8..0x82A9E1E4)
	// 82A9E1D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A9E1DC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A9E1E0: 4820B260  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A9E1E4 => {
    //   block [0x82A9E1E4..0x82A9E1F0)
	// 82A9E1E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A9E1E8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A9E1EC: 4820B254  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A9E1F0 => {
    //   block [0x82A9E1F0..0x82A9E200)
	// 82A9E1F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A9E1F4: 419A000C  beq cr6, 0x82a9e200
	if ctx.cr[6].eq {
	pc = 0x82A9E200; continue 'dispatch;
	}
	// 82A9E1F8: 7F0AC040  cmplw cr6, r10, r24
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A9E1FC: 419A0008  beq cr6, 0x82a9e204
	if ctx.cr[6].eq {
	pc = 0x82A9E204; continue 'dispatch;
	}
	pc = 0x82A9E200; continue 'dispatch;
            }
            0x82A9E200 => {
    //   block [0x82A9E200..0x82A9E204)
	// 82A9E200: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E204; continue 'dispatch;
            }
            0x82A9E204 => {
    //   block [0x82A9E204..0x82A9E21C)
	// 82A9E204: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A9E208: 409A0024  bne cr6, 0x82a9e22c
	if !ctx.cr[6].eq {
	pc = 0x82A9E22C; continue 'dispatch;
	}
	// 82A9E20C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E210: 419A000C  beq cr6, 0x82a9e21c
	if ctx.cr[6].eq {
	pc = 0x82A9E21C; continue 'dispatch;
	}
	// 82A9E214: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82A9E218: 419A0008  beq cr6, 0x82a9e220
	if ctx.cr[6].eq {
	pc = 0x82A9E220; continue 'dispatch;
	}
	pc = 0x82A9E21C; continue 'dispatch;
            }
            0x82A9E21C => {
    //   block [0x82A9E21C..0x82A9E220)
	// 82A9E21C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A9E220; continue 'dispatch;
            }
            0x82A9E220 => {
    //   block [0x82A9E220..0x82A9E22C)
	// 82A9E220: 7F1AB040  cmplw cr6, r26, r22
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82A9E224: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A9E228: 409A0008  bne cr6, 0x82a9e230
	if !ctx.cr[6].eq {
	pc = 0x82A9E230; continue 'dispatch;
	}
	pc = 0x82A9E22C; continue 'dispatch;
            }
            0x82A9E22C => {
    //   block [0x82A9E22C..0x82A9E230)
	// 82A9E22C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A9E230; continue 'dispatch;
            }
            0x82A9E230 => {
    //   block [0x82A9E230..0x82A9E23C)
	// 82A9E230: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A9E234: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A9E238: 4820B208  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9E240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9E240 size=236
    let mut pc: u32 = 0x82A9E240;
    'dispatch: loop {
        match pc {
            0x82A9E240 => {
    //   block [0x82A9E240..0x82A9E26C)
	// 82A9E240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9E244: 4820B1C5  bl 0x82ca9408
	ctx.lr = 0x82A9E248;
	sub_82CA93D0(ctx, base);
	// 82A9E248: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9E24C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A9E250: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A9E254: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E258: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E25C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A9E260: 409A000C  bne cr6, 0x82a9e26c
	if !ctx.cr[6].eq {
	pc = 0x82A9E26C; continue 'dispatch;
	}
	// 82A9E264: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A9E268: 4800003C  b 0x82a9e2a4
	pc = 0x82A9E2A4; continue 'dispatch;
            }
            0x82A9E26C => {
    //   block [0x82A9E26C..0x82A9E27C)
	// 82A9E26C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A9E270: 409A000C  bne cr6, 0x82a9e27c
	if !ctx.cr[6].eq {
	pc = 0x82A9E27C; continue 'dispatch;
	}
	// 82A9E274: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A9E278: 4800002C  b 0x82a9e2a4
	pc = 0x82A9E2A4; continue 'dispatch;
            }
            0x82A9E27C => {
    //   block [0x82A9E27C..0x82A9E28C)
	// 82A9E27C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A9E280: 409A000C  bne cr6, 0x82a9e28c
	if !ctx.cr[6].eq {
	pc = 0x82A9E28C; continue 'dispatch;
	}
	// 82A9E284: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A9E288: 4800001C  b 0x82a9e2a4
	pc = 0x82A9E2A4; continue 'dispatch;
            }
            0x82A9E28C => {
    //   block [0x82A9E28C..0x82A9E2A4)
	// 82A9E28C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E290: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E294: 4B7CF565  bl 0x8226d7f8
	ctx.lr = 0x82A9E298;
	sub_8226D7F8(ctx, base);
	// 82A9E298: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82A9E29C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A9E2A0: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x82A9E2A4; continue 'dispatch;
            }
            0x82A9E2A4 => {
    //   block [0x82A9E2A4..0x82A9E2C8)
	// 82A9E2A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A9E2A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E2AC: 409A0070  bne cr6, 0x82a9e31c
	if !ctx.cr[6].eq {
	pc = 0x82A9E31C; continue 'dispatch;
	}
	// 82A9E2B0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A9E2B4: 419A003C  beq cr6, 0x82a9e2f0
	if ctx.cr[6].eq {
	pc = 0x82A9E2F0; continue 'dispatch;
	}
	// 82A9E2B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A9E2BC: 409A000C  bne cr6, 0x82a9e2c8
	if !ctx.cr[6].eq {
	pc = 0x82A9E2C8; continue 'dispatch;
	}
	// 82A9E2C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A9E2C4: 4800002C  b 0x82a9e2f0
	pc = 0x82A9E2F0; continue 'dispatch;
            }
            0x82A9E2C8 => {
    //   block [0x82A9E2C8..0x82A9E2D8)
	// 82A9E2C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A9E2CC: 409A000C  bne cr6, 0x82a9e2d8
	if !ctx.cr[6].eq {
	pc = 0x82A9E2D8; continue 'dispatch;
	}
	// 82A9E2D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A9E2D4: 4800001C  b 0x82a9e2f0
	pc = 0x82A9E2F0; continue 'dispatch;
            }
            0x82A9E2D8 => {
    //   block [0x82A9E2D8..0x82A9E2F0)
	// 82A9E2D8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E2DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E2E0: 4B7CF519  bl 0x8226d7f8
	ctx.lr = 0x82A9E2E4;
	sub_8226D7F8(ctx, base);
	// 82A9E2E4: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82A9E2E8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A9E2EC: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x82A9E2F0; continue 'dispatch;
            }
            0x82A9E2F0 => {
    //   block [0x82A9E2F0..0x82A9E30C)
	// 82A9E2F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A9E2F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E2F8: 409A0014  bne cr6, 0x82a9e30c
	if !ctx.cr[6].eq {
	pc = 0x82A9E30C; continue 'dispatch;
	}
	// 82A9E2FC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E300: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E304: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A9E308: 41980014  blt cr6, 0x82a9e31c
	if ctx.cr[6].lt {
	pc = 0x82A9E31C; continue 'dispatch;
	}
	pc = 0x82A9E30C; continue 'dispatch;
            }
            0x82A9E30C => {
    //   block [0x82A9E30C..0x82A9E31C)
	// 82A9E30C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A9E310: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A9E314: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A9E318: 4820B140  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A9E31C => {
    //   block [0x82A9E31C..0x82A9E32C)
	// 82A9E31C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A9E320: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A9E324: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A9E328: 4820B130  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9E330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9E330 size=832
    let mut pc: u32 = 0x82A9E330;
    'dispatch: loop {
        match pc {
            0x82A9E330 => {
    //   block [0x82A9E330..0x82A9E368)
	// 82A9E330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9E334: 4820B0D5  bl 0x82ca9408
	ctx.lr = 0x82A9E338;
	sub_82CA93D0(ctx, base);
	// 82A9E338: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9E33C: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82A9E340: 89686F07  lbz r11, 0x6f07(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(28423 as u32) ) } as u64;
	// 82A9E344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E348: 409A0320  bne cr6, 0x82a9e668
	if !ctx.cr[6].eq {
	pc = 0x82A9E668; continue 'dispatch;
	}
	// 82A9E34C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A9E350: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82A9E354: 3BEB51A0  addi r31, r11, 0x51a0
	ctx.r[31].s64 = ctx.r[11].s64 + 20896;
	// 82A9E358: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82A9E35C: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 82A9E360: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A9E364: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82A9E368; continue 'dispatch;
            }
            0x82A9E368 => {
    //   block [0x82A9E368..0x82A9E3E4)
	// 82A9E368: 938BFFF4  stw r28, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[28].u32 ) };
	// 82A9E36C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A9E370: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A9E374: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A9E378: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A9E37C: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82A9E380: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82A9E384: 4082FFE4  bne 0x82a9e368
	if !ctx.cr[0].eq {
	pc = 0x82A9E368; continue 'dispatch;
	}
	// 82A9E388: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A9E38C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82A9E390: 99686F07  stb r11, 0x6f07(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(28423 as u32), ctx.r[11].u8 ) };
	// 82A9E394: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82A9E398: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A9E39C: 997F0064  stb r11, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 82A9E3A0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A9E3A4: 993F0040  stb r9, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u8 ) };
	// 82A9E3A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9E3AC: 91476F20  stw r10, 0x6f20(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28448 as u32), ctx.r[10].u32 ) };
	// 82A9E3B0: 991F0088  stb r8, 0x88(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[8].u8 ) };
	// 82A9E3B4: 4BFDC795  bl 0x82a7ab48
	ctx.lr = 0x82A9E3B8;
	sub_82A7AB48(ctx, base);
	// 82A9E3B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A9E3BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A9E3C0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E3C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A9E3C8: 4B780729  bl 0x8221eaf0
	ctx.lr = 0x82A9E3CC;
	sub_8221EAF0(ctx, base);
	// 82A9E3CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A9E3D0: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82A9E3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E3D8: 419A0048  beq cr6, 0x82a9e420
	if ctx.cr[6].eq {
	pc = 0x82A9E420; continue 'dispatch;
	}
	// 82A9E3DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9E3E0: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9E3E4; continue 'dispatch;
            }
            0x82A9E3E4 => {
    //   block [0x82A9E3E4..0x82A9E41C)
	// 82A9E3E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E3E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E3EC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E3F0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9E3F4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E3F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E3FC: 4082FFE8  bne 0x82a9e3e4
	if !ctx.cr[0].eq {
	pc = 0x82A9E3E4; continue 'dispatch;
	}
	// 82A9E400: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9E404: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E408: 409A0014  bne cr6, 0x82a9e41c
	if !ctx.cr[6].eq {
	pc = 0x82A9E41C; continue 'dispatch;
	}
	// 82A9E40C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E410: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E414: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E418: 4E800421  bctrl
	ctx.lr = 0x82A9E41C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E41C => {
    //   block [0x82A9E41C..0x82A9E420)
	// 82A9E41C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	pc = 0x82A9E420; continue 'dispatch;
            }
            0x82A9E420 => {
    //   block [0x82A9E420..0x82A9E454)
	// 82A9E420: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A9E424: 4BFDC92D  bl 0x82a7ad50
	ctx.lr = 0x82A9E428;
	sub_82A7AD50(ctx, base);
	// 82A9E428: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A9E42C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A9E430: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E434: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A9E438: 4B7806B9  bl 0x8221eaf0
	ctx.lr = 0x82A9E43C;
	sub_8221EAF0(ctx, base);
	// 82A9E43C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A9E440: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82A9E444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E448: 419A0048  beq cr6, 0x82a9e490
	if ctx.cr[6].eq {
	pc = 0x82A9E490; continue 'dispatch;
	}
	// 82A9E44C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9E450: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9E454; continue 'dispatch;
            }
            0x82A9E454 => {
    //   block [0x82A9E454..0x82A9E48C)
	// 82A9E454: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E458: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E45C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E460: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9E464: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E468: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E46C: 4082FFE8  bne 0x82a9e454
	if !ctx.cr[0].eq {
	pc = 0x82A9E454; continue 'dispatch;
	}
	// 82A9E470: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9E474: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E478: 409A0014  bne cr6, 0x82a9e48c
	if !ctx.cr[6].eq {
	pc = 0x82A9E48C; continue 'dispatch;
	}
	// 82A9E47C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E480: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E484: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E488: 4E800421  bctrl
	ctx.lr = 0x82A9E48C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E48C => {
    //   block [0x82A9E48C..0x82A9E490)
	// 82A9E48C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x82A9E490; continue 'dispatch;
            }
            0x82A9E490 => {
    //   block [0x82A9E490..0x82A9E4C4)
	// 82A9E490: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A9E494: 4BFDC9BD  bl 0x82a7ae50
	ctx.lr = 0x82A9E498;
	sub_82A7AE50(ctx, base);
	// 82A9E498: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A9E49C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A9E4A0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E4A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A9E4A8: 4B780649  bl 0x8221eaf0
	ctx.lr = 0x82A9E4AC;
	sub_8221EAF0(ctx, base);
	// 82A9E4AC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A9E4B0: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82A9E4B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E4B8: 419A0048  beq cr6, 0x82a9e500
	if ctx.cr[6].eq {
	pc = 0x82A9E500; continue 'dispatch;
	}
	// 82A9E4BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9E4C0: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9E4C4; continue 'dispatch;
            }
            0x82A9E4C4 => {
    //   block [0x82A9E4C4..0x82A9E4FC)
	// 82A9E4C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E4C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E4CC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E4D0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9E4D4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E4D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E4DC: 4082FFE8  bne 0x82a9e4c4
	if !ctx.cr[0].eq {
	pc = 0x82A9E4C4; continue 'dispatch;
	}
	// 82A9E4E0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9E4E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E4E8: 409A0014  bne cr6, 0x82a9e4fc
	if !ctx.cr[6].eq {
	pc = 0x82A9E4FC; continue 'dispatch;
	}
	// 82A9E4EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E4F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E4F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E4F8: 4E800421  bctrl
	ctx.lr = 0x82A9E4FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E4FC => {
    //   block [0x82A9E4FC..0x82A9E500)
	// 82A9E4FC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	pc = 0x82A9E500; continue 'dispatch;
            }
            0x82A9E500 => {
    //   block [0x82A9E500..0x82A9E534)
	// 82A9E500: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A9E504: 4B803495  bl 0x822a1998
	ctx.lr = 0x82A9E508;
	sub_822A1998(ctx, base);
	// 82A9E508: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A9E50C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A9E510: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E514: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A9E518: 4B7805D9  bl 0x8221eaf0
	ctx.lr = 0x82A9E51C;
	sub_8221EAF0(ctx, base);
	// 82A9E51C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A9E520: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82A9E524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E528: 419A0048  beq cr6, 0x82a9e570
	if ctx.cr[6].eq {
	pc = 0x82A9E570; continue 'dispatch;
	}
	// 82A9E52C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9E530: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9E534; continue 'dispatch;
            }
            0x82A9E534 => {
    //   block [0x82A9E534..0x82A9E56C)
	// 82A9E534: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E53C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E540: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9E544: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E548: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E54C: 4082FFE8  bne 0x82a9e534
	if !ctx.cr[0].eq {
	pc = 0x82A9E534; continue 'dispatch;
	}
	// 82A9E550: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9E554: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E558: 409A0014  bne cr6, 0x82a9e56c
	if !ctx.cr[6].eq {
	pc = 0x82A9E56C; continue 'dispatch;
	}
	// 82A9E55C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E560: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E564: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E568: 4E800421  bctrl
	ctx.lr = 0x82A9E56C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E56C => {
    //   block [0x82A9E56C..0x82A9E570)
	// 82A9E56C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	pc = 0x82A9E570; continue 'dispatch;
            }
            0x82A9E570 => {
    //   block [0x82A9E570..0x82A9E5F0)
	// 82A9E570: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82A9E574: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82A9E578: 390000D3  li r8, 0xd3
	ctx.r[8].s64 = 211;
	// 82A9E57C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A9E580: 913F0024  stw r9, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 82A9E584: 392000D1  li r9, 0xd1
	ctx.r[9].s64 = 209;
	// 82A9E588: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 82A9E58C: 39400107  li r10, 0x107
	ctx.r[10].s64 = 263;
	// 82A9E590: 911F006C  stw r8, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 82A9E594: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82A9E598: 913F0090  stw r9, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 82A9E59C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82A9E5A0: 915F00B4  stw r10, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[10].u32 ) };
	// 82A9E5A4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82A9E5A8: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A9E5AC: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 82A9E5B0: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82A9E5B4: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A9E5B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A9E5BC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A9E5C0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82A9E5C4: 911F002C  stw r8, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 82A9E5C8: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 82A9E5CC: 396B5278  addi r11, r11, 0x5278
	ctx.r[11].s64 = ctx.r[11].s64 + 21112;
	// 82A9E5D0: 913F004C  stw r9, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 82A9E5D4: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82A9E5D8: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A9E5DC: 80E7F770  lwz r7, -0x890(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-2192 as u32) ) } as u64;
	// 82A9E5E0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A9E5E4: 911F0060  stw r8, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82A9E5E8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82A9E5EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82A9E5F0; continue 'dispatch;
            }
            0x82A9E5F0 => {
    //   block [0x82A9E5F0..0x82A9E62C)
	// 82A9E5F0: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A9E5F4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A9E5F8: 4200FFF8  bdnz 0x82a9e5f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A9E5F0; continue 'dispatch;
	}
	// 82A9E5FC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82A9E600: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A9E604: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82A9E608: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82A9E60C: 3BC901F0  addi r30, r9, 0x1f0
	ctx.r[30].s64 = ctx.r[9].s64 + 496;
	// 82A9E610: 8128F778  lwz r9, -0x888(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-2184 as u32) ) } as u64;
	// 82A9E614: 814AF774  lwz r10, -0x88c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2188 as u32) ) } as u64;
	// 82A9E618: 8107F77C  lwz r8, -0x884(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-2180 as u32) ) } as u64;
	// 82A9E61C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A9E620: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A9E624: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A9E628: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82A9E62C; continue 'dispatch;
            }
            0x82A9E62C => {
    //   block [0x82A9E62C..0x82A9E668)
	// 82A9E62C: 3D001A20  lis r8, 0x1a20
	ctx.r[8].s64 = 438304768;
	// 82A9E630: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82A9E634: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A9E638: 61080152  ori r8, r8, 0x152
	ctx.r[8].u64 = ctx.r[8].u64 | 338;
	// 82A9E63C: 38E00200  li r7, 0x200
	ctx.r[7].s64 = 512;
	// 82A9E640: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A9E644: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A9E648: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82A9E64C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82A9E650: 480FA4D9  bl 0x82b98b28
	ctx.lr = 0x82A9E654;
	sub_82B98B28(ctx, base);
	// 82A9E654: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A9E658: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A9E65C: 397E001C  addi r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 + 28;
	// 82A9E660: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9E664: 4198FFC8  blt cr6, 0x82a9e62c
	if ctx.cr[6].lt {
	pc = 0x82A9E62C; continue 'dispatch;
	}
	pc = 0x82A9E668; continue 'dispatch;
            }
            0x82A9E668 => {
    //   block [0x82A9E668..0x82A9E670)
	// 82A9E668: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A9E66C: 4820ADEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9E670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9E670 size=112
    let mut pc: u32 = 0x82A9E670;
    'dispatch: loop {
        match pc {
            0x82A9E670 => {
    //   block [0x82A9E670..0x82A9E698)
	// 82A9E670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9E674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A9E678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A9E67C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9E680: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9E688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E68C: 4099000C  ble cr6, 0x82a9e698
	if !ctx.cr[6].gt {
	pc = 0x82A9E698; continue 'dispatch;
	}
	// 82A9E690: 4B70D409  bl 0x821aba98
	ctx.lr = 0x82A9E694;
	sub_821ABA98(ctx, base);
	// 82A9E694: 48000034  b 0x82a9e6c8
	pc = 0x82A9E6C8; continue 'dispatch;
            }
            0x82A9E698 => {
    //   block [0x82A9E698..0x82A9E6AC)
	// 82A9E698: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E69C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E6A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A9E6A4: 419A0024  beq cr6, 0x82a9e6c8
	if ctx.cr[6].eq {
	pc = 0x82A9E6C8; continue 'dispatch;
	}
	// 82A9E6A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9E6AC; continue 'dispatch;
            }
            0x82A9E6AC => {
    //   block [0x82A9E6AC..0x82A9E6C8)
	// 82A9E6AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E6B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E6B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E6B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9E6BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E6C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E6C4: 4082FFE8  bne 0x82a9e6ac
	if !ctx.cr[0].eq {
	pc = 0x82A9E6AC; continue 'dispatch;
	}
	pc = 0x82A9E6C8; continue 'dispatch;
            }
            0x82A9E6C8 => {
    //   block [0x82A9E6C8..0x82A9E6E0)
	// 82A9E6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9E6CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A9E6D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A9E6D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A9E6D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A9E6DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9E6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9E6E0 size=100
    let mut pc: u32 = 0x82A9E6E0;
    'dispatch: loop {
        match pc {
            0x82A9E6E0 => {
    //   block [0x82A9E6E0..0x82A9E744)
	// 82A9E6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9E6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A9E6E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A9E6EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A9E6F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9E6F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9E6F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9E6FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A9E700: 4B750439  bl 0x821eeb38
	ctx.lr = 0x82A9E704;
	sub_821EEB38(ctx, base);
	// 82A9E704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9E708: 481650E9  bl 0x82c037f0
	ctx.lr = 0x82A9E70C;
	sub_82C037F0(ctx, base);
	// 82A9E70C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A9E710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9E714: 4B7766C5  bl 0x82214dd8
	ctx.lr = 0x82A9E718;
	sub_82214DD8(ctx, base);
	// 82A9E718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9E71C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A9E720: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A9E724: 4BFFFF4D  bl 0x82a9e670
	ctx.lr = 0x82A9E728;
	sub_82A9E670(ctx, base);
	// 82A9E728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9E72C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A9E730: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A9E734: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A9E738: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A9E73C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A9E740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9E748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A9E748 size=332
    let mut pc: u32 = 0x82A9E748;
    'dispatch: loop {
        match pc {
            0x82A9E748 => {
    //   block [0x82A9E748..0x82A9E7B0)
	// 82A9E748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9E74C: 4820ACBD  bl 0x82ca9408
	ctx.lr = 0x82A9E750;
	sub_82CA93D0(ctx, base);
	// 82A9E750: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9E754: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9E758: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A9E75C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9E760: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82A9E764: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A9E768: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A9E76C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A9E770: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82A9E774: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82A9E778: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82A9E77C: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82A9E780: 9BDF0098  stb r30, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u8 ) };
	// 82A9E784: 9BDF0099  stb r30, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[30].u8 ) };
	// 82A9E788: 9BDF009A  stb r30, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[30].u8 ) };
	// 82A9E78C: 9BDF009B  stb r30, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[30].u8 ) };
	// 82A9E790: 4BFDC3B9  bl 0x82a7ab48
	ctx.lr = 0x82A9E794;
	sub_82A7AB48(ctx, base);
	// 82A9E794: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E798: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A9E79C: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A9E7A0: 419A0074  beq cr6, 0x82a9e814
	if ctx.cr[6].eq {
	pc = 0x82A9E814; continue 'dispatch;
	}
	// 82A9E7A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9E7A8: 419A0040  beq cr6, 0x82a9e7e8
	if ctx.cr[6].eq {
	pc = 0x82A9E7E8; continue 'dispatch;
	}
	// 82A9E7AC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9E7B0; continue 'dispatch;
            }
            0x82A9E7B0 => {
    //   block [0x82A9E7B0..0x82A9E7E4)
	// 82A9E7B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9E7B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E7B8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9E7BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9E7C0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E7C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E7C8: 4082FFE8  bne 0x82a9e7b0
	if !ctx.cr[0].eq {
	pc = 0x82A9E7B0; continue 'dispatch;
	}
	// 82A9E7CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E7D0: 409A0014  bne cr6, 0x82a9e7e4
	if !ctx.cr[6].eq {
	pc = 0x82A9E7E4; continue 'dispatch;
	}
	// 82A9E7D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E7D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E7DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E7E0: 4E800421  bctrl
	ctx.lr = 0x82A9E7E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E7E4 => {
    //   block [0x82A9E7E4..0x82A9E7E8)
	// 82A9E7E4: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A9E7E8; continue 'dispatch;
            }
            0x82A9E7E8 => {
    //   block [0x82A9E7E8..0x82A9E7F8)
	// 82A9E7E8: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A9E7EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A9E7F0: 419A006C  beq cr6, 0x82a9e85c
	if ctx.cr[6].eq {
	pc = 0x82A9E85C; continue 'dispatch;
	}
	// 82A9E7F4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	pc = 0x82A9E7F8; continue 'dispatch;
            }
            0x82A9E7F8 => {
    //   block [0x82A9E7F8..0x82A9E814)
	// 82A9E7F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E7FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E800: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E804: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9E808: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E80C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E810: 4082FFE8  bne 0x82a9e7f8
	if !ctx.cr[0].eq {
	pc = 0x82A9E7F8; continue 'dispatch;
	}
	pc = 0x82A9E814; continue 'dispatch;
            }
            0x82A9E814 => {
    //   block [0x82A9E814..0x82A9E820)
	// 82A9E814: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A9E818: 419A0044  beq cr6, 0x82a9e85c
	if ctx.cr[6].eq {
	pc = 0x82A9E85C; continue 'dispatch;
	}
	// 82A9E81C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	pc = 0x82A9E820; continue 'dispatch;
            }
            0x82A9E820 => {
    //   block [0x82A9E820..0x82A9E85C)
	// 82A9E820: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E824: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E828: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E82C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9E830: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E834: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E838: 4082FFE8  bne 0x82a9e820
	if !ctx.cr[0].eq {
	pc = 0x82A9E820; continue 'dispatch;
	}
	// 82A9E83C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9E840: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E844: 409A0018  bne cr6, 0x82a9e85c
	if !ctx.cr[6].eq {
	pc = 0x82A9E85C; continue 'dispatch;
	}
	// 82A9E848: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E84C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A9E850: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E854: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E858: 4E800421  bctrl
	ctx.lr = 0x82A9E85C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E85C => {
    //   block [0x82A9E85C..0x82A9E894)
	// 82A9E85C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A9E860: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A9E864: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A9E868: 915F00A4  stw r10, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 82A9E86C: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 82A9E870: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 82A9E874: C00BB46C  lfs f0, -0x4b94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A9E878: 93DF00B0  stw r30, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 82A9E87C: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A9E880: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A9E884: 4BFFFAAD  bl 0x82a9e330
	ctx.lr = 0x82A9E888;
	sub_82A9E330(ctx, base);
	// 82A9E888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9E88C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A9E890: 4820ABC8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9E898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9E898 size=1248
    let mut pc: u32 = 0x82A9E898;
    'dispatch: loop {
        match pc {
            0x82A9E898 => {
    //   block [0x82A9E898..0x82A9E8F4)
	// 82A9E898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9E89C: 4820AB65  bl 0x82ca9400
	ctx.lr = 0x82A9E8A0;
	sub_82CA93D0(ctx, base);
	// 82A9E8A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9E8A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A9E8A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A9E8AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A9E8B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A9E8B4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A9E8B8: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82A9E8BC: 4BFDC395  bl 0x82a7ac50
	ctx.lr = 0x82A9E8C0;
	sub_82A7AC50(ctx, base);
	// 82A9E8C0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9E8C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A9E8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9E8CC: 4BFFFDA5  bl 0x82a9e670
	ctx.lr = 0x82A9E8D0;
	sub_82A9E670(ctx, base);
	// 82A9E8D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9E8D4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E8D8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A9E8DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E8E0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9E8E4: 419A0078  beq cr6, 0x82a9e95c
	if ctx.cr[6].eq {
	pc = 0x82A9E95C; continue 'dispatch;
	}
	// 82A9E8E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9E8EC: 419A0040  beq cr6, 0x82a9e92c
	if ctx.cr[6].eq {
	pc = 0x82A9E92C; continue 'dispatch;
	}
	// 82A9E8F0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9E8F4; continue 'dispatch;
            }
            0x82A9E8F4 => {
    //   block [0x82A9E8F4..0x82A9E928)
	// 82A9E8F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9E8F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E8FC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9E900: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9E904: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E908: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E90C: 4082FFE8  bne 0x82a9e8f4
	if !ctx.cr[0].eq {
	pc = 0x82A9E8F4; continue 'dispatch;
	}
	// 82A9E910: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E914: 409A0014  bne cr6, 0x82a9e928
	if !ctx.cr[6].eq {
	pc = 0x82A9E928; continue 'dispatch;
	}
	// 82A9E918: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E91C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E920: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E924: 4E800421  bctrl
	ctx.lr = 0x82A9E928;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E928 => {
    //   block [0x82A9E928..0x82A9E92C)
	// 82A9E928: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9E92C; continue 'dispatch;
            }
            0x82A9E92C => {
    //   block [0x82A9E92C..0x82A9E940)
	// 82A9E92C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E934: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A9E938: 419A0024  beq cr6, 0x82a9e95c
	if ctx.cr[6].eq {
	pc = 0x82A9E95C; continue 'dispatch;
	}
	// 82A9E93C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9E940; continue 'dispatch;
            }
            0x82A9E940 => {
    //   block [0x82A9E940..0x82A9E95C)
	// 82A9E940: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E944: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E948: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E94C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9E950: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E954: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E958: 4082FFE8  bne 0x82a9e940
	if !ctx.cr[0].eq {
	pc = 0x82A9E940; continue 'dispatch;
	}
	pc = 0x82A9E95C; continue 'dispatch;
            }
            0x82A9E95C => {
    //   block [0x82A9E95C..0x82A9E970)
	// 82A9E95C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A9E960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E964: 419A0048  beq cr6, 0x82a9e9ac
	if ctx.cr[6].eq {
	pc = 0x82A9E9AC; continue 'dispatch;
	}
	// 82A9E968: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9E96C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9E970; continue 'dispatch;
            }
            0x82A9E970 => {
    //   block [0x82A9E970..0x82A9E9A8)
	// 82A9E970: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E978: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E97C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9E980: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E984: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E988: 4082FFE8  bne 0x82a9e970
	if !ctx.cr[0].eq {
	pc = 0x82A9E970; continue 'dispatch;
	}
	// 82A9E98C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9E990: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E994: 409A0014  bne cr6, 0x82a9e9a8
	if !ctx.cr[6].eq {
	pc = 0x82A9E9A8; continue 'dispatch;
	}
	// 82A9E998: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E99C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E9A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E9A4: 4E800421  bctrl
	ctx.lr = 0x82A9E9A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E9A8 => {
    //   block [0x82A9E9A8..0x82A9E9AC)
	// 82A9E9A8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9E9AC; continue 'dispatch;
            }
            0x82A9E9AC => {
    //   block [0x82A9E9AC..0x82A9E9C0)
	// 82A9E9AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A9E9B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9E9B4: 419A0048  beq cr6, 0x82a9e9fc
	if ctx.cr[6].eq {
	pc = 0x82A9E9FC; continue 'dispatch;
	}
	// 82A9E9B8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9E9BC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9E9C0; continue 'dispatch;
            }
            0x82A9E9C0 => {
    //   block [0x82A9E9C0..0x82A9E9F8)
	// 82A9E9C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9E9C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E9C8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9E9CC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9E9D0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9E9D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9E9D8: 4082FFE8  bne 0x82a9e9c0
	if !ctx.cr[0].eq {
	pc = 0x82A9E9C0; continue 'dispatch;
	}
	// 82A9E9DC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9E9E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9E9E4: 409A0014  bne cr6, 0x82a9e9f8
	if !ctx.cr[6].eq {
	pc = 0x82A9E9F8; continue 'dispatch;
	}
	// 82A9E9E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9E9EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9E9F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9E9F4: 4E800421  bctrl
	ctx.lr = 0x82A9E9F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9E9F8 => {
    //   block [0x82A9E9F8..0x82A9E9FC)
	// 82A9E9F8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9E9FC; continue 'dispatch;
            }
            0x82A9E9FC => {
    //   block [0x82A9E9FC..0x82A9EA34)
	// 82A9E9FC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A9EA00: 4BFDC351  bl 0x82a7ad50
	ctx.lr = 0x82A9EA04;
	sub_82A7AD50(ctx, base);
	// 82A9EA04: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9EA08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A9EA0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A9EA10: 4BFFFC61  bl 0x82a9e670
	ctx.lr = 0x82A9EA14;
	sub_82A9E670(ctx, base);
	// 82A9EA14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9EA18: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A9EA1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EA20: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9EA24: 419A0078  beq cr6, 0x82a9ea9c
	if ctx.cr[6].eq {
	pc = 0x82A9EA9C; continue 'dispatch;
	}
	// 82A9EA28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9EA2C: 419A0040  beq cr6, 0x82a9ea6c
	if ctx.cr[6].eq {
	pc = 0x82A9EA6C; continue 'dispatch;
	}
	// 82A9EA30: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9EA34; continue 'dispatch;
            }
            0x82A9EA34 => {
    //   block [0x82A9EA34..0x82A9EA68)
	// 82A9EA34: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9EA38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EA3C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9EA40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9EA44: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EA48: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EA4C: 4082FFE8  bne 0x82a9ea34
	if !ctx.cr[0].eq {
	pc = 0x82A9EA34; continue 'dispatch;
	}
	// 82A9EA50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9EA54: 409A0014  bne cr6, 0x82a9ea68
	if !ctx.cr[6].eq {
	pc = 0x82A9EA68; continue 'dispatch;
	}
	// 82A9EA58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EA5C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9EA60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EA64: 4E800421  bctrl
	ctx.lr = 0x82A9EA68;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9EA68 => {
    //   block [0x82A9EA68..0x82A9EA6C)
	// 82A9EA68: 937D0008  stw r27, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9EA6C; continue 'dispatch;
            }
            0x82A9EA6C => {
    //   block [0x82A9EA6C..0x82A9EA80)
	// 82A9EA6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EA70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9EA74: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A9EA78: 419A0024  beq cr6, 0x82a9ea9c
	if ctx.cr[6].eq {
	pc = 0x82A9EA9C; continue 'dispatch;
	}
	// 82A9EA7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9EA80; continue 'dispatch;
            }
            0x82A9EA80 => {
    //   block [0x82A9EA80..0x82A9EA9C)
	// 82A9EA80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9EA84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EA88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9EA8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9EA90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EA94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EA98: 4082FFE8  bne 0x82a9ea80
	if !ctx.cr[0].eq {
	pc = 0x82A9EA80; continue 'dispatch;
	}
	pc = 0x82A9EA9C; continue 'dispatch;
            }
            0x82A9EA9C => {
    //   block [0x82A9EA9C..0x82A9EAB0)
	// 82A9EA9C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A9EAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9EAA4: 419A0048  beq cr6, 0x82a9eaec
	if ctx.cr[6].eq {
	pc = 0x82A9EAEC; continue 'dispatch;
	}
	// 82A9EAA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9EAAC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9EAB0; continue 'dispatch;
            }
            0x82A9EAB0 => {
    //   block [0x82A9EAB0..0x82A9EAE8)
	// 82A9EAB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9EAB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EAB8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9EABC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9EAC0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EAC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EAC8: 4082FFE8  bne 0x82a9eab0
	if !ctx.cr[0].eq {
	pc = 0x82A9EAB0; continue 'dispatch;
	}
	// 82A9EACC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9EAD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9EAD4: 409A0014  bne cr6, 0x82a9eae8
	if !ctx.cr[6].eq {
	pc = 0x82A9EAE8; continue 'dispatch;
	}
	// 82A9EAD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EADC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9EAE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EAE4: 4E800421  bctrl
	ctx.lr = 0x82A9EAE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9EAE8 => {
    //   block [0x82A9EAE8..0x82A9EAEC)
	// 82A9EAE8: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9EAEC; continue 'dispatch;
            }
            0x82A9EAEC => {
    //   block [0x82A9EAEC..0x82A9EB00)
	// 82A9EAEC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A9EAF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9EAF4: 419A0048  beq cr6, 0x82a9eb3c
	if ctx.cr[6].eq {
	pc = 0x82A9EB3C; continue 'dispatch;
	}
	// 82A9EAF8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9EAFC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9EB00; continue 'dispatch;
            }
            0x82A9EB00 => {
    //   block [0x82A9EB00..0x82A9EB38)
	// 82A9EB00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9EB04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EB08: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9EB0C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9EB10: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EB14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EB18: 4082FFE8  bne 0x82a9eb00
	if !ctx.cr[0].eq {
	pc = 0x82A9EB00; continue 'dispatch;
	}
	// 82A9EB1C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9EB20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9EB24: 409A0014  bne cr6, 0x82a9eb38
	if !ctx.cr[6].eq {
	pc = 0x82A9EB38; continue 'dispatch;
	}
	// 82A9EB28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EB2C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9EB30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EB34: 4E800421  bctrl
	ctx.lr = 0x82A9EB38;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9EB38 => {
    //   block [0x82A9EB38..0x82A9EB3C)
	// 82A9EB38: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9EB3C; continue 'dispatch;
            }
            0x82A9EB3C => {
    //   block [0x82A9EB3C..0x82A9EB74)
	// 82A9EB3C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A9EB40: 4BFDC311  bl 0x82a7ae50
	ctx.lr = 0x82A9EB44;
	sub_82A7AE50(ctx, base);
	// 82A9EB44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9EB48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A9EB4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A9EB50: 4BFFFB21  bl 0x82a9e670
	ctx.lr = 0x82A9EB54;
	sub_82A9E670(ctx, base);
	// 82A9EB54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9EB58: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A9EB5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EB60: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9EB64: 419A0078  beq cr6, 0x82a9ebdc
	if ctx.cr[6].eq {
	pc = 0x82A9EBDC; continue 'dispatch;
	}
	// 82A9EB68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9EB6C: 419A0040  beq cr6, 0x82a9ebac
	if ctx.cr[6].eq {
	pc = 0x82A9EBAC; continue 'dispatch;
	}
	// 82A9EB70: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9EB74; continue 'dispatch;
            }
            0x82A9EB74 => {
    //   block [0x82A9EB74..0x82A9EBA8)
	// 82A9EB74: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9EB78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EB7C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9EB80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9EB84: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EB88: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EB8C: 4082FFE8  bne 0x82a9eb74
	if !ctx.cr[0].eq {
	pc = 0x82A9EB74; continue 'dispatch;
	}
	// 82A9EB90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9EB94: 409A0014  bne cr6, 0x82a9eba8
	if !ctx.cr[6].eq {
	pc = 0x82A9EBA8; continue 'dispatch;
	}
	// 82A9EB98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EB9C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9EBA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EBA4: 4E800421  bctrl
	ctx.lr = 0x82A9EBA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9EBA8 => {
    //   block [0x82A9EBA8..0x82A9EBAC)
	// 82A9EBA8: 937D000C  stw r27, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9EBAC; continue 'dispatch;
            }
            0x82A9EBAC => {
    //   block [0x82A9EBAC..0x82A9EBC0)
	// 82A9EBAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EBB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9EBB4: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A9EBB8: 419A0024  beq cr6, 0x82a9ebdc
	if ctx.cr[6].eq {
	pc = 0x82A9EBDC; continue 'dispatch;
	}
	// 82A9EBBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9EBC0; continue 'dispatch;
            }
            0x82A9EBC0 => {
    //   block [0x82A9EBC0..0x82A9EBDC)
	// 82A9EBC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9EBC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EBC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9EBCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9EBD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EBD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EBD8: 4082FFE8  bne 0x82a9ebc0
	if !ctx.cr[0].eq {
	pc = 0x82A9EBC0; continue 'dispatch;
	}
	pc = 0x82A9EBDC; continue 'dispatch;
            }
            0x82A9EBDC => {
    //   block [0x82A9EBDC..0x82A9EBF0)
	// 82A9EBDC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A9EBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9EBE4: 419A0048  beq cr6, 0x82a9ec2c
	if ctx.cr[6].eq {
	pc = 0x82A9EC2C; continue 'dispatch;
	}
	// 82A9EBE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9EBEC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9EBF0; continue 'dispatch;
            }
            0x82A9EBF0 => {
    //   block [0x82A9EBF0..0x82A9EC28)
	// 82A9EBF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9EBF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EBF8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9EBFC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9EC00: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EC04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EC08: 4082FFE8  bne 0x82a9ebf0
	if !ctx.cr[0].eq {
	pc = 0x82A9EBF0; continue 'dispatch;
	}
	// 82A9EC0C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9EC10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9EC14: 409A0014  bne cr6, 0x82a9ec28
	if !ctx.cr[6].eq {
	pc = 0x82A9EC28; continue 'dispatch;
	}
	// 82A9EC18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EC1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9EC20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EC24: 4E800421  bctrl
	ctx.lr = 0x82A9EC28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9EC28 => {
    //   block [0x82A9EC28..0x82A9EC2C)
	// 82A9EC28: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9EC2C; continue 'dispatch;
            }
            0x82A9EC2C => {
    //   block [0x82A9EC2C..0x82A9EC40)
	// 82A9EC2C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A9EC30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9EC34: 419A0048  beq cr6, 0x82a9ec7c
	if ctx.cr[6].eq {
	pc = 0x82A9EC7C; continue 'dispatch;
	}
	// 82A9EC38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9EC3C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9EC40; continue 'dispatch;
            }
            0x82A9EC40 => {
    //   block [0x82A9EC40..0x82A9EC78)
	// 82A9EC40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9EC44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EC48: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9EC4C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9EC50: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EC54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EC58: 4082FFE8  bne 0x82a9ec40
	if !ctx.cr[0].eq {
	pc = 0x82A9EC40; continue 'dispatch;
	}
	// 82A9EC5C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9EC60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9EC64: 409A0014  bne cr6, 0x82a9ec78
	if !ctx.cr[6].eq {
	pc = 0x82A9EC78; continue 'dispatch;
	}
	// 82A9EC68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EC6C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9EC70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EC74: 4E800421  bctrl
	ctx.lr = 0x82A9EC78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9EC78 => {
    //   block [0x82A9EC78..0x82A9EC7C)
	// 82A9EC78: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9EC7C; continue 'dispatch;
            }
            0x82A9EC7C => {
    //   block [0x82A9EC7C..0x82A9ECB0)
	// 82A9EC7C: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82A9EC80: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82A9EC84: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A9EC88: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A9EC8C: 4BFFF9E5  bl 0x82a9e670
	ctx.lr = 0x82A9EC90;
	sub_82A9E670(ctx, base);
	// 82A9EC90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9EC94: 807D0010  lwz r3, 0x10(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A9EC98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EC9C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9ECA0: 419A0078  beq cr6, 0x82a9ed18
	if ctx.cr[6].eq {
	pc = 0x82A9ED18; continue 'dispatch;
	}
	// 82A9ECA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9ECA8: 419A0040  beq cr6, 0x82a9ece8
	if ctx.cr[6].eq {
	pc = 0x82A9ECE8; continue 'dispatch;
	}
	// 82A9ECAC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9ECB0; continue 'dispatch;
            }
            0x82A9ECB0 => {
    //   block [0x82A9ECB0..0x82A9ECE4)
	// 82A9ECB0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9ECB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9ECB8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9ECBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9ECC0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9ECC4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9ECC8: 4082FFE8  bne 0x82a9ecb0
	if !ctx.cr[0].eq {
	pc = 0x82A9ECB0; continue 'dispatch;
	}
	// 82A9ECCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9ECD0: 409A0014  bne cr6, 0x82a9ece4
	if !ctx.cr[6].eq {
	pc = 0x82A9ECE4; continue 'dispatch;
	}
	// 82A9ECD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9ECD8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9ECDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9ECE0: 4E800421  bctrl
	ctx.lr = 0x82A9ECE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9ECE4 => {
    //   block [0x82A9ECE4..0x82A9ECE8)
	// 82A9ECE4: 937D0010  stw r27, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9ECE8; continue 'dispatch;
            }
            0x82A9ECE8 => {
    //   block [0x82A9ECE8..0x82A9ECFC)
	// 82A9ECE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9ECEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9ECF0: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A9ECF4: 419A0024  beq cr6, 0x82a9ed18
	if ctx.cr[6].eq {
	pc = 0x82A9ED18; continue 'dispatch;
	}
	// 82A9ECF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9ECFC; continue 'dispatch;
            }
            0x82A9ECFC => {
    //   block [0x82A9ECFC..0x82A9ED18)
	// 82A9ECFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9ED00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9ED04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9ED08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9ED0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9ED10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9ED14: 4082FFE8  bne 0x82a9ecfc
	if !ctx.cr[0].eq {
	pc = 0x82A9ECFC; continue 'dispatch;
	}
	pc = 0x82A9ED18; continue 'dispatch;
            }
            0x82A9ED18 => {
    //   block [0x82A9ED18..0x82A9ED2C)
	// 82A9ED18: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A9ED1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9ED20: 419A0048  beq cr6, 0x82a9ed68
	if ctx.cr[6].eq {
	pc = 0x82A9ED68; continue 'dispatch;
	}
	// 82A9ED24: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9ED28: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9ED2C; continue 'dispatch;
            }
            0x82A9ED2C => {
    //   block [0x82A9ED2C..0x82A9ED64)
	// 82A9ED2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9ED30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9ED34: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9ED38: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9ED3C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9ED40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9ED44: 4082FFE8  bne 0x82a9ed2c
	if !ctx.cr[0].eq {
	pc = 0x82A9ED2C; continue 'dispatch;
	}
	// 82A9ED48: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9ED4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9ED50: 409A0014  bne cr6, 0x82a9ed64
	if !ctx.cr[6].eq {
	pc = 0x82A9ED64; continue 'dispatch;
	}
	// 82A9ED54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9ED58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9ED5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9ED60: 4E800421  bctrl
	ctx.lr = 0x82A9ED64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9ED64 => {
    //   block [0x82A9ED64..0x82A9ED68)
	// 82A9ED64: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	pc = 0x82A9ED68; continue 'dispatch;
            }
            0x82A9ED68 => {
    //   block [0x82A9ED68..0x82A9ED78)
	// 82A9ED68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A9ED6C: 48001735  bl 0x82aa04a0
	ctx.lr = 0x82A9ED70;
	sub_82AA04A0(ctx, base);
	// 82A9ED70: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A9ED74: 4820A6DC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9ED78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9ED78 size=296
    let mut pc: u32 = 0x82A9ED78;
    'dispatch: loop {
        match pc {
            0x82A9ED78 => {
    //   block [0x82A9ED78..0x82A9EEA0)
	// 82A9ED78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9ED7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A9ED80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A9ED84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A9ED88: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9ED8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9ED90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A9ED94: 480017FD  bl 0x82aa0590
	ctx.lr = 0x82A9ED98;
	sub_82AA0590(ctx, base);
	// 82A9ED98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9ED9C: 4BFDBEB5  bl 0x82a7ac50
	ctx.lr = 0x82A9EDA0;
	sub_82A7AC50(ctx, base);
	// 82A9EDA0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A9EDA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A9EDA8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EDAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A9EDB0: 4B77FD41  bl 0x8221eaf0
	ctx.lr = 0x82A9EDB4;
	sub_8221EAF0(ctx, base);
	// 82A9EDB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A9EDB8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82A9EDBC: 90610090  stw r3, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 82A9EDC0: 392B4370  addi r9, r11, 0x4370
	ctx.r[9].s64 = ctx.r[11].s64 + 17264;
	// 82A9EDC4: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82A9EDC8: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82A9EDCC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A9EDD0: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9EEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9EEA0 size=2260
    let mut pc: u32 = 0x82A9EEA0;
    'dispatch: loop {
        match pc {
            0x82A9EEA0 => {
    //   block [0x82A9EEA0..0x82A9EFC4)
	// 82A9EEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9EEA4: 4820A565  bl 0x82ca9408
	ctx.lr = 0x82A9EEA8;
	sub_82CA93D0(ctx, base);
	// 82A9EEA8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9EEAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A9EEB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A9EEB4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A9EEB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EEBC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EEC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EEC4: 4E800421  bctrl
	ctx.lr = 0x82A9EEC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EEC8: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EECC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9EED0: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82A9EED4: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EED8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A9EEDC: 4E800421  bctrl
	ctx.lr = 0x82A9EEE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EEE0: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EEE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9EEE8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A9EEEC: 80C70014  lwz r6, 0x14(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EEF0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82A9EEF4: 4E800421  bctrl
	ctx.lr = 0x82A9EEF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EEF8: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EEFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9EF00: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82A9EF04: 81650014  lwz r11, 0x14(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EF08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A9EF0C: 4E800421  bctrl
	ctx.lr = 0x82A9EF10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EF10: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EF14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9EF18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A9EF1C: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EF20: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A9EF24: 4E800421  bctrl
	ctx.lr = 0x82A9EF28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EF28: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EF2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9EF30: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82A9EF34: 80E80014  lwz r7, 0x14(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EF38: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82A9EF3C: 4E800421  bctrl
	ctx.lr = 0x82A9EF40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EF40: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EF44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9EF48: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A9EF4C: 80A60014  lwz r5, 0x14(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EF50: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 82A9EF54: 4E800421  bctrl
	ctx.lr = 0x82A9EF58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EF58: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EF5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9EF60: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82A9EF64: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EF68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EF6C: 4E800421  bctrl
	ctx.lr = 0x82A9EF70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EF70: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EF74: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A9EF78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9EF7C: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9EF80: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A9EF84: 4E800421  bctrl
	ctx.lr = 0x82A9EF88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9EF88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A9EF8C: 4BFDBBBD  bl 0x82a7ab48
	ctx.lr = 0x82A9EF90;
	sub_82A7AB48(ctx, base);
	// 82A9EF90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9EF94: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A9EF98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9EF9C: 4BFFF745  bl 0x82a9e6e0
	ctx.lr = 0x82A9EFA0;
	sub_82A9E6E0(ctx, base);
	// 82A9EFA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9EFA4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9EFA8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A9EFAC: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EFB0: 7F033800  cmpw cr6, r3, r7
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82A9EFB4: 419A0078  beq cr6, 0x82a9f02c
	if ctx.cr[6].eq {
	pc = 0x82A9F02C; continue 'dispatch;
	}
	// 82A9EFB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9EFBC: 419A0040  beq cr6, 0x82a9effc
	if ctx.cr[6].eq {
	pc = 0x82A9EFFC; continue 'dispatch;
	}
	// 82A9EFC0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
            }
            0x82A9EFC4 => {
    //   block [0x82A9EFC4..0x82A9EFF8)
	// 82A9EFC4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9EFC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EFCC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9EFD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9EFD4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9EFD8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9EFDC: 4082FFE8  bne 0x82a9efc4
	if !ctx.cr[0].eq {
	pc = 0x82A9EFC4; continue 'dispatch;
	}
	// 82A9EFE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9EFE4: 409A0014  bne cr6, 0x82a9eff8
	if !ctx.cr[6].eq {
	pc = 0x82A9EFF8; continue 'dispatch;
	}
	// 82A9EFE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9EFEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9EFF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9EFF4: 4E800421  bctrl
	ctx.lr = 0x82A9EFF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9EFF8 => {
    //   block [0x82A9EFF8..0x82A9EFFC)
	// 82A9EFF8: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9EFFC; continue 'dispatch;
            }
            0x82A9EFFC => {
    //   block [0x82A9EFFC..0x82A9F010)
	// 82A9EFFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F004: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A9F008: 419A0024  beq cr6, 0x82a9f02c
	if ctx.cr[6].eq {
	pc = 0x82A9F02C; continue 'dispatch;
	}
	// 82A9F00C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F010; continue 'dispatch;
            }
            0x82A9F010 => {
    //   block [0x82A9F010..0x82A9F02C)
	// 82A9F010: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F014: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F018: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F01C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F020: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F024: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F028: 4082FFE8  bne 0x82a9f010
	if !ctx.cr[0].eq {
	pc = 0x82A9F010; continue 'dispatch;
	}
	pc = 0x82A9F02C; continue 'dispatch;
            }
            0x82A9F02C => {
    //   block [0x82A9F02C..0x82A9F040)
	// 82A9F02C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A9F030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F034: 419A0048  beq cr6, 0x82a9f07c
	if ctx.cr[6].eq {
	pc = 0x82A9F07C; continue 'dispatch;
	}
	// 82A9F038: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F03C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F040; continue 'dispatch;
            }
            0x82A9F040 => {
    //   block [0x82A9F040..0x82A9F078)
	// 82A9F040: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F044: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F048: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F04C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F050: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F054: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F058: 4082FFE8  bne 0x82a9f040
	if !ctx.cr[0].eq {
	pc = 0x82A9F040; continue 'dispatch;
	}
	// 82A9F05C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F060: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F064: 409A0014  bne cr6, 0x82a9f078
	if !ctx.cr[6].eq {
	pc = 0x82A9F078; continue 'dispatch;
	}
	// 82A9F068: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F06C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F070: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F074: 4E800421  bctrl
	ctx.lr = 0x82A9F078;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F078 => {
    //   block [0x82A9F078..0x82A9F07C)
	// 82A9F078: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F07C; continue 'dispatch;
            }
            0x82A9F07C => {
    //   block [0x82A9F07C..0x82A9F090)
	// 82A9F07C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A9F080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F084: 419A0048  beq cr6, 0x82a9f0cc
	if ctx.cr[6].eq {
	pc = 0x82A9F0CC; continue 'dispatch;
	}
	// 82A9F088: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F08C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F090; continue 'dispatch;
            }
            0x82A9F090 => {
    //   block [0x82A9F090..0x82A9F0C8)
	// 82A9F090: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F094: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F098: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F09C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F0A0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F0A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F0A8: 4082FFE8  bne 0x82a9f090
	if !ctx.cr[0].eq {
	pc = 0x82A9F090; continue 'dispatch;
	}
	// 82A9F0AC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F0B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F0B4: 409A0014  bne cr6, 0x82a9f0c8
	if !ctx.cr[6].eq {
	pc = 0x82A9F0C8; continue 'dispatch;
	}
	// 82A9F0B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F0BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F0C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F0C4: 4E800421  bctrl
	ctx.lr = 0x82A9F0C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F0C8 => {
    //   block [0x82A9F0C8..0x82A9F0CC)
	// 82A9F0C8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F0CC; continue 'dispatch;
            }
            0x82A9F0CC => {
    //   block [0x82A9F0CC..0x82A9F104)
	// 82A9F0CC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A9F0D0: 4BFDBC81  bl 0x82a7ad50
	ctx.lr = 0x82A9F0D4;
	sub_82A7AD50(ctx, base);
	// 82A9F0D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9F0D8: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82A9F0DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A9F0E0: 4BFFF601  bl 0x82a9e6e0
	ctx.lr = 0x82A9F0E4;
	sub_82A9E6E0(ctx, base);
	// 82A9F0E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9F0E8: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A9F0EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F0F0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9F0F4: 419A0078  beq cr6, 0x82a9f16c
	if ctx.cr[6].eq {
	pc = 0x82A9F16C; continue 'dispatch;
	}
	// 82A9F0F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9F0FC: 419A0040  beq cr6, 0x82a9f13c
	if ctx.cr[6].eq {
	pc = 0x82A9F13C; continue 'dispatch;
	}
	// 82A9F100: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9F104; continue 'dispatch;
            }
            0x82A9F104 => {
    //   block [0x82A9F104..0x82A9F138)
	// 82A9F104: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9F108: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F10C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9F110: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9F114: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F118: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F11C: 4082FFE8  bne 0x82a9f104
	if !ctx.cr[0].eq {
	pc = 0x82A9F104; continue 'dispatch;
	}
	// 82A9F120: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F124: 409A0014  bne cr6, 0x82a9f138
	if !ctx.cr[6].eq {
	pc = 0x82A9F138; continue 'dispatch;
	}
	// 82A9F128: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F12C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F130: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F134: 4E800421  bctrl
	ctx.lr = 0x82A9F138;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F138 => {
    //   block [0x82A9F138..0x82A9F13C)
	// 82A9F138: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F13C; continue 'dispatch;
            }
            0x82A9F13C => {
    //   block [0x82A9F13C..0x82A9F150)
	// 82A9F13C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F144: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A9F148: 419A0024  beq cr6, 0x82a9f16c
	if ctx.cr[6].eq {
	pc = 0x82A9F16C; continue 'dispatch;
	}
	// 82A9F14C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F150; continue 'dispatch;
            }
            0x82A9F150 => {
    //   block [0x82A9F150..0x82A9F16C)
	// 82A9F150: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F154: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F158: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F15C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F160: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F164: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F168: 4082FFE8  bne 0x82a9f150
	if !ctx.cr[0].eq {
	pc = 0x82A9F150; continue 'dispatch;
	}
	pc = 0x82A9F16C; continue 'dispatch;
            }
            0x82A9F16C => {
    //   block [0x82A9F16C..0x82A9F180)
	// 82A9F16C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A9F170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F174: 419A0048  beq cr6, 0x82a9f1bc
	if ctx.cr[6].eq {
	pc = 0x82A9F1BC; continue 'dispatch;
	}
	// 82A9F178: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F17C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F180; continue 'dispatch;
            }
            0x82A9F180 => {
    //   block [0x82A9F180..0x82A9F1B8)
	// 82A9F180: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F184: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F188: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F18C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F190: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F194: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F198: 4082FFE8  bne 0x82a9f180
	if !ctx.cr[0].eq {
	pc = 0x82A9F180; continue 'dispatch;
	}
	// 82A9F19C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F1A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F1A4: 409A0014  bne cr6, 0x82a9f1b8
	if !ctx.cr[6].eq {
	pc = 0x82A9F1B8; continue 'dispatch;
	}
	// 82A9F1A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F1AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F1B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F1B4: 4E800421  bctrl
	ctx.lr = 0x82A9F1B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F1B8 => {
    //   block [0x82A9F1B8..0x82A9F1BC)
	// 82A9F1B8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F1BC; continue 'dispatch;
            }
            0x82A9F1BC => {
    //   block [0x82A9F1BC..0x82A9F1D0)
	// 82A9F1BC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A9F1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F1C4: 419A0048  beq cr6, 0x82a9f20c
	if ctx.cr[6].eq {
	pc = 0x82A9F20C; continue 'dispatch;
	}
	// 82A9F1C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F1CC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F1D0; continue 'dispatch;
            }
            0x82A9F1D0 => {
    //   block [0x82A9F1D0..0x82A9F208)
	// 82A9F1D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F1D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F1D8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F1DC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F1E0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F1E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F1E8: 4082FFE8  bne 0x82a9f1d0
	if !ctx.cr[0].eq {
	pc = 0x82A9F1D0; continue 'dispatch;
	}
	// 82A9F1EC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F1F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F1F4: 409A0014  bne cr6, 0x82a9f208
	if !ctx.cr[6].eq {
	pc = 0x82A9F208; continue 'dispatch;
	}
	// 82A9F1F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F1FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F200: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F204: 4E800421  bctrl
	ctx.lr = 0x82A9F208;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F208 => {
    //   block [0x82A9F208..0x82A9F20C)
	// 82A9F208: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F20C; continue 'dispatch;
            }
            0x82A9F20C => {
    //   block [0x82A9F20C..0x82A9F244)
	// 82A9F20C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A9F210: 4BFDBC41  bl 0x82a7ae50
	ctx.lr = 0x82A9F214;
	sub_82A7AE50(ctx, base);
	// 82A9F214: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9F218: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82A9F21C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A9F220: 4BFFF4C1  bl 0x82a9e6e0
	ctx.lr = 0x82A9F224;
	sub_82A9E6E0(ctx, base);
	// 82A9F224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9F228: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A9F22C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F230: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9F234: 419A0078  beq cr6, 0x82a9f2ac
	if ctx.cr[6].eq {
	pc = 0x82A9F2AC; continue 'dispatch;
	}
	// 82A9F238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9F23C: 419A0040  beq cr6, 0x82a9f27c
	if ctx.cr[6].eq {
	pc = 0x82A9F27C; continue 'dispatch;
	}
	// 82A9F240: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9F244; continue 'dispatch;
            }
            0x82A9F244 => {
    //   block [0x82A9F244..0x82A9F278)
	// 82A9F244: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9F248: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F24C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9F250: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9F254: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F258: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F25C: 4082FFE8  bne 0x82a9f244
	if !ctx.cr[0].eq {
	pc = 0x82A9F244; continue 'dispatch;
	}
	// 82A9F260: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F264: 409A0014  bne cr6, 0x82a9f278
	if !ctx.cr[6].eq {
	pc = 0x82A9F278; continue 'dispatch;
	}
	// 82A9F268: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F26C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F270: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F274: 4E800421  bctrl
	ctx.lr = 0x82A9F278;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F278 => {
    //   block [0x82A9F278..0x82A9F27C)
	// 82A9F278: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F27C; continue 'dispatch;
            }
            0x82A9F27C => {
    //   block [0x82A9F27C..0x82A9F290)
	// 82A9F27C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F284: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A9F288: 419A0024  beq cr6, 0x82a9f2ac
	if ctx.cr[6].eq {
	pc = 0x82A9F2AC; continue 'dispatch;
	}
	// 82A9F28C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F290; continue 'dispatch;
            }
            0x82A9F290 => {
    //   block [0x82A9F290..0x82A9F2AC)
	// 82A9F290: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F294: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F298: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F29C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F2A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F2A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F2A8: 4082FFE8  bne 0x82a9f290
	if !ctx.cr[0].eq {
	pc = 0x82A9F290; continue 'dispatch;
	}
	pc = 0x82A9F2AC; continue 'dispatch;
            }
            0x82A9F2AC => {
    //   block [0x82A9F2AC..0x82A9F2C0)
	// 82A9F2AC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A9F2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F2B4: 419A0048  beq cr6, 0x82a9f2fc
	if ctx.cr[6].eq {
	pc = 0x82A9F2FC; continue 'dispatch;
	}
	// 82A9F2B8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F2BC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F2C0; continue 'dispatch;
            }
            0x82A9F2C0 => {
    //   block [0x82A9F2C0..0x82A9F2F8)
	// 82A9F2C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F2C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F2C8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F2CC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F2D0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F2D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F2D8: 4082FFE8  bne 0x82a9f2c0
	if !ctx.cr[0].eq {
	pc = 0x82A9F2C0; continue 'dispatch;
	}
	// 82A9F2DC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F2E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F2E4: 409A0014  bne cr6, 0x82a9f2f8
	if !ctx.cr[6].eq {
	pc = 0x82A9F2F8; continue 'dispatch;
	}
	// 82A9F2E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F2EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F2F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F2F4: 4E800421  bctrl
	ctx.lr = 0x82A9F2F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F2F8 => {
    //   block [0x82A9F2F8..0x82A9F2FC)
	// 82A9F2F8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F2FC; continue 'dispatch;
            }
            0x82A9F2FC => {
    //   block [0x82A9F2FC..0x82A9F310)
	// 82A9F2FC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A9F300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F304: 419A0048  beq cr6, 0x82a9f34c
	if ctx.cr[6].eq {
	pc = 0x82A9F34C; continue 'dispatch;
	}
	// 82A9F308: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F30C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F310; continue 'dispatch;
            }
            0x82A9F310 => {
    //   block [0x82A9F310..0x82A9F348)
	// 82A9F310: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F314: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F318: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F31C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F320: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F324: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F328: 4082FFE8  bne 0x82a9f310
	if !ctx.cr[0].eq {
	pc = 0x82A9F310; continue 'dispatch;
	}
	// 82A9F32C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F330: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F334: 409A0014  bne cr6, 0x82a9f348
	if !ctx.cr[6].eq {
	pc = 0x82A9F348; continue 'dispatch;
	}
	// 82A9F338: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F33C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F340: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F344: 4E800421  bctrl
	ctx.lr = 0x82A9F348;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F348 => {
    //   block [0x82A9F348..0x82A9F34C)
	// 82A9F348: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F34C; continue 'dispatch;
            }
            0x82A9F34C => {
    //   block [0x82A9F34C..0x82A9F380)
	// 82A9F34C: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 82A9F350: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 82A9F354: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A9F358: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A9F35C: 4BFFF385  bl 0x82a9e6e0
	ctx.lr = 0x82A9F360;
	sub_82A9E6E0(ctx, base);
	// 82A9F360: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9F364: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A9F368: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F36C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9F370: 419A0078  beq cr6, 0x82a9f3e8
	if ctx.cr[6].eq {
	pc = 0x82A9F3E8; continue 'dispatch;
	}
	// 82A9F374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9F378: 419A0040  beq cr6, 0x82a9f3b8
	if ctx.cr[6].eq {
	pc = 0x82A9F3B8; continue 'dispatch;
	}
	// 82A9F37C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9F380; continue 'dispatch;
            }
            0x82A9F380 => {
    //   block [0x82A9F380..0x82A9F3B4)
	// 82A9F380: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9F384: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F388: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9F38C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9F390: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F394: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F398: 4082FFE8  bne 0x82a9f380
	if !ctx.cr[0].eq {
	pc = 0x82A9F380; continue 'dispatch;
	}
	// 82A9F39C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F3A0: 409A0014  bne cr6, 0x82a9f3b4
	if !ctx.cr[6].eq {
	pc = 0x82A9F3B4; continue 'dispatch;
	}
	// 82A9F3A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F3A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F3AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F3B0: 4E800421  bctrl
	ctx.lr = 0x82A9F3B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F3B4 => {
    //   block [0x82A9F3B4..0x82A9F3B8)
	// 82A9F3B4: 939E0010  stw r28, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F3B8; continue 'dispatch;
            }
            0x82A9F3B8 => {
    //   block [0x82A9F3B8..0x82A9F3CC)
	// 82A9F3B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F3C0: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A9F3C4: 419A0024  beq cr6, 0x82a9f3e8
	if ctx.cr[6].eq {
	pc = 0x82A9F3E8; continue 'dispatch;
	}
	// 82A9F3C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F3CC; continue 'dispatch;
            }
            0x82A9F3CC => {
    //   block [0x82A9F3CC..0x82A9F3E8)
	// 82A9F3CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F3D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F3D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F3D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F3DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F3E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F3E4: 4082FFE8  bne 0x82a9f3cc
	if !ctx.cr[0].eq {
	pc = 0x82A9F3CC; continue 'dispatch;
	}
	pc = 0x82A9F3E8; continue 'dispatch;
            }
            0x82A9F3E8 => {
    //   block [0x82A9F3E8..0x82A9F3FC)
	// 82A9F3E8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A9F3EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F3F0: 419A0048  beq cr6, 0x82a9f438
	if ctx.cr[6].eq {
	pc = 0x82A9F438; continue 'dispatch;
	}
	// 82A9F3F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F3F8: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F3FC; continue 'dispatch;
            }
            0x82A9F3FC => {
    //   block [0x82A9F3FC..0x82A9F434)
	// 82A9F3FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F400: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F404: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F408: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F40C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F410: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F414: 4082FFE8  bne 0x82a9f3fc
	if !ctx.cr[0].eq {
	pc = 0x82A9F3FC; continue 'dispatch;
	}
	// 82A9F418: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F41C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F420: 409A0014  bne cr6, 0x82a9f434
	if !ctx.cr[6].eq {
	pc = 0x82A9F434; continue 'dispatch;
	}
	// 82A9F424: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F428: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F42C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F430: 4E800421  bctrl
	ctx.lr = 0x82A9F434;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F434 => {
    //   block [0x82A9F434..0x82A9F438)
	// 82A9F434: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F438; continue 'dispatch;
            }
            0x82A9F438 => {
    //   block [0x82A9F438..0x82A9F46C)
	// 82A9F438: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 82A9F43C: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 82A9F440: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82A9F444: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82A9F448: 4BFFF299  bl 0x82a9e6e0
	ctx.lr = 0x82A9F44C;
	sub_82A9E6E0(ctx, base);
	// 82A9F44C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9F450: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9F454: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F458: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9F45C: 419A0078  beq cr6, 0x82a9f4d4
	if ctx.cr[6].eq {
	pc = 0x82A9F4D4; continue 'dispatch;
	}
	// 82A9F460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9F464: 419A0040  beq cr6, 0x82a9f4a4
	if ctx.cr[6].eq {
	pc = 0x82A9F4A4; continue 'dispatch;
	}
	// 82A9F468: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9F46C; continue 'dispatch;
            }
            0x82A9F46C => {
    //   block [0x82A9F46C..0x82A9F4A0)
	// 82A9F46C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9F470: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F474: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9F478: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9F47C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F480: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F484: 4082FFE8  bne 0x82a9f46c
	if !ctx.cr[0].eq {
	pc = 0x82A9F46C; continue 'dispatch;
	}
	// 82A9F488: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F48C: 409A0014  bne cr6, 0x82a9f4a0
	if !ctx.cr[6].eq {
	pc = 0x82A9F4A0; continue 'dispatch;
	}
	// 82A9F490: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F494: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F498: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F49C: 4E800421  bctrl
	ctx.lr = 0x82A9F4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F4A0 => {
    //   block [0x82A9F4A0..0x82A9F4A4)
	// 82A9F4A0: 939E0014  stw r28, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F4A4; continue 'dispatch;
            }
            0x82A9F4A4 => {
    //   block [0x82A9F4A4..0x82A9F4B8)
	// 82A9F4A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F4A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F4AC: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A9F4B0: 419A0024  beq cr6, 0x82a9f4d4
	if ctx.cr[6].eq {
	pc = 0x82A9F4D4; continue 'dispatch;
	}
	// 82A9F4B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F4B8; continue 'dispatch;
            }
            0x82A9F4B8 => {
    //   block [0x82A9F4B8..0x82A9F4D4)
	// 82A9F4B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F4BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F4C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F4C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F4C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F4CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F4D0: 4082FFE8  bne 0x82a9f4b8
	if !ctx.cr[0].eq {
	pc = 0x82A9F4B8; continue 'dispatch;
	}
	pc = 0x82A9F4D4; continue 'dispatch;
            }
            0x82A9F4D4 => {
    //   block [0x82A9F4D4..0x82A9F4E8)
	// 82A9F4D4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A9F4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F4DC: 419A0048  beq cr6, 0x82a9f524
	if ctx.cr[6].eq {
	pc = 0x82A9F524; continue 'dispatch;
	}
	// 82A9F4E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F4E4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F4E8; continue 'dispatch;
            }
            0x82A9F4E8 => {
    //   block [0x82A9F4E8..0x82A9F520)
	// 82A9F4E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F4EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F4F0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F4F4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F4F8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F4FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F500: 4082FFE8  bne 0x82a9f4e8
	if !ctx.cr[0].eq {
	pc = 0x82A9F4E8; continue 'dispatch;
	}
	// 82A9F504: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F508: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F50C: 409A0014  bne cr6, 0x82a9f520
	if !ctx.cr[6].eq {
	pc = 0x82A9F520; continue 'dispatch;
	}
	// 82A9F510: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F514: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F518: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F51C: 4E800421  bctrl
	ctx.lr = 0x82A9F520;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F520 => {
    //   block [0x82A9F520..0x82A9F524)
	// 82A9F520: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F524; continue 'dispatch;
            }
            0x82A9F524 => {
    //   block [0x82A9F524..0x82A9F558)
	// 82A9F524: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 82A9F528: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 82A9F52C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82A9F530: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A9F534: 4BFFF1AD  bl 0x82a9e6e0
	ctx.lr = 0x82A9F538;
	sub_82A9E6E0(ctx, base);
	// 82A9F538: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9F53C: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A9F540: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F544: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9F548: 419A0078  beq cr6, 0x82a9f5c0
	if ctx.cr[6].eq {
	pc = 0x82A9F5C0; continue 'dispatch;
	}
	// 82A9F54C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9F550: 419A0040  beq cr6, 0x82a9f590
	if ctx.cr[6].eq {
	pc = 0x82A9F590; continue 'dispatch;
	}
	// 82A9F554: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9F558; continue 'dispatch;
            }
            0x82A9F558 => {
    //   block [0x82A9F558..0x82A9F58C)
	// 82A9F558: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9F55C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F560: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9F564: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9F568: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F56C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F570: 4082FFE8  bne 0x82a9f558
	if !ctx.cr[0].eq {
	pc = 0x82A9F558; continue 'dispatch;
	}
	// 82A9F574: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F578: 409A0014  bne cr6, 0x82a9f58c
	if !ctx.cr[6].eq {
	pc = 0x82A9F58C; continue 'dispatch;
	}
	// 82A9F57C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F580: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F584: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F588: 4E800421  bctrl
	ctx.lr = 0x82A9F58C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F58C => {
    //   block [0x82A9F58C..0x82A9F590)
	// 82A9F58C: 939E0018  stw r28, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F590; continue 'dispatch;
            }
            0x82A9F590 => {
    //   block [0x82A9F590..0x82A9F5A4)
	// 82A9F590: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F598: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A9F59C: 419A0024  beq cr6, 0x82a9f5c0
	if ctx.cr[6].eq {
	pc = 0x82A9F5C0; continue 'dispatch;
	}
	// 82A9F5A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F5A4; continue 'dispatch;
            }
            0x82A9F5A4 => {
    //   block [0x82A9F5A4..0x82A9F5C0)
	// 82A9F5A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F5A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F5AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F5B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F5B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F5B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F5BC: 4082FFE8  bne 0x82a9f5a4
	if !ctx.cr[0].eq {
	pc = 0x82A9F5A4; continue 'dispatch;
	}
	pc = 0x82A9F5C0; continue 'dispatch;
            }
            0x82A9F5C0 => {
    //   block [0x82A9F5C0..0x82A9F5D4)
	// 82A9F5C0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A9F5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F5C8: 419A0048  beq cr6, 0x82a9f610
	if ctx.cr[6].eq {
	pc = 0x82A9F610; continue 'dispatch;
	}
	// 82A9F5CC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F5D0: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F5D4; continue 'dispatch;
            }
            0x82A9F5D4 => {
    //   block [0x82A9F5D4..0x82A9F60C)
	// 82A9F5D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F5D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F5DC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F5E0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F5E4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F5E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F5EC: 4082FFE8  bne 0x82a9f5d4
	if !ctx.cr[0].eq {
	pc = 0x82A9F5D4; continue 'dispatch;
	}
	// 82A9F5F0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F5F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F5F8: 409A0014  bne cr6, 0x82a9f60c
	if !ctx.cr[6].eq {
	pc = 0x82A9F60C; continue 'dispatch;
	}
	// 82A9F5FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F600: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F604: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F608: 4E800421  bctrl
	ctx.lr = 0x82A9F60C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F60C => {
    //   block [0x82A9F60C..0x82A9F610)
	// 82A9F60C: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F610; continue 'dispatch;
            }
            0x82A9F610 => {
    //   block [0x82A9F610..0x82A9F644)
	// 82A9F610: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 82A9F614: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 82A9F618: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82A9F61C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82A9F620: 4BFFF0C1  bl 0x82a9e6e0
	ctx.lr = 0x82A9F624;
	sub_82A9E6E0(ctx, base);
	// 82A9F624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9F628: 807E0094  lwz r3, 0x94(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A9F62C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F630: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9F634: 419A0078  beq cr6, 0x82a9f6ac
	if ctx.cr[6].eq {
	pc = 0x82A9F6AC; continue 'dispatch;
	}
	// 82A9F638: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9F63C: 419A0040  beq cr6, 0x82a9f67c
	if ctx.cr[6].eq {
	pc = 0x82A9F67C; continue 'dispatch;
	}
	// 82A9F640: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9F644; continue 'dispatch;
            }
            0x82A9F644 => {
    //   block [0x82A9F644..0x82A9F678)
	// 82A9F644: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9F648: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F64C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9F650: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9F654: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F658: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F65C: 4082FFE8  bne 0x82a9f644
	if !ctx.cr[0].eq {
	pc = 0x82A9F644; continue 'dispatch;
	}
	// 82A9F660: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F664: 409A0014  bne cr6, 0x82a9f678
	if !ctx.cr[6].eq {
	pc = 0x82A9F678; continue 'dispatch;
	}
	// 82A9F668: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F66C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F670: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F674: 4E800421  bctrl
	ctx.lr = 0x82A9F678;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F678 => {
    //   block [0x82A9F678..0x82A9F67C)
	// 82A9F678: 939E0094  stw r28, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F67C; continue 'dispatch;
            }
            0x82A9F67C => {
    //   block [0x82A9F67C..0x82A9F690)
	// 82A9F67C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F684: 917E0094  stw r11, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82A9F688: 419A0024  beq cr6, 0x82a9f6ac
	if ctx.cr[6].eq {
	pc = 0x82A9F6AC; continue 'dispatch;
	}
	// 82A9F68C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F690; continue 'dispatch;
            }
            0x82A9F690 => {
    //   block [0x82A9F690..0x82A9F6AC)
	// 82A9F690: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F694: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F698: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F69C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F6A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F6A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F6A8: 4082FFE8  bne 0x82a9f690
	if !ctx.cr[0].eq {
	pc = 0x82A9F690; continue 'dispatch;
	}
	pc = 0x82A9F6AC; continue 'dispatch;
            }
            0x82A9F6AC => {
    //   block [0x82A9F6AC..0x82A9F6C0)
	// 82A9F6AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A9F6B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F6B4: 419A0048  beq cr6, 0x82a9f6fc
	if ctx.cr[6].eq {
	pc = 0x82A9F6FC; continue 'dispatch;
	}
	// 82A9F6B8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A9F6BC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F6C0; continue 'dispatch;
            }
            0x82A9F6C0 => {
    //   block [0x82A9F6C0..0x82A9F6F8)
	// 82A9F6C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F6C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F6C8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F6CC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F6D0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F6D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F6D8: 4082FFE8  bne 0x82a9f6c0
	if !ctx.cr[0].eq {
	pc = 0x82A9F6C0; continue 'dispatch;
	}
	// 82A9F6DC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F6E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F6E4: 409A0014  bne cr6, 0x82a9f6f8
	if !ctx.cr[6].eq {
	pc = 0x82A9F6F8; continue 'dispatch;
	}
	// 82A9F6E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F6EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F6F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F6F4: 4E800421  bctrl
	ctx.lr = 0x82A9F6F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F6F8 => {
    //   block [0x82A9F6F8..0x82A9F6FC)
	// 82A9F6F8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F6FC; continue 'dispatch;
            }
            0x82A9F6FC => {
    //   block [0x82A9F6FC..0x82A9F774)
	// 82A9F6FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A9F700: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A9F704: 4BF82095  bl 0x82a21798
	ctx.lr = 0x82A9F708;
	sub_82A21798(ctx, base);
	// 82A9F708: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A9F70C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9F710: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F714: 915E009C  stw r10, 0x9c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 82A9F718: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F71C: 913E00A0  stw r9, 0xa0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 82A9F720: 48000D81  bl 0x82aa04a0
	ctx.lr = 0x82A9F724;
	sub_82AA04A0(ctx, base);
	// 82A9F724: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A9F728: 4B7756B1  bl 0x82214dd8
	ctx.lr = 0x82A9F72C;
	sub_82214DD8(ctx, base);
	// 82A9F72C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82A9F730: 4B7756A9  bl 0x82214dd8
	ctx.lr = 0x82A9F734;
	sub_82214DD8(ctx, base);
	// 82A9F734: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A9F738: 4B7756A1  bl 0x82214dd8
	ctx.lr = 0x82A9F73C;
	sub_82214DD8(ctx, base);
	// 82A9F73C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82A9F740: 4B775699  bl 0x82214dd8
	ctx.lr = 0x82A9F744;
	sub_82214DD8(ctx, base);
	// 82A9F744: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A9F748: 4B775691  bl 0x82214dd8
	ctx.lr = 0x82A9F74C;
	sub_82214DD8(ctx, base);
	// 82A9F74C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82A9F750: 4B775689  bl 0x82214dd8
	ctx.lr = 0x82A9F754;
	sub_82214DD8(ctx, base);
	// 82A9F754: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A9F758: 4B775681  bl 0x82214dd8
	ctx.lr = 0x82A9F75C;
	sub_82214DD8(ctx, base);
	// 82A9F75C: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82A9F760: 4B775679  bl 0x82214dd8
	ctx.lr = 0x82A9F764;
	sub_82214DD8(ctx, base);
	// 82A9F764: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A9F768: 4B775671  bl 0x82214dd8
	ctx.lr = 0x82A9F76C;
	sub_82214DD8(ctx, base);
	// 82A9F76C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A9F770: 48209CE8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9F778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9F778 size=328
    let mut pc: u32 = 0x82A9F778;
    'dispatch: loop {
        match pc {
            0x82A9F778 => {
    //   block [0x82A9F778..0x82A9F79C)
	// 82A9F778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9F77C: 48209C85  bl 0x82ca9400
	ctx.lr = 0x82A9F780;
	sub_82CA93D0(ctx, base);
	// 82A9F780: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9F784: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A9F788: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A9F78C: 3B4B5278  addi r26, r11, 0x5278
	ctx.r[26].s64 = ctx.r[11].s64 + 21112;
	// 82A9F790: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 82A9F794: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A9F798: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82A9F79C; continue 'dispatch;
            }
            0x82A9F79C => {
    //   block [0x82A9F79C..0x82A9F7F8)
	// 82A9F79C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F7A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F7A4: 419A0100  beq cr6, 0x82a9f8a4
	if ctx.cr[6].eq {
	pc = 0x82A9F8A4; continue 'dispatch;
	}
	// 82A9F7A8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A9F7AC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A9F7B0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F7B4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A9F7B8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A9F7BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A9F7C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9F7C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A9F7C8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A9F7CC: 4BFBCB4D  bl 0x82a5c318
	ctx.lr = 0x82A9F7D0;
	sub_82A5C318(ctx, base);
	// 82A9F7D0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A9F7D4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A9F7D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A9F7DC: 419A0080  beq cr6, 0x82a9f85c
	if ctx.cr[6].eq {
	pc = 0x82A9F85C; continue 'dispatch;
	}
	// 82A9F7E0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F7E4: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A9F7E8: 419A0074  beq cr6, 0x82a9f85c
	if ctx.cr[6].eq {
	pc = 0x82A9F85C; continue 'dispatch;
	}
	// 82A9F7EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9F7F0: 419A0040  beq cr6, 0x82a9f830
	if ctx.cr[6].eq {
	pc = 0x82A9F830; continue 'dispatch;
	}
	// 82A9F7F4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9F7F8; continue 'dispatch;
            }
            0x82A9F7F8 => {
    //   block [0x82A9F7F8..0x82A9F82C)
	// 82A9F7F8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9F7FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F800: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9F804: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9F808: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F80C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F810: 4082FFE8  bne 0x82a9f7f8
	if !ctx.cr[0].eq {
	pc = 0x82A9F7F8; continue 'dispatch;
	}
	// 82A9F814: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F818: 409A0014  bne cr6, 0x82a9f82c
	if !ctx.cr[6].eq {
	pc = 0x82A9F82C; continue 'dispatch;
	}
	// 82A9F81C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F820: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F824: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F828: 4E800421  bctrl
	ctx.lr = 0x82A9F82C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F82C => {
    //   block [0x82A9F82C..0x82A9F830)
	// 82A9F82C: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A9F830; continue 'dispatch;
            }
            0x82A9F830 => {
    //   block [0x82A9F830..0x82A9F840)
	// 82A9F830: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A9F834: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A9F838: 419A006C  beq cr6, 0x82a9f8a4
	if ctx.cr[6].eq {
	pc = 0x82A9F8A4; continue 'dispatch;
	}
	// 82A9F83C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A9F840; continue 'dispatch;
            }
            0x82A9F840 => {
    //   block [0x82A9F840..0x82A9F85C)
	// 82A9F840: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F848: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F84C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F850: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F854: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F858: 4082FFE8  bne 0x82a9f840
	if !ctx.cr[0].eq {
	pc = 0x82A9F840; continue 'dispatch;
	}
	pc = 0x82A9F85C; continue 'dispatch;
            }
            0x82A9F85C => {
    //   block [0x82A9F85C..0x82A9F868)
	// 82A9F85C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A9F860: 419A0044  beq cr6, 0x82a9f8a4
	if ctx.cr[6].eq {
	pc = 0x82A9F8A4; continue 'dispatch;
	}
	// 82A9F864: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A9F868; continue 'dispatch;
            }
            0x82A9F868 => {
    //   block [0x82A9F868..0x82A9F8A4)
	// 82A9F868: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F86C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F870: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F874: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A9F878: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F87C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F880: 4082FFE8  bne 0x82a9f868
	if !ctx.cr[0].eq {
	pc = 0x82A9F868; continue 'dispatch;
	}
	// 82A9F884: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A9F888: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F88C: 409A0018  bne cr6, 0x82a9f8a4
	if !ctx.cr[6].eq {
	pc = 0x82A9F8A4; continue 'dispatch;
	}
	// 82A9F890: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9F898: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F89C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F8A0: 4E800421  bctrl
	ctx.lr = 0x82A9F8A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F8A4 => {
    //   block [0x82A9F8A4..0x82A9F8C0)
	// 82A9F8A4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A9F8A8: 397A0018  addi r11, r26, 0x18
	ctx.r[11].s64 = ctx.r[26].s64 + 24;
	// 82A9F8AC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A9F8B0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9F8B4: 4198FEE8  blt cr6, 0x82a9f79c
	if ctx.cr[6].lt {
	pc = 0x82A9F79C; continue 'dispatch;
	}
	// 82A9F8B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A9F8BC: 48209B94  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9F8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9F8C0 size=628
    let mut pc: u32 = 0x82A9F8C0;
    'dispatch: loop {
        match pc {
            0x82A9F8C0 => {
    //   block [0x82A9F8C0..0x82A9F8EC)
	// 82A9F8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9F8C4: 48209B3D  bl 0x82ca9400
	ctx.lr = 0x82A9F8C8;
	sub_82CA93D0(ctx, base);
	// 82A9F8C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9F8CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A9F8D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A9F8D4: 3B600006  li r27, 6
	ctx.r[27].s64 = 6;
	// 82A9F8D8: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82A9F8DC: 7F9EE850  subf r28, r30, r29
	ctx.r[28].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A9F8E0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F8E4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A9F8E8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A9F8EC; continue 'dispatch;
            }
            0x82A9F8EC => {
    //   block [0x82A9F8EC..0x82A9F908)
	// 82A9F8EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F8F0: 7D7CF82E  lwzx r11, r28, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A9F8F4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9F8F8: 419A0078  beq cr6, 0x82a9f970
	if ctx.cr[6].eq {
	pc = 0x82A9F970; continue 'dispatch;
	}
	// 82A9F8FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9F900: 419A0040  beq cr6, 0x82a9f940
	if ctx.cr[6].eq {
	pc = 0x82A9F940; continue 'dispatch;
	}
	// 82A9F904: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9F908; continue 'dispatch;
            }
            0x82A9F908 => {
    //   block [0x82A9F908..0x82A9F93C)
	// 82A9F908: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9F90C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F910: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9F914: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9F918: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F91C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F920: 4082FFE8  bne 0x82a9f908
	if !ctx.cr[0].eq {
	pc = 0x82A9F908; continue 'dispatch;
	}
	// 82A9F924: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9F928: 409A0014  bne cr6, 0x82a9f93c
	if !ctx.cr[6].eq {
	pc = 0x82A9F93C; continue 'dispatch;
	}
	// 82A9F92C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F930: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9F934: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9F938: 4E800421  bctrl
	ctx.lr = 0x82A9F93C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9F93C => {
    //   block [0x82A9F93C..0x82A9F940)
	// 82A9F93C: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82A9F940; continue 'dispatch;
            }
            0x82A9F940 => {
    //   block [0x82A9F940..0x82A9F954)
	// 82A9F940: 7D7CF82E  lwzx r11, r28, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A9F944: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9F948: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A9F94C: 419A0024  beq cr6, 0x82a9f970
	if ctx.cr[6].eq {
	pc = 0x82A9F970; continue 'dispatch;
	}
	// 82A9F950: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9F954; continue 'dispatch;
            }
            0x82A9F954 => {
    //   block [0x82A9F954..0x82A9F970)
	// 82A9F954: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9F958: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F95C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9F960: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9F964: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9F968: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9F96C: 4082FFE8  bne 0x82a9f954
	if !ctx.cr[0].eq {
	pc = 0x82A9F954; continue 'dispatch;
	}
	pc = 0x82A9F970; continue 'dispatch;
            }
            0x82A9F970 => {
    //   block [0x82A9F970..0x82A9F98C)
	// 82A9F970: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82A9F974: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A9F978: 4082FF74  bne 0x82a9f8ec
	if !ctx.cr[0].eq {
	pc = 0x82A9F8EC; continue 'dispatch;
	}
	// 82A9F97C: 397D001C  addi r11, r29, 0x1c
	ctx.r[11].s64 = ctx.r[29].s64 + 28;
	// 82A9F980: 395E001C  addi r10, r30, 0x1c
	ctx.r[10].s64 = ctx.r[30].s64 + 28;
	// 82A9F984: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82A9F988: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A9F98C; continue 'dispatch;
            }
            0x82A9F98C => {
    //   block [0x82A9F98C..0x82A9F9B0)
	// 82A9F98C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F990: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9F994: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A9F998: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A9F99C: 4200FFF0  bdnz 0x82a9f98c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A9F98C; continue 'dispatch;
	}
	// 82A9F9A0: 397D0030  addi r11, r29, 0x30
	ctx.r[11].s64 = ctx.r[29].s64 + 48;
	// 82A9F9A4: 395E0030  addi r10, r30, 0x30
	ctx.r[10].s64 = ctx.r[30].s64 + 48;
	// 82A9F9A8: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82A9F9AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A9F9B0; continue 'dispatch;
            }
            0x82A9F9B0 => {
    //   block [0x82A9F9B0..0x82A9F9D4)
	// 82A9F9B0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F9B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9F9B8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A9F9BC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A9F9C0: 4200FFF0  bdnz 0x82a9f9b0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A9F9B0; continue 'dispatch;
	}
	// 82A9F9C4: 397D0044  addi r11, r29, 0x44
	ctx.r[11].s64 = ctx.r[29].s64 + 68;
	// 82A9F9C8: 395E0044  addi r10, r30, 0x44
	ctx.r[10].s64 = ctx.r[30].s64 + 68;
	// 82A9F9CC: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82A9F9D0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A9F9D4; continue 'dispatch;
            }
            0x82A9F9D4 => {
    //   block [0x82A9F9D4..0x82A9F9F8)
	// 82A9F9D4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F9D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9F9DC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A9F9E0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A9F9E4: 4200FFF0  bdnz 0x82a9f9d4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A9F9D4; continue 'dispatch;
	}
	// 82A9F9E8: 397D0058  addi r11, r29, 0x58
	ctx.r[11].s64 = ctx.r[29].s64 + 88;
	// 82A9F9EC: 395E0058  addi r10, r30, 0x58
	ctx.r[10].s64 = ctx.r[30].s64 + 88;
	// 82A9F9F0: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82A9F9F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A9F9F8; continue 'dispatch;
            }
            0x82A9F9F8 => {
    //   block [0x82A9F9F8..0x82A9FA1C)
	// 82A9F9F8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9F9FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9FA00: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A9FA04: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A9FA08: 4200FFF0  bdnz 0x82a9f9f8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A9F9F8; continue 'dispatch;
	}
	// 82A9FA0C: 397D006C  addi r11, r29, 0x6c
	ctx.r[11].s64 = ctx.r[29].s64 + 108;
	// 82A9FA10: 395E006C  addi r10, r30, 0x6c
	ctx.r[10].s64 = ctx.r[30].s64 + 108;
	// 82A9FA14: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82A9FA18: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A9FA1C; continue 'dispatch;
            }
            0x82A9FA1C => {
    //   block [0x82A9FA1C..0x82A9FA40)
	// 82A9FA1C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FA20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9FA24: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A9FA28: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A9FA2C: 4200FFF0  bdnz 0x82a9fa1c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A9FA1C; continue 'dispatch;
	}
	// 82A9FA30: 397D0080  addi r11, r29, 0x80
	ctx.r[11].s64 = ctx.r[29].s64 + 128;
	// 82A9FA34: 395E0080  addi r10, r30, 0x80
	ctx.r[10].s64 = ctx.r[30].s64 + 128;
	// 82A9FA38: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82A9FA3C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A9FA40; continue 'dispatch;
            }
            0x82A9FA40 => {
    //   block [0x82A9FA40..0x82A9FA70)
	// 82A9FA40: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FA44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9FA48: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A9FA4C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A9FA50: 4200FFF0  bdnz 0x82a9fa40
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A9FA40; continue 'dispatch;
	}
	// 82A9FA54: 817D0094  lwz r11, 0x94(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A9FA58: 807E0094  lwz r3, 0x94(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A9FA5C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A9FA60: 419A0078  beq cr6, 0x82a9fad8
	if ctx.cr[6].eq {
	pc = 0x82A9FAD8; continue 'dispatch;
	}
	// 82A9FA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9FA68: 419A0040  beq cr6, 0x82a9faa8
	if ctx.cr[6].eq {
	pc = 0x82A9FAA8; continue 'dispatch;
	}
	// 82A9FA6C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A9FA70; continue 'dispatch;
            }
            0x82A9FA70 => {
    //   block [0x82A9FA70..0x82A9FAA4)
	// 82A9FA70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A9FA74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FA78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A9FA7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A9FA80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9FA84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FA88: 4082FFE8  bne 0x82a9fa70
	if !ctx.cr[0].eq {
	pc = 0x82A9FA70; continue 'dispatch;
	}
	// 82A9FA8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9FA90: 409A0014  bne cr6, 0x82a9faa4
	if !ctx.cr[6].eq {
	pc = 0x82A9FAA4; continue 'dispatch;
	}
	// 82A9FA94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FA98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FA9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A9FAA0: 4E800421  bctrl
	ctx.lr = 0x82A9FAA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A9FAA4 => {
    //   block [0x82A9FAA4..0x82A9FAA8)
	// 82A9FAA4: 935E0094  stw r26, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	pc = 0x82A9FAA8; continue 'dispatch;
            }
            0x82A9FAA8 => {
    //   block [0x82A9FAA8..0x82A9FABC)
	// 82A9FAA8: 817D0094  lwz r11, 0x94(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A9FAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FAB0: 917E0094  stw r11, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82A9FAB4: 419A0024  beq cr6, 0x82a9fad8
	if ctx.cr[6].eq {
	pc = 0x82A9FAD8; continue 'dispatch;
	}
	// 82A9FAB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A9FABC; continue 'dispatch;
            }
            0x82A9FABC => {
    //   block [0x82A9FABC..0x82A9FAD8)
	// 82A9FABC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9FAC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FAC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9FAC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9FACC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9FAD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FAD4: 4082FFE8  bne 0x82a9fabc
	if !ctx.cr[0].eq {
	pc = 0x82A9FABC; continue 'dispatch;
	}
	pc = 0x82A9FAD8; continue 'dispatch;
            }
            0x82A9FAD8 => {
    //   block [0x82A9FAD8..0x82A9FB34)
	// 82A9FAD8: 897D0098  lbz r11, 0x98(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A9FADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FAE0: 997E0098  stb r11, 0x98(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 82A9FAE4: 895D0099  lbz r10, 0x99(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(153 as u32) ) } as u64;
	// 82A9FAE8: 995E0099  stb r10, 0x99(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(153 as u32), ctx.r[10].u8 ) };
	// 82A9FAEC: 893D009A  lbz r9, 0x9a(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(154 as u32) ) } as u64;
	// 82A9FAF0: 993E009A  stb r9, 0x9a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(154 as u32), ctx.r[9].u8 ) };
	// 82A9FAF4: 891D009B  lbz r8, 0x9b(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(155 as u32) ) } as u64;
	// 82A9FAF8: 991E009B  stb r8, 0x9b(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(155 as u32), ctx.r[8].u8 ) };
	// 82A9FAFC: 80FD009C  lwz r7, 0x9c(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A9FB00: 90FE009C  stw r7, 0x9c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), ctx.r[7].u32 ) };
	// 82A9FB04: 80DD00A0  lwz r6, 0xa0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 82A9FB08: 90DE00A0  stw r6, 0xa0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), ctx.r[6].u32 ) };
	// 82A9FB0C: 80BD00A4  lwz r5, 0xa4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A9FB10: 90BE00A4  stw r5, 0xa4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82A9FB14: 809D00A8  lwz r4, 0xa8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) } as u64;
	// 82A9FB18: 909E00A8  stw r4, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[4].u32 ) };
	// 82A9FB1C: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A9FB20: 917E00AC  stw r11, 0xac(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82A9FB24: 815D00B0  lwz r10, 0xb0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A9FB28: 915E00B0  stw r10, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 82A9FB2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A9FB30: 48209920  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9FB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A9FB38 size=352
    let mut pc: u32 = 0x82A9FB38;
    'dispatch: loop {
        match pc {
            0x82A9FB38 => {
    //   block [0x82A9FB38..0x82A9FB7C)
	// 82A9FB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9FB3C: 482098CD  bl 0x82ca9408
	ctx.lr = 0x82A9FB40;
	sub_82CA93D0(ctx, base);
	// 82A9FB40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9FB44: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 82A9FB48: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A9FB4C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A9FB50: 7D255A14  add r9, r5, r11
	ctx.r[9].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82A9FB54: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 82A9FB58: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A9FB5C: 396551A0  addi r11, r5, 0x51a0
	ctx.r[11].s64 = ctx.r[5].s64 + 20896;
	// 82A9FB60: 7C6A182E  lwzx r3, r10, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82A9FB64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A9FB68: 7FC95A14  add r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A9FB6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9FB70: 409A000C  bne cr6, 0x82a9fb7c
	if !ctx.cr[6].eq {
	pc = 0x82A9FB7C; continue 'dispatch;
	}
	// 82A9FB74: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A9FB78: 482098E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A9FB7C => {
    //   block [0x82A9FB7C..0x82A9FBE0)
	// 82A9FB7C: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FB80: 5505063E  clrlwi r5, r8, 0x18
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82A9FB84: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FB88: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 82A9FB8C: 80C30094  lwz r6, 0x94(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A9FB90: 3948FFFF  addi r10, r8, -1
	ctx.r[10].s64 = ctx.r[8].s64 + -1;
	// 82A9FB94: 80830098  lwz r4, 0x98(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A9FB98: 7D7DFE70  srawi r29, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 82A9FB9C: 7D5CFE70  srawi r28, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A9FBA0: 7FAB5838  and r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 & ctx.r[11].u64;
	// 82A9FBA4: 7F8A5038  and r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 & ctx.r[10].u64;
	// 82A9FBA8: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A9FBAC: 7D0A4050  subf r8, r10, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82A9FBB0: 7D664BD6  divw r11, r6, r9
	ctx.r[11].s32 = ctx.r[6].s32 / ctx.r[9].s32;
	// 82A9FBB4: 7CC443D6  divw r6, r4, r8
	ctx.r[6].s32 = ctx.r[4].s32 / ctx.r[8].s32;
	// 82A9FBB8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A9FBBC: 7C8B3050  subf r4, r11, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 82A9FBC0: 7C8AFE70  srawi r10, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 82A9FBC4: 7D4A2038  and r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	// 82A9FBC8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A9FBCC: 61280001  ori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 | 1;
	// 82A9FBD0: 7D060034  cntlzw r6, r8
	ctx.r[6].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 82A9FBD4: 20C6001F  subfic r6, r6, 0x1f
	ctx.xer.ca = ctx.r[6].u32 <= 31 as u32;
	ctx.r[6].s64 = (31 as i64) - ctx.r[6].s64;
	// 82A9FBD8: 419A0008  beq cr6, 0x82a9fbe0
	if ctx.cr[6].eq {
	pc = 0x82A9FBE0; continue 'dispatch;
	}
	// 82A9FBDC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	pc = 0x82A9FBE0; continue 'dispatch;
            }
            0x82A9FBE0 => {
    //   block [0x82A9FBE0..0x82A9FC8C)
	// 82A9FBE0: 21650000  subfic r11, r5, 0
	ctx.xer.ca = ctx.r[5].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[5].s64;
	// 82A9FBE4: 80BE0018  lwz r5, 0x18(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A9FBE8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82A9FBEC: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A9FBF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A9FBF4: 55470738  rlwinm r7, r10, 0, 0x1c, 0x1c
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A9FBF8: 4B782CD9  bl 0x822228d0
	ctx.lr = 0x82A9FBFC;
	sub_822228D0(ctx, base);
	// 82A9FBFC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A9FC00: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A9FC04: 409A0088  bne cr6, 0x82a9fc8c
	if !ctx.cr[6].eq {
	pc = 0x82A9FC8C; continue 'dispatch;
	}
	// 82A9FC08: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A9FC0C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A9FC10: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A9FC14: 390B4370  addi r8, r11, 0x4370
	ctx.r[8].s64 = ctx.r[11].s64 + 17264;
	// 82A9FC18: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A9FC1C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A9FC20: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A9FC24: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82A9FC28: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	pc = 0x82A9FC8C; continue 'dispatch;
            }
            0x82A9FC8C => {
    //   block [0x82A9FC8C..0x82A9FC98)
	// 82A9FC8C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A9FC90: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A9FC94: 482097C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9FC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9FC98 size=224
    let mut pc: u32 = 0x82A9FC98;
    'dispatch: loop {
        match pc {
            0x82A9FC98 => {
    //   block [0x82A9FC98..0x82A9FCD0)
	// 82A9FC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9FC9C: 4820975D  bl 0x82ca93f8
	ctx.lr = 0x82A9FCA0;
	sub_82CA93D0(ctx, base);
	// 82A9FCA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9FCA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A9FCA8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A9FCAC: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82A9FCB0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A9FCB4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A9FCB8: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FCBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A9FCC0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A9FCC4: 419A0084  beq cr6, 0x82a9fd48
	if ctx.cr[6].eq {
	pc = 0x82A9FD48; continue 'dispatch;
	}
	// 82A9FCC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A9FCCC: 3B2B51A0  addi r25, r11, 0x51a0
	ctx.r[25].s64 = ctx.r[11].s64 + 20896;
	pc = 0x82A9FCD0; continue 'dispatch;
            }
            0x82A9FCD0 => {
    //   block [0x82A9FCD0..0x82A9FCF4)
	// 82A9FCD0: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A9FCD4: 39590008  addi r10, r25, 8
	ctx.r[10].s64 = ctx.r[25].s64 + 8;
	// 82A9FCD8: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A9FCDC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A9FCE0: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A9FCE4: 7CC8502E  lwzx r6, r8, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A9FCE8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A9FCEC: 41980008  blt cr6, 0x82a9fcf4
	if ctx.cr[6].lt {
	pc = 0x82A9FCF4; continue 'dispatch;
	}
	// 82A9FCF0: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	pc = 0x82A9FCF4; continue 'dispatch;
            }
            0x82A9FCF4 => {
    //   block [0x82A9FCF4..0x82A9FD28)
	// 82A9FCF4: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A9FCF8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82A9FCFC: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A9FD00: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A9FD04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A9FD08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A9FD0C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A9FD10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FD14: 388B001C  addi r4, r11, 0x1c
	ctx.r[4].s64 = ctx.r[11].s64 + 28;
	// 82A9FD18: 4BFFFE21  bl 0x82a9fb38
	ctx.lr = 0x82A9FD1C;
	sub_82A9FB38(ctx, base);
	// 82A9FD1C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A9FD20: 57A9063E  clrlwi r9, r29, 0x18
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82A9FD24: 7D5D4838  and r29, r10, r9
	ctx.r[29].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	pc = 0x82A9FD28; continue 'dispatch;
            }
            0x82A9FD28 => {
    //   block [0x82A9FD28..0x82A9FD48)
	// 82A9FD28: 579CF87E  srwi r28, r28, 1
	ctx.r[28].u32 = ctx.r[28].u32.wrapping_shr(1);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A9FD2C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A9FD30: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A9FD34: 419A0014  beq cr6, 0x82a9fd48
	if ctx.cr[6].eq {
	pc = 0x82A9FD48; continue 'dispatch;
	}
	// 82A9FD38: 578B07FE  clrlwi r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82A9FD3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FD40: 419AFFE8  beq cr6, 0x82a9fd28
	if ctx.cr[6].eq {
	pc = 0x82A9FD28; continue 'dispatch;
	}
	// 82A9FD44: 4BFFFF8C  b 0x82a9fcd0
	pc = 0x82A9FCD0; continue 'dispatch;
            }
            0x82A9FD48 => {
    //   block [0x82A9FD48..0x82A9FD78)
	// 82A9FD48: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A9FD4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A9FD50: 816BFA0C  lwz r11, -0x5f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 82A9FD54: 814B0514  lwz r10, 0x514(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82A9FD58: 915E00A4  stw r10, 0xa4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 82A9FD5C: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FD60: 913E00A8  stw r9, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[9].u32 ) };
	// 82A9FD64: 811B0004  lwz r8, 4(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FD68: 911E00AC  stw r8, 0xac(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[8].u32 ) };
	// 82A9FD6C: 931E00B0  stw r24, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[24].u32 ) };
	// 82A9FD70: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A9FD74: 482096D4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9FD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9FD78 size=444
    let mut pc: u32 = 0x82A9FD78;
    'dispatch: loop {
        match pc {
            0x82A9FD78 => {
    //   block [0x82A9FD78..0x82A9FDB0)
	// 82A9FD78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9FD7C: 48209691  bl 0x82ca940c
	ctx.lr = 0x82A9FD80;
	sub_82CA93D0(ctx, base);
	// 82A9FD80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9FD84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A9FD88: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A9FD8C: 5489063E  clrlwi r9, r4, 0x18
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82A9FD90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A9FD94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A9FD98: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FD9C: 816B6F20  lwz r11, 0x6f20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28448 as u32) ) } as u64;
	// 82A9FDA0: 7D5F5B78  or r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 82A9FDA4: 419A0038  beq cr6, 0x82a9fddc
	if ctx.cr[6].eq {
	pc = 0x82A9FDDC; continue 'dispatch;
	}
	// 82A9FDA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A9FDAC: 419A0064  beq cr6, 0x82a9fe10
	if ctx.cr[6].eq {
	pc = 0x82A9FE10; continue 'dispatch;
	}
	pc = 0x82A9FDB0; continue 'dispatch;
            }
            0x82A9FDB0 => {
    //   block [0x82A9FDB0..0x82A9FDBC)
	// 82A9FDB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A9FDB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A9FDB8: 480004C1  bl 0x82aa0278
	ctx.lr = 0x82A9FDBC;
	sub_82AA0278(ctx, base);
	pc = 0x82A9FDBC; continue 'dispatch;
            }
            0x82A9FDBC => {
    //   block [0x82A9FDBC..0x82A9FDDC)
	// 82A9FDBC: 57FFF87E  srwi r31, r31, 1
	ctx.r[31].u32 = ctx.r[31].u32.wrapping_shr(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A9FDC0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A9FDC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A9FDC8: 419A0048  beq cr6, 0x82a9fe10
	if ctx.cr[6].eq {
	pc = 0x82A9FE10; continue 'dispatch;
	}
	// 82A9FDCC: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 82A9FDD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FDD4: 419AFFE8  beq cr6, 0x82a9fdbc
	if ctx.cr[6].eq {
	pc = 0x82A9FDBC; continue 'dispatch;
	}
	// 82A9FDD8: 4BFFFFD8  b 0x82a9fdb0
	pc = 0x82A9FDB0; continue 'dispatch;
            }
            0x82A9FDDC => {
    //   block [0x82A9FDDC..0x82A9FDE4)
	// 82A9FDDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A9FDE0: 419A0030  beq cr6, 0x82a9fe10
	if ctx.cr[6].eq {
	pc = 0x82A9FE10; continue 'dispatch;
	}
	pc = 0x82A9FDE4; continue 'dispatch;
            }
            0x82A9FDE4 => {
    //   block [0x82A9FDE4..0x82A9FDF0)
	// 82A9FDE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A9FDE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A9FDEC: 4800014D  bl 0x82a9ff38
	ctx.lr = 0x82A9FDF0;
	sub_82A9FF38(ctx, base);
	pc = 0x82A9FDF0; continue 'dispatch;
            }
            0x82A9FDF0 => {
    //   block [0x82A9FDF0..0x82A9FE10)
	// 82A9FDF0: 57FFF87E  srwi r31, r31, 1
	ctx.r[31].u32 = ctx.r[31].u32.wrapping_shr(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A9FDF4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A9FDF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A9FDFC: 419A0014  beq cr6, 0x82a9fe10
	if ctx.cr[6].eq {
	pc = 0x82A9FE10; continue 'dispatch;
	}
	// 82A9FE00: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 82A9FE04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FE08: 419AFFE8  beq cr6, 0x82a9fdf0
	if ctx.cr[6].eq {
	pc = 0x82A9FDF0; continue 'dispatch;
	}
	// 82A9FE0C: 4BFFFFD8  b 0x82a9fde4
	pc = 0x82A9FDE4; continue 'dispatch;
            }
            0x82A9FE10 => {
    //   block [0x82A9FE10..0x82A9FEEC)
	// 82A9FE10: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A9FE14: 394BDED4  addi r10, r11, -0x212c
	ctx.r[10].s64 = ctx.r[11].s64 + -8492;
	// 82A9FE18: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FE1C: 83EB03F0  lwz r31, 0x3f0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82A9FE20: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A9FE24: 41980100  blt cr6, 0x82a9ff24
	if ctx.cr[6].lt {
	pc = 0x82A9FF24; continue 'dispatch;
	}
	// 82A9FE28: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A9FE2C: 391F0020  addi r8, r31, 0x20
	ctx.r[8].s64 = ctx.r[31].s64 + 32;
	// 82A9FE30: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A9FE34: 392B01F0  addi r9, r11, 0x1f0
	ctx.r[9].s64 = ctx.r[11].s64 + 496;
	// 82A9FE38: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A9FE3C: 79060020  clrldi r6, r8, 0x20
	ctx.r[6].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 82A9FE40: 78EBFFE6  rldicr r11, r7, 0x3f, 0x3f
	ctx.r[11].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82A9FE44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A9FE48: 7D663436  srd r6, r11, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[11].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 82A9FE4C: 80A90018  lwz r5, 0x18(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A9FE50: 806A0364  lwz r3, 0x364(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A9FE54: 4B71708D  bl 0x821b6ee0
	ctx.lr = 0x82A9FE58;
	sub_821B6EE0(ctx, base);
	// 82A9FE58: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A9FE5C: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 82A9FE60: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A9FE64: 396A63A0  addi r11, r10, 0x63a0
	ctx.r[11].s64 = ctx.r[10].s64 + 25504;
	// 82A9FE68: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A9FE6C: 396B08D0  addi r11, r11, 0x8d0
	ctx.r[11].s64 = ctx.r[11].s64 + 2256;
	// 82A9FE70: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 82A9FE74: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A9FE78: 3CE0834B  lis r7, -0x7cb5
	ctx.r[7].s64 = -2092236800;
	// 82A9FE7C: 38C86FCC  addi r6, r8, 0x6fcc
	ctx.r[6].s64 = ctx.r[8].s64 + 28620;
	// 82A9FE80: 39472390  addi r10, r7, 0x2390
	ctx.r[10].s64 = ctx.r[7].s64 + 9104;
	// 82A9FE84: 88AB0015  lbz r5, 0x15(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A9FE88: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FE8C: 1D252008  mulli r9, r5, 0x2008
	ctx.r[9].s32 = ((ctx.r[5].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A9FE90: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FE94: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A9FE98: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A9FE9C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A9FEA0: 419A0084  beq cr6, 0x82a9ff24
	if ctx.cr[6].eq {
	pc = 0x82A9FF24; continue 'dispatch;
	}
	// 82A9FEA4: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A9FEA8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A9FEAC: 7CE64838  and r6, r7, r9
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82A9FEB0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A9FEB4: 409A0038  bne cr6, 0x82a9feec
	if !ctx.cr[6].eq {
	pc = 0x82A9FEEC; continue 'dispatch;
	}
	// 82A9FEB8: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A9FEBC: 7CE54B78  or r5, r7, r9
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[9].u64;
	// 82A9FEC0: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A9FEC4: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A9FEC8: 7D64512E  stwx r11, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A9FECC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FED0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A9FED4: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A9FED8: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A9FEDC: 90670004  stw r3, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A9FEE0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A9FEE4: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 82A9FEE8: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x82A9FEEC; continue 'dispatch;
            }
            0x82A9FEEC => {
    //   block [0x82A9FEEC..0x82A9FF24)
	// 82A9FEEC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A9FEF0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A9FEF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A9FEF8: 409A002C  bne cr6, 0x82a9ff24
	if !ctx.cr[6].eq {
	pc = 0x82A9FF24; continue 'dispatch;
	}
	// 82A9FEFC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A9FF00: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82A9FF04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A9FF08: 38C80DB8  addi r6, r8, 0xdb8
	ctx.r[6].s64 = ctx.r[8].s64 + 3512;
	// 82A9FF0C: 98EB0014  stb r7, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[7].u8 ) };
	// 82A9FF10: 81490DB0  lwz r10, 0xdb0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A9FF14: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A9FF18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9FF1C: 91490DB0  stw r10, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 82A9FF20: 7D65312E  stwx r11, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	pc = 0x82A9FF24; continue 'dispatch;
            }
            0x82A9FF24 => {
    //   block [0x82A9FF24..0x82A9FF34)
	// 82A9FF24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A9FF28: 480004D1  bl 0x82aa03f8
	ctx.lr = 0x82A9FF2C;
	sub_82AA03F8(ctx, base);
	// 82A9FF2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A9FF30: 4820952C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9FF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9FF38 size=444
    let mut pc: u32 = 0x82A9FF38;
    'dispatch: loop {
        match pc {
            0x82A9FF38 => {
    //   block [0x82A9FF38..0x82A9FF80)
	// 82A9FF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9FF3C: 482094D1  bl 0x82ca940c
	ctx.lr = 0x82A9FF40;
	sub_82CA93D0(ctx, base);
	// 82A9FF40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9FF44: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A9FF48: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82A9FF4C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A9FF50: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A9FF54: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A9FF58: 7D0B4A14  add r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A9FF5C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A9FF60: 392751A0  addi r9, r7, 0x51a0
	ctx.r[9].s64 = ctx.r[7].s64 + 20896;
	// 82A9FF64: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A9FF68: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82A9FF6C: 7FC84A14  add r30, r8, r9
	ctx.r[30].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A9FF70: 394A001C  addi r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 + 28;
	// 82A9FF74: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A9FF78: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82A9FF7C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A9FF80; continue 'dispatch;
            }
            0x82A9FF80 => {
    //   block [0x82A9FF80..0x82AA0088)
	// 82A9FF80: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FF84: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A9FF88: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A9FF8C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A9FF90: 4200FFF0  bdnz 0x82a9ff80
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A9FF80; continue 'dispatch;
	}
	// 82A9FF94: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FF98: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A9FF9C: 419800EC  blt cr6, 0x82aa0088
	if ctx.cr[6].lt {
	pc = 0x82AA0088; continue 'dispatch;
	}
	// 82A9FFA0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A9FFA4: 39240020  addi r9, r4, 0x20
	ctx.r[9].s64 = ctx.r[4].s64 + 32;
	// 82A9FFA8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A9FFAC: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A9FFB0: 38AA01F0  addi r5, r10, 0x1f0
	ctx.r[5].s64 = ctx.r[10].s64 + 496;
	// 82A9FFB4: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 82A9FFB8: 791FFFE6  rldicr r31, r8, 0x3f, 0x3f
	ctx.r[31].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82A9FFBC: 792B0020  clrldi r11, r9, 0x20
	ctx.r[11].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 82A9FFC0: 7FE65C36  srd r6, r31, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[31].u64) >> ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82A9FFC4: 7CA7282E  lwzx r5, r7, r5
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82A9FFC8: 807D0364  lwz r3, 0x364(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A9FFCC: 4B716F15  bl 0x821b6ee0
	ctx.lr = 0x82A9FFD0;
	sub_821B6EE0(ctx, base);
	// 82A9FFD0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A9FFD4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82A9FFD8: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 82A9FFDC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A9FFE0: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 82A9FFE4: 7D661670  srawi r6, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82AA0088; continue 'dispatch;
            }
            0x82AA0088 => {
    //   block [0x82AA0088..0x82AA00F4)
	// 82AA0088: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA008C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA0090: 419A005C  beq cr6, 0x82aa00ec
	if ctx.cr[6].eq {
	pc = 0x82AA00EC; continue 'dispatch;
	}
	// 82AA0094: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0098: 3D00834C  lis r8, -0x7cb4
	ctx.r[8].s64 = -2092171264;
	// 82AA009C: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA00A0: 38E8DED4  addi r7, r8, -0x212c
	ctx.r[7].s64 = ctx.r[8].s64 + -8492;
	// 82AA00A4: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82AA00A8: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA00AC: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA00B0: 7C85502E  lwzx r4, r5, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA00B4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AA00B8: 41980034  blt cr6, 0x82aa00ec
	if ctx.cr[6].lt {
	pc = 0x82AA00EC; continue 'dispatch;
	}
	// 82AA00BC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82AA00C0: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82AA00C4: 39040020  addi r8, r4, 0x20
	ctx.r[8].s64 = ctx.r[4].s64 + 32;
	// 82AA00C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA00CC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA00D0: 806A0364  lwz r3, 0x364(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA00D4: 396901F0  addi r11, r9, 0x1f0
	ctx.r[11].s64 = ctx.r[9].s64 + 496;
	// 82AA00D8: 790A0020  clrldi r10, r8, 0x20
	ctx.r[10].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 82AA00DC: 78E9FFE6  rldicr r9, r7, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82AA00E0: 7D265436  srd r6, r9, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[9].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 82AA00E4: 7CA5582E  lwzx r5, r5, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AA00E8: 4B716DF9  bl 0x821b6ee0
	ctx.lr = 0x82AA00EC;
	sub_821B6EE0(ctx, base);
	// 82AA00EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA00F0: 4820936C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA00F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA00F8 size=384
    let mut pc: u32 = 0x82AA00F8;
    'dispatch: loop {
        match pc {
            0x82AA00F8 => {
    //   block [0x82AA00F8..0x82AA0120)
	// 82AA00F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA00FC: 4820930D  bl 0x82ca9408
	ctx.lr = 0x82AA0100;
	sub_82CA93D0(ctx, base);
	// 82AA0100: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0104: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AA0108: 419A0018  beq cr6, 0x82aa0120
	if ctx.cr[6].eq {
	pc = 0x82AA0120; continue 'dispatch;
	}
	// 82AA010C: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 82AA0110: 419A0010  beq cr6, 0x82aa0120
	if ctx.cr[6].eq {
	pc = 0x82AA0120; continue 'dispatch;
	}
	// 82AA0114: 4B77673D  bl 0x82216850
	ctx.lr = 0x82AA0118;
	sub_82216850(ctx, base);
	// 82AA0118: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA011C: 4820933C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA0120 => {
    //   block [0x82AA0120..0x82AA018C)
	// 82AA0120: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA0124: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82AA0128: 7D245A14  add r9, r4, r11
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82AA012C: 396A51A0  addi r11, r10, 0x51a0
	ctx.r[11].s64 = ctx.r[10].s64 + 20896;
	// 82AA0130: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA0134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0138: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA013C: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0140: 4B816CF9  bl 0x822b6e38
	ctx.lr = 0x82AA0144;
	sub_822B6E38(ctx, base);
	// 82AA0144: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AA0148: 809D0018  lwz r4, 0x18(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AA014C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA0150: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0154: 4B77E99D  bl 0x8221eaf0
	ctx.lr = 0x82AA0158;
	sub_8221EAF0(ctx, base);
	// 82AA0158: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AA015C: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 82AA0160: 791EFFE6  rldicr r30, r8, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82AA0164: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA0168: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA016C: 41980020  blt cr6, 0x82aa018c
	if ctx.cr[6].lt {
	pc = 0x82AA018C; continue 'dispatch;
	}
	// 82AA0170: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 82AA0174: 807C0364  lwz r3, 0x364(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA0178: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA017C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0180: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82AA0184: 7FC64C36  srd r6, r30, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82AA0188: 4B716D59  bl 0x821b6ee0
	ctx.lr = 0x82AA018C;
	sub_821B6EE0(ctx, base);
	pc = 0x82AA018C; continue 'dispatch;
            }
            0x82AA018C => {
    //   block [0x82AA018C..0x82AA01A0)
	// 82AA018C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA0190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0194: 419A004C  beq cr6, 0x82aa01e0
	if ctx.cr[6].eq {
	pc = 0x82AA01E0; continue 'dispatch;
	}
	// 82AA0198: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA019C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82AA01A0; continue 'dispatch;
            }
            0x82AA01A0 => {
    //   block [0x82AA01A0..0x82AA01D8)
	// 82AA01A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA01A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA01A8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA01AC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AA01B0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA01B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA01B8: 4082FFE8  bne 0x82aa01a0
	if !ctx.cr[0].eq {
	pc = 0x82AA01A0; continue 'dispatch;
	}
	// 82AA01BC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82AA01C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA01C4: 409A0014  bne cr6, 0x82aa01d8
	if !ctx.cr[6].eq {
	pc = 0x82AA01D8; continue 'dispatch;
	}
	// 82AA01C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA01CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA01D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA01D4: 4E800421  bctrl
	ctx.lr = 0x82AA01D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA01D8 => {
    //   block [0x82AA01D8..0x82AA01E0)
	// 82AA01D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA01DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82AA01E0; continue 'dispatch;
            }
            0x82AA01E0 => {
    //   block [0x82AA01E0..0x82AA0278)
	// 82AA01E0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA01E4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AA01E8: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82AA01EC: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82AA01F0: 38E94370  addi r7, r9, 0x4370
	ctx.r[7].s64 = ctx.r[9].s64 + 17264;
	// 82AA01F4: 7CC80194  addze r6, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[6].s64 = tmp.s64;
	// 82AA01F8: E96B1758  ld r11, 0x1758(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5976 as u32) ) };
	// 82AA01FC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AA0200: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 82AA0204: 7FC32436  srd r3, r30, r4
	if (ctx.r[4].u8 & 0x40) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = (ctx.r[30].u64) >> ((ctx.r[4].u8 & 0x3F) as u32);
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA0278 size=384
    let mut pc: u32 = 0x82AA0278;
    'dispatch: loop {
        match pc {
            0x82AA0278 => {
    //   block [0x82AA0278..0x82AA02A0)
	// 82AA0278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA027C: 4820918D  bl 0x82ca9408
	ctx.lr = 0x82AA0280;
	sub_82CA93D0(ctx, base);
	// 82AA0280: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0284: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AA0288: 419A0018  beq cr6, 0x82aa02a0
	if ctx.cr[6].eq {
	pc = 0x82AA02A0; continue 'dispatch;
	}
	// 82AA028C: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 82AA0290: 419A0010  beq cr6, 0x82aa02a0
	if ctx.cr[6].eq {
	pc = 0x82AA02A0; continue 'dispatch;
	}
	// 82AA0294: 4BFFFCA5  bl 0x82a9ff38
	ctx.lr = 0x82AA0298;
	sub_82A9FF38(ctx, base);
	// 82AA0298: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA029C: 482091BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA02A0 => {
    //   block [0x82AA02A0..0x82AA030C)
	// 82AA02A0: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA02A4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82AA02A8: 7D245A14  add r9, r4, r11
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82AA02AC: 396A51A0  addi r11, r10, 0x51a0
	ctx.r[11].s64 = ctx.r[10].s64 + 20896;
	// 82AA02B0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA02B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA02B8: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA02BC: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA02C0: 4B816B79  bl 0x822b6e38
	ctx.lr = 0x82AA02C4;
	sub_822B6E38(ctx, base);
	// 82AA02C4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AA02C8: 809D0018  lwz r4, 0x18(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AA02CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA02D0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA02D4: 4B77E81D  bl 0x8221eaf0
	ctx.lr = 0x82AA02D8;
	sub_8221EAF0(ctx, base);
	// 82AA02D8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AA02DC: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 82AA02E0: 791EFFE6  rldicr r30, r8, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82AA02E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA02E8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA02EC: 41980020  blt cr6, 0x82aa030c
	if ctx.cr[6].lt {
	pc = 0x82AA030C; continue 'dispatch;
	}
	// 82AA02F0: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 82AA02F4: 807C0364  lwz r3, 0x364(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA02F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA02FC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0300: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82AA0304: 7FC64C36  srd r6, r30, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82AA0308: 4B716BD9  bl 0x821b6ee0
	ctx.lr = 0x82AA030C;
	sub_821B6EE0(ctx, base);
	pc = 0x82AA030C; continue 'dispatch;
            }
            0x82AA030C => {
    //   block [0x82AA030C..0x82AA0320)
	// 82AA030C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA0310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0314: 419A004C  beq cr6, 0x82aa0360
	if ctx.cr[6].eq {
	pc = 0x82AA0360; continue 'dispatch;
	}
	// 82AA0318: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA031C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82AA0320; continue 'dispatch;
            }
            0x82AA0320 => {
    //   block [0x82AA0320..0x82AA0358)
	// 82AA0320: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA0324: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA0328: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA032C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AA0330: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA0334: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA0338: 4082FFE8  bne 0x82aa0320
	if !ctx.cr[0].eq {
	pc = 0x82AA0320; continue 'dispatch;
	}
	// 82AA033C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82AA0340: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0344: 409A0014  bne cr6, 0x82aa0358
	if !ctx.cr[6].eq {
	pc = 0x82AA0358; continue 'dispatch;
	}
	// 82AA0348: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA034C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0350: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA0354: 4E800421  bctrl
	ctx.lr = 0x82AA0358;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA0358 => {
    //   block [0x82AA0358..0x82AA0360)
	// 82AA0358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA035C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82AA0360; continue 'dispatch;
            }
            0x82AA0360 => {
    //   block [0x82AA0360..0x82AA03F8)
	// 82AA0360: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA0364: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AA0368: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82AA036C: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82AA0370: 38E94370  addi r7, r9, 0x4370
	ctx.r[7].s64 = ctx.r[9].s64 + 17264;
	// 82AA0374: 7CC80194  addze r6, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[6].s64 = tmp.s64;
	// 82AA0378: E96B1758  ld r11, 0x1758(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5976 as u32) ) };
	// 82AA037C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AA0380: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 82AA0384: 7FC32436  srd r3, r30, r4
	if (ctx.r[4].u8 & 0x40) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = (ctx.r[30].u64) >> ((ctx.r[4].u8 & 0x3F) as u32);
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA03F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA03F8 size=164
    let mut pc: u32 = 0x82AA03F8;
    'dispatch: loop {
        match pc {
            0x82AA03F8 => {
    //   block [0x82AA03F8..0x82AA0420)
	// 82AA03F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA03FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0400: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0404: 89430099  lbz r10, 0x99(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(153 as u32) ) } as u64;
	// 82AA0408: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA040C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA0410: 419A0010  beq cr6, 0x82aa0420
	if ctx.cr[6].eq {
	pc = 0x82AA0420; continue 'dispatch;
	}
	// 82AA0414: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0418: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AA041C: 554BD7FE  rlwinm r11, r10, 0x1a, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	pc = 0x82AA0420; continue 'dispatch;
            }
            0x82AA0420 => {
    //   block [0x82AA0420..0x82AA0474)
	// 82AA0420: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82AA0424: 5569063E  clrlwi r9, r11, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA0428: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AA042C: 890A05A1  lbz r8, 0x5a1(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1441 as u32) ) } as u64;
	// 82AA0430: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA0434: 419A0040  beq cr6, 0x82aa0474
	if ctx.cr[6].eq {
	pc = 0x82AA0474; continue 'dispatch;
	}
	// 82AA0438: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AA043C: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82AA0440: 38EB16B8  addi r7, r11, 0x16b8
	ctx.r[7].s64 = ctx.r[11].s64 + 5816;
	// 82AA0444: 81480DB4  lwz r10, 0xdb4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3508 as u32) ) } as u64;
	// 82AA0448: 81670010  lwz r11, 0x10(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA044C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82AA0450: 512B07FE  rlwimi r11, r9, 0, 0x1f, 0x1f
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x0000000000000001) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFFE);
	// 82AA0454: 7D653278  xor r5, r11, r6
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[6].u64;
	// 82AA0458: 91670010  stw r11, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82AA045C: 7CAB5378  or r11, r5, r10
	ctx.r[11].u64 = ctx.r[5].u64 | ctx.r[10].u64;
	// 82AA0460: 91680DB4  stw r11, 0xdb4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(3508 as u32), ctx.r[11].u32 ) };
	// 82AA0464: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA0468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA046C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0470: 4E800020  blr
	return;
            }
            0x82AA0474 => {
    //   block [0x82AA0474..0x82AA049C)
	// 82AA0474: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82AA0478: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AA047C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA0480: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA0484: 806B0364  lwz r3, 0x364(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA0488: 4B7CDC99  bl 0x8226e120
	ctx.lr = 0x82AA048C;
	sub_8226E120(ctx, base);
	// 82AA048C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA0490: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA0494: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA04A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA04A0 size=240
    let mut pc: u32 = 0x82AA04A0;
    'dispatch: loop {
        match pc {
            0x82AA04A0 => {
    //   block [0x82AA04A0..0x82AA04F8)
	// 82AA04A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA04A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA04A8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA04AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA04B0: 812B0090  lwz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AA04B4: 5527DFFE  rlwinm r7, r9, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82AA04B8: 98E30098  stb r7, 0x98(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[7].u8 ) };
	// 82AA04BC: 80CB0090  lwz r6, 0x90(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AA04C0: 54C90634  rlwinm r9, r6, 0, 0x18, 0x1a
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA04C4: 552906B0  rlwinm r9, r9, 0, 0x1a, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA04C8: 38A9FFE0  addi r5, r9, -0x20
	ctx.r[5].s64 = ctx.r[9].s64 + -32;
	// 82AA04CC: 7CA40034  cntlzw r4, r5
	ctx.r[4].u64 = if ctx.r[5].u32 == 0 { 32 } else { ctx.r[5].u32.leading_zeros() as u64 };
	// 82AA04D0: 5489DFFE  rlwinm r9, r4, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 82AA04D4: 99230099  stb r9, 0x99(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(153 as u32), ctx.r[9].u8 ) };
	// 82AA04D8: 80EB0090  lwz r7, 0x90(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AA04DC: 54E6CFFE  rlwinm r6, r7, 0x19, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000007Fu64;
	// 82AA04E0: 98C3009A  stb r6, 0x9a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(154 as u32), ctx.r[6].u8 ) };
	// 82AA04E4: 9903009B  stb r8, 0x9b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(155 as u32), ctx.r[8].u8 ) };
	// 82AA04E8: 419A0010  beq cr6, 0x82aa04f8
	if ctx.cr[6].eq {
	pc = 0x82AA04F8; continue 'dispatch;
	}
	// 82AA04EC: 816A0090  lwz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AA04F0: 556ACFFE  rlwinm r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 82AA04F4: 9943009B  stb r10, 0x9b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(155 as u32), ctx.r[10].u8 ) };
	pc = 0x82AA04F8; continue 'dispatch;
            }
            0x82AA04F8 => {
    //   block [0x82AA04F8..0x82AA0510)
	// 82AA04F8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AA04FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0500: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0504: 419A000C  beq cr6, 0x82aa0510
	if ctx.cr[6].eq {
	pc = 0x82AA0510; continue 'dispatch;
	}
	// 82AA0508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA050C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82AA0510; continue 'dispatch;
            }
            0x82AA0510 => {
    //   block [0x82AA0510..0x82AA0528)
	// 82AA0510: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA0514: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0518: 419A0010  beq cr6, 0x82aa0528
	if ctx.cr[6].eq {
	pc = 0x82AA0528; continue 'dispatch;
	}
	// 82AA051C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0520: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	// 82AA0524: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA0528; continue 'dispatch;
            }
            0x82AA0528 => {
    //   block [0x82AA0528..0x82AA0540)
	// 82AA0528: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA052C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0530: 419A0010  beq cr6, 0x82aa0540
	if ctx.cr[6].eq {
	pc = 0x82AA0540; continue 'dispatch;
	}
	// 82AA0534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0538: 616A0004  ori r10, r11, 4
	ctx.r[10].u64 = ctx.r[11].u64 | 4;
	// 82AA053C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA0540; continue 'dispatch;
            }
            0x82AA0540 => {
    //   block [0x82AA0540..0x82AA0558)
	// 82AA0540: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA0544: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0548: 419A0010  beq cr6, 0x82aa0558
	if ctx.cr[6].eq {
	pc = 0x82AA0558; continue 'dispatch;
	}
	// 82AA054C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0550: 616A0008  ori r10, r11, 8
	ctx.r[10].u64 = ctx.r[11].u64 | 8;
	// 82AA0554: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA0558; continue 'dispatch;
            }
            0x82AA0558 => {
    //   block [0x82AA0558..0x82AA0570)
	// 82AA0558: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA055C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0560: 419A0010  beq cr6, 0x82aa0570
	if ctx.cr[6].eq {
	pc = 0x82AA0570; continue 'dispatch;
	}
	// 82AA0564: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0568: 616A0010  ori r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u64 | 16;
	// 82AA056C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA0570; continue 'dispatch;
            }
            0x82AA0570 => {
    //   block [0x82AA0570..0x82AA0588)
	// 82AA0570: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AA0574: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0578: 419A0010  beq cr6, 0x82aa0588
	if ctx.cr[6].eq {
	pc = 0x82AA0588; continue 'dispatch;
	}
	// 82AA057C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0580: 616A0020  ori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 | 32;
	// 82AA0584: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA0588; continue 'dispatch;
            }
            0x82AA0588 => {
    //   block [0x82AA0588..0x82AA0590)
	// 82AA0588: 48000008  b 0x82aa0590
	sub_82AA0590(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA0590 size=716
    let mut pc: u32 = 0x82AA0590;
    'dispatch: loop {
        match pc {
            0x82AA0590 => {
    //   block [0x82AA0590..0x82AA085C)
	// 82AA0590: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AA0594: 3901FFD0  addi r8, r1, -0x30
	ctx.r[8].s64 = ctx.r[1].s64 + -48;
	// 82AA0598: 396B4370  addi r11, r11, 0x4370
	ctx.r[11].s64 = ctx.r[11].s64 + 17264;
	// 82AA059C: 38E1FFA0  addi r7, r1, -0x60
	ctx.r[7].s64 = ctx.r[1].s64 + -96;
	// 82AA05A0: 38A1FFB0  addi r5, r1, -0x50
	ctx.r[5].s64 = ctx.r[1].s64 + -80;
	// 82AA05A4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82AA05A8: 3921FFC0  addi r9, r1, -0x40
	ctx.r[9].s64 = ctx.r[1].s64 + -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0860 size=212
    let mut pc: u32 = 0x82AA0860;
    'dispatch: loop {
        match pc {
            0x82AA0860 => {
    //   block [0x82AA0860..0x82AA0934)
	// 82AA0860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0868: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA086C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0870: 398000F0  li r12, 0xf0
	ctx.r[12].s64 = 240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0938 size=136
    let mut pc: u32 = 0x82AA0938;
    'dispatch: loop {
        match pc {
            0x82AA0938 => {
    //   block [0x82AA0938..0x82AA0984)
	// 82AA0938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA093C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0940: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0944: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0948: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82AA094C: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82AA0950: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA0954: 419A0058  beq cr6, 0x82aa09ac
	if ctx.cr[6].eq {
	pc = 0x82AA09AC; continue 'dispatch;
	}
	// 82AA0958: 4B6F2811  bl 0x82193168
	ctx.lr = 0x82AA095C;
	sub_82193168(ctx, base);
	// 82AA095C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0960: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA0964: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA0968: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA096C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA0970: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA0974: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA0978: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82AA097C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA0980: 419A001C  beq cr6, 0x82aa099c
	if ctx.cr[6].eq {
	pc = 0x82AA099C; continue 'dispatch;
	}
	pc = 0x82AA0984; continue 'dispatch;
            }
            0x82AA0984 => {
    //   block [0x82AA0984..0x82AA099C)
	// 82AA0984: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0988: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA098C: 419A0010  beq cr6, 0x82aa099c
	if ctx.cr[6].eq {
	pc = 0x82AA099C; continue 'dispatch;
	}
	// 82AA0990: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA0994: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA0998: 409AFFEC  bne cr6, 0x82aa0984
	if !ctx.cr[6].eq {
	pc = 0x82AA0984; continue 'dispatch;
	}
	pc = 0x82AA099C; continue 'dispatch;
            }
            0x82AA099C => {
    //   block [0x82AA099C..0x82AA09AC)
	// 82AA099C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA09A0: 409A000C  bne cr6, 0x82aa09ac
	if !ctx.cr[6].eq {
	pc = 0x82AA09AC; continue 'dispatch;
	}
	// 82AA09A4: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82AA09A8: 4B73B359  bl 0x821dbd00
	ctx.lr = 0x82AA09AC;
	sub_821DBD00(ctx, base);
	pc = 0x82AA09AC; continue 'dispatch;
            }
            0x82AA09AC => {
    //   block [0x82AA09AC..0x82AA09C0)
	// 82AA09AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA09B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA09B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA09B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA09BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA09C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA09C0 size=176
    let mut pc: u32 = 0x82AA09C0;
    'dispatch: loop {
        match pc {
            0x82AA09C0 => {
    //   block [0x82AA09C0..0x82AA0A10)
	// 82AA09C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA09C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA09C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA09CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA09D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA09D4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82AA09D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA09DC: 419A007C  beq cr6, 0x82aa0a58
	if ctx.cr[6].eq {
	pc = 0x82AA0A58; continue 'dispatch;
	}
	// 82AA09E0: 4B6F2789  bl 0x82193168
	ctx.lr = 0x82AA09E4;
	sub_82193168(ctx, base);
	// 82AA09E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA09E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA09EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA09F0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA09F4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA09F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA09FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA0A00: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA0A04: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82AA0A08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA0A0C: 419A001C  beq cr6, 0x82aa0a28
	if ctx.cr[6].eq {
	pc = 0x82AA0A28; continue 'dispatch;
	}
	pc = 0x82AA0A10; continue 'dispatch;
            }
            0x82AA0A10 => {
    //   block [0x82AA0A10..0x82AA0A28)
	// 82AA0A10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0A14: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA0A18: 419A0010  beq cr6, 0x82aa0a28
	if ctx.cr[6].eq {
	pc = 0x82AA0A28; continue 'dispatch;
	}
	// 82AA0A1C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82AA0A20: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA0A24: 409AFFEC  bne cr6, 0x82aa0a10
	if !ctx.cr[6].eq {
	pc = 0x82AA0A10; continue 'dispatch;
	}
	pc = 0x82AA0A28; continue 'dispatch;
            }
            0x82AA0A28 => {
    //   block [0x82AA0A28..0x82AA0A4C)
	// 82AA0A28: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA0A2C: 419A002C  beq cr6, 0x82aa0a58
	if ctx.cr[6].eq {
	pc = 0x82AA0A58; continue 'dispatch;
	}
	// 82AA0A30: 38A30004  addi r5, r3, 4
	ctx.r[5].s64 = ctx.r[3].s64 + 4;
	// 82AA0A34: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82AA0A38: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0A3C: 40810010  ble 0x82aa0a4c
	if !ctx.cr[0].gt {
	pc = 0x82AA0A4C; continue 'dispatch;
	}
	// 82AA0A40: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82AA0A44: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82AA0A48: 482095E1  bl 0x82caa028
	ctx.lr = 0x82AA0A4C;
	sub_82CAA028(ctx, base);
	pc = 0x82AA0A4C; continue 'dispatch;
            }
            0x82AA0A4C => {
    //   block [0x82AA0A4C..0x82AA0A58)
	// 82AA0A4C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA0A50: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82AA0A54: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82AA0A58; continue 'dispatch;
            }
            0x82AA0A58 => {
    //   block [0x82AA0A58..0x82AA0A70)
	// 82AA0A58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA0A5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA0A60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0A64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA0A68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA0A6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA0A98 size=836
    let mut pc: u32 = 0x82AA0A98;
    'dispatch: loop {
        match pc {
            0x82AA0A98 => {
    //   block [0x82AA0A98..0x82AA0AD8)
	// 82AA0A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0A9C: 48208965  bl 0x82ca9400
	ctx.lr = 0x82AA0AA0;
	sub_82CA93D0(ctx, base);
	// 82AA0AA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA0AA8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA0AAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA0AB0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82AA0AB4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82AA0AB8: 993F0008  stb r9, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 82AA0ABC: 395F0018  addi r10, r31, 0x18
	ctx.r[10].s64 = ctx.r[31].s64 + 24;
	// 82AA0AC0: 90BF0014  stw r5, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 82AA0AC4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82AA0AC8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AA0ACC: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 82AA0AD0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AA0AD4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82AA0AD8; continue 'dispatch;
            }
            0x82AA0AD8 => {
    //   block [0x82AA0AD8..0x82AA0DDC)
	// 82AA0AD8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0ADC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA0AE0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA0AE4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AA0AE8: 4200FFF0  bdnz 0x82aa0ad8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AA0AD8; continue 'dispatch;
	}
	// 82AA0AEC: 3F80820A  lis r28, -0x7df6
	ctx.r[28].s64 = -2113273856;
	// 82AA0AF0: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82AA0AF4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA0AF8: 395C9490  addi r10, r28, -0x6b70
	ctx.r[10].s64 = ctx.r[28].s64 + -27504;
	// 82AA0AFC: 392001B0  li r9, 0x1b0
	ctx.r[9].s64 = 432;
	// 82AA0B00: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82AA0B04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA0B08: 38E82A30  addi r7, r8, 0x2a30
	ctx.r[7].s64 = ctx.r[8].s64 + 10800;
	// 82AA0B0C: C06AFFF4  lfs f3, -0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AA0B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0B14: D0610050  stfs f3, 0x50(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0DE0 size=284
    let mut pc: u32 = 0x82AA0DE0;
    'dispatch: loop {
        match pc {
            0x82AA0DE0 => {
    //   block [0x82AA0DE0..0x82AA0E14)
	// 82AA0DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0DE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA0DEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0DF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0DF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA0DF8: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0DFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E00: 419A0014  beq cr6, 0x82aa0e14
	if ctx.cr[6].eq {
	pc = 0x82AA0E14; continue 'dispatch;
	}
	// 82AA0E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0E08: 4B7FCC91  bl 0x8229da98
	ctx.lr = 0x82AA0E0C;
	sub_8229DA98(ctx, base);
	// 82AA0E0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0E10: 4B77AF29  bl 0x8221bd38
	ctx.lr = 0x82AA0E14;
	sub_8221BD38(ctx, base);
	pc = 0x82AA0E14; continue 'dispatch;
            }
            0x82AA0E14 => {
    //   block [0x82AA0E14..0x82AA0E30)
	// 82AA0E14: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0E18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E1C: 419A0014  beq cr6, 0x82aa0e30
	if ctx.cr[6].eq {
	pc = 0x82AA0E30; continue 'dispatch;
	}
	// 82AA0E20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0E24: 4B7D44E5  bl 0x82275308
	ctx.lr = 0x82AA0E28;
	sub_82275308(ctx, base);
	// 82AA0E28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0E2C: 4B77AF0D  bl 0x8221bd38
	ctx.lr = 0x82AA0E30;
	sub_8221BD38(ctx, base);
	pc = 0x82AA0E30; continue 'dispatch;
            }
            0x82AA0E30 => {
    //   block [0x82AA0E30..0x82AA0E50)
	// 82AA0E30: 807F0254  lwz r3, 0x254(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 82AA0E34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E38: 419A0018  beq cr6, 0x82aa0e50
	if ctx.cr[6].eq {
	pc = 0x82AA0E50; continue 'dispatch;
	}
	// 82AA0E3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0E40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA0E44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0E48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA0E4C: 4E800421  bctrl
	ctx.lr = 0x82AA0E50;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA0E50 => {
    //   block [0x82AA0E50..0x82AA0E6C)
	// 82AA0E50: 83DF0250  lwz r30, 0x250(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 82AA0E54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E58: 419A0014  beq cr6, 0x82aa0e6c
	if ctx.cr[6].eq {
	pc = 0x82AA0E6C; continue 'dispatch;
	}
	// 82AA0E5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0E60: 4801B4C1  bl 0x82abc320
	ctx.lr = 0x82AA0E64;
	sub_82ABC320(ctx, base);
	// 82AA0E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0E68: 4B77AED1  bl 0x8221bd38
	ctx.lr = 0x82AA0E6C;
	sub_8221BD38(ctx, base);
	pc = 0x82AA0E6C; continue 'dispatch;
            }
            0x82AA0E6C => {
    //   block [0x82AA0E6C..0x82AA0E8C)
	// 82AA0E6C: 807F024C  lwz r3, 0x24c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82AA0E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E74: 419A0018  beq cr6, 0x82aa0e8c
	if ctx.cr[6].eq {
	pc = 0x82AA0E8C; continue 'dispatch;
	}
	// 82AA0E78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0E7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA0E80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0E84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA0E88: 4E800421  bctrl
	ctx.lr = 0x82AA0E8C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA0E8C => {
    //   block [0x82AA0E8C..0x82AA0EB4)
	// 82AA0E8C: 807F0240  lwz r3, 0x240(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 82AA0E90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA0E94: 93DF024C  stw r30, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[30].u32 ) };
	// 82AA0E98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E9C: 419A0018  beq cr6, 0x82aa0eb4
	if ctx.cr[6].eq {
	pc = 0x82AA0EB4; continue 'dispatch;
	}
	// 82AA0EA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0EA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA0EA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0EAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA0EB0: 4E800421  bctrl
	ctx.lr = 0x82AA0EB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA0EB4 => {
    //   block [0x82AA0EB4..0x82AA0EFC)
	// 82AA0EB4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AA0EB8: 93DF0240  stw r30, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[30].u32 ) };
	// 82AA0EBC: 3BDF0244  addi r30, r31, 0x244
	ctx.r[30].s64 = ctx.r[31].s64 + 580;
	// 82AA0EC0: 394B2A30  addi r10, r11, 0x2a30
	ctx.r[10].s64 = ctx.r[11].s64 + 10800;
	// 82AA0EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0EC8: 915F0244  stw r10, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[10].u32 ) };
	// 82AA0ECC: 4B75B13D  bl 0x821fc008
	ctx.lr = 0x82AA0ED0;
	sub_821FC008(ctx, base);
	// 82AA0ED0: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82AA0ED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0ED8: 39092A40  addi r8, r9, 0x2a40
	ctx.r[8].s64 = ctx.r[9].s64 + 10816;
	// 82AA0EDC: 911F0244  stw r8, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[8].u32 ) };
	// 82AA0EE0: 4B75B129  bl 0x821fc008
	ctx.lr = 0x82AA0EE4;
	sub_821FC008(ctx, base);
	// 82AA0EE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA0EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA0EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0EF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA0EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA0EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA0F00 size=624
    let mut pc: u32 = 0x82AA0F00;
    'dispatch: loop {
        match pc {
            0x82AA0F00 => {
    //   block [0x82AA0F00..0x82AA0F90)
	// 82AA0F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA0F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0F10: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0F14: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 82AA0F18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0F1C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82AA0F20: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA0F24: 409A0144  bne cr6, 0x82aa1068
	if !ctx.cr[6].eq {
	pc = 0x82AA1068; continue 'dispatch;
	}
	// 82AA0F28: 3BCBB0BC  addi r30, r11, -0x4f44
	ctx.r[30].s64 = ctx.r[11].s64 + -20292;
	// 82AA0F2C: 3CC00200  lis r6, 0x200
	ctx.r[6].s64 = 33554432;
	// 82AA0F30: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82AA0F34: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0F38: 4B715FA9  bl 0x821b6ee0
	ctx.lr = 0x82AA0F3C;
	sub_821B6EE0(ctx, base);
	// 82AA0F3C: 3CC00040  lis r6, 0x40
	ctx.r[6].s64 = 4194304;
	// 82AA0F40: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0F44: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82AA0F48: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA0F4C: 4B715F95  bl 0x821b6ee0
	ctx.lr = 0x82AA0F50;
	sub_821B6EE0(ctx, base);
	// 82AA0F50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA0F54: 4B79AE5D  bl 0x8223bdb0
	ctx.lr = 0x82AA0F58;
	sub_8223BDB0(ctx, base);
	// 82AA0F58: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82AA0F5C: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 82AA0F60: 798CBFE6  rldicr r12, r12, 0x37, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(55) & 0xFFFFFFFFFFFFFFFF;
	// 82AA0F64: EBCA1758  ld r30, 0x1758(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(5976 as u32) ) };
	// 82AA0F68: 7FC96038  and r9, r30, r12
	ctx.r[9].u64 = ctx.r[30].u64 & ctx.r[12].u64;
	// 82AA0F6C: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 82AA0F70: 419A0020  beq cr6, 0x82aa0f90
	if ctx.cr[6].eq {
	pc = 0x82AA0F90; continue 'dispatch;
	}
	// 82AA0F74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA0F78: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA0F7C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82AA0F80: 78E7BFE6  rldicr r7, r7, 0x37, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(55) & 0xFFFFFFFFFFFFFFFF;
	// 82AA0F84: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82AA0F88: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82AA0F8C: 4B773EA5  bl 0x82214e30
	ctx.lr = 0x82AA0F90;
	sub_82214E30(ctx, base);
	pc = 0x82AA0F90; continue 'dispatch;
            }
            0x82AA0F90 => {
    //   block [0x82AA0F90..0x82AA0FC8)
	// 82AA0F90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA0F94: 4B79AE1D  bl 0x8223bdb0
	ctx.lr = 0x82AA0F98;
	sub_8223BDB0(ctx, base);
	// 82AA0F98: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 82AA0F9C: 798CB7E6  rldicr r12, r12, 0x36, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(54) & 0xFFFFFFFFFFFFFFFF;
	// 82AA0FA0: 7FCB6038  and r11, r30, r12
	ctx.r[11].u64 = ctx.r[30].u64 & ctx.r[12].u64;
	// 82AA0FA4: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82AA0FA8: 419A0020  beq cr6, 0x82aa0fc8
	if ctx.cr[6].eq {
	pc = 0x82AA0FC8; continue 'dispatch;
	}
	// 82AA0FAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA0FB0: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA0FB4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82AA0FB8: 78E7B7E6  rldicr r7, r7, 0x36, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(54) & 0xFFFFFFFFFFFFFFFF;
	// 82AA0FBC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82AA0FC0: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 82AA0FC4: 4B773E6D  bl 0x82214e30
	ctx.lr = 0x82AA0FC8;
	sub_82214E30(ctx, base);
	pc = 0x82AA0FC8; continue 'dispatch;
            }
            0x82AA0FC8 => {
    //   block [0x82AA0FC8..0x82AA1068)
	// 82AA0FC8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA0FCC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82AA0FD0: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 82AA0FD4: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82AA0FD8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AA0FDC: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA0FE0: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 82AA0FE4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AA0FE8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	pc = 0x82AA1068; continue 'dispatch;
            }
            0x82AA1068 => {
    //   block [0x82AA1068..0x82AA1170)
	// 82AA1068: 394BB0BC  addi r10, r11, -0x4f44
	ctx.r[10].s64 = ctx.r[11].s64 + -20292;
	// 82AA106C: 3CC00100  lis r6, 0x100
	ctx.r[6].s64 = 16777216;
	// 82AA1070: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82AA1074: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1078: 4B715E69  bl 0x821b6ee0
	ctx.lr = 0x82AA107C;
	sub_821B6EE0(ctx, base);
	// 82AA107C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82AA1080: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82AA1084: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AA1088: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82AA108C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA1090: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA1094: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 82AA1098: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82AA109C: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 82AA10A0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AA10A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA1170 size=804
    let mut pc: u32 = 0x82AA1170;
    'dispatch: loop {
        match pc {
            0x82AA1170 => {
    //   block [0x82AA1170..0x82AA1494)
	// 82AA1170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1174: 48208291  bl 0x82ca9404
	ctx.lr = 0x82AA1178;
	sub_82CA93D0(ctx, base);
	// 82AA1178: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82AA117C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82AA1180: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1184: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA1188: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82AA118C: 3BABE7AC  addi r29, r11, -0x1854
	ctx.r[29].s64 = ctx.r[11].s64 + -6228;
	// 82AA1190: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82AA1194: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 82AA1198: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 82AA119C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82AA11A0: C3DDACE4  lfs f30, -0x531c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21276 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA11A4: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 82AA11A8: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82AA11AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1498 size=104
    let mut pc: u32 = 0x82AA1498;
    'dispatch: loop {
        match pc {
            0x82AA1498 => {
    //   block [0x82AA1498..0x82AA1500)
	// 82AA1498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA149C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA14A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA14A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA14A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA14AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA14B0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AA14B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA14B8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA14BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA14C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA14C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA14C8: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA14CC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA14D0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA14D4: 480B0E3D  bl 0x82b52310
	ctx.lr = 0x82AA14D8;
	sub_82B52310(ctx, base);
	// 82AA14D8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA14DC: 4B77A85D  bl 0x8221bd38
	ctx.lr = 0x82AA14E0;
	sub_8221BD38(ctx, base);
	// 82AA14E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA14E4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AA14E8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA14EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA14F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA14F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA14F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA14FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1500 size=344
    let mut pc: u32 = 0x82AA1500;
    'dispatch: loop {
        match pc {
            0x82AA1500 => {
    //   block [0x82AA1500..0x82AA1538)
	// 82AA1500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1504: 48207EFD  bl 0x82ca9400
	ctx.lr = 0x82AA1508;
	sub_82CA93D0(ctx, base);
	// 82AA1508: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA150C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AA1510: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82AA1514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA1518: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82AA151C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82AA1520: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1524: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1528: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82AA152C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA1530: 409A0044  bne cr6, 0x82aa1574
	if !ctx.cr[6].eq {
	pc = 0x82AA1574; continue 'dispatch;
	}
	// 82AA1534: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AA1538; continue 'dispatch;
            }
            0x82AA1538 => {
    //   block [0x82AA1538..0x82AA1550)
	// 82AA1538: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA153C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82AA1540: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA1544: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82AA1548: 41980008  blt cr6, 0x82aa1550
	if ctx.cr[6].lt {
	pc = 0x82AA1550; continue 'dispatch;
	}
	// 82AA154C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82AA1550; continue 'dispatch;
            }
            0x82AA1550 => {
    //   block [0x82AA1550..0x82AA1564)
	// 82AA1550: 555D063E  clrlwi r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82AA1554: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AA1558: 419A000C  beq cr6, 0x82aa1564
	if ctx.cr[6].eq {
	pc = 0x82AA1564; continue 'dispatch;
	}
	// 82AA155C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1560: 48000008  b 0x82aa1568
	pc = 0x82AA1568; continue 'dispatch;
            }
            0x82AA1564 => {
    //   block [0x82AA1564..0x82AA1568)
	// 82AA1564: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AA1568; continue 'dispatch;
            }
            0x82AA1568 => {
    //   block [0x82AA1568..0x82AA1574)
	// 82AA1568: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82AA156C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA1570: 419AFFC8  beq cr6, 0x82aa1538
	if ctx.cr[6].eq {
	pc = 0x82AA1538; continue 'dispatch;
	}
	pc = 0x82AA1574; continue 'dispatch;
            }
            0x82AA1574 => {
    //   block [0x82AA1574..0x82AA15D4)
	// 82AA1574: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82AA1578: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82AA157C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82AA1580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1584: 419A0054  beq cr6, 0x82aa15d8
	if ctx.cr[6].eq {
	pc = 0x82AA15D8; continue 'dispatch;
	}
	// 82AA1588: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA158C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1590: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1594: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA1598: 409A003C  bne cr6, 0x82aa15d4
	if !ctx.cr[6].eq {
	pc = 0x82AA15D4; continue 'dispatch;
	}
	// 82AA159C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82AA15A0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA15A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA15A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA15AC: 4800014D  bl 0x82aa16f8
	ctx.lr = 0x82AA15B0;
	sub_82AA16F8(ctx, base);
	// 82AA15B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA15B4: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82AA15B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA15BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA15C0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA15C4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA15C8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA15CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA15D0: 48207E80  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA15D4 => {
    //   block [0x82AA15D4..0x82AA15D8)
	// 82AA15D4: 4B8DCE0D  bl 0x8237e3e0
	ctx.lr = 0x82AA15D8;
	sub_8237E3E0(ctx, base);
	pc = 0x82AA15D8; continue 'dispatch;
            }
            0x82AA15D8 => {
    //   block [0x82AA15D8..0x82AA15F4)
	// 82AA15D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA15DC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA15E0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA15E4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82AA15E8: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA15EC: 41980008  blt cr6, 0x82aa15f4
	if ctx.cr[6].lt {
	pc = 0x82AA15F4; continue 'dispatch;
	}
	// 82AA15F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AA15F4; continue 'dispatch;
            }
            0x82AA15F4 => {
    //   block [0x82AA15F4..0x82AA163C)
	// 82AA15F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA15F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA15FC: 419A0040  beq cr6, 0x82aa163c
	if ctx.cr[6].eq {
	pc = 0x82AA163C; continue 'dispatch;
	}
	// 82AA1600: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82AA1604: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA1608: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA160C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA1610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1614: 480000E5  bl 0x82aa16f8
	ctx.lr = 0x82AA1618;
	sub_82AA16F8(ctx, base);
	// 82AA1618: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA161C: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82AA1620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1624: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1628: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA162C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA1630: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA1634: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA1638: 48207E18  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA163C => {
    //   block [0x82AA163C..0x82AA1658)
	// 82AA163C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA1640: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA1644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1648: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82AA164C: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AA1650: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA1654: 48207DFC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1658 size=156
    let mut pc: u32 = 0x82AA1658;
    'dispatch: loop {
        match pc {
            0x82AA1658 => {
    //   block [0x82AA1658..0x82AA1678)
	// 82AA1658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA165C: 48207DAD  bl 0x82ca9408
	ctx.lr = 0x82AA1660;
	sub_82CA93D0(ctx, base);
	// 82AA1660: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1664: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA1668: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AA166C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA1670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1674: 419A0028  beq cr6, 0x82aa169c
	if ctx.cr[6].eq {
	pc = 0x82AA169C; continue 'dispatch;
	}
	pc = 0x82AA1678; continue 'dispatch;
            }
            0x82AA1678 => {
    //   block [0x82AA1678..0x82AA1690)
	// 82AA1678: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA167C: 419A0014  beq cr6, 0x82aa1690
	if ctx.cr[6].eq {
	pc = 0x82AA1690; continue 'dispatch;
	}
	// 82AA1680: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA1684: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82AA1688: 40820008  bne 0x82aa1690
	if !ctx.cr[0].eq {
	pc = 0x82AA1690; continue 'dispatch;
	}
	// 82AA168C: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x82AA1690; continue 'dispatch;
            }
            0x82AA1690 => {
    //   block [0x82AA1690..0x82AA169C)
	// 82AA1690: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA1694: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA1698: 409AFFE0  bne cr6, 0x82aa1678
	if !ctx.cr[6].eq {
	pc = 0x82AA1678; continue 'dispatch;
	}
	pc = 0x82AA169C; continue 'dispatch;
            }
            0x82AA169C => {
    //   block [0x82AA169C..0x82AA16AC)
	// 82AA169C: 83BE0008  lwz r29, 8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA16A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AA16A4: 419A0030  beq cr6, 0x82aa16d4
	if ctx.cr[6].eq {
	pc = 0x82AA16D4; continue 'dispatch;
	}
	// 82AA16A8: 57BF103A  slwi r31, r29, 2
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x82AA16AC; continue 'dispatch;
            }
            0x82AA16AC => {
    //   block [0x82AA16AC..0x82AA16CC)
	// 82AA16AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA16B0: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82AA16B4: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82AA16B8: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AA16BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA16C0: 419A000C  beq cr6, 0x82aa16cc
	if ctx.cr[6].eq {
	pc = 0x82AA16CC; continue 'dispatch;
	}
	// 82AA16C4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AA16C8: 4B77A671  bl 0x8221bd38
	ctx.lr = 0x82AA16CC;
	sub_8221BD38(ctx, base);
	pc = 0x82AA16CC; continue 'dispatch;
            }
            0x82AA16CC => {
    //   block [0x82AA16CC..0x82AA16D4)
	// 82AA16CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AA16D0: 409AFFDC  bne cr6, 0x82aa16ac
	if !ctx.cr[6].eq {
	pc = 0x82AA16AC; continue 'dispatch;
	}
	pc = 0x82AA16D4; continue 'dispatch;
            }
            0x82AA16D4 => {
    //   block [0x82AA16D4..0x82AA16E4)
	// 82AA16D4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA16D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA16DC: 419A0008  beq cr6, 0x82aa16e4
	if ctx.cr[6].eq {
	pc = 0x82AA16E4; continue 'dispatch;
	}
	// 82AA16E0: 4B77A659  bl 0x8221bd38
	ctx.lr = 0x82AA16E4;
	sub_8221BD38(ctx, base);
	pc = 0x82AA16E4; continue 'dispatch;
            }
            0x82AA16E4 => {
    //   block [0x82AA16E4..0x82AA16F4)
	// 82AA16E4: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82AA16E8: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AA16EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA16F0: 48207D68  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA16F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA16F8 size=632
    let mut pc: u32 = 0x82AA16F8;
    'dispatch: loop {
        match pc {
            0x82AA16F8 => {
    //   block [0x82AA16F8..0x82AA1770)
	// 82AA16F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA16FC: 48207CFD  bl 0x82ca93f8
	ctx.lr = 0x82AA1700;
	sub_82CA93D0(ctx, base);
	// 82AA1700: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1704: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA1708: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 82AA170C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82AA1710: 6169CCCB  ori r9, r11, 0xcccb
	ctx.r[9].u64 = ctx.r[11].u64 | 52427;
	// 82AA1714: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82AA1718: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA171C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82AA1720: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82AA1724: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA1728: 41980048  blt cr6, 0x82aa1770
	if ctx.cr[6].lt {
	pc = 0x82AA1770; continue 'dispatch;
	}
	// 82AA172C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA1730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1734: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82AA1738: 4B850809  bl 0x822f1f40
	ctx.lr = 0x82AA173C;
	sub_822F1F40(ctx, base);
	// 82AA173C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA1740: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA1744: 4B85066D  bl 0x822f1db0
	ctx.lr = 0x82AA1748;
	sub_822F1DB0(ctx, base);
	// 82AA1748: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AA174C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA1750: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82AA1754: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AA1758: 4B8506C9  bl 0x822f1e20
	ctx.lr = 0x82AA175C;
	sub_822F1E20(ctx, base);
	// 82AA175C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AA1760: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA1764: 4BBDA07D  bl 0x8267b7e0
	ctx.lr = 0x82AA1768;
	sub_8267B7E0(ctx, base);
	// 82AA1768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA176C: 4B6D00A5  bl 0x82171810
	ctx.lr = 0x82AA1770;
	sub_82171810(ctx, base);
	pc = 0x82AA1770; continue 'dispatch;
            }
            0x82AA1770 => {
    //   block [0x82AA1770..0x82AA17B8)
	// 82AA1770: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82AA1774: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1778: 4B77DAE1  bl 0x8221f258
	ctx.lr = 0x82AA177C;
	sub_8221F258(ctx, base);
	// 82AA177C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA1780: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82AA1784: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AA1788: 419A0030  beq cr6, 0x82aa17b8
	if ctx.cr[6].eq {
	pc = 0x82AA17B8; continue 'dispatch;
	}
	// 82AA178C: 397B000C  addi r11, r27, 0xc
	ctx.r[11].s64 = ctx.r[27].s64 + 12;
	// 82AA1790: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AA1794: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82AA1798: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 82AA179C: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AA17A0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82AA17A4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA17A8: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AA17AC: 4B880395  bl 0x82321b40
	ctx.lr = 0x82AA17B0;
	sub_82321B40(ctx, base);
	// 82AA17B0: 9B3B0020  stb r25, 0x20(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82AA17B4: 9B3B0021  stb r25, 0x21(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(33 as u32), ctx.r[25].u8 ) };
	pc = 0x82AA17B8; continue 'dispatch;
            }
            0x82AA17B8 => {
    //   block [0x82AA17B8..0x82AA17E8)
	// 82AA17B8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA17BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA17C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA17C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA17C8: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA17CC: 409A001C  bne cr6, 0x82aa17e8
	if !ctx.cr[6].eq {
	pc = 0x82AA17E8; continue 'dispatch;
	}
	// 82AA17D0: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82AA17D4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA17D8: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82AA17DC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA17E0: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82AA17E4: 48000044  b 0x82aa1828
	pc = 0x82AA1828; continue 'dispatch;
            }
            0x82AA17E8 => {
    //   block [0x82AA17E8..0x82AA1810)
	// 82AA17E8: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82AA17EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA17F0: 419A0020  beq cr6, 0x82aa1810
	if ctx.cr[6].eq {
	pc = 0x82AA1810; continue 'dispatch;
	}
	// 82AA17F4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82AA17F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA17FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1800: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA1804: 409A0024  bne cr6, 0x82aa1828
	if !ctx.cr[6].eq {
	pc = 0x82AA1828; continue 'dispatch;
	}
	// 82AA1808: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82AA180C: 4800001C  b 0x82aa1828
	pc = 0x82AA1828; continue 'dispatch;
            }
            0x82AA1810 => {
    //   block [0x82AA1810..0x82AA1828)
	// 82AA1810: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82AA1814: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1818: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA181C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA1820: 409A0008  bne cr6, 0x82aa1828
	if !ctx.cr[6].eq {
	pc = 0x82AA1828; continue 'dispatch;
	}
	// 82AA1824: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82AA1828; continue 'dispatch;
            }
            0x82AA1828 => {
    //   block [0x82AA1828..0x82AA1844)
	// 82AA1828: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA182C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82AA1830: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AA1834: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA1838: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AA183C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA1840: 409A0110  bne cr6, 0x82aa1950
	if !ctx.cr[6].eq {
	pc = 0x82AA1950; continue 'dispatch;
	}
	pc = 0x82AA1844; continue 'dispatch;
            }
            0x82AA1844 => {
    //   block [0x82AA1844..0x82AA188C)
	// 82AA1844: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1848: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA184C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1850: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA1854: 409A0078  bne cr6, 0x82aa18cc
	if !ctx.cr[6].eq {
	pc = 0x82AA18CC; continue 'dispatch;
	}
	// 82AA1858: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA185C: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AA1860: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA1864: 409A0028  bne cr6, 0x82aa188c
	if !ctx.cr[6].eq {
	pc = 0x82AA188C; continue 'dispatch;
	}
	// 82AA1868: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA186C: 9BC90020  stb r30, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82AA1870: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82AA1874: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1878: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA187C: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82AA1880: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1884: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1888: 480000B4  b 0x82aa193c
	pc = 0x82AA193C; continue 'dispatch;
            }
            0x82AA188C => {
    //   block [0x82AA188C..0x82AA18A4)
	// 82AA188C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA1890: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA1894: 409A0010  bne cr6, 0x82aa18a4
	if !ctx.cr[6].eq {
	pc = 0x82AA18A4; continue 'dispatch;
	}
	// 82AA1898: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA189C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA18A0: 4BE0FFE1  bl 0x828b1880
	ctx.lr = 0x82AA18A4;
	sub_828B1880(ctx, base);
	pc = 0x82AA18A4; continue 'dispatch;
            }
            0x82AA18A4 => {
    //   block [0x82AA18A4..0x82AA18CC)
	// 82AA18A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA18A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA18AC: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82AA18B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA18B4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA18B8: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82AA18BC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA18C0: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA18C4: 4B872235  bl 0x82313af8
	ctx.lr = 0x82AA18C8;
	sub_82313AF8(ctx, base);
	// 82AA18C8: 48000074  b 0x82aa193c
	pc = 0x82AA193C; continue 'dispatch;
            }
            0x82AA18CC => {
    //   block [0x82AA18CC..0x82AA1900)
	// 82AA18CC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA18D0: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AA18D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA18D8: 409A0028  bne cr6, 0x82aa1900
	if !ctx.cr[6].eq {
	pc = 0x82AA1900; continue 'dispatch;
	}
	// 82AA18DC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA18E0: 9BC90020  stb r30, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82AA18E4: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82AA18E8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA18EC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA18F0: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82AA18F4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA18F8: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA18FC: 48000040  b 0x82aa193c
	pc = 0x82AA193C; continue 'dispatch;
            }
            0x82AA1900 => {
    //   block [0x82AA1900..0x82AA1918)
	// 82AA1900: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1904: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA1908: 409A0010  bne cr6, 0x82aa1918
	if !ctx.cr[6].eq {
	pc = 0x82AA1918; continue 'dispatch;
	}
	// 82AA190C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA1910: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA1914: 4B8721E5  bl 0x82313af8
	ctx.lr = 0x82AA1918;
	sub_82313AF8(ctx, base);
	pc = 0x82AA1918; continue 'dispatch;
            }
            0x82AA1918 => {
    //   block [0x82AA1918..0x82AA193C)
	// 82AA1918: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA191C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA1920: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82AA1924: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1928: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA192C: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82AA1930: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1934: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1938: 4BE0FF49  bl 0x828b1880
	ctx.lr = 0x82AA193C;
	sub_828B1880(ctx, base);
	pc = 0x82AA193C; continue 'dispatch;
            }
            0x82AA193C => {
    //   block [0x82AA193C..0x82AA1950)
	// 82AA193C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1940: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AA1944: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AA1948: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA194C: 419AFEF8  beq cr6, 0x82aa1844
	if ctx.cr[6].eq {
	pc = 0x82AA1844; continue 'dispatch;
	}
	pc = 0x82AA1950; continue 'dispatch;
            }
            0x82AA1950 => {
    //   block [0x82AA1950..0x82AA1970)
	// 82AA1950: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1954: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82AA1958: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82AA195C: 93B80000  stw r29, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AA1960: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1964: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82AA1968: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AA196C: 48207ADC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1970 size=148
    let mut pc: u32 = 0x82AA1970;
    'dispatch: loop {
        match pc {
            0x82AA1970 => {
    //   block [0x82AA1970..0x82AA19A4)
	// 82AA1970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA1978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA197C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA1980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1984: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82AA1988: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82AA198C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82AA1990: 419A004C  beq cr6, 0x82aa19dc
	if ctx.cr[6].eq {
	pc = 0x82AA19DC; continue 'dispatch;
	}
	// 82AA1994: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82AA1998: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AA199C: 38EA2A40  addi r7, r10, 0x2a40
	ctx.r[7].s64 = ctx.r[10].s64 + 10816;
	// 82AA19A0: 3BCB2A30  addi r30, r11, 0x2a30
	ctx.r[30].s64 = ctx.r[11].s64 + 10800;
	pc = 0x82AA19A4; continue 'dispatch;
            }
            0x82AA19A4 => {
    //   block [0x82AA19A4..0x82AA19C4)
	// 82AA19A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA19A8: 419A0028  beq cr6, 0x82aa19d0
	if ctx.cr[6].eq {
	pc = 0x82AA19D0; continue 'dispatch;
	}
	// 82AA19AC: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82AA19B0: 80660004  lwz r3, 4(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA19B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA19B8: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82AA19BC: 419A0008  beq cr6, 0x82aa19c4
	if ctx.cr[6].eq {
	pc = 0x82AA19C4; continue 'dispatch;
	}
	// 82AA19C0: 4B75A7B9  bl 0x821fc178
	ctx.lr = 0x82AA19C4;
	sub_821FC178(ctx, base);
	pc = 0x82AA19C4; continue 'dispatch;
            }
            0x82AA19C4 => {
    //   block [0x82AA19C4..0x82AA19D0)
	// 82AA19C4: 93C80000  stw r30, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AA19C8: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA19CC: 91680008  stw r11, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82AA19D0; continue 'dispatch;
            }
            0x82AA19D0 => {
    //   block [0x82AA19D0..0x82AA19DC)
	// 82AA19D0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA19D4: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 82AA19D8: 4082FFCC  bne 0x82aa19a4
	if !ctx.cr[0].eq {
	pc = 0x82AA19A4; continue 'dispatch;
	}
	pc = 0x82AA19DC; continue 'dispatch;
            }
            0x82AA19DC => {
    //   block [0x82AA19DC..0x82AA1A04)
	// 82AA19DC: 54AB083C  slwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA19E0: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82AA19E4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA19E8: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82AA19EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA19F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA19F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA19F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA19FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA1A00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1A08 size=88
    let mut pc: u32 = 0x82AA1A08;
    'dispatch: loop {
        match pc {
            0x82AA1A08 => {
    //   block [0x82AA1A08..0x82AA1A34)
	// 82AA1A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1A0C: 482079FD  bl 0x82ca9408
	ctx.lr = 0x82AA1A10;
	sub_82CA93D0(ctx, base);
	// 82AA1A10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1A14: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AA1A18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA1A1C: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA1A20: 419A0038  beq cr6, 0x82aa1a58
	if ctx.cr[6].eq {
	pc = 0x82AA1A58; continue 'dispatch;
	}
	// 82AA1A24: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82AA1A28: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AA1A2C: 3BCA2A40  addi r30, r10, 0x2a40
	ctx.r[30].s64 = ctx.r[10].s64 + 10816;
	// 82AA1A30: 3BAB2A30  addi r29, r11, 0x2a30
	ctx.r[29].s64 = ctx.r[11].s64 + 10800;
	pc = 0x82AA1A34; continue 'dispatch;
            }
            0x82AA1A34 => {
    //   block [0x82AA1A34..0x82AA1A58)
	// 82AA1A34: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AA1A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1A3C: 4B75A5CD  bl 0x821fc008
	ctx.lr = 0x82AA1A40;
	sub_821FC008(ctx, base);
	// 82AA1A40: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AA1A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1A48: 4B75A5C1  bl 0x821fc008
	ctx.lr = 0x82AA1A4C;
	sub_821FC008(ctx, base);
	// 82AA1A4C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82AA1A50: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA1A54: 409AFFE0  bne cr6, 0x82aa1a34
	if !ctx.cr[6].eq {
	pc = 0x82AA1A34; continue 'dispatch;
	}
	pc = 0x82AA1A58; continue 'dispatch;
            }
            0x82AA1A58 => {
    //   block [0x82AA1A58..0x82AA1A60)
	// 82AA1A58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA1A5C: 482079FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1A60 size=716
    let mut pc: u32 = 0x82AA1A60;
    'dispatch: loop {
        match pc {
            0x82AA1A60 => {
    //   block [0x82AA1A60..0x82AA1A8C)
	// 82AA1A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1A64: 48207995  bl 0x82ca93f8
	ctx.lr = 0x82AA1A68;
	sub_82CA93D0(ctx, base);
	// 82AA1A68: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1A6C: 83260004  lwz r25, 4(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1A70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA1A74: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82AA1A78: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82AA1A7C: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82AA1A80: 419A000C  beq cr6, 0x82aa1a8c
	if ctx.cr[6].eq {
	pc = 0x82AA1A8C; continue 'dispatch;
	}
	// 82AA1A84: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA1A88: 4B75A6F1  bl 0x821fc178
	ctx.lr = 0x82AA1A8C;
	sub_821FC178(ctx, base);
	pc = 0x82AA1A8C; continue 'dispatch;
            }
            0x82AA1A8C => {
    //   block [0x82AA1A8C..0x82AA1AB8)
	// 82AA1A8C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AA1A90: 83460008  lwz r26, 8(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA1A94: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 82AA1A98: 3B0B2A30  addi r24, r11, 0x2a30
	ctx.r[24].s64 = ctx.r[11].s64 + 10800;
	// 82AA1A9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1AA0: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82AA1AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1AA8: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82AA1AAC: 409A000C  bne cr6, 0x82aa1ab8
	if !ctx.cr[6].eq {
	pc = 0x82AA1AB8; continue 'dispatch;
	}
	// 82AA1AB0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA1AB4: 48000010  b 0x82aa1ac4
	pc = 0x82AA1AC4; continue 'dispatch;
            }
            0x82AA1AB8 => {
    //   block [0x82AA1AB8..0x82AA1AC4)
	// 82AA1AB8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA1ABC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA1AC0: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82AA1AC4; continue 'dispatch;
            }
            0x82AA1AC4 => {
    //   block [0x82AA1AC4..0x82AA1AEC)
	// 82AA1AC4: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA1AC8: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 82AA1ACC: 7D0BE850  subf r8, r11, r29
	ctx.r[8].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82AA1AD0: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 82AA1AD4: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82AA1AD8: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA1ADC: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82AA1AE0: 4098000C  bge cr6, 0x82aa1aec
	if !ctx.cr[6].lt {
	pc = 0x82AA1AEC; continue 'dispatch;
	}
	// 82AA1AE4: 4BFA59E5  bl 0x82a474c8
	ctx.lr = 0x82AA1AE8;
	sub_82A474C8(ctx, base);
	// 82AA1AE8: 4800021C  b 0x82aa1d04
	pc = 0x82AA1D04; continue 'dispatch;
            }
            0x82AA1AEC => {
    //   block [0x82AA1AEC..0x82AA1B10)
	// 82AA1AEC: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82AA1AF0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA1AF4: 409800D4  bge cr6, 0x82aa1bc8
	if !ctx.cr[6].lt {
	pc = 0x82AA1BC8; continue 'dispatch;
	}
	// 82AA1AF8: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA1AFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA1B00: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA1B04: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA1B08: 41980008  blt cr6, 0x82aa1b10
	if ctx.cr[6].lt {
	pc = 0x82AA1B10; continue 'dispatch;
	}
	// 82AA1B0C: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82AA1B10; continue 'dispatch;
            }
            0x82AA1B10 => {
    //   block [0x82AA1B10..0x82AA1B1C)
	// 82AA1B10: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA1B14: 40980008  bge cr6, 0x82aa1b1c
	if !ctx.cr[6].lt {
	pc = 0x82AA1B1C; continue 'dispatch;
	}
	// 82AA1B18: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x82AA1B1C; continue 'dispatch;
            }
            0x82AA1B1C => {
    //   block [0x82AA1B1C..0x82AA1B98)
	// 82AA1B1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA1B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1B24: 4B88188D  bl 0x823233b0
	ctx.lr = 0x82AA1B28;
	sub_823233B0(ctx, base);
	// 82AA1B28: 838100CC  lwz r28, 0xcc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA1B2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA1B30: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1B34: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA1B38: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA1B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1B40: 480001F1  bl 0x82aa1d30
	ctx.lr = 0x82AA1B44;
	sub_82AA1D30(ctx, base);
	// 82AA1B44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA1B48: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA1B4C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA1B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1B54: 4BFFFE1D  bl 0x82aa1970
	ctx.lr = 0x82AA1B58;
	sub_82AA1970(ctx, base);
	// 82AA1B58: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA1B5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA1B60: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA1B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1B68: 480001C9  bl 0x82aa1d30
	ctx.lr = 0x82AA1B6C;
	sub_82AA1D30(ctx, base);
	// 82AA1B6C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1B70: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA1B74: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AA1B78: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82AA1B7C: 7D6BDBD6  divw r11, r11, r27
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82AA1B80: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 82AA1B84: 419A0014  beq cr6, 0x82aa1b98
	if ctx.cr[6].eq {
	pc = 0x82AA1B98; continue 'dispatch;
	}
	// 82AA1B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1B8C: 4BFFFE7D  bl 0x82aa1a08
	ctx.lr = 0x82AA1B90;
	sub_82AA1A08(ctx, base);
	// 82AA1B90: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1B94: 4B77A1A5  bl 0x8221bd38
	ctx.lr = 0x82AA1B98;
	sub_8221BD38(ctx, base);
	pc = 0x82AA1B98; continue 'dispatch;
            }
            0x82AA1B98 => {
    //   block [0x82AA1B98..0x82AA1BC8)
	// 82AA1B98: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA1B9C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AA1BA0: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA1BA4: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AA1BA8: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82AA1BAC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA1BB0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA1BB4: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA1BB8: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82AA1BBC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82AA1BC0: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82AA1BC4: 48000140  b 0x82aa1d04
	pc = 0x82AA1D04; continue 'dispatch;
            }
            0x82AA1BC8 => {
    //   block [0x82AA1BC8..0x82AA1C24)
	// 82AA1BC8: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA1BCC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA1BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1BD4: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82AA1BD8: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82AA1BDC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82AA1BE0: 40980080  bge cr6, 0x82aa1c60
	if !ctx.cr[6].lt {
	pc = 0x82AA1C60; continue 'dispatch;
	}
	// 82AA1BE4: 38DE000C  addi r6, r30, 0xc
	ctx.r[6].s64 = ctx.r[30].s64 + 12;
	// 82AA1BE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA1BEC: 48000145  bl 0x82aa1d30
	ctx.lr = 0x82AA1BF0;
	sub_82AA1D30(ctx, base);
	// 82AA1BF0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA1BF4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA1BF8: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82AA1BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1C00: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82AA1C04: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82AA1C08: 4BFFFD69  bl 0x82aa1970
	ctx.lr = 0x82AA1C0C;
	sub_82AA1970(ctx, base);
	// 82AA1C0C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA1C10: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82AA1C14: 3BABFFF4  addi r29, r11, -0xc
	ctx.r[29].s64 = ctx.r[11].s64 + -12;
	// 82AA1C18: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA1C1C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA1C20: 419A00E4  beq cr6, 0x82aa1d04
	if ctx.cr[6].eq {
	pc = 0x82AA1D04; continue 'dispatch;
	}
	pc = 0x82AA1C24; continue 'dispatch;
            }
            0x82AA1C24 => {
    //   block [0x82AA1C24..0x82AA1C4C)
	// 82AA1C24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA1C28: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA1C2C: 419A0020  beq cr6, 0x82aa1c4c
	if ctx.cr[6].eq {
	pc = 0x82AA1C4C; continue 'dispatch;
	}
	// 82AA1C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1C34: 4B75A3D5  bl 0x821fc008
	ctx.lr = 0x82AA1C38;
	sub_821FC008(ctx, base);
	// 82AA1C38: 933E0004  stw r25, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82AA1C3C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82AA1C40: 419A000C  beq cr6, 0x82aa1c4c
	if ctx.cr[6].eq {
	pc = 0x82AA1C4C; continue 'dispatch;
	}
	// 82AA1C44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA1C48: 4B75A531  bl 0x821fc178
	ctx.lr = 0x82AA1C4C;
	sub_821FC178(ctx, base);
	pc = 0x82AA1C4C; continue 'dispatch;
            }
            0x82AA1C4C => {
    //   block [0x82AA1C4C..0x82AA1C60)
	// 82AA1C4C: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82AA1C50: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82AA1C54: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA1C58: 409AFFCC  bne cr6, 0x82aa1c24
	if !ctx.cr[6].eq {
	pc = 0x82AA1C24; continue 'dispatch;
	}
	// 82AA1C5C: 480000A8  b 0x82aa1d04
	pc = 0x82AA1D04; continue 'dispatch;
            }
            0x82AA1C60 => {
    //   block [0x82AA1C60..0x82AA1C80)
	// 82AA1C60: 3B9DFFF4  addi r28, r29, -0xc
	ctx.r[28].s64 = ctx.r[29].s64 + -12;
	// 82AA1C64: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA1C68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA1C6C: 480000C5  bl 0x82aa1d30
	ctx.lr = 0x82AA1C70;
	sub_82AA1D30(ctx, base);
	// 82AA1C70: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AA1C74: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA1C78: 419A0044  beq cr6, 0x82aa1cbc
	if ctx.cr[6].eq {
	pc = 0x82AA1CBC; continue 'dispatch;
	}
	// 82AA1C7C: 3BFDFFFC  addi r31, r29, -4
	ctx.r[31].s64 = ctx.r[29].s64 + -4;
	pc = 0x82AA1C80; continue 'dispatch;
            }
            0x82AA1C80 => {
    //   block [0x82AA1C80..0x82AA1CAC)
	// 82AA1C80: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 82AA1C84: 3BBFFFF8  addi r29, r31, -8
	ctx.r[29].s64 = ctx.r[31].s64 + -8;
	// 82AA1C88: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82AA1C8C: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82AA1C90: 419A001C  beq cr6, 0x82aa1cac
	if ctx.cr[6].eq {
	pc = 0x82AA1CAC; continue 'dispatch;
	}
	// 82AA1C94: 4B75A375  bl 0x821fc008
	ctx.lr = 0x82AA1C98;
	sub_821FC008(ctx, base);
	// 82AA1C98: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AA1C9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1CA0: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AA1CA4: 419A0008  beq cr6, 0x82aa1cac
	if ctx.cr[6].eq {
	pc = 0x82AA1CAC; continue 'dispatch;
	}
	// 82AA1CA8: 4B75A4D1  bl 0x821fc178
	ctx.lr = 0x82AA1CAC;
	sub_821FC178(ctx, base);
	pc = 0x82AA1CAC; continue 'dispatch;
            }
            0x82AA1CAC => {
    //   block [0x82AA1CAC..0x82AA1CBC)
	// 82AA1CAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1CB0: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA1CB4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AA1CB8: 409AFFC8  bne cr6, 0x82aa1c80
	if !ctx.cr[6].eq {
	pc = 0x82AA1C80; continue 'dispatch;
	}
	pc = 0x82AA1CBC; continue 'dispatch;
            }
            0x82AA1CBC => {
    //   block [0x82AA1CBC..0x82AA1CCC)
	// 82AA1CBC: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 82AA1CC0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82AA1CC4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA1CC8: 419A003C  beq cr6, 0x82aa1d04
	if ctx.cr[6].eq {
	pc = 0x82AA1D04; continue 'dispatch;
	}
	pc = 0x82AA1CCC; continue 'dispatch;
            }
            0x82AA1CCC => {
    //   block [0x82AA1CCC..0x82AA1CF4)
	// 82AA1CCC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA1CD0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA1CD4: 419A0020  beq cr6, 0x82aa1cf4
	if ctx.cr[6].eq {
	pc = 0x82AA1CF4; continue 'dispatch;
	}
	// 82AA1CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1CDC: 4B75A32D  bl 0x821fc008
	ctx.lr = 0x82AA1CE0;
	sub_821FC008(ctx, base);
	// 82AA1CE0: 933F0004  stw r25, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82AA1CE4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82AA1CE8: 419A000C  beq cr6, 0x82aa1cf4
	if ctx.cr[6].eq {
	pc = 0x82AA1CF4; continue 'dispatch;
	}
	// 82AA1CEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA1CF0: 4B75A489  bl 0x821fc178
	ctx.lr = 0x82AA1CF4;
	sub_821FC178(ctx, base);
	pc = 0x82AA1CF4; continue 'dispatch;
            }
            0x82AA1CF4 => {
    //   block [0x82AA1CF4..0x82AA1D04)
	// 82AA1CF4: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82AA1CF8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82AA1CFC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA1D00: 409AFFCC  bne cr6, 0x82aa1ccc
	if !ctx.cr[6].eq {
	pc = 0x82AA1CCC; continue 'dispatch;
	}
	pc = 0x82AA1D04; continue 'dispatch;
            }
            0x82AA1D04 => {
    //   block [0x82AA1D04..0x82AA1D2C)
	// 82AA1D04: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82AA1D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1D0C: 4B75A2FD  bl 0x821fc008
	ctx.lr = 0x82AA1D10;
	sub_821FC008(ctx, base);
	// 82AA1D10: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AA1D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1D18: 394B2A40  addi r10, r11, 0x2a40
	ctx.r[10].s64 = ctx.r[11].s64 + 10816;
	// 82AA1D1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA1D20: 4B75A2E9  bl 0x821fc008
	ctx.lr = 0x82AA1D24;
	sub_821FC008(ctx, base);
	// 82AA1D24: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA1D28: 48207720  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1D30 size=136
    let mut pc: u32 = 0x82AA1D30;
    'dispatch: loop {
        match pc {
            0x82AA1D30 => {
    //   block [0x82AA1D30..0x82AA1D60)
	// 82AA1D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA1D38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA1D3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1D40: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA1D44: 419A005C  beq cr6, 0x82aa1da0
	if ctx.cr[6].eq {
	pc = 0x82AA1DA0; continue 'dispatch;
	}
	// 82AA1D48: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82AA1D4C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AA1D50: 39040008  addi r8, r4, 8
	ctx.r[8].s64 = ctx.r[4].s64 + 8;
	// 82AA1D54: 7FE43050  subf r31, r4, r6
	ctx.r[31].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82AA1D58: 38EA2A40  addi r7, r10, 0x2a40
	ctx.r[7].s64 = ctx.r[10].s64 + 10816;
	// 82AA1D5C: 388B2A30  addi r4, r11, 0x2a30
	ctx.r[4].s64 = ctx.r[11].s64 + 10800;
	pc = 0x82AA1D60; continue 'dispatch;
            }
            0x82AA1D60 => {
    //   block [0x82AA1D60..0x82AA1D80)
	// 82AA1D60: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82AA1D64: 419A0028  beq cr6, 0x82aa1d8c
	if ctx.cr[6].eq {
	pc = 0x82AA1D8C; continue 'dispatch;
	}
	// 82AA1D68: 90E60000  stw r7, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82AA1D6C: 8068FFFC  lwz r3, -4(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AA1D70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1D74: 90660004  stw r3, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82AA1D78: 419A0008  beq cr6, 0x82aa1d80
	if ctx.cr[6].eq {
	pc = 0x82AA1D80; continue 'dispatch;
	}
	// 82AA1D7C: 4B75A3FD  bl 0x821fc178
	ctx.lr = 0x82AA1D80;
	sub_821FC178(ctx, base);
	pc = 0x82AA1D80; continue 'dispatch;
            }
            0x82AA1D80 => {
    //   block [0x82AA1D80..0x82AA1D8C)
	// 82AA1D80: 90860000  stw r4, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82AA1D84: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1D88: 7D7F412E  stwx r11, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	pc = 0x82AA1D8C; continue 'dispatch;
            }
            0x82AA1D8C => {
    //   block [0x82AA1D8C..0x82AA1DA0)
	// 82AA1D8C: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 82AA1D90: 38C6000C  addi r6, r6, 0xc
	ctx.r[6].s64 = ctx.r[6].s64 + 12;
	// 82AA1D94: 3968FFF8  addi r11, r8, -8
	ctx.r[11].s64 = ctx.r[8].s64 + -8;
	// 82AA1D98: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA1D9C: 409AFFC4  bne cr6, 0x82aa1d60
	if !ctx.cr[6].eq {
	pc = 0x82AA1D60; continue 'dispatch;
	}
	pc = 0x82AA1DA0; continue 'dispatch;
            }
            0x82AA1DA0 => {
    //   block [0x82AA1DA0..0x82AA1DB8)
	// 82AA1DA0: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82AA1DA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA1DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA1DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA1DB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA1DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1DB8 size=180
    let mut pc: u32 = 0x82AA1DB8;
    'dispatch: loop {
        match pc {
            0x82AA1DB8 => {
    //   block [0x82AA1DB8..0x82AA1E08)
	// 82AA1DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1DBC: 4820764D  bl 0x82ca9408
	ctx.lr = 0x82AA1DC0;
	sub_82CA93D0(ctx, base);
	// 82AA1DC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1DC4: F8610090  std r3, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u64 ) };
	// 82AA1DC8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82AA1DCC: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 82AA1DD0: 83C10094  lwz r30, 0x94(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA1DD4: 83E1009C  lwz r31, 0x9c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AA1DD8: F8A100A0  std r5, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u64 ) };
	// 82AA1DDC: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1DE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1DE4: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 82AA1DE8: 4E800421  bctrl
	ctx.lr = 0x82AA1DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1DEC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AA1DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1DF4: 419A0014  beq cr6, 0x82aa1e08
	if ctx.cr[6].eq {
	pc = 0x82AA1E08; continue 'dispatch;
	}
	// 82AA1DF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1DFC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA1E04: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
            }
            0x82AA1E08 => {
    //   block [0x82AA1E08..0x82AA1E38)
	// 82AA1E08: 838100A4  lwz r28, 0xa4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA1E0C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E10: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E14: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 82AA1E18: 4E800421  bctrl
	ctx.lr = 0x82AA1E1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1E1C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AA1E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1E24: 419A0014  beq cr6, 0x82aa1e38
	if ctx.cr[6].eq {
	pc = 0x82AA1E38; continue 'dispatch;
	}
	// 82AA1E28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E2C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E30: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA1E34: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
            }
            0x82AA1E38 => {
    //   block [0x82AA1E38..0x82AA1E64)
	// 82AA1E38: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E3C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E40: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 82AA1E44: 4E800421  bctrl
	ctx.lr = 0x82AA1E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1E48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AA1E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1E50: 419A0014  beq cr6, 0x82aa1e64
	if ctx.cr[6].eq {
	pc = 0x82AA1E64; continue 'dispatch;
	}
	// 82AA1E54: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E58: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E5C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA1E60: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
            }
            0x82AA1E64 => {
    //   block [0x82AA1E64..0x82AA1E6C)
	// 82AA1E64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA1E68: 482075F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA1E70 size=280
    let mut pc: u32 = 0x82AA1E70;
    'dispatch: loop {
        match pc {
            0x82AA1E70 => {
    //   block [0x82AA1E70..0x82AA1EA8)
	// 82AA1E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1E74: 48207589  bl 0x82ca93fc
	ctx.lr = 0x82AA1E78;
	sub_82CA93D0(ctx, base);
	// 82AA1E78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1E7C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA1E80: F86100B0  std r3, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u64 ) };
	// 82AA1E84: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AA1E88: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AA1E8C: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82AA1E90: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82AA1E94: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82AA1E98: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82AA1E9C: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82AA1EA0: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82AA1EA4: 4098005C  bge cr6, 0x82aa1f00
	if !ctx.cr[6].lt {
	pc = 0x82AA1F00; continue 'dispatch;
	}
	pc = 0x82AA1EA8; continue 'dispatch;
            }
            0x82AA1EA8 => {
    //   block [0x82AA1EA8..0x82AA1ED8)
	// 82AA1EA8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA1EAC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA1EB0: 394BFFFC  addi r10, r11, -4
	ctx.r[10].s64 = ctx.r[11].s64 + -4;
	// 82AA1EB4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA1EB8: 808BFFFC  lwz r4, -4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AA1EBC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1EC0: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 82AA1EC4: 4E800421  bctrl
	ctx.lr = 0x82AA1EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1EC8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AA1ECC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA1ED0: 419A0008  beq cr6, 0x82aa1ed8
	if ctx.cr[6].eq {
	pc = 0x82AA1ED8; continue 'dispatch;
	}
	// 82AA1ED4: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
            }
            0x82AA1ED8 => {
    //   block [0x82AA1ED8..0x82AA1F00)
	// 82AA1ED8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA1EDC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA1EE0: 393F0001  addi r9, r31, 1
	ctx.r[9].s64 = ctx.r[31].s64 + 1;
	// 82AA1EE4: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82AA1EE8: 553F083C  slwi r31, r9, 1
	ctx.r[31].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82AA1EEC: 7D0BF02E  lwzx r8, r11, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82AA1EF0: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82AA1EF4: 7D0AF12E  stwx r8, r10, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[8].u32) };
	// 82AA1EF8: 4198FFB0  blt cr6, 0x82aa1ea8
	if ctx.cr[6].lt {
	pc = 0x82AA1EA8; continue 'dispatch;
	}
	// 82AA1EFC: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	pc = 0x82AA1F00; continue 'dispatch;
            }
            0x82AA1F00 => {
    //   block [0x82AA1F00..0x82AA1F20)
	// 82AA1F00: 409A0020  bne cr6, 0x82aa1f20
	if !ctx.cr[6].eq {
	pc = 0x82AA1F20; continue 'dispatch;
	}
	// 82AA1F04: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA1F08: 57A9103A  slwi r9, r29, 2
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA1F0C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA1F10: 3BBCFFFF  addi r29, r28, -1
	ctx.r[29].s64 = ctx.r[28].s64 + -1;
	// 82AA1F14: 394BFFFC  addi r10, r11, -4
	ctx.r[10].s64 = ctx.r[11].s64 + -4;
	// 82AA1F18: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AA1F1C: 7D69F12E  stwx r11, r9, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	pc = 0x82AA1F20; continue 'dispatch;
            }
            0x82AA1F20 => {
    //   block [0x82AA1F20..0x82AA1F34)
	// 82AA1F20: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 82AA1F24: 7F1AE800  cmpw cr6, r26, r29
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82AA1F28: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AA1F2C: 7FEA0194  addze r31, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[31].s64 = tmp.s64;
	// 82AA1F30: 40980048  bge cr6, 0x82aa1f78
	if !ctx.cr[6].lt {
	pc = 0x82AA1F78; continue 'dispatch;
	}
	pc = 0x82AA1F34; continue 'dispatch;
            }
            0x82AA1F34 => {
    //   block [0x82AA1F34..0x82AA1F78)
	// 82AA1F34: 57FC103A  slwi r28, r31, 2
	ctx.r[28].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82AA1F38: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AA1F3C: 7C7CF02E  lwzx r3, r28, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82AA1F40: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 82AA1F44: 4E800421  bctrl
	ctx.lr = 0x82AA1F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1F48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AA1F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1F50: 419A0028  beq cr6, 0x82aa1f78
	if ctx.cr[6].eq {
	pc = 0x82AA1F78; continue 'dispatch;
	}
	// 82AA1F54: 7D5CF02E  lwzx r10, r28, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82AA1F58: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA1F5C: 393FFFFF  addi r9, r31, -1
	ctx.r[9].s64 = ctx.r[31].s64 + -1;
	// 82AA1F60: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82AA1F64: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82AA1F68: 7F1AE800  cmpw cr6, r26, r29
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82AA1F6C: 7FE80194  addze r31, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[31].s64 = tmp.s64;
	// 82AA1F70: 7D4BF12E  stwx r10, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u32) };
	// 82AA1F74: 4198FFC0  blt cr6, 0x82aa1f34
	if ctx.cr[6].lt {
	pc = 0x82AA1F34; continue 'dispatch;
	}
            }
            0x82AA1F78 => {
    //   block [0x82AA1F78..0x82AA1F88)
	// 82AA1F78: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA1F7C: 7F2BF12E  stwx r25, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[25].u32) };
	// 82AA1F80: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA1F84: 482074C8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1F88 size=808
    let mut pc: u32 = 0x82AA1F88;
    'dispatch: loop {
        match pc {
            0x82AA1F88 => {
    //   block [0x82AA1F88..0x82AA206C)
	// 82AA1F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1F8C: 48207455  bl 0x82ca93e0
	ctx.lr = 0x82AA1F90;
	sub_82CA93D0(ctx, base);
	// 82AA1F90: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1F94: 48067A0D  bl 0x82b099a0
	ctx.lr = 0x82AA1F98;
	sub_82B099A0(ctx, base);
	// 82AA1F98: 48067B39  bl 0x82b09ad0
	ctx.lr = 0x82AA1F9C;
	sub_82B09AD0(ctx, base);
	// 82AA1F9C: 48067C65  bl 0x82b09c00
	ctx.lr = 0x82AA1FA0;
	sub_82B09C00(ctx, base);
	// 82AA1FA0: 48067D91  bl 0x82b09d30
	ctx.lr = 0x82AA1FA4;
	sub_82B09D30(ctx, base);
	// 82AA1FA4: 48067EBD  bl 0x82b09e60
	ctx.lr = 0x82AA1FA8;
	sub_82B09E60(ctx, base);
	// 82AA1FA8: 48067FE9  bl 0x82b09f90
	ctx.lr = 0x82AA1FAC;
	sub_82B09F90(ctx, base);
	// 82AA1FAC: 48068115  bl 0x82b0a0c0
	ctx.lr = 0x82AA1FB0;
	sub_82B0A0C0(ctx, base);
	// 82AA1FB0: 48068241  bl 0x82b0a1f0
	ctx.lr = 0x82AA1FB4;
	sub_82B0A1F0(ctx, base);
	// 82AA1FB4: 4806836D  bl 0x82b0a320
	ctx.lr = 0x82AA1FB8;
	sub_82B0A320(ctx, base);
	// 82AA1FB8: 48068499  bl 0x82b0a450
	ctx.lr = 0x82AA1FBC;
	sub_82B0A450(ctx, base);
	// 82AA1FBC: 480685C5  bl 0x82b0a580
	ctx.lr = 0x82AA1FC0;
	sub_82B0A580(ctx, base);
	// 82AA1FC0: 480686F1  bl 0x82b0a6b0
	ctx.lr = 0x82AA1FC4;
	sub_82B0A6B0(ctx, base);
	// 82AA1FC4: 4806881D  bl 0x82b0a7e0
	ctx.lr = 0x82AA1FC8;
	sub_82B0A7E0(ctx, base);
	// 82AA1FC8: 48068949  bl 0x82b0a910
	ctx.lr = 0x82AA1FCC;
	sub_82B0A910(ctx, base);
	// 82AA1FCC: 48068A75  bl 0x82b0aa40
	ctx.lr = 0x82AA1FD0;
	sub_82B0AA40(ctx, base);
	// 82AA1FD0: 48068BA1  bl 0x82b0ab70
	ctx.lr = 0x82AA1FD4;
	sub_82B0AB70(ctx, base);
	// 82AA1FD4: 48068CCD  bl 0x82b0aca0
	ctx.lr = 0x82AA1FD8;
	sub_82B0ACA0(ctx, base);
	// 82AA1FD8: 48068DF9  bl 0x82b0add0
	ctx.lr = 0x82AA1FDC;
	sub_82B0ADD0(ctx, base);
	// 82AA1FDC: 48068F25  bl 0x82b0af00
	ctx.lr = 0x82AA1FE0;
	sub_82B0AF00(ctx, base);
	// 82AA1FE0: 48069051  bl 0x82b0b030
	ctx.lr = 0x82AA1FE4;
	sub_82B0B030(ctx, base);
	// 82AA1FE4: 4806917D  bl 0x82b0b160
	ctx.lr = 0x82AA1FE8;
	sub_82B0B160(ctx, base);
	// 82AA1FE8: 480692A9  bl 0x82b0b290
	ctx.lr = 0x82AA1FEC;
	sub_82B0B290(ctx, base);
	// 82AA1FEC: 480693D5  bl 0x82b0b3c0
	ctx.lr = 0x82AA1FF0;
	sub_82B0B3C0(ctx, base);
	// 82AA1FF0: 48069501  bl 0x82b0b4f0
	ctx.lr = 0x82AA1FF4;
	sub_82B0B4F0(ctx, base);
	// 82AA1FF4: 4806962D  bl 0x82b0b620
	ctx.lr = 0x82AA1FF8;
	sub_82B0B620(ctx, base);
	// 82AA1FF8: 48069759  bl 0x82b0b750
	ctx.lr = 0x82AA1FFC;
	sub_82B0B750(ctx, base);
	// 82AA1FFC: 48069885  bl 0x82b0b880
	ctx.lr = 0x82AA2000;
	sub_82B0B880(ctx, base);
	// 82AA2000: 480699B1  bl 0x82b0b9b0
	ctx.lr = 0x82AA2004;
	sub_82B0B9B0(ctx, base);
	// 82AA2004: 48069ADD  bl 0x82b0bae0
	ctx.lr = 0x82AA2008;
	sub_82B0BAE0(ctx, base);
	// 82AA2008: 48069C09  bl 0x82b0bc10
	ctx.lr = 0x82AA200C;
	sub_82B0BC10(ctx, base);
	// 82AA200C: 48069D35  bl 0x82b0bd40
	ctx.lr = 0x82AA2010;
	sub_82B0BD40(ctx, base);
	// 82AA2010: 48069E61  bl 0x82b0be70
	ctx.lr = 0x82AA2014;
	sub_82B0BE70(ctx, base);
	// 82AA2014: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AA2018: 386B5894  addi r3, r11, 0x5894
	ctx.r[3].s64 = ctx.r[11].s64 + 22676;
	// 82AA201C: 480763F5  bl 0x82b18410
	ctx.lr = 0x82AA2020;
	sub_82B18410(ctx, base);
	// 82AA2020: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA2024: 4BA0C63D  bl 0x824ae660
	ctx.lr = 0x82AA2028;
	sub_824AE660(ctx, base);
	// 82AA2028: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82AA202C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AA2030: 3A4B0210  addi r18, r11, 0x210
	ctx.r[18].s64 = ctx.r[11].s64 + 528;
	// 82AA2034: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AA2038: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82AA203C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA2040: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82AA2044: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 82AA2048: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 82AA204C: 7F94E378  mr r20, r28
	ctx.r[20].u64 = ctx.r[28].u64;
	// 82AA2050: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 82AA2054: 3BAB7088  addi r29, r11, 0x7088
	ctx.r[29].s64 = ctx.r[11].s64 + 28808;
	// 82AA2058: 3B4A7F98  addi r26, r10, 0x7f98
	ctx.r[26].s64 = ctx.r[10].s64 + 32664;
	// 82AA205C: 3B096C20  addi r24, r9, 0x6c20
	ctx.r[24].s64 = ctx.r[9].s64 + 27680;
	// 82AA2060: 3AC87F74  addi r22, r8, 0x7f74
	ctx.r[22].s64 = ctx.r[8].s64 + 32628;
	// 82AA2064: 3AA77F58  addi r21, r7, 0x7f58
	ctx.r[21].s64 = ctx.r[7].s64 + 32600;
	// 82AA2068: 3A667F38  addi r19, r6, 0x7f38
	ctx.r[19].s64 = ctx.r[6].s64 + 32568;
	pc = 0x82AA206C; continue 'dispatch;
            }
            0x82AA206C => {
    //   block [0x82AA206C..0x82AA209C)
	// 82AA206C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82AA2070: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AA2074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2078: 4B78AE59  bl 0x8222ced0
	ctx.lr = 0x82AA207C;
	sub_8222CED0(ctx, base);
	// 82AA207C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA2080: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA2084: 4B8666D5  bl 0x82308758
	ctx.lr = 0x82AA2088;
	sub_82308758(ctx, base);
	// 82AA2088: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA208C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2090: 928B0000  stw r20, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 82AA2094: 4B7246D5  bl 0x821c6768
	ctx.lr = 0x82AA2098;
	sub_821C6768(ctx, base);
	// 82AA2098: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82AA209C; continue 'dispatch;
            }
            0x82AA209C => {
    //   block [0x82AA209C..0x82AA20C0)
	// 82AA209C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA20A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA20A4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA20A8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AA20AC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA20B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA20B4: 4082FFE8  bne 0x82aa209c
	if !ctx.cr[0].eq {
	pc = 0x82AA209C; continue 'dispatch;
	}
	// 82AA20B8: 7F97E378  mr r23, r28
	ctx.r[23].u64 = ctx.r[28].u64;
	// 82AA20BC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82AA20C0; continue 'dispatch;
            }
            0x82AA20C0 => {
    //   block [0x82AA20C0..0x82AA20F0)
	// 82AA20C0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82AA20C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AA20C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA20CC: 4B78AE05  bl 0x8222ced0
	ctx.lr = 0x82AA20D0;
	sub_8222CED0(ctx, base);
	// 82AA20D0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA20D4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA20D8: 4B866681  bl 0x82308758
	ctx.lr = 0x82AA20DC;
	sub_82308758(ctx, base);
	// 82AA20DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA20E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA20E4: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82AA20E8: 4B724681  bl 0x821c6768
	ctx.lr = 0x82AA20EC;
	sub_821C6768(ctx, base);
	// 82AA20EC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82AA20F0; continue 'dispatch;
            }
            0x82AA20F0 => {
    //   block [0x82AA20F0..0x82AA2114)
	// 82AA20F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA20F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA20F8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA20FC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AA2100: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2104: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2108: 4082FFE8  bne 0x82aa20f0
	if !ctx.cr[0].eq {
	pc = 0x82AA20F0; continue 'dispatch;
	}
	// 82AA210C: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 82AA2110: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x82AA2114; continue 'dispatch;
            }
            0x82AA2114 => {
    //   block [0x82AA2114..0x82AA2144)
	// 82AA2114: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82AA2118: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AA211C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA2120: 4B78ADB1  bl 0x8222ced0
	ctx.lr = 0x82AA2124;
	sub_8222CED0(ctx, base);
	// 82AA2124: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AA2128: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA212C: 4B86662D  bl 0x82308758
	ctx.lr = 0x82AA2130;
	sub_82308758(ctx, base);
	// 82AA2130: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA2134: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA2138: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82AA213C: 4B72462D  bl 0x821c6768
	ctx.lr = 0x82AA2140;
	sub_821C6768(ctx, base);
	// 82AA2140: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82AA2144; continue 'dispatch;
            }
            0x82AA2144 => {
    //   block [0x82AA2144..0x82AA2168)
	// 82AA2144: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA2148: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA214C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA2150: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AA2154: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2158: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA215C: 4082FFE8  bne 0x82aa2144
	if !ctx.cr[0].eq {
	pc = 0x82AA2144; continue 'dispatch;
	}
	// 82AA2160: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 82AA2164: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	pc = 0x82AA2168; continue 'dispatch;
            }
            0x82AA2168 => {
    //   block [0x82AA2168..0x82AA2198)
	// 82AA2168: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AA216C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AA2170: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA2174: 4B78AD5D  bl 0x8222ced0
	ctx.lr = 0x82AA2178;
	sub_8222CED0(ctx, base);
	// 82AA2178: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA217C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA2180: 4B8665D9  bl 0x82308758
	ctx.lr = 0x82AA2184;
	sub_82308758(ctx, base);
	// 82AA2184: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA2188: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA218C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82AA2190: 4B7245D9  bl 0x821c6768
	ctx.lr = 0x82AA2194;
	sub_821C6768(ctx, base);
	// 82AA2194: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82AA2198; continue 'dispatch;
            }
            0x82AA2198 => {
    //   block [0x82AA2198..0x82AA21BC)
	// 82AA2198: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA219C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA21A0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA21A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AA21A8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA21AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA21B0: 4082FFE8  bne 0x82aa2198
	if !ctx.cr[0].eq {
	pc = 0x82AA2198; continue 'dispatch;
	}
	// 82AA21B4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82AA21B8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	pc = 0x82AA21BC; continue 'dispatch;
            }
            0x82AA21BC => {
    //   block [0x82AA21BC..0x82AA21EC)
	// 82AA21BC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA21C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AA21C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA21C8: 4B78AD09  bl 0x8222ced0
	ctx.lr = 0x82AA21CC;
	sub_8222CED0(ctx, base);
	// 82AA21CC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82AA21D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA21D4: 4B866585  bl 0x82308758
	ctx.lr = 0x82AA21D8;
	sub_82308758(ctx, base);
	// 82AA21D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA21DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA21E0: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA21E4: 4B724585  bl 0x821c6768
	ctx.lr = 0x82AA21E8;
	sub_821C6768(ctx, base);
	// 82AA21E8: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82AA21EC; continue 'dispatch;
            }
            0x82AA21EC => {
    //   block [0x82AA21EC..0x82AA22B0)
	// 82AA21EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA21F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA21F4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA21F8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AA21FC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2200: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2204: 4082FFE8  bne 0x82aa21ec
	if !ctx.cr[0].eq {
	pc = 0x82AA21EC; continue 'dispatch;
	}
	// 82AA2208: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA220C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82AA2210: 4806A321  bl 0x82b0c530
	ctx.lr = 0x82AA2214;
	sub_82B0C530(ctx, base);
	// 82AA2214: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2218: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82AA221C: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 82AA2220: E8C70004  ld r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	// 82AA2224: F8C10070  std r6, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[6].u64 ) };
	// 82AA2228: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA222C: 90BE0000  stw r5, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82AA2230: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AA2234: 4198FF88  blt cr6, 0x82aa21bc
	if ctx.cr[6].lt {
	pc = 0x82AA21BC; continue 'dispatch;
	}
	// 82AA2238: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AA223C: 2F1B0002  cmpwi cr6, r27, 2
	ctx.cr[6].compare_i32(ctx.r[27].s32, 2, &mut ctx.xer);
	// 82AA2240: 4198FF28  blt cr6, 0x82aa2168
	if ctx.cr[6].lt {
	pc = 0x82AA2168; continue 'dispatch;
	}
	// 82AA2244: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82AA2248: 2F190002  cmpwi cr6, r25, 2
	ctx.cr[6].compare_i32(ctx.r[25].s32, 2, &mut ctx.xer);
	// 82AA224C: 4198FEC8  blt cr6, 0x82aa2114
	if ctx.cr[6].lt {
	pc = 0x82AA2114; continue 'dispatch;
	}
	// 82AA2250: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82AA2254: 2F170002  cmpwi cr6, r23, 2
	ctx.cr[6].compare_i32(ctx.r[23].s32, 2, &mut ctx.xer);
	// 82AA2258: 4198FE68  blt cr6, 0x82aa20c0
	if ctx.cr[6].lt {
	pc = 0x82AA20C0; continue 'dispatch;
	}
	// 82AA225C: 39720080  addi r11, r18, 0x80
	ctx.r[11].s64 = ctx.r[18].s64 + 128;
	// 82AA2260: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 82AA2264: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AA2268: 4198FE04  blt cr6, 0x82aa206c
	if ctx.cr[6].lt {
	pc = 0x82AA206C; continue 'dispatch;
	}
	// 82AA226C: 39210078  addi r9, r1, 0x78
	ctx.r[9].s64 = ctx.r[1].s64 + 120;
	// 82AA2270: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA2274: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 82AA2278: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82AA227C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AA2280: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA2284: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82AA2288: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA228C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA2290: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AA2294: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82AA2298: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA229C: 4B866985  bl 0x82308c20
	ctx.lr = 0x82AA22A0;
	sub_82308C20(ctx, base);
	// 82AA22A0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA22A4: 4B779A95  bl 0x8221bd38
	ctx.lr = 0x82AA22A8;
	sub_8221BD38(ctx, base);
	// 82AA22A8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AA22AC: 48207184  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA22B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA22B0 size=656
    let mut pc: u32 = 0x82AA22B0;
    'dispatch: loop {
        match pc {
            0x82AA22B0 => {
    //   block [0x82AA22B0..0x82AA2540)
	// 82AA22B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA22B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA22B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA22BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA22C0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA22C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AA22C8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA2540 size=280
    let mut pc: u32 = 0x82AA2540;
    'dispatch: loop {
        match pc {
            0x82AA2540 => {
    //   block [0x82AA2540..0x82AA2610)
	// 82AA2540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA2548: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA254C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA2550: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82AA2554: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AA2558: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA255C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA2560: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA2564: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA2568: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 82AA256C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2570: C18B9490  lfs f12, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA2574: C00A372C  lfs f0, 0x372c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2578: C1AAFFF4  lfs f13, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA257C: C03F0200  lfs f1, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA2580: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 82AA2584: C17F0204  lfs f11, 0x204(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AA2588: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 82AA258C: ED4B0828  fsubs f10, f11, f1
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AA2590: C13F00BC  lfs f9, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82AA2594: C11F00B8  lfs f8, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82AA2598: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AA259C: EFE80032  fmuls f31, f8, f0
	ctx.f[31].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AA25A0: C00A1FF0  lfs f0, 0x1ff0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA25A4: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AA25A8: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 82AA25AC: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA25B0: FD006890  fmr f8, f13
	ctx.f[8].f64 = ctx.f[13].f64;
	// 82AA25B4: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	// 82AA25B8: FC606890  fmr f3, f13
	ctx.f[3].f64 = ctx.f[13].f64;
	// 82AA25BC: FC406890  fmr f2, f13
	ctx.f[2].f64 = ctx.f[13].f64;
	// 82AA25C0: ED6B5024  fdivs f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[10].f64) as f32) as f64;
	// 82AA25C4: ECC03024  fdivs f6, f0, f6
	ctx.f[6].f64 = ((ctx.f[0].f64 / ctx.f[6].f64) as f32) as f64;
	// 82AA25C8: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 82AA25CC: EFCB0072  fmuls f30, f11, f1
	ctx.f[30].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 82AA25D0: EC20F824  fdivs f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 82AA25D4: FC00F050  fneg f0, f30
	ctx.f[0].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82AA25D8: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AA25DC: 4BA100CD  bl 0x824b26a8
	ctx.lr = 0x82AA25E0;
	sub_824B26A8(ctx, base);
	// 82AA25E0: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82AA25E4: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 82AA25E8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA25EC: 4B7785A5  bl 0x8221ab90
	ctx.lr = 0x82AA25F0;
	sub_8221AB90(ctx, base);
	// 82AA25F0: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82AA25F4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA25F8: 4B7CE6D9  bl 0x82270cd0
	ctx.lr = 0x82AA25FC;
	sub_82270CD0(ctx, base);
	// 82AA25FC: 389E06B0  addi r4, r30, 0x6b0
	ctx.r[4].s64 = ctx.r[30].s64 + 1712;
	// 82AA2600: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA2604: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82AA2608: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82AA260C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82AA2610; continue 'dispatch;
            }
            0x82AA2610 => {
    //   block [0x82AA2610..0x82AA2658)
	// 82AA2610: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AA2614: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AA2618: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82AA261C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AA2620: 4200FFF0  bdnz 0x82aa2610
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AA2610; continue 'dispatch;
	}
	// 82AA2624: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA2628: 4B6FFE69  bl 0x821a2490
	ctx.lr = 0x82AA262C;
	sub_821A2490(ctx, base);
	// 82AA262C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA2630: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 82AA2634: 4B7EB9D5  bl 0x8228e008
	ctx.lr = 0x82AA2638;
	sub_8228E008(ctx, base);
	// 82AA2638: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82AA263C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA2640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA2644: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA2648: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AA264C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA2650: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA2654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA2658 size=360
    let mut pc: u32 = 0x82AA2658;
    'dispatch: loop {
        match pc {
            0x82AA2658 => {
    //   block [0x82AA2658..0x82AA27C0)
	// 82AA2658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA265C: 48206DB1  bl 0x82ca940c
	ctx.lr = 0x82AA2660;
	sub_82CA93D0(ctx, base);
	// 82AA2660: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2664: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AA2668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA266C: 480786AD  bl 0x82b1ad18
	ctx.lr = 0x82AA2670;
	sub_82B1AD18(ctx, base);
	// 82AA2670: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AA2674: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA2678: 394B7FC0  addi r10, r11, 0x7fc0
	ctx.r[10].s64 = ctx.r[11].s64 + 32704;
	// 82AA267C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA2680: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA2684: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82AA2688: 93DF00B0  stw r30, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 82AA268C: 387F01F4  addi r3, r31, 0x1f4
	ctx.r[3].s64 = ctx.r[31].s64 + 500;
	// 82AA2690: 93DF00B8  stw r30, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 82AA2694: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 82AA2698: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82AA269C: 93DF00C8  stw r30, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 82AA26A0: 93DF00CC  stw r30, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 82AA26A4: 93DF00D0  stw r30, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 82AA26A8: 93DF00D4  stw r30, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u32 ) };
	// 82AA26AC: 93DF00D8  stw r30, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 82AA26B0: 93DF00DC  stw r30, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[30].u32 ) };
	// 82AA26B4: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 82AA26B8: 93DF01B0  stw r30, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u32 ) };
	// 82AA26BC: 9BDF01B4  stb r30, 0x1b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[30].u8 ) };
	// 82AA26C0: 9BDF01B5  stb r30, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[30].u8 ) };
	// 82AA26C4: 93DF01B8  stw r30, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[30].u32 ) };
	// 82AA26C8: 93DF01BC  stw r30, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[30].u32 ) };
	// 82AA26CC: 93DF01C0  stw r30, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[30].u32 ) };
	// 82AA26D0: FBDF01C8  std r30, 0x1c8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[30].u64 ) };
	// 82AA26D4: 93DF01D0  stw r30, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[30].u32 ) };
	// 82AA26D8: 917F01D4  stw r11, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82AA26DC: 997F01D8  stb r11, 0x1d8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[11].u8 ) };
	// 82AA26E0: 997F01D9  stb r11, 0x1d9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(473 as u32), ctx.r[11].u8 ) };
	// 82AA26E4: 397F01C0  addi r11, r31, 0x1c0
	ctx.r[11].s64 = ctx.r[31].s64 + 448;
	// 82AA26E8: 93DF01E4  stw r30, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[30].u32 ) };
	// 82AA26EC: 93BF01E8  stw r29, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[29].u32 ) };
	// 82AA26F0: 93DF01EC  stw r30, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[30].u32 ) };
	// 82AA26F4: 93DF01F0  stw r30, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[30].u32 ) };
	// 82AA26F8: 4B87E491  bl 0x82320b88
	ctx.lr = 0x82AA26FC;
	sub_82320B88(ctx, base);
	// 82AA26FC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82AA2700: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82AA2704: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82AA2708: 38E992D8  addi r7, r9, -0x6d28
	ctx.r[7].s64 = ctx.r[9].s64 + -27944;
	// 82AA270C: 93BF0130  stw r29, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[29].u32 ) };
	// 82AA2710: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 82AA2714: FBDF0138  std r30, 0x138(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u64 ) };
	// 82AA2718: 3C808331  lis r4, -0x7ccf
	ctx.r[4].s64 = -2093940736;
	// 82AA271C: C18992D8  lfs f12, -0x6d28(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27944 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA2720: 3C608331  lis r3, -0x7ccf
	ctx.r[3].s64 = -2093940736;
	// 82AA2724: 3CA08209  lis r5, -0x7df7
	ctx.r[5].s64 = -2113339392;
	// 82AA2728: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA272C: C00701B8  lfs f0, 0x1b8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2730: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 82AA2734: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AA2738: 39600140  li r11, 0x140
	ctx.r[11].s64 = 320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA27C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA27C0 size=80
    let mut pc: u32 = 0x82AA27C0;
    'dispatch: loop {
        match pc {
            0x82AA27C0 => {
    //   block [0x82AA27C0..0x82AA27F8)
	// 82AA27C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA27C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA27C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA27CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA27D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA27D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA27D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA27DC: 48000035  bl 0x82aa2810
	ctx.lr = 0x82AA27E0;
	sub_82AA2810(ctx, base);
	// 82AA27E0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82AA27E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA27E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA27EC: 419A000C  beq cr6, 0x82aa27f8
	if ctx.cr[6].eq {
	pc = 0x82AA27F8; continue 'dispatch;
	}
	// 82AA27F0: 4B779549  bl 0x8221bd38
	ctx.lr = 0x82AA27F4;
	sub_8221BD38(ctx, base);
	// 82AA27F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82AA27F8; continue 'dispatch;
            }
            0x82AA27F8 => {
    //   block [0x82AA27F8..0x82AA2810)
	// 82AA27F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA27FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA2800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA2804: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA2808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA280C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA2810 size=484
    let mut pc: u32 = 0x82AA2810;
    'dispatch: loop {
        match pc {
            0x82AA2810 => {
    //   block [0x82AA2810..0x82AA286C)
	// 82AA2810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA2818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA281C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA2820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2828: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AA282C: 394B7FC0  addi r10, r11, 0x7fc0
	ctx.r[10].s64 = ctx.r[11].s64 + 32704;
	// 82AA2830: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA2834: 807F01BC  lwz r3, 0x1bc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 82AA2838: 4B779501  bl 0x8221bd38
	ctx.lr = 0x82AA283C;
	sub_8221BD38(ctx, base);
	// 82AA283C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA2840: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82AA2844: 93DF01BC  stw r30, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[30].u32 ) };
	// 82AA2848: 4B7794F1  bl 0x8221bd38
	ctx.lr = 0x82AA284C;
	sub_8221BD38(ctx, base);
	// 82AA284C: 93DF01B0  stw r30, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u32 ) };
	// 82AA2850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2854: 480014E5  bl 0x82aa3d38
	ctx.lr = 0x82AA2858;
	sub_82AA3D38(ctx, base);
	// 82AA2858: 807F01E4  lwz r3, 0x1e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82AA285C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA2860: 419A000C  beq cr6, 0x82aa286c
	if ctx.cr[6].eq {
	pc = 0x82AA286C; continue 'dispatch;
	}
	// 82AA2864: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2868: 4BFD1CB9  bl 0x82a74520
	ctx.lr = 0x82AA286C;
	sub_82A74520(ctx, base);
	pc = 0x82AA286C; continue 'dispatch;
            }
            0x82AA286C => {
    //   block [0x82AA286C..0x82AA28A8)
	// 82AA286C: 387F01F4  addi r3, r31, 0x1f4
	ctx.r[3].s64 = ctx.r[31].s64 + 500;
	// 82AA2870: 4BF72521  bl 0x82a14d90
	ctx.lr = 0x82AA2874;
	sub_82A14D90(ctx, base);
	// 82AA2874: 807F01F8  lwz r3, 0x1f8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(504 as u32) ) } as u64;
	// 82AA2878: 4B7794C1  bl 0x8221bd38
	ctx.lr = 0x82AA287C;
	sub_8221BD38(ctx, base);
	// 82AA287C: 93DF01F8  stw r30, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[30].u32 ) };
	// 82AA2880: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82AA2884: 4B78F435  bl 0x82231cb8
	ctx.lr = 0x82AA2888;
	sub_82231CB8(ctx, base);
	// 82AA2888: 387F01EC  addi r3, r31, 0x1ec
	ctx.r[3].s64 = ctx.r[31].s64 + 492;
	// 82AA288C: 4B78F42D  bl 0x82231cb8
	ctx.lr = 0x82AA2890;
	sub_82231CB8(ctx, base);
	// 82AA2890: 387F01C0  addi r3, r31, 0x1c0
	ctx.r[3].s64 = ctx.r[31].s64 + 448;
	// 82AA2894: 4807B7BD  bl 0x82b1e050
	ctx.lr = 0x82AA2898;
	sub_82B1E050(ctx, base);
	// 82AA2898: 807F00E0  lwz r3, 0xe0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82AA289C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA28A0: 419A0040  beq cr6, 0x82aa28e0
	if ctx.cr[6].eq {
	pc = 0x82AA28E0; continue 'dispatch;
	}
	// 82AA28A4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AA28A8; continue 'dispatch;
            }
            0x82AA28A8 => {
    //   block [0x82AA28A8..0x82AA28DC)
	// 82AA28A8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AA28AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA28B0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AA28B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA28B8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA28BC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA28C0: 4082FFE8  bne 0x82aa28a8
	if !ctx.cr[0].eq {
	pc = 0x82AA28A8; continue 'dispatch;
	}
	// 82AA28C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA28C8: 409A0014  bne cr6, 0x82aa28dc
	if !ctx.cr[6].eq {
	pc = 0x82AA28DC; continue 'dispatch;
	}
	// 82AA28CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA28D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA28D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA28D8: 4E800421  bctrl
	ctx.lr = 0x82AA28DC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA28DC => {
    //   block [0x82AA28DC..0x82AA28E0)
	// 82AA28DC: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	pc = 0x82AA28E0; continue 'dispatch;
            }
            0x82AA28E0 => {
    //   block [0x82AA28E0..0x82AA28F0)
	// 82AA28E0: 807F00DC  lwz r3, 0xdc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 82AA28E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA28E8: 419A0040  beq cr6, 0x82aa2928
	if ctx.cr[6].eq {
	pc = 0x82AA2928; continue 'dispatch;
	}
	// 82AA28EC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AA28F0; continue 'dispatch;
            }
            0x82AA28F0 => {
    //   block [0x82AA28F0..0x82AA2924)
	// 82AA28F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AA28F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA28F8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AA28FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA2900: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2904: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2908: 4082FFE8  bne 0x82aa28f0
	if !ctx.cr[0].eq {
	pc = 0x82AA28F0; continue 'dispatch;
	}
	// 82AA290C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA2910: 409A0014  bne cr6, 0x82aa2924
	if !ctx.cr[6].eq {
	pc = 0x82AA2924; continue 'dispatch;
	}
	// 82AA2914: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2918: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA291C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA2920: 4E800421  bctrl
	ctx.lr = 0x82AA2924;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA2924 => {
    //   block [0x82AA2924..0x82AA2928)
	// 82AA2924: 93DF00DC  stw r30, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[30].u32 ) };
	pc = 0x82AA2928; continue 'dispatch;
            }
            0x82AA2928 => {
    //   block [0x82AA2928..0x82AA2938)
	// 82AA2928: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82AA292C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA2930: 419A0040  beq cr6, 0x82aa2970
	if ctx.cr[6].eq {
	pc = 0x82AA2970; continue 'dispatch;
	}
	// 82AA2934: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AA2938; continue 'dispatch;
            }
            0x82AA2938 => {
    //   block [0x82AA2938..0x82AA296C)
	// 82AA2938: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AA293C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2940: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AA2944: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA2948: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA294C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2950: 4082FFE8  bne 0x82aa2938
	if !ctx.cr[0].eq {
	pc = 0x82AA2938; continue 'dispatch;
	}
	// 82AA2954: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA2958: 409A0014  bne cr6, 0x82aa296c
	if !ctx.cr[6].eq {
	pc = 0x82AA296C; continue 'dispatch;
	}
	// 82AA295C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2960: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2964: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA2968: 4E800421  bctrl
	ctx.lr = 0x82AA296C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA296C => {
    //   block [0x82AA296C..0x82AA2970)
	// 82AA296C: 93DF00D8  stw r30, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	pc = 0x82AA2970; continue 'dispatch;
            }
            0x82AA2970 => {
    //   block [0x82AA2970..0x82AA2980)
	// 82AA2970: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA2974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA2978: 419A0040  beq cr6, 0x82aa29b8
	if ctx.cr[6].eq {
	pc = 0x82AA29B8; continue 'dispatch;
	}
	// 82AA297C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AA2980; continue 'dispatch;
            }
            0x82AA2980 => {
    //   block [0x82AA2980..0x82AA29B4)
	// 82AA2980: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AA2984: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2988: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AA298C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA2990: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2994: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2998: 4082FFE8  bne 0x82aa2980
	if !ctx.cr[0].eq {
	pc = 0x82AA2980; continue 'dispatch;
	}
	// 82AA299C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA29A0: 409A0014  bne cr6, 0x82aa29b4
	if !ctx.cr[6].eq {
	pc = 0x82AA29B4; continue 'dispatch;
	}
	// 82AA29A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA29A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA29AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA29B0: 4E800421  bctrl
	ctx.lr = 0x82AA29B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA29B4 => {
    //   block [0x82AA29B4..0x82AA29B8)
	// 82AA29B4: 93DF00D4  stw r30, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u32 ) };
	pc = 0x82AA29B8; continue 'dispatch;
            }
            0x82AA29B8 => {
    //   block [0x82AA29B8..0x82AA29F4)
	// 82AA29B8: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 82AA29BC: 480016CD  bl 0x82aa4088
	ctx.lr = 0x82AA29C0;
	sub_82AA4088(ctx, base);
	// 82AA29C0: 387F00B4  addi r3, r31, 0xb4
	ctx.r[3].s64 = ctx.r[31].s64 + 180;
	// 82AA29C4: 48001665  bl 0x82aa4028
	ctx.lr = 0x82AA29C8;
	sub_82AA4028(ctx, base);
	// 82AA29C8: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AA29CC: 4B77936D  bl 0x8221bd38
	ctx.lr = 0x82AA29D0;
	sub_8221BD38(ctx, base);
	// 82AA29D0: 93DF00B0  stw r30, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 82AA29D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA29D8: 480784F1  bl 0x82b1aec8
	ctx.lr = 0x82AA29DC;
	sub_82B1AEC8(ctx, base);
	// 82AA29DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA29E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA29E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA29E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA29EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA29F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA29F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA29F8 size=112
    let mut pc: u32 = 0x82AA29F8;
    'dispatch: loop {
        match pc {
            0x82AA29F8 => {
    //   block [0x82AA29F8..0x82AA2A20)
	// 82AA29F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA29FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA2A00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA2A04: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2A08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2A0C: 814400D4  lwz r10, 0xd4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA2A10: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AA2A14: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82AA2A18: 38CB7088  addi r6, r11, 0x7088
	ctx.r[6].s64 = ctx.r[11].s64 + 28808;
	// 82AA2A1C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x82AA2A20; continue 'dispatch;
            }
            0x82AA2A20 => {
    //   block [0x82AA2A20..0x82AA2A68)
	// 82AA2A20: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AA2A24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2A28: 7D203028  lwarx r9, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AA2A2C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AA2A30: 7D20312D  stwcx. r9, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2A34: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2A38: 4082FFE8  bne 0x82aa2a20
	if !ctx.cr[0].eq {
	pc = 0x82AA2A20; continue 'dispatch;
	}
	// 82AA2A3C: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 82AA2A40: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA2A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2A48: 38842B88  addi r4, r4, 0x2b88
	ctx.r[4].s64 = ctx.r[4].s64 + 11144;
	// 82AA2A4C: 4B741405  bl 0x821e3e50
	ctx.lr = 0x82AA2A50;
	sub_821E3E50(ctx, base);
	// 82AA2A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2A54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA2A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA2A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA2A60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA2A64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA2A68 size=200
    let mut pc: u32 = 0x82AA2A68;
    'dispatch: loop {
        match pc {
            0x82AA2A68 => {
    //   block [0x82AA2A68..0x82AA2AD0)
	// 82AA2A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2A6C: 482069A1  bl 0x82ca940c
	ctx.lr = 0x82AA2A70;
	sub_82CA93D0(ctx, base);
	// 82AA2A70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2A78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA2A7C: 389E003C  addi r4, r30, 0x3c
	ctx.r[4].s64 = ctx.r[30].s64 + 60;
	// 82AA2A80: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA2A84: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2A88: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2A8C: 514B083C  rlwimi r11, r10, 1, 0, 0x1e
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[11].u64 & 0xFFFFFFFF00000001);
	// 82AA2A90: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA2A94: 81090060  lwz r8, 0x60(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA2A98: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82AA2A9C: 4E800421  bctrl
	ctx.lr = 0x82AA2AA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2AA0: 38E000FE  li r7, 0xfe
	ctx.r[7].s64 = 254;
	// 82AA2AA4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AA2AA8: 98FF00E4  stb r7, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[7].u8 ) };
	// 82AA2AAC: 80BE0064  lwz r5, 0x64(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA2AB0: 90BF01D4  stw r5, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[5].u32 ) };
	// 82AA2AB4: 98DF01D8  stb r6, 0x1d8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[6].u8 ) };
	// 82AA2AB8: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA2ABC: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2AC0: 888B0081  lbz r4, 0x81(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82AA2AC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AA2AC8: 419A0008  beq cr6, 0x82aa2ad0
	if ctx.cr[6].eq {
	pc = 0x82AA2AD0; continue 'dispatch;
	}
	// 82AA2ACC: 63BD0600  ori r29, r29, 0x600
	ctx.r[29].u64 = ctx.r[29].u64 | 1536;
            }
            0x82AA2AD0 => {
    //   block [0x82AA2AD0..0x82AA2B30)
	// 82AA2AD0: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AA2AD4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82AA2AD8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82AA2ADC: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82AA2AE0: 614A0010  ori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 16;
	// 82AA2AE4: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA2B30 size=272
    let mut pc: u32 = 0x82AA2B30;
    'dispatch: loop {
        match pc {
            0x82AA2B30 => {
    //   block [0x82AA2B30..0x82AA2BC0)
	// 82AA2B30: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2B34: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA2B38: D0030124  stfs f0, 0x124(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82AA2B3C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82AA2B40: C1A40024  lfs f13, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2B44: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82AA2B48: D1A3012C  stfs f13, 0x12c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82AA2B4C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AA2B50: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AA2B54: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82AA2B58: C00B9A80  lfs f0, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2B5C: 39099490  addi r8, r9, -0x6b70
	ctx.r[8].s64 = ctx.r[9].s64 + -27504;
	// 82AA2B60: ED0A0028  fsubs f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82AA2B64: C1699490  lfs f11, -0x6b70(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AA2B68: ED2C5028  fsubs f9, f12, f10
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82AA2B6C: D123011C  stfs f9, 0x11c(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82AA2B70: 394A0E68  addi r10, r10, 0xe68
	ctx.r[10].s64 = ctx.r[10].s64 + 3688;
	// 82AA2B74: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2B78: C008FFF4  lfs f0, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2B7C: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82AA2B80: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 82AA2B84: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 82AA2B88: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 82AA2B8C: 7CC92B78  or r9, r6, r5
	ctx.r[9].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82AA2B90: 7CEA4C2E  lfsx f7, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82AA2B94: FCC76AAE  fsel f6, f7, f10, f13
	ctx.f[6].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[13].f64 };
	// 82AA2B98: ECAB3024  fdivs f5, f11, f6
	ctx.f[5].f64 = ((ctx.f[11].f64 / ctx.f[6].f64) as f32) as f64;
	// 82AA2B9C: D0A30120  stfs f5, 0x120(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82AA2BA0: C1A40014  lfs f13, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2BA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA2BA8: 41990018  bgt cr6, 0x82aa2bc0
	if ctx.cr[6].gt {
	pc = 0x82AA2BC0; continue 'dispatch;
	}
	// 82AA2BAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA2BB0: D0030118  stfs f0, 0x118(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82AA2BB4: C1AB0C1C  lfs f13, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2BB8: D1A30114  stfs f13, 0x114(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82AA2BBC: 4800003C  b 0x82aa2bf8
	pc = 0x82AA2BF8; continue 'dispatch;
            }
            0x82AA2BC0 => {
    //   block [0x82AA2BC0..0x82AA2BF8)
	// 82AA2BC0: D1A30114  stfs f13, 0x114(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82AA2BC4: C1440018  lfs f10, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AA2BC8: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AA2BCC: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2BD0: ED096828  fsubs f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AA2BD4: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82AA2BD8: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 82AA2BDC: 5569DF7A  rlwinm r9, r11, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AA2BE0: 5568F77A  rlwinm r8, r11, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82AA2BE4: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82AA2BE8: 7CEA3C2E  lfsx f7, r10, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82AA2BEC: FCC76A6E  fsel f6, f7, f9, f13
	ctx.f[6].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[9].f64 } else { ctx.f[13].f64 };
	// 82AA2BF0: ECAB3024  fdivs f5, f11, f6
	ctx.f[5].f64 = ((ctx.f[11].f64 / ctx.f[6].f64) as f32) as f64;
	// 82AA2BF4: D0A30118  stfs f5, 0x118(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), tmp.u32 ) };
	pc = 0x82AA2BF8; continue 'dispatch;
            }
            0x82AA2BF8 => {
    //   block [0x82AA2BF8..0x82AA2C40)
	// 82AA2BF8: 816301E4  lwz r11, 0x1e4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(484 as u32) ) } as u64;
	// 82AA2BFC: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2C00: D1A30128  stfs f13, 0x128(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82AA2C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2C08: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AA2C0C: C1AB0100  lfs f13, 0x100(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2C10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA2C14: ED6D6028  fsubs f11, f13, f12
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82AA2C18: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82AA2C1C: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 82AA2C20: 5507DF7A  rlwinm r7, r8, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82AA2C24: 5506F77A  rlwinm r6, r8, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 82AA2C28: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 82AA2C2C: 7D4A2C2E  lfsx f10, r10, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AA2C30: FD2A636E  fsel f9, f10, f13, f12
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[12].f64 };
	// 82AA2C34: D12B0100  stfs f9, 0x100(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82AA2C38: 992B0104  stb r9, 0x104(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), ctx.r[9].u8 ) };
	// 82AA2C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA2C40 size=756
    let mut pc: u32 = 0x82AA2C40;
    'dispatch: loop {
        match pc {
            0x82AA2C40 => {
    //   block [0x82AA2C40..0x82AA2F34)
	// 82AA2C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2C44: 48206791  bl 0x82ca93d4
	ctx.lr = 0x82AA2C48;
	sub_82CA93D0(ctx, base);
	// 82AA2C48: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82AA2C4C: 4820B089  bl 0x82cadcd4
	ctx.lr = 0x82AA2C50;
	sub_82CADCA0(ctx, base);
	// 82AA2C50: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2C54: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82AA2C58: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82AA2C5C: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 82AA2C60: 39780070  addi r11, r24, 0x70
	ctx.r[11].s64 = ctx.r[24].s64 + 112;
	// 82AA2C64: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82AA2C68: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2C6C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AA2C70: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82AA2C74: 811800CC  lwz r8, 0xcc(r24)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA2C78: 80D800C8  lwz r6, 0xc8(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(200 as u32) ) } as u64;
	// 82AA2C7C: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA2F38 size=328
    let mut pc: u32 = 0x82AA2F38;
    'dispatch: loop {
        match pc {
            0x82AA2F38 => {
    //   block [0x82AA2F38..0x82AA3080)
	// 82AA2F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2F3C: 482064CD  bl 0x82ca9408
	ctx.lr = 0x82AA2F40;
	sub_82CA93D0(ctx, base);
	// 82AA2F40: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AA2F44: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2F48: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AA2F4C: 1020038C  vspltisw v1, 0
	for i in 0..4 {
		ctx.v[1].u32[i] = 0;
	}
	// 82AA2F50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA2F54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA2F58: C3FC0030  lfs f31, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA2F5C: E89C0010  ld r4, 0x10(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	// 82AA2F60: E8BC0018  ld r5, 0x18(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	// 82AA2F64: 4B76998D  bl 0x8220c8f0
	ctx.lr = 0x82AA2F68;
	sub_8220C8F0(ctx, base);
	// 82AA2F68: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA2F6C: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AA2F70: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82AA2F74: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82AA2F78: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82AA2F7C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82AA2F80: 38E99490  addi r7, r9, -0x6b70
	ctx.r[7].s64 = ctx.r[9].s64 + -27504;
	// 82AA2F84: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3080 size=144
    let mut pc: u32 = 0x82AA3080;
    'dispatch: loop {
        match pc {
            0x82AA3080 => {
    //   block [0x82AA3080..0x82AA30AC)
	// 82AA3080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3084: 48206389  bl 0x82ca940c
	ctx.lr = 0x82AA3088;
	sub_82CA93D0(ctx, base);
	// 82AA3088: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA308C: 83A300E0  lwz r29, 0xe0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 82AA3090: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AA3094: 419A0074  beq cr6, 0x82aa3108
	if ctx.cr[6].eq {
	pc = 0x82AA3108; continue 'dispatch;
	}
	// 82AA3098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA309C: 3BFD002C  addi r31, r29, 0x2c
	ctx.r[31].s64 = ctx.r[29].s64 + 44;
	// 82AA30A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA30A4: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82AA30A8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82AA30AC; continue 'dispatch;
            }
            0x82AA30AC => {
    //   block [0x82AA30AC..0x82AA3104)
	// 82AA30AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA30B0: 389FFFFC  addi r4, r31, -4
	ctx.r[4].s64 = ctx.r[31].s64 + -4;
	// 82AA30B4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA30B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA30BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA30C0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA30C4: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA30C8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA30CC: 48080895  bl 0x82b23960
	ctx.lr = 0x82AA30D0;
	sub_82B23960(ctx, base);
	// 82AA30D0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AA30D4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA30D8: 4082FFD4  bne 0x82aa30ac
	if !ctx.cr[0].eq {
	pc = 0x82AA30AC; continue 'dispatch;
	}
	// 82AA30DC: 807D001C  lwz r3, 0x1c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA30E0: 3BDD0018  addi r30, r29, 0x18
	ctx.r[30].s64 = ctx.r[29].s64 + 24;
	// 82AA30E4: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AA30E8: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA30EC: 419A001C  beq cr6, 0x82aa3108
	if ctx.cr[6].eq {
	pc = 0x82AA3108; continue 'dispatch;
	}
	// 82AA30F0: 7CC52851  subf. r6, r5, r5
	ctx.r[6].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82AA30F4: 7FE61A14  add r31, r6, r3
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82AA30F8: 4081000C  ble 0x82aa3104
	if !ctx.cr[0].gt {
	pc = 0x82AA3104; continue 'dispatch;
	}
	// 82AA30FC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82AA3100: 48206F29  bl 0x82caa028
	ctx.lr = 0x82AA3104;
	sub_82CAA028(ctx, base);
	pc = 0x82AA3104; continue 'dispatch;
            }
            0x82AA3104 => {
    //   block [0x82AA3104..0x82AA3108)
	// 82AA3104: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82AA3108; continue 'dispatch;
            }
            0x82AA3108 => {
    //   block [0x82AA3108..0x82AA3110)
	// 82AA3108: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA310C: 48206350  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3110 size=96
    let mut pc: u32 = 0x82AA3110;
    'dispatch: loop {
        match pc {
            0x82AA3110 => {
    //   block [0x82AA3110..0x82AA3170)
	// 82AA3110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3118: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA311C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3124: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA3128: 389F00C4  addi r4, r31, 0xc4
	ctx.r[4].s64 = ctx.r[31].s64 + 196;
	// 82AA312C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA3130: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA3134: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA3138: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82AA313C: 815F00CC  lwz r10, 0xcc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA3140: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82AA3144: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA3148: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA314C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA3150: 48000F99  bl 0x82aa40e8
	ctx.lr = 0x82AA3154;
	sub_82AA40E8(ctx, base);
	// 82AA3154: 387F01EC  addi r3, r31, 0x1ec
	ctx.r[3].s64 = ctx.r[31].s64 + 492;
	// 82AA3158: 4BFCDB49  bl 0x82a70ca0
	ctx.lr = 0x82AA315C;
	sub_82A70CA0(ctx, base);
	// 82AA315C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3168: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA316C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3170 size=96
    let mut pc: u32 = 0x82AA3170;
    'dispatch: loop {
        match pc {
            0x82AA3170 => {
    //   block [0x82AA3170..0x82AA31D0)
	// 82AA3170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3178: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA317C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3180: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA3188: 389F00B4  addi r4, r31, 0xb4
	ctx.r[4].s64 = ctx.r[31].s64 + 180;
	// 82AA318C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA3190: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA3194: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA3198: 813F00B8  lwz r9, 0xb8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82AA319C: 815F00BC  lwz r10, 0xbc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AA31A0: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82AA31A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA31A8: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA31AC: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA31B0: 4BFCE499  bl 0x82a71648
	ctx.lr = 0x82AA31B4;
	sub_82A71648(ctx, base);
	// 82AA31B4: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82AA31B8: 4BFCDAE9  bl 0x82a70ca0
	ctx.lr = 0x82AA31BC;
	sub_82A70CA0(ctx, base);
	// 82AA31BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA31C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA31C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA31C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA31CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA31D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA31D0 size=48
    let mut pc: u32 = 0x82AA31D0;
    'dispatch: loop {
        match pc {
            0x82AA31D0 => {
    //   block [0x82AA31D0..0x82AA3200)
	// 82AA31D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA31D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA31D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA31DC: 396301C0  addi r11, r3, 0x1c0
	ctx.r[11].s64 = ctx.r[3].s64 + 448;
	// 82AA31E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA31E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA31E8: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82AA31EC: 4B738B15  bl 0x821dbd00
	ctx.lr = 0x82AA31F0;
	sub_821DBD00(ctx, base);
	// 82AA31F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA31F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA31F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA31FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA3200 size=8
    let mut pc: u32 = 0x82AA3200;
    'dispatch: loop {
        match pc {
            0x82AA3200 => {
    //   block [0x82AA3200..0x82AA3208)
	// 82AA3200: 386301C0  addi r3, r3, 0x1c0
	ctx.r[3].s64 = ctx.r[3].s64 + 448;
	// 82AA3204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA3208 size=168
    let mut pc: u32 = 0x82AA3208;
    'dispatch: loop {
        match pc {
            0x82AA3208 => {
    //   block [0x82AA3208..0x82AA32B0)
	// 82AA3208: 39200150  li r9, 0x150
	ctx.r[9].s64 = 336;
	// 82AA320C: E9030050  ld r8, 0x50(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	// 82AA3210: 814300D4  lwz r10, 0xd4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA3214: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 82AA3218: 39630180  addi r11, r3, 0x180
	ctx.r[11].s64 = ctx.r[3].s64 + 384;
	// 82AA321C: 38CA0030  addi r6, r10, 0x30
	ctx.r[6].s64 = ctx.r[10].s64 + 48;
	// 82AA3220: 39440040  addi r10, r4, 0x40
	ctx.r[10].s64 = ctx.r[4].s64 + 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA32B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA32B0 size=52
    let mut pc: u32 = 0x82AA32B0;
    'dispatch: loop {
        match pc {
            0x82AA32B0 => {
    //   block [0x82AA32B0..0x82AA32E4)
	// 82AA32B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA32B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA32B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA32BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA32C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA32C4: 4BFFFEAD  bl 0x82aa3170
	ctx.lr = 0x82AA32C8;
	sub_82AA3170(ctx, base);
	// 82AA32C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA32CC: 48000A6D  bl 0x82aa3d38
	ctx.lr = 0x82AA32D0;
	sub_82AA3D38(ctx, base);
	// 82AA32D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA32D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA32D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA32DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA32E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA32E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA32E8 size=4
    let mut pc: u32 = 0x82AA32E8;
    'dispatch: loop {
        match pc {
            0x82AA32E8 => {
    //   block [0x82AA32E8..0x82AA32EC)
	// 82AA32E8: 4BFFFE28  b 0x82aa3110
	sub_82AA3110(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA32F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA32F0 size=116
    let mut pc: u32 = 0x82AA32F0;
    'dispatch: loop {
        match pc {
            0x82AA32F0 => {
    //   block [0x82AA32F0..0x82AA3328)
	// 82AA32F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA32F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA32F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA32FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3300: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3308: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA330C: 817F01E4  lwz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82AA3310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3314: 409A0014  bne cr6, 0x82aa3328
	if !ctx.cr[6].eq {
	pc = 0x82AA3328; continue 'dispatch;
	}
	// 82AA3318: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA331C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3320: 4BFB0F31  bl 0x82a54250
	ctx.lr = 0x82AA3324;
	sub_82A54250(ctx, base);
	// 82AA3324: 48000028  b 0x82aa334c
	pc = 0x82AA334C; continue 'dispatch;
            }
            0x82AA3328 => {
    //   block [0x82AA3328..0x82AA334C)
	// 82AA3328: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA332C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA3330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3334: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AA3338: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA333C: 4E800421  bctrl
	ctx.lr = 0x82AA3340;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA3340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA3344: 387E0D54  addi r3, r30, 0xd54
	ctx.r[3].s64 = ctx.r[30].s64 + 3412;
	// 82AA3348: 4BFE8651  bl 0x82a8b998
	ctx.lr = 0x82AA334C;
	sub_82A8B998(ctx, base);
            }
            0x82AA334C => {
    //   block [0x82AA334C..0x82AA3364)
	// 82AA334C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3350: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3354: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3358: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA335C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA3368 size=424
    let mut pc: u32 = 0x82AA3368;
    'dispatch: loop {
        match pc {
            0x82AA3368 => {
    //   block [0x82AA3368..0x82AA33A8)
	// 82AA3368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA336C: 4820609D  bl 0x82ca9408
	ctx.lr = 0x82AA3370;
	sub_82CA93D0(ctx, base);
	// 82AA3370: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3378: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82AA337C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA3380: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA3384: 817F01E4  lwz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82AA3388: 994916DD  stb r10, 0x16dd(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(5853 as u32), ctx.r[10].u8 ) };
	// 82AA338C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3390: 419A0018  beq cr6, 0x82aa33a8
	if ctx.cr[6].eq {
	pc = 0x82AA33A8; continue 'dispatch;
	}
	// 82AA3394: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA3398: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA339C: 419A016C  beq cr6, 0x82aa3508
	if ctx.cr[6].eq {
	pc = 0x82AA3508; continue 'dispatch;
	}
	// 82AA33A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA33A4: 409A000C  bne cr6, 0x82aa33b0
	if !ctx.cr[6].eq {
	pc = 0x82AA33B0; continue 'dispatch;
	}
	pc = 0x82AA33A8; continue 'dispatch;
            }
            0x82AA33A8 => {
    //   block [0x82AA33A8..0x82AA33B0)
	// 82AA33A8: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82AA33AC: 419A015C  beq cr6, 0x82aa3508
	if ctx.cr[6].eq {
	pc = 0x82AA3508; continue 'dispatch;
	}
	pc = 0x82AA33B0; continue 'dispatch;
            }
            0x82AA33B0 => {
    //   block [0x82AA33B0..0x82AA33D0)
	// 82AA33B0: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA33B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AA33B8: 419A0018  beq cr6, 0x82aa33d0
	if ctx.cr[6].eq {
	pc = 0x82AA33D0; continue 'dispatch;
	}
	// 82AA33BC: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 82AA33C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA33C4: 4B821C85  bl 0x822c5048
	ctx.lr = 0x82AA33C8;
	sub_822C5048(ctx, base);
	// 82AA33C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA33CC: 4801A5CD  bl 0x82abd998
	ctx.lr = 0x82AA33D0;
	sub_82ABD998(ctx, base);
	pc = 0x82AA33D0; continue 'dispatch;
            }
            0x82AA33D0 => {
    //   block [0x82AA33D0..0x82AA33EC)
	// 82AA33D0: 807F01E4  lwz r3, 0x1e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82AA33D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA33D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA33DC: 419A0010  beq cr6, 0x82aa33ec
	if ctx.cr[6].eq {
	pc = 0x82AA33EC; continue 'dispatch;
	}
	// 82AA33E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA33E4: 4BFD113D  bl 0x82a74520
	ctx.lr = 0x82AA33E8;
	sub_82A74520(ctx, base);
	// 82AA33E8: 93DF01E4  stw r30, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[30].u32 ) };
	pc = 0x82AA33EC; continue 'dispatch;
            }
            0x82AA33EC => {
    //   block [0x82AA33EC..0x82AA3430)
	// 82AA33EC: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82AA33F0: 419A00F0  beq cr6, 0x82aa34e0
	if ctx.cr[6].eq {
	pc = 0x82AA34E0; continue 'dispatch;
	}
	// 82AA33F4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AA33F8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AA33FC: 396BF7A8  addi r11, r11, -0x858
	ctx.r[11].s64 = ctx.r[11].s64 + -2136;
	// 82AA3400: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3404: 4198002C  blt cr6, 0x82aa3430
	if ctx.cr[6].lt {
	pc = 0x82AA3430; continue 'dispatch;
	}
	// 82AA3408: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA340C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA3410: 7D691670  srawi r9, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82AA3414: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA3418: 40980018  bge cr6, 0x82aa3430
	if !ctx.cr[6].lt {
	pc = 0x82AA3430; continue 'dispatch;
	}
	// 82AA341C: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA3420: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA3424: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3428: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA342C: 409A0008  bne cr6, 0x82aa3434
	if !ctx.cr[6].eq {
	pc = 0x82AA3434; continue 'dispatch;
	}
	pc = 0x82AA3430; continue 'dispatch;
            }
            0x82AA3430 => {
    //   block [0x82AA3430..0x82AA3434)
	// 82AA3430: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82AA3434; continue 'dispatch;
            }
            0x82AA3434 => {
    //   block [0x82AA3434..0x82AA34E0)
	// 82AA3434: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA3438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA343C: 419A00A4  beq cr6, 0x82aa34e0
	if ctx.cr[6].eq {
	pc = 0x82AA34E0; continue 'dispatch;
	}
	// 82AA3440: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA3444: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA3448: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA344C: 2F0A0022  cmpwi cr6, r10, 0x22
	ctx.cr[6].compare_i32(ctx.r[10].s32, 34, &mut ctx.xer);
	// 82AA3450: 409A0090  bne cr6, 0x82aa34e0
	if !ctx.cr[6].eq {
	pc = 0x82AA34E0; continue 'dispatch;
	}
	// 82AA3454: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3458: 419A0088  beq cr6, 0x82aa34e0
	if ctx.cr[6].eq {
	pc = 0x82AA34E0; continue 'dispatch;
	}
	// 82AA345C: 907F01E4  stw r3, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[3].u32 ) };
	// 82AA3460: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA3464: 4BFD0F2D  bl 0x82a74390
	ctx.lr = 0x82AA3468;
	sub_82A74390(ctx, base);
	// 82AA3468: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA346C: 811F01E4  lwz r8, 0x1e4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82AA3470: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AA3474: 80FF01E8  lwz r7, 0x1e8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82AA3478: 392A0E68  addi r9, r10, 0xe68
	ctx.r[9].s64 = ctx.r[10].s64 + 3688;
	// 82AA347C: E8DF0050  ld r6, 0x50(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	// 82AA3480: 54EA2834  slwi r10, r7, 5
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA3484: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA3488: 816800C4  lwz r11, 0xc4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(196 as u32) ) } as u64;
	// 82AA348C: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA3490: 7CCA592A  stdx r6, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u64) };
	// 82AA3494: E89F0058  ld r4, 0x58(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	// 82AA3498: F8850008  std r4, 8(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[4].u64 ) };
	// 82AA349C: E87F0060  ld r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	// 82AA34A0: F8650010  std r3, 0x10(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 82AA34A4: E97F0068  ld r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	// 82AA34A8: F9650018  std r11, 0x18(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 82AA34AC: C1BF0124  lfs f13, 0x124(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA34B0: 815F01E4  lwz r10, 0x1e4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82AA34B4: C18A0100  lfs f12, 0x100(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA34B8: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AA34BC: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82AA34C0: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 82AA34C4: 5507DF7A  rlwinm r7, r8, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82AA34C8: 5506F77A  rlwinm r6, r8, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 82AA34CC: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 82AA34D0: 7D492C2E  lfsx f10, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AA34D4: FD2A6B2E  fsel f9, f10, f12, f13
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[13].f64 };
	// 82AA34D8: D12A0100  stfs f9, 0x100(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82AA34DC: 9BCA0104  stb r30, 0x104(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(260 as u32), ctx.r[30].u8 ) };
	pc = 0x82AA34E0; continue 'dispatch;
            }
            0x82AA34E0 => {
    //   block [0x82AA34E0..0x82AA3500)
	// 82AA34E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AA34E4: 419A001C  beq cr6, 0x82aa3500
	if ctx.cr[6].eq {
	pc = 0x82AA3500; continue 'dispatch;
	}
	// 82AA34E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA34EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA34F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA34F4: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AA34F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AA34FC: 4E800421  bctrl
	ctx.lr = 0x82AA3500;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA3500 => {
    //   block [0x82AA3500..0x82AA3508)
	// 82AA3500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3504: 4B7862DD  bl 0x822297e0
	ctx.lr = 0x82AA3508;
	sub_822297E0(ctx, base);
	pc = 0x82AA3508; continue 'dispatch;
            }
            0x82AA3508 => {
    //   block [0x82AA3508..0x82AA3510)
	// 82AA3508: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA350C: 48205F4C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3510 size=1896
    let mut pc: u32 = 0x82AA3510;
    'dispatch: loop {
        match pc {
            0x82AA3510 => {
    //   block [0x82AA3510..0x82AA35A0)
	// 82AA3510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3514: 48205EF5  bl 0x82ca9408
	ctx.lr = 0x82AA3518;
	sub_82CA93D0(ctx, base);
	// 82AA3518: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA351C: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82AA3520: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 82AA3524: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 82AA3528: 3BCA2390  addi r30, r10, 0x2390
	ctx.r[30].s64 = ctx.r[10].s64 + 9104;
	// 82AA352C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82AA3530: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82AA3534: 3B8A0DB8  addi r28, r10, 0xdb8
	ctx.r[28].s64 = ctx.r[10].s64 + 3512;
	// 82AA3538: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 82AA353C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA3540: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA3544: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA3548: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA354C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA3550: 419A0088  beq cr6, 0x82aa35d8
	if ctx.cr[6].eq {
	pc = 0x82AA35D8; continue 'dispatch;
	}
	// 82AA3554: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3558: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AA355C: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82AA3560: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA3564: 409A003C  bne cr6, 0x82aa35a0
	if !ctx.cr[6].eq {
	pc = 0x82AA35A0; continue 'dispatch;
	}
	// 82AA3568: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA356C: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82AA3570: 38FF0018  addi r7, r31, 0x18
	ctx.r[7].s64 = ctx.r[31].s64 + 24;
	// 82AA3574: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82AA3578: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82AA357C: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AA3580: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA3584: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3588: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA358C: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA3590: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3594: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3598: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 82AA359C: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x82AA35A0; continue 'dispatch;
            }
            0x82AA35A0 => {
    //   block [0x82AA35A0..0x82AA35D8)
	// 82AA35A0: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AA35A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA35A8: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82AA35AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA35B0: 409A0028  bne cr6, 0x82aa35d8
	if !ctx.cr[6].eq {
	pc = 0x82AA35D8; continue 'dispatch;
	}
	// 82AA35B4: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82AA35B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA35BC: 393F0018  addi r9, r31, 0x18
	ctx.r[9].s64 = ctx.r[31].s64 + 24;
	// 82AA35C0: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA35C4: 995F002C  stb r10, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82AA35C8: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 82AA35CC: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA35D0: 7D28E12E  stwx r9, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 82AA35D4: 48000008  b 0x82aa35dc
	pc = 0x82AA35DC; continue 'dispatch;
            }
            0x82AA35D8 => {
    //   block [0x82AA35D8..0x82AA35DC)
	// 82AA35D8: 80DD0DB0  lwz r6, 0xdb0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82AA35DC; continue 'dispatch;
            }
            0x82AA35DC => {
    //   block [0x82AA35DC..0x82AA3644)
	// 82AA35DC: 897F005D  lbz r11, 0x5d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(93 as u32) ) } as u64;
	// 82AA35E0: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82AA35E4: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA35E8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA35EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA35F0: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA35F4: 419A0080  beq cr6, 0x82aa3674
	if ctx.cr[6].eq {
	pc = 0x82AA3674; continue 'dispatch;
	}
	// 82AA35F8: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA35FC: 813F0050  lwz r9, 0x50(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA3600: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82AA3604: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA3608: 409A003C  bne cr6, 0x82aa3644
	if !ctx.cr[6].eq {
	pc = 0x82AA3644; continue 'dispatch;
	}
	// 82AA360C: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3610: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82AA3614: 38FF0048  addi r7, r31, 0x48
	ctx.r[7].s64 = ctx.r[31].s64 + 72;
	// 82AA3618: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA361C: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA3620: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AA3624: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82AA3628: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA362C: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3630: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA3634: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3638: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA363C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3640: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA3644; continue 'dispatch;
            }
            0x82AA3644 => {
    //   block [0x82AA3644..0x82AA3674)
	// 82AA3644: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA3648: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA364C: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82AA3650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3654: 409A0020  bne cr6, 0x82aa3674
	if !ctx.cr[6].eq {
	pc = 0x82AA3674; continue 'dispatch;
	}
	// 82AA3658: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA365C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3660: 393F0048  addi r9, r31, 0x48
	ctx.r[9].s64 = ctx.r[31].s64 + 72;
	// 82AA3664: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA3668: 997F005C  stb r11, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 82AA366C: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA3670: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82AA3674; continue 'dispatch;
            }
            0x82AA3674 => {
    //   block [0x82AA3674..0x82AA36DC)
	// 82AA3674: 897F0045  lbz r11, 0x45(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 82AA3678: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AA367C: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA3680: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA3684: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA3688: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA368C: 419A0080  beq cr6, 0x82aa370c
	if ctx.cr[6].eq {
	pc = 0x82AA370C; continue 'dispatch;
	}
	// 82AA3690: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3694: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AA3698: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82AA369C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA36A0: 409A003C  bne cr6, 0x82aa36dc
	if !ctx.cr[6].eq {
	pc = 0x82AA36DC; continue 'dispatch;
	}
	// 82AA36A4: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA36A8: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82AA36AC: 38FF0030  addi r7, r31, 0x30
	ctx.r[7].s64 = ctx.r[31].s64 + 48;
	// 82AA36B0: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA36B4: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82AA36B8: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AA36BC: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA36C0: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AA36C4: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA36C8: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA36CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA36D0: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA36D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA36D8: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA36DC; continue 'dispatch;
            }
            0x82AA36DC => {
    //   block [0x82AA36DC..0x82AA370C)
	// 82AA36DC: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82AA36E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA36E4: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82AA36E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA36EC: 409A0020  bne cr6, 0x82aa370c
	if !ctx.cr[6].eq {
	pc = 0x82AA370C; continue 'dispatch;
	}
	// 82AA36F0: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA36F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA36F8: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 82AA36FC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA3700: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82AA3704: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA3708: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82AA370C; continue 'dispatch;
            }
            0x82AA370C => {
    //   block [0x82AA370C..0x82AA377C)
	// 82AA370C: 891F1A25  lbz r8, 0x1a25(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6693 as u32) ) } as u64;
	// 82AA3710: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 82AA3714: 815F1A14  lwz r10, 0x1a14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6676 as u32) ) } as u64;
	// 82AA3718: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA371C: 81096FAC  lwz r8, 0x6fac(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28588 as u32) ) } as u64;
	// 82AA3720: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA3724: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA3728: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA372C: 419A0070  beq cr6, 0x82aa379c
	if ctx.cr[6].eq {
	pc = 0x82AA379C; continue 'dispatch;
	}
	// 82AA3730: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3734: 813F1A18  lwz r9, 0x1a18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6680 as u32) ) } as u64;
	// 82AA3738: 7D474838  and r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82AA373C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82AA3740: 409A003C  bne cr6, 0x82aa377c
	if !ctx.cr[6].eq {
	pc = 0x82AA377C; continue 'dispatch;
	}
	// 82AA3744: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3748: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82AA374C: 38DF1A10  addi r6, r31, 0x1a10
	ctx.r[6].s64 = ctx.r[31].s64 + 6672;
	// 82AA3750: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA3754: 915F1A18  stw r10, 0x1a18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6680 as u32), ctx.r[10].u32 ) };
	// 82AA3758: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 82AA375C: 815F1A14  lwz r10, 0x1a14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6676 as u32) ) } as u64;
	// 82AA3760: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3764: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3768: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA376C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3770: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3774: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3778: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA377C; continue 'dispatch;
            }
            0x82AA377C => {
    //   block [0x82AA377C..0x82AA379C)
	// 82AA377C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3780: 911F1A14  stw r8, 0x1a14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6676 as u32), ctx.r[8].u32 ) };
	// 82AA3784: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA3788: 997F1A24  stb r11, 0x1a24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6692 as u32), ctx.r[11].u8 ) };
	// 82AA378C: 387F1A10  addi r3, r31, 0x1a10
	ctx.r[3].s64 = ctx.r[31].s64 + 6672;
	// 82AA3790: 995F1A1C  stb r10, 0x1a1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6684 as u32), ctx.r[10].u8 ) };
	// 82AA3794: 4B77ADBD  bl 0x8221e550
	ctx.lr = 0x82AA3798;
	sub_8221E550(ctx, base);
	// 82AA3798: 80DD0DB0  lwz r6, 0xdb0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82AA379C; continue 'dispatch;
            }
            0x82AA379C => {
    //   block [0x82AA379C..0x82AA3804)
	// 82AA379C: 897F020D  lbz r11, 0x20d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(525 as u32) ) } as u64;
	// 82AA37A0: 815F01FC  lwz r10, 0x1fc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82AA37A4: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA37A8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA37AC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82AA37B0: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA37B4: 419A0080  beq cr6, 0x82aa3834
	if ctx.cr[6].eq {
	pc = 0x82AA3834; continue 'dispatch;
	}
	// 82AA37B8: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA37BC: 813F0200  lwz r9, 0x200(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82AA37C0: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82AA37C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA37C8: 409A003C  bne cr6, 0x82aa3804
	if !ctx.cr[6].eq {
	pc = 0x82AA3804; continue 'dispatch;
	}
	// 82AA37CC: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA37D0: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82AA37D4: 38FF01F8  addi r7, r31, 0x1f8
	ctx.r[7].s64 = ctx.r[31].s64 + 504;
	// 82AA37D8: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA37DC: 915F0200  stw r10, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[10].u32 ) };
	// 82AA37E0: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AA37E4: 815F01FC  lwz r10, 0x1fc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82AA37E8: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA37EC: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA37F0: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA37F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA37F8: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA37FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3800: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA3804; continue 'dispatch;
            }
            0x82AA3804 => {
    //   block [0x82AA3804..0x82AA3834)
	// 82AA3804: 897F020C  lbz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82AA3808: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA380C: 915F01FC  stw r10, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[10].u32 ) };
	// 82AA3810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3814: 409A0020  bne cr6, 0x82aa3834
	if !ctx.cr[6].eq {
	pc = 0x82AA3834; continue 'dispatch;
	}
	// 82AA3818: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA381C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3820: 393F01F8  addi r9, r31, 0x1f8
	ctx.r[9].s64 = ctx.r[31].s64 + 504;
	// 82AA3824: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA3828: 997F020C  stb r11, 0x20c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u8 ) };
	// 82AA382C: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA3830: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82AA3834; continue 'dispatch;
            }
            0x82AA3834 => {
    //   block [0x82AA3834..0x82AA38A8)
	// 82AA3834: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 82AA3838: 891F026D  lbz r8, 0x26d(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(621 as u32) ) } as u64;
	// 82AA383C: 815F025C  lwz r10, 0x25c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 82AA3840: 38E96F8C  addi r7, r9, 0x6f8c
	ctx.r[7].s64 = ctx.r[9].s64 + 28556;
	// 82AA3844: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA3848: 8107001C  lwz r8, 0x1c(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA384C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA3850: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA3854: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA3858: 419A007C  beq cr6, 0x82aa38d4
	if ctx.cr[6].eq {
	pc = 0x82AA38D4; continue 'dispatch;
	}
	// 82AA385C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3860: 813F0260  lwz r9, 0x260(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82AA3864: 7D474838  and r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82AA3868: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82AA386C: 409A003C  bne cr6, 0x82aa38a8
	if !ctx.cr[6].eq {
	pc = 0x82AA38A8; continue 'dispatch;
	}
	// 82AA3870: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3874: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82AA3878: 38BF0258  addi r5, r31, 0x258
	ctx.r[5].s64 = ctx.r[31].s64 + 600;
	// 82AA387C: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82AA3880: 915F0260  stw r10, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[10].u32 ) };
	// 82AA3884: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 82AA3888: 815F025C  lwz r10, 0x25c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 82AA388C: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3890: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3894: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA3898: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA389C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA38A0: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82AA38A4: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82AA38A8; continue 'dispatch;
            }
            0x82AA38A8 => {
    //   block [0x82AA38A8..0x82AA38D4)
	// 82AA38A8: 897F026C  lbz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82AA38AC: 911F025C  stw r8, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[8].u32 ) };
	// 82AA38B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA38B4: 409A0020  bne cr6, 0x82aa38d4
	if !ctx.cr[6].eq {
	pc = 0x82AA38D4; continue 'dispatch;
	}
	// 82AA38B8: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA38BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA38C0: 393F0258  addi r9, r31, 0x258
	ctx.r[9].s64 = ctx.r[31].s64 + 600;
	// 82AA38C4: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA38C8: 997F026C  stb r11, 0x26c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u8 ) };
	// 82AA38CC: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA38D0: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82AA38D4; continue 'dispatch;
            }
            0x82AA38D4 => {
    //   block [0x82AA38D4..0x82AA3950)
	// 82AA38D4: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 82AA38D8: 897F0255  lbz r11, 0x255(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(597 as u32) ) } as u64;
	// 82AA38DC: 811F0244  lwz r8, 0x244(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82AA38E0: 392A6FFC  addi r9, r10, 0x6ffc
	ctx.r[9].s64 = ctx.r[10].s64 + 28668;
	// 82AA38E4: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA38E8: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA38EC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA38F0: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82AA38F4: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA38F8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA38FC: 419A0080  beq cr6, 0x82aa397c
	if ctx.cr[6].eq {
	pc = 0x82AA397C; continue 'dispatch;
	}
	// 82AA3900: 810B2000  lwz r8, 0x2000(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3904: 80FF0248  lwz r7, 0x248(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 82AA3908: 7D043838  and r4, r8, r7
	ctx.r[4].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 82AA390C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AA3910: 409A0040  bne cr6, 0x82aa3950
	if !ctx.cr[6].eq {
	pc = 0x82AA3950; continue 'dispatch;
	}
	// 82AA3914: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3918: 7D0A3B78  or r10, r8, r7
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 82AA391C: 387F0240  addi r3, r31, 0x240
	ctx.r[3].s64 = ctx.r[31].s64 + 576;
	// 82AA3920: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA3924: 915F0248  stw r10, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[10].u32 ) };
	// 82AA3928: 7C68592E  stwx r3, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82AA392C: 815F0244  lwz r10, 0x244(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82AA3930: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3934: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA3938: 7C885A14  add r4, r8, r11
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82AA393C: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3940: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA3944: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3948: 38690001  addi r3, r9, 1
	ctx.r[3].s64 = ctx.r[9].s64 + 1;
	// 82AA394C: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x82AA3950; continue 'dispatch;
            }
            0x82AA3950 => {
    //   block [0x82AA3950..0x82AA397C)
	// 82AA3950: 897F0254  lbz r11, 0x254(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 82AA3954: 90BF0244  stw r5, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[5].u32 ) };
	// 82AA3958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA395C: 409A0020  bne cr6, 0x82aa397c
	if !ctx.cr[6].eq {
	pc = 0x82AA397C; continue 'dispatch;
	}
	// 82AA3960: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3964: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3968: 391F0240  addi r8, r31, 0x240
	ctx.r[8].s64 = ctx.r[31].s64 + 576;
	// 82AA396C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA3970: 997F0254  stb r11, 0x254(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u8 ) };
	// 82AA3974: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA3978: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82AA397C; continue 'dispatch;
            }
            0x82AA397C => {
    //   block [0x82AA397C..0x82AA39E4)
	// 82AA397C: 897F023D  lbz r11, 0x23d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(573 as u32) ) } as u64;
	// 82AA3980: 813F022C  lwz r9, 0x22c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 82AA3984: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA3988: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA398C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA3990: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA3994: 419A007C  beq cr6, 0x82aa3a10
	if ctx.cr[6].eq {
	pc = 0x82AA3A10; continue 'dispatch;
	}
	// 82AA3998: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA399C: 811F0230  lwz r8, 0x230(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82AA39A0: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82AA39A4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82AA39A8: 409A003C  bne cr6, 0x82aa39e4
	if !ctx.cr[6].eq {
	pc = 0x82AA39E4; continue 'dispatch;
	}
	// 82AA39AC: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA39B0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82AA39B4: 38BF0228  addi r5, r31, 0x228
	ctx.r[5].s64 = ctx.r[31].s64 + 552;
	// 82AA39B8: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82AA39BC: 913F0230  stw r9, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[9].u32 ) };
	// 82AA39C0: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 82AA39C4: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA39C8: 813F022C  lwz r9, 0x22c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 82AA39CC: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA39D0: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82AA39D4: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA39D8: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA39DC: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82AA39E0: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82AA39E4; continue 'dispatch;
            }
            0x82AA39E4 => {
    //   block [0x82AA39E4..0x82AA3A10)
	// 82AA39E4: 897F023C  lbz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82AA39E8: 915F022C  stw r10, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[10].u32 ) };
	// 82AA39EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA39F0: 409A0020  bne cr6, 0x82aa3a10
	if !ctx.cr[6].eq {
	pc = 0x82AA3A10; continue 'dispatch;
	}
	// 82AA39F4: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA39F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA39FC: 393F0228  addi r9, r31, 0x228
	ctx.r[9].s64 = ctx.r[31].s64 + 552;
	// 82AA3A00: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA3A04: 997F023C  stb r11, 0x23c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[11].u8 ) };
	// 82AA3A08: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA3A0C: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82AA3A10; continue 'dispatch;
            }
            0x82AA3A10 => {
    //   block [0x82AA3A10..0x82AA3A78)
	// 82AA3A10: 897F1A6D  lbz r11, 0x1a6d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6765 as u32) ) } as u64;
	// 82AA3A14: 815F1A5C  lwz r10, 0x1a5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6748 as u32) ) } as u64;
	// 82AA3A18: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA3A1C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA3A20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA3A24: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA3A28: 419A0080  beq cr6, 0x82aa3aa8
	if ctx.cr[6].eq {
	pc = 0x82AA3AA8; continue 'dispatch;
	}
	// 82AA3A2C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3A30: 813F1A60  lwz r9, 0x1a60(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6752 as u32) ) } as u64;
	// 82AA3A34: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82AA3A38: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA3A3C: 409A003C  bne cr6, 0x82aa3a78
	if !ctx.cr[6].eq {
	pc = 0x82AA3A78; continue 'dispatch;
	}
	// 82AA3A40: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3A44: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82AA3A48: 38FF1A58  addi r7, r31, 0x1a58
	ctx.r[7].s64 = ctx.r[31].s64 + 6744;
	// 82AA3A4C: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA3A50: 915F1A60  stw r10, 0x1a60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6752 as u32), ctx.r[10].u32 ) };
	// 82AA3A54: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AA3A58: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3A5C: 815F1A5C  lwz r10, 0x1a5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6748 as u32) ) } as u64;
	// 82AA3A60: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3A64: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA3A68: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3A6C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3A70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3A74: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA3A78; continue 'dispatch;
            }
            0x82AA3A78 => {
    //   block [0x82AA3A78..0x82AA3AA8)
	// 82AA3A78: 897F1A6C  lbz r11, 0x1a6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6764 as u32) ) } as u64;
	// 82AA3A7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA3A80: 915F1A5C  stw r10, 0x1a5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6748 as u32), ctx.r[10].u32 ) };
	// 82AA3A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3A88: 409A0020  bne cr6, 0x82aa3aa8
	if !ctx.cr[6].eq {
	pc = 0x82AA3AA8; continue 'dispatch;
	}
	// 82AA3A8C: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA3A90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3A94: 393F1A58  addi r9, r31, 0x1a58
	ctx.r[9].s64 = ctx.r[31].s64 + 6744;
	// 82AA3A98: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA3A9C: 997F1A6C  stb r11, 0x1a6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6764 as u32), ctx.r[11].u8 ) };
	// 82AA3AA0: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA3AA4: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82AA3AA8; continue 'dispatch;
            }
            0x82AA3AA8 => {
    //   block [0x82AA3AA8..0x82AA3B10)
	// 82AA3AA8: 897F0285  lbz r11, 0x285(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(645 as u32) ) } as u64;
	// 82AA3AAC: 815F0274  lwz r10, 0x274(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82AA3AB0: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA3AB4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA3AB8: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 82AA3ABC: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA3AC0: 419A0080  beq cr6, 0x82aa3b40
	if ctx.cr[6].eq {
	pc = 0x82AA3B40; continue 'dispatch;
	}
	// 82AA3AC4: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3AC8: 813F0278  lwz r9, 0x278(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82AA3ACC: 7D285038  and r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 82AA3AD0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA3AD4: 409A003C  bne cr6, 0x82aa3b10
	if !ctx.cr[6].eq {
	pc = 0x82AA3B10; continue 'dispatch;
	}
	// 82AA3AD8: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3ADC: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82AA3AE0: 38FF0270  addi r7, r31, 0x270
	ctx.r[7].s64 = ctx.r[31].s64 + 624;
	// 82AA3AE4: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA3AE8: 915F0278  stw r10, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[10].u32 ) };
	// 82AA3AEC: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AA3AF0: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3AF4: 815F0274  lwz r10, 0x274(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82AA3AF8: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3AFC: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA3B00: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3B04: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3B08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3B0C: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA3B10; continue 'dispatch;
            }
            0x82AA3B10 => {
    //   block [0x82AA3B10..0x82AA3B40)
	// 82AA3B10: 897F0284  lbz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 82AA3B14: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82AA3B18: 915F0274  stw r10, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[10].u32 ) };
	// 82AA3B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3B20: 409A0020  bne cr6, 0x82aa3b40
	if !ctx.cr[6].eq {
	pc = 0x82AA3B40; continue 'dispatch;
	}
	// 82AA3B24: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA3B28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3B2C: 393F0270  addi r9, r31, 0x270
	ctx.r[9].s64 = ctx.r[31].s64 + 624;
	// 82AA3B30: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA3B34: 997F0284  stb r11, 0x284(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u8 ) };
	// 82AA3B38: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA3B3C: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82AA3B40; continue 'dispatch;
            }
            0x82AA3B40 => {
    //   block [0x82AA3B40..0x82AA3BA8)
	// 82AA3B40: 897F029D  lbz r11, 0x29d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(669 as u32) ) } as u64;
	// 82AA3B44: 815F028C  lwz r10, 0x28c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 82AA3B48: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA3B4C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA3B50: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 82AA3B54: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA3B58: 419A0080  beq cr6, 0x82aa3bd8
	if ctx.cr[6].eq {
	pc = 0x82AA3BD8; continue 'dispatch;
	}
	// 82AA3B5C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3B60: 813F0290  lwz r9, 0x290(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 82AA3B64: 7D285038  and r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 82AA3B68: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA3B6C: 409A003C  bne cr6, 0x82aa3ba8
	if !ctx.cr[6].eq {
	pc = 0x82AA3BA8; continue 'dispatch;
	}
	// 82AA3B70: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3B74: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82AA3B78: 38FF0288  addi r7, r31, 0x288
	ctx.r[7].s64 = ctx.r[31].s64 + 648;
	// 82AA3B7C: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA3B80: 915F0290  stw r10, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[10].u32 ) };
	// 82AA3B84: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AA3B88: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3B8C: 815F028C  lwz r10, 0x28c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 82AA3B90: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3B94: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA3B98: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3B9C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3BA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3BA4: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA3BA8; continue 'dispatch;
            }
            0x82AA3BA8 => {
    //   block [0x82AA3BA8..0x82AA3BD8)
	// 82AA3BA8: 897F029C  lbz r11, 0x29c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 82AA3BAC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82AA3BB0: 915F028C  stw r10, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[10].u32 ) };
	// 82AA3BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3BB8: 409A0020  bne cr6, 0x82aa3bd8
	if !ctx.cr[6].eq {
	pc = 0x82AA3BD8; continue 'dispatch;
	}
	// 82AA3BBC: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA3BC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3BC4: 393F0288  addi r9, r31, 0x288
	ctx.r[9].s64 = ctx.r[31].s64 + 648;
	// 82AA3BC8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82AA3BCC: 997F029C  stb r11, 0x29c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u8 ) };
	// 82AA3BD0: 90DD0DB0  stw r6, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 82AA3BD4: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82AA3BD8; continue 'dispatch;
            }
            0x82AA3BD8 => {
    //   block [0x82AA3BD8..0x82AA3C40)
	// 82AA3BD8: 897F02B5  lbz r11, 0x2b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(693 as u32) ) } as u64;
	// 82AA3BDC: 815F02A4  lwz r10, 0x2a4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 82AA3BE0: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA3BE4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AA3BE8: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 82AA3BEC: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82AA3BF0: 419A0080  beq cr6, 0x82aa3c70
	if ctx.cr[6].eq {
	pc = 0x82AA3C70; continue 'dispatch;
	}
	// 82AA3BF4: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AA3BF8: 813F02A8  lwz r9, 0x2a8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 82AA3BFC: 7D285038  and r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 82AA3C00: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA3C04: 409A003C  bne cr6, 0x82aa3c40
	if !ctx.cr[6].eq {
	pc = 0x82AA3C40; continue 'dispatch;
	}
	// 82AA3C08: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3C0C: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82AA3C10: 38FF02A0  addi r7, r31, 0x2a0
	ctx.r[7].s64 = ctx.r[31].s64 + 672;
	// 82AA3C14: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AA3C18: 915F02A8  stw r10, 0x2a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(680 as u32), ctx.r[10].u32 ) };
	// 82AA3C1C: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AA3C20: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3C24: 815F02A4  lwz r10, 0x2a4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 82AA3C28: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3C2C: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA3C30: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3C34: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AA3C38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3C3C: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82AA3C40; continue 'dispatch;
            }
            0x82AA3C40 => {
    //   block [0x82AA3C40..0x82AA3C70)
	// 82AA3C40: 897F02B4  lbz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 82AA3C44: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82AA3C48: 915F02A4  stw r10, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[10].u32 ) };
	// 82AA3C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3C50: 409A0020  bne cr6, 0x82aa3c70
	if !ctx.cr[6].eq {
	pc = 0x82AA3C70; continue 'dispatch;
	}
	// 82AA3C54: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA3C58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3C5C: 391F02A0  addi r8, r31, 0x2a0
	ctx.r[8].s64 = ctx.r[31].s64 + 672;
	// 82AA3C60: 39460001  addi r10, r6, 1
	ctx.r[10].s64 = ctx.r[6].s64 + 1;
	// 82AA3C64: 997F02B4  stb r11, 0x2b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u8 ) };
	// 82AA3C68: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 82AA3C6C: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82AA3C70; continue 'dispatch;
            }
            0x82AA3C70 => {
    //   block [0x82AA3C70..0x82AA3C78)
	// 82AA3C70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA3C74: 482057E4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3C78 size=192
    let mut pc: u32 = 0x82AA3C78;
    'dispatch: loop {
        match pc {
            0x82AA3C78 => {
    //   block [0x82AA3C78..0x82AA3CA8)
	// 82AA3C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA3C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3C88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3C8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA3C90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA3C94: 57EB0528  rlwinm r11, r31, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA3C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3C9C: 419A000C  beq cr6, 0x82aa3ca8
	if ctx.cr[6].eq {
	pc = 0x82AA3CA8; continue 'dispatch;
	}
	// 82AA3CA0: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 82AA3CA4: 48000014  b 0x82aa3cb8
	pc = 0x82AA3CB8; continue 'dispatch;
            }
            0x82AA3CA8 => {
    //   block [0x82AA3CA8..0x82AA3CB8)
	// 82AA3CA8: 57EB04E6  rlwinm r11, r31, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA3CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3CB0: 419A0010  beq cr6, 0x82aa3cc0
	if ctx.cr[6].eq {
	pc = 0x82AA3CC0; continue 'dispatch;
	}
	// 82AA3CB4: 38804000  li r4, 0x4000
	ctx.r[4].s64 = 16384;
	pc = 0x82AA3CB8; continue 'dispatch;
            }
            0x82AA3CB8 => {
    //   block [0x82AA3CB8..0x82AA3CC0)
	// 82AA3CB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3CBC: 4BFD594D  bl 0x82a79608
	ctx.lr = 0x82AA3CC0;
	sub_82A79608(ctx, base);
	pc = 0x82AA3CC0; continue 'dispatch;
            }
            0x82AA3CC0 => {
    //   block [0x82AA3CC0..0x82AA3CF0)
	// 82AA3CC0: 7FEBF8F8  nor r11, r31, r31
	ctx.r[11].u64 = !(ctx.r[31].u64 | ctx.r[31].u64);
	// 82AA3CC4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82AA3CC8: 5565D7FE  rlwinm r5, r11, 0x1a, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82AA3CCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3CD0: 4BFD59A9  bl 0x82a79678
	ctx.lr = 0x82AA3CD4;
	sub_82A79678(ctx, base);
	// 82AA3CD4: 57EA0672  rlwinm r10, r31, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA3CD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA3CDC: 409A0014  bne cr6, 0x82aa3cf0
	if !ctx.cr[6].eq {
	pc = 0x82AA3CF0; continue 'dispatch;
	}
	// 82AA3CE0: 57EB0630  rlwinm r11, r31, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA3CE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA3CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3CEC: 419A0008  beq cr6, 0x82aa3cf4
	if ctx.cr[6].eq {
	pc = 0x82AA3CF4; continue 'dispatch;
	}
	pc = 0x82AA3CF0; continue 'dispatch;
            }
            0x82AA3CF0 => {
    //   block [0x82AA3CF0..0x82AA3CF4)
	// 82AA3CF0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x82AA3CF4; continue 'dispatch;
            }
            0x82AA3CF4 => {
    //   block [0x82AA3CF4..0x82AA3D38)
	// 82AA3CF4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82AA3CF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3CFC: 4BFD597D  bl 0x82a79678
	ctx.lr = 0x82AA3D00;
	sub_82A79678(ctx, base);
	// 82AA3D00: 57E5BFFE  rlwinm r5, r31, 0x17, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[31].u32 as u64 & 0x000001FFu64;
	// 82AA3D04: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AA3D08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3D0C: 4BFD596D  bl 0x82a79678
	ctx.lr = 0x82AA3D10;
	sub_82A79678(ctx, base);
	// 82AA3D10: 57E5B7FE  rlwinm r5, r31, 0x16, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[31].u32 as u64 & 0x000003FFu64;
	// 82AA3D14: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AA3D18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3D1C: 4BFD595D  bl 0x82a79678
	ctx.lr = 0x82AA3D20;
	sub_82A79678(ctx, base);
	// 82AA3D20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3D24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3D28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3D2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA3D30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3D38 size=124
    let mut pc: u32 = 0x82AA3D38;
    'dispatch: loop {
        match pc {
            0x82AA3D38 => {
    //   block [0x82AA3D38..0x82AA3D58)
	// 82AA3D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3D3C: 482056D1  bl 0x82ca940c
	ctx.lr = 0x82AA3D40;
	sub_82CA93D0(ctx, base);
	// 82AA3D40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3D44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA3D48: 817E01FC  lwz r11, 0x1fc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82AA3D4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3D50: 419A005C  beq cr6, 0x82aa3dac
	if ctx.cr[6].eq {
	pc = 0x82AA3DAC; continue 'dispatch;
	}
	// 82AA3D54: 3BFE01F4  addi r31, r30, 0x1f4
	ctx.r[31].s64 = ctx.r[30].s64 + 500;
	pc = 0x82AA3D58; continue 'dispatch;
            }
            0x82AA3D58 => {
    //   block [0x82AA3D58..0x82AA3D70)
	// 82AA3D58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3D5C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA3D60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3D64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA3D68: 409A0008  bne cr6, 0x82aa3d70
	if !ctx.cr[6].eq {
	pc = 0x82AA3D70; continue 'dispatch;
	}
	// 82AA3D6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AA3D70; continue 'dispatch;
            }
            0x82AA3D70 => {
    //   block [0x82AA3D70..0x82AA3DAC)
	// 82AA3D70: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3D74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA3D78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA3D7C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA3D80: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA3D84: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3D88: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82AA3D8C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA3D90: 4B736159  bl 0x821d9ee8
	ctx.lr = 0x82AA3D94;
	sub_821D9EE8(ctx, base);
	// 82AA3D94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA3D98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA3D9C: 4BFBED55  bl 0x82a62af0
	ctx.lr = 0x82AA3DA0;
	sub_82A62AF0(ctx, base);
	// 82AA3DA0: 811E01FC  lwz r8, 0x1fc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82AA3DA4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA3DA8: 409AFFB0  bne cr6, 0x82aa3d58
	if !ctx.cr[6].eq {
	pc = 0x82AA3D58; continue 'dispatch;
	}
	pc = 0x82AA3DAC; continue 'dispatch;
            }
            0x82AA3DAC => {
    //   block [0x82AA3DAC..0x82AA3DB4)
	// 82AA3DAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA3DB0: 482056AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3DB8 size=212
    let mut pc: u32 = 0x82AA3DB8;
    'dispatch: loop {
        match pc {
            0x82AA3DB8 => {
    //   block [0x82AA3DB8..0x82AA3E80)
	// 82AA3DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3DBC: 48205651  bl 0x82ca940c
	ctx.lr = 0x82AA3DC0;
	sub_82CA93D0(ctx, base);
	// 82AA3DC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3DC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3DC8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA3DCC: 83DF00D4  lwz r30, 0xd4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA3DD0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA3DD4: 419A00AC  beq cr6, 0x82aa3e80
	if ctx.cr[6].eq {
	pc = 0x82AA3E80; continue 'dispatch;
	}
	// 82AA3DD8: 3D601941  lis r11, 0x1941
	ctx.r[11].s64 = 423690240;
	// 82AA3DDC: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA3DE0: 61691C86  ori r9, r11, 0x1c86
	ctx.r[9].u64 = ctx.r[11].u64 | 7302;
	// 82AA3DE4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA3DE8: 419A0098  beq cr6, 0x82aa3e80
	if ctx.cr[6].eq {
	pc = 0x82AA3E80; continue 'dispatch;
	}
	// 82AA3DEC: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA3DF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA3DF4: 4099008C  ble cr6, 0x82aa3e80
	if !ctx.cr[6].gt {
	pc = 0x82AA3E80; continue 'dispatch;
	}
	// 82AA3DF8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3DFC: 39400140  li r10, 0x140
	ctx.r[10].s64 = 320;
	// 82AA3E00: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 82AA3E04: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82AA3E08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x82AA3E80; continue 'dispatch;
            }
            0x82AA3E80 => {
    //   block [0x82AA3E80..0x82AA3E8C)
	// 82AA3E80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA3E84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA3E88: 482055D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3E90 size=196
    let mut pc: u32 = 0x82AA3E90;
    'dispatch: loop {
        match pc {
            0x82AA3E90 => {
    //   block [0x82AA3E90..0x82AA3EBC)
	// 82AA3E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3E94: 48205579  bl 0x82ca940c
	ctx.lr = 0x82AA3E98;
	sub_82CA93D0(ctx, base);
	// 82AA3E98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3E9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3EA0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA3EA4: 83DF00D4  lwz r30, 0xd4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA3EA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA3EAC: 409A0010  bne cr6, 0x82aa3ebc
	if !ctx.cr[6].eq {
	pc = 0x82AA3EBC; continue 'dispatch;
	}
	// 82AA3EB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA3EB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA3EB8: 482055A4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA3EBC => {
    //   block [0x82AA3EBC..0x82AA3F54)
	// 82AA3EBC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3EC0: 39400140  li r10, 0x140
	ctx.r[10].s64 = 320;
	// 82AA3EC4: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 82AA3EC8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82AA3ECC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA3ED0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3F58 size=208
    let mut pc: u32 = 0x82AA3F58;
    'dispatch: loop {
        match pc {
            0x82AA3F58 => {
    //   block [0x82AA3F58..0x82AA3FC8)
	// 82AA3F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3F60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA3F64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3F68: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3F6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3F70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA3F74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA3F78: 4BFFA7D1  bl 0x82a9e748
	ctx.lr = 0x82AA3F7C;
	sub_82A9E748(ctx, base);
	// 82AA3F7C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3F80: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA3F84: 390000B4  li r8, 0xb4
	ctx.r[8].s64 = 180;
	// 82AA3F88: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA3F8C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA3F90: 7D2943D6  divw r9, r9, r8
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 82AA3F94: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA3F98: 40990030  ble cr6, 0x82aa3fc8
	if !ctx.cr[6].gt {
	pc = 0x82AA3FC8; continue 'dispatch;
	}
	// 82AA3F9C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA3FA0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA3FA4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA3FA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA3FAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3FB0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AA3FB4: 7CA743D6  divw r5, r7, r8
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 82AA3FB8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA3FBC: 7CA5F050  subf r5, r5, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82AA3FC0: 480002D1  bl 0x82aa4290
	ctx.lr = 0x82AA3FC4;
	sub_82AA4290(ctx, base);
	// 82AA3FC4: 48000044  b 0x82aa4008
	pc = 0x82AA4008; continue 'dispatch;
            }
            0x82AA3FC8 => {
    //   block [0x82AA3FC8..0x82AA4008)
	// 82AA3FC8: 40980040  bge cr6, 0x82aa4008
	if !ctx.cr[6].lt {
	pc = 0x82AA4008; continue 'dispatch;
	}
	// 82AA3FCC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA3FD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA3FD4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA3FD8: 1D5E00B4  mulli r10, r30, 0xb4
	ctx.r[10].s32 = ((ctx.r[30].s32 as i64 * 180 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82AA3FDC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82AA3FE0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AA3FE4: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA3FE8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82AA3FEC: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA3FF0: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA3FF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA3FF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA3FFC: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82AA4000: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA4004: 48000185  bl 0x82aa4188
	ctx.lr = 0x82AA4008;
	sub_82AA4188(ctx, base);
	pc = 0x82AA4008; continue 'dispatch;
            }
            0x82AA4008 => {
    //   block [0x82AA4008..0x82AA4028)
	// 82AA4008: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA400C: 4BFC36F5  bl 0x82a67700
	ctx.lr = 0x82AA4010;
	sub_82A67700(ctx, base);
	// 82AA4010: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82AA4014: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA4018: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA401C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA4020: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4024: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4028 size=96
    let mut pc: u32 = 0x82AA4028;
    'dispatch: loop {
        match pc {
            0x82AA4028 => {
    //   block [0x82AA4028..0x82AA4050)
	// 82AA4028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA402C: 482053E1  bl 0x82ca940c
	ctx.lr = 0x82AA4030;
	sub_82CA93D0(ctx, base);
	// 82AA4030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA4038: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA403C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA4040: 419A0030  beq cr6, 0x82aa4070
	if ctx.cr[6].eq {
	pc = 0x82AA4070; continue 'dispatch;
	}
	// 82AA4044: 83BE0008  lwz r29, 8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4048: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA404C: 419A001C  beq cr6, 0x82aa4068
	if ctx.cr[6].eq {
	pc = 0x82AA4068; continue 'dispatch;
	}
	pc = 0x82AA4050; continue 'dispatch;
            }
            0x82AA4050 => {
    //   block [0x82AA4050..0x82AA4068)
	// 82AA4050: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4058: 4BCBEEE9  bl 0x82762f40
	ctx.lr = 0x82AA405C;
	sub_82762F40(ctx, base);
	// 82AA405C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82AA4060: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4064: 409AFFEC  bne cr6, 0x82aa4050
	if !ctx.cr[6].eq {
	pc = 0x82AA4050; continue 'dispatch;
	}
	pc = 0x82AA4068; continue 'dispatch;
            }
            0x82AA4068 => {
    //   block [0x82AA4068..0x82AA4070)
	// 82AA4068: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA406C: 4B777CCD  bl 0x8221bd38
	ctx.lr = 0x82AA4070;
	sub_8221BD38(ctx, base);
	pc = 0x82AA4070; continue 'dispatch;
            }
            0x82AA4070 => {
    //   block [0x82AA4070..0x82AA4088)
	// 82AA4070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA4074: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AA4078: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA407C: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AA4080: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4084: 482053D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4088 size=92
    let mut pc: u32 = 0x82AA4088;
    'dispatch: loop {
        match pc {
            0x82AA4088 => {
    //   block [0x82AA4088..0x82AA40B0)
	// 82AA4088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA408C: 48205381  bl 0x82ca940c
	ctx.lr = 0x82AA4090;
	sub_82CA93D0(ctx, base);
	// 82AA4090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4094: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA4098: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA409C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA40A0: 419A002C  beq cr6, 0x82aa40cc
	if ctx.cr[6].eq {
	pc = 0x82AA40CC; continue 'dispatch;
	}
	// 82AA40A4: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA40A8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA40AC: 419A0018  beq cr6, 0x82aa40c4
	if ctx.cr[6].eq {
	pc = 0x82AA40C4; continue 'dispatch;
	}
	pc = 0x82AA40B0; continue 'dispatch;
            }
            0x82AA40B0 => {
    //   block [0x82AA40B0..0x82AA40C4)
	// 82AA40B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA40B4: 4800017D  bl 0x82aa4230
	ctx.lr = 0x82AA40B8;
	sub_82AA4230(ctx, base);
	// 82AA40B8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA40BC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA40C0: 409AFFF0  bne cr6, 0x82aa40b0
	if !ctx.cr[6].eq {
	pc = 0x82AA40B0; continue 'dispatch;
	}
	pc = 0x82AA40C4; continue 'dispatch;
            }
            0x82AA40C4 => {
    //   block [0x82AA40C4..0x82AA40CC)
	// 82AA40C4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA40C8: 4B777C71  bl 0x8221bd38
	ctx.lr = 0x82AA40CC;
	sub_8221BD38(ctx, base);
	pc = 0x82AA40CC; continue 'dispatch;
            }
            0x82AA40CC => {
    //   block [0x82AA40CC..0x82AA40E4)
	// 82AA40CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA40D0: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AA40D4: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA40D8: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AA40DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA40E0: 4820537C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA40E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA40E8 size=160
    let mut pc: u32 = 0x82AA40E8;
    'dispatch: loop {
        match pc {
            0x82AA40E8 => {
    //   block [0x82AA40E8..0x82AA4138)
	// 82AA40E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA40EC: 48205311  bl 0x82ca93fc
	ctx.lr = 0x82AA40F0;
	sub_82CA93D0(ctx, base);
	// 82AA40F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA40F4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82AA40F8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA40FC: FB2100B0  std r25, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u64 ) };
	// 82AA4100: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AA4104: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82AA4108: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AA410C: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AA4110: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA4114: 419A0064  beq cr6, 0x82aa4178
	if ctx.cr[6].eq {
	pc = 0x82AA4178; continue 'dispatch;
	}
	// 82AA4118: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA411C: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82AA4120: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4124: 7D492670  srawi r9, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 82AA4128: 552A2036  slwi r10, r9, 4
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA412C: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA4130: 419A0020  beq cr6, 0x82aa4150
	if ctx.cr[6].eq {
	pc = 0x82AA4150; continue 'dispatch;
	}
	// 82AA4134: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82AA4138; continue 'dispatch;
            }
            0x82AA4138 => {
    //   block [0x82AA4138..0x82AA4150)
	// 82AA4138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA413C: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82AA4140: 48000A91  bl 0x82aa4bd0
	ctx.lr = 0x82AA4144;
	sub_82AA4BD0(ctx, base);
	// 82AA4144: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA4148: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA414C: 409AFFEC  bne cr6, 0x82aa4138
	if !ctx.cr[6].eq {
	pc = 0x82AA4138; continue 'dispatch;
	}
	pc = 0x82AA4150; continue 'dispatch;
            }
            0x82AA4150 => {
    //   block [0x82AA4150..0x82AA4160)
	// 82AA4150: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4154: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA4158: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA415C: 419A0018  beq cr6, 0x82aa4174
	if ctx.cr[6].eq {
	pc = 0x82AA4174; continue 'dispatch;
	}
	pc = 0x82AA4160; continue 'dispatch;
            }
            0x82AA4160 => {
    //   block [0x82AA4160..0x82AA4174)
	// 82AA4160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4164: 480000CD  bl 0x82aa4230
	ctx.lr = 0x82AA4168;
	sub_82AA4230(ctx, base);
	// 82AA4168: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA416C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4170: 409AFFF0  bne cr6, 0x82aa4160
	if !ctx.cr[6].eq {
	pc = 0x82AA4160; continue 'dispatch;
	}
	pc = 0x82AA4174; continue 'dispatch;
            }
            0x82AA4174 => {
    //   block [0x82AA4174..0x82AA4178)
	// 82AA4174: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82AA4178; continue 'dispatch;
            }
            0x82AA4178 => {
    //   block [0x82AA4178..0x82AA4188)
	// 82AA4178: FB3A0000  std r25, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 82AA417C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA4180: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA4184: 482052C8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4188 size=164
    let mut pc: u32 = 0x82AA4188;
    'dispatch: loop {
        match pc {
            0x82AA4188 => {
    //   block [0x82AA4188..0x82AA41DC)
	// 82AA4188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA418C: 48205271  bl 0x82ca93fc
	ctx.lr = 0x82AA4190;
	sub_82CA93D0(ctx, base);
	// 82AA4190: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4194: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82AA4198: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA419C: FB2100B0  std r25, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u64 ) };
	// 82AA41A0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AA41A4: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82AA41A8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AA41AC: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AA41B0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA41B4: 419A0068  beq cr6, 0x82aa421c
	if ctx.cr[6].eq {
	pc = 0x82AA421C; continue 'dispatch;
	}
	// 82AA41B8: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA41BC: 394000B4  li r10, 0xb4
	ctx.r[10].s64 = 180;
	// 82AA41C0: 7D3FF050  subf r9, r31, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82AA41C4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA41C8: 7D0953D6  divw r8, r9, r10
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[10].s32;
	// 82AA41CC: 1D4800B4  mulli r10, r8, 0xb4
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 180 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82AA41D0: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA41D4: 419A0020  beq cr6, 0x82aa41f4
	if ctx.cr[6].eq {
	pc = 0x82AA41F4; continue 'dispatch;
	}
	// 82AA41D8: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82AA41DC; continue 'dispatch;
            }
            0x82AA41DC => {
    //   block [0x82AA41DC..0x82AA41F4)
	// 82AA41DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA41E0: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82AA41E4: 4BFFB6DD  bl 0x82a9f8c0
	ctx.lr = 0x82AA41E8;
	sub_82A9F8C0(ctx, base);
	// 82AA41E8: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA41EC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA41F0: 409AFFEC  bne cr6, 0x82aa41dc
	if !ctx.cr[6].eq {
	pc = 0x82AA41DC; continue 'dispatch;
	}
	pc = 0x82AA41F4; continue 'dispatch;
            }
            0x82AA41F4 => {
    //   block [0x82AA41F4..0x82AA4204)
	// 82AA41F4: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA41F8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA41FC: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4200: 419A0018  beq cr6, 0x82aa4218
	if ctx.cr[6].eq {
	pc = 0x82AA4218; continue 'dispatch;
	}
	pc = 0x82AA4204; continue 'dispatch;
            }
            0x82AA4204 => {
    //   block [0x82AA4204..0x82AA4218)
	// 82AA4204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4208: 4BFC34F9  bl 0x82a67700
	ctx.lr = 0x82AA420C;
	sub_82A67700(ctx, base);
	// 82AA420C: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4210: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4214: 409AFFF0  bne cr6, 0x82aa4204
	if !ctx.cr[6].eq {
	pc = 0x82AA4204; continue 'dispatch;
	}
	pc = 0x82AA4218; continue 'dispatch;
            }
            0x82AA4218 => {
    //   block [0x82AA4218..0x82AA421C)
	// 82AA4218: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82AA421C; continue 'dispatch;
            }
            0x82AA421C => {
    //   block [0x82AA421C..0x82AA422C)
	// 82AA421C: FB3A0000  std r25, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 82AA4220: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA4224: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA4228: 48205224  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4230 size=92
    let mut pc: u32 = 0x82AA4230;
    'dispatch: loop {
        match pc {
            0x82AA4230 => {
    //   block [0x82AA4230..0x82AA4258)
	// 82AA4230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4234: 482051D9  bl 0x82ca940c
	ctx.lr = 0x82AA4238;
	sub_82CA93D0(ctx, base);
	// 82AA4238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA423C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA4240: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4244: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA4248: 419A002C  beq cr6, 0x82aa4274
	if ctx.cr[6].eq {
	pc = 0x82AA4274; continue 'dispatch;
	}
	// 82AA424C: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4250: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4254: 419A0018  beq cr6, 0x82aa426c
	if ctx.cr[6].eq {
	pc = 0x82AA426C; continue 'dispatch;
	}
	pc = 0x82AA4258; continue 'dispatch;
            }
            0x82AA4258 => {
    //   block [0x82AA4258..0x82AA426C)
	// 82AA4258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA425C: 4BFC34A5  bl 0x82a67700
	ctx.lr = 0x82AA4260;
	sub_82A67700(ctx, base);
	// 82AA4260: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4264: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4268: 409AFFF0  bne cr6, 0x82aa4258
	if !ctx.cr[6].eq {
	pc = 0x82AA4258; continue 'dispatch;
	}
	pc = 0x82AA426C; continue 'dispatch;
            }
            0x82AA426C => {
    //   block [0x82AA426C..0x82AA4274)
	// 82AA426C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4270: 4B777AC9  bl 0x8221bd38
	ctx.lr = 0x82AA4274;
	sub_8221BD38(ctx, base);
	pc = 0x82AA4274; continue 'dispatch;
            }
            0x82AA4274 => {
    //   block [0x82AA4274..0x82AA428C)
	// 82AA4274: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA4278: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AA427C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA4280: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AA4284: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4288: 482051D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4290 size=836
    let mut pc: u32 = 0x82AA4290;
    'dispatch: loop {
        match pc {
            0x82AA4290 => {
    //   block [0x82AA4290..0x82AA42CC)
	// 82AA4290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4294: 48205161  bl 0x82ca93f4
	ctx.lr = 0x82AA4298;
	sub_82CA93D0(ctx, base);
	// 82AA4298: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA429C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA42A0: F8810178  std r4, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[4].u64 ) };
	// 82AA42A4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82AA42A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA42AC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82AA42B0: 48000669  bl 0x82aa4918
	ctx.lr = 0x82AA42B4;
	sub_82AA4918(ctx, base);
	// 82AA42B4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA42B8: 3AE000B4  li r23, 0xb4
	ctx.r[23].s64 = 180;
	// 82AA42BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA42C0: 409A000C  bne cr6, 0x82aa42cc
	if !ctx.cr[6].eq {
	pc = 0x82AA42CC; continue 'dispatch;
	}
	// 82AA42C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA42C8: 48000010  b 0x82aa42d8
	pc = 0x82AA42D8; continue 'dispatch;
            }
            0x82AA42CC => {
    //   block [0x82AA42CC..0x82AA42D8)
	// 82AA42CC: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA42D0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA42D4: 7D29BBD6  divw r9, r9, r23
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[23].s32;
	pc = 0x82AA42D8; continue 'dispatch;
            }
            0x82AA42D8 => {
    //   block [0x82AA42D8..0x82AA4314)
	// 82AA42D8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AA42DC: 419A02E8  beq cr6, 0x82aa45c4
	if ctx.cr[6].eq {
	pc = 0x82AA45C4; continue 'dispatch;
	}
	// 82AA42E0: 83D90008  lwz r30, 8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA42E4: 3D40016C  lis r10, 0x16c
	ctx.r[10].s64 = 23855104;
	// 82AA42E8: 7D0BF050  subf r8, r11, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82AA42EC: 614A16C1  ori r10, r10, 0x16c1
	ctx.r[10].u64 = ctx.r[10].u64 | 5825;
	// 82AA42F0: 7D68BBD6  divw r11, r8, r23
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[23].s32;
	// 82AA42F4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA42F8: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AA42FC: 40980018  bge cr6, 0x82aa4314
	if !ctx.cr[6].lt {
	pc = 0x82AA4314; continue 'dispatch;
	}
	// 82AA4300: 4BFA31C9  bl 0x82a474c8
	ctx.lr = 0x82AA4304;
	sub_82A474C8(ctx, base);
	// 82AA4304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4308: 4BFC33F9  bl 0x82a67700
	ctx.lr = 0x82AA430C;
	sub_82A67700(ctx, base);
	// 82AA430C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82AA4310: 48205134  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA4314 => {
    //   block [0x82AA4314..0x82AA4338)
	// 82AA4314: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82AA4318: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA431C: 40980154  bge cr6, 0x82aa4470
	if !ctx.cr[6].lt {
	pc = 0x82AA4470; continue 'dispatch;
	}
	// 82AA4320: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4324: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82AA4328: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA432C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA4330: 41980008  blt cr6, 0x82aa4338
	if ctx.cr[6].lt {
	pc = 0x82AA4338; continue 'dispatch;
	}
	// 82AA4334: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82AA4338; continue 'dispatch;
            }
            0x82AA4338 => {
    //   block [0x82AA4338..0x82AA4344)
	// 82AA4338: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA433C: 40980008  bge cr6, 0x82aa4344
	if !ctx.cr[6].lt {
	pc = 0x82AA4344; continue 'dispatch;
	}
	// 82AA4340: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x82AA4344; continue 'dispatch;
            }
            0x82AA4344 => {
    //   block [0x82AA4344..0x82AA4368)
	// 82AA4344: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AA4348: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA434C: 48000815  bl 0x82aa4b60
	ctx.lr = 0x82AA4350;
	sub_82AA4B60(ctx, base);
	// 82AA4350: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4354: 8381017C  lwz r28, 0x17c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 82AA4358: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA435C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA4360: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA4364: 419A0028  beq cr6, 0x82aa438c
	if ctx.cr[6].eq {
	pc = 0x82AA438C; continue 'dispatch;
	}
	pc = 0x82AA4368; continue 'dispatch;
            }
            0x82AA4368 => {
    //   block [0x82AA4368..0x82AA437C)
	// 82AA4368: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA436C: 419A0010  beq cr6, 0x82aa437c
	if ctx.cr[6].eq {
	pc = 0x82AA437C; continue 'dispatch;
	}
	// 82AA4370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA4374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4378: 480005A1  bl 0x82aa4918
	ctx.lr = 0x82AA437C;
	sub_82AA4918(ctx, base);
	pc = 0x82AA437C; continue 'dispatch;
            }
            0x82AA437C => {
    //   block [0x82AA437C..0x82AA438C)
	// 82AA437C: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA4380: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4384: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA4388: 409AFFE0  bne cr6, 0x82aa4368
	if !ctx.cr[6].eq {
	pc = 0x82AA4368; continue 'dispatch;
	}
	pc = 0x82AA438C; continue 'dispatch;
            }
            0x82AA438C => {
    //   block [0x82AA438C..0x82AA439C)
	// 82AA438C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82AA4390: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82AA4394: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AA4398: 419A0024  beq cr6, 0x82aa43bc
	if ctx.cr[6].eq {
	pc = 0x82AA43BC; continue 'dispatch;
	}
	pc = 0x82AA439C; continue 'dispatch;
            }
            0x82AA439C => {
    //   block [0x82AA439C..0x82AA43B0)
	// 82AA439C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA43A0: 419A0010  beq cr6, 0x82aa43b0
	if ctx.cr[6].eq {
	pc = 0x82AA43B0; continue 'dispatch;
	}
	// 82AA43A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA43A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA43AC: 4800056D  bl 0x82aa4918
	ctx.lr = 0x82AA43B0;
	sub_82AA4918(ctx, base);
	pc = 0x82AA43B0; continue 'dispatch;
            }
            0x82AA43B0 => {
    //   block [0x82AA43B0..0x82AA43BC)
	// 82AA43B0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AA43B4: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA43B8: 4082FFE4  bne 0x82aa439c
	if !ctx.cr[0].eq {
	pc = 0x82AA439C; continue 'dispatch;
	}
	pc = 0x82AA43BC; continue 'dispatch;
            }
            0x82AA43BC => {
    //   block [0x82AA43BC..0x82AA43DC)
	// 82AA43BC: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA43C0: 1D7A00B4  mulli r11, r26, 0xb4
	ctx.r[11].s32 = ((ctx.r[26].s32 as i64 * 180 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA43C4: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AA43C8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA43CC: 419A0034  beq cr6, 0x82aa4400
	if ctx.cr[6].eq {
	pc = 0x82AA4400; continue 'dispatch;
	}
	// 82AA43D0: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82AA43D4: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82AA43D8: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82AA43DC; continue 'dispatch;
            }
            0x82AA43DC => {
    //   block [0x82AA43DC..0x82AA43F0)
	// 82AA43DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA43E0: 419A0010  beq cr6, 0x82aa43f0
	if ctx.cr[6].eq {
	pc = 0x82AA43F0; continue 'dispatch;
	}
	// 82AA43E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA43E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA43EC: 4800052D  bl 0x82aa4918
	ctx.lr = 0x82AA43F0;
	sub_82AA4918(ctx, base);
	pc = 0x82AA43F0; continue 'dispatch;
            }
            0x82AA43F0 => {
    //   block [0x82AA43F0..0x82AA4400)
	// 82AA43F0: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA43F4: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA43F8: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA43FC: 409AFFE0  bne cr6, 0x82aa43dc
	if !ctx.cr[6].eq {
	pc = 0x82AA43DC; continue 'dispatch;
	}
	pc = 0x82AA4400; continue 'dispatch;
            }
            0x82AA4400 => {
    //   block [0x82AA4400..0x82AA4428)
	// 82AA4400: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4404: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA440C: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82AA4410: 7D4ABBD6  divw r10, r10, r23
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 82AA4414: 7FAAD214  add r29, r10, r26
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82AA4418: 419A002C  beq cr6, 0x82aa4444
	if ctx.cr[6].eq {
	pc = 0x82AA4444; continue 'dispatch;
	}
	// 82AA441C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82AA4420: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA4424: 419A0018  beq cr6, 0x82aa443c
	if ctx.cr[6].eq {
	pc = 0x82AA443C; continue 'dispatch;
	}
	pc = 0x82AA4428; continue 'dispatch;
            }
            0x82AA4428 => {
    //   block [0x82AA4428..0x82AA443C)
	// 82AA4428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA442C: 4BFC32D5  bl 0x82a67700
	ctx.lr = 0x82AA4430;
	sub_82A67700(ctx, base);
	// 82AA4430: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA4434: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA4438: 409AFFF0  bne cr6, 0x82aa4428
	if !ctx.cr[6].eq {
	pc = 0x82AA4428; continue 'dispatch;
	}
	pc = 0x82AA443C; continue 'dispatch;
            }
            0x82AA443C => {
    //   block [0x82AA443C..0x82AA4444)
	// 82AA443C: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4440: 4B7778F9  bl 0x8221bd38
	ctx.lr = 0x82AA4444;
	sub_8221BD38(ctx, base);
	pc = 0x82AA4444; continue 'dispatch;
            }
            0x82AA4444 => {
    //   block [0x82AA4444..0x82AA4470)
	// 82AA4444: 1D7D00B4  mulli r11, r29, 0xb4
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 180 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA4448: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82AA444C: 1D5800B4  mulli r10, r24, 0xb4
	ctx.r[10].s32 = ((ctx.r[24].s32 as i64 * 180 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82AA4450: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82AA4454: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82AA4458: 9159000C  stw r10, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82AA445C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4460: 91390008  stw r9, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82AA4464: 4BFC329D  bl 0x82a67700
	ctx.lr = 0x82AA4468;
	sub_82A67700(ctx, base);
	// 82AA4468: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82AA446C: 48204FD8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA4470 => {
    //   block [0x82AA4470..0x82AA4498)
	// 82AA4470: 8361017C  lwz r27, 0x17c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 82AA4474: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 82AA4478: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82AA447C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AA4480: 409800B8  bge cr6, 0x82aa4538
	if !ctx.cr[6].lt {
	pc = 0x82AA4538; continue 'dispatch;
	}
	// 82AA4484: 1F9A00B4  mulli r28, r26, 0xb4
	ctx.r[28].s32 = ((ctx.r[26].s32 as i64 * 180 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82AA4488: 7FFCDA14  add r31, r28, r27
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82AA448C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4490: 419A002C  beq cr6, 0x82aa44bc
	if ctx.cr[6].eq {
	pc = 0x82AA44BC; continue 'dispatch;
	}
	// 82AA4494: 7FBCF850  subf r29, r28, r31
	ctx.r[29].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	pc = 0x82AA4498; continue 'dispatch;
            }
            0x82AA4498 => {
    //   block [0x82AA4498..0x82AA44AC)
	// 82AA4498: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA449C: 419A0010  beq cr6, 0x82aa44ac
	if ctx.cr[6].eq {
	pc = 0x82AA44AC; continue 'dispatch;
	}
	// 82AA44A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA44A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA44A8: 48000471  bl 0x82aa4918
	ctx.lr = 0x82AA44AC;
	sub_82AA4918(ctx, base);
	pc = 0x82AA44AC; continue 'dispatch;
            }
            0x82AA44AC => {
    //   block [0x82AA44AC..0x82AA44BC)
	// 82AA44AC: 3BBD00B4  addi r29, r29, 0xb4
	ctx.r[29].s64 = ctx.r[29].s64 + 180;
	// 82AA44B0: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA44B4: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA44B8: 409AFFE0  bne cr6, 0x82aa4498
	if !ctx.cr[6].eq {
	pc = 0x82AA4498; continue 'dispatch;
	}
	pc = 0x82AA44BC; continue 'dispatch;
            }
            0x82AA44BC => {
    //   block [0x82AA44BC..0x82AA44D4)
	// 82AA44BC: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA44C0: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82AA44C4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82AA44C8: 7D2ABBD6  divw r9, r10, r23
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 82AA44CC: 7FE9D051  subf. r31, r9, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA44D0: 41820024  beq 0x82aa44f4
	if ctx.cr[0].eq {
	pc = 0x82AA44F4; continue 'dispatch;
	}
	pc = 0x82AA44D4; continue 'dispatch;
            }
            0x82AA44D4 => {
    //   block [0x82AA44D4..0x82AA44E8)
	// 82AA44D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA44D8: 419A0010  beq cr6, 0x82aa44e8
	if ctx.cr[6].eq {
	pc = 0x82AA44E8; continue 'dispatch;
	}
	// 82AA44DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA44E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA44E4: 48000435  bl 0x82aa4918
	ctx.lr = 0x82AA44E8;
	sub_82AA4918(ctx, base);
	pc = 0x82AA44E8; continue 'dispatch;
            }
            0x82AA44E8 => {
    //   block [0x82AA44E8..0x82AA44F4)
	// 82AA44E8: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA44EC: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA44F0: 4082FFE4  bne 0x82aa44d4
	if !ctx.cr[0].eq {
	pc = 0x82AA44D4; continue 'dispatch;
	}
	pc = 0x82AA44F4; continue 'dispatch;
            }
            0x82AA44F4 => {
    //   block [0x82AA44F4..0x82AA4510)
	// 82AA44F4: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA44F8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA44FC: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82AA4500: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82AA4504: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA4508: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA450C: 419A00B8  beq cr6, 0x82aa45c4
	if ctx.cr[6].eq {
	pc = 0x82AA45C4; continue 'dispatch;
	}
	pc = 0x82AA4510; continue 'dispatch;
            }
            0x82AA4510 => {
    //   block [0x82AA4510..0x82AA4538)
	// 82AA4510: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4518: 4BFFB3A9  bl 0x82a9f8c0
	ctx.lr = 0x82AA451C;
	sub_82A9F8C0(ctx, base);
	// 82AA451C: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4520: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4524: 409AFFEC  bne cr6, 0x82aa4510
	if !ctx.cr[6].eq {
	pc = 0x82AA4510; continue 'dispatch;
	}
	// 82AA4528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA452C: 4BFC31D5  bl 0x82a67700
	ctx.lr = 0x82AA4530;
	sub_82A67700(ctx, base);
	// 82AA4530: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82AA4534: 48204F10  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA4538 => {
    //   block [0x82AA4538..0x82AA4550)
	// 82AA4538: 1F5A00B4  mulli r26, r26, 0xb4
	ctx.r[26].s32 = ((ctx.r[26].s32 as i64 * 180 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	// 82AA453C: 7FFAF050  subf r31, r26, r30
	ctx.r[31].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 82AA4540: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82AA4544: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82AA4548: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA454C: 419A0028  beq cr6, 0x82aa4574
	if ctx.cr[6].eq {
	pc = 0x82AA4574; continue 'dispatch;
	}
	pc = 0x82AA4550; continue 'dispatch;
            }
            0x82AA4550 => {
    //   block [0x82AA4550..0x82AA4564)
	// 82AA4550: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AA4554: 419A0010  beq cr6, 0x82aa4564
	if ctx.cr[6].eq {
	pc = 0x82AA4564; continue 'dispatch;
	}
	// 82AA4558: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA455C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA4560: 480003B9  bl 0x82aa4918
	ctx.lr = 0x82AA4564;
	sub_82AA4918(ctx, base);
	pc = 0x82AA4564; continue 'dispatch;
            }
            0x82AA4564 => {
    //   block [0x82AA4564..0x82AA4574)
	// 82AA4564: 3B9C00B4  addi r28, r28, 0xb4
	ctx.r[28].s64 = ctx.r[28].s64 + 180;
	// 82AA4568: 3BBD00B4  addi r29, r29, 0xb4
	ctx.r[29].s64 = ctx.r[29].s64 + 180;
	// 82AA456C: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4570: 409AFFE0  bne cr6, 0x82aa4550
	if !ctx.cr[6].eq {
	pc = 0x82AA4550; continue 'dispatch;
	}
	pc = 0x82AA4574; continue 'dispatch;
            }
            0x82AA4574 => {
    //   block [0x82AA4574..0x82AA4584)
	// 82AA4574: 93B90008  stw r29, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82AA4578: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA457C: 419A0020  beq cr6, 0x82aa459c
	if ctx.cr[6].eq {
	pc = 0x82AA459C; continue 'dispatch;
	}
	// 82AA4580: 7FDFF050  subf r30, r31, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	pc = 0x82AA4584; continue 'dispatch;
            }
            0x82AA4584 => {
    //   block [0x82AA4584..0x82AA459C)
	// 82AA4584: 3BFFFF4C  addi r31, r31, -0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + -180;
	// 82AA4588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA458C: 7C7FF214  add r3, r31, r30
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82AA4590: 4BFFB331  bl 0x82a9f8c0
	ctx.lr = 0x82AA4594;
	sub_82A9F8C0(ctx, base);
	// 82AA4594: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AA4598: 409AFFEC  bne cr6, 0x82aa4584
	if !ctx.cr[6].eq {
	pc = 0x82AA4584; continue 'dispatch;
	}
	pc = 0x82AA459C; continue 'dispatch;
            }
            0x82AA459C => {
    //   block [0x82AA459C..0x82AA45AC)
	// 82AA459C: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82AA45A0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA45A4: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA45A8: 419A001C  beq cr6, 0x82aa45c4
	if ctx.cr[6].eq {
	pc = 0x82AA45C4; continue 'dispatch;
	}
	pc = 0x82AA45AC; continue 'dispatch;
            }
            0x82AA45AC => {
    //   block [0x82AA45AC..0x82AA45C4)
	// 82AA45AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA45B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA45B4: 4BFFB30D  bl 0x82a9f8c0
	ctx.lr = 0x82AA45B8;
	sub_82A9F8C0(ctx, base);
	// 82AA45B8: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA45BC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA45C0: 409AFFEC  bne cr6, 0x82aa45ac
	if !ctx.cr[6].eq {
	pc = 0x82AA45AC; continue 'dispatch;
	}
	pc = 0x82AA45C4; continue 'dispatch;
            }
            0x82AA45C4 => {
    //   block [0x82AA45C4..0x82AA45D4)
	// 82AA45C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA45C8: 4BFC3139  bl 0x82a67700
	ctx.lr = 0x82AA45CC;
	sub_82A67700(ctx, base);
	// 82AA45CC: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82AA45D0: 48204E74  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA45D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA45D8 size=828
    let mut pc: u32 = 0x82AA45D8;
    'dispatch: loop {
        match pc {
            0x82AA45D8 => {
    //   block [0x82AA45D8..0x82AA4610)
	// 82AA45D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA45DC: 48204E1D  bl 0x82ca93f8
	ctx.lr = 0x82AA45E0;
	sub_82CA93D0(ctx, base);
	// 82AA45E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA45E4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA45E8: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82AA45EC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82AA45F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA45F4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82AA45F8: 48000441  bl 0x82aa4a38
	ctx.lr = 0x82AA45FC;
	sub_82AA4A38(ctx, base);
	// 82AA45FC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4604: 409A000C  bne cr6, 0x82aa4610
	if !ctx.cr[6].eq {
	pc = 0x82AA4610; continue 'dispatch;
	}
	// 82AA4608: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA460C: 48000010  b 0x82aa461c
	pc = 0x82AA461C; continue 'dispatch;
            }
            0x82AA4610 => {
    //   block [0x82AA4610..0x82AA461C)
	// 82AA4610: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA4614: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA4618: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	pc = 0x82AA461C; continue 'dispatch;
            }
            0x82AA461C => {
    //   block [0x82AA461C..0x82AA4658)
	// 82AA461C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AA4620: 419A02E4  beq cr6, 0x82aa4904
	if ctx.cr[6].eq {
	pc = 0x82AA4904; continue 'dispatch;
	}
	// 82AA4624: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4628: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 82AA462C: 7D0BE850  subf r8, r11, r29
	ctx.r[8].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82AA4630: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82AA4634: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 82AA4638: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA463C: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AA4640: 40980018  bge cr6, 0x82aa4658
	if !ctx.cr[6].lt {
	pc = 0x82AA4658; continue 'dispatch;
	}
	// 82AA4644: 4BFA2E85  bl 0x82a474c8
	ctx.lr = 0x82AA4648;
	sub_82A474C8(ctx, base);
	// 82AA4648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA464C: 4BFFFBE5  bl 0x82aa4230
	ctx.lr = 0x82AA4650;
	sub_82AA4230(ctx, base);
	// 82AA4650: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA4654: 48204DF4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA4658 => {
    //   block [0x82AA4658..0x82AA467C)
	// 82AA4658: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82AA465C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA4660: 40980154  bge cr6, 0x82aa47b4
	if !ctx.cr[6].lt {
	pc = 0x82AA47B4; continue 'dispatch;
	}
	// 82AA4664: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4668: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82AA466C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA4670: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA4674: 41980008  blt cr6, 0x82aa467c
	if ctx.cr[6].lt {
	pc = 0x82AA467C; continue 'dispatch;
	}
	// 82AA4678: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82AA467C; continue 'dispatch;
            }
            0x82AA467C => {
    //   block [0x82AA467C..0x82AA4688)
	// 82AA467C: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA4680: 40980008  bge cr6, 0x82aa4688
	if !ctx.cr[6].lt {
	pc = 0x82AA4688; continue 'dispatch;
	}
	// 82AA4684: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x82AA4688; continue 'dispatch;
            }
            0x82AA4688 => {
    //   block [0x82AA4688..0x82AA46AC)
	// 82AA4688: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AA468C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA4690: 4B97EBA9  bl 0x82423238
	ctx.lr = 0x82AA4694;
	sub_82423238(ctx, base);
	// 82AA4694: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4698: 838100CC  lwz r28, 0xcc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA469C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA46A0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA46A4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA46A8: 419A0028  beq cr6, 0x82aa46d0
	if ctx.cr[6].eq {
	pc = 0x82AA46D0; continue 'dispatch;
	}
	pc = 0x82AA46AC; continue 'dispatch;
            }
            0x82AA46AC => {
    //   block [0x82AA46AC..0x82AA46C0)
	// 82AA46AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA46B0: 419A0010  beq cr6, 0x82aa46c0
	if ctx.cr[6].eq {
	pc = 0x82AA46C0; continue 'dispatch;
	}
	// 82AA46B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA46B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA46BC: 4800037D  bl 0x82aa4a38
	ctx.lr = 0x82AA46C0;
	sub_82AA4A38(ctx, base);
	pc = 0x82AA46C0; continue 'dispatch;
            }
            0x82AA46C0 => {
    //   block [0x82AA46C0..0x82AA46D0)
	// 82AA46C0: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82AA46C4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA46C8: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA46CC: 409AFFE0  bne cr6, 0x82aa46ac
	if !ctx.cr[6].eq {
	pc = 0x82AA46AC; continue 'dispatch;
	}
	pc = 0x82AA46D0; continue 'dispatch;
            }
            0x82AA46D0 => {
    //   block [0x82AA46D0..0x82AA46E0)
	// 82AA46D0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82AA46D4: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82AA46D8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AA46DC: 419A0024  beq cr6, 0x82aa4700
	if ctx.cr[6].eq {
	pc = 0x82AA4700; continue 'dispatch;
	}
	pc = 0x82AA46E0; continue 'dispatch;
            }
            0x82AA46E0 => {
    //   block [0x82AA46E0..0x82AA46F4)
	// 82AA46E0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA46E4: 419A0010  beq cr6, 0x82aa46f4
	if ctx.cr[6].eq {
	pc = 0x82AA46F4; continue 'dispatch;
	}
	// 82AA46E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA46EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA46F0: 48000349  bl 0x82aa4a38
	ctx.lr = 0x82AA46F4;
	sub_82AA4A38(ctx, base);
	pc = 0x82AA46F4; continue 'dispatch;
            }
            0x82AA46F4 => {
    //   block [0x82AA46F4..0x82AA4700)
	// 82AA46F4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AA46F8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82AA46FC: 4082FFE4  bne 0x82aa46e0
	if !ctx.cr[0].eq {
	pc = 0x82AA46E0; continue 'dispatch;
	}
	pc = 0x82AA4700; continue 'dispatch;
            }
            0x82AA4700 => {
    //   block [0x82AA4700..0x82AA4720)
	// 82AA4700: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4704: 574B2036  slwi r11, r26, 4
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4708: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AA470C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4710: 419A0034  beq cr6, 0x82aa4744
	if ctx.cr[6].eq {
	pc = 0x82AA4744; continue 'dispatch;
	}
	// 82AA4714: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82AA4718: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82AA471C: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82AA4720; continue 'dispatch;
            }
            0x82AA4720 => {
    //   block [0x82AA4720..0x82AA4734)
	// 82AA4720: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA4724: 419A0010  beq cr6, 0x82aa4734
	if ctx.cr[6].eq {
	pc = 0x82AA4734; continue 'dispatch;
	}
	// 82AA4728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA472C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4730: 48000309  bl 0x82aa4a38
	ctx.lr = 0x82AA4734;
	sub_82AA4A38(ctx, base);
	pc = 0x82AA4734; continue 'dispatch;
            }
            0x82AA4734 => {
    //   block [0x82AA4734..0x82AA4744)
	// 82AA4734: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA4738: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82AA473C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4740: 409AFFE0  bne cr6, 0x82aa4720
	if !ctx.cr[6].eq {
	pc = 0x82AA4720; continue 'dispatch;
	}
	pc = 0x82AA4744; continue 'dispatch;
            }
            0x82AA4744 => {
    //   block [0x82AA4744..0x82AA476C)
	// 82AA4744: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4748: 83D90008  lwz r30, 8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA474C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4750: 7D4BF050  subf r10, r11, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82AA4754: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 82AA4758: 7FAAD214  add r29, r10, r26
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82AA475C: 419A002C  beq cr6, 0x82aa4788
	if ctx.cr[6].eq {
	pc = 0x82AA4788; continue 'dispatch;
	}
	// 82AA4760: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82AA4764: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4768: 419A0018  beq cr6, 0x82aa4780
	if ctx.cr[6].eq {
	pc = 0x82AA4780; continue 'dispatch;
	}
	pc = 0x82AA476C; continue 'dispatch;
            }
            0x82AA476C => {
    //   block [0x82AA476C..0x82AA4780)
	// 82AA476C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4770: 4BFFFAC1  bl 0x82aa4230
	ctx.lr = 0x82AA4774;
	sub_82AA4230(ctx, base);
	// 82AA4774: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA4778: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA477C: 409AFFF0  bne cr6, 0x82aa476c
	if !ctx.cr[6].eq {
	pc = 0x82AA476C; continue 'dispatch;
	}
	pc = 0x82AA4780; continue 'dispatch;
            }
            0x82AA4780 => {
    //   block [0x82AA4780..0x82AA4788)
	// 82AA4780: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4784: 4B7775B5  bl 0x8221bd38
	ctx.lr = 0x82AA4788;
	sub_8221BD38(ctx, base);
	pc = 0x82AA4788; continue 'dispatch;
            }
            0x82AA4788 => {
    //   block [0x82AA4788..0x82AA47B4)
	// 82AA4788: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA478C: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82AA4790: 570A2036  slwi r10, r24, 4
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA4794: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82AA4798: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82AA479C: 91390008  stw r9, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82AA47A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA47A4: 9159000C  stw r10, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82AA47A8: 4BFFFA89  bl 0x82aa4230
	ctx.lr = 0x82AA47AC;
	sub_82AA4230(ctx, base);
	// 82AA47AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA47B0: 48204C98  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA47B4 => {
    //   block [0x82AA47B4..0x82AA47DC)
	// 82AA47B4: 836100CC  lwz r27, 0xcc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA47B8: 7D7BE850  subf r11, r27, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 82AA47BC: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82AA47C0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AA47C4: 409800B4  bge cr6, 0x82aa4878
	if !ctx.cr[6].lt {
	pc = 0x82AA4878; continue 'dispatch;
	}
	// 82AA47C8: 575C2036  slwi r28, r26, 4
	ctx.r[28].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82AA47CC: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA47D0: 7FFCDA14  add r31, r28, r27
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82AA47D4: 419A002C  beq cr6, 0x82aa4800
	if ctx.cr[6].eq {
	pc = 0x82AA4800; continue 'dispatch;
	}
	// 82AA47D8: 7FDCF850  subf r30, r28, r31
	ctx.r[30].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	pc = 0x82AA47DC; continue 'dispatch;
            }
            0x82AA47DC => {
    //   block [0x82AA47DC..0x82AA47F0)
	// 82AA47DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA47E0: 419A0010  beq cr6, 0x82aa47f0
	if ctx.cr[6].eq {
	pc = 0x82AA47F0; continue 'dispatch;
	}
	// 82AA47E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA47E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA47EC: 4800024D  bl 0x82aa4a38
	ctx.lr = 0x82AA47F0;
	sub_82AA4A38(ctx, base);
	pc = 0x82AA47F0; continue 'dispatch;
            }
            0x82AA47F0 => {
    //   block [0x82AA47F0..0x82AA4800)
	// 82AA47F0: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82AA47F4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA47F8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA47FC: 409AFFE0  bne cr6, 0x82aa47dc
	if !ctx.cr[6].eq {
	pc = 0x82AA47DC; continue 'dispatch;
	}
	pc = 0x82AA4800; continue 'dispatch;
            }
            0x82AA4800 => {
    //   block [0x82AA4800..0x82AA4814)
	// 82AA4800: 83D90008  lwz r30, 8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4804: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 82AA4808: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82AA480C: 7FEAD051  subf. r31, r10, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA4810: 41820024  beq 0x82aa4834
	if ctx.cr[0].eq {
	pc = 0x82AA4834; continue 'dispatch;
	}
	pc = 0x82AA4814; continue 'dispatch;
            }
            0x82AA4814 => {
    //   block [0x82AA4814..0x82AA4828)
	// 82AA4814: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA4818: 419A0010  beq cr6, 0x82aa4828
	if ctx.cr[6].eq {
	pc = 0x82AA4828; continue 'dispatch;
	}
	// 82AA481C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4824: 48000215  bl 0x82aa4a38
	ctx.lr = 0x82AA4828;
	sub_82AA4A38(ctx, base);
	pc = 0x82AA4828; continue 'dispatch;
            }
            0x82AA4828 => {
    //   block [0x82AA4828..0x82AA4834)
	// 82AA4828: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA482C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82AA4830: 4082FFE4  bne 0x82aa4814
	if !ctx.cr[0].eq {
	pc = 0x82AA4814; continue 'dispatch;
	}
	pc = 0x82AA4834; continue 'dispatch;
            }
            0x82AA4834 => {
    //   block [0x82AA4834..0x82AA4850)
	// 82AA4834: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4838: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA483C: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82AA4840: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82AA4844: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA4848: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA484C: 419A00B8  beq cr6, 0x82aa4904
	if ctx.cr[6].eq {
	pc = 0x82AA4904; continue 'dispatch;
	}
	pc = 0x82AA4850; continue 'dispatch;
            }
            0x82AA4850 => {
    //   block [0x82AA4850..0x82AA4878)
	// 82AA4850: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4858: 48000379  bl 0x82aa4bd0
	ctx.lr = 0x82AA485C;
	sub_82AA4BD0(ctx, base);
	// 82AA485C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA4860: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4864: 409AFFEC  bne cr6, 0x82aa4850
	if !ctx.cr[6].eq {
	pc = 0x82AA4850; continue 'dispatch;
	}
	// 82AA4868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA486C: 4BFFF9C5  bl 0x82aa4230
	ctx.lr = 0x82AA4870;
	sub_82AA4230(ctx, base);
	// 82AA4870: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA4874: 48204BD4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA4878 => {
    //   block [0x82AA4878..0x82AA4890)
	// 82AA4878: 575A2036  slwi r26, r26, 4
	ctx.r[26].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82AA487C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82AA4880: 7FFAE850  subf r31, r26, r29
	ctx.r[31].s64 = ctx.r[29].s64 - ctx.r[26].s64;
	// 82AA4884: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82AA4888: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA488C: 419A0028  beq cr6, 0x82aa48b4
	if ctx.cr[6].eq {
	pc = 0x82AA48B4; continue 'dispatch;
	}
	pc = 0x82AA4890; continue 'dispatch;
            }
            0x82AA4890 => {
    //   block [0x82AA4890..0x82AA48A4)
	// 82AA4890: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA4894: 419A0010  beq cr6, 0x82aa48a4
	if ctx.cr[6].eq {
	pc = 0x82AA48A4; continue 'dispatch;
	}
	// 82AA4898: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA489C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA48A0: 48000199  bl 0x82aa4a38
	ctx.lr = 0x82AA48A4;
	sub_82AA4A38(ctx, base);
	pc = 0x82AA48A4; continue 'dispatch;
            }
            0x82AA48A4 => {
    //   block [0x82AA48A4..0x82AA48B4)
	// 82AA48A4: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 82AA48A8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82AA48AC: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA48B0: 409AFFE0  bne cr6, 0x82aa4890
	if !ctx.cr[6].eq {
	pc = 0x82AA4890; continue 'dispatch;
	}
	pc = 0x82AA48B4; continue 'dispatch;
            }
            0x82AA48B4 => {
    //   block [0x82AA48B4..0x82AA48C4)
	// 82AA48B4: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AA48B8: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA48BC: 419A0020  beq cr6, 0x82aa48dc
	if ctx.cr[6].eq {
	pc = 0x82AA48DC; continue 'dispatch;
	}
	// 82AA48C0: 7FDFE850  subf r30, r31, r29
	ctx.r[30].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	pc = 0x82AA48C4; continue 'dispatch;
            }
            0x82AA48C4 => {
    //   block [0x82AA48C4..0x82AA48DC)
	// 82AA48C4: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 82AA48C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA48CC: 7C7FF214  add r3, r31, r30
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82AA48D0: 48000301  bl 0x82aa4bd0
	ctx.lr = 0x82AA48D4;
	sub_82AA4BD0(ctx, base);
	// 82AA48D4: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AA48D8: 409AFFEC  bne cr6, 0x82aa48c4
	if !ctx.cr[6].eq {
	pc = 0x82AA48C4; continue 'dispatch;
	}
	pc = 0x82AA48DC; continue 'dispatch;
            }
            0x82AA48DC => {
    //   block [0x82AA48DC..0x82AA48EC)
	// 82AA48DC: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82AA48E0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA48E4: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA48E8: 419A001C  beq cr6, 0x82aa4904
	if ctx.cr[6].eq {
	pc = 0x82AA4904; continue 'dispatch;
	}
	pc = 0x82AA48EC; continue 'dispatch;
            }
            0x82AA48EC => {
    //   block [0x82AA48EC..0x82AA4904)
	// 82AA48EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA48F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA48F4: 480002DD  bl 0x82aa4bd0
	ctx.lr = 0x82AA48F8;
	sub_82AA4BD0(ctx, base);
	// 82AA48F8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA48FC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4900: 409AFFEC  bne cr6, 0x82aa48ec
	if !ctx.cr[6].eq {
	pc = 0x82AA48EC; continue 'dispatch;
	}
	pc = 0x82AA4904; continue 'dispatch;
            }
            0x82AA4904 => {
    //   block [0x82AA4904..0x82AA4914)
	// 82AA4904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4908: 4BFFF929  bl 0x82aa4230
	ctx.lr = 0x82AA490C;
	sub_82AA4230(ctx, base);
	// 82AA490C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA4910: 48204B38  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4918 size=284
    let mut pc: u32 = 0x82AA4918;
    'dispatch: loop {
        match pc {
            0x82AA4918 => {
    //   block [0x82AA4918..0x82AA494C)
	// 82AA4918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA491C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA4924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA492C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA4930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4934: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82AA4938: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82AA493C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82AA4940: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4944: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AA4948: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x82AA494C; continue 'dispatch;
            }
            0x82AA494C => {
    //   block [0x82AA494C..0x82AA4960)
	// 82AA494C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4950: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA4954: 7D48592E  stwx r10, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82AA4958: 419A0024  beq cr6, 0x82aa497c
	if ctx.cr[6].eq {
	pc = 0x82AA497C; continue 'dispatch;
	}
	// 82AA495C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x82AA4960; continue 'dispatch;
            }
            0x82AA4960 => {
    //   block [0x82AA4960..0x82AA497C)
	// 82AA4960: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82AA4964: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA4968: 7CE05028  lwarx r7, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82AA496C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82AA4970: 7CE0512D  stwcx. r7, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA4974: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA4978: 4082FFE8  bne 0x82aa4960
	if !ctx.cr[0].eq {
	pc = 0x82AA4960; continue 'dispatch;
	}
	pc = 0x82AA497C; continue 'dispatch;
            }
            0x82AA497C => {
    //   block [0x82AA497C..0x82AA49AC)
	// 82AA497C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AA4980: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA4984: 4080FFC8  bge 0x82aa494c
	if !ctx.cr[0].lt {
	pc = 0x82AA494C; continue 'dispatch;
	}
	// 82AA4988: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82AA498C: 389E001C  addi r4, r30, 0x1c
	ctx.r[4].s64 = ctx.r[30].s64 + 28;
	// 82AA4990: 38A00078  li r5, 0x78
	ctx.r[5].s64 = 120;
	// 82AA4994: 48204AED  bl 0x82ca9480
	ctx.lr = 0x82AA4998;
	sub_82CA9480(ctx, base);
	// 82AA4998: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA499C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA49A0: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82AA49A4: 419A0024  beq cr6, 0x82aa49c8
	if ctx.cr[6].eq {
	pc = 0x82AA49C8; continue 'dispatch;
	}
	// 82AA49A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82AA49AC; continue 'dispatch;
            }
            0x82AA49AC => {
    //   block [0x82AA49AC..0x82AA49C8)
	// 82AA49AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA49B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA49B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA49B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA49BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA49C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA49C4: 4082FFE8  bne 0x82aa49ac
	if !ctx.cr[0].eq {
	pc = 0x82AA49AC; continue 'dispatch;
	}
	pc = 0x82AA49C8; continue 'dispatch;
            }
            0x82AA49C8 => {
    //   block [0x82AA49C8..0x82AA4A34)
	// 82AA49C8: 897E0098  lbz r11, 0x98(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA49CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA49D0: 997F0098  stb r11, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 82AA49D4: 895E0099  lbz r10, 0x99(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(153 as u32) ) } as u64;
	// 82AA49D8: 995F0099  stb r10, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[10].u8 ) };
	// 82AA49DC: 893E009A  lbz r9, 0x9a(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(154 as u32) ) } as u64;
	// 82AA49E0: 993F009A  stb r9, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[9].u8 ) };
	// 82AA49E4: 891E009B  lbz r8, 0x9b(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(155 as u32) ) } as u64;
	// 82AA49E8: 991F009B  stb r8, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[8].u8 ) };
	// 82AA49EC: 80FE009C  lwz r7, 0x9c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AA49F0: 90FF009C  stw r7, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[7].u32 ) };
	// 82AA49F4: 80DE00A0  lwz r6, 0xa0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 82AA49F8: 90DF00A0  stw r6, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[6].u32 ) };
	// 82AA49FC: 80BE00A4  lwz r5, 0xa4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA4A00: 90BF00A4  stw r5, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82AA4A04: 809E00A8  lwz r4, 0xa8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 82AA4A08: 909F00A8  stw r4, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[4].u32 ) };
	// 82AA4A0C: 817E00AC  lwz r11, 0xac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 82AA4A10: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82AA4A14: 815E00B0  lwz r10, 0xb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AA4A18: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 82AA4A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA4A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA4A28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA4A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4A38 size=180
    let mut pc: u32 = 0x82AA4A38;
    'dispatch: loop {
        match pc {
            0x82AA4A38 => {
    //   block [0x82AA4A38..0x82AA4A7C)
	// 82AA4A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4A3C: 482049CD  bl 0x82ca9408
	ctx.lr = 0x82AA4A40;
	sub_82CA93D0(ctx, base);
	// 82AA4A40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4A44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA4A48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA4A4C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA4A50: 394000B4  li r10, 0xb4
	ctx.r[10].s64 = 180;
	// 82AA4A54: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4A58: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4A5C: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AA4A60: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82AA4A64: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AA4A68: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AA4A6C: 7C8853D7  divw. r4, r8, r10
	ctx.r[4].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AA4A70: 4082000C  bne 0x82aa4a7c
	if !ctx.cr[0].eq {
	pc = 0x82AA4A7C; continue 'dispatch;
	}
	// 82AA4A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4A78: 4800000C  b 0x82aa4a84
	pc = 0x82AA4A84; continue 'dispatch;
            }
            0x82AA4A7C => {
    //   block [0x82AA4A7C..0x82AA4A84)
	// 82AA4A7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA4A80: 48000071  bl 0x82aa4af0
	ctx.lr = 0x82AA4A84;
	sub_82AA4AF0(ctx, base);
	pc = 0x82AA4A84; continue 'dispatch;
            }
            0x82AA4A84 => {
    //   block [0x82AA4A84..0x82AA4AB8)
	// 82AA4A84: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AA4A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4A8C: 419A0054  beq cr6, 0x82aa4ae0
	if ctx.cr[6].eq {
	pc = 0x82AA4AE0; continue 'dispatch;
	}
	// 82AA4A90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4A94: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4A98: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AA4A9C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA4AA0: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4AA4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA4AA8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA4AAC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82AA4AB0: 419A002C  beq cr6, 0x82aa4adc
	if ctx.cr[6].eq {
	pc = 0x82AA4ADC; continue 'dispatch;
	}
	// 82AA4AB4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82AA4AB8; continue 'dispatch;
            }
            0x82AA4AB8 => {
    //   block [0x82AA4AB8..0x82AA4ACC)
	// 82AA4AB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA4ABC: 419A0010  beq cr6, 0x82aa4acc
	if ctx.cr[6].eq {
	pc = 0x82AA4ACC; continue 'dispatch;
	}
	// 82AA4AC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA4AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4AC8: 4BFFFE51  bl 0x82aa4918
	ctx.lr = 0x82AA4ACC;
	sub_82AA4918(ctx, base);
	pc = 0x82AA4ACC; continue 'dispatch;
            }
            0x82AA4ACC => {
    //   block [0x82AA4ACC..0x82AA4ADC)
	// 82AA4ACC: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA4AD0: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4AD4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA4AD8: 409AFFE0  bne cr6, 0x82aa4ab8
	if !ctx.cr[6].eq {
	pc = 0x82AA4AB8; continue 'dispatch;
	}
	pc = 0x82AA4ADC; continue 'dispatch;
            }
            0x82AA4ADC => {
    //   block [0x82AA4ADC..0x82AA4AE0)
	// 82AA4ADC: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82AA4AE0; continue 'dispatch;
            }
            0x82AA4AE0 => {
    //   block [0x82AA4AE0..0x82AA4AEC)
	// 82AA4AE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA4AE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA4AE8: 48204970  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4AF0 size=112
    let mut pc: u32 = 0x82AA4AF0;
    'dispatch: loop {
        match pc {
            0x82AA4AF0 => {
    //   block [0x82AA4AF0..0x82AA4B24)
	// 82AA4AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA4AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4B00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4B04: 3D60016C  lis r11, 0x16c
	ctx.r[11].s64 = 23855104;
	// 82AA4B08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA4B0C: 616A16C1  ori r10, r11, 0x16c1
	ctx.r[10].u64 = ctx.r[11].u64 | 5825;
	// 82AA4B10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4B14: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA4B18: 4099000C  ble cr6, 0x82aa4b24
	if !ctx.cr[6].gt {
	pc = 0x82AA4B24; continue 'dispatch;
	}
	// 82AA4B1C: 4BFA29AD  bl 0x82a474c8
	ctx.lr = 0x82AA4B20;
	sub_82A474C8(ctx, base);
	// 82AA4B20: 48000024  b 0x82aa4b44
	pc = 0x82AA4B44; continue 'dispatch;
            }
            0x82AA4B24 => {
    //   block [0x82AA4B24..0x82AA4B44)
	// 82AA4B24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA4B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4B2C: 48000035  bl 0x82aa4b60
	ctx.lr = 0x82AA4B30;
	sub_82AA4B60(ctx, base);
	// 82AA4B30: 1D7E00B4  mulli r11, r30, 0xb4
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 180 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA4B34: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82AA4B38: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AA4B3C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82AA4B40: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82AA4B44; continue 'dispatch;
            }
            0x82AA4B44 => {
    //   block [0x82AA4B44..0x82AA4B60)
	// 82AA4B44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA4B48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA4B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA4B54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA4B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4B60 size=112
    let mut pc: u32 = 0x82AA4B60;
    'dispatch: loop {
        match pc {
            0x82AA4B60 => {
    //   block [0x82AA4B60..0x82AA4BB4)
	// 82AA4B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4B68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4B6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4B70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA4B74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA4B78: 419A003C  beq cr6, 0x82aa4bb4
	if ctx.cr[6].eq {
	pc = 0x82AA4BB4; continue 'dispatch;
	}
	// 82AA4B7C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82AA4B80: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82AA4B84: 2B0A00B4  cmplwi cr6, r10, 0xb4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 180 as u32, &mut ctx.xer);
	// 82AA4B88: 4098002C  bge cr6, 0x82aa4bb4
	if !ctx.cr[6].lt {
	pc = 0x82AA4BB4; continue 'dispatch;
	}
	// 82AA4B8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA4B90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA4B94: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82AA4B98: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA4B9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4BA0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AA4BA4: 4B84D27D  bl 0x822f1e20
	ctx.lr = 0x82AA4BA8;
	sub_822F1E20(ctx, base);
	// 82AA4BA8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82AA4BAC: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82AA4BB0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82AA4BB4; continue 'dispatch;
            }
            0x82AA4BB4 => {
    //   block [0x82AA4BB4..0x82AA4BD0)
	// 82AA4BB4: 1C7F00B4  mulli r3, r31, 0xb4
	ctx.r[3].s32 = ((ctx.r[31].s32 as i64 * 180 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82AA4BB8: 4B77A6A1  bl 0x8221f258
	ctx.lr = 0x82AA4BBC;
	sub_8221F258(ctx, base);
	// 82AA4BBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4BC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA4BC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA4BC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4BCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4BD0 size=608
    let mut pc: u32 = 0x82AA4BD0;
    'dispatch: loop {
        match pc {
            0x82AA4BD0 => {
    //   block [0x82AA4BD0..0x82AA4C40)
	// 82AA4BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4BD4: 48204829  bl 0x82ca93fc
	ctx.lr = 0x82AA4BD8;
	sub_82CA93D0(ctx, base);
	// 82AA4BD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4BDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA4BE0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82AA4BE4: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82AA4BE8: 419A023C  beq cr6, 0x82aa4e24
	if ctx.cr[6].eq {
	pc = 0x82AA4E24; continue 'dispatch;
	}
	// 82AA4BEC: 83D90008  lwz r30, 8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4BF0: 3B4000B4  li r26, 0xb4
	ctx.r[26].s64 = 180;
	// 82AA4BF4: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4BF8: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82AA4BFC: 7D2BD3D7  divw. r9, r11, r26
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AA4C00: 40820040  bne 0x82aa4c40
	if !ctx.cr[0].eq {
	pc = 0x82AA4C40; continue 'dispatch;
	}
	// 82AA4C04: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4C08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA4C0C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4C10: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA4C14: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82AA4C18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA4C1C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AA4C20: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA4C24: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA4C28: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA4C2C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA4C30: 4BFFF559  bl 0x82aa4188
	ctx.lr = 0x82AA4C34;
	sub_82AA4188(ctx, base);
	// 82AA4C34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA4C38: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA4C3C: 48204810  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA4C40 => {
    //   block [0x82AA4C40..0x82AA4C74)
	// 82AA4C40: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4C44: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4C48: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82AA4C4C: 7D4AD3D6  divw r10, r10, r26
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 82AA4C50: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA4C54: 41990088  bgt cr6, 0x82aa4cdc
	if ctx.cr[6].gt {
	pc = 0x82AA4CDC; continue 'dispatch;
	}
	// 82AA4C58: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82AA4C5C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4C60: 7D2AD3D6  divw r9, r10, r26
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 82AA4C64: 1D4900B4  mulli r10, r9, 0xb4
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 180 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82AA4C68: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA4C6C: 419A0020  beq cr6, 0x82aa4c8c
	if ctx.cr[6].eq {
	pc = 0x82AA4C8C; continue 'dispatch;
	}
	// 82AA4C70: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82AA4C74; continue 'dispatch;
            }
            0x82AA4C74 => {
    //   block [0x82AA4C74..0x82AA4C8C)
	// 82AA4C74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4C78: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82AA4C7C: 4BFFAC45  bl 0x82a9f8c0
	ctx.lr = 0x82AA4C80;
	sub_82A9F8C0(ctx, base);
	// 82AA4C80: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4C84: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4C88: 409AFFEC  bne cr6, 0x82aa4c74
	if !ctx.cr[6].eq {
	pc = 0x82AA4C74; continue 'dispatch;
	}
	pc = 0x82AA4C8C; continue 'dispatch;
            }
            0x82AA4C8C => {
    //   block [0x82AA4C8C..0x82AA4C9C)
	// 82AA4C8C: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4C90: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AA4C94: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4C98: 419A0018  beq cr6, 0x82aa4cb0
	if ctx.cr[6].eq {
	pc = 0x82AA4CB0; continue 'dispatch;
	}
	pc = 0x82AA4C9C; continue 'dispatch;
            }
            0x82AA4C9C => {
    //   block [0x82AA4C9C..0x82AA4CB0)
	// 82AA4C9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4CA0: 4BFC2A61  bl 0x82a67700
	ctx.lr = 0x82AA4CA4;
	sub_82A67700(ctx, base);
	// 82AA4CA4: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4CA8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA4CAC: 409AFFF0  bne cr6, 0x82aa4c9c
	if !ctx.cr[6].eq {
	pc = 0x82AA4C9C; continue 'dispatch;
	}
	pc = 0x82AA4CB0; continue 'dispatch;
            }
            0x82AA4CB0 => {
    //   block [0x82AA4CB0..0x82AA4CDC)
	// 82AA4CB0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4CB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA4CB8: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4CBC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4CC0: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82AA4CC4: 7CE8D3D6  divw r7, r8, r26
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[26].s32;
	// 82AA4CC8: 1D6700B4  mulli r11, r7, 0xb4
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * 180 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AA4CCC: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AA4CD0: 90DC0008  stw r6, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82AA4CD4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA4CD8: 48204774  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA4CDC => {
    //   block [0x82AA4CDC..0x82AA4CF0)
	// 82AA4CDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA4CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4CE4: 409A000C  bne cr6, 0x82aa4cf0
	if !ctx.cr[6].eq {
	pc = 0x82AA4CF0; continue 'dispatch;
	}
	// 82AA4CE8: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82AA4CEC: 48000010  b 0x82aa4cfc
	pc = 0x82AA4CFC; continue 'dispatch;
            }
            0x82AA4CF0 => {
    //   block [0x82AA4CF0..0x82AA4CFC)
	// 82AA4CF0: 811C000C  lwz r8, 0xc(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA4CF4: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82AA4CF8: 7D07D3D6  divw r8, r7, r26
	ctx.r[8].s32 = ctx.r[7].s32 / ctx.r[26].s32;
	pc = 0x82AA4CFC; continue 'dispatch;
            }
            0x82AA4CFC => {
    //   block [0x82AA4CFC..0x82AA4D1C)
	// 82AA4CFC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA4D00: 4199007C  bgt cr6, 0x82aa4d7c
	if ctx.cr[6].gt {
	pc = 0x82AA4D7C; continue 'dispatch;
	}
	// 82AA4D04: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4D08: 1D4A00B4  mulli r10, r10, 0xb4
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 180 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82AA4D0C: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82AA4D10: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82AA4D14: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA4D18: 419A0020  beq cr6, 0x82aa4d38
	if ctx.cr[6].eq {
	pc = 0x82AA4D38; continue 'dispatch;
	}
	pc = 0x82AA4D1C; continue 'dispatch;
            }
            0x82AA4D1C => {
    //   block [0x82AA4D1C..0x82AA4D38)
	// 82AA4D1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA4D20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA4D24: 4BFFAB9D  bl 0x82a9f8c0
	ctx.lr = 0x82AA4D28;
	sub_82A9F8C0(ctx, base);
	// 82AA4D28: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA4D2C: 3BBD00B4  addi r29, r29, 0xb4
	ctx.r[29].s64 = ctx.r[29].s64 + 180;
	// 82AA4D30: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA4D34: 409AFFE8  bne cr6, 0x82aa4d1c
	if !ctx.cr[6].eq {
	pc = 0x82AA4D1C; continue 'dispatch;
	}
	pc = 0x82AA4D38; continue 'dispatch;
            }
            0x82AA4D38 => {
    //   block [0x82AA4D38..0x82AA4D48)
	// 82AA4D38: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4D3C: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4D40: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4D44: 419A00DC  beq cr6, 0x82aa4e20
	if ctx.cr[6].eq {
	pc = 0x82AA4E20; continue 'dispatch;
	}
	pc = 0x82AA4D48; continue 'dispatch;
            }
            0x82AA4D48 => {
    //   block [0x82AA4D48..0x82AA4D5C)
	// 82AA4D48: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA4D4C: 419A0010  beq cr6, 0x82aa4d5c
	if ctx.cr[6].eq {
	pc = 0x82AA4D5C; continue 'dispatch;
	}
	// 82AA4D50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4D58: 4BFFFBC1  bl 0x82aa4918
	ctx.lr = 0x82AA4D5C;
	sub_82AA4918(ctx, base);
	pc = 0x82AA4D5C; continue 'dispatch;
            }
            0x82AA4D5C => {
    //   block [0x82AA4D5C..0x82AA4D7C)
	// 82AA4D5C: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4D60: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA4D64: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4D68: 409AFFE0  bne cr6, 0x82aa4d48
	if !ctx.cr[6].eq {
	pc = 0x82AA4D48; continue 'dispatch;
	}
	// 82AA4D6C: 93DC0008  stw r30, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AA4D70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA4D74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA4D78: 482046D4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA4D7C => {
    //   block [0x82AA4D7C..0x82AA4D90)
	// 82AA4D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4D80: 419A002C  beq cr6, 0x82aa4dac
	if ctx.cr[6].eq {
	pc = 0x82AA4DAC; continue 'dispatch;
	}
	// 82AA4D84: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82AA4D88: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4D8C: 419A0018  beq cr6, 0x82aa4da4
	if ctx.cr[6].eq {
	pc = 0x82AA4DA4; continue 'dispatch;
	}
	pc = 0x82AA4D90; continue 'dispatch;
            }
            0x82AA4D90 => {
    //   block [0x82AA4D90..0x82AA4DA4)
	// 82AA4D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4D94: 4BFC296D  bl 0x82a67700
	ctx.lr = 0x82AA4D98;
	sub_82A67700(ctx, base);
	// 82AA4D98: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4D9C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4DA0: 409AFFF0  bne cr6, 0x82aa4d90
	if !ctx.cr[6].eq {
	pc = 0x82AA4D90; continue 'dispatch;
	}
	pc = 0x82AA4DA4; continue 'dispatch;
            }
            0x82AA4DA4 => {
    //   block [0x82AA4DA4..0x82AA4DAC)
	// 82AA4DA4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4DA8: 4B776F91  bl 0x8221bd38
	ctx.lr = 0x82AA4DAC;
	sub_8221BD38(ctx, base);
	pc = 0x82AA4DAC; continue 'dispatch;
            }
            0x82AA4DAC => {
    //   block [0x82AA4DAC..0x82AA4DD4)
	// 82AA4DAC: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4DB0: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4DB4: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AA4DB8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA4DBC: 93DC0008  stw r30, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AA4DC0: 93DC000C  stw r30, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AA4DC4: 7C89D3D7  divw. r4, r9, r26
	ctx.r[4].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AA4DC8: 4082000C  bne 0x82aa4dd4
	if !ctx.cr[0].eq {
	pc = 0x82AA4DD4; continue 'dispatch;
	}
	// 82AA4DCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4DD0: 4800000C  b 0x82aa4ddc
	pc = 0x82AA4DDC; continue 'dispatch;
            }
            0x82AA4DD4 => {
    //   block [0x82AA4DD4..0x82AA4DDC)
	// 82AA4DD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA4DD8: 4BFFFD19  bl 0x82aa4af0
	ctx.lr = 0x82AA4DDC;
	sub_82AA4AF0(ctx, base);
	pc = 0x82AA4DDC; continue 'dispatch;
            }
            0x82AA4DDC => {
    //   block [0x82AA4DDC..0x82AA4DFC)
	// 82AA4DDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AA4DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4DE4: 419A0040  beq cr6, 0x82aa4e24
	if ctx.cr[6].eq {
	pc = 0x82AA4E24; continue 'dispatch;
	}
	// 82AA4DE8: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4DEC: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4DF0: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4DF4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4DF8: 419A0028  beq cr6, 0x82aa4e20
	if ctx.cr[6].eq {
	pc = 0x82AA4E20; continue 'dispatch;
	}
	pc = 0x82AA4DFC; continue 'dispatch;
            }
            0x82AA4DFC => {
    //   block [0x82AA4DFC..0x82AA4E10)
	// 82AA4DFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA4E00: 419A0010  beq cr6, 0x82aa4e10
	if ctx.cr[6].eq {
	pc = 0x82AA4E10; continue 'dispatch;
	}
	// 82AA4E04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4E08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4E0C: 4BFFFB0D  bl 0x82aa4918
	ctx.lr = 0x82AA4E10;
	sub_82AA4918(ctx, base);
	pc = 0x82AA4E10; continue 'dispatch;
            }
            0x82AA4E10 => {
    //   block [0x82AA4E10..0x82AA4E20)
	// 82AA4E10: 3BFF00B4  addi r31, r31, 0xb4
	ctx.r[31].s64 = ctx.r[31].s64 + 180;
	// 82AA4E14: 3BDE00B4  addi r30, r30, 0xb4
	ctx.r[30].s64 = ctx.r[30].s64 + 180;
	// 82AA4E18: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA4E1C: 409AFFE0  bne cr6, 0x82aa4dfc
	if !ctx.cr[6].eq {
	pc = 0x82AA4DFC; continue 'dispatch;
	}
	pc = 0x82AA4E20; continue 'dispatch;
            }
            0x82AA4E20 => {
    //   block [0x82AA4E20..0x82AA4E24)
	// 82AA4E20: 93DC0008  stw r30, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82AA4E24; continue 'dispatch;
            }
            0x82AA4E24 => {
    //   block [0x82AA4E24..0x82AA4E30)
	// 82AA4E24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA4E28: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA4E2C: 48204620  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4E30 size=396
    let mut pc: u32 = 0x82AA4E30;
    'dispatch: loop {
        match pc {
            0x82AA4E30 => {
    //   block [0x82AA4E30..0x82AA4E6C)
	// 82AA4E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4E34: 482045C9  bl 0x82ca93fc
	ctx.lr = 0x82AA4E38;
	sub_82CA93D0(ctx, base);
	// 82AA4E38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4E3C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA4E40: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4E44: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82AA4E48: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA4E4C: 419A0044  beq cr6, 0x82aa4e90
	if ctx.cr[6].eq {
	pc = 0x82AA4E90; continue 'dispatch;
	}
	// 82AA4E50: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AA4E54: 4B77A405  bl 0x8221f258
	ctx.lr = 0x82AA4E58;
	sub_8221F258(ctx, base);
	// 82AA4E58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4E5C: 419A0010  beq cr6, 0x82aa4e6c
	if ctx.cr[6].eq {
	pc = 0x82AA4E6C; continue 'dispatch;
	}
	// 82AA4E60: 480C2391  bl 0x82b671f0
	ctx.lr = 0x82AA4E64;
	sub_82B671F0(ctx, base);
	// 82AA4E64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA4E68: 48000008  b 0x82aa4e70
	pc = 0x82AA4E70; continue 'dispatch;
            }
            0x82AA4E6C => {
    //   block [0x82AA4E6C..0x82AA4E70)
	// 82AA4E6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82AA4E70; continue 'dispatch;
            }
            0x82AA4E70 => {
    //   block [0x82AA4E70..0x82AA4E90)
	// 82AA4E70: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 82AA4E74: 387F5F74  addi r3, r31, 0x5f74
	ctx.r[3].s64 = ctx.r[31].s64 + 24436;
	// 82AA4E78: 480C4331  bl 0x82b691a8
	ctx.lr = 0x82AA4E7C;
	sub_82B691A8(ctx, base);
	// 82AA4E7C: 817F5F74  lwz r11, 0x5f74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24436 as u32) ) } as u64;
	// 82AA4E80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA4E84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA4E88: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4E8C: 480C1CCD  bl 0x82b66b58
	ctx.lr = 0x82AA4E90;
	sub_82B66B58(ctx, base);
	pc = 0x82AA4E90; continue 'dispatch;
            }
            0x82AA4E90 => {
    //   block [0x82AA4E90..0x82AA4ECC)
	// 82AA4E90: 813B001C  lwz r9, 0x1c(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA4E94: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82AA4E98: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AA4E9C: 3BBB001C  addi r29, r27, 0x1c
	ctx.r[29].s64 = ctx.r[27].s64 + 28;
	// 82AA4EA0: 3B4A570C  addi r26, r10, 0x570c
	ctx.r[26].s64 = ctx.r[10].s64 + 22284;
	// 82AA4EA4: 3B2B5710  addi r25, r11, 0x5710
	ctx.r[25].s64 = ctx.r[11].s64 + 22288;
	// 82AA4EA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA4EAC: 4099009C  ble cr6, 0x82aa4f48
	if !ctx.cr[6].gt {
	pc = 0x82AA4F48; continue 'dispatch;
	}
	// 82AA4EB0: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82AA4EB4: 4B77A3A5  bl 0x8221f258
	ctx.lr = 0x82AA4EB8;
	sub_8221F258(ctx, base);
	// 82AA4EB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4EBC: 419A0010  beq cr6, 0x82aa4ecc
	if ctx.cr[6].eq {
	pc = 0x82AA4ECC; continue 'dispatch;
	}
	// 82AA4EC0: 480CB911  bl 0x82b707d0
	ctx.lr = 0x82AA4EC4;
	sub_82B707D0(ctx, base);
	// 82AA4EC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4EC8: 48000008  b 0x82aa4ed0
	pc = 0x82AA4ED0; continue 'dispatch;
            }
            0x82AA4ECC => {
    //   block [0x82AA4ECC..0x82AA4ED0)
	// 82AA4ECC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82AA4ED0; continue 'dispatch;
            }
            0x82AA4ED0 => {
    //   block [0x82AA4ED0..0x82AA4EF0)
	// 82AA4ED0: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 82AA4ED4: 839E5708  lwz r28, 0x5708(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(22280 as u32) ) } as u64;
	// 82AA4ED8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AA4EDC: 419A0014  beq cr6, 0x82aa4ef0
	if ctx.cr[6].eq {
	pc = 0x82AA4EF0; continue 'dispatch;
	}
	// 82AA4EE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA4EE4: 480D34BD  bl 0x82b783a0
	ctx.lr = 0x82AA4EE8;
	sub_82B783A0(ctx, base);
	// 82AA4EE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA4EEC: 4B776E4D  bl 0x8221bd38
	ctx.lr = 0x82AA4EF0;
	sub_8221BD38(ctx, base);
	pc = 0x82AA4EF0; continue 'dispatch;
            }
            0x82AA4EF0 => {
    //   block [0x82AA4EF0..0x82AA4F48)
	// 82AA4EF0: 93FE5708  stw r31, 0x5708(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(22280 as u32), ctx.r[31].u32 ) };
	// 82AA4EF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA4EF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4F00: 4B750DC1  bl 0x821f5cc0
	ctx.lr = 0x82AA4F04;
	sub_821F5CC0(ctx, base);
	// 82AA4F04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA4F08: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA4F0C: 4B6E90AD  bl 0x8218dfb8
	ctx.lr = 0x82AA4F10;
	sub_8218DFB8(ctx, base);
	// 82AA4F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4F14: 4B78CDA5  bl 0x82231cb8
	ctx.lr = 0x82AA4F18;
	sub_82231CB8(ctx, base);
	// 82AA4F18: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AA4F1C: 38BB0020  addi r5, r27, 0x20
	ctx.r[5].s64 = ctx.r[27].s64 + 32;
	// 82AA4F20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4F24: 40990024  ble cr6, 0x82aa4f48
	if !ctx.cr[6].gt {
	pc = 0x82AA4F48; continue 'dispatch;
	}
	// 82AA4F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4F2C: 809E5708  lwz r4, 0x5708(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(22280 as u32) ) } as u64;
	// 82AA4F30: 4B750D91  bl 0x821f5cc0
	ctx.lr = 0x82AA4F34;
	sub_821F5CC0(ctx, base);
	// 82AA4F34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA4F38: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA4F3C: 4B6E907D  bl 0x8218dfb8
	ctx.lr = 0x82AA4F40;
	sub_8218DFB8(ctx, base);
	// 82AA4F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4F44: 4B78CD75  bl 0x82231cb8
	ctx.lr = 0x82AA4F48;
	sub_82231CB8(ctx, base);
	pc = 0x82AA4F48; continue 'dispatch;
            }
            0x82AA4F48 => {
    //   block [0x82AA4F48..0x82AA4F5C)
	// 82AA4F48: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4F50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA4F54: 419A0024  beq cr6, 0x82aa4f78
	if ctx.cr[6].eq {
	pc = 0x82AA4F78; continue 'dispatch;
	}
	// 82AA4F58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82AA4F5C; continue 'dispatch;
            }
            0x82AA4F5C => {
    //   block [0x82AA4F5C..0x82AA4F78)
	// 82AA4F5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA4F60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA4F64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA4F68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA4F6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA4F70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA4F74: 4082FFE8  bne 0x82aa4f5c
	if !ctx.cr[0].eq {
	pc = 0x82AA4F5C; continue 'dispatch;
	}
	pc = 0x82AA4F78; continue 'dispatch;
            }
            0x82AA4F78 => {
    //   block [0x82AA4F78..0x82AA4F8C)
	// 82AA4F78: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4F80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA4F84: 419A0024  beq cr6, 0x82aa4fa8
	if ctx.cr[6].eq {
	pc = 0x82AA4FA8; continue 'dispatch;
	}
	// 82AA4F88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82AA4F8C; continue 'dispatch;
            }
            0x82AA4F8C => {
    //   block [0x82AA4F8C..0x82AA4FA8)
	// 82AA4F8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA4F90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA4F94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA4F98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA4F9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA4FA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA4FA4: 4082FFE8  bne 0x82aa4f8c
	if !ctx.cr[0].eq {
	pc = 0x82AA4F8C; continue 'dispatch;
	}
	pc = 0x82AA4FA8; continue 'dispatch;
            }
            0x82AA4FA8 => {
    //   block [0x82AA4FA8..0x82AA4FBC)
	// 82AA4FA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4FAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA4FB0: 480051C9  bl 0x82aaa178
	ctx.lr = 0x82AA4FB4;
	sub_82AAA178(ctx, base);
	// 82AA4FB4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA4FB8: 48204494  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4FC0 size=428
    let mut pc: u32 = 0x82AA4FC0;
    'dispatch: loop {
        match pc {
            0x82AA4FC0 => {
    //   block [0x82AA4FC0..0x82AA5160)
	// 82AA4FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4FC4: 48204449  bl 0x82ca940c
	ctx.lr = 0x82AA4FC8;
	sub_82CA93D0(ctx, base);
	// 82AA4FC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4FCC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AA4FD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA4FD4: 388B56C0  addi r4, r11, 0x56c0
	ctx.r[4].s64 = ctx.r[11].s64 + 22208;
	// 82AA4FD8: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82AA4FDC: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82AA4FE0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4FE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4FE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA4FEC: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA4FF0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA4FF4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA4FF8: 4B6D7611  bl 0x8217c608
	ctx.lr = 0x82AA4FFC;
	sub_8217C608(ctx, base);
	// 82AA4FFC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82AA5000: 390956CC  addi r8, r9, 0x56cc
	ctx.r[8].s64 = ctx.r[9].s64 + 22220;
	// 82AA5004: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA5008: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82AA500C: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82AA5010: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82AA5014: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA5018: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA501C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5020: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA5024: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82AA5028: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA502C: 4B6D7BCD  bl 0x8217cbf8
	ctx.lr = 0x82AA5030;
	sub_8217CBF8(ctx, base);
	// 82AA5030: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82AA5034: 38A656D8  addi r5, r6, 0x56d8
	ctx.r[5].s64 = ctx.r[6].s64 + 22232;
	// 82AA5038: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA503C: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 82AA5040: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82AA5044: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 82AA5048: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA504C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA5050: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5054: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA5058: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA505C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA5060: 4B6D7809  bl 0x8217c868
	ctx.lr = 0x82AA5064;
	sub_8217C868(ctx, base);
	// 82AA5064: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82AA5068: 390956F0  addi r8, r9, 0x56f0
	ctx.r[8].s64 = ctx.r[9].s64 + 22256;
	// 82AA506C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA5070: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82AA5074: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82AA5078: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82AA507C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA5080: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA5084: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5088: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA508C: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82AA5090: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA5094: 4B6D76A5  bl 0x8217c738
	ctx.lr = 0x82AA5098;
	sub_8217C738(ctx, base);
	// 82AA5098: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82AA509C: 38A656FC  addi r5, r6, 0x56fc
	ctx.r[5].s64 = ctx.r[6].s64 + 22268;
	// 82AA50A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA50A4: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 82AA50A8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82AA50AC: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 82AA50B0: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA50B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA50B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA50BC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA50C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA50C4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA50C8: 4B6D78D1  bl 0x8217c998
	ctx.lr = 0x82AA50CC;
	sub_8217C998(ctx, base);
	// 82AA50CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA50D0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA50D4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82AA50D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA50DC: 3869572C  addi r3, r9, 0x572c
	ctx.r[3].s64 = ctx.r[9].s64 + 22316;
	// 82AA50E0: 4B6E8ED9  bl 0x8218dfb8
	ctx.lr = 0x82AA50E4;
	sub_8218DFB8(ctx, base);
	// 82AA50E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA50E8: 4B78CBD1  bl 0x82231cb8
	ctx.lr = 0x82AA50EC;
	sub_82231CB8(ctx, base);
	// 82AA50EC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA50F0: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82AA50F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA50F8: 38685730  addi r3, r8, 0x5730
	ctx.r[3].s64 = ctx.r[8].s64 + 22320;
	// 82AA50FC: 4B6E8EBD  bl 0x8218dfb8
	ctx.lr = 0x82AA5100;
	sub_8218DFB8(ctx, base);
	// 82AA5100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5104: 4B78CBB5  bl 0x82231cb8
	ctx.lr = 0x82AA5108;
	sub_82231CB8(ctx, base);
	// 82AA5108: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82AA510C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA5110: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5114: 3867570C  addi r3, r7, 0x570c
	ctx.r[3].s64 = ctx.r[7].s64 + 22284;
	// 82AA5118: 4B6E8EA1  bl 0x8218dfb8
	ctx.lr = 0x82AA511C;
	sub_8218DFB8(ctx, base);
	// 82AA511C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5120: 4B78CB99  bl 0x82231cb8
	ctx.lr = 0x82AA5124;
	sub_82231CB8(ctx, base);
	// 82AA5124: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA5128: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82AA512C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5130: 38665710  addi r3, r6, 0x5710
	ctx.r[3].s64 = ctx.r[6].s64 + 22288;
	// 82AA5134: 4B6E8E85  bl 0x8218dfb8
	ctx.lr = 0x82AA5138;
	sub_8218DFB8(ctx, base);
	// 82AA5138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA513C: 4B78CB7D  bl 0x82231cb8
	ctx.lr = 0x82AA5140;
	sub_82231CB8(ctx, base);
	// 82AA5140: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 82AA5144: 83DD5708  lwz r30, 0x5708(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(22280 as u32) ) } as u64;
	// 82AA5148: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA514C: 419A0014  beq cr6, 0x82aa5160
	if ctx.cr[6].eq {
	pc = 0x82AA5160; continue 'dispatch;
	}
	// 82AA5150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA5154: 480D324D  bl 0x82b783a0
	ctx.lr = 0x82AA5158;
	sub_82B783A0(ctx, base);
	// 82AA5158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA515C: 4B776BDD  bl 0x8221bd38
	ctx.lr = 0x82AA5160;
	sub_8221BD38(ctx, base);
	pc = 0x82AA5160; continue 'dispatch;
            }
            0x82AA5160 => {
    //   block [0x82AA5160..0x82AA516C)
	// 82AA5160: 93FD5708  stw r31, 0x5708(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(22280 as u32), ctx.r[31].u32 ) };
	// 82AA5164: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA5168: 482042F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA5170 size=2116
    let mut pc: u32 = 0x82AA5170;
    'dispatch: loop {
        match pc {
            0x82AA5170 => {
    //   block [0x82AA5170..0x82AA59B4)
	// 82AA5170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5174: 48204295  bl 0x82ca9408
	ctx.lr = 0x82AA5178;
	sub_82CA93D0(ctx, base);
	// 82AA5178: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA517C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82AA5180: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 82AA5184: 394BDF40  addi r10, r11, -0x20c0
	ctx.r[10].s64 = ctx.r[11].s64 + -8384;
	// 82AA5188: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82AA518C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA5190: 38600062  li r3, 0x62
	ctx.r[3].s64 = 98;
	// 82AA5194: 817F0364  lwz r11, 0x364(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA5198: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA519C: 814A0050  lwz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA51A0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82AA51A4: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 82AA51A8: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 82AA51AC: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 82AA51B0: 914970B8  stw r10, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 82AA51B4: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82AA51B8: 4B787059  bl 0x8222c210
	ctx.lr = 0x82AA51BC;
	sub_8222C210(ctx, base);
	// 82AA51BC: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AA51C0: 4B763951  bl 0x82208b10
	ctx.lr = 0x82AA51C4;
	sub_82208B10(ctx, base);
	// 82AA51C4: 38600062  li r3, 0x62
	ctx.r[3].s64 = 98;
	// 82AA51C8: 4B787049  bl 0x8222c210
	ctx.lr = 0x82AA51CC;
	sub_8222C210(ctx, base);
	// 82AA51CC: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AA51D0: 4B763941  bl 0x82208b10
	ctx.lr = 0x82AA51D4;
	sub_82208B10(ctx, base);
	// 82AA51D4: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82AA51D8: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 82AA51DC: 88DD0058  lbz r6, 0x58(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AA51E0: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82AA51E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA51E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA51EC: E9681760  ld r11, 0x1760(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(5984 as u32) ) };
	// 82AA51F0: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82AA51F4: C00516C8  lfs f0, 0x16c8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(5832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA51F8: 79670004  rldicr r7, r11, 0, 0
	ctx.r[7].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 82AA51FC: 2B270000  cmpldi cr6, r7, 0
	ctx.cr[6].compare_u64(ctx.r[7].u64, 0, &mut ctx.xer);
	// 82AA5200: 897D005B  lbz r11, 0x5b(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(91 as u32) ) } as u64;
	// 82AA5204: 88FD005A  lbz r7, 0x5a(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AA5208: 88BD0059  lbz r5, 0x59(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AA520C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82AA5210: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA5214: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 82AA5218: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA521C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82AA5220: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 82AA5224: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA5228: FCA0669C  fcfid f5, f12
	ctx.f[5].f64 = (ctx.f[12].s64 as f64);
	// 82AA522C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82AA5230: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA5234: FCC05E9C  fcfid f6, f11
	ctx.f[6].f64 = (ctx.f[11].s64 as f64);
	// 82AA5238: FC202818  frsp f1, f5
	ctx.f[1].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82AA523C: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82AA5240: FD006E9C  fcfid f8, f13
	ctx.f[8].f64 = (ctx.f[13].s64 as f64);
	// 82AA5244: FC403018  frsp f2, f6
	ctx.f[2].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82AA5248: ED610032  fmuls f11, f1, f0
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AA524C: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA59B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA59B8 size=1596
    let mut pc: u32 = 0x82AA59B8;
    'dispatch: loop {
        match pc {
            0x82AA59B8 => {
    //   block [0x82AA59B8..0x82AA5FF4)
	// 82AA59B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA59BC: 48203A45  bl 0x82ca9400
	ctx.lr = 0x82AA59C0;
	sub_82CA93D0(ctx, base);
	// 82AA59C0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82AA59C4: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA59C8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82AA59CC: 3F408336  lis r26, -0x7cca
	ctx.r[26].s64 = -2093613056;
	// 82AA59D0: 394BDF40  addi r10, r11, -0x20c0
	ctx.r[10].s64 = ctx.r[11].s64 + -8384;
	// 82AA59D4: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82AA59D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA59DC: 38600062  li r3, 0x62
	ctx.r[3].s64 = 98;
	// 82AA59E0: 817A0364  lwz r11, 0x364(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA59E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA59E8: 814A0050  lwz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA59EC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82AA59F0: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 82AA59F4: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 82AA59F8: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 82AA59FC: 914970B8  stw r10, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 82AA5A00: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82AA5A04: 4B78680D  bl 0x8222c210
	ctx.lr = 0x82AA5A08;
	sub_8222C210(ctx, base);
	// 82AA5A08: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AA5A0C: 4B763105  bl 0x82208b10
	ctx.lr = 0x82AA5A10;
	sub_82208B10(ctx, base);
	// 82AA5A10: 38600062  li r3, 0x62
	ctx.r[3].s64 = 98;
	// 82AA5A14: 4B7867FD  bl 0x8222c210
	ctx.lr = 0x82AA5A18;
	sub_8222C210(ctx, base);
	// 82AA5A18: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AA5A1C: 4B7630F5  bl 0x82208b10
	ctx.lr = 0x82AA5A20;
	sub_82208B10(ctx, base);
	// 82AA5A20: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82AA5A24: 88DC0059  lbz r6, 0x59(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AA5A28: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 82AA5A2C: 88FC0058  lbz r7, 0x58(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AA5A30: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82AA5A34: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82AA5A38: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AA5A3C: E9691760  ld r11, 0x1760(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5984 as u32) ) };
	// 82AA5A40: 79680004  rldicr r8, r11, 0, 0
	ctx.r[8].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 82AA5A44: 2B280000  cmpldi cr6, r8, 0
	ctx.cr[6].compare_u64(ctx.r[8].u64, 0, &mut ctx.xer);
	// 82AA5A48: 897C005B  lbz r11, 0x5b(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(91 as u32) ) } as u64;
	// 82AA5A4C: 891C005A  lbz r8, 0x5a(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AA5A50: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82AA5A54: C8010070  lfd f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AA5A58: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 82AA5A5C: C9A10070  lfd f13, 0x70(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AA5A60: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82AA5A64: F8C10070  std r6, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[6].u64 ) };
	// 82AA5A68: C9810070  lfd f12, 0x70(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AA5A6C: FCC06E9C  fcfid f6, f13
	ctx.f[6].f64 = (ctx.f[13].s64 as f64);
	// 82AA5A70: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82AA5A74: C9610070  lfd f11, 0x70(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AA5A78: FD20069C  fcfid f9, f0
	ctx.f[9].f64 = (ctx.f[0].s64 as f64);
	// 82AA5A7C: FCE0669C  fcfid f7, f12
	ctx.f[7].f64 = (ctx.f[12].s64 as f64);
	// 82AA5A80: FC603018  frsp f3, f6
	ctx.f[3].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82AA5A84: D0610068  stfs f3, 0x68(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA5FF8 size=2240
    let mut pc: u32 = 0x82AA5FF8;
    'dispatch: loop {
        match pc {
            0x82AA5FF8 => {
    //   block [0x82AA5FF8..0x82AA68B8)
	// 82AA5FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5FFC: 482033E1  bl 0x82ca93dc
	ctx.lr = 0x82AA6000;
	sub_82CA93D0(ctx, base);
	// 82AA6000: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 82AA6004: 48207CBD  bl 0x82cadcc0
	ctx.lr = 0x82AA6008;
	sub_82CADCA0(ctx, base);
	// 82AA6008: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA68B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA68B8 size=2488
    let mut pc: u32 = 0x82AA68B8;
    'dispatch: loop {
        match pc {
            0x82AA68B8 => {
    //   block [0x82AA68B8..0x82AA7270)
	// 82AA68B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA68BC: 48202B29  bl 0x82ca93e4
	ctx.lr = 0x82AA68C0;
	sub_82CA93D0(ctx, base);
	// 82AA68C0: DBA1FF78  stfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[29].u64 ) };
	// 82AA68C4: DBC1FF80  stfd f30, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 82AA68C8: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 82AA68CC: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA7270 size=1548
    let mut pc: u32 = 0x82AA7270;
    'dispatch: loop {
        match pc {
            0x82AA7270 => {
    //   block [0x82AA7270..0x82AA787C)
	// 82AA7270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7274: 4820217D  bl 0x82ca93f0
	ctx.lr = 0x82AA7278;
	sub_82CA93D0(ctx, base);
	// 82AA7278: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82AA727C: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82AA7280: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7284: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82AA7288: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 82AA728C: 394BDF40  addi r10, r11, -0x20c0
	ctx.r[10].s64 = ctx.r[11].s64 + -8384;
	// 82AA7290: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82AA7294: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA7298: 38600062  li r3, 0x62
	ctx.r[3].s64 = 98;
	// 82AA729C: 817F0364  lwz r11, 0x364(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AA72A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA72A4: 814A0050  lwz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA72A8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82AA72AC: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 82AA72B0: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 82AA72B4: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 82AA72B8: 914970B8  stw r10, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 82AA72BC: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82AA72C0: 4B784F51  bl 0x8222c210
	ctx.lr = 0x82AA72C4;
	sub_8222C210(ctx, base);
	// 82AA72C4: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AA72C8: 4B761849  bl 0x82208b10
	ctx.lr = 0x82AA72CC;
	sub_82208B10(ctx, base);
	// 82AA72CC: 38600062  li r3, 0x62
	ctx.r[3].s64 = 98;
	// 82AA72D0: 4B784F41  bl 0x8222c210
	ctx.lr = 0x82AA72D4;
	sub_8222C210(ctx, base);
	// 82AA72D4: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AA72D8: 4B761839  bl 0x82208b10
	ctx.lr = 0x82AA72DC;
	sub_82208B10(ctx, base);
	// 82AA72DC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82AA72E0: 88DA0041  lbz r6, 0x41(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(65 as u32) ) } as u64;
	// 82AA72E4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82AA72E8: 88FA0040  lbz r7, 0x40(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AA72EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA72F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA72F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA72F8: E9691760  ld r11, 0x1760(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5984 as u32) ) };
	// 82AA72FC: 79680004  rldicr r8, r11, 0, 0
	ctx.r[8].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 82AA7300: 2B280000  cmpldi cr6, r8, 0
	ctx.cr[6].compare_u64(ctx.r[8].u64, 0, &mut ctx.xer);
	// 82AA7304: 897A0043  lbz r11, 0x43(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(67 as u32) ) } as u64;
	// 82AA7308: 891A0042  lbz r8, 0x42(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(66 as u32) ) } as u64;
	// 82AA730C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82AA7310: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA7314: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 82AA7318: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA731C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82AA7320: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82AA7324: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA7328: FCC06E9C  fcfid f6, f13
	ctx.f[6].f64 = (ctx.f[13].s64 as f64);
	// 82AA732C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82AA7330: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA7334: FD20069C  fcfid f9, f0
	ctx.f[9].f64 = (ctx.f[0].s64 as f64);
	// 82AA7338: FCE0669C  fcfid f7, f12
	ctx.f[7].f64 = (ctx.f[12].s64 as f64);
	// 82AA733C: FC603018  frsp f3, f6
	ctx.f[3].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82AA7340: D0610058  stfs f3, 0x58(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA7880 size=36
    let mut pc: u32 = 0x82AA7880;
    'dispatch: loop {
        match pc {
            0x82AA7880 => {
    //   block [0x82AA7880..0x82AA78A4)
	// 82AA7880: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AA7884: 409A0020  bne cr6, 0x82aa78a4
	if !ctx.cr[6].eq {
		sub_82AA78A4(ctx, base);
		return;
	}
	// 82AA7888: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 82AA788C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA7890: 99430002  stb r10, 2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 82AA7894: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82AA7898: 99430003  stb r10, 3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 82AA789C: 99630001  stb r11, 1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82AA78A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA78A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA78A4 size=36
    let mut pc: u32 = 0x82AA78A4;
    'dispatch: loop {
        match pc {
            0x82AA78A4 => {
    //   block [0x82AA78A4..0x82AA78C8)
	// 82AA78A4: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 82AA78A8: 409A0020  bne cr6, 0x82aa78c8
	if !ctx.cr[6].eq {
		sub_82AA78C8(ctx, base);
		return;
	}
	// 82AA78AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA78B0: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 82AA78B4: 99630002  stb r11, 2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	// 82AA78B8: 99430001  stb r10, 1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 82AA78BC: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82AA78C0: 99430003  stb r10, 3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 82AA78C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA78C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA78C8 size=128
    let mut pc: u32 = 0x82AA78C8;
    'dispatch: loop {
        match pc {
            0x82AA78C8 => {
    //   block [0x82AA78C8..0x82AA7948)
	// 82AA78C8: 548B6026  slwi r11, r4, 0xc
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(12);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA78CC: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 82AA78D0: 7D2B2214  add r9, r11, r4
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82AA78D4: 99430003  stb r10, 3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 82AA78D8: 3D097ED5  addis r8, r9, 0x7ed5
	ctx.r[8].s64 = ctx.r[9].s64 + 2127888384;
	// 82AA78DC: 39085D16  addi r8, r8, 0x5d16
	ctx.r[8].s64 = ctx.r[8].s64 + 23830;
	// 82AA78E0: 55076CFE  srwi r7, r8, 0x13
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(19);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82AA78E4: 7CE64278  xor r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 ^ ctx.r[8].u64;
	// 82AA78E8: 6CCBC761  xoris r11, r6, 0xc761
	ctx.r[11].u64 = ctx.r[6].u64 ^ 3345022976;
	// 82AA78EC: 696BC23C  xori r11, r11, 0xc23c
	ctx.r[11].u64 = ctx.r[11].u64 ^ 49724;
	// 82AA78F0: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA78F4: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA78F8: 3C851656  addis r4, r5, 0x1656
	ctx.r[4].s64 = ctx.r[5].s64 + 374734848;
	// 82AA78FC: 388467B1  addi r4, r4, 0x67b1
	ctx.r[4].s64 = ctx.r[4].s64 + 26545;
	// 82AA7900: 3D64D3A2  addis r11, r4, -0x2c5e
	ctx.r[11].s64 = ctx.r[4].s64 + -744357888;
	// 82AA7904: 548A482C  slwi r10, r4, 9
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(9);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA7908: 396B646C  addi r11, r11, 0x646c
	ctx.r[11].s64 = ctx.r[11].s64 + 25708;
	// 82AA790C: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82AA7910: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA7914: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AA7918: 3D09FD70  addis r8, r9, -0x290
	ctx.r[8].s64 = ctx.r[9].s64 + -42991616;
	// 82AA791C: 390846C5  addi r8, r8, 0x46c5
	ctx.r[8].s64 = ctx.r[8].s64 + 18117;
	// 82AA7920: 5507843E  srwi r7, r8, 0x10
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(16);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82AA7924: 7CE64278  xor r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 ^ ctx.r[8].u64;
	// 82AA7928: 6CC5B55A  xoris r5, r6, 0xb55a
	ctx.r[5].u64 = ctx.r[6].u64 ^ 3042574336;
	// 82AA792C: 68A54F09  xori r5, r5, 0x4f09
	ctx.r[5].u64 = ctx.r[5].u64 ^ 20233;
	// 82AA7930: 54ABC63E  rlwinm r11, r5, 0x18, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82AA7934: 98A30002  stb r5, 2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[5].u8 ) };
	// 82AA7938: 54AA863E  rlwinm r10, r5, 0x10, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 82AA793C: 99630001  stb r11, 1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82AA7940: 99430000  stb r10, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82AA7944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7948 size=292
    let mut pc: u32 = 0x82AA7948;
    'dispatch: loop {
        match pc {
            0x82AA7948 => {
    //   block [0x82AA7948..0x82AA797C)
	// 82AA7948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA794C: 48201AB9  bl 0x82ca9404
	ctx.lr = 0x82AA7950;
	sub_82CA93D0(ctx, base);
	// 82AA7950: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7954: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82AA7958: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AA795C: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AA7960: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AA7964: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7968: 4B7778F1  bl 0x8221f258
	ctx.lr = 0x82AA796C;
	sub_8221F258(ctx, base);
	// 82AA796C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA7970: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA7974: 419A0008  beq cr6, 0x82aa797c
	if ctx.cr[6].eq {
	pc = 0x82AA797C; continue 'dispatch;
	}
	// 82AA7978: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82AA797C; continue 'dispatch;
            }
            0x82AA797C => {
    //   block [0x82AA797C..0x82AA798C)
	// 82AA797C: 3B9E0004  addi r28, r30, 4
	ctx.r[28].s64 = ctx.r[30].s64 + 4;
	// 82AA7980: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AA7984: 419A0008  beq cr6, 0x82aa798c
	if ctx.cr[6].eq {
	pc = 0x82AA798C; continue 'dispatch;
	}
	// 82AA7988: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x82AA798C; continue 'dispatch;
            }
            0x82AA798C => {
    //   block [0x82AA798C..0x82AA79A4)
	// 82AA798C: 37FE0008  addic. r31, r30, 8
	ctx.xer.ca = (ctx.r[30].u32 > (!(8 as u32)));
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA7990: 41820058  beq 0x82aa79e8
	if ctx.cr[0].eq {
	pc = 0x82AA79E8; continue 'dispatch;
	}
	// 82AA7994: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82AA7998: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82AA799C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82AA79A0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82AA79A4; continue 'dispatch;
            }
            0x82AA79A4 => {
    //   block [0x82AA79A4..0x82AA79E8)
	// 82AA79A4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA79A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA79AC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA79B0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AA79B4: 4200FFF0  bdnz 0x82aa79a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AA79A4; continue 'dispatch;
	}
	// 82AA79B8: 389D0018  addi r4, r29, 0x18
	ctx.r[4].s64 = ctx.r[29].s64 + 24;
	// 82AA79BC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82AA79C0: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82AA79C4: 48201ABD  bl 0x82ca9480
	ctx.lr = 0x82AA79C8;
	sub_82CA9480(ctx, base);
	// 82AA79C8: 897D005B  lbz r11, 0x5b(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(91 as u32) ) } as u64;
	// 82AA79CC: 895D0058  lbz r10, 0x58(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AA79D0: 893D0059  lbz r9, 0x59(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AA79D4: 891D005A  lbz r8, 0x5a(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AA79D8: 997F005B  stb r11, 0x5b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 82AA79DC: 995F0058  stb r10, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 82AA79E0: 993F0059  stb r9, 0x59(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(89 as u32), ctx.r[9].u8 ) };
	// 82AA79E4: 991F005A  stb r8, 0x5a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(90 as u32), ctx.r[8].u8 ) };
	pc = 0x82AA79E8; continue 'dispatch;
            }
            0x82AA79E8 => {
    //   block [0x82AA79E8..0x82AA7A50)
	// 82AA79E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AA79EC: 3D4002C8  lis r10, 0x2c8
	ctx.r[10].s64 = 46661632;
	// 82AA79F0: 3BEB56D8  addi r31, r11, 0x56d8
	ctx.r[31].s64 = ctx.r[11].s64 + 22232;
	// 82AA79F4: 6149590B  ori r9, r10, 0x590b
	ctx.r[9].u64 = ctx.r[10].u64 | 22795;
	// 82AA79F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA79FC: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AA7A00: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82AA7A04: 4098004C  bge cr6, 0x82aa7a50
	if !ctx.cr[6].lt {
	pc = 0x82AA7A50; continue 'dispatch;
	}
	// 82AA7A08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA7A0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7A10: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82AA7A14: 4B84A52D  bl 0x822f1f40
	ctx.lr = 0x82AA7A18;
	sub_822F1F40(ctx, base);
	// 82AA7A18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7A1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA7A20: 4B84A391  bl 0x822f1db0
	ctx.lr = 0x82AA7A24;
	sub_822F1DB0(ctx, base);
	// 82AA7A24: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AA7A28: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA7A2C: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82AA7A30: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82AA7A34: 4B84A3ED  bl 0x822f1e20
	ctx.lr = 0x82AA7A38;
	sub_822F1E20(ctx, base);
	// 82AA7A38: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82AA7A3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA7A40: 4BBD3DA1  bl 0x8267b7e0
	ctx.lr = 0x82AA7A44;
	sub_8267B7E0(ctx, base);
	// 82AA7A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7A48: 4B6C9DC9  bl 0x82171810
	ctx.lr = 0x82AA7A4C;
	sub_82171810(ctx, base);
	// 82AA7A4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AA7A50; continue 'dispatch;
            }
            0x82AA7A50 => {
    //   block [0x82AA7A50..0x82AA7A6C)
	// 82AA7A50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AA7A54: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA7A58: 93DB0004  stw r30, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AA7A5C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7A60: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AA7A64: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AA7A68: 482019EC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA7A70 size=320
    let mut pc: u32 = 0x82AA7A70;
    'dispatch: loop {
        match pc {
            0x82AA7A70 => {
    //   block [0x82AA7A70..0x82AA7AA4)
	// 82AA7A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7A74: 48201991  bl 0x82ca9404
	ctx.lr = 0x82AA7A78;
	sub_82CA93D0(ctx, base);
	// 82AA7A78: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7A7C: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82AA7A80: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 82AA7A84: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AA7A88: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA7A8C: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7A90: 4B7777C9  bl 0x8221f258
	ctx.lr = 0x82AA7A94;
	sub_8221F258(ctx, base);
	// 82AA7A94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA7A98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AA7A9C: 419A0008  beq cr6, 0x82aa7aa4
	if ctx.cr[6].eq {
	pc = 0x82AA7AA4; continue 'dispatch;
	}
	// 82AA7AA0: 937D0000  stw r27, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82AA7AA4; continue 'dispatch;
            }
            0x82AA7AA4 => {
    //   block [0x82AA7AA4..0x82AA7AB4)
	// 82AA7AA4: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 82AA7AA8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AA7AAC: 419A0008  beq cr6, 0x82aa7ab4
	if ctx.cr[6].eq {
	pc = 0x82AA7AB4; continue 'dispatch;
	}
	// 82AA7AB0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x82AA7AB4; continue 'dispatch;
            }
            0x82AA7AB4 => {
    //   block [0x82AA7AB4..0x82AA7B2C)
	// 82AA7AB4: 37FD0008  addic. r31, r29, 8
	ctx.xer.ca = (ctx.r[29].u32 > (!(8 as u32)));
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA7AB8: 41820074  beq 0x82aa7b2c
	if ctx.cr[0].eq {
	pc = 0x82AA7B2C; continue 'dispatch;
	}
	// 82AA7ABC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7AC0: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82AA7AC4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82AA7AC8: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82AA7ACC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA7AD0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7AD4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA7AD8: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA7ADC: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82AA7AE0: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA7AE4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AA7AE8: 48201999  bl 0x82ca9480
	ctx.lr = 0x82AA7AEC;
	sub_82CA9480(ctx, base);
	// 82AA7AEC: 891E0053  lbz r8, 0x53(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(83 as u32) ) } as u64;
	// 82AA7AF0: 88FE0050  lbz r7, 0x50(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA7AF4: 88DE0051  lbz r6, 0x51(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AA7AF8: 88BE0052  lbz r5, 0x52(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AA7AFC: 991F0053  stb r8, 0x53(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	// 82AA7B00: 98FF0050  stb r7, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[7].u8 ) };
	// 82AA7B04: 98DF0051  stb r6, 0x51(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(81 as u32), ctx.r[6].u8 ) };
	// 82AA7B08: 98BF0052  stb r5, 0x52(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(82 as u32), ctx.r[5].u8 ) };
	// 82AA7B0C: 889E0054  lbz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA7B10: 989F0054  stb r4, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[4].u8 ) };
	// 82AA7B14: C1BE0058  lfs f13, 0x58(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA7B18: D1BF0058  stfs f13, 0x58(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82AA7B1C: 807E005C  lwz r3, 0x5c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA7B20: 907F005C  stw r3, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82AA7B24: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA7B28: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	pc = 0x82AA7B2C; continue 'dispatch;
            }
            0x82AA7B2C => {
    //   block [0x82AA7B2C..0x82AA7B94)
	// 82AA7B2C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AA7B30: 3D40028F  lis r10, 0x28f
	ctx.r[10].s64 = 42926080;
	// 82AA7B34: 3BEB56E4  addi r31, r11, 0x56e4
	ctx.r[31].s64 = ctx.r[11].s64 + 22244;
	// 82AA7B38: 61495C28  ori r9, r10, 0x5c28
	ctx.r[9].u64 = ctx.r[10].u64 | 23592;
	// 82AA7B3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA7B40: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AA7B44: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82AA7B48: 4098004C  bge cr6, 0x82aa7b94
	if !ctx.cr[6].lt {
	pc = 0x82AA7B94; continue 'dispatch;
	}
	// 82AA7B4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA7B50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7B54: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82AA7B58: 4B84A3E9  bl 0x822f1f40
	ctx.lr = 0x82AA7B5C;
	sub_822F1F40(ctx, base);
	// 82AA7B5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7B60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA7B64: 4B84A24D  bl 0x822f1db0
	ctx.lr = 0x82AA7B68;
	sub_822F1DB0(ctx, base);
	// 82AA7B68: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AA7B6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA7B70: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82AA7B74: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AA7B78: 4B84A2A9  bl 0x822f1e20
	ctx.lr = 0x82AA7B7C;
	sub_822F1E20(ctx, base);
	// 82AA7B7C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AA7B80: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA7B84: 4BBD3C5D  bl 0x8267b7e0
	ctx.lr = 0x82AA7B88;
	sub_8267B7E0(ctx, base);
	// 82AA7B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7B8C: 4B6C9C85  bl 0x82171810
	ctx.lr = 0x82AA7B90;
	sub_82171810(ctx, base);
	// 82AA7B90: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AA7B94; continue 'dispatch;
            }
            0x82AA7B94 => {
    //   block [0x82AA7B94..0x82AA7BB0)
	// 82AA7B94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AA7B98: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA7B9C: 93BB0004  stw r29, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AA7BA0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7BA4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AA7BA8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AA7BAC: 482018A8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7BB0 size=80
    let mut pc: u32 = 0x82AA7BB0;
    'dispatch: loop {
        match pc {
            0x82AA7BB0 => {
    //   block [0x82AA7BB0..0x82AA7BE8)
	// 82AA7BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7BB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA7BBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7BC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7BC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA7BCC: 4BFA804D  bl 0x82a4fc18
	ctx.lr = 0x82AA7BD0;
	sub_82A4FC18(ctx, base);
	// 82AA7BD0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82AA7BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA7BD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA7BDC: 419A000C  beq cr6, 0x82aa7be8
	if ctx.cr[6].eq {
	pc = 0x82AA7BE8; continue 'dispatch;
	}
	// 82AA7BE0: 4B774159  bl 0x8221bd38
	ctx.lr = 0x82AA7BE4;
	sub_8221BD38(ctx, base);
	// 82AA7BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82AA7BE8; continue 'dispatch;
            }
            0x82AA7BE8 => {
    //   block [0x82AA7BE8..0x82AA7C00)
	// 82AA7BE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA7BEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7BF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA7BF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA7BF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7BFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA7C00 size=220
    let mut pc: u32 = 0x82AA7C00;
    'dispatch: loop {
        match pc {
            0x82AA7C00 => {
    //   block [0x82AA7C00..0x82AA7C38)
	// 82AA7C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7C04: 482017FD  bl 0x82ca9400
	ctx.lr = 0x82AA7C08;
	sub_82CA93D0(ctx, base);
	// 82AA7C08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7C0C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA7C10: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AA7C14: FB6100A0  std r27, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[27].u64 ) };
	// 82AA7C18: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82AA7C1C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82AA7C20: 2F1C0020  cmpwi cr6, r28, 0x20
	ctx.cr[6].compare_i32(ctx.r[28].s32, 32, &mut ctx.xer);
	// 82AA7C24: 41990014  bgt cr6, 0x82aa7c38
	if ctx.cr[6].gt {
	pc = 0x82AA7C38; continue 'dispatch;
	}
	// 82AA7C28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA7C2C: 4B70FD45  bl 0x821b7970
	ctx.lr = 0x82AA7C30;
	sub_821B7970(ctx, base);
	// 82AA7C30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA7C34: 4820181C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA7C38 => {
    //   block [0x82AA7C38..0x82AA7C9C)
	// 82AA7C38: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 82AA7C3C: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA7C40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA7C44: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82AA7C48: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AA7C4C: 7FE90194  addze r31, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[31].s64 = tmp.s64;
	// 82AA7C50: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA7C54: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AA7C58: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82AA7C5C: 480003F5  bl 0x82aa8050
	ctx.lr = 0x82AA7C60;
	sub_82AA8050(ctx, base);
	// 82AA7C60: EBA10050  ld r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA7C64: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82AA7C68: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA7C6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA7C70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA7C74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA7C78: 41990024  bgt cr6, 0x82aa7c9c
	if ctx.cr[6].gt {
	pc = 0x82AA7C9C; continue 'dispatch;
	}
	// 82AA7C7C: 4800090D  bl 0x82aa8588
	ctx.lr = 0x82AA7C80;
	sub_82AA8588(ctx, base);
	// 82AA7C80: 7F9FE050  subf r28, r31, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 82AA7C84: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA7C88: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA7C8C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA7C90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7C94: 480008F5  bl 0x82aa8588
	ctx.lr = 0x82AA7C98;
	sub_82AA8588(ctx, base);
	// 82AA7C98: 48000020  b 0x82aa7cb8
	pc = 0x82AA7CB8; continue 'dispatch;
            }
            0x82AA7C9C => {
    //   block [0x82AA7C9C..0x82AA7CB8)
	// 82AA7C9C: 4BFFFF65  bl 0x82aa7c00
	ctx.lr = 0x82AA7CA0;
	sub_82AA7C00(ctx, base);
	// 82AA7CA0: 7F9FE050  subf r28, r31, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 82AA7CA4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA7CA8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA7CAC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA7CB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7CB4: 4BFFFF4D  bl 0x82aa7c00
	ctx.lr = 0x82AA7CB8;
	sub_82AA7C00(ctx, base);
	pc = 0x82AA7CB8; continue 'dispatch;
            }
            0x82AA7CB8 => {
    //   block [0x82AA7CB8..0x82AA7CDC)
	// 82AA7CB8: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82AA7CBC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AA7CC0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82AA7CC4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA7CC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA7CCC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA7CD0: 48000A69  bl 0x82aa8738
	ctx.lr = 0x82AA7CD4;
	sub_82AA8738(ctx, base);
	// 82AA7CD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA7CD8: 48201778  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA7CE0 size=880
    let mut pc: u32 = 0x82AA7CE0;
    'dispatch: loop {
        match pc {
            0x82AA7CE0 => {
    //   block [0x82AA7CE0..0x82AA7D64)
	// 82AA7CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7CE4: 48201721  bl 0x82ca9404
	ctx.lr = 0x82AA7CE8;
	sub_82CA93D0(ctx, base);
	// 82AA7CE8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7CEC: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82AA7CF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA7CF4: F8A100D0  std r5, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[5].u64 ) };
	// 82AA7CF8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AA7CFC: 838100D4  lwz r28, 0xd4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA7D00: 397CFFF8  addi r11, r28, -8
	ctx.r[11].s64 = ctx.r[28].s64 + -8;
	// 82AA7D04: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 82AA7D08: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA7D0C: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA7D10: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA7D14: 7D5DE050  subf r10, r29, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 82AA7D18: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AA7D1C: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82AA7D20: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82AA7D24: 7CE80194  addze r7, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[7].s64 = tmp.s64;
	// 82AA7D28: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA7D2C: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AA7D30: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82AA7D34: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA7D38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA7D3C: 48000D7D  bl 0x82aa8ab8
	ctx.lr = 0x82AA7D40;
	sub_82AA8AB8(ctx, base);
	// 82AA7D40: 393F0008  addi r9, r31, 8
	ctx.r[9].s64 = ctx.r[31].s64 + 8;
	// 82AA7D44: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 82AA7D48: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AA7D4C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82AA7D50: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA7D54: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82AA7D58: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA7D5C: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82AA7D60: 40980058  bge cr6, 0x82aa7db8
	if !ctx.cr[6].lt {
	pc = 0x82AA7DB8; continue 'dispatch;
	}
	pc = 0x82AA7D64; continue 'dispatch;
            }
            0x82AA7D64 => {
    //   block [0x82AA7D64..0x82AA7D7C)
	// 82AA7D64: 8167FFF8  lwz r11, -8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7D68: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7D6C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA7D70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA7D74: 41990008  bgt cr6, 0x82aa7d7c
	if ctx.cr[6].gt {
	pc = 0x82AA7D7C; continue 'dispatch;
	}
	// 82AA7D78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AA7D7C; continue 'dispatch;
            }
            0x82AA7D7C => {
    //   block [0x82AA7D7C..0x82AA7D9C)
	// 82AA7D7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA7D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA7D84: 409A0034  bne cr6, 0x82aa7db8
	if !ctx.cr[6].eq {
	pc = 0x82AA7DB8; continue 'dispatch;
	}
	// 82AA7D88: 8167FFF8  lwz r11, -8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7D8C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AA7D90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA7D94: 41990008  bgt cr6, 0x82aa7d9c
	if ctx.cr[6].gt {
	pc = 0x82AA7D9C; continue 'dispatch;
	}
	// 82AA7D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AA7D9C; continue 'dispatch;
            }
            0x82AA7D9C => {
    //   block [0x82AA7D9C..0x82AA7DB8)
	// 82AA7D9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA7DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA7DA4: 409A0014  bne cr6, 0x82aa7db8
	if !ctx.cr[6].eq {
	pc = 0x82AA7DB8; continue 'dispatch;
	}
	// 82AA7DA8: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 82AA7DAC: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82AA7DB0: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AA7DB4: 4198FFB0  blt cr6, 0x82aa7d64
	if ctx.cr[6].lt {
	pc = 0x82AA7D64; continue 'dispatch;
	}
	pc = 0x82AA7DB8; continue 'dispatch;
            }
            0x82AA7DB8 => {
    //   block [0x82AA7DB8..0x82AA7DC8)
	// 82AA7DB8: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA7DBC: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA7DC0: 40980054  bge cr6, 0x82aa7e14
	if !ctx.cr[6].lt {
	pc = 0x82AA7E14; continue 'dispatch;
	}
	// 82AA7DC4: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AA7DC8; continue 'dispatch;
            }
            0x82AA7DC8 => {
    //   block [0x82AA7DC8..0x82AA7DDC)
	// 82AA7DC8: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7DCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA7DD0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AA7DD4: 41990008  bgt cr6, 0x82aa7ddc
	if ctx.cr[6].gt {
	pc = 0x82AA7DDC; continue 'dispatch;
	}
	// 82AA7DD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AA7DDC; continue 'dispatch;
            }
            0x82AA7DDC => {
    //   block [0x82AA7DDC..0x82AA7DF8)
	// 82AA7DDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA7DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA7DE4: 409A0030  bne cr6, 0x82aa7e14
	if !ctx.cr[6].eq {
	pc = 0x82AA7E14; continue 'dispatch;
	}
	// 82AA7DE8: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA7DEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA7DF0: 41990008  bgt cr6, 0x82aa7df8
	if ctx.cr[6].gt {
	pc = 0x82AA7DF8; continue 'dispatch;
	}
	// 82AA7DF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AA7DF8; continue 'dispatch;
            }
            0x82AA7DF8 => {
    //   block [0x82AA7DF8..0x82AA7E14)
	// 82AA7DF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA7DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA7E00: 409A0014  bne cr6, 0x82aa7e14
	if !ctx.cr[6].eq {
	pc = 0x82AA7E14; continue 'dispatch;
	}
	// 82AA7E04: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82AA7E08: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82AA7E0C: 7F05E040  cmplw cr6, r5, r28
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA7E10: 4198FFB8  blt cr6, 0x82aa7dc8
	if ctx.cr[6].lt {
	pc = 0x82AA7DC8; continue 'dispatch;
	}
	pc = 0x82AA7E14; continue 'dispatch;
            }
            0x82AA7E14 => {
    //   block [0x82AA7E14..0x82AA7E2C)
	// 82AA7E14: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA7E18: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA7E1C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82AA7E20: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82AA7E24: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA7E28: 80C1006C  lwz r6, 0x6c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x82AA7E2C; continue 'dispatch;
            }
            0x82AA7E2C => {
    //   block [0x82AA7E2C..0x82AA7E34)
	// 82AA7E2C: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA7E30: 40980080  bge cr6, 0x82aa7eb0
	if !ctx.cr[6].lt {
	pc = 0x82AA7EB0; continue 'dispatch;
	}
	pc = 0x82AA7E34; continue 'dispatch;
            }
            0x82AA7E34 => {
    //   block [0x82AA7E34..0x82AA7E4C)
	// 82AA7E34: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7E38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA7E3C: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7E40: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA7E44: 41990008  bgt cr6, 0x82aa7e4c
	if ctx.cr[6].gt {
	pc = 0x82AA7E4C; continue 'dispatch;
	}
	// 82AA7E48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AA7E4C; continue 'dispatch;
            }
            0x82AA7E4C => {
    //   block [0x82AA7E4C..0x82AA7E68)
	// 82AA7E4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA7E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA7E54: 409A004C  bne cr6, 0x82aa7ea0
	if !ctx.cr[6].eq {
	pc = 0x82AA7EA0; continue 'dispatch;
	}
	// 82AA7E58: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AA7E5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA7E60: 41990008  bgt cr6, 0x82aa7e68
	if ctx.cr[6].gt {
	pc = 0x82AA7E68; continue 'dispatch;
	}
	// 82AA7E64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AA7E68; continue 'dispatch;
            }
            0x82AA7E68 => {
    //   block [0x82AA7E68..0x82AA7EA0)
	// 82AA7E68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA7E6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA7E70: 409A0040  bne cr6, 0x82aa7eb0
	if !ctx.cr[6].eq {
	pc = 0x82AA7EB0; continue 'dispatch;
	}
	// 82AA7E74: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA7E78: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82AA7E7C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7E80: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82AA7E84: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82AA7E88: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA7E8C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AA7E90: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA7E94: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7E98: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AA7E9C: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x82AA7EA0; continue 'dispatch;
            }
            0x82AA7EA0 => {
    //   block [0x82AA7EA0..0x82AA7EB0)
	// 82AA7EA0: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82AA7EA4: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82AA7EA8: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA7EAC: 4198FF88  blt cr6, 0x82aa7e34
	if ctx.cr[6].lt {
	pc = 0x82AA7E34; continue 'dispatch;
	}
	pc = 0x82AA7EB0; continue 'dispatch;
            }
            0x82AA7EB0 => {
    //   block [0x82AA7EB0..0x82AA7EB8)
	// 82AA7EB0: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AA7EB4: 40990080  ble cr6, 0x82aa7f34
	if !ctx.cr[6].gt {
	pc = 0x82AA7F34; continue 'dispatch;
	}
	pc = 0x82AA7EB8; continue 'dispatch;
            }
            0x82AA7EB8 => {
    //   block [0x82AA7EB8..0x82AA7ED4)
	// 82AA7EB8: 8146FFF8  lwz r10, -8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7EBC: 3966FFF8  addi r11, r6, -8
	ctx.r[11].s64 = ctx.r[6].s64 + -8;
	// 82AA7EC0: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7EC4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AA7EC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA7ECC: 41990008  bgt cr6, 0x82aa7ed4
	if ctx.cr[6].gt {
	pc = 0x82AA7ED4; continue 'dispatch;
	}
	// 82AA7ED0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82AA7ED4; continue 'dispatch;
            }
            0x82AA7ED4 => {
    //   block [0x82AA7ED4..0x82AA7EF4)
	// 82AA7ED4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82AA7ED8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA7EDC: 409A0048  bne cr6, 0x82aa7f24
	if !ctx.cr[6].eq {
	pc = 0x82AA7F24; continue 'dispatch;
	}
	// 82AA7EE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7EE4: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA7EE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA7EEC: 41990008  bgt cr6, 0x82aa7ef4
	if ctx.cr[6].gt {
	pc = 0x82AA7EF4; continue 'dispatch;
	}
	// 82AA7EF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82AA7EF4; continue 'dispatch;
            }
            0x82AA7EF4 => {
    //   block [0x82AA7EF4..0x82AA7F24)
	// 82AA7EF4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82AA7EF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA7EFC: 409A0034  bne cr6, 0x82aa7f30
	if !ctx.cr[6].eq {
	pc = 0x82AA7F30; continue 'dispatch;
	}
	// 82AA7F00: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82AA7F04: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 82AA7F08: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82AA7F0C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7F10: E8C70000  ld r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 82AA7F14: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA7F18: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7F1C: 90870004  stw r4, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AA7F20: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	pc = 0x82AA7F24; continue 'dispatch;
            }
            0x82AA7F24 => {
    //   block [0x82AA7F24..0x82AA7F30)
	// 82AA7F24: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82AA7F28: 7F1D3040  cmplw cr6, r29, r6
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82AA7F2C: 4198FF8C  blt cr6, 0x82aa7eb8
	if ctx.cr[6].lt {
	pc = 0x82AA7EB8; continue 'dispatch;
	}
	pc = 0x82AA7F30; continue 'dispatch;
            }
            0x82AA7F30 => {
    //   block [0x82AA7F30..0x82AA7F34)
	// 82AA7F30: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	pc = 0x82AA7F34; continue 'dispatch;
            }
            0x82AA7F34 => {
    //   block [0x82AA7F34..0x82AA7F60)
	// 82AA7F34: 409A0078  bne cr6, 0x82aa7fac
	if !ctx.cr[6].eq {
	pc = 0x82AA7FAC; continue 'dispatch;
	}
	// 82AA7F38: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA7F3C: 419A00F8  beq cr6, 0x82aa8034
	if ctx.cr[6].eq {
	pc = 0x82AA8034; continue 'dispatch;
	}
	// 82AA7F40: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA7F44: 419A001C  beq cr6, 0x82aa7f60
	if ctx.cr[6].eq {
	pc = 0x82AA7F60; continue 'dispatch;
	}
	// 82AA7F48: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7F4C: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 82AA7F50: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA7F54: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7F58: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA7F5C: F9450000  std r10, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x82AA7F60; continue 'dispatch;
            }
            0x82AA7F60 => {
    //   block [0x82AA7F60..0x82AA7FAC)
	// 82AA7F60: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA7F64: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82AA7F68: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA7F6C: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82AA7F70: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82AA7F74: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82AA7F78: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82AA7F7C: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82AA7F80: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82AA7F84: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA7F88: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82AA7F8C: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA7F90: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82AA7F94: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7F98: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82AA7F9C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7FA0: 906A0004  stw r3, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82AA7FA4: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82AA7FA8: 4BFFFE84  b 0x82aa7e2c
	pc = 0x82AA7E2C; continue 'dispatch;
            }
            0x82AA7FAC => {
    //   block [0x82AA7FAC..0x82AA7FE0)
	// 82AA7FAC: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AA7FB0: 38C6FFF8  addi r6, r6, -8
	ctx.r[6].s64 = ctx.r[6].s64 + -8;
	// 82AA7FB4: 409A0050  bne cr6, 0x82aa8004
	if !ctx.cr[6].eq {
	pc = 0x82AA8004; continue 'dispatch;
	}
	// 82AA7FB8: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 82AA7FBC: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82AA7FC0: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AA7FC4: 419A001C  beq cr6, 0x82aa7fe0
	if ctx.cr[6].eq {
	pc = 0x82AA7FE0; continue 'dispatch;
	}
	// 82AA7FC8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7FCC: E9460000  ld r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 82AA7FD0: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA7FD4: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7FD8: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA7FDC: F9470000  std r10, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x82AA7FE0; continue 'dispatch;
            }
            0x82AA7FE0 => {
    //   block [0x82AA7FE0..0x82AA8004)
	// 82AA7FE0: 38A5FFF8  addi r5, r5, -8
	ctx.r[5].s64 = ctx.r[5].s64 + -8;
	// 82AA7FE4: E9670000  ld r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 82AA7FE8: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82AA7FEC: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7FF0: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA7FF4: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7FF8: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA7FFC: F9650000  std r11, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AA8000: 4BFFFE2C  b 0x82aa7e2c
	pc = 0x82AA7E2C; continue 'dispatch;
            }
            0x82AA8004 => {
    //   block [0x82AA8004..0x82AA8034)
	// 82AA8004: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA8008: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82AA800C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8010: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82AA8014: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82AA8018: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA801C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AA8020: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA8024: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8028: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AA802C: F9260000  std r9, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82AA8030: 4BFFFDFC  b 0x82aa7e2c
	pc = 0x82AA7E2C; continue 'dispatch;
            }
            0x82AA8034 => {
    //   block [0x82AA8034..0x82AA8050)
	// 82AA8034: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA8038: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA803C: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA8040: F97B0000  std r11, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AA8044: F95B0008  std r10, 8(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82AA8048: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA804C: 48201408  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8050 size=152
    let mut pc: u32 = 0x82AA8050;
    'dispatch: loop {
        match pc {
            0x82AA8050 => {
    //   block [0x82AA8050..0x82AA80CC)
	// 82AA8050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA8058: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA805C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8060: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8064: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8068: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA806C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA8070: 409A005C  bne cr6, 0x82aa80cc
	if !ctx.cr[6].eq {
	pc = 0x82AA80CC; continue 'dispatch;
	}
	// 82AA8074: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA8078: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AA807C: 40990050  ble cr6, 0x82aa80cc
	if !ctx.cr[6].gt {
	pc = 0x82AA80CC; continue 'dispatch;
	}
	// 82AA8080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8084: 48000B4D  bl 0x82aa8bd0
	ctx.lr = 0x82AA8088;
	sub_82AA8BD0(ctx, base);
	// 82AA8088: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA808C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA8090: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA8094: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA8098: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA809C: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AA80A0: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA80A4: 91670008  stw r11, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA80A8: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA80AC: 9126000C  stw r9, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82AA80B0: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA80B4: 8065000C  lwz r3, 0xc(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA80B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA80BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA80C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA80C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA80C8: 4E800020  blr
	return;
            }
            0x82AA80CC => {
    //   block [0x82AA80CC..0x82AA80E8)
	// 82AA80CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA80D0: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA80D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA80D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA80DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA80E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA80E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA80E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA80E8 size=272
    let mut pc: u32 = 0x82AA80E8;
    'dispatch: loop {
        match pc {
            0x82AA80E8 => {
    //   block [0x82AA80E8..0x82AA8118)
	// 82AA80E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA80EC: 48201311  bl 0x82ca93fc
	ctx.lr = 0x82AA80F0;
	sub_82CA93D0(ctx, base);
	// 82AA80F0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA80F4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AA80F8: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82AA80FC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA8100: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82AA8104: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82AA8108: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82AA810C: 2F1D0020  cmpwi cr6, r29, 0x20
	ctx.cr[6].compare_i32(ctx.r[29].s32, 32, &mut ctx.xer);
	// 82AA8110: 41980038  blt cr6, 0x82aa8148
	if ctx.cr[6].lt {
	pc = 0x82AA8148; continue 'dispatch;
	}
	// 82AA8114: 57BFD97E  srwi r31, r29, 5
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shr(5);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x82AA8118; continue 'dispatch;
            }
            0x82AA8118 => {
    //   block [0x82AA8118..0x82AA8148)
	// 82AA8118: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA811C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA8120: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82AA8124: 394B0100  addi r10, r11, 0x100
	ctx.r[10].s64 = ctx.r[11].s64 + 256;
	// 82AA8128: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA812C: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA8130: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA8134: 4B6E59CD  bl 0x8218db00
	ctx.lr = 0x82AA8138;
	sub_8218DB00(ctx, base);
	// 82AA8138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA813C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA8140: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82AA8144: 4082FFD4  bne 0x82aa8118
	if !ctx.cr[0].eq {
	pc = 0x82AA8118; continue 'dispatch;
	}
	pc = 0x82AA8148; continue 'dispatch;
            }
            0x82AA8148 => {
    //   block [0x82AA8148..0x82AA8164)
	// 82AA8148: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA814C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AA8150: 4B6E59B1  bl 0x8218db00
	ctx.lr = 0x82AA8154;
	sub_8218DB00(ctx, base);
	// 82AA8154: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 82AA8158: 2F1D0020  cmpwi cr6, r29, 0x20
	ctx.cr[6].compare_i32(ctx.r[29].s32, 32, &mut ctx.xer);
	// 82AA815C: 40990094  ble cr6, 0x82aa81f0
	if !ctx.cr[6].gt {
	pc = 0x82AA81F0; continue 'dispatch;
	}
	// 82AA8160: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82AA8164; continue 'dispatch;
            }
            0x82AA8164 => {
    //   block [0x82AA8164..0x82AA81F0)
	// 82AA8164: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8168: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82AA816C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AA8170: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82AA8174: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AA8178: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82AA817C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82AA8180: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA8184: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82AA8188: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AA818C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8190: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AA8194: 9BEA0000  stb r31, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82AA8198: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82AA819C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA81A0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA81A4: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA81A8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AA81AC: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA81B0: 48001129  bl 0x82aa92d8
	ctx.lr = 0x82AA81B4;
	sub_82AA92D8(ctx, base);
	// 82AA81B4: 39410051  addi r10, r1, 0x51
	ctx.r[10].s64 = ctx.r[1].s64 + 81;
	// 82AA81B8: 813B0014  lwz r9, 0x14(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA81BC: 57DE083C  slwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82AA81C0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82AA81C4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82AA81C8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA81CC: 9BEA0000  stb r31, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82AA81D0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA81D4: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA81D8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA81DC: 89210051  lbz r9, 0x51(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AA81E0: 48001281  bl 0x82aa9460
	ctx.lr = 0x82AA81E4;
	sub_82AA9460(ctx, base);
	// 82AA81E4: 57DE083C  slwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82AA81E8: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82AA81EC: 4198FF78  blt cr6, 0x82aa8164
	if ctx.cr[6].lt {
	pc = 0x82AA8164; continue 'dispatch;
	}
	pc = 0x82AA81F0; continue 'dispatch;
            }
            0x82AA81F0 => {
    //   block [0x82AA81F0..0x82AA81F8)
	// 82AA81F0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AA81F4: 48201258  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA81F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA81F8 size=912
    let mut pc: u32 = 0x82AA81F8;
    'dispatch: loop {
        match pc {
            0x82AA81F8 => {
    //   block [0x82AA81F8..0x82AA8240)
	// 82AA81F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA81FC: 482011E9  bl 0x82ca93e4
	ctx.lr = 0x82AA8200;
	sub_82CA93D0(ctx, base);
	// 82AA8200: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8204: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82AA8208: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82AA820C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82AA8210: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82AA8214: 7D7FCA14  add r11, r31, r25
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 82AA8218: FB010150  std r24, 0x150(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[24].u64 ) };
	// 82AA821C: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 82AA8220: FB410158  std r26, 0x158(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[26].u64 ) };
	// 82AA8224: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82AA8228: FA610160  std r19, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[19].u64 ) };
	// 82AA822C: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 82AA8230: 7D354B78  mr r21, r9
	ctx.r[21].u64 = ctx.r[9].u64;
	// 82AA8234: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AA8238: 419A01F4  beq cr6, 0x82aa842c
	if ctx.cr[6].eq {
	pc = 0x82AA842C; continue 'dispatch;
	}
	// 82AA823C: 82810164  lwz r20, 0x164(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	pc = 0x82AA8240; continue 'dispatch;
            }
            0x82AA8240 => {
    //   block [0x82AA8240..0x82AA8258)
	// 82AA8240: 7F1FC800  cmpw cr6, r31, r25
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82AA8244: 41990014  bgt cr6, 0x82aa8258
	if ctx.cr[6].gt {
	pc = 0x82AA8258; continue 'dispatch;
	}
	// 82AA8248: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82AA824C: 4BFFFE05  bl 0x82aa8050
	ctx.lr = 0x82AA8250;
	sub_82AA8050(ctx, base);
	// 82AA8250: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82AA8254: 40990224  ble cr6, 0x82aa8478
	if !ctx.cr[6].gt {
	pc = 0x82AA8478; continue 'dispatch;
	}
	pc = 0x82AA8258; continue 'dispatch;
            }
            0x82AA8258 => {
    //   block [0x82AA8258..0x82AA82A8)
	// 82AA8258: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82AA825C: 4BFFFDF5  bl 0x82aa8050
	ctx.lr = 0x82AA8260;
	sub_82AA8050(ctx, base);
	// 82AA8260: 7F191800  cmpw cr6, r25, r3
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82AA8264: 409902A0  ble cr6, 0x82aa8504
	if !ctx.cr[6].gt {
	pc = 0x82AA8504; continue 'dispatch;
	}
	// 82AA8268: 7F19F800  cmpw cr6, r25, r31
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82AA826C: 409800B0  bge cr6, 0x82aa831c
	if !ctx.cr[6].lt {
	pc = 0x82AA831C; continue 'dispatch;
	}
	// 82AA8270: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 82AA8274: 80C1015C  lwz r6, 0x15c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82AA8278: 81410154  lwz r10, 0x154(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82AA827C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82AA8280: 7F6B0194  addze r27, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[27].s64 = tmp.s64;
	// 82AA8284: FB010078  std r24, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[24].u64 ) };
	// 82AA8288: 7D06A050  subf r8, r6, r20
	ctx.r[8].s64 = ctx.r[20].s64 - ctx.r[6].s64;
	// 82AA828C: FBA10068  std r29, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u64 ) };
	// 82AA8290: 57691838  slwi r9, r27, 3
	ctx.r[9].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA8294: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA8298: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA829C: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82AA82A0: 40810068  ble 0x82aa8308
	if !ctx.cr[0].gt {
	pc = 0x82AA8308; continue 'dispatch;
	}
	// 82AA82A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AA82A8; continue 'dispatch;
            }
            0x82AA82A8 => {
    //   block [0x82AA82A8..0x82AA82D4)
	// 82AA82A8: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AA82AC: 8101006C  lwz r8, 0x6c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA82B0: FBA10070  std r29, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u64 ) };
	// 82AA82B4: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82AA82B8: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA82BC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82AA82C0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AA82C4: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA82C8: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82AA82CC: 41990008  bgt cr6, 0x82aa82d4
	if ctx.cr[6].gt {
	pc = 0x82AA82D4; continue 'dispatch;
	}
	// 82AA82D0: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	pc = 0x82AA82D4; continue 'dispatch;
            }
            0x82AA82D4 => {
    //   block [0x82AA82D4..0x82AA82FC)
	// 82AA82D4: 5508063E  clrlwi r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82AA82D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA82DC: 419A0020  beq cr6, 0x82aa82fc
	if ctx.cr[6].eq {
	pc = 0x82AA82FC; continue 'dispatch;
	}
	// 82AA82E0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AA82E4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA82E8: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82AA82EC: EBA10070  ld r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AA82F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA82F4: FBA10068  std r29, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u64 ) };
	// 82AA82F8: 48000008  b 0x82aa8300
	pc = 0x82AA8300; continue 'dispatch;
            }
            0x82AA82FC => {
    //   block [0x82AA82FC..0x82AA8300)
	// 82AA82FC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82AA8300; continue 'dispatch;
            }
            0x82AA8300 => {
    //   block [0x82AA8300..0x82AA8308)
	// 82AA8300: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA8304: 4199FFA4  bgt cr6, 0x82aa82a8
	if ctx.cr[6].gt {
	pc = 0x82AA82A8; continue 'dispatch;
	}
	pc = 0x82AA8308; continue 'dispatch;
            }
            0x82AA8308 => {
    //   block [0x82AA8308..0x82AA831C)
	// 82AA8308: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA830C: EBC10078  ld r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82AA8310: 7D465850  subf r10, r6, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82AA8314: 7D5C1E70  srawi r28, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AA8318: 480000AC  b 0x82aa83c4
	pc = 0x82AA83C4; continue 'dispatch;
            }
            0x82AA831C => {
    //   block [0x82AA831C..0x82AA8354)
	// 82AA831C: 7F2B0E70  srawi r11, r25, 1
	ctx.xer.ca = (ctx.r[25].s32 < 0) && ((ctx.r[25].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[25].s32 >> 1) as i64;
	// 82AA8320: 8141015C  lwz r10, 0x15c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82AA8324: 80C10154  lwz r6, 0x154(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82AA8328: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82AA832C: 7F8B0194  addze r28, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[28].s64 = tmp.s64;
	// 82AA8330: FB410070  std r26, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u64 ) };
	// 82AA8334: 7D065050  subf r8, r6, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 82AA8338: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 82AA833C: 57891838  slwi r9, r28, 3
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA8340: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA8344: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA8348: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82AA834C: 40810068  ble 0x82aa83b4
	if !ctx.cr[0].gt {
	pc = 0x82AA83B4; continue 'dispatch;
	}
	// 82AA8350: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AA8354; continue 'dispatch;
            }
            0x82AA8354 => {
    //   block [0x82AA8354..0x82AA8380)
	// 82AA8354: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AA8358: 8101006C  lwz r8, 0x6c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA835C: FBC10078  std r30, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u64 ) };
	// 82AA8360: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82AA8364: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA8368: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82AA836C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AA8370: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8374: 7F072800  cmpw cr6, r7, r5
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82AA8378: 41990008  bgt cr6, 0x82aa8380
	if ctx.cr[6].gt {
	pc = 0x82AA8380; continue 'dispatch;
	}
	// 82AA837C: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	pc = 0x82AA8380; continue 'dispatch;
            }
            0x82AA8380 => {
    //   block [0x82AA8380..0x82AA83A8)
	// 82AA8380: 5508063E  clrlwi r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82AA8384: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA8388: 409A0020  bne cr6, 0x82aa83a8
	if !ctx.cr[6].eq {
	pc = 0x82AA83A8; continue 'dispatch;
	}
	// 82AA838C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AA8390: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA8394: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 82AA8398: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA839C: EBC10078  ld r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82AA83A0: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 82AA83A4: 48000008  b 0x82aa83ac
	pc = 0x82AA83AC; continue 'dispatch;
            }
            0x82AA83A8 => {
    //   block [0x82AA83A8..0x82AA83AC)
	// 82AA83A8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82AA83AC; continue 'dispatch;
            }
            0x82AA83AC => {
    //   block [0x82AA83AC..0x82AA83B4)
	// 82AA83AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA83B0: 4199FFA4  bgt cr6, 0x82aa8354
	if ctx.cr[6].gt {
	pc = 0x82AA8354; continue 'dispatch;
	}
	pc = 0x82AA83B4; continue 'dispatch;
            }
            0x82AA83B4 => {
    //   block [0x82AA83B4..0x82AA83C4)
	// 82AA83B4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA83B8: EBA10070  ld r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AA83BC: 7D465850  subf r10, r6, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82AA83C0: 7D5B1E70  srawi r27, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82AA83C4; continue 'dispatch;
            }
            0x82AA83C4 => {
    //   block [0x82AA83C4..0x82AA842C)
	// 82AA83C4: 7FFBF850  subf r31, r27, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82AA83C8: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82AA83CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AA83D0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82AA83D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA83D8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA83DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA83E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA83E4: 4800095D  bl 0x82aa8d40
	ctx.lr = 0x82AA83E8;
	sub_82AA8D40(ctx, base);
	// 82AA83E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA83EC: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 82AA83F0: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82AA83F4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AA83F8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82AA83FC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82AA8400: EBC10080  ld r30, 0x80(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82AA8404: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA8408: 4BFFFDF1  bl 0x82aa81f8
	ctx.lr = 0x82AA840C;
	sub_82AA81F8(ctx, base);
	// 82AA840C: 7F3CC850  subf r25, r28, r25
	ctx.r[25].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	// 82AA8410: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 82AA8414: 7D7FCA14  add r11, r31, r25
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 82AA8418: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82AA841C: FB010150  std r24, 0x150(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[24].u64 ) };
	// 82AA8420: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AA8424: FB410158  std r26, 0x158(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[26].u64 ) };
	// 82AA8428: 409AFE18  bne cr6, 0x82aa8240
	if !ctx.cr[6].eq {
	pc = 0x82AA8240; continue 'dispatch;
	}
	pc = 0x82AA842C; continue 'dispatch;
            }
            0x82AA842C => {
    //   block [0x82AA842C..0x82AA844C)
	// 82AA842C: 8141015C  lwz r10, 0x15c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82AA8430: 81210154  lwz r9, 0x154(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82AA8434: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8438: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA843C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82AA8440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA8444: 41990008  bgt cr6, 0x82aa844c
	if ctx.cr[6].gt {
	pc = 0x82AA844C; continue 'dispatch;
	}
	// 82AA8448: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x82AA844C; continue 'dispatch;
            }
            0x82AA844C => {
    //   block [0x82AA844C..0x82AA8478)
	// 82AA844C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA8450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA8454: 419A012C  beq cr6, 0x82aa8580
	if ctx.cr[6].eq {
	pc = 0x82AA8580; continue 'dispatch;
	}
	// 82AA8458: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA845C: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82AA8460: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA8464: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8468: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA846C: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82AA8470: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82AA8474: 48200FC0  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA8478 => {
    //   block [0x82AA8478..0x82AA84C4)
	// 82AA8478: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA847C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82AA8480: 92C10090  stw r22, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 82AA8484: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA8488: 92C10094  stw r22, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[22].u32 ) };
	// 82AA848C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AA8490: 92C10098  stw r22, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[22].u32 ) };
	// 82AA8494: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA8498: 92C1009C  stw r22, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[22].u32 ) };
	// 82AA849C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA84A0: 92C100A0  stw r22, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[22].u32 ) };
	// 82AA84A4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA84A8: 81370014  lwz r9, 0x14(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA84AC: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 82AA84B0: 480007F1  bl 0x82aa8ca0
	ctx.lr = 0x82AA84B4;
	sub_82AA8CA0(ctx, base);
	// 82AA84B4: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AA84B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA84BC: 419A0008  beq cr6, 0x82aa84c4
	if ctx.cr[6].eq {
	pc = 0x82AA84C4; continue 'dispatch;
	}
	// 82AA84C0: 4B773879  bl 0x8221bd38
	ctx.lr = 0x82AA84C4;
	sub_8221BD38(ctx, base);
	pc = 0x82AA84C4; continue 'dispatch;
            }
            0x82AA84C4 => {
    //   block [0x82AA84C4..0x82AA8504)
	// 82AA84C4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82AA84C8: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA84CC: 80970014  lwz r4, 0x14(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA84D0: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 82AA84D4: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82AA84D8: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 82AA84DC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82AA84E0: 9ACB0000  stb r22, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	// 82AA84E4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA84E8: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA84EC: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA84F0: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA84F4: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82AA84F8: 48001051  bl 0x82aa9548
	ctx.lr = 0x82AA84FC;
	sub_82AA9548(ctx, base);
	// 82AA84FC: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82AA8500: 48200F34  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA8504 => {
    //   block [0x82AA8504..0x82AA8550)
	// 82AA8504: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8508: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82AA850C: 92C10090  stw r22, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 82AA8510: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 82AA8514: 92C10094  stw r22, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[22].u32 ) };
	// 82AA8518: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA851C: 92C10098  stw r22, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[22].u32 ) };
	// 82AA8520: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA8524: 92C1009C  stw r22, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[22].u32 ) };
	// 82AA8528: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA852C: 92C100A0  stw r22, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[22].u32 ) };
	// 82AA8530: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA8534: 81370014  lwz r9, 0x14(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8538: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 82AA853C: 48000765  bl 0x82aa8ca0
	ctx.lr = 0x82AA8540;
	sub_82AA8CA0(ctx, base);
	// 82AA8540: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AA8544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8548: 419A0008  beq cr6, 0x82aa8550
	if ctx.cr[6].eq {
	pc = 0x82AA8550; continue 'dispatch;
	}
	// 82AA854C: 4B7737ED  bl 0x8221bd38
	ctx.lr = 0x82AA8550;
	sub_8221BD38(ctx, base);
	pc = 0x82AA8550; continue 'dispatch;
            }
            0x82AA8550 => {
    //   block [0x82AA8550..0x82AA8580)
	// 82AA8550: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82AA8554: 81570014  lwz r10, 0x14(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8558: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 82AA855C: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 82AA8560: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA8564: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AA8568: 9ACB0000  stb r22, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	// 82AA856C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA8570: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8574: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8578: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA857C: 480010FD  bl 0x82aa9678
	ctx.lr = 0x82AA8580;
	sub_82AA9678(ctx, base);
	pc = 0x82AA8580; continue 'dispatch;
            }
            0x82AA8580 => {
    //   block [0x82AA8580..0x82AA8588)
	// 82AA8580: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82AA8584: 48200EB0  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8588 size=428
    let mut pc: u32 = 0x82AA8588;
    'dispatch: loop {
        match pc {
            0x82AA8588 => {
    //   block [0x82AA8588..0x82AA85B4)
	// 82AA8588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA858C: 48200E59  bl 0x82ca93e4
	ctx.lr = 0x82AA8590;
	sub_82CA93D0(ctx, base);
	// 82AA8590: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8594: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82AA8598: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82AA859C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82AA85A0: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 82AA85A4: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82AA85A8: 2F180020  cmpwi cr6, r24, 0x20
	ctx.cr[6].compare_i32(ctx.r[24].s32, 32, &mut ctx.xer);
	// 82AA85AC: 41980038  blt cr6, 0x82aa85e4
	if ctx.cr[6].lt {
	pc = 0x82AA85E4; continue 'dispatch;
	}
	// 82AA85B0: 571FD97E  srwi r31, r24, 5
	ctx.r[31].u32 = ctx.r[24].u32.wrapping_shr(5);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x82AA85B4; continue 'dispatch;
            }
            0x82AA85B4 => {
    //   block [0x82AA85B4..0x82AA85E4)
	// 82AA85B4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA85B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA85BC: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82AA85C0: 394B0100  addi r10, r11, 0x100
	ctx.r[10].s64 = ctx.r[11].s64 + 256;
	// 82AA85C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA85C8: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA85CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA85D0: 4B70F3A1  bl 0x821b7970
	ctx.lr = 0x82AA85D4;
	sub_821B7970(ctx, base);
	// 82AA85D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA85D8: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA85DC: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82AA85E0: 4082FFD4  bne 0x82aa85b4
	if !ctx.cr[0].eq {
	pc = 0x82AA85B4; continue 'dispatch;
	}
	pc = 0x82AA85E4; continue 'dispatch;
            }
            0x82AA85E4 => {
    //   block [0x82AA85E4..0x82AA8608)
	// 82AA85E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA85E8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82AA85EC: 4B70F385  bl 0x821b7970
	ctx.lr = 0x82AA85F0;
	sub_821B7970(ctx, base);
	// 82AA85F0: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 82AA85F4: 2F180020  cmpwi cr6, r24, 0x20
	ctx.cr[6].compare_i32(ctx.r[24].s32, 32, &mut ctx.xer);
	// 82AA85F8: 40990134  ble cr6, 0x82aa872c
	if !ctx.cr[6].gt {
	pc = 0x82AA872C; continue 'dispatch;
	}
	// 82AA85FC: 8AC10052  lbz r22, 0x52(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AA8600: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA8604: 8A610052  lbz r19, 0x52(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	pc = 0x82AA8608; continue 'dispatch;
            }
            0x82AA8608 => {
    //   block [0x82AA8608..0x82AA867C)
	// 82AA8608: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA860C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82AA8610: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82AA8614: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82AA8618: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82AA861C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA8620: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82AA8624: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82AA8628: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82AA862C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82AA8630: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8634: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82AA8638: 9BEA0000  stb r31, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82AA863C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82AA8640: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA8644: 81170014  lwz r8, 0x14(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8648: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 82AA864C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA8650: 48001251  bl 0x82aa98a0
	ctx.lr = 0x82AA8654;
	sub_82AA98A0(ctx, base);
	// 82AA8654: 80F70014  lwz r7, 0x14(r23)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8658: 57DA083C  slwi r26, r30, 1
	ctx.r[26].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82AA865C: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82AA8660: 575C083C  slwi r28, r26, 1
	ctx.r[28].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82AA8664: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 82AA8668: 7F1CC000  cmpw cr6, r28, r24
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82AA866C: 83270004  lwz r25, 4(r7)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8670: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8674: 41990044  bgt cr6, 0x82aa86b8
	if ctx.cr[6].gt {
	pc = 0x82AA86B8; continue 'dispatch;
	}
	// 82AA8678: 575B1838  slwi r27, r26, 3
	ctx.r[27].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	pc = 0x82AA867C; continue 'dispatch;
            }
            0x82AA867C => {
    //   block [0x82AA867C..0x82AA86B8)
	// 82AA867C: 39610051  addi r11, r1, 0x51
	ctx.r[11].s64 = ctx.r[1].s64 + 81;
	// 82AA8680: 7CDB2214  add r6, r27, r4
	ctx.r[6].u64 = ctx.r[27].u64 + ctx.r[4].u64;
	// 82AA8684: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 82AA8688: 7FBB3214  add r29, r27, r6
	ctx.r[29].u64 = ctx.r[27].u64 + ctx.r[6].u64;
	// 82AA868C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA8690: 9BEB0000  stb r31, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82AA8694: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82AA8698: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA869C: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AA86A0: 480019D9  bl 0x82aaa078
	ctx.lr = 0x82AA86A4;
	sub_82AAA078(ctx, base);
	// 82AA86A4: 7FDCF050  subf r30, r28, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 82AA86A8: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA86AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA86B0: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82AA86B4: 4098FFC8  bge cr6, 0x82aa867c
	if !ctx.cr[6].lt {
	pc = 0x82AA867C; continue 'dispatch;
	}
	pc = 0x82AA86B8; continue 'dispatch;
            }
            0x82AA86B8 => {
    //   block [0x82AA86B8..0x82AA86D4)
	// 82AA86B8: 7F1ED000  cmpw cr6, r30, r26
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82AA86BC: 4199003C  bgt cr6, 0x82aa86f8
	if ctx.cr[6].gt {
	pc = 0x82AA86F8; continue 'dispatch;
	}
	// 82AA86C0: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 82AA86C4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82AA86C8: 7F04C840  cmplw cr6, r4, r25
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82AA86CC: 419A0054  beq cr6, 0x82aa8720
	if ctx.cr[6].eq {
	pc = 0x82AA8720; continue 'dispatch;
	}
	// 82AA86D0: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x82AA86D4; continue 'dispatch;
            }
            0x82AA86D4 => {
    //   block [0x82AA86D4..0x82AA86F8)
	// 82AA86D4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA86D8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA86DC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA86E0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AA86E4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AA86E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AA86EC: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82AA86F0: 409AFFE4  bne cr6, 0x82aa86d4
	if !ctx.cr[6].eq {
	pc = 0x82AA86D4; continue 'dispatch;
	}
	// 82AA86F4: 4800002C  b 0x82aa8720
	pc = 0x82AA8720; continue 'dispatch;
            }
            0x82AA86F8 => {
    //   block [0x82AA86F8..0x82AA8720)
	// 82AA86F8: 39410052  addi r10, r1, 0x52
	ctx.r[10].s64 = ctx.r[1].s64 + 82;
	// 82AA86FC: 574B1838  slwi r11, r26, 3
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA8700: 7E699B78  mr r9, r19
	ctx.r[9].u64 = ctx.r[19].u64;
	// 82AA8704: 7CCB2214  add r6, r11, r4
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82AA8708: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82AA870C: 9BEA0000  stb r31, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82AA8710: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA8714: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA8718: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AA871C: 4800195D  bl 0x82aaa078
	ctx.lr = 0x82AA8720;
	sub_82AAA078(ctx, base);
	pc = 0x82AA8720; continue 'dispatch;
            }
            0x82AA8720 => {
    //   block [0x82AA8720..0x82AA872C)
	// 82AA8720: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82AA8724: 7F1CC000  cmpw cr6, r28, r24
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82AA8728: 4198FEE0  blt cr6, 0x82aa8608
	if ctx.cr[6].lt {
	pc = 0x82AA8608; continue 'dispatch;
	}
	pc = 0x82AA872C; continue 'dispatch;
            }
            0x82AA872C => {
    //   block [0x82AA872C..0x82AA8734)
	// 82AA872C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AA8730: 48200D04  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA8738 size=892
    let mut pc: u32 = 0x82AA8738;
    'dispatch: loop {
        match pc {
            0x82AA8738 => {
    //   block [0x82AA8738..0x82AA877C)
	// 82AA8738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA873C: 48200CAD  bl 0x82ca93e8
	ctx.lr = 0x82AA8740;
	sub_82CA93D0(ctx, base);
	// 82AA8740: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8744: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82AA8748: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82AA874C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82AA8750: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82AA8754: 7D7FCA14  add r11, r31, r25
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 82AA8758: FB010130  std r24, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[24].u64 ) };
	// 82AA875C: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 82AA8760: FB410138  std r26, 0x138(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[26].u64 ) };
	// 82AA8764: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82AA8768: FA810140  std r20, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[20].u64 ) };
	// 82AA876C: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 82AA8770: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AA8774: 419A01F0  beq cr6, 0x82aa8964
	if ctx.cr[6].eq {
	pc = 0x82AA8964; continue 'dispatch;
	}
	// 82AA8778: 82A10144  lwz r21, 0x144(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	pc = 0x82AA877C; continue 'dispatch;
            }
            0x82AA877C => {
    //   block [0x82AA877C..0x82AA8794)
	// 82AA877C: 7F1FC800  cmpw cr6, r31, r25
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82AA8780: 41990014  bgt cr6, 0x82aa8794
	if ctx.cr[6].gt {
	pc = 0x82AA8794; continue 'dispatch;
	}
	// 82AA8784: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82AA8788: 4BFFF8C9  bl 0x82aa8050
	ctx.lr = 0x82AA878C;
	sub_82AA8050(ctx, base);
	// 82AA878C: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82AA8790: 40990220  ble cr6, 0x82aa89b0
	if !ctx.cr[6].gt {
	pc = 0x82AA89B0; continue 'dispatch;
	}
	pc = 0x82AA8794; continue 'dispatch;
            }
            0x82AA8794 => {
    //   block [0x82AA8794..0x82AA87E4)
	// 82AA8794: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82AA8798: 4BFFF8B9  bl 0x82aa8050
	ctx.lr = 0x82AA879C;
	sub_82AA8050(ctx, base);
	// 82AA879C: 7F191800  cmpw cr6, r25, r3
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82AA87A0: 40990294  ble cr6, 0x82aa8a34
	if !ctx.cr[6].gt {
	pc = 0x82AA8A34; continue 'dispatch;
	}
	// 82AA87A4: 7F19F800  cmpw cr6, r25, r31
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82AA87A8: 409800B0  bge cr6, 0x82aa8858
	if !ctx.cr[6].lt {
	pc = 0x82AA8858; continue 'dispatch;
	}
	// 82AA87AC: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 82AA87B0: 80C1013C  lwz r6, 0x13c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82AA87B4: 81410134  lwz r10, 0x134(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82AA87B8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82AA87BC: 7F6B0194  addze r27, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[27].s64 = tmp.s64;
	// 82AA87C0: FB010068  std r24, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u64 ) };
	// 82AA87C4: 7D06A850  subf r8, r6, r21
	ctx.r[8].s64 = ctx.r[21].s64 - ctx.r[6].s64;
	// 82AA87C8: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 82AA87CC: 57691838  slwi r9, r27, 3
	ctx.r[9].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA87D0: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA87D4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA87D8: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82AA87DC: 40810068  ble 0x82aa8844
	if !ctx.cr[0].gt {
	pc = 0x82AA8844; continue 'dispatch;
	}
	// 82AA87E0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AA87E4; continue 'dispatch;
            }
            0x82AA87E4 => {
    //   block [0x82AA87E4..0x82AA8810)
	// 82AA87E4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AA87E8: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA87EC: FBA10060  std r29, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u64 ) };
	// 82AA87F0: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82AA87F4: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA87F8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82AA87FC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AA8800: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8804: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82AA8808: 41980008  blt cr6, 0x82aa8810
	if ctx.cr[6].lt {
	pc = 0x82AA8810; continue 'dispatch;
	}
	// 82AA880C: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	pc = 0x82AA8810; continue 'dispatch;
            }
            0x82AA8810 => {
    //   block [0x82AA8810..0x82AA8838)
	// 82AA8810: 5508063E  clrlwi r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82AA8814: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA8818: 419A0020  beq cr6, 0x82aa8838
	if ctx.cr[6].eq {
	pc = 0x82AA8838; continue 'dispatch;
	}
	// 82AA881C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AA8820: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA8824: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82AA8828: EBA10060  ld r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA882C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA8830: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 82AA8834: 48000008  b 0x82aa883c
	pc = 0x82AA883C; continue 'dispatch;
            }
            0x82AA8838 => {
    //   block [0x82AA8838..0x82AA883C)
	// 82AA8838: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82AA883C; continue 'dispatch;
            }
            0x82AA883C => {
    //   block [0x82AA883C..0x82AA8844)
	// 82AA883C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA8840: 4199FFA4  bgt cr6, 0x82aa87e4
	if ctx.cr[6].gt {
	pc = 0x82AA87E4; continue 'dispatch;
	}
	pc = 0x82AA8844; continue 'dispatch;
            }
            0x82AA8844 => {
    //   block [0x82AA8844..0x82AA8858)
	// 82AA8844: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA8848: EBC10068  ld r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AA884C: 7D465850  subf r10, r6, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82AA8850: 7D5C1E70  srawi r28, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AA8854: 480000AC  b 0x82aa8900
	pc = 0x82AA8900; continue 'dispatch;
            }
            0x82AA8858 => {
    //   block [0x82AA8858..0x82AA8890)
	// 82AA8858: 7F2B0E70  srawi r11, r25, 1
	ctx.xer.ca = (ctx.r[25].s32 < 0) && ((ctx.r[25].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[25].s32 >> 1) as i64;
	// 82AA885C: 8141013C  lwz r10, 0x13c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82AA8860: 80C10134  lwz r6, 0x134(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82AA8864: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82AA8868: 7F8B0194  addze r28, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[28].s64 = tmp.s64;
	// 82AA886C: FB410060  std r26, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u64 ) };
	// 82AA8870: 7D065050  subf r8, r6, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 82AA8874: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 82AA8878: 57891838  slwi r9, r28, 3
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA887C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA8880: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA8884: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82AA8888: 40810068  ble 0x82aa88f0
	if !ctx.cr[0].gt {
	pc = 0x82AA88F0; continue 'dispatch;
	}
	// 82AA888C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AA8890; continue 'dispatch;
            }
            0x82AA8890 => {
    //   block [0x82AA8890..0x82AA88BC)
	// 82AA8890: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AA8894: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA8898: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 82AA889C: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82AA88A0: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA88A4: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82AA88A8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AA88AC: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA88B0: 7F072800  cmpw cr6, r7, r5
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82AA88B4: 41980008  blt cr6, 0x82aa88bc
	if ctx.cr[6].lt {
	pc = 0x82AA88BC; continue 'dispatch;
	}
	// 82AA88B8: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	pc = 0x82AA88BC; continue 'dispatch;
            }
            0x82AA88BC => {
    //   block [0x82AA88BC..0x82AA88E4)
	// 82AA88BC: 5508063E  clrlwi r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82AA88C0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AA88C4: 409A0020  bne cr6, 0x82aa88e4
	if !ctx.cr[6].eq {
	pc = 0x82AA88E4; continue 'dispatch;
	}
	// 82AA88C8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AA88CC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA88D0: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82AA88D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA88D8: EBC10068  ld r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AA88DC: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 82AA88E0: 48000008  b 0x82aa88e8
	pc = 0x82AA88E8; continue 'dispatch;
            }
            0x82AA88E4 => {
    //   block [0x82AA88E4..0x82AA88E8)
	// 82AA88E4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82AA88E8; continue 'dispatch;
            }
            0x82AA88E8 => {
    //   block [0x82AA88E8..0x82AA88F0)
	// 82AA88E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA88EC: 4199FFA4  bgt cr6, 0x82aa8890
	if ctx.cr[6].gt {
	pc = 0x82AA8890; continue 'dispatch;
	}
	pc = 0x82AA88F0; continue 'dispatch;
            }
            0x82AA88F0 => {
    //   block [0x82AA88F0..0x82AA8900)
	// 82AA88F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA88F4: EBA10060  ld r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA88F8: 7D465850  subf r10, r6, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82AA88FC: 7D5B1E70  srawi r27, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82AA8900; continue 'dispatch;
            }
            0x82AA8900 => {
    //   block [0x82AA8900..0x82AA8964)
	// 82AA8900: 7FFBF850  subf r31, r27, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82AA8904: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82AA8908: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AA890C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82AA8910: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA8914: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA8918: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA891C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA8920: 48000421  bl 0x82aa8d40
	ctx.lr = 0x82AA8924;
	sub_82AA8D40(ctx, base);
	// 82AA8924: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA8928: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82AA892C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AA8930: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82AA8934: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82AA8938: EBC10070  ld r30, 0x70(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AA893C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA8940: 4BFFFDF9  bl 0x82aa8738
	ctx.lr = 0x82AA8944;
	sub_82AA8738(ctx, base);
	// 82AA8944: 7F3CC850  subf r25, r28, r25
	ctx.r[25].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	// 82AA8948: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 82AA894C: 7D7FCA14  add r11, r31, r25
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 82AA8950: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82AA8954: FB010130  std r24, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[24].u64 ) };
	// 82AA8958: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AA895C: FB410138  std r26, 0x138(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[26].u64 ) };
	// 82AA8960: 409AFE1C  bne cr6, 0x82aa877c
	if !ctx.cr[6].eq {
	pc = 0x82AA877C; continue 'dispatch;
	}
	pc = 0x82AA8964; continue 'dispatch;
            }
            0x82AA8964 => {
    //   block [0x82AA8964..0x82AA8984)
	// 82AA8964: 8141013C  lwz r10, 0x13c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82AA8968: 81210134  lwz r9, 0x134(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82AA896C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8970: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8974: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82AA8978: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA897C: 41980008  blt cr6, 0x82aa8984
	if ctx.cr[6].lt {
	pc = 0x82AA8984; continue 'dispatch;
	}
	// 82AA8980: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x82AA8984; continue 'dispatch;
            }
            0x82AA8984 => {
    //   block [0x82AA8984..0x82AA89B0)
	// 82AA8984: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA8988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA898C: 419A0120  beq cr6, 0x82aa8aac
	if ctx.cr[6].eq {
	pc = 0x82AA8AAC; continue 'dispatch;
	}
	// 82AA8990: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8994: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82AA8998: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA899C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA89A0: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA89A4: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82AA89A8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82AA89AC: 48200A8C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA89B0 => {
    //   block [0x82AA89B0..0x82AA89FC)
	// 82AA89B0: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA89B4: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82AA89B8: 92C10080  stw r22, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[22].u32 ) };
	// 82AA89BC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA89C0: 92C10084  stw r22, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[22].u32 ) };
	// 82AA89C4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AA89C8: 92C10088  stw r22, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[22].u32 ) };
	// 82AA89CC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA89D0: 92C1008C  stw r22, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[22].u32 ) };
	// 82AA89D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA89D8: 92C10090  stw r22, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 82AA89DC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA89E0: 81370014  lwz r9, 0x14(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA89E4: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 82AA89E8: 480002B9  bl 0x82aa8ca0
	ctx.lr = 0x82AA89EC;
	sub_82AA8CA0(ctx, base);
	// 82AA89EC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA89F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA89F4: 419A0008  beq cr6, 0x82aa89fc
	if ctx.cr[6].eq {
	pc = 0x82AA89FC; continue 'dispatch;
	}
	// 82AA89F8: 4B773341  bl 0x8221bd38
	ctx.lr = 0x82AA89FC;
	sub_8221BD38(ctx, base);
	pc = 0x82AA89FC; continue 'dispatch;
            }
            0x82AA89FC => {
    //   block [0x82AA89FC..0x82AA8A34)
	// 82AA89FC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA8A00: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA8A04: 81570014  lwz r10, 0x14(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8A08: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82AA8A0C: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 82AA8A10: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82AA8A14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA8A18: 9ACB0000  stb r22, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	// 82AA8A1C: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8A20: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8A24: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA8A28: 480011E9  bl 0x82aa9c10
	ctx.lr = 0x82AA8A2C;
	sub_82AA9C10(ctx, base);
	// 82AA8A2C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82AA8A30: 48200A08  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA8A34 => {
    //   block [0x82AA8A34..0x82AA8A80)
	// 82AA8A34: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8A38: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82AA8A3C: 92C10080  stw r22, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[22].u32 ) };
	// 82AA8A40: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82AA8A44: 92C10084  stw r22, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[22].u32 ) };
	// 82AA8A48: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA8A4C: 92C10088  stw r22, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[22].u32 ) };
	// 82AA8A50: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA8A54: 92C1008C  stw r22, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[22].u32 ) };
	// 82AA8A58: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8A5C: 92C10090  stw r22, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 82AA8A60: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA8A64: 81370014  lwz r9, 0x14(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8A68: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 82AA8A6C: 48000235  bl 0x82aa8ca0
	ctx.lr = 0x82AA8A70;
	sub_82AA8CA0(ctx, base);
	// 82AA8A70: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA8A74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8A78: 419A0008  beq cr6, 0x82aa8a80
	if ctx.cr[6].eq {
	pc = 0x82AA8A80; continue 'dispatch;
	}
	// 82AA8A7C: 4B7732BD  bl 0x8221bd38
	ctx.lr = 0x82AA8A80;
	sub_8221BD38(ctx, base);
	pc = 0x82AA8A80; continue 'dispatch;
            }
            0x82AA8A80 => {
    //   block [0x82AA8A80..0x82AA8AAC)
	// 82AA8A80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA8A84: 81570014  lwz r10, 0x14(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8A88: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	// 82AA8A8C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA8A90: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AA8A94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA8A98: 9ACB0000  stb r22, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	// 82AA8A9C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8AA0: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8AA4: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA8AA8: 48000F51  bl 0x82aa99f8
	ctx.lr = 0x82AA8AAC;
	sub_82AA99F8(ctx, base);
	pc = 0x82AA8AAC; continue 'dispatch;
            }
            0x82AA8AAC => {
    //   block [0x82AA8AAC..0x82AA8AB4)
	// 82AA8AAC: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82AA8AB0: 48200988  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA8AB8 size=276
    let mut pc: u32 = 0x82AA8AB8;
    'dispatch: loop {
        match pc {
            0x82AA8AB8 => {
    //   block [0x82AA8AB8..0x82AA8BB8)
	// 82AA8AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8ABC: 4820093D  bl 0x82ca93f8
	ctx.lr = 0x82AA8AC0;
	sub_82CA93D0(ctx, base);
	// 82AA8AC0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8AC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA8AC8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AA8ACC: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 82AA8AD0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA8AD4: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 82AA8AD8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82AA8ADC: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82AA8AE0: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA8AE4: 7D6AC050  subf r11, r10, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 82AA8AE8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AA8AEC: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 82AA8AF0: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 82AA8AF4: 409900C4  ble cr6, 0x82aa8bb8
	if !ctx.cr[6].gt {
	pc = 0x82AA8BB8; continue 'dispatch;
	}
	// 82AA8AF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AA8AFC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82AA8B00: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 82AA8B04: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AA8B08: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82AA8B0C: 557F1838  slwi r31, r11, 3
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82AA8B10: 55792036  slwi r25, r11, 4
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82AA8B14: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82AA8B18: 7D195214  add r8, r25, r10
	ctx.r[8].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 82AA8B1C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82AA8B20: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82AA8B24: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA8B28: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA8B2C: 480003D5  bl 0x82aa8f00
	ctx.lr = 0x82AA8B30;
	sub_82AA8F00(ctx, base);
	// 82AA8B30: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA8B34: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82AA8B38: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 82AA8B3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA8B40: 7CBF5850  subf r5, r31, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82AA8B44: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82AA8B48: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82AA8B4C: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82AA8B50: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82AA8B54: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA8B58: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA8B5C: 480003A5  bl 0x82aa8f00
	ctx.lr = 0x82AA8B60;
	sub_82AA8F00(ctx, base);
	// 82AA8B60: 7C99C050  subf r4, r25, r24
	ctx.r[4].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 82AA8B64: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82AA8B68: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 82AA8B6C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82AA8B70: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82AA8B74: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82AA8B78: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA8B7C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82AA8B80: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA8B84: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA8B88: 48000379  bl 0x82aa8f00
	ctx.lr = 0x82AA8B8C;
	sub_82AA8F00(ctx, base);
	// 82AA8B8C: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82AA8B90: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82AA8B94: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82AA8B98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA8B9C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82AA8BA0: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82AA8BA4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA8BA8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA8BAC: 48000355  bl 0x82aa8f00
	ctx.lr = 0x82AA8BB0;
	sub_82AA8F00(ctx, base);
	// 82AA8BB0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA8BB4: 48200894  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA8BB8 => {
    //   block [0x82AA8BB8..0x82AA8BCC)
	// 82AA8BB8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA8BBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA8BC0: 48000341  bl 0x82aa8f00
	ctx.lr = 0x82AA8BC4;
	sub_82AA8F00(ctx, base);
	// 82AA8BC4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA8BC8: 48200880  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA8BD0 size=204
    let mut pc: u32 = 0x82AA8BD0;
    'dispatch: loop {
        match pc {
            0x82AA8BD0 => {
    //   block [0x82AA8BD0..0x82AA8BF4)
	// 82AA8BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8BD4: 48200835  bl 0x82ca9408
	ctx.lr = 0x82AA8BD8;
	sub_82CA93D0(ctx, base);
	// 82AA8BD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8BDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA8BE0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA8BE4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA8BE8: 4199000C  bgt cr6, 0x82aa8bf4
	if ctx.cr[6].gt {
	pc = 0x82AA8BF4; continue 'dispatch;
	}
	// 82AA8BEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA8BF0: 4800003C  b 0x82aa8c2c
	pc = 0x82AA8C2C; continue 'dispatch;
            }
            0x82AA8BF4 => {
    //   block [0x82AA8BF4..0x82AA8C2C)
	// 82AA8BF4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82AA8BF8: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82AA8BFC: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 82AA8C00: 4098002C  bge cr6, 0x82aa8c2c
	if !ctx.cr[6].lt {
	pc = 0x82AA8C2C; continue 'dispatch;
	}
	// 82AA8C04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA8C08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA8C0C: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82AA8C10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA8C14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8C18: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AA8C1C: 4B849205  bl 0x822f1e20
	ctx.lr = 0x82AA8C20;
	sub_822F1E20(ctx, base);
	// 82AA8C20: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82AA8C24: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82AA8C28: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82AA8C2C; continue 'dispatch;
            }
            0x82AA8C2C => {
    //   block [0x82AA8C2C..0x82AA8C3C)
	// 82AA8C2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA8C30: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA8C34: 40990054  ble cr6, 0x82aa8c88
	if !ctx.cr[6].gt {
	pc = 0x82AA8C88; continue 'dispatch;
	}
	// 82AA8C38: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	pc = 0x82AA8C3C; continue 'dispatch;
            }
            0x82AA8C3C => {
    //   block [0x82AA8C3C..0x82AA8C6C)
	// 82AA8C3C: 57E31838  slwi r3, r31, 3
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AA8C40: 4B776681  bl 0x8221f2c0
	ctx.lr = 0x82AA8C44;
	sub_8221F2C0(ctx, base);
	// 82AA8C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA8C48: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA8C4C: 409A0024  bne cr6, 0x82aa8c70
	if !ctx.cr[6].eq {
	pc = 0x82AA8C70; continue 'dispatch;
	}
	// 82AA8C50: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AA8C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA8C58: 419A0014  beq cr6, 0x82aa8c6c
	if ctx.cr[6].eq {
	pc = 0x82AA8C6C; continue 'dispatch;
	}
	// 82AA8C5C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA8C60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA8C64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA8C68: 4E800421  bctrl
	ctx.lr = 0x82AA8C6C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AA8C6C => {
    //   block [0x82AA8C6C..0x82AA8C70)
	// 82AA8C6C: 4821973D  bl 0x82cc23a8
	ctx.lr = 0x82AA8C70;
	sub_82CC23A8(ctx, base);
	pc = 0x82AA8C70; continue 'dispatch;
            }
            0x82AA8C70 => {
    //   block [0x82AA8C70..0x82AA8C88)
	// 82AA8C70: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82AA8C74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA8C78: 409A0010  bne cr6, 0x82aa8c88
	if !ctx.cr[6].eq {
	pc = 0x82AA8C88; continue 'dispatch;
	}
	// 82AA8C7C: 7FEA0E70  srawi r10, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 82AA8C80: 7FEA0195  addze. r31, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA8C84: 4181FFB8  bgt 0x82aa8c3c
	if ctx.cr[0].gt {
	pc = 0x82AA8C3C; continue 'dispatch;
	}
	pc = 0x82AA8C88; continue 'dispatch;
            }
            0x82AA8C88 => {
    //   block [0x82AA8C88..0x82AA8C9C)
	// 82AA8C88: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA8C8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA8C90: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82AA8C94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA8C98: 482007C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8CA0 size=160
    let mut pc: u32 = 0x82AA8CA0;
    'dispatch: loop {
        match pc {
            0x82AA8CA0 => {
    //   block [0x82AA8CA0..0x82AA8CF4)
	// 82AA8CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8CA4: 4820075D  bl 0x82ca9400
	ctx.lr = 0x82AA8CA8;
	sub_82CA93D0(ctx, base);
	// 82AA8CA8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8CAC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82AA8CB0: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82AA8CB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA8CB8: F8A100D0  std r5, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[5].u64 ) };
	// 82AA8CBC: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA8CC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA8CC4: 836100D4  lwz r27, 0xd4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AA8CC8: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AA8CCC: 835C0014  lwz r26, 0x14(r28)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8CD0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AA8CD4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AA8CD8: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82AA8CDC: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82AA8CE0: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 82AA8CE4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82AA8CE8: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82AA8CEC: 419A0020  beq cr6, 0x82aa8d0c
	if ctx.cr[6].eq {
	pc = 0x82AA8D0C; continue 'dispatch;
	}
	// 82AA8CF0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82AA8CF4; continue 'dispatch;
            }
            0x82AA8CF4 => {
    //   block [0x82AA8CF4..0x82AA8D0C)
	// 82AA8CF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA8CF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA8CFC: 48000DED  bl 0x82aa9ae8
	ctx.lr = 0x82AA8D00;
	sub_82AA9AE8(ctx, base);
	// 82AA8D00: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82AA8D04: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AA8D08: 409AFFEC  bne cr6, 0x82aa8cf4
	if !ctx.cr[6].eq {
	pc = 0x82AA8CF4; continue 'dispatch;
	}
	pc = 0x82AA8D0C; continue 'dispatch;
            }
            0x82AA8D0C => {
    //   block [0x82AA8D0C..0x82AA8D34)
	// 82AA8D0C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8D10: 935E0014  stw r26, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 82AA8D14: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA8D18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8D1C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82AA8D20: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82AA8D24: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA8D28: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82AA8D2C: 419A0008  beq cr6, 0x82aa8d34
	if ctx.cr[6].eq {
	pc = 0x82AA8D34; continue 'dispatch;
	}
	// 82AA8D30: 4B773009  bl 0x8221bd38
	ctx.lr = 0x82AA8D34;
	sub_8221BD38(ctx, base);
	pc = 0x82AA8D34; continue 'dispatch;
            }
            0x82AA8D34 => {
    //   block [0x82AA8D34..0x82AA8D40)
	// 82AA8D34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA8D38: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA8D3C: 48200714  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8D40 size=448
    let mut pc: u32 = 0x82AA8D40;
    'dispatch: loop {
        match pc {
            0x82AA8D40 => {
    //   block [0x82AA8D40..0x82AA8DDC)
	// 82AA8D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8D44: 482006B9  bl 0x82ca93fc
	ctx.lr = 0x82AA8D48;
	sub_82CA93D0(ctx, base);
	// 82AA8D48: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8D4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA8D50: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA8D54: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82AA8D58: FBA100F8  std r29, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[29].u64 ) };
	// 82AA8D5C: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82AA8D60: FBC10100  std r30, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u64 ) };
	// 82AA8D64: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82AA8D68: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA8D6C: FB810108  std r28, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[28].u64 ) };
	// 82AA8D70: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82AA8D74: 7F1BC800  cmpw cr6, r27, r25
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82AA8D78: 4199009C  bgt cr6, 0x82aa8e14
	if ctx.cr[6].gt {
	pc = 0x82AA8E14; continue 'dispatch;
	}
	// 82AA8D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8D80: 4BFFF2D1  bl 0x82aa8050
	ctx.lr = 0x82AA8D84;
	sub_82AA8050(ctx, base);
	// 82AA8D84: 7F1B1800  cmpw cr6, r27, r3
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82AA8D88: 4199008C  bgt cr6, 0x82aa8e14
	if ctx.cr[6].gt {
	pc = 0x82AA8E14; continue 'dispatch;
	}
	// 82AA8D8C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8D90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA8D94: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82AA8D98: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA8D9C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA8DA0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA8DA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA8DA8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA8DAC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA8DB0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8DB4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA8DB8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA8DBC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA8DC0: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8DC4: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 82AA8DC8: 4BFFFED9  bl 0x82aa8ca0
	ctx.lr = 0x82AA8DCC;
	sub_82AA8CA0(ctx, base);
	// 82AA8DCC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AA8DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8DD4: 419A0008  beq cr6, 0x82aa8ddc
	if ctx.cr[6].eq {
	pc = 0x82AA8DDC; continue 'dispatch;
	}
	// 82AA8DD8: 4B772F61  bl 0x8221bd38
	ctx.lr = 0x82AA8DDC;
	sub_8221BD38(ctx, base);
	pc = 0x82AA8DDC; continue 'dispatch;
            }
            0x82AA8DDC => {
    //   block [0x82AA8DDC..0x82AA8E14)
	// 82AA8DDC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA8DE0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA8DE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA8DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8DEC: 4800097D  bl 0x82aa9768
	ctx.lr = 0x82AA8DF0;
	sub_82AA9768(ctx, base);
	// 82AA8DF0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8DF4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82AA8DF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA8DFC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8E00: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8E04: 480009DD  bl 0x82aa97e0
	ctx.lr = 0x82AA8E08;
	sub_82AA97E0(ctx, base);
	// 82AA8E08: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA8E0C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AA8E10: 4820063C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA8E14 => {
    //   block [0x82AA8E14..0x82AA8E74)
	// 82AA8E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8E18: 4BFFF239  bl 0x82aa8050
	ctx.lr = 0x82AA8E1C;
	sub_82AA8050(ctx, base);
	// 82AA8E1C: 7F191800  cmpw cr6, r25, r3
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82AA8E20: 4199008C  bgt cr6, 0x82aa8eac
	if ctx.cr[6].gt {
	pc = 0x82AA8EAC; continue 'dispatch;
	}
	// 82AA8E24: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8E28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA8E2C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82AA8E30: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA8E34: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA8E38: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA8E3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA8E40: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA8E44: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA8E48: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8E4C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA8E50: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA8E54: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA8E58: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8E5C: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 82AA8E60: 4BFFFE41  bl 0x82aa8ca0
	ctx.lr = 0x82AA8E64;
	sub_82AA8CA0(ctx, base);
	// 82AA8E64: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AA8E68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8E6C: 419A0008  beq cr6, 0x82aa8e74
	if ctx.cr[6].eq {
	pc = 0x82AA8E74; continue 'dispatch;
	}
	// 82AA8E70: 4B772EC9  bl 0x8221bd38
	ctx.lr = 0x82AA8E74;
	sub_8221BD38(ctx, base);
	pc = 0x82AA8E74; continue 'dispatch;
            }
            0x82AA8E74 => {
    //   block [0x82AA8E74..0x82AA8EAC)
	// 82AA8E74: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82AA8E78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA8E7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA8E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8E84: 480003DD  bl 0x82aa9260
	ctx.lr = 0x82AA8E88;
	sub_82AA9260(ctx, base);
	// 82AA8E88: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8E8C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA8E90: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA8E94: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8E98: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8E9C: 480009A5  bl 0x82aa9840
	ctx.lr = 0x82AA8EA0;
	sub_82AA9840(ctx, base);
	// 82AA8EA0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA8EA4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AA8EA8: 482005A4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA8EAC => {
    //   block [0x82AA8EAC..0x82AA8EE0)
	// 82AA8EAC: 83E100FC  lwz r31, 0xfc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82AA8EB0: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AA8EB4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA8EB8: 419A0028  beq cr6, 0x82aa8ee0
	if ctx.cr[6].eq {
	pc = 0x82AA8EE0; continue 'dispatch;
	}
	// 82AA8EBC: 8141010C  lwz r10, 0x10c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82AA8EC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA8EC4: 419A001C  beq cr6, 0x82aa8ee0
	if ctx.cr[6].eq {
	pc = 0x82AA8EE0; continue 'dispatch;
	}
	// 82AA8EC8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82AA8ECC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA8ED0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA8ED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA8ED8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA8EDC: 4BFEA0DD  bl 0x82a92fb8
	ctx.lr = 0x82AA8EE0;
	sub_82A92FB8(ctx, base);
	pc = 0x82AA8EE0; continue 'dispatch;
            }
            0x82AA8EE0 => {
    //   block [0x82AA8EE0..0x82AA8F00)
	// 82AA8EE0: 572B1838  slwi r11, r25, 3
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA8EE4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA8EE8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AA8EEC: 916100FC  stw r11, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82AA8EF0: E94100F8  ld r10, 0xf8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 82AA8EF4: F95A0000  std r10, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82AA8EF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AA8EFC: 48200550  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA8F00 size=208
    let mut pc: u32 = 0x82AA8F00;
    'dispatch: loop {
        match pc {
            0x82AA8F00 => {
    //   block [0x82AA8F00..0x82AA8F2C)
	// 82AA8F00: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 82AA8F04: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82AA8F08: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA8F0C: 81010014  lwz r8, 0x14(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8F10: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82AA8F14: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F18: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F1C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AA8F20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA8F24: 41990008  bgt cr6, 0x82aa8f2c
	if ctx.cr[6].gt {
	pc = 0x82AA8F2C; continue 'dispatch;
	}
	// 82AA8F28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82AA8F2C; continue 'dispatch;
            }
            0x82AA8F2C => {
    //   block [0x82AA8F2C..0x82AA8F50)
	// 82AA8F2C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82AA8F30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA8F34: 419A001C  beq cr6, 0x82aa8f50
	if ctx.cr[6].eq {
	pc = 0x82AA8F50; continue 'dispatch;
	}
	// 82AA8F38: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F3C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AA8F40: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA8F44: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8F48: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA8F4C: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x82AA8F50; continue 'dispatch;
            }
            0x82AA8F50 => {
    //   block [0x82AA8F50..0x82AA8F6C)
	// 82AA8F50: 81210024  lwz r9, 0x24(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AA8F54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F58: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F5C: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA8F60: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA8F64: 41990008  bgt cr6, 0x82aa8f6c
	if ctx.cr[6].gt {
	pc = 0x82AA8F6C; continue 'dispatch;
	}
	// 82AA8F68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82AA8F6C; continue 'dispatch;
            }
            0x82AA8F6C => {
    //   block [0x82AA8F6C..0x82AA8F90)
	// 82AA8F6C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82AA8F70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA8F74: 419A001C  beq cr6, 0x82aa8f90
	if ctx.cr[6].eq {
	pc = 0x82AA8F90; continue 'dispatch;
	}
	// 82AA8F78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F7C: E8E90000  ld r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82AA8F80: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA8F84: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8F88: 90C90004  stw r6, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AA8F8C: F8EB0000  std r7, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	pc = 0x82AA8F90; continue 'dispatch;
            }
            0x82AA8F90 => {
    //   block [0x82AA8F90..0x82AA8FA8)
	// 82AA8F90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F94: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F98: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AA8F9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA8FA0: 41990008  bgt cr6, 0x82aa8fa8
	if ctx.cr[6].gt {
	pc = 0x82AA8FA8; continue 'dispatch;
	}
	// 82AA8FA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82AA8FA8; continue 'dispatch;
            }
            0x82AA8FA8 => {
    //   block [0x82AA8FA8..0x82AA8FD0)
	// 82AA8FA8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82AA8FAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA8FB0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AA8FB4: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8FB8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AA8FBC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA8FC0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8FC4: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA8FC8: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82AA8FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA8FD0 size=324
    let mut pc: u32 = 0x82AA8FD0;
    'dispatch: loop {
        match pc {
            0x82AA8FD0 => {
    //   block [0x82AA8FD0..0x82AA8FF4)
	// 82AA8FD0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82AA8FD4: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 82AA8FD8: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 82AA8FDC: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA8FE0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AA8FE4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA8FE8: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82AA8FEC: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82AA8FF0: 40980074  bge cr6, 0x82aa9064
	if !ctx.cr[6].lt {
	pc = 0x82AA9064; continue 'dispatch;
	}
	pc = 0x82AA8FF4; continue 'dispatch;
            }
            0x82AA8FF4 => {
    //   block [0x82AA8FF4..0x82AA901C)
	// 82AA8FF4: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA8FF8: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA8FFC: 3909FFF8  addi r8, r9, -8
	ctx.r[8].s64 = ctx.r[9].s64 + -8;
	// 82AA9000: 9101FFF4  stw r8, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 82AA9004: 80E9FFF8  lwz r7, -8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9008: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA900C: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82AA9010: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA9014: 41990008  bgt cr6, 0x82aa901c
	if ctx.cr[6].gt {
	pc = 0x82AA901C; continue 'dispatch;
	}
	// 82AA9018: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82AA901C; continue 'dispatch;
            }
            0x82AA901C => {
    //   block [0x82AA901C..0x82AA902C)
	// 82AA901C: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82AA9020: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA9024: 419A0008  beq cr6, 0x82aa902c
	if ctx.cr[6].eq {
	pc = 0x82AA902C; continue 'dispatch;
	}
	// 82AA9028: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82AA902C; continue 'dispatch;
            }
            0x82AA902C => {
    //   block [0x82AA902C..0x82AA9064)
	// 82AA902C: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA9030: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82AA9034: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA9038: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA903C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82AA9040: 54EB083C  slwi r11, r7, 1
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA9044: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AA9048: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA904C: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82AA9050: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82AA9054: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9058: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA905C: 4198FF98  blt cr6, 0x82aa8ff4
	if ctx.cr[6].lt {
	pc = 0x82AA8FF4; continue 'dispatch;
	}
	// 82AA9060: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	pc = 0x82AA9064; continue 'dispatch;
            }
            0x82AA9064 => {
    //   block [0x82AA9064..0x82AA9090)
	// 82AA9064: 409A002C  bne cr6, 0x82aa9090
	if !ctx.cr[6].eq {
	pc = 0x82AA9090; continue 'dispatch;
	}
	// 82AA9068: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA906C: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA9070: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AA9074: 7D685214  add r11, r8, r10
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AA9078: 3885FFFF  addi r4, r5, -1
	ctx.r[4].s64 = ctx.r[5].s64 + -1;
	// 82AA907C: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82AA9080: 810BFFF8  lwz r8, -8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9084: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AA9088: 80EBFFFC  lwz r7, -4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AA908C: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82AA9090; continue 'dispatch;
            }
            0x82AA9090 => {
    //   block [0x82AA9090..0x82AA90AC)
	// 82AA9090: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82AA9094: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82AA9098: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AA909C: 7F032000  cmpw cr6, r3, r4
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82AA90A0: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82AA90A4: 40980060  bge cr6, 0x82aa9104
	if !ctx.cr[6].lt {
	pc = 0x82AA9104; continue 'dispatch;
	}
	// 82AA90A8: 80A10028  lwz r5, 0x28(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) } as u64;
	pc = 0x82AA90AC; continue 'dispatch;
            }
            0x82AA90AC => {
    //   block [0x82AA90AC..0x82AA90C8)
	// 82AA90AC: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA90B0: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA90B4: 7D29502E  lwzx r9, r9, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA90B8: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82AA90BC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA90C0: 41990008  bgt cr6, 0x82aa90c8
	if ctx.cr[6].gt {
	pc = 0x82AA90C8; continue 'dispatch;
	}
	// 82AA90C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82AA90C8; continue 'dispatch;
            }
            0x82AA90C8 => {
    //   block [0x82AA90C8..0x82AA9104)
	// 82AA90C8: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82AA90CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA90D0: 419A0034  beq cr6, 0x82aa9104
	if ctx.cr[6].eq {
	pc = 0x82AA9104; continue 'dispatch;
	}
	// 82AA90D4: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA90D8: 83E70000  lwz r31, 0(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA90DC: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 82AA90E0: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA90E4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82AA90E8: 7C8B0E70  srawi r11, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82AA90EC: 7F034000  cmpw cr6, r3, r8
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82AA90F0: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82AA90F4: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA90F8: 80E70004  lwz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA90FC: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA9100: 4198FFAC  blt cr6, 0x82aa90ac
	if ctx.cr[6].lt {
	pc = 0x82AA90AC; continue 'dispatch;
	}
	pc = 0x82AA9104; continue 'dispatch;
            }
            0x82AA9104 => {
    //   block [0x82AA9104..0x82AA9114)
	// 82AA9104: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA9108: 7CCB512A  stdx r6, r11, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u64) };
	// 82AA910C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82AA9110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA9118 size=324
    let mut pc: u32 = 0x82AA9118;
    'dispatch: loop {
        match pc {
            0x82AA9118 => {
    //   block [0x82AA9118..0x82AA913C)
	// 82AA9118: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82AA911C: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 82AA9120: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 82AA9124: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9128: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AA912C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA9130: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82AA9134: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82AA9138: 40980074  bge cr6, 0x82aa91ac
	if !ctx.cr[6].lt {
	pc = 0x82AA91AC; continue 'dispatch;
	}
	pc = 0x82AA913C; continue 'dispatch;
            }
            0x82AA913C => {
    //   block [0x82AA913C..0x82AA9164)
	// 82AA913C: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA9140: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA9144: 3909FFF8  addi r8, r9, -8
	ctx.r[8].s64 = ctx.r[9].s64 + -8;
	// 82AA9148: 9101FFF4  stw r8, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 82AA914C: 80E9FFF8  lwz r7, -8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9150: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9154: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82AA9158: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA915C: 41980008  blt cr6, 0x82aa9164
	if ctx.cr[6].lt {
	pc = 0x82AA9164; continue 'dispatch;
	}
	// 82AA9160: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82AA9164; continue 'dispatch;
            }
            0x82AA9164 => {
    //   block [0x82AA9164..0x82AA9174)
	// 82AA9164: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82AA9168: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA916C: 419A0008  beq cr6, 0x82aa9174
	if ctx.cr[6].eq {
	pc = 0x82AA9174; continue 'dispatch;
	}
	// 82AA9170: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82AA9174; continue 'dispatch;
            }
            0x82AA9174 => {
    //   block [0x82AA9174..0x82AA91AC)
	// 82AA9174: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA9178: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82AA917C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA9180: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA9184: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82AA9188: 54EB083C  slwi r11, r7, 1
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA918C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AA9190: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9194: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82AA9198: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82AA919C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA91A0: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA91A4: 4198FF98  blt cr6, 0x82aa913c
	if ctx.cr[6].lt {
	pc = 0x82AA913C; continue 'dispatch;
	}
	// 82AA91A8: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	pc = 0x82AA91AC; continue 'dispatch;
            }
            0x82AA91AC => {
    //   block [0x82AA91AC..0x82AA91D8)
	// 82AA91AC: 409A002C  bne cr6, 0x82aa91d8
	if !ctx.cr[6].eq {
	pc = 0x82AA91D8; continue 'dispatch;
	}
	// 82AA91B0: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA91B4: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA91B8: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AA91BC: 7D685214  add r11, r8, r10
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AA91C0: 3885FFFF  addi r4, r5, -1
	ctx.r[4].s64 = ctx.r[5].s64 + -1;
	// 82AA91C4: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82AA91C8: 810BFFF8  lwz r8, -8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA91CC: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AA91D0: 80EBFFFC  lwz r7, -4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AA91D4: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82AA91D8; continue 'dispatch;
            }
            0x82AA91D8 => {
    //   block [0x82AA91D8..0x82AA91F4)
	// 82AA91D8: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82AA91DC: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82AA91E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AA91E4: 7F032000  cmpw cr6, r3, r4
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82AA91E8: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82AA91EC: 40980060  bge cr6, 0x82aa924c
	if !ctx.cr[6].lt {
	pc = 0x82AA924C; continue 'dispatch;
	}
	// 82AA91F0: 80A10028  lwz r5, 0x28(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) } as u64;
	pc = 0x82AA91F4; continue 'dispatch;
            }
            0x82AA91F4 => {
    //   block [0x82AA91F4..0x82AA9210)
	// 82AA91F4: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA91F8: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA91FC: 7D29502E  lwzx r9, r9, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA9200: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82AA9204: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA9208: 41980008  blt cr6, 0x82aa9210
	if ctx.cr[6].lt {
	pc = 0x82AA9210; continue 'dispatch;
	}
	// 82AA920C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82AA9210; continue 'dispatch;
            }
            0x82AA9210 => {
    //   block [0x82AA9210..0x82AA924C)
	// 82AA9210: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82AA9214: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA9218: 419A0034  beq cr6, 0x82aa924c
	if ctx.cr[6].eq {
	pc = 0x82AA924C; continue 'dispatch;
	}
	// 82AA921C: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA9220: 83E70000  lwz r31, 0(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9224: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 82AA9228: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AA922C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82AA9230: 7C8B0E70  srawi r11, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82AA9234: 7F034000  cmpw cr6, r3, r8
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82AA9238: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82AA923C: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA9240: 80E70004  lwz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9244: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA9248: 4198FFAC  blt cr6, 0x82aa91f4
	if ctx.cr[6].lt {
	pc = 0x82AA91F4; continue 'dispatch;
	}
	pc = 0x82AA924C; continue 'dispatch;
            }
            0x82AA924C => {
    //   block [0x82AA924C..0x82AA925C)
	// 82AA924C: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA9250: 7CCB512A  stdx r6, r11, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u64) };
	// 82AA9254: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82AA9258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA9260 size=116
    let mut pc: u32 = 0x82AA9260;
    'dispatch: loop {
        match pc {
            0x82AA9260 => {
    //   block [0x82AA9260..0x82AA92B0)
	// 82AA9260: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82AA9264: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82AA9268: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82AA926C: 8141002C  lwz r10, 0x2c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AA9270: 8121001C  lwz r9, 0x1c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA9274: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AA9278: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82AA927C: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82AA9280: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82AA9284: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82AA9288: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA928C: 54E61838  slwi r6, r7, 3
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82AA9290: F8A1FFE8  std r5, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[5].u64 ) };
	// 82AA9294: 7CA65050  subf r5, r6, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 82AA9298: 90A1FFE4  stw r5, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[5].u32 ) };
	// 82AA929C: E881FFE0  ld r4, -0x20(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AA92A0: F8830000  std r4, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 82AA92A4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AA92A8: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82AA92AC: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	pc = 0x82AA92B0; continue 'dispatch;
            }
            0x82AA92B0 => {
    //   block [0x82AA92B0..0x82AA92D4)
	// 82AA92B0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82AA92B4: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82AA92B8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA92BC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA92C0: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AA92C4: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA92C8: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA92CC: 409AFFE4  bne cr6, 0x82aa92b0
	if !ctx.cr[6].eq {
	pc = 0x82AA92B0; continue 'dispatch;
	}
	// 82AA92D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA92D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA92D8 size=392
    let mut pc: u32 = 0x82AA92D8;
    'dispatch: loop {
        match pc {
            0x82AA92D8 => {
    //   block [0x82AA92D8..0x82AA9314)
	// 82AA92D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA92DC: 48200115  bl 0x82ca93f0
	ctx.lr = 0x82AA92E0;
	sub_82CA93D0(ctx, base);
	// 82AA92E0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA92E4: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82AA92E8: F8610110  std r3, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[3].u64 ) };
	// 82AA92EC: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82AA92F0: 56F8083C  slwi r24, r23, 1
	ctx.r[24].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 82AA92F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA92F8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82AA92FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA9300: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82AA9304: 7F18D000  cmpw cr6, r24, r26
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82AA9308: 419900A8  bgt cr6, 0x82aa93b0
	if ctx.cr[6].gt {
	pc = 0x82AA93B0; continue 'dispatch;
	}
	// 82AA930C: 8B210060  lbz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA9310: 56FD1838  slwi r29, r23, 3
	ctx.r[29].u32 = ctx.r[23].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x82AA9314; continue 'dispatch;
            }
            0x82AA9314 => {
    //   block [0x82AA9314..0x82AA939C)
	// 82AA9314: 81610114  lwz r11, 0x114(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82AA9318: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82AA931C: 9BEA0000  stb r31, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82AA9320: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AA9324: F8610068  std r3, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u64 ) };
	// 82AA9328: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA932C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA9330: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA9334: 7CFD5A14  add r7, r29, r11
	ctx.r[7].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AA9338: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AA933C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82AA9340: F8C10068  std r6, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[6].u64 ) };
	// 82AA9344: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82AA9348: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 82AA934C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82AA9350: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA9354: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AA9358: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82AA935C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA9360: EB810068  ld r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AA9364: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AA9368: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82AA936C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82AA9370: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82AA9374: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82AA9378: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82AA937C: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82AA9380: 48000979  bl 0x82aa9cf8
	ctx.lr = 0x82AA9384;
	sub_82AA9CF8(ctx, base);
	// 82AA9384: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA9388: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA938C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9390: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82AA9394: 419A0008  beq cr6, 0x82aa939c
	if ctx.cr[6].eq {
	pc = 0x82AA939C; continue 'dispatch;
	}
	// 82AA9398: 4B7729A1  bl 0x8221bd38
	ctx.lr = 0x82AA939C;
	sub_8221BD38(ctx, base);
	pc = 0x82AA939C; continue 'dispatch;
            }
            0x82AA939C => {
    //   block [0x82AA939C..0x82AA93B0)
	// 82AA939C: 7F58D050  subf r26, r24, r26
	ctx.r[26].s64 = ctx.r[26].s64 - ctx.r[24].s64;
	// 82AA93A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA93A4: 7F1AC000  cmpw cr6, r26, r24
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82AA93A8: F8610110  std r3, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[3].u64 ) };
	// 82AA93AC: 4098FF68  bge cr6, 0x82aa9314
	if !ctx.cr[6].lt {
	pc = 0x82AA9314; continue 'dispatch;
	}
	pc = 0x82AA93B0; continue 'dispatch;
            }
            0x82AA93B0 => {
    //   block [0x82AA93B0..0x82AA93EC)
	// 82AA93B0: 7F1AB800  cmpw cr6, r26, r23
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[23].s32, &mut ctx.xer);
	// 82AA93B4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82AA93B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA93BC: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82AA93C0: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82AA93C4: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82AA93C8: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82AA93CC: 41990020  bgt cr6, 0x82aa93ec
	if ctx.cr[6].gt {
	pc = 0x82AA93EC; continue 'dispatch;
	}
	// 82AA93D0: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA93D4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82AA93D8: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82AA93DC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AA93E0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AA93E4: 4BFFF8BD  bl 0x82aa8ca0
	ctx.lr = 0x82AA93E8;
	sub_82AA8CA0(ctx, base);
	// 82AA93E8: 48000050  b 0x82aa9438
	pc = 0x82AA9438; continue 'dispatch;
            }
            0x82AA93EC => {
    //   block [0x82AA93EC..0x82AA9438)
	// 82AA93EC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82AA93F0: 81610114  lwz r11, 0x114(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82AA93F4: 56EA1838  slwi r10, r23, 3
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA93F8: 80DE0014  lwz r6, 0x14(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA93FC: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 82AA9400: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82AA9404: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA9408: F8610068  std r3, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u64 ) };
	// 82AA940C: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82AA9410: 9BE80000  stb r31, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82AA9414: 90A1006C  stw r5, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[5].u32 ) };
	// 82AA9418: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82AA941C: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AA9420: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AA9424: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA9428: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA942C: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA9430: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82AA9434: 480008C5  bl 0x82aa9cf8
	ctx.lr = 0x82AA9438;
	sub_82AA9CF8(ctx, base);
	pc = 0x82AA9438; continue 'dispatch;
            }
            0x82AA9438 => {
    //   block [0x82AA9438..0x82AA9448)
	// 82AA9438: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA943C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9440: 419A0008  beq cr6, 0x82aa9448
	if ctx.cr[6].eq {
	pc = 0x82AA9448; continue 'dispatch;
	}
	// 82AA9444: 4B7728F5  bl 0x8221bd38
	ctx.lr = 0x82AA9448;
	sub_8221BD38(ctx, base);
	pc = 0x82AA9448; continue 'dispatch;
            }
            0x82AA9448 => {
    //   block [0x82AA9448..0x82AA9458)
	// 82AA9448: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA944C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9450: 419A0008  beq cr6, 0x82aa9458
	if ctx.cr[6].eq {
	pc = 0x82AA9458; continue 'dispatch;
	}
	// 82AA9454: 4B7728E5  bl 0x8221bd38
	ctx.lr = 0x82AA9458;
	sub_8221BD38(ctx, base);
	pc = 0x82AA9458; continue 'dispatch;
            }
            0x82AA9458 => {
    //   block [0x82AA9458..0x82AA9460)
	// 82AA9458: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AA945C: 481FFFE4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9460 size=228
    let mut pc: u32 = 0x82AA9460;
    'dispatch: loop {
        match pc {
            0x82AA9460 => {
    //   block [0x82AA9460..0x82AA9498)
	// 82AA9460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9464: 481FFF91  bl 0x82ca93f4
	ctx.lr = 0x82AA9468;
	sub_82CA93D0(ctx, base);
	// 82AA9468: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA946C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82AA9470: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82AA9474: 571D083C  slwi r29, r24, 1
	ctx.r[29].u32 = ctx.r[24].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82AA9478: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82AA947C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82AA9480: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82AA9484: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AA9488: 7F1DF800  cmpw cr6, r29, r31
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82AA948C: 41990058  bgt cr6, 0x82aa94e4
	if ctx.cr[6].gt {
	pc = 0x82AA94E4; continue 'dispatch;
	}
	// 82AA9490: 8B210060  lbz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA9494: 571C1838  slwi r28, r24, 3
	ctx.r[28].u32 = ctx.r[24].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	pc = 0x82AA9498; continue 'dispatch;
            }
            0x82AA9498 => {
    //   block [0x82AA9498..0x82AA94E4)
	// 82AA9498: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82AA949C: 7CDC1A14  add r6, r28, r3
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 82AA94A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA94A4: 7FDC3214  add r30, r28, r6
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[6].u64;
	// 82AA94A8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82AA94AC: 9B4A0000  stb r26, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82AA94B0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AA94B4: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82AA94B8: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82AA94BC: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA94C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA94C4: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA94C8: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82AA94CC: 4800096D  bl 0x82aa9e38
	ctx.lr = 0x82AA94D0;
	sub_82AA9E38(ctx, base);
	// 82AA94D0: 7FFDF850  subf r31, r29, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 82AA94D4: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AA94D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA94DC: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82AA94E0: 4098FFB8  bge cr6, 0x82aa9498
	if !ctx.cr[6].lt {
	pc = 0x82AA9498; continue 'dispatch;
	}
	pc = 0x82AA94E4; continue 'dispatch;
            }
            0x82AA94E4 => {
    //   block [0x82AA94E4..0x82AA9508)
	// 82AA94E4: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82AA94E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA94EC: 4199001C  bgt cr6, 0x82aa9508
	if ctx.cr[6].gt {
	pc = 0x82AA9508; continue 'dispatch;
	}
	// 82AA94F0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82AA94F4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82AA94F8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA94FC: 48000345  bl 0x82aa9840
	ctx.lr = 0x82AA9500;
	sub_82AA9840(ctx, base);
	// 82AA9500: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AA9504: 481FFF40  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AA9508 => {
    //   block [0x82AA9508..0x82AA9544)
	// 82AA9508: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82AA950C: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA9510: 57081838  slwi r8, r24, 3
	ctx.r[8].u32 = ctx.r[24].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA9514: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82AA9518: 7CC81A14  add r6, r8, r3
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 82AA951C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82AA9520: 9B470000  stb r26, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82AA9524: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 82AA9528: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA952C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA9530: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA9534: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82AA9538: 48000901  bl 0x82aa9e38
	ctx.lr = 0x82AA953C;
	sub_82AA9E38(ctx, base);
	// 82AA953C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AA9540: 481FFF04  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9548 size=304
    let mut pc: u32 = 0x82AA9548;
    'dispatch: loop {
        match pc {
            0x82AA9548 => {
    //   block [0x82AA9548..0x82AA95D0)
	// 82AA9548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA954C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA9550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA9554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA9558: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA955C: F8C100A8  std r6, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[6].u64 ) };
	// 82AA9560: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82AA9564: F90100B8  std r8, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[8].u64 ) };
	// 82AA9568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA956C: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 82AA9570: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82AA9574: FBC100B0  std r30, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u64 ) };
	// 82AA9578: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA957C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82AA9580: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AA9584: 80E100B4  lwz r7, 0xb4(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AA9588: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA958C: 814100BC  lwz r10, 0xbc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AA9590: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82AA9594: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AA9598: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA959C: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA95A0: 7D233850  subf r9, r3, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[3].s64;
	// 82AA95A4: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82AA95A8: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82AA95AC: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AA95B0: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA95B4: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA95B8: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82AA95BC: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AA95C0: F87F0000  std r3, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 82AA95C4: 419A0074  beq cr6, 0x82aa9638
	if ctx.cr[6].eq {
	pc = 0x82AA9638; continue 'dispatch;
	}
	// 82AA95C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA95CC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82AA95D0; continue 'dispatch;
            }
            0x82AA95D0 => {
    //   block [0x82AA95D0..0x82AA95F0)
	// 82AA95D0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AA95D4: 419A0064  beq cr6, 0x82aa9638
	if ctx.cr[6].eq {
	pc = 0x82AA9638; continue 'dispatch;
	}
	// 82AA95D8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA95DC: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA95E0: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82AA95E4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA95E8: 41990008  bgt cr6, 0x82aa95f0
	if ctx.cr[6].gt {
	pc = 0x82AA95F0; continue 'dispatch;
	}
	// 82AA95EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82AA95F0; continue 'dispatch;
            }
            0x82AA95F0 => {
    //   block [0x82AA95F0..0x82AA9614)
	// 82AA95F0: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82AA95F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA95F8: 419A001C  beq cr6, 0x82aa9614
	if ctx.cr[6].eq {
	pc = 0x82AA9614; continue 'dispatch;
	}
	// 82AA95FC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9600: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA9604: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9608: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AA960C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA9610: 48000014  b 0x82aa9624
	pc = 0x82AA9624; continue 'dispatch;
            }
            0x82AA9614 => {
    //   block [0x82AA9614..0x82AA9624)
	// 82AA9614: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9618: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA961C: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9620: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	pc = 0x82AA9624; continue 'dispatch;
            }
            0x82AA9624 => {
    //   block [0x82AA9624..0x82AA9638)
	// 82AA9624: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AA9628: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AA962C: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA9630: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA9634: 409AFF9C  bne cr6, 0x82aa95d0
	if !ctx.cr[6].eq {
	pc = 0x82AA95D0; continue 'dispatch;
	}
	pc = 0x82AA9638; continue 'dispatch;
            }
            0x82AA9638 => {
    //   block [0x82AA9638..0x82AA9678)
	// 82AA9638: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA963C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA9640: 48000201  bl 0x82aa9840
	ctx.lr = 0x82AA9644;
	sub_82AA9840(ctx, base);
	// 82AA9644: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA9648: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA964C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA9650: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA9654: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AA9658: 48000111  bl 0x82aa9768
	ctx.lr = 0x82AA965C;
	sub_82AA9768(ctx, base);
	// 82AA965C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9660: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA9664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA966C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA9670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA9674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9678 size=236
    let mut pc: u32 = 0x82AA9678;
    'dispatch: loop {
        match pc {
            0x82AA9678 => {
    //   block [0x82AA9678..0x82AA96B0)
	// 82AA9678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA967C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA9680: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA9684: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9688: F8810078  std r4, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[4].u64 ) };
	// 82AA968C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA9690: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82AA9694: F9010098  std r8, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[8].u64 ) };
	// 82AA9698: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82AA969C: 80C1007C  lwz r6, 0x7c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA96A0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AA96A4: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA96A8: 419A007C  beq cr6, 0x82aa9724
	if ctx.cr[6].eq {
	pc = 0x82AA9724; continue 'dispatch;
	}
	// 82AA96AC: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	pc = 0x82AA96B0; continue 'dispatch;
            }
            0x82AA96B0 => {
    //   block [0x82AA96B0..0x82AA96DC)
	// 82AA96B0: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AA96B4: 419A0088  beq cr6, 0x82aa973c
	if ctx.cr[6].eq {
	pc = 0x82AA973C; continue 'dispatch;
	}
	// 82AA96B8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82AA96BC: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 82AA96C0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AA96C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA96C8: 80A70000  lwz r5, 0(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA96CC: 7F054800  cmpw cr6, r5, r9
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AA96D0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA96D4: 41990008  bgt cr6, 0x82aa96dc
	if ctx.cr[6].gt {
	pc = 0x82AA96DC; continue 'dispatch;
	}
	// 82AA96D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82AA96DC; continue 'dispatch;
            }
            0x82AA96DC => {
    //   block [0x82AA96DC..0x82AA9704)
	// 82AA96DC: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82AA96E0: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82AA96E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA96E8: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 82AA96EC: 419A0018  beq cr6, 0x82aa9704
	if ctx.cr[6].eq {
	pc = 0x82AA9704; continue 'dispatch;
	}
	// 82AA96F0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA96F4: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82AA96F8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA96FC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9700: 48000018  b 0x82aa9718
	pc = 0x82AA9718; continue 'dispatch;
            }
            0x82AA9704 => {
    //   block [0x82AA9704..0x82AA9718)
	// 82AA9704: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9708: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AA970C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AA9710: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA9714: 80A70004  lwz r5, 4(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82AA9718; continue 'dispatch;
            }
            0x82AA9718 => {
    //   block [0x82AA9718..0x82AA9724)
	// 82AA9718: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82AA971C: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA9720: 409AFF90  bne cr6, 0x82aa96b0
	if !ctx.cr[6].eq {
	pc = 0x82AA96B0; continue 'dispatch;
	}
	pc = 0x82AA9724; continue 'dispatch;
            }
            0x82AA9724 => {
    //   block [0x82AA9724..0x82AA973C)
	// 82AA9724: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 82AA9728: E8C10098  ld r6, 0x98(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82AA972C: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82AA9730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9734: 480000AD  bl 0x82aa97e0
	ctx.lr = 0x82AA9738;
	sub_82AA97E0(ctx, base);
	// 82AA9738: 48000014  b 0x82aa974c
	pc = 0x82AA974C; continue 'dispatch;
            }
            0x82AA973C => {
    //   block [0x82AA973C..0x82AA974C)
	// 82AA973C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9740: E8C10098  ld r6, 0x98(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82AA9744: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82AA9748: 4BFFFB19  bl 0x82aa9260
	ctx.lr = 0x82AA974C;
	sub_82AA9260(ctx, base);
	pc = 0x82AA974C; continue 'dispatch;
            }
            0x82AA974C => {
    //   block [0x82AA974C..0x82AA9764)
	// 82AA974C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9750: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA9754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA975C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA9760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA9768 size=116
    let mut pc: u32 = 0x82AA9768;
    'dispatch: loop {
        match pc {
            0x82AA9768 => {
    //   block [0x82AA9768..0x82AA97B8)
	// 82AA9768: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82AA976C: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82AA9770: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82AA9774: 8141002C  lwz r10, 0x2c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AA9778: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA977C: 81210024  lwz r9, 0x24(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AA9780: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AA9784: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82AA9788: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82AA978C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA9790: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82AA9794: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA9798: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82AA979C: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AA97A0: 90C1FFE4  stw r6, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[6].u32 ) };
	// 82AA97A4: E8A1FFE0  ld r5, -0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AA97A8: F8A30000  std r5, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82AA97AC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AA97B0: 8141FFEC  lwz r10, -0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82AA97B4: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	pc = 0x82AA97B8; continue 'dispatch;
            }
            0x82AA97B8 => {
    //   block [0x82AA97B8..0x82AA97DC)
	// 82AA97B8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA97BC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AA97C0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA97C4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AA97C8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA97CC: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA97D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AA97D4: 409AFFE4  bne cr6, 0x82aa97b8
	if !ctx.cr[6].eq {
	pc = 0x82AA97B8; continue 'dispatch;
	}
	// 82AA97D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA97E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA97E0 size=96
    let mut pc: u32 = 0x82AA97E0;
    'dispatch: loop {
        match pc {
            0x82AA97E0 => {
    //   block [0x82AA97E0..0x82AA981C)
	// 82AA97E0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82AA97E4: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82AA97E8: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82AA97EC: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82AA97F0: 8101002C  lwz r8, 0x2c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AA97F4: F8C1FFF8  std r6, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[6].u64 ) };
	// 82AA97F8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA97FC: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AA9800: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82AA9804: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82AA9808: 90C1FFF4  stw r6, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[6].u32 ) };
	// 82AA980C: E8A1FFF0  ld r5, -0x10(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA9810: F8A30000  std r5, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82AA9814: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AA9818: 8141FFFC  lwz r10, -4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) } as u64;
	pc = 0x82AA981C; continue 'dispatch;
            }
            0x82AA981C => {
    //   block [0x82AA981C..0x82AA9840)
	// 82AA981C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82AA9820: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82AA9824: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82AA9828: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA982C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA9830: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9834: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AA9838: 409AFFE4  bne cr6, 0x82aa981c
	if !ctx.cr[6].eq {
	pc = 0x82AA981C; continue 'dispatch;
	}
	// 82AA983C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA9840 size=96
    let mut pc: u32 = 0x82AA9840;
    'dispatch: loop {
        match pc {
            0x82AA9840 => {
    //   block [0x82AA9840..0x82AA987C)
	// 82AA9840: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82AA9844: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82AA9848: 8121002C  lwz r9, 0x2c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AA984C: 7D4B2850  subf r10, r11, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82AA9850: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82AA9854: F8C1FFF8  std r6, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[6].u64 ) };
	// 82AA9858: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA985C: 7D481E70  srawi r8, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AA9860: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA9864: 7CEA4A14  add r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82AA9868: 90E1FFF4  stw r7, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[7].u32 ) };
	// 82AA986C: E8C1FFF0  ld r6, -0x10(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA9870: F8C30000  std r6, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82AA9874: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AA9878: 8141FFFC  lwz r10, -4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) } as u64;
	pc = 0x82AA987C; continue 'dispatch;
            }
            0x82AA987C => {
    //   block [0x82AA987C..0x82AA98A0)
	// 82AA987C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9880: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA9884: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9888: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AA988C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AA9890: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AA9894: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA9898: 409AFFE4  bne cr6, 0x82aa987c
	if !ctx.cr[6].eq {
	pc = 0x82AA987C; continue 'dispatch;
	}
	// 82AA989C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA98A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA98A0 size=340
    let mut pc: u32 = 0x82AA98A0;
    'dispatch: loop {
        match pc {
            0x82AA98A0 => {
    //   block [0x82AA98A0..0x82AA98D4)
	// 82AA98A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA98A4: 481FFB55  bl 0x82ca93f8
	ctx.lr = 0x82AA98A8;
	sub_82CA93D0(ctx, base);
	// 82AA98A8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA98AC: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82AA98B0: F8610110  std r3, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[3].u64 ) };
	// 82AA98B4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82AA98B8: 573A083C  slwi r26, r25, 1
	ctx.r[26].u32 = ctx.r[25].u32.wrapping_shl(1);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82AA98BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA98C0: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82AA98C4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA98C8: 7F1AD800  cmpw cr6, r26, r27
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82AA98CC: 41990090  bgt cr6, 0x82aa995c
	if ctx.cr[6].gt {
	pc = 0x82AA995C; continue 'dispatch;
	}
	// 82AA98D0: 573D1838  slwi r29, r25, 3
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x82AA98D4; continue 'dispatch;
            }
            0x82AA98D4 => {
    //   block [0x82AA98D4..0x82AA9948)
	// 82AA98D4: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA98D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA98DC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AA98E0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82AA98E4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AA98E8: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82AA98EC: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82AA98F0: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82AA98F4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82AA98F8: 81610114  lwz r11, 0x114(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82AA98FC: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 82AA9900: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA9904: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AA9908: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA990C: 7D3D5A14  add r9, r29, r11
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AA9910: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA9914: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA9918: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82AA991C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82AA9920: EB810050  ld r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA9924: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AA9928: 48000261  bl 0x82aa9b88
	ctx.lr = 0x82AA992C;
	sub_82AA9B88(ctx, base);
	// 82AA992C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9930: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AA9934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9938: 911E0014  stw r8, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82AA993C: 419A000C  beq cr6, 0x82aa9948
	if ctx.cr[6].eq {
	pc = 0x82AA9948; continue 'dispatch;
	}
	// 82AA9940: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA9944: 4B7723F5  bl 0x8221bd38
	ctx.lr = 0x82AA9948;
	sub_8221BD38(ctx, base);
	pc = 0x82AA9948; continue 'dispatch;
            }
            0x82AA9948 => {
    //   block [0x82AA9948..0x82AA995C)
	// 82AA9948: 7F7AD850  subf r27, r26, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[26].s64;
	// 82AA994C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA9950: 7F1BD000  cmpw cr6, r27, r26
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82AA9954: F8610110  std r3, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[3].u64 ) };
	// 82AA9958: 4098FF7C  bge cr6, 0x82aa98d4
	if !ctx.cr[6].lt {
	pc = 0x82AA98D4; continue 'dispatch;
	}
	pc = 0x82AA995C; continue 'dispatch;
            }
            0x82AA995C => {
    //   block [0x82AA995C..0x82AA9998)
	// 82AA995C: 7F1BC800  cmpw cr6, r27, r25
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82AA9960: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AA9964: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA9968: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AA996C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82AA9970: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82AA9974: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82AA9978: 41990020  bgt cr6, 0x82aa9998
	if ctx.cr[6].gt {
	pc = 0x82AA9998; continue 'dispatch;
	}
	// 82AA997C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9980: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82AA9984: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82AA9988: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA998C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AA9990: 4BFFF311  bl 0x82aa8ca0
	ctx.lr = 0x82AA9994;
	sub_82AA8CA0(ctx, base);
	// 82AA9994: 48000038  b 0x82aa99cc
	pc = 0x82AA99CC; continue 'dispatch;
            }
            0x82AA9998 => {
    //   block [0x82AA9998..0x82AA99CC)
	// 82AA9998: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA999C: 572B1838  slwi r11, r25, 3
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA99A0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82AA99A4: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82AA99A8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82AA99AC: 81410114  lwz r10, 0x114(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82AA99B0: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 82AA99B4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA99B8: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AA99BC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82AA99C0: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA99C4: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA99C8: 480001C1  bl 0x82aa9b88
	ctx.lr = 0x82AA99CC;
	sub_82AA9B88(ctx, base);
	pc = 0x82AA99CC; continue 'dispatch;
            }
            0x82AA99CC => {
    //   block [0x82AA99CC..0x82AA99DC)
	// 82AA99CC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA99D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA99D4: 419A0008  beq cr6, 0x82aa99dc
	if ctx.cr[6].eq {
	pc = 0x82AA99DC; continue 'dispatch;
	}
	// 82AA99D8: 4B772361  bl 0x8221bd38
	ctx.lr = 0x82AA99DC;
	sub_8221BD38(ctx, base);
	pc = 0x82AA99DC; continue 'dispatch;
            }
            0x82AA99DC => {
    //   block [0x82AA99DC..0x82AA99EC)
	// 82AA99DC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA99E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA99E4: 419A0008  beq cr6, 0x82aa99ec
	if ctx.cr[6].eq {
	pc = 0x82AA99EC; continue 'dispatch;
	}
	// 82AA99E8: 4B772351  bl 0x8221bd38
	ctx.lr = 0x82AA99EC;
	sub_8221BD38(ctx, base);
	pc = 0x82AA99EC; continue 'dispatch;
            }
            0x82AA99EC => {
    //   block [0x82AA99EC..0x82AA99F4)
	// 82AA99EC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AA99F0: 481FFA58  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA99F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA99F8 size=236
    let mut pc: u32 = 0x82AA99F8;
    'dispatch: loop {
        match pc {
            0x82AA99F8 => {
    //   block [0x82AA99F8..0x82AA9A30)
	// 82AA99F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA99FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA9A00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA9A04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9A08: F8810078  std r4, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[4].u64 ) };
	// 82AA9A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA9A10: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82AA9A14: F9010098  std r8, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[8].u64 ) };
	// 82AA9A18: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82AA9A1C: 80C1007C  lwz r6, 0x7c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA9A20: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AA9A24: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA9A28: 419A007C  beq cr6, 0x82aa9aa4
	if ctx.cr[6].eq {
	pc = 0x82AA9AA4; continue 'dispatch;
	}
	// 82AA9A2C: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	pc = 0x82AA9A30; continue 'dispatch;
            }
            0x82AA9A30 => {
    //   block [0x82AA9A30..0x82AA9A5C)
	// 82AA9A30: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AA9A34: 419A0088  beq cr6, 0x82aa9abc
	if ctx.cr[6].eq {
	pc = 0x82AA9ABC; continue 'dispatch;
	}
	// 82AA9A38: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82AA9A3C: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 82AA9A40: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AA9A44: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9A48: 80A70000  lwz r5, 0(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9A4C: 7F054800  cmpw cr6, r5, r9
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AA9A50: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA9A54: 41980008  blt cr6, 0x82aa9a5c
	if ctx.cr[6].lt {
	pc = 0x82AA9A5C; continue 'dispatch;
	}
	// 82AA9A58: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82AA9A5C; continue 'dispatch;
            }
            0x82AA9A5C => {
    //   block [0x82AA9A5C..0x82AA9A84)
	// 82AA9A5C: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82AA9A60: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82AA9A64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA9A68: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 82AA9A6C: 419A0018  beq cr6, 0x82aa9a84
	if ctx.cr[6].eq {
	pc = 0x82AA9A84; continue 'dispatch;
	}
	// 82AA9A70: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9A74: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82AA9A78: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA9A7C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9A80: 48000018  b 0x82aa9a98
	pc = 0x82AA9A98; continue 'dispatch;
            }
            0x82AA9A84 => {
    //   block [0x82AA9A84..0x82AA9A98)
	// 82AA9A84: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9A88: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AA9A8C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AA9A90: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA9A94: 80A70004  lwz r5, 4(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82AA9A98; continue 'dispatch;
            }
            0x82AA9A98 => {
    //   block [0x82AA9A98..0x82AA9AA4)
	// 82AA9A98: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82AA9A9C: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA9AA0: 409AFF90  bne cr6, 0x82aa9a30
	if !ctx.cr[6].eq {
	pc = 0x82AA9A30; continue 'dispatch;
	}
	pc = 0x82AA9AA4; continue 'dispatch;
            }
            0x82AA9AA4 => {
    //   block [0x82AA9AA4..0x82AA9ABC)
	// 82AA9AA4: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 82AA9AA8: E8C10098  ld r6, 0x98(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82AA9AAC: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82AA9AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9AB4: 4BFFFD2D  bl 0x82aa97e0
	ctx.lr = 0x82AA9AB8;
	sub_82AA97E0(ctx, base);
	// 82AA9AB8: 48000014  b 0x82aa9acc
	pc = 0x82AA9ACC; continue 'dispatch;
            }
            0x82AA9ABC => {
    //   block [0x82AA9ABC..0x82AA9ACC)
	// 82AA9ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9AC0: E8C10098  ld r6, 0x98(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82AA9AC4: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82AA9AC8: 4BFFF799  bl 0x82aa9260
	ctx.lr = 0x82AA9ACC;
	sub_82AA9260(ctx, base);
	pc = 0x82AA9ACC; continue 'dispatch;
            }
            0x82AA9ACC => {
    //   block [0x82AA9ACC..0x82AA9AE4)
	// 82AA9ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9AD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA9AD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9AD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA9ADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA9AE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA9AE8 size=60
    let mut pc: u32 = 0x82AA9AE8;
    'dispatch: loop {
        match pc {
            0x82AA9AE8 => {
    //   block [0x82AA9AE8..0x82AA9B24)
	// 82AA9AE8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9AEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9AF0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA9AF4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA9AF8: 4098002C  bge cr6, 0x82aa9b24
	if !ctx.cr[6].lt {
		sub_82AA9B24(ctx, base);
		return;
	}
	// 82AA9AFC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9B00: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9B04: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA9B08: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9B0C: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AA9B10: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9B14: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9B18: 38EA0008  addi r7, r10, 8
	ctx.r[7].s64 = ctx.r[10].s64 + 8;
	// 82AA9B1C: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA9B20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9B24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA9B24 size=96
    let mut pc: u32 = 0x82AA9B24;
    'dispatch: loop {
        match pc {
            0x82AA9B24 => {
    //   block [0x82AA9B24..0x82AA9B44)
	// 82AA9B24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9B28: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9B2C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA9B30: 7CE95050  subf r7, r9, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AA9B34: 7CE61E70  srawi r6, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AA9B38: 7F064000  cmpw cr6, r6, r8
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82AA9B3C: 41980008  blt cr6, 0x82aa9b44
	if ctx.cr[6].lt {
	pc = 0x82AA9B44; continue 'dispatch;
	}
	// 82AA9B40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AA9B44; continue 'dispatch;
            }
            0x82AA9B44 => {
    //   block [0x82AA9B44..0x82AA9B64)
	// 82AA9B44: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9B48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9B50: 419A0014  beq cr6, 0x82aa9b64
	if ctx.cr[6].eq {
	pc = 0x82AA9B64; continue 'dispatch;
	}
	// 82AA9B54: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9B58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA9B5C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9B60: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x82AA9B64; continue 'dispatch;
            }
            0x82AA9B64 => {
    //   block [0x82AA9B64..0x82AA9B84)
	// 82AA9B64: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9B68: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9B6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AA9B70: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA9B74: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9B78: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9B7C: 91090008  stw r8, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82AA9B80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9B88 size=132
    let mut pc: u32 = 0x82AA9B88;
    'dispatch: loop {
        match pc {
            0x82AA9B88 => {
    //   block [0x82AA9B88..0x82AA9BF0)
	// 82AA9B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9B8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA9B90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA9B94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA9B98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9B9C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82AA9BA0: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA9BA4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82AA9BA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA9BAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA9BB0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82AA9BB4: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9BB8: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82AA9BBC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA9BC0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA9BC4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA9BC8: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82AA9BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9BD0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA9BD4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA9BD8: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA9BDC: 4800035D  bl 0x82aa9f38
	ctx.lr = 0x82AA9BE0;
	sub_82AA9F38(ctx, base);
	// 82AA9BE0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9BE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9BE8: 419A0008  beq cr6, 0x82aa9bf0
	if ctx.cr[6].eq {
	pc = 0x82AA9BF0; continue 'dispatch;
	}
	// 82AA9BEC: 4B77214D  bl 0x8221bd38
	ctx.lr = 0x82AA9BF0;
	sub_8221BD38(ctx, base);
	pc = 0x82AA9BF0; continue 'dispatch;
            }
            0x82AA9BF0 => {
    //   block [0x82AA9BF0..0x82AA9C0C)
	// 82AA9BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9BF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA9BF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9BFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA9C00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA9C04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA9C08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9C10 size=228
    let mut pc: u32 = 0x82AA9C10;
    'dispatch: loop {
        match pc {
            0x82AA9C10 => {
    //   block [0x82AA9C10..0x82AA9C4C)
	// 82AA9C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9C14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA9C18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA9C1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA9C20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9C24: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82AA9C28: F8C10098  std r6, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[6].u64 ) };
	// 82AA9C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA9C30: FBC100A0  std r30, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u64 ) };
	// 82AA9C34: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA9C38: F90100A8  std r8, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u64 ) };
	// 82AA9C3C: 419A0078  beq cr6, 0x82aa9cb4
	if ctx.cr[6].eq {
	pc = 0x82AA9CB4; continue 'dispatch;
	}
	// 82AA9C40: 810100A4  lwz r8, 0xa4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA9C44: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82AA9C48: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	pc = 0x82AA9C4C; continue 'dispatch;
            }
            0x82AA9C4C => {
    //   block [0x82AA9C4C..0x82AA9C6C)
	// 82AA9C4C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AA9C50: 419A0064  beq cr6, 0x82aa9cb4
	if ctx.cr[6].eq {
	pc = 0x82AA9CB4; continue 'dispatch;
	}
	// 82AA9C54: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9C58: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9C5C: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82AA9C60: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA9C64: 41980008  blt cr6, 0x82aa9c6c
	if ctx.cr[6].lt {
	pc = 0x82AA9C6C; continue 'dispatch;
	}
	// 82AA9C68: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82AA9C6C; continue 'dispatch;
            }
            0x82AA9C6C => {
    //   block [0x82AA9C6C..0x82AA9C90)
	// 82AA9C6C: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82AA9C70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA9C74: 419A001C  beq cr6, 0x82aa9c90
	if ctx.cr[6].eq {
	pc = 0x82AA9C90; continue 'dispatch;
	}
	// 82AA9C78: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9C7C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA9C80: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9C84: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AA9C88: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 82AA9C8C: 48000014  b 0x82aa9ca0
	pc = 0x82AA9CA0; continue 'dispatch;
            }
            0x82AA9C90 => {
    //   block [0x82AA9C90..0x82AA9CA0)
	// 82AA9C90: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9C94: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA9C98: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9C9C: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	pc = 0x82AA9CA0; continue 'dispatch;
            }
            0x82AA9CA0 => {
    //   block [0x82AA9CA0..0x82AA9CB4)
	// 82AA9CA0: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AA9CA4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AA9CA8: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA9CAC: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82AA9CB0: 409AFF9C  bne cr6, 0x82aa9c4c
	if !ctx.cr[6].eq {
	pc = 0x82AA9C4C; continue 'dispatch;
	}
	pc = 0x82AA9CB4; continue 'dispatch;
            }
            0x82AA9CB4 => {
    //   block [0x82AA9CB4..0x82AA9CF4)
	// 82AA9CB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9CB8: E8C100A8  ld r6, 0xa8(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82AA9CBC: 4BFFFB85  bl 0x82aa9840
	ctx.lr = 0x82AA9CC0;
	sub_82AA9840(ctx, base);
	// 82AA9CC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA9CC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA9CC8: E8810098  ld r4, 0x98(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82AA9CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9CD0: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AA9CD4: 4BFFFA95  bl 0x82aa9768
	ctx.lr = 0x82AA9CD8;
	sub_82AA9768(ctx, base);
	// 82AA9CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA9CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA9CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA9CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA9CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9CF8 size=316
    let mut pc: u32 = 0x82AA9CF8;
    'dispatch: loop {
        match pc {
            0x82AA9CF8 => {
    //   block [0x82AA9CF8..0x82AA9D40)
	// 82AA9CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9CFC: 481FF6F9  bl 0x82ca93f4
	ctx.lr = 0x82AA9D00;
	sub_82CA93D0(ctx, base);
	// 82AA9D00: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9D04: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82AA9D08: F88100F8  std r4, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[4].u64 ) };
	// 82AA9D0C: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 82AA9D10: 83A100FC  lwz r29, 0xfc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82AA9D14: FB410100  std r26, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[26].u64 ) };
	// 82AA9D18: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA9D1C: 83610104  lwz r27, 0x104(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AA9D20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA9D24: F8C10108  std r6, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[6].u64 ) };
	// 82AA9D28: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82AA9D2C: FAE10110  std r23, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[23].u64 ) };
	// 82AA9D30: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AA9D34: 419A0068  beq cr6, 0x82aa9d9c
	if ctx.cr[6].eq {
	pc = 0x82AA9D9C; continue 'dispatch;
	}
	// 82AA9D38: 83010114  lwz r24, 0x114(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82AA9D3C: 8381010C  lwz r28, 0x10c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	pc = 0x82AA9D40; continue 'dispatch;
            }
            0x82AA9D40 => {
    //   block [0x82AA9D40..0x82AA9D60)
	// 82AA9D40: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82AA9D44: 419A0058  beq cr6, 0x82aa9d9c
	if ctx.cr[6].eq {
	pc = 0x82AA9D9C; continue 'dispatch;
	}
	// 82AA9D48: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9D4C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9D50: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA9D54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA9D58: 41990008  bgt cr6, 0x82aa9d60
	if ctx.cr[6].gt {
	pc = 0x82AA9D60; continue 'dispatch;
	}
	// 82AA9D5C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82AA9D60; continue 'dispatch;
            }
            0x82AA9D60 => {
    //   block [0x82AA9D60..0x82AA9D84)
	// 82AA9D60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA9D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9D68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9D6C: 419A0018  beq cr6, 0x82aa9d84
	if ctx.cr[6].eq {
	pc = 0x82AA9D84; continue 'dispatch;
	}
	// 82AA9D70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA9D74: 4BFFFD75  bl 0x82aa9ae8
	ctx.lr = 0x82AA9D78;
	sub_82AA9AE8(ctx, base);
	// 82AA9D78: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82AA9D7C: 9381010C  stw r28, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[28].u32 ) };
	// 82AA9D80: 48000014  b 0x82aa9d94
	pc = 0x82AA9D94; continue 'dispatch;
            }
            0x82AA9D84 => {
    //   block [0x82AA9D84..0x82AA9D94)
	// 82AA9D84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA9D88: 4BFFFD61  bl 0x82aa9ae8
	ctx.lr = 0x82AA9D8C;
	sub_82AA9AE8(ctx, base);
	// 82AA9D8C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82AA9D90: 93A100FC  stw r29, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[29].u32 ) };
	pc = 0x82AA9D94; continue 'dispatch;
            }
            0x82AA9D94 => {
    //   block [0x82AA9D94..0x82AA9D9C)
	// 82AA9D94: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AA9D98: 409AFFA8  bne cr6, 0x82aa9d40
	if !ctx.cr[6].eq {
	pc = 0x82AA9D40; continue 'dispatch;
	}
	pc = 0x82AA9D9C; continue 'dispatch;
            }
            0x82AA9D9C => {
    //   block [0x82AA9D9C..0x82AA9DE8)
	// 82AA9D9C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9DA0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA9DA4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA9DA8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA9DAC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AA9DB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA9DB4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AA9DB8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82AA9DBC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AA9DC0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA9DC4: E88100F8  ld r4, 0xf8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 82AA9DC8: 4BFFEED9  bl 0x82aa8ca0
	ctx.lr = 0x82AA9DCC;
	sub_82AA8CA0(ctx, base);
	// 82AA9DCC: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9DD0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA9DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9DD8: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82AA9DDC: 419A000C  beq cr6, 0x82aa9de8
	if ctx.cr[6].eq {
	pc = 0x82AA9DE8; continue 'dispatch;
	}
	// 82AA9DE0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA9DE4: 4B771F55  bl 0x8221bd38
	ctx.lr = 0x82AA9DE8;
	sub_8221BD38(ctx, base);
	pc = 0x82AA9DE8; continue 'dispatch;
            }
            0x82AA9DE8 => {
    //   block [0x82AA9DE8..0x82AA9E28)
	// 82AA9DE8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9DEC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA9DF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA9DF4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82AA9DF8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AA9DFC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA9E00: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AA9E04: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82AA9E08: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA9E0C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AA9E10: E8810108  ld r4, 0x108(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	// 82AA9E14: 4BFFEE8D  bl 0x82aa8ca0
	ctx.lr = 0x82AA9E18;
	sub_82AA8CA0(ctx, base);
	// 82AA9E18: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9E1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9E20: 419A0008  beq cr6, 0x82aa9e28
	if ctx.cr[6].eq {
	pc = 0x82AA9E28; continue 'dispatch;
	}
	// 82AA9E24: 4B771F15  bl 0x8221bd38
	ctx.lr = 0x82AA9E28;
	sub_8221BD38(ctx, base);
	pc = 0x82AA9E28; continue 'dispatch;
            }
            0x82AA9E28 => {
    //   block [0x82AA9E28..0x82AA9E34)
	// 82AA9E28: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA9E2C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AA9E30: 481FF614  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9E38 size=256
    let mut pc: u32 = 0x82AA9E38;
    'dispatch: loop {
        match pc {
            0x82AA9E38 => {
    //   block [0x82AA9E38..0x82AA9EA4)
	// 82AA9E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9E3C: 481FF5D1  bl 0x82ca940c
	ctx.lr = 0x82AA9E40;
	sub_82CA93D0(ctx, base);
	// 82AA9E40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9E44: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82AA9E48: F90100B8  std r8, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[8].u64 ) };
	// 82AA9E4C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82AA9E50: 80E100BC  lwz r7, 0xbc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AA9E54: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AA9E58: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 82AA9E5C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82AA9E60: 7D26F050  subf r9, r6, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[6].s64;
	// 82AA9E64: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA9E68: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AA9E6C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82AA9E70: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA9E74: E8E10058  ld r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA9E78: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA9E7C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 82AA9E80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA9E84: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA9E88: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82AA9E8C: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82AA9E90: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA9E94: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AA9E98: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AA9E9C: 419A006C  beq cr6, 0x82aa9f08
	if ctx.cr[6].eq {
	pc = 0x82AA9F08; continue 'dispatch;
	}
	// 82AA9EA0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82AA9EA4; continue 'dispatch;
            }
            0x82AA9EA4 => {
    //   block [0x82AA9EA4..0x82AA9EC4)
	// 82AA9EA4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AA9EA8: 419A0060  beq cr6, 0x82aa9f08
	if ctx.cr[6].eq {
	pc = 0x82AA9F08; continue 'dispatch;
	}
	// 82AA9EAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9EB0: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9EB4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AA9EB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA9EBC: 41990008  bgt cr6, 0x82aa9ec4
	if ctx.cr[6].gt {
	pc = 0x82AA9EC4; continue 'dispatch;
	}
	// 82AA9EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AA9EC4; continue 'dispatch;
            }
            0x82AA9EC4 => {
    //   block [0x82AA9EC4..0x82AA9EE4)
	// 82AA9EC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA9EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9ECC: 419A0018  beq cr6, 0x82aa9ee4
	if ctx.cr[6].eq {
	pc = 0x82AA9EE4; continue 'dispatch;
	}
	// 82AA9ED0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9ED4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA9ED8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9EDC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AA9EE0: 48000014  b 0x82aa9ef4
	pc = 0x82AA9EF4; continue 'dispatch;
            }
            0x82AA9EE4 => {
    //   block [0x82AA9EE4..0x82AA9EF4)
	// 82AA9EE4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9EE8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA9EEC: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA9EF0: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	pc = 0x82AA9EF4; continue 'dispatch;
            }
            0x82AA9EF4 => {
    //   block [0x82AA9EF4..0x82AA9F08)
	// 82AA9EF4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA9EF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AA9EFC: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AA9F00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AA9F04: 409AFFA0  bne cr6, 0x82aa9ea4
	if !ctx.cr[6].eq {
	pc = 0x82AA9EA4; continue 'dispatch;
	}
	pc = 0x82AA9F08; continue 'dispatch;
            }
            0x82AA9F08 => {
    //   block [0x82AA9F08..0x82AA9F38)
	// 82AA9F08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA9F0C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AA9F10: 4BFFF931  bl 0x82aa9840
	ctx.lr = 0x82AA9F14;
	sub_82AA9840(ctx, base);
	// 82AA9F14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA9F18: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA9F1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA9F20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9F24: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AA9F28: 4BFFF919  bl 0x82aa9840
	ctx.lr = 0x82AA9F2C;
	sub_82AA9840(ctx, base);
	// 82AA9F2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA9F30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA9F34: 481FF528  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9F38 size=316
    let mut pc: u32 = 0x82AA9F38;
    'dispatch: loop {
        match pc {
            0x82AA9F38 => {
    //   block [0x82AA9F38..0x82AA9F80)
	// 82AA9F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9F3C: 481FF4B9  bl 0x82ca93f4
	ctx.lr = 0x82AA9F40;
	sub_82CA93D0(ctx, base);
	// 82AA9F40: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9F44: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82AA9F48: F88100F8  std r4, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[4].u64 ) };
	// 82AA9F4C: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 82AA9F50: 83A100FC  lwz r29, 0xfc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82AA9F54: FB410100  std r26, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[26].u64 ) };
	// 82AA9F58: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA9F5C: 83610104  lwz r27, 0x104(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AA9F60: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA9F64: F8C10108  std r6, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[6].u64 ) };
	// 82AA9F68: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82AA9F6C: FAE10110  std r23, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[23].u64 ) };
	// 82AA9F70: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AA9F74: 419A0068  beq cr6, 0x82aa9fdc
	if ctx.cr[6].eq {
	pc = 0x82AA9FDC; continue 'dispatch;
	}
	// 82AA9F78: 83010114  lwz r24, 0x114(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82AA9F7C: 8381010C  lwz r28, 0x10c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	pc = 0x82AA9F80; continue 'dispatch;
            }
            0x82AA9F80 => {
    //   block [0x82AA9F80..0x82AA9FA0)
	// 82AA9F80: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82AA9F84: 419A0058  beq cr6, 0x82aa9fdc
	if ctx.cr[6].eq {
	pc = 0x82AA9FDC; continue 'dispatch;
	}
	// 82AA9F88: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9F8C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9F90: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AA9F94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA9F98: 41980008  blt cr6, 0x82aa9fa0
	if ctx.cr[6].lt {
	pc = 0x82AA9FA0; continue 'dispatch;
	}
	// 82AA9F9C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82AA9FA0; continue 'dispatch;
            }
            0x82AA9FA0 => {
    //   block [0x82AA9FA0..0x82AA9FC4)
	// 82AA9FA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA9FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9FA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9FAC: 419A0018  beq cr6, 0x82aa9fc4
	if ctx.cr[6].eq {
	pc = 0x82AA9FC4; continue 'dispatch;
	}
	// 82AA9FB0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA9FB4: 4BFFFB35  bl 0x82aa9ae8
	ctx.lr = 0x82AA9FB8;
	sub_82AA9AE8(ctx, base);
	// 82AA9FB8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82AA9FBC: 9381010C  stw r28, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[28].u32 ) };
	// 82AA9FC0: 48000014  b 0x82aa9fd4
	pc = 0x82AA9FD4; continue 'dispatch;
            }
            0x82AA9FC4 => {
    //   block [0x82AA9FC4..0x82AA9FD4)
	// 82AA9FC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA9FC8: 4BFFFB21  bl 0x82aa9ae8
	ctx.lr = 0x82AA9FCC;
	sub_82AA9AE8(ctx, base);
	// 82AA9FCC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82AA9FD0: 93A100FC  stw r29, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[29].u32 ) };
	pc = 0x82AA9FD4; continue 'dispatch;
            }
            0x82AA9FD4 => {
    //   block [0x82AA9FD4..0x82AA9FDC)
	// 82AA9FD4: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AA9FD8: 409AFFA8  bne cr6, 0x82aa9f80
	if !ctx.cr[6].eq {
	pc = 0x82AA9F80; continue 'dispatch;
	}
	pc = 0x82AA9FDC; continue 'dispatch;
            }
            0x82AA9FDC => {
    //   block [0x82AA9FDC..0x82AAA028)
	// 82AA9FDC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AA9FE0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA9FE4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AA9FE8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA9FEC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AA9FF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA9FF4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AA9FF8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82AA9FFC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AAA000: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AAA004: E88100F8  ld r4, 0xf8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 82AAA008: 4BFFEC99  bl 0x82aa8ca0
	ctx.lr = 0x82AAA00C;
	sub_82AA8CA0(ctx, base);
	// 82AAA00C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAA010: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AAA014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA018: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82AAA01C: 419A000C  beq cr6, 0x82aaa028
	if ctx.cr[6].eq {
	pc = 0x82AAA028; continue 'dispatch;
	}
	// 82AAA020: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AAA024: 4B771D15  bl 0x8221bd38
	ctx.lr = 0x82AAA028;
	sub_8221BD38(ctx, base);
	pc = 0x82AAA028; continue 'dispatch;
            }
            0x82AAA028 => {
    //   block [0x82AAA028..0x82AAA068)
	// 82AAA028: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAA02C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AAA030: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AAA034: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82AAA038: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AAA03C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AAA040: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AAA044: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82AAA048: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AAA04C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AAA050: E8810108  ld r4, 0x108(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	// 82AAA054: 4BFFEC4D  bl 0x82aa8ca0
	ctx.lr = 0x82AAA058;
	sub_82AA8CA0(ctx, base);
	// 82AAA058: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA05C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAA060: 419A0008  beq cr6, 0x82aaa068
	if ctx.cr[6].eq {
	pc = 0x82AAA068; continue 'dispatch;
	}
	// 82AAA064: 4B771CD5  bl 0x8221bd38
	ctx.lr = 0x82AAA068;
	sub_8221BD38(ctx, base);
	pc = 0x82AAA068; continue 'dispatch;
            }
            0x82AAA068 => {
    //   block [0x82AAA068..0x82AAA074)
	// 82AAA068: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AAA06C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AAA070: 481FF3D4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAA078 size=256
    let mut pc: u32 = 0x82AAA078;
    'dispatch: loop {
        match pc {
            0x82AAA078 => {
    //   block [0x82AAA078..0x82AAA0E4)
	// 82AAA078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA07C: 481FF391  bl 0x82ca940c
	ctx.lr = 0x82AAA080;
	sub_82CA93D0(ctx, base);
	// 82AAA080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA084: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82AAA088: F90100B8  std r8, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[8].u64 ) };
	// 82AAA08C: 812100BC  lwz r9, 0xbc(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AAA090: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82AAA094: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AAA098: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 82AAA09C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82AAA0A0: 7CE6F050  subf r7, r6, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[6].s64;
	// 82AAA0A4: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AAA0A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAA0AC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82AAA0B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AAA0B4: E9210058  ld r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AAA0B8: 7CE31E70  srawi r3, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AAA0BC: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82AAA0C0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82AAA0C4: 546A1838  slwi r10, r3, 3
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AAA0C8: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AAA0CC: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AAA0D0: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82AAA0D4: E8E10058  ld r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AAA0D8: F8FD0000  std r7, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 82AAA0DC: 419A006C  beq cr6, 0x82aaa148
	if ctx.cr[6].eq {
	pc = 0x82AAA148; continue 'dispatch;
	}
	// 82AAA0E0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82AAA0E4; continue 'dispatch;
            }
            0x82AAA0E4 => {
    //   block [0x82AAA0E4..0x82AAA104)
	// 82AAA0E4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AAA0E8: 419A0060  beq cr6, 0x82aaa148
	if ctx.cr[6].eq {
	pc = 0x82AAA148; continue 'dispatch;
	}
	// 82AAA0EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA0F0: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA0F4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AAA0F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAA0FC: 41980008  blt cr6, 0x82aaa104
	if ctx.cr[6].lt {
	pc = 0x82AAA104; continue 'dispatch;
	}
	// 82AAA100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AAA104; continue 'dispatch;
            }
            0x82AAA104 => {
    //   block [0x82AAA104..0x82AAA124)
	// 82AAA104: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AAA108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA10C: 419A0018  beq cr6, 0x82aaa124
	if ctx.cr[6].eq {
	pc = 0x82AAA124; continue 'dispatch;
	}
	// 82AAA110: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA114: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA118: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA11C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AAA120: 48000014  b 0x82aaa134
	pc = 0x82AAA134; continue 'dispatch;
            }
            0x82AAA124 => {
    //   block [0x82AAA124..0x82AAA134)
	// 82AAA124: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA128: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA12C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA130: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	pc = 0x82AAA134; continue 'dispatch;
            }
            0x82AAA134 => {
    //   block [0x82AAA134..0x82AAA148)
	// 82AAA134: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AAA138: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AAA13C: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AAA140: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AAA144: 409AFFA0  bne cr6, 0x82aaa0e4
	if !ctx.cr[6].eq {
	pc = 0x82AAA0E4; continue 'dispatch;
	}
	pc = 0x82AAA148; continue 'dispatch;
            }
            0x82AAA148 => {
    //   block [0x82AAA148..0x82AAA178)
	// 82AAA148: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAA14C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AAA150: 4BFFF6F1  bl 0x82aa9840
	ctx.lr = 0x82AAA154;
	sub_82AA9840(ctx, base);
	// 82AAA154: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAA158: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AAA15C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAA160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA164: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AAA168: 4BFFF6D9  bl 0x82aa9840
	ctx.lr = 0x82AAA16C;
	sub_82AA9840(ctx, base);
	// 82AAA16C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAA170: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAA174: 481FF2E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAA178 size=1156
    let mut pc: u32 = 0x82AAA178;
    'dispatch: loop {
        match pc {
            0x82AAA178 => {
    //   block [0x82AAA178..0x82AAA5FC)
	// 82AAA178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA17C: 481FF291  bl 0x82ca940c
	ctx.lr = 0x82AAA180;
	sub_82CA93D0(ctx, base);
	// 82AAA180: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA188: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AAA18C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAA190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAA194: 386B572C  addi r3, r11, 0x572c
	ctx.r[3].s64 = ctx.r[11].s64 + 22316;
	// 82AAA198: 4B6E3E21  bl 0x8218dfb8
	ctx.lr = 0x82AAA19C;
	sub_8218DFB8(ctx, base);
	// 82AAA19C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82AAA1A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAA1A4: 386A5730  addi r3, r10, 0x5730
	ctx.r[3].s64 = ctx.r[10].s64 + 22320;
	// 82AAA1A8: 4B6E3E11  bl 0x8218dfb8
	ctx.lr = 0x82AAA1AC;
	sub_8218DFB8(ctx, base);
	// 82AAA1AC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82AAA1B0: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82AAA1B4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82AAA1B8: 38A85734  addi r5, r8, 0x5734
	ctx.r[5].s64 = ctx.r[8].s64 + 22324;
	// 82AAA1BC: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 82AAA1C0: 3C608349  lis r3, -0x7cb7
	ctx.r[3].s64 = -2092367872;
	// 82AAA1C4: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82AAA1C8: C0079484  lfs f0, -0x6b7c(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA1CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAA1D0: C9A60D38  lfd f13, 0xd38(r6)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(3384 as u32) ) };
	// 82AAA1D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AAA1D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AAA1DC: D0046F28  stfs f0, 0x6f28(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28456 as u32), tmp.u32 ) };
	// 82AAA1E0: D9A36F30  stfd f13, 0x6f30(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(28464 as u32), ctx.f[13].u64 ) };
	// 82AAA1E4: 91685734  stw r11, 0x5734(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(22324 as u32), ctx.r[11].u32 ) };
	// 82AAA1E8: 91450004  stw r10, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAA1EC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAA1F0: 913D6F2C  stw r9, 0x6f2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28460 as u32), ctx.r[9].u32 ) };
	// 82AAA1F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA1F8: 388B8044  addi r4, r11, -0x7fbc
	ctx.r[4].s64 = ctx.r[11].s64 + -32700;
	// 82AAA1FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA200: 4B782CD1  bl 0x8222ced0
	ctx.lr = 0x82AAA204;
	sub_8222CED0(ctx, base);
	// 82AAA204: 3D4082AB  lis r10, -0x7d55
	ctx.r[10].s64 = -2102722560;
	// 82AAA208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA20C: 388ADC38  addi r4, r10, -0x23c8
	ctx.r[4].s64 = ctx.r[10].s64 + -9160;
	// 82AAA210: 48003791  bl 0x82aad9a0
	ctx.lr = 0x82AAA214;
	sub_82AAD9A0(ctx, base);
	// 82AAA214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA218: 4B76ABC1  bl 0x82214dd8
	ctx.lr = 0x82AAA21C;
	sub_82214DD8(ctx, base);
	// 82AAA21C: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AAA220: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA224: 3889804C  addi r4, r9, -0x7fb4
	ctx.r[4].s64 = ctx.r[9].s64 + -32692;
	// 82AAA228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA22C: 4B782CA5  bl 0x8222ced0
	ctx.lr = 0x82AAA230;
	sub_8222CED0(ctx, base);
	// 82AAA230: 3D0082AB  lis r8, -0x7d55
	ctx.r[8].s64 = -2102722560;
	// 82AAA234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA238: 3888D440  addi r4, r8, -0x2bc0
	ctx.r[4].s64 = ctx.r[8].s64 + -11200;
	// 82AAA23C: 48003765  bl 0x82aad9a0
	ctx.lr = 0x82AAA240;
	sub_82AAD9A0(ctx, base);
	// 82AAA240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA244: 4B76AB95  bl 0x82214dd8
	ctx.lr = 0x82AAA248;
	sub_82214DD8(ctx, base);
	// 82AAA248: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AAA24C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA250: 38878058  addi r4, r7, -0x7fa8
	ctx.r[4].s64 = ctx.r[7].s64 + -32680;
	// 82AAA254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA258: 4B782C79  bl 0x8222ced0
	ctx.lr = 0x82AAA25C;
	sub_8222CED0(ctx, base);
	// 82AAA25C: 3CC082AB  lis r6, -0x7d55
	ctx.r[6].s64 = -2102722560;
	// 82AAA260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA264: 3886D100  addi r4, r6, -0x2f00
	ctx.r[4].s64 = ctx.r[6].s64 + -12032;
	// 82AAA268: 48003739  bl 0x82aad9a0
	ctx.lr = 0x82AAA26C;
	sub_82AAD9A0(ctx, base);
	// 82AAA26C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA270: 4B76AB69  bl 0x82214dd8
	ctx.lr = 0x82AAA274;
	sub_82214DD8(ctx, base);
	// 82AAA274: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAA278: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA27C: 38848064  addi r4, r4, -0x7f9c
	ctx.r[4].s64 = ctx.r[4].s64 + -32668;
	// 82AAA280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA284: 4B782C4D  bl 0x8222ced0
	ctx.lr = 0x82AAA288;
	sub_8222CED0(ctx, base);
	// 82AAA288: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82AAA28C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA290: 388BA600  addi r4, r11, -0x5a00
	ctx.r[4].s64 = ctx.r[11].s64 + -23040;
	// 82AAA294: 4800370D  bl 0x82aad9a0
	ctx.lr = 0x82AAA298;
	sub_82AAD9A0(ctx, base);
	// 82AAA298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA29C: 4B76AB3D  bl 0x82214dd8
	ctx.lr = 0x82AAA2A0;
	sub_82214DD8(ctx, base);
	// 82AAA2A0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAA2A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA2A8: 388A8070  addi r4, r10, -0x7f90
	ctx.r[4].s64 = ctx.r[10].s64 + -32656;
	// 82AAA2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA2B0: 4B782C21  bl 0x8222ced0
	ctx.lr = 0x82AAA2B4;
	sub_8222CED0(ctx, base);
	// 82AAA2B4: 3D2082AB  lis r9, -0x7d55
	ctx.r[9].s64 = -2102722560;
	// 82AAA2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA2BC: 3889ABF8  addi r4, r9, -0x5408
	ctx.r[4].s64 = ctx.r[9].s64 + -21512;
	// 82AAA2C0: 480036E1  bl 0x82aad9a0
	ctx.lr = 0x82AAA2C4;
	sub_82AAD9A0(ctx, base);
	// 82AAA2C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA2C8: 4B76AB11  bl 0x82214dd8
	ctx.lr = 0x82AAA2CC;
	sub_82214DD8(ctx, base);
	// 82AAA2CC: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAA2D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA2D4: 38888080  addi r4, r8, -0x7f80
	ctx.r[4].s64 = ctx.r[8].s64 + -32640;
	// 82AAA2D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA2DC: 4B782BF5  bl 0x8222ced0
	ctx.lr = 0x82AAA2E0;
	sub_8222CED0(ctx, base);
	// 82AAA2E0: 3CE082AB  lis r7, -0x7d55
	ctx.r[7].s64 = -2102722560;
	// 82AAA2E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA2E8: 3887C208  addi r4, r7, -0x3df8
	ctx.r[4].s64 = ctx.r[7].s64 + -15864;
	// 82AAA2EC: 480036B5  bl 0x82aad9a0
	ctx.lr = 0x82AAA2F0;
	sub_82AAD9A0(ctx, base);
	// 82AAA2F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA2F4: 4B76AAE5  bl 0x82214dd8
	ctx.lr = 0x82AAA2F8;
	sub_82214DD8(ctx, base);
	// 82AAA2F8: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAA2FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA300: 38868090  addi r4, r6, -0x7f70
	ctx.r[4].s64 = ctx.r[6].s64 + -32624;
	// 82AAA304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA308: 4B782BC9  bl 0x8222ced0
	ctx.lr = 0x82AAA30C;
	sub_8222CED0(ctx, base);
	// 82AAA30C: 3CA082AB  lis r5, -0x7d55
	ctx.r[5].s64 = -2102722560;
	// 82AAA310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA314: 3885C688  addi r4, r5, -0x3978
	ctx.r[4].s64 = ctx.r[5].s64 + -14712;
	// 82AAA318: 48003689  bl 0x82aad9a0
	ctx.lr = 0x82AAA31C;
	sub_82AAD9A0(ctx, base);
	// 82AAA31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA320: 4B76AAB9  bl 0x82214dd8
	ctx.lr = 0x82AAA324;
	sub_82214DD8(ctx, base);
	// 82AAA324: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAA328: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA32C: 3884809C  addi r4, r4, -0x7f64
	ctx.r[4].s64 = ctx.r[4].s64 + -32612;
	// 82AAA330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA334: 4B782B9D  bl 0x8222ced0
	ctx.lr = 0x82AAA338;
	sub_8222CED0(ctx, base);
	// 82AAA338: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82AAA33C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA340: 388BA940  addi r4, r11, -0x56c0
	ctx.r[4].s64 = ctx.r[11].s64 + -22208;
	// 82AAA344: 4800365D  bl 0x82aad9a0
	ctx.lr = 0x82AAA348;
	sub_82AAD9A0(ctx, base);
	// 82AAA348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA34C: 4B76AA8D  bl 0x82214dd8
	ctx.lr = 0x82AAA350;
	sub_82214DD8(ctx, base);
	// 82AAA350: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAA354: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA358: 388A80AC  addi r4, r10, -0x7f54
	ctx.r[4].s64 = ctx.r[10].s64 + -32596;
	// 82AAA35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA360: 4B782B71  bl 0x8222ced0
	ctx.lr = 0x82AAA364;
	sub_8222CED0(ctx, base);
	// 82AAA364: 3D2082AB  lis r9, -0x7d55
	ctx.r[9].s64 = -2102722560;
	// 82AAA368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA36C: 3889AB70  addi r4, r9, -0x5490
	ctx.r[4].s64 = ctx.r[9].s64 + -21648;
	// 82AAA370: 48003631  bl 0x82aad9a0
	ctx.lr = 0x82AAA374;
	sub_82AAD9A0(ctx, base);
	// 82AAA374: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA378: 4B76AA61  bl 0x82214dd8
	ctx.lr = 0x82AAA37C;
	sub_82214DD8(ctx, base);
	// 82AAA37C: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAA380: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA384: 388880B8  addi r4, r8, -0x7f48
	ctx.r[4].s64 = ctx.r[8].s64 + -32584;
	// 82AAA388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA38C: 4B782B45  bl 0x8222ced0
	ctx.lr = 0x82AAA390;
	sub_8222CED0(ctx, base);
	// 82AAA390: 3CE082AB  lis r7, -0x7d55
	ctx.r[7].s64 = -2102722560;
	// 82AAA394: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA398: 3887BDE8  addi r4, r7, -0x4218
	ctx.r[4].s64 = ctx.r[7].s64 + -16920;
	// 82AAA39C: 48003605  bl 0x82aad9a0
	ctx.lr = 0x82AAA3A0;
	sub_82AAD9A0(ctx, base);
	// 82AAA3A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA3A4: 4B76AA35  bl 0x82214dd8
	ctx.lr = 0x82AAA3A8;
	sub_82214DD8(ctx, base);
	// 82AAA3A8: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 82AAA3AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA3B0: 388647B8  addi r4, r6, 0x47b8
	ctx.r[4].s64 = ctx.r[6].s64 + 18360;
	// 82AAA3B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA3B8: 4B782B19  bl 0x8222ced0
	ctx.lr = 0x82AAA3BC;
	sub_8222CED0(ctx, base);
	// 82AAA3BC: 3CA082AB  lis r5, -0x7d55
	ctx.r[5].s64 = -2102722560;
	// 82AAA3C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA3C4: 3885C088  addi r4, r5, -0x3f78
	ctx.r[4].s64 = ctx.r[5].s64 + -16248;
	// 82AAA3C8: 480035D9  bl 0x82aad9a0
	ctx.lr = 0x82AAA3CC;
	sub_82AAD9A0(ctx, base);
	// 82AAA3CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA3D0: 4B76AA09  bl 0x82214dd8
	ctx.lr = 0x82AAA3D4;
	sub_82214DD8(ctx, base);
	// 82AAA3D4: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAA3D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA3DC: 388480C4  addi r4, r4, -0x7f3c
	ctx.r[4].s64 = ctx.r[4].s64 + -32572;
	// 82AAA3E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA3E4: 4B782AED  bl 0x8222ced0
	ctx.lr = 0x82AAA3E8;
	sub_8222CED0(ctx, base);
	// 82AAA3E8: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82AAA3EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA3F0: 388BAE38  addi r4, r11, -0x51c8
	ctx.r[4].s64 = ctx.r[11].s64 + -20936;
	// 82AAA3F4: 480035AD  bl 0x82aad9a0
	ctx.lr = 0x82AAA3F8;
	sub_82AAD9A0(ctx, base);
	// 82AAA3F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA3FC: 4B76A9DD  bl 0x82214dd8
	ctx.lr = 0x82AAA400;
	sub_82214DD8(ctx, base);
	// 82AAA400: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAA404: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA408: 388A80D4  addi r4, r10, -0x7f2c
	ctx.r[4].s64 = ctx.r[10].s64 + -32556;
	// 82AAA40C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA410: 4B782AC1  bl 0x8222ced0
	ctx.lr = 0x82AAA414;
	sub_8222CED0(ctx, base);
	// 82AAA414: 3D2082AB  lis r9, -0x7d55
	ctx.r[9].s64 = -2102722560;
	// 82AAA418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA41C: 3889AF70  addi r4, r9, -0x5090
	ctx.r[4].s64 = ctx.r[9].s64 + -20624;
	// 82AAA420: 48003581  bl 0x82aad9a0
	ctx.lr = 0x82AAA424;
	sub_82AAD9A0(ctx, base);
	// 82AAA424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA428: 4B76A9B1  bl 0x82214dd8
	ctx.lr = 0x82AAA42C;
	sub_82214DD8(ctx, base);
	// 82AAA42C: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAA430: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA434: 388880E4  addi r4, r8, -0x7f1c
	ctx.r[4].s64 = ctx.r[8].s64 + -32540;
	// 82AAA438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA43C: 4B782A95  bl 0x8222ced0
	ctx.lr = 0x82AAA440;
	sub_8222CED0(ctx, base);
	// 82AAA440: 3CE082AB  lis r7, -0x7d55
	ctx.r[7].s64 = -2102722560;
	// 82AAA444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA448: 3887BD08  addi r4, r7, -0x42f8
	ctx.r[4].s64 = ctx.r[7].s64 + -17144;
	// 82AAA44C: 48003555  bl 0x82aad9a0
	ctx.lr = 0x82AAA450;
	sub_82AAD9A0(ctx, base);
	// 82AAA450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA454: 4B76A985  bl 0x82214dd8
	ctx.lr = 0x82AAA458;
	sub_82214DD8(ctx, base);
	// 82AAA458: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAA45C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA460: 388680F0  addi r4, r6, -0x7f10
	ctx.r[4].s64 = ctx.r[6].s64 + -32528;
	// 82AAA464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA468: 4B782A69  bl 0x8222ced0
	ctx.lr = 0x82AAA46C;
	sub_8222CED0(ctx, base);
	// 82AAA46C: 3CA082AB  lis r5, -0x7d55
	ctx.r[5].s64 = -2102722560;
	// 82AAA470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA474: 3885C7F0  addi r4, r5, -0x3810
	ctx.r[4].s64 = ctx.r[5].s64 + -14352;
	// 82AAA478: 48003529  bl 0x82aad9a0
	ctx.lr = 0x82AAA47C;
	sub_82AAD9A0(ctx, base);
	// 82AAA47C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA480: 4B76A959  bl 0x82214dd8
	ctx.lr = 0x82AAA484;
	sub_82214DD8(ctx, base);
	// 82AAA484: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAA488: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA48C: 388480FC  addi r4, r4, -0x7f04
	ctx.r[4].s64 = ctx.r[4].s64 + -32516;
	// 82AAA490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA494: 4B782A3D  bl 0x8222ced0
	ctx.lr = 0x82AAA498;
	sub_8222CED0(ctx, base);
	// 82AAA498: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82AAA49C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA4A0: 388BCB38  addi r4, r11, -0x34c8
	ctx.r[4].s64 = ctx.r[11].s64 + -13512;
	// 82AAA4A4: 480034FD  bl 0x82aad9a0
	ctx.lr = 0x82AAA4A8;
	sub_82AAD9A0(ctx, base);
	// 82AAA4A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA4AC: 4B76A92D  bl 0x82214dd8
	ctx.lr = 0x82AAA4B0;
	sub_82214DD8(ctx, base);
	// 82AAA4B0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAA4B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA4B8: 388A810C  addi r4, r10, -0x7ef4
	ctx.r[4].s64 = ctx.r[10].s64 + -32500;
	// 82AAA4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA4C0: 4B782A11  bl 0x8222ced0
	ctx.lr = 0x82AAA4C4;
	sub_8222CED0(ctx, base);
	// 82AAA4C4: 3D2082AB  lis r9, -0x7d55
	ctx.r[9].s64 = -2102722560;
	// 82AAA4C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA4CC: 3889CBE0  addi r4, r9, -0x3420
	ctx.r[4].s64 = ctx.r[9].s64 + -13344;
	// 82AAA4D0: 480034D1  bl 0x82aad9a0
	ctx.lr = 0x82AAA4D4;
	sub_82AAD9A0(ctx, base);
	// 82AAA4D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA4D8: 4B76A901  bl 0x82214dd8
	ctx.lr = 0x82AAA4DC;
	sub_82214DD8(ctx, base);
	// 82AAA4DC: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAA4E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA4E4: 3888811C  addi r4, r8, -0x7ee4
	ctx.r[4].s64 = ctx.r[8].s64 + -32484;
	// 82AAA4E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA4EC: 4B7829E5  bl 0x8222ced0
	ctx.lr = 0x82AAA4F0;
	sub_8222CED0(ctx, base);
	// 82AAA4F0: 3CE082AB  lis r7, -0x7d55
	ctx.r[7].s64 = -2102722560;
	// 82AAA4F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA4F8: 3887CE00  addi r4, r7, -0x3200
	ctx.r[4].s64 = ctx.r[7].s64 + -12800;
	// 82AAA4FC: 480034A5  bl 0x82aad9a0
	ctx.lr = 0x82AAA500;
	sub_82AAD9A0(ctx, base);
	// 82AAA500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA504: 4B76A8D5  bl 0x82214dd8
	ctx.lr = 0x82AAA508;
	sub_82214DD8(ctx, base);
	// 82AAA508: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAA50C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA510: 38868130  addi r4, r6, -0x7ed0
	ctx.r[4].s64 = ctx.r[6].s64 + -32464;
	// 82AAA514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA518: 4B7829B9  bl 0x8222ced0
	ctx.lr = 0x82AAA51C;
	sub_8222CED0(ctx, base);
	// 82AAA51C: 3CA082AB  lis r5, -0x7d55
	ctx.r[5].s64 = -2102722560;
	// 82AAA520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA524: 3885CE40  addi r4, r5, -0x31c0
	ctx.r[4].s64 = ctx.r[5].s64 + -12736;
	// 82AAA528: 48003479  bl 0x82aad9a0
	ctx.lr = 0x82AAA52C;
	sub_82AAD9A0(ctx, base);
	// 82AAA52C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA530: 4B76A8A9  bl 0x82214dd8
	ctx.lr = 0x82AAA534;
	sub_82214DD8(ctx, base);
	// 82AAA534: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 82AAA538: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA53C: 3884824C  addi r4, r4, -0x7db4
	ctx.r[4].s64 = ctx.r[4].s64 + -32180;
	// 82AAA540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA544: 4B78298D  bl 0x8222ced0
	ctx.lr = 0x82AAA548;
	sub_8222CED0(ctx, base);
	// 82AAA548: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82AAA54C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA550: 388BD240  addi r4, r11, -0x2dc0
	ctx.r[4].s64 = ctx.r[11].s64 + -11712;
	// 82AAA554: 4800344D  bl 0x82aad9a0
	ctx.lr = 0x82AAA558;
	sub_82AAD9A0(ctx, base);
	// 82AAA558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA55C: 4B76A87D  bl 0x82214dd8
	ctx.lr = 0x82AAA560;
	sub_82214DD8(ctx, base);
	// 82AAA560: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAA564: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA568: 388A8148  addi r4, r10, -0x7eb8
	ctx.r[4].s64 = ctx.r[10].s64 + -32440;
	// 82AAA56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA570: 4B782961  bl 0x8222ced0
	ctx.lr = 0x82AAA574;
	sub_8222CED0(ctx, base);
	// 82AAA574: 3D2082AB  lis r9, -0x7d55
	ctx.r[9].s64 = -2102722560;
	// 82AAA578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA57C: 3889C550  addi r4, r9, -0x3ab0
	ctx.r[4].s64 = ctx.r[9].s64 + -15024;
	// 82AAA580: 48003421  bl 0x82aad9a0
	ctx.lr = 0x82AAA584;
	sub_82AAD9A0(ctx, base);
	// 82AAA584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA588: 4B76A851  bl 0x82214dd8
	ctx.lr = 0x82AAA58C;
	sub_82214DD8(ctx, base);
	// 82AAA58C: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAA590: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA594: 38888158  addi r4, r8, -0x7ea8
	ctx.r[4].s64 = ctx.r[8].s64 + -32424;
	// 82AAA598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA59C: 4B782935  bl 0x8222ced0
	ctx.lr = 0x82AAA5A0;
	sub_8222CED0(ctx, base);
	// 82AAA5A0: 3CE082AB  lis r7, -0x7d55
	ctx.r[7].s64 = -2102722560;
	// 82AAA5A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA5A8: 3887C5E0  addi r4, r7, -0x3a20
	ctx.r[4].s64 = ctx.r[7].s64 + -14880;
	// 82AAA5AC: 480033F5  bl 0x82aad9a0
	ctx.lr = 0x82AAA5B0;
	sub_82AAD9A0(ctx, base);
	// 82AAA5B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA5B4: 4B76A825  bl 0x82214dd8
	ctx.lr = 0x82AAA5B8;
	sub_82214DD8(ctx, base);
	// 82AAA5B8: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAA5BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAA5C0: 38868168  addi r4, r6, -0x7e98
	ctx.r[4].s64 = ctx.r[6].s64 + -32408;
	// 82AAA5C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA5C8: 4B782909  bl 0x8222ced0
	ctx.lr = 0x82AAA5CC;
	sub_8222CED0(ctx, base);
	// 82AAA5CC: 3CA082AB  lis r5, -0x7d55
	ctx.r[5].s64 = -2102722560;
	// 82AAA5D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA5D4: 3885D908  addi r4, r5, -0x26f8
	ctx.r[4].s64 = ctx.r[5].s64 + -9976;
	// 82AAA5D8: 480033C9  bl 0x82aad9a0
	ctx.lr = 0x82AAA5DC;
	sub_82AAD9A0(ctx, base);
	// 82AAA5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA5E0: 4B76A7F9  bl 0x82214dd8
	ctx.lr = 0x82AAA5E4;
	sub_82214DD8(ctx, base);
	// 82AAA5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA5E8: 4B7876D1  bl 0x82231cb8
	ctx.lr = 0x82AAA5EC;
	sub_82231CB8(ctx, base);
	// 82AAA5EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAA5F0: 4B7876C9  bl 0x82231cb8
	ctx.lr = 0x82AAA5F4;
	sub_82231CB8(ctx, base);
	// 82AAA5F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAA5F8: 481FEE64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAA600 size=828
    let mut pc: u32 = 0x82AAA600;
    'dispatch: loop {
        match pc {
            0x82AAA600 => {
    //   block [0x82AAA600..0x82AAA93C)
	// 82AAA600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAA60C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA610: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82AAA614: 482036C5  bl 0x82cadcd8
	ctx.lr = 0x82AAA618;
	sub_82CADCA0(ctx, base);
	// 82AAA618: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAA940 size=560
    let mut pc: u32 = 0x82AAA940;
    'dispatch: loop {
        match pc {
            0x82AAA940 => {
    //   block [0x82AAA940..0x82AAA974)
	// 82AAA940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA944: 481FEAC5  bl 0x82ca9408
	ctx.lr = 0x82AAA948;
	sub_82CA93D0(ctx, base);
	// 82AAA948: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA94C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA950: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 82AAA954: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAA958: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAA95C: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 82AAA960: 4B749B21  bl 0x821f4480
	ctx.lr = 0x82AAA964;
	sub_821F4480(ctx, base);
	// 82AAA964: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AAA968: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AAA96C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAA970: 419A00B0  beq cr6, 0x82aaaa20
	if ctx.cr[6].eq {
	pc = 0x82AAAA20; continue 'dispatch;
	}
	pc = 0x82AAA974; continue 'dispatch;
            }
            0x82AAA974 => {
    //   block [0x82AAA974..0x82AAA998)
	// 82AAA974: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAA978: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AAA97C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA980: 419A0018  beq cr6, 0x82aaa998
	if ctx.cr[6].eq {
	pc = 0x82AAA998; continue 'dispatch;
	}
	// 82AAA984: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAA988: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AAA98C: 7D091670  srawi r9, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82AAA990: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AAA994: 41980008  blt cr6, 0x82aaa99c
	if ctx.cr[6].lt {
	pc = 0x82AAA99C; continue 'dispatch;
	}
	pc = 0x82AAA998; continue 'dispatch;
            }
            0x82AAA998 => {
    //   block [0x82AAA998..0x82AAA99C)
	// 82AAA998: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AAA99C; continue 'dispatch;
            }
            0x82AAA99C => {
    //   block [0x82AAA99C..0x82AAA9D0)
	// 82AAA99C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AAA9A0: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AAA9A4: 806900F0  lwz r3, 0xf0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AAA9A8: 4B77B951  bl 0x822262f8
	ctx.lr = 0x82AAA9AC;
	sub_822262F8(ctx, base);
	// 82AAA9AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AAA9B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AAA9B4: 3BFC0078  addi r31, r28, 0x78
	ctx.r[31].s64 = ctx.r[28].s64 + 120;
	// 82AAA9B8: 811C0080  lwz r8, 0x80(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AAA9BC: 80FC007C  lwz r7, 0x7c(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AAA9C0: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82AAA9C4: 7CC51E71  srawi. r5, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82AAA9C8: 41820040  beq 0x82aaaa08
	if ctx.cr[0].eq {
	pc = 0x82AAAA08; continue 'dispatch;
	}
	// 82AAA9CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82AAA9D0; continue 'dispatch;
            }
            0x82AAA9D0 => {
    //   block [0x82AAA9D0..0x82AAAA08)
	// 82AAA9D0: 817C007C  lwz r11, 0x7c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AAA9D4: 38C10074  addi r6, r1, 0x74
	ctx.r[6].s64 = ctx.r[1].s64 + 116;
	// 82AAA9D8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82AAA9DC: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AAA9E0: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AAA9E4: 4808361D  bl 0x82b2e000
	ctx.lr = 0x82AAA9E8;
	sub_82B2E000(ctx, base);
	// 82AAA9E8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAA9EC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82AAA9F0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA9F4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82AAA9F8: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AAA9FC: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82AAAA00: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AAAA04: 4198FFCC  blt cr6, 0x82aaa9d0
	if ctx.cr[6].lt {
	pc = 0x82AAA9D0; continue 'dispatch;
	}
	pc = 0x82AAAA08; continue 'dispatch;
            }
            0x82AAAA08 => {
    //   block [0x82AAAA08..0x82AAAA20)
	// 82AAAA08: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAAA0C: 4B75536D  bl 0x821ffd78
	ctx.lr = 0x82AAAA10;
	sub_821FFD78(ctx, base);
	// 82AAAA10: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AAAA14: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AAAA18: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AAAA1C: 409AFF58  bne cr6, 0x82aaa974
	if !ctx.cr[6].eq {
	pc = 0x82AAA974; continue 'dispatch;
	}
	pc = 0x82AAAA20; continue 'dispatch;
            }
            0x82AAAA20 => {
    //   block [0x82AAAA20..0x82AAAA34)
	// 82AAAA20: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAAA24: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AAAA28: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82AAAA2C: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 82AAAA30: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82AAAA34; continue 'dispatch;
            }
            0x82AAAA34 => {
    //   block [0x82AAAA34..0x82AAAB4C)
	// 82AAAA34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAAA38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAA3C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAAA40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAAA44: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAAA48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAA4C: 4082FFE8  bne 0x82aaaa34
	if !ctx.cr[0].eq {
	pc = 0x82AAAA34; continue 'dispatch;
	}
	// 82AAAA50: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAAA54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAA58: 38868220  addi r4, r6, -0x7de0
	ctx.r[4].s64 = ctx.r[6].s64 + -32224;
	// 82AAAA5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAA60: 4B7393F1  bl 0x821e3e50
	ctx.lr = 0x82AAAA64;
	sub_821E3E50(ctx, base);
	// 82AAAA64: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AAAA68: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAA6C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAA70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAA74: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAA78: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAA7C: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAA80: 48003029  bl 0x82aadaa8
	ctx.lr = 0x82AAAA84;
	sub_82AADAA8(ctx, base);
	// 82AAAA84: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAAA88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAA8C: 38848244  addi r4, r4, -0x7dbc
	ctx.r[4].s64 = ctx.r[4].s64 + -32188;
	// 82AAAA90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAA94: 4B7393BD  bl 0x821e3e50
	ctx.lr = 0x82AAAA98;
	sub_821E3E50(ctx, base);
	// 82AAAA98: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAA9C: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAAA0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAAA4: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAAA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAAAC: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAAB0: 48002FF9  bl 0x82aadaa8
	ctx.lr = 0x82AAAAB4;
	sub_82AADAA8(ctx, base);
	// 82AAAAB4: 3C608210  lis r3, -0x7df0
	ctx.r[3].s64 = -2112880640;
	// 82AAAAB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAABC: 38838268  addi r4, r3, -0x7d98
	ctx.r[4].s64 = ctx.r[3].s64 + -32152;
	// 82AAAAC0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAAC4: 4B73938D  bl 0x821e3e50
	ctx.lr = 0x82AAAAC8;
	sub_821E3E50(ctx, base);
	// 82AAAAC8: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAACC: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAAD0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAAD4: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAAD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAADC: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAAE0: 48002FC9  bl 0x82aadaa8
	ctx.lr = 0x82AAAAE4;
	sub_82AADAA8(ctx, base);
	// 82AAAAE4: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAAAE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAAEC: 388B8290  addi r4, r11, -0x7d70
	ctx.r[4].s64 = ctx.r[11].s64 + -32112;
	// 82AAAAF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAAF4: 4B73935D  bl 0x821e3e50
	ctx.lr = 0x82AAAAF8;
	sub_821E3E50(ctx, base);
	// 82AAAAF8: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAAFC: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAB00: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAB04: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAB08: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAB0C: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAB10: 48002F99  bl 0x82aadaa8
	ctx.lr = 0x82AAAB14;
	sub_82AADAA8(ctx, base);
	// 82AAAB14: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAAB18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAB1C: 388A82B4  addi r4, r10, -0x7d4c
	ctx.r[4].s64 = ctx.r[10].s64 + -32076;
	// 82AAAB20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAB24: 4B73932D  bl 0x821e3e50
	ctx.lr = 0x82AAAB28;
	sub_821E3E50(ctx, base);
	// 82AAAB28: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAB2C: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAB30: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAB34: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAB38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAB3C: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAB40: 48002F69  bl 0x82aadaa8
	ctx.lr = 0x82AAAB44;
	sub_82AADAA8(ctx, base);
	// 82AAAB44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAB48: 4B71BC21  bl 0x821c6768
	ctx.lr = 0x82AAAB4C;
	sub_821C6768(ctx, base);
	pc = 0x82AAAB4C; continue 'dispatch;
            }
            0x82AAAB4C => {
    //   block [0x82AAAB4C..0x82AAAB70)
	// 82AAAB4C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AAAB50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAB54: 7D20F028  lwarx r9, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AAAB58: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82AAAB5C: 7D20F12D  stwcx. r9, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAAB60: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAB64: 4082FFE8  bne 0x82aaab4c
	if !ctx.cr[0].eq {
	pc = 0x82AAAB4C; continue 'dispatch;
	}
	// 82AAAB68: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AAAB6C: 481FE8EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAAB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAAB70 size=132
    let mut pc: u32 = 0x82AAAB70;
    'dispatch: loop {
        match pc {
            0x82AAAB70 => {
    //   block [0x82AAAB70..0x82AAAB8C)
	// 82AAAB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAAB74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAAB78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAAB7C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAAB80: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AAAB84: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82AAAB88: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	pc = 0x82AAAB8C; continue 'dispatch;
            }
            0x82AAAB8C => {
    //   block [0x82AAAB8C..0x82AAABF4)
	// 82AAAB8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAAB90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAB94: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAAB98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAAB9C: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAABA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAABA4: 4082FFE8  bne 0x82aaab8c
	if !ctx.cr[0].eq {
	pc = 0x82AAAB8C; continue 'dispatch;
	}
	// 82AAABA8: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAABAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAABB0: 388682E0  addi r4, r6, -0x7d20
	ctx.r[4].s64 = ctx.r[6].s64 + -32032;
	// 82AAABB4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAABB8: 4B739299  bl 0x821e3e50
	ctx.lr = 0x82AAABBC;
	sub_821E3E50(ctx, base);
	// 82AAABBC: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82AAABC0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAABC4: 99610072  stb r11, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[11].u8 ) };
	// 82AAABC8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAABCC: 99610071  stb r11, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[11].u8 ) };
	// 82AAABD0: 99610070  stb r11, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82AAABD4: 99610073  stb r11, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[11].u8 ) };
	// 82AAABD8: 48002ED1  bl 0x82aadaa8
	ctx.lr = 0x82AAABDC;
	sub_82AADAA8(ctx, base);
	// 82AAABDC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAABE0: 4B76A1F9  bl 0x82214dd8
	ctx.lr = 0x82AAABE4;
	sub_82214DD8(ctx, base);
	// 82AAABE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAABE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAABEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAABF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAABF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAABF8 size=572
    let mut pc: u32 = 0x82AAABF8;
    'dispatch: loop {
        match pc {
            0x82AAABF8 => {
    //   block [0x82AAABF8..0x82AAAC18)
	// 82AAABF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAABFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAAC00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAAC04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAAC08: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAAC0C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AAAC10: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82AAAC14: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	pc = 0x82AAAC18; continue 'dispatch;
            }
            0x82AAAC18 => {
    //   block [0x82AAAC18..0x82AAAE34)
	// 82AAAC18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAAC1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAC20: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAAC24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAAC28: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAAC2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAC30: 4082FFE8  bne 0x82aaac18
	if !ctx.cr[0].eq {
	pc = 0x82AAAC18; continue 'dispatch;
	}
	// 82AAAC34: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAAC38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAC3C: 388682F8  addi r4, r6, -0x7d08
	ctx.r[4].s64 = ctx.r[6].s64 + -32008;
	// 82AAAC40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAC44: 4B73920D  bl 0x821e3e50
	ctx.lr = 0x82AAAC48;
	sub_821E3E50(ctx, base);
	// 82AAAC48: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AAAC4C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAC50: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAC54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAC58: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAC5C: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAC60: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAC64: 48002E45  bl 0x82aadaa8
	ctx.lr = 0x82AAAC68;
	sub_82AADAA8(ctx, base);
	// 82AAAC68: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAAC6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAC70: 38848314  addi r4, r4, -0x7cec
	ctx.r[4].s64 = ctx.r[4].s64 + -31980;
	// 82AAAC74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAC78: 4B7391D9  bl 0x821e3e50
	ctx.lr = 0x82AAAC7C;
	sub_821E3E50(ctx, base);
	// 82AAAC7C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAC80: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAC84: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAC88: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAC8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAC90: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAC94: 48002E15  bl 0x82aadaa8
	ctx.lr = 0x82AAAC98;
	sub_82AADAA8(ctx, base);
	// 82AAAC98: 3C608210  lis r3, -0x7df0
	ctx.r[3].s64 = -2112880640;
	// 82AAAC9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAACA0: 38838330  addi r4, r3, -0x7cd0
	ctx.r[4].s64 = ctx.r[3].s64 + -31952;
	// 82AAACA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAACA8: 4B7391A9  bl 0x821e3e50
	ctx.lr = 0x82AAACAC;
	sub_821E3E50(ctx, base);
	// 82AAACAC: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAACB0: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAACB4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAACB8: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAACBC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAACC0: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAACC4: 48002DE5  bl 0x82aadaa8
	ctx.lr = 0x82AAACC8;
	sub_82AADAA8(ctx, base);
	// 82AAACC8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAACCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAACD0: 388B8350  addi r4, r11, -0x7cb0
	ctx.r[4].s64 = ctx.r[11].s64 + -31920;
	// 82AAACD4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAACD8: 4B739179  bl 0x821e3e50
	ctx.lr = 0x82AAACDC;
	sub_821E3E50(ctx, base);
	// 82AAACDC: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAACE0: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAACE4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAACE8: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAACEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAACF0: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAACF4: 48002DB5  bl 0x82aadaa8
	ctx.lr = 0x82AAACF8;
	sub_82AADAA8(ctx, base);
	// 82AAACF8: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAACFC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAD00: 388A8364  addi r4, r10, -0x7c9c
	ctx.r[4].s64 = ctx.r[10].s64 + -31900;
	// 82AAAD04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAD08: 4B739149  bl 0x821e3e50
	ctx.lr = 0x82AAAD0C;
	sub_821E3E50(ctx, base);
	// 82AAAD0C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAD10: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAD14: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAD18: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAD1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAD20: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAD24: 48002D85  bl 0x82aadaa8
	ctx.lr = 0x82AAAD28;
	sub_82AADAA8(ctx, base);
	// 82AAAD28: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AAAD2C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAD30: 3889837C  addi r4, r9, -0x7c84
	ctx.r[4].s64 = ctx.r[9].s64 + -31876;
	// 82AAAD34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAD38: 4B739119  bl 0x821e3e50
	ctx.lr = 0x82AAAD3C;
	sub_821E3E50(ctx, base);
	// 82AAAD3C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAD40: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAD44: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAD48: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAD4C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAD50: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAD54: 48002D55  bl 0x82aadaa8
	ctx.lr = 0x82AAAD58;
	sub_82AADAA8(ctx, base);
	// 82AAAD58: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAAD5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAD60: 38888398  addi r4, r8, -0x7c68
	ctx.r[4].s64 = ctx.r[8].s64 + -31848;
	// 82AAAD64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAD68: 4B7390E9  bl 0x821e3e50
	ctx.lr = 0x82AAAD6C;
	sub_821E3E50(ctx, base);
	// 82AAAD6C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAD70: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAD74: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAD78: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAD7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAD80: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAD84: 48002D25  bl 0x82aadaa8
	ctx.lr = 0x82AAAD88;
	sub_82AADAA8(ctx, base);
	// 82AAAD88: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AAAD8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAD90: 388783B8  addi r4, r7, -0x7c48
	ctx.r[4].s64 = ctx.r[7].s64 + -31816;
	// 82AAAD94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAD98: 4B7390B9  bl 0x821e3e50
	ctx.lr = 0x82AAAD9C;
	sub_821E3E50(ctx, base);
	// 82AAAD9C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAADA0: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAADA4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAADA8: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAADAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAADB0: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAADB4: 48002CF5  bl 0x82aadaa8
	ctx.lr = 0x82AAADB8;
	sub_82AADAA8(ctx, base);
	// 82AAADB8: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAADBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAADC0: 388683CC  addi r4, r6, -0x7c34
	ctx.r[4].s64 = ctx.r[6].s64 + -31796;
	// 82AAADC4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAADC8: 4B739089  bl 0x821e3e50
	ctx.lr = 0x82AAADCC;
	sub_821E3E50(ctx, base);
	// 82AAADCC: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAADD0: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAADD4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAADD8: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAADDC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAADE0: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAADE4: 48002CC5  bl 0x82aadaa8
	ctx.lr = 0x82AAADE8;
	sub_82AADAA8(ctx, base);
	// 82AAADE8: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAADEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAADF0: 388483EC  addi r4, r4, -0x7c14
	ctx.r[4].s64 = ctx.r[4].s64 + -31764;
	// 82AAADF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAADF8: 4B739059  bl 0x821e3e50
	ctx.lr = 0x82AAADFC;
	sub_821E3E50(ctx, base);
	// 82AAADFC: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAE00: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAE04: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAE08: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAE0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAE10: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAE14: 48002C95  bl 0x82aadaa8
	ctx.lr = 0x82AAAE18;
	sub_82AADAA8(ctx, base);
	// 82AAAE18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAE1C: 4B769FBD  bl 0x82214dd8
	ctx.lr = 0x82AAAE20;
	sub_82214DD8(ctx, base);
	// 82AAAE20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAAE24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAAE28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAAE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAAE30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAAE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAAE38 size=308
    let mut pc: u32 = 0x82AAAE38;
    'dispatch: loop {
        match pc {
            0x82AAAE38 => {
    //   block [0x82AAAE38..0x82AAAE58)
	// 82AAAE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAAE3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAAE40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAAE44: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAAE48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAAE4C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82AAAE50: 90A10070  stw r5, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 82AAAE54: 39097088  addi r8, r9, 0x7088
	ctx.r[8].s64 = ctx.r[9].s64 + 28808;
	pc = 0x82AAAE58; continue 'dispatch;
            }
            0x82AAAE58 => {
    //   block [0x82AAAE58..0x82AAAEA0)
	// 82AAAE58: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AAAE5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAE60: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AAAE64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAAE68: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAAE6C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAE70: 4082FFE8  bne 0x82aaae58
	if !ctx.cr[0].eq {
	pc = 0x82AAAE58; continue 'dispatch;
	}
	// 82AAAE74: 3CE0834C  lis r7, -0x7cb4
	ctx.r[7].s64 = -2092171264;
	// 82AAAE78: 38C00070  li r6, 0x70
	ctx.r[6].s64 = 112;
	// 82AAAE7C: 3887DE9C  addi r4, r7, -0x2164
	ctx.r[4].s64 = ctx.r[7].s64 + -8548;
	// 82AAAE80: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAAE84: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAAE88: 7C6B5050  subf r3, r11, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AAAE8C: 7CC333D6  divw r6, r3, r6
	ctx.r[6].s32 = ctx.r[3].s32 / ctx.r[6].s32;
	// 82AAAE90: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82AAAE94: 40990028  ble cr6, 0x82aaaebc
	if !ctx.cr[6].gt {
	pc = 0x82AAAEBC; continue 'dispatch;
	}
	// 82AAAE98: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 82AAAE9C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x82AAAEA0; continue 'dispatch;
            }
            0x82AAAEA0 => {
    //   block [0x82AAAEA0..0x82AAAEB0)
	// 82AAAEA0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAAEA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AAAEA8: 419A0008  beq cr6, 0x82aaaeb0
	if ctx.cr[6].eq {
	pc = 0x82AAAEB0; continue 'dispatch;
	}
	// 82AAAEAC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	pc = 0x82AAAEB0; continue 'dispatch;
            }
            0x82AAAEB0 => {
    //   block [0x82AAAEB0..0x82AAAEBC)
	// 82AAAEB0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAAEB4: 394A0070  addi r10, r10, 0x70
	ctx.r[10].s64 = ctx.r[10].s64 + 112;
	// 82AAAEB8: 4082FFE8  bne 0x82aaaea0
	if !ctx.cr[0].eq {
	pc = 0x82AAAEA0; continue 'dispatch;
	}
	pc = 0x82AAAEBC; continue 'dispatch;
            }
            0x82AAAEBC => {
    //   block [0x82AAAEBC..0x82AAAF6C)
	// 82AAAEBC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAAEC0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAEC4: 388B840C  addi r4, r11, -0x7bf4
	ctx.r[4].s64 = ctx.r[11].s64 + -31732;
	// 82AAAEC8: 4B738F89  bl 0x821e3e50
	ctx.lr = 0x82AAAECC;
	sub_821E3E50(ctx, base);
	// 82AAAECC: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AAAED0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAED4: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAED8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAEDC: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAEE0: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAEE4: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAEE8: 48002BC1  bl 0x82aadaa8
	ctx.lr = 0x82AAAEEC;
	sub_82AADAA8(ctx, base);
	// 82AAAEEC: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAAEF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAEF4: 388A842C  addi r4, r10, -0x7bd4
	ctx.r[4].s64 = ctx.r[10].s64 + -31700;
	// 82AAAEF8: 4B738F59  bl 0x821e3e50
	ctx.lr = 0x82AAAEFC;
	sub_821E3E50(ctx, base);
	// 82AAAEFC: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAF00: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAF04: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAF08: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAF0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAF10: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAF14: 48002B95  bl 0x82aadaa8
	ctx.lr = 0x82AAAF18;
	sub_82AADAA8(ctx, base);
	// 82AAAF18: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAAF1C: 480DC575  bl 0x82b87490
	ctx.lr = 0x82AAAF20;
	sub_82B87490(ctx, base);
	// 82AAAF20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAAF24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAF28: 4B7BA279  bl 0x822651a0
	ctx.lr = 0x82AAAF2C;
	sub_822651A0(ctx, base);
	// 82AAAF2C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAAF30: 4B769EA9  bl 0x82214dd8
	ctx.lr = 0x82AAAF34;
	sub_82214DD8(ctx, base);
	// 82AAAF34: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAAF38: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAAF3C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAAF40: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAAF44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAF48: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAAF4C: 48002B5D  bl 0x82aadaa8
	ctx.lr = 0x82AAAF50;
	sub_82AADAA8(ctx, base);
	// 82AAAF50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAF54: 4B769E85  bl 0x82214dd8
	ctx.lr = 0x82AAAF58;
	sub_82214DD8(ctx, base);
	// 82AAAF58: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAAF5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAAF60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAAF64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAAF68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAAF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAAF70 size=3480
    let mut pc: u32 = 0x82AAAF70;
    'dispatch: loop {
        match pc {
            0x82AAAF70 => {
    //   block [0x82AAAF70..0x82AAAF90)
	// 82AAAF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAAF74: 481FE46D  bl 0x82ca93e0
	ctx.lr = 0x82AAAF78;
	sub_82CA93D0(ctx, base);
	// 82AAAF78: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAAF7C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAAF80: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82AAAF84: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	// 82AAAF88: 93010098  stw r24, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[24].u32 ) };
	// 82AAAF8C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x82AAAF90; continue 'dispatch;
            }
            0x82AAAF90 => {
    //   block [0x82AAAF90..0x82AAB030)
	// 82AAAF90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAAF94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAF98: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAAF9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAAFA0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAAFA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAAFA8: 4082FFE8  bne 0x82aaaf90
	if !ctx.cr[0].eq {
	pc = 0x82AAAF90; continue 'dispatch;
	}
	// 82AAAFAC: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82AAAFB0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AAAFB4: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82AAAFB8: 3AEB5734  addi r23, r11, 0x5734
	ctx.r[23].s64 = ctx.r[11].s64 + 22324;
	// 82AAAFBC: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 82AAAFC0: 82A7FA0C  lwz r21, -0x5f4(r7)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 82AAAFC4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAAFC8: 388470E4  addi r4, r4, 0x70e4
	ctx.r[4].s64 = ctx.r[4].s64 + 28900;
	// 82AAAFCC: 82CB5734  lwz r22, 0x5734(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22324 as u32) ) } as u64;
	// 82AAAFD0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAAFD4: 8366FA10  lwz r27, -0x5f0(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-1520 as u32) ) } as u64;
	// 82AAAFD8: 83970004  lwz r28, 4(r23)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAAFDC: 83B50008  lwz r29, 8(r21)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAAFE0: 4B781EF1  bl 0x8222ced0
	ctx.lr = 0x82AAAFE4;
	sub_8222CED0(ctx, base);
	// 82AAAFE4: 3B2000FF  li r25, 0xff
	ctx.r[25].s64 = 255;
	// 82AAAFE8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAAFEC: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAAFF0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAAFF4: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAAFF8: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAAFFC: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	// 82AAB000: 48002AA9  bl 0x82aadaa8
	ctx.lr = 0x82AAB004;
	sub_82AADAA8(ctx, base);
	// 82AAB004: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB008: 4B769DD1  bl 0x82214dd8
	ctx.lr = 0x82AAB00C;
	sub_82214DD8(ctx, base);
	// 82AAB00C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAB010: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 82AAB014: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAB018: 3A8B0B34  addi r20, r11, 0xb34
	ctx.r[20].s64 = ctx.r[11].s64 + 2868;
	// 82AAB01C: 40990088  ble cr6, 0x82aab0a4
	if !ctx.cr[6].gt {
	pc = 0x82AAB0A4; continue 'dispatch;
	}
	// 82AAB020: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB024: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB028: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB02C: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	pc = 0x82AAB030; continue 'dispatch;
            }
            0x82AAB030 => {
    //   block [0x82AAB030..0x82AAB038)
	// 82AAB030: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82AAB034: 93010088  stw r24, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[24].u32 ) };
	pc = 0x82AAB038; continue 'dispatch;
            }
            0x82AAB038 => {
    //   block [0x82AAB038..0x82AAB07C)
	// 82AAB038: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AAB03C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB040: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AAB044: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAB048: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB04C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB050: 4082FFE8  bne 0x82aab038
	if !ctx.cr[0].eq {
	pc = 0x82AAB038; continue 'dispatch;
	}
	// 82AAB054: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82AAB058: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAB05C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB060: 4B738DF1  bl 0x821e3e50
	ctx.lr = 0x82AAB064;
	sub_821E3E50(ctx, base);
	// 82AAB064: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB068: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB06C: 48002A3D  bl 0x82aadaa8
	ctx.lr = 0x82AAB070;
	sub_82AADAA8(ctx, base);
	// 82AAB070: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB074: 4B71B6F5  bl 0x821c6768
	ctx.lr = 0x82AAB078;
	sub_821C6768(ctx, base);
	// 82AAB078: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	pc = 0x82AAB07C; continue 'dispatch;
            }
            0x82AAB07C => {
    //   block [0x82AAB07C..0x82AAB0A4)
	// 82AAB07C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82AAB080: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB084: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82AAB088: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82AAB08C: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB090: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB094: 4082FFE8  bne 0x82aab07c
	if !ctx.cr[0].eq {
	pc = 0x82AAB07C; continue 'dispatch;
	}
	// 82AAB098: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82AAB09C: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82AAB0A0: 4198FF90  blt cr6, 0x82aab030
	if ctx.cr[6].lt {
	pc = 0x82AAB030; continue 'dispatch;
	}
	pc = 0x82AAB0A4; continue 'dispatch;
            }
            0x82AAB0A4 => {
    //   block [0x82AAB0A4..0x82AAB0EC)
	// 82AAB0A4: 39760064  addi r11, r22, 0x64
	ctx.r[11].s64 = ctx.r[22].s64 + 100;
	// 82AAB0A8: 93970004  stw r28, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AAB0AC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82AAB0B0: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB0B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAB0B8: 388AA64C  addi r4, r10, -0x59b4
	ctx.r[4].s64 = ctx.r[10].s64 + -22964;
	// 82AAB0BC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB0C0: 4B781E11  bl 0x8222ced0
	ctx.lr = 0x82AAB0C4;
	sub_8222CED0(ctx, base);
	// 82AAB0C4: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB0C8: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB0CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB0D0: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB0D4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB0D8: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	// 82AAB0DC: 480029CD  bl 0x82aadaa8
	ctx.lr = 0x82AAB0E0;
	sub_82AADAA8(ctx, base);
	// 82AAB0E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB0E4: 4B71B685  bl 0x821c6768
	ctx.lr = 0x82AAB0E8;
	sub_821C6768(ctx, base);
	// 82AAB0E8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82AAB0EC; continue 'dispatch;
            }
            0x82AAB0EC => {
    //   block [0x82AAB0EC..0x82AAB128)
	// 82AAB0EC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AAB0F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB0F4: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AAB0F8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82AAB0FC: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB100: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB104: 4082FFE8  bne 0x82aab0ec
	if !ctx.cr[0].eq {
	pc = 0x82AAB0EC; continue 'dispatch;
	}
	// 82AAB108: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAB10C: 40990090  ble cr6, 0x82aab19c
	if !ctx.cr[6].gt {
	pc = 0x82AAB19C; continue 'dispatch;
	}
	// 82AAB110: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB114: 3BD50080  addi r30, r21, 0x80
	ctx.r[30].s64 = ctx.r[21].s64 + 128;
	// 82AAB118: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB11C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82AAB120: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB124: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	pc = 0x82AAB128; continue 'dispatch;
            }
            0x82AAB128 => {
    //   block [0x82AAB128..0x82AAB134)
	// 82AAB128: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB12C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82AAB130: 93010088  stw r24, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[24].u32 ) };
	pc = 0x82AAB134; continue 'dispatch;
            }
            0x82AAB134 => {
    //   block [0x82AAB134..0x82AAB174)
	// 82AAB134: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AAB138: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB13C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AAB140: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAB144: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB148: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB14C: 4082FFE8  bne 0x82aab134
	if !ctx.cr[0].eq {
	pc = 0x82AAB134; continue 'dispatch;
	}
	// 82AAB150: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82AAB154: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB158: 4B738CF9  bl 0x821e3e50
	ctx.lr = 0x82AAB15C;
	sub_821E3E50(ctx, base);
	// 82AAB15C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB160: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB164: 48002945  bl 0x82aadaa8
	ctx.lr = 0x82AAB168;
	sub_82AADAA8(ctx, base);
	// 82AAB168: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB16C: 4B71B5FD  bl 0x821c6768
	ctx.lr = 0x82AAB170;
	sub_821C6768(ctx, base);
	// 82AAB170: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	pc = 0x82AAB174; continue 'dispatch;
            }
            0x82AAB174 => {
    //   block [0x82AAB174..0x82AAB19C)
	// 82AAB174: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82AAB178: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB17C: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82AAB180: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82AAB184: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB188: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB18C: 4082FFE8  bne 0x82aab174
	if !ctx.cr[0].eq {
	pc = 0x82AAB174; continue 'dispatch;
	}
	// 82AAB190: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAB194: 3BDE004C  addi r30, r30, 0x4c
	ctx.r[30].s64 = ctx.r[30].s64 + 76;
	// 82AAB198: 4082FF90  bne 0x82aab128
	if !ctx.cr[0].eq {
	pc = 0x82AAB128; continue 'dispatch;
	}
	pc = 0x82AAB19C; continue 'dispatch;
            }
            0x82AAB19C => {
    //   block [0x82AAB19C..0x82AAB1E4)
	// 82AAB19C: 397600C8  addi r11, r22, 0xc8
	ctx.r[11].s64 = ctx.r[22].s64 + 200;
	// 82AAB1A0: 93970004  stw r28, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AAB1A4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAB1A8: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB1AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAB1B0: 388A843C  addi r4, r10, -0x7bc4
	ctx.r[4].s64 = ctx.r[10].s64 + -31684;
	// 82AAB1B4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB1B8: 4B781D19  bl 0x8222ced0
	ctx.lr = 0x82AAB1BC;
	sub_8222CED0(ctx, base);
	// 82AAB1BC: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB1C0: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB1C4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB1C8: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB1CC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB1D0: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	// 82AAB1D4: 480028D5  bl 0x82aadaa8
	ctx.lr = 0x82AAB1D8;
	sub_82AADAA8(ctx, base);
	// 82AAB1D8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB1DC: 4B71B58D  bl 0x821c6768
	ctx.lr = 0x82AAB1E0;
	sub_821C6768(ctx, base);
	// 82AAB1E0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82AAB1E4; continue 'dispatch;
            }
            0x82AAB1E4 => {
    //   block [0x82AAB1E4..0x82AAB220)
	// 82AAB1E4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AAB1E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB1EC: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AAB1F0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82AAB1F4: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB1F8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB1FC: 4082FFE8  bne 0x82aab1e4
	if !ctx.cr[0].eq {
	pc = 0x82AAB1E4; continue 'dispatch;
	}
	// 82AAB200: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAB204: 409900C4  ble cr6, 0x82aab2c8
	if !ctx.cr[6].gt {
	pc = 0x82AAB2C8; continue 'dispatch;
	}
	// 82AAB208: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB20C: 3BF50080  addi r31, r21, 0x80
	ctx.r[31].s64 = ctx.r[21].s64 + 128;
	// 82AAB210: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB214: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82AAB218: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB21C: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	pc = 0x82AAB220; continue 'dispatch;
            }
            0x82AAB220 => {
    //   block [0x82AAB220..0x82AAB238)
	// 82AAB220: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB224: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82AAB228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAB22C: 419A002C  beq cr6, 0x82aab258
	if ctx.cr[6].eq {
	pc = 0x82AAB258; continue 'dispatch;
	}
	// 82AAB230: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAB234: 394A0026  addi r10, r10, 0x26
	ctx.r[10].s64 = ctx.r[10].s64 + 38;
	pc = 0x82AAB238; continue 'dispatch;
            }
            0x82AAB238 => {
    //   block [0x82AAB238..0x82AAB24C)
	// 82AAB238: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB23C: 55280672  rlwinm r8, r9, 0, 0x19, 0x19
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82AAB240: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAB244: 419A0008  beq cr6, 0x82aab24c
	if ctx.cr[6].eq {
	pc = 0x82AAB24C; continue 'dispatch;
	}
	// 82AAB248: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	pc = 0x82AAB24C; continue 'dispatch;
            }
            0x82AAB24C => {
    //   block [0x82AAB24C..0x82AAB258)
	// 82AAB24C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB250: 394A004C  addi r10, r10, 0x4c
	ctx.r[10].s64 = ctx.r[10].s64 + 76;
	// 82AAB254: 4082FFE4  bne 0x82aab238
	if !ctx.cr[0].eq {
	pc = 0x82AAB238; continue 'dispatch;
	}
	pc = 0x82AAB258; continue 'dispatch;
            }
            0x82AAB258 => {
    //   block [0x82AAB258..0x82AAB260)
	// 82AAB258: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82AAB25C: 93010088  stw r24, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[24].u32 ) };
	pc = 0x82AAB260; continue 'dispatch;
            }
            0x82AAB260 => {
    //   block [0x82AAB260..0x82AAB2A0)
	// 82AAB260: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AAB264: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB268: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AAB26C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAB270: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB274: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB278: 4082FFE8  bne 0x82aab260
	if !ctx.cr[0].eq {
	pc = 0x82AAB260; continue 'dispatch;
	}
	// 82AAB27C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82AAB280: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB284: 4B738BCD  bl 0x821e3e50
	ctx.lr = 0x82AAB288;
	sub_821E3E50(ctx, base);
	// 82AAB288: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB28C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB290: 48002819  bl 0x82aadaa8
	ctx.lr = 0x82AAB294;
	sub_82AADAA8(ctx, base);
	// 82AAB294: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB298: 4B71B4D1  bl 0x821c6768
	ctx.lr = 0x82AAB29C;
	sub_821C6768(ctx, base);
	// 82AAB29C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	pc = 0x82AAB2A0; continue 'dispatch;
            }
            0x82AAB2A0 => {
    //   block [0x82AAB2A0..0x82AAB2C8)
	// 82AAB2A0: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82AAB2A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB2A8: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82AAB2AC: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82AAB2B0: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB2B4: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB2B8: 4082FFE8  bne 0x82aab2a0
	if !ctx.cr[0].eq {
	pc = 0x82AAB2A0; continue 'dispatch;
	}
	// 82AAB2BC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AAB2C0: 3BFF004C  addi r31, r31, 0x4c
	ctx.r[31].s64 = ctx.r[31].s64 + 76;
	// 82AAB2C4: 4082FF5C  bne 0x82aab220
	if !ctx.cr[0].eq {
	pc = 0x82AAB220; continue 'dispatch;
	}
	pc = 0x82AAB2C8; continue 'dispatch;
            }
            0x82AAB2C8 => {
    //   block [0x82AAB2C8..0x82AAB310)
	// 82AAB2C8: 3976012C  addi r11, r22, 0x12c
	ctx.r[11].s64 = ctx.r[22].s64 + 300;
	// 82AAB2CC: 93970004  stw r28, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AAB2D0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAB2D4: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB2D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAB2DC: 388A8444  addi r4, r10, -0x7bbc
	ctx.r[4].s64 = ctx.r[10].s64 + -31676;
	// 82AAB2E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB2E4: 4B781BED  bl 0x8222ced0
	ctx.lr = 0x82AAB2E8;
	sub_8222CED0(ctx, base);
	// 82AAB2E8: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB2EC: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB2F0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB2F4: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB2F8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB2FC: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	// 82AAB300: 480027A9  bl 0x82aadaa8
	ctx.lr = 0x82AAB304;
	sub_82AADAA8(ctx, base);
	// 82AAB304: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB308: 4B71B461  bl 0x821c6768
	ctx.lr = 0x82AAB30C;
	sub_821C6768(ctx, base);
	// 82AAB30C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82AAB310; continue 'dispatch;
            }
            0x82AAB310 => {
    //   block [0x82AAB310..0x82AAB34C)
	// 82AAB310: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AAB314: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB318: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AAB31C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82AAB320: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB324: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB328: 4082FFE8  bne 0x82aab310
	if !ctx.cr[0].eq {
	pc = 0x82AAB310; continue 'dispatch;
	}
	// 82AAB32C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAB330: 409900E8  ble cr6, 0x82aab418
	if !ctx.cr[6].gt {
	pc = 0x82AAB418; continue 'dispatch;
	}
	// 82AAB334: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB338: 3BF50080  addi r31, r21, 0x80
	ctx.r[31].s64 = ctx.r[21].s64 + 128;
	// 82AAB33C: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB340: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82AAB344: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB348: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	pc = 0x82AAB34C; continue 'dispatch;
            }
            0x82AAB34C => {
    //   block [0x82AAB34C..0x82AAB368)
	// 82AAB34C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB350: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82AAB354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAB358: 419A0050  beq cr6, 0x82aab3a8
	if ctx.cr[6].eq {
	pc = 0x82AAB3A8; continue 'dispatch;
	}
	// 82AAB35C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAB360: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82AAB364: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	pc = 0x82AAB368; continue 'dispatch;
            }
            0x82AAB368 => {
    //   block [0x82AAB368..0x82AAB39C)
	// 82AAB368: 894B001E  lbz r10, 0x1e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(30 as u32) ) } as u64;
	// 82AAB36C: 55480672  rlwinm r8, r10, 0, 0x19, 0x19
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AAB370: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAB374: 419A0028  beq cr6, 0x82aab39c
	if ctx.cr[6].eq {
	pc = 0x82AAB39C; continue 'dispatch;
	}
	// 82AAB378: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB37C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAB380: 419A001C  beq cr6, 0x82aab39c
	if ctx.cr[6].eq {
	pc = 0x82AAB39C; continue 'dispatch;
	}
	// 82AAB384: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AAB388: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAB38C: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82AAB390: 2B070003  cmplwi cr6, r7, 3
	ctx.cr[6].compare_u32(ctx.r[7].u32, 3 as u32, &mut ctx.xer);
	// 82AAB394: 41990008  bgt cr6, 0x82aab39c
	if ctx.cr[6].gt {
	pc = 0x82AAB39C; continue 'dispatch;
	}
	// 82AAB398: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	pc = 0x82AAB39C; continue 'dispatch;
            }
            0x82AAB39C => {
    //   block [0x82AAB39C..0x82AAB3A8)
	// 82AAB39C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AAB3A0: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	// 82AAB3A4: 4082FFC4  bne 0x82aab368
	if !ctx.cr[0].eq {
	pc = 0x82AAB368; continue 'dispatch;
	}
	pc = 0x82AAB3A8; continue 'dispatch;
            }
            0x82AAB3A8 => {
    //   block [0x82AAB3A8..0x82AAB3B0)
	// 82AAB3A8: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82AAB3AC: 93010088  stw r24, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[24].u32 ) };
	pc = 0x82AAB3B0; continue 'dispatch;
            }
            0x82AAB3B0 => {
    //   block [0x82AAB3B0..0x82AAB3F0)
	// 82AAB3B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AAB3B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB3B8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AAB3BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAB3C0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB3C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB3C8: 4082FFE8  bne 0x82aab3b0
	if !ctx.cr[0].eq {
	pc = 0x82AAB3B0; continue 'dispatch;
	}
	// 82AAB3CC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82AAB3D0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB3D4: 4B738A7D  bl 0x821e3e50
	ctx.lr = 0x82AAB3D8;
	sub_821E3E50(ctx, base);
	// 82AAB3D8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB3DC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB3E0: 480026C9  bl 0x82aadaa8
	ctx.lr = 0x82AAB3E4;
	sub_82AADAA8(ctx, base);
	// 82AAB3E4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB3E8: 4B71B381  bl 0x821c6768
	ctx.lr = 0x82AAB3EC;
	sub_821C6768(ctx, base);
	// 82AAB3EC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	pc = 0x82AAB3F0; continue 'dispatch;
            }
            0x82AAB3F0 => {
    //   block [0x82AAB3F0..0x82AAB418)
	// 82AAB3F0: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82AAB3F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB3F8: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82AAB3FC: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82AAB400: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB404: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB408: 4082FFE8  bne 0x82aab3f0
	if !ctx.cr[0].eq {
	pc = 0x82AAB3F0; continue 'dispatch;
	}
	// 82AAB40C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AAB410: 3BFF004C  addi r31, r31, 0x4c
	ctx.r[31].s64 = ctx.r[31].s64 + 76;
	// 82AAB414: 4082FF38  bne 0x82aab34c
	if !ctx.cr[0].eq {
	pc = 0x82AAB34C; continue 'dispatch;
	}
	pc = 0x82AAB418; continue 'dispatch;
            }
            0x82AAB418 => {
    //   block [0x82AAB418..0x82AAB460)
	// 82AAB418: 39760190  addi r11, r22, 0x190
	ctx.r[11].s64 = ctx.r[22].s64 + 400;
	// 82AAB41C: 93970004  stw r28, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AAB420: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAB424: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB428: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAB42C: 388A844C  addi r4, r10, -0x7bb4
	ctx.r[4].s64 = ctx.r[10].s64 + -31668;
	// 82AAB430: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB434: 4B781A9D  bl 0x8222ced0
	ctx.lr = 0x82AAB438;
	sub_8222CED0(ctx, base);
	// 82AAB438: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB43C: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB440: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB444: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB448: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB44C: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	// 82AAB450: 48002659  bl 0x82aadaa8
	ctx.lr = 0x82AAB454;
	sub_82AADAA8(ctx, base);
	// 82AAB454: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB458: 4B71B311  bl 0x821c6768
	ctx.lr = 0x82AAB45C;
	sub_821C6768(ctx, base);
	// 82AAB45C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82AAB460; continue 'dispatch;
            }
            0x82AAB460 => {
    //   block [0x82AAB460..0x82AAB49C)
	// 82AAB460: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AAB464: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB468: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AAB46C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82AAB470: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB474: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB478: 4082FFE8  bne 0x82aab460
	if !ctx.cr[0].eq {
	pc = 0x82AAB460; continue 'dispatch;
	}
	// 82AAB47C: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 82AAB480: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAB484: 40990100  ble cr6, 0x82aab584
	if !ctx.cr[6].gt {
	pc = 0x82AAB584; continue 'dispatch;
	}
	// 82AAB488: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB48C: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82AAB490: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB494: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB498: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	pc = 0x82AAB49C; continue 'dispatch;
            }
            0x82AAB49C => {
    //   block [0x82AAB49C..0x82AAB4A8)
	// 82AAB49C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82AAB4A0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82AAB4A4: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	pc = 0x82AAB4A8; continue 'dispatch;
            }
            0x82AAB4A8 => {
    //   block [0x82AAB4A8..0x82AAB4D0)
	// 82AAB4A8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB4AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAB4B0: 419A0058  beq cr6, 0x82aab508
	if ctx.cr[6].eq {
	pc = 0x82AAB508; continue 'dispatch;
	}
	// 82AAB4B4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAB4B8: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82AAB4BC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAB4C0: 7C895050  subf r4, r9, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AAB4C4: 7C8A1E71  srawi. r10, r4, 3
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[4].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAB4C8: 4081003C  ble 0x82aab504
	if !ctx.cr[0].gt {
	pc = 0x82AAB504; continue 'dispatch;
	}
	// 82AAB4CC: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x82AAB4D0; continue 'dispatch;
            }
            0x82AAB4D0 => {
    //   block [0x82AAB4D0..0x82AAB4E8)
	// 82AAB4D0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB4D4: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AAB4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAB4DC: 409A000C  bne cr6, 0x82aab4e8
	if !ctx.cr[6].eq {
	pc = 0x82AAB4E8; continue 'dispatch;
	}
	// 82AAB4E0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82AAB4E4: 48000008  b 0x82aab4ec
	pc = 0x82AAB4EC; continue 'dispatch;
            }
            0x82AAB4E8 => {
    //   block [0x82AAB4E8..0x82AAB4EC)
	// 82AAB4E8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	pc = 0x82AAB4EC; continue 'dispatch;
            }
            0x82AAB4EC => {
    //   block [0x82AAB4EC..0x82AAB4F8)
	// 82AAB4EC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AAB4F0: 409A0008  bne cr6, 0x82aab4f8
	if !ctx.cr[6].eq {
	pc = 0x82AAB4F8; continue 'dispatch;
	}
	// 82AAB4F4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	pc = 0x82AAB4F8; continue 'dispatch;
            }
            0x82AAB4F8 => {
    //   block [0x82AAB4F8..0x82AAB504)
	// 82AAB4F8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAB4FC: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AAB500: 4082FFD0  bne 0x82aab4d0
	if !ctx.cr[0].eq {
	pc = 0x82AAB4D0; continue 'dispatch;
	}
	pc = 0x82AAB504; continue 'dispatch;
            }
            0x82AAB504 => {
    //   block [0x82AAB504..0x82AAB508)
	// 82AAB504: 7CA82A14  add r5, r8, r5
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	pc = 0x82AAB508; continue 'dispatch;
            }
            0x82AAB508 => {
    //   block [0x82AAB508..0x82AAB51C)
	// 82AAB508: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82AAB50C: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82AAB510: 4082FF98  bne 0x82aab4a8
	if !ctx.cr[0].eq {
	pc = 0x82AAB4A8; continue 'dispatch;
	}
	// 82AAB514: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82AAB518: 93010088  stw r24, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[24].u32 ) };
	pc = 0x82AAB51C; continue 'dispatch;
            }
            0x82AAB51C => {
    //   block [0x82AAB51C..0x82AAB55C)
	// 82AAB51C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AAB520: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB524: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AAB528: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAB52C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB530: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB534: 4082FFE8  bne 0x82aab51c
	if !ctx.cr[0].eq {
	pc = 0x82AAB51C; continue 'dispatch;
	}
	// 82AAB538: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82AAB53C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB540: 4B738911  bl 0x821e3e50
	ctx.lr = 0x82AAB544;
	sub_821E3E50(ctx, base);
	// 82AAB544: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB548: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB54C: 4800255D  bl 0x82aadaa8
	ctx.lr = 0x82AAB550;
	sub_82AADAA8(ctx, base);
	// 82AAB550: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB554: 4B71B215  bl 0x821c6768
	ctx.lr = 0x82AAB558;
	sub_821C6768(ctx, base);
	// 82AAB558: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	pc = 0x82AAB55C; continue 'dispatch;
            }
            0x82AAB55C => {
    //   block [0x82AAB55C..0x82AAB584)
	// 82AAB55C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82AAB560: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB564: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82AAB568: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82AAB56C: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB570: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB574: 4082FFE8  bne 0x82aab55c
	if !ctx.cr[0].eq {
	pc = 0x82AAB55C; continue 'dispatch;
	}
	// 82AAB578: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82AAB57C: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82AAB580: 4198FF1C  blt cr6, 0x82aab49c
	if ctx.cr[6].lt {
	pc = 0x82AAB49C; continue 'dispatch;
	}
	pc = 0x82AAB584; continue 'dispatch;
            }
            0x82AAB584 => {
    //   block [0x82AAB584..0x82AAB5CC)
	// 82AAB584: 397601F4  addi r11, r22, 0x1f4
	ctx.r[11].s64 = ctx.r[22].s64 + 500;
	// 82AAB588: 93970004  stw r28, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AAB58C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAB590: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB594: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAB598: 388A8454  addi r4, r10, -0x7bac
	ctx.r[4].s64 = ctx.r[10].s64 + -31660;
	// 82AAB59C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB5A0: 4B781931  bl 0x8222ced0
	ctx.lr = 0x82AAB5A4;
	sub_8222CED0(ctx, base);
	// 82AAB5A4: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB5A8: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB5AC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB5B0: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB5B4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB5B8: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	// 82AAB5BC: 480024ED  bl 0x82aadaa8
	ctx.lr = 0x82AAB5C0;
	sub_82AADAA8(ctx, base);
	// 82AAB5C0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB5C4: 4B71B1A5  bl 0x821c6768
	ctx.lr = 0x82AAB5C8;
	sub_821C6768(ctx, base);
	// 82AAB5C8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82AAB5CC; continue 'dispatch;
            }
            0x82AAB5CC => {
    //   block [0x82AAB5CC..0x82AAB618)
	// 82AAB5CC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AAB5D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB5D4: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AAB5D8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82AAB5DC: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB5E0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB5E4: 4082FFE8  bne 0x82aab5cc
	if !ctx.cr[0].eq {
	pc = 0x82AAB5CC; continue 'dispatch;
	}
	// 82AAB5E8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAB5EC: 409901D8  ble cr6, 0x82aab7c4
	if !ctx.cr[6].gt {
	pc = 0x82AAB7C4; continue 'dispatch;
	}
	// 82AAB5F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AAB5F4: 9B210072  stb r25, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[25].u8 ) };
	// 82AAB5F8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AAB5FC: 9B210071  stb r25, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[25].u8 ) };
	// 82AAB600: 3BF5000C  addi r31, r21, 0xc
	ctx.r[31].s64 = ctx.r[21].s64 + 12;
	// 82AAB604: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 82AAB608: 3BD50080  addi r30, r21, 0x80
	ctx.r[30].s64 = ctx.r[21].s64 + 128;
	// 82AAB60C: 9B210073  stb r25, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[25].u8 ) };
	// 82AAB610: 3B8B3560  addi r28, r11, 0x3560
	ctx.r[28].s64 = ctx.r[11].s64 + 13664;
	// 82AAB614: 3B6A4A08  addi r27, r10, 0x4a08
	ctx.r[27].s64 = ctx.r[10].s64 + 18952;
	pc = 0x82AAB618; continue 'dispatch;
            }
            0x82AAB618 => {
    //   block [0x82AAB618..0x82AAB664)
	// 82AAB618: 827F0000  lwz r19, 0(r31)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB61C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AAB620: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AAB624: 825E0000  lwz r18, 0(r30)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB628: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82AAB62C: 48092D25  bl 0x82b3e350
	ctx.lr = 0x82AAB630;
	sub_82B3E350(ctx, base);
	// 82AAB630: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAB634: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB638: 4B744C09  bl 0x821f0240
	ctx.lr = 0x82AAB63C;
	sub_821F0240(ctx, base);
	// 82AAB63C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AAB640: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB644: 4B72F37D  bl 0x821da9c0
	ctx.lr = 0x82AAB648;
	sub_821DA9C0(ctx, base);
	// 82AAB648: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AAB64C: 7C9299D6  mullw r4, r18, r19
	ctx.r[4].s32 = ((ctx.r[18].s32 as i64 * ctx.r[19].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82AAB650: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82AAB654: 48092CFD  bl 0x82b3e350
	ctx.lr = 0x82AAB658;
	sub_82B3E350(ctx, base);
	// 82AAB658: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAB65C: 93010078  stw r24, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[24].u32 ) };
	// 82AAB660: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82AAB664; continue 'dispatch;
            }
            0x82AAB664 => {
    //   block [0x82AAB664..0x82AAB694)
	// 82AAB664: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AAB668: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB66C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AAB670: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAB674: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB678: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB67C: 4082FFE8  bne 0x82aab664
	if !ctx.cr[0].eq {
	pc = 0x82AAB664; continue 'dispatch;
	}
	// 82AAB680: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82AAB684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAB688: 419A0028  beq cr6, 0x82aab6b0
	if ctx.cr[6].eq {
	pc = 0x82AAB6B0; continue 'dispatch;
	}
	// 82AAB68C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82AAB690: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82AAB694; continue 'dispatch;
            }
            0x82AAB694 => {
    //   block [0x82AAB694..0x82AAB6B0)
	// 82AAB694: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAB698: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB69C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAB6A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAB6A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB6A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB6AC: 4082FFE8  bne 0x82aab694
	if !ctx.cr[0].eq {
	pc = 0x82AAB694; continue 'dispatch;
	}
	pc = 0x82AAB6B0; continue 'dispatch;
            }
            0x82AAB6B0 => {
    //   block [0x82AAB6B0..0x82AAB6E8)
	// 82AAB6B0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAB6B4: 4B741145  bl 0x821ec7f8
	ctx.lr = 0x82AAB6B8;
	sub_821EC7F8(ctx, base);
	// 82AAB6B8: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AAB6BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB6C0: 4B744B81  bl 0x821f0240
	ctx.lr = 0x82AAB6C4;
	sub_821F0240(ctx, base);
	// 82AAB6C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AAB6C8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB6CC: 4B72F2F5  bl 0x821da9c0
	ctx.lr = 0x82AAB6D0;
	sub_821DA9C0(ctx, base);
	// 82AAB6D0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAB6D4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB6D8: 480023D1  bl 0x82aadaa8
	ctx.lr = 0x82AAB6DC;
	sub_82AADAA8(ctx, base);
	// 82AAB6DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB6E0: 4B71B089  bl 0x821c6768
	ctx.lr = 0x82AAB6E4;
	sub_821C6768(ctx, base);
	// 82AAB6E4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82AAB6E8; continue 'dispatch;
            }
            0x82AAB6E8 => {
    //   block [0x82AAB6E8..0x82AAB714)
	// 82AAB6E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AAB6EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB6F0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AAB6F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AAB6F8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB6FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB700: 4082FFE8  bne 0x82aab6e8
	if !ctx.cr[0].eq {
	pc = 0x82AAB6E8; continue 'dispatch;
	}
	// 82AAB704: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAB708: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 82AAB70C: 4B71B05D  bl 0x821c6768
	ctx.lr = 0x82AAB710;
	sub_821C6768(ctx, base);
	// 82AAB710: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	pc = 0x82AAB714; continue 'dispatch;
            }
            0x82AAB714 => {
    //   block [0x82AAB714..0x82AAB73C)
	// 82AAB714: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82AAB718: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB71C: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82AAB720: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82AAB724: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB728: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB72C: 4082FFE8  bne 0x82aab714
	if !ctx.cr[0].eq {
	pc = 0x82AAB714; continue 'dispatch;
	}
	// 82AAB730: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAB734: 4B71B035  bl 0x821c6768
	ctx.lr = 0x82AAB738;
	sub_821C6768(ctx, base);
	// 82AAB738: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82AAB73C; continue 'dispatch;
            }
            0x82AAB73C => {
    //   block [0x82AAB73C..0x82AAB768)
	// 82AAB73C: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 82AAB740: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB744: 7CA05828  lwarx r5, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 82AAB748: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 82AAB74C: 7CA0592D  stwcx. r5, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB750: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB754: 4082FFE8  bne 0x82aab73c
	if !ctx.cr[0].eq {
	pc = 0x82AAB73C; continue 'dispatch;
	}
	// 82AAB758: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AAB75C: 93010088  stw r24, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[24].u32 ) };
	// 82AAB760: 4B71B009  bl 0x821c6768
	ctx.lr = 0x82AAB764;
	sub_821C6768(ctx, base);
	// 82AAB764: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x82AAB768; continue 'dispatch;
            }
            0x82AAB768 => {
    //   block [0x82AAB768..0x82AAB794)
	// 82AAB768: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAB76C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB770: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAB774: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AAB778: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB77C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB780: 4082FFE8  bne 0x82aab768
	if !ctx.cr[0].eq {
	pc = 0x82AAB768; continue 'dispatch;
	}
	// 82AAB784: 93010090  stw r24, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[24].u32 ) };
	// 82AAB788: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82AAB78C: 4B71AFDD  bl 0x821c6768
	ctx.lr = 0x82AAB790;
	sub_821C6768(ctx, base);
	// 82AAB790: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	pc = 0x82AAB794; continue 'dispatch;
            }
            0x82AAB794 => {
    //   block [0x82AAB794..0x82AAB7C4)
	// 82AAB794: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82AAB798: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB79C: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82AAB7A0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82AAB7A4: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB7A8: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB7AC: 4082FFE8  bne 0x82aab794
	if !ctx.cr[0].eq {
	pc = 0x82AAB794; continue 'dispatch;
	}
	// 82AAB7B0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAB7B4: 93010094  stw r24, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[24].u32 ) };
	// 82AAB7B8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82AAB7BC: 3BDE004C  addi r30, r30, 0x4c
	ctx.r[30].s64 = ctx.r[30].s64 + 76;
	// 82AAB7C0: 4082FE58  bne 0x82aab618
	if !ctx.cr[0].eq {
	pc = 0x82AAB618; continue 'dispatch;
	}
	pc = 0x82AAB7C4; continue 'dispatch;
            }
            0x82AAB7C4 => {
    //   block [0x82AAB7C4..0x82AAB804)
	// 82AAB7C4: 92D70000  stw r22, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 82AAB7C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAB7CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAB7D0: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82AAB7D4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB7D8: 4B7816F9  bl 0x8222ced0
	ctx.lr = 0x82AAB7DC;
	sub_8222CED0(ctx, base);
	// 82AAB7DC: 9B21008A  stb r25, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[25].u8 ) };
	// 82AAB7E0: 9B210089  stb r25, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[25].u8 ) };
	// 82AAB7E4: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82AAB7E8: 9B210088  stb r25, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u8 ) };
	// 82AAB7EC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB7F0: 9B21008B  stb r25, 0x8b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(139 as u32), ctx.r[25].u8 ) };
	// 82AAB7F4: 480022B5  bl 0x82aadaa8
	ctx.lr = 0x82AAB7F8;
	sub_82AADAA8(ctx, base);
	// 82AAB7F8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB7FC: 4B71AF6D  bl 0x821c6768
	ctx.lr = 0x82AAB800;
	sub_821C6768(ctx, base);
	// 82AAB800: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x82AAB804; continue 'dispatch;
            }
            0x82AAB804 => {
    //   block [0x82AAB804..0x82AAB83C)
	// 82AAB804: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAB808: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB80C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAB810: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AAB814: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB818: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB81C: 4082FFE8  bne 0x82aab804
	if !ctx.cr[0].eq {
	pc = 0x82AAB804; continue 'dispatch;
	}
	// 82AAB820: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AAB824: 4BA02E3D  bl 0x824ae660
	ctx.lr = 0x82AAB828;
	sub_824AE660(ctx, base);
	// 82AAB828: 80F50008  lwz r7, 8(r21)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAB82C: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 82AAB830: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82AAB834: 40990028  ble cr6, 0x82aab85c
	if !ctx.cr[6].gt {
	pc = 0x82AAB85C; continue 'dispatch;
	}
	// 82AAB838: 3BD5004C  addi r30, r21, 0x4c
	ctx.r[30].s64 = ctx.r[21].s64 + 76;
	pc = 0x82AAB83C; continue 'dispatch;
            }
            0x82AAB83C => {
    //   block [0x82AAB83C..0x82AAB85C)
	// 82AAB83C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82AAB840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAB844: 480B4D65  bl 0x82b605a8
	ctx.lr = 0x82AAB848;
	sub_82B605A8(ctx, base);
	// 82AAB848: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAB84C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82AAB850: 3BDE004C  addi r30, r30, 0x4c
	ctx.r[30].s64 = ctx.r[30].s64 + 76;
	// 82AAB854: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AAB858: 4198FFE4  blt cr6, 0x82aab83c
	if ctx.cr[6].lt {
	pc = 0x82AAB83C; continue 'dispatch;
	}
	pc = 0x82AAB85C; continue 'dispatch;
            }
            0x82AAB85C => {
    //   block [0x82AAB85C..0x82AAB898)
	// 82AAB85C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAB860: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAB864: 388B8470  addi r4, r11, -0x7b90
	ctx.r[4].s64 = ctx.r[11].s64 + -31632;
	// 82AAB868: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB86C: 4B781665  bl 0x8222ced0
	ctx.lr = 0x82AAB870;
	sub_8222CED0(ctx, base);
	// 82AAB870: 9B21008A  stb r25, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[25].u8 ) };
	// 82AAB874: 9B210089  stb r25, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[25].u8 ) };
	// 82AAB878: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82AAB87C: 9B210088  stb r25, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u8 ) };
	// 82AAB880: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB884: 9B21008B  stb r25, 0x8b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(139 as u32), ctx.r[25].u8 ) };
	// 82AAB888: 48002221  bl 0x82aadaa8
	ctx.lr = 0x82AAB88C;
	sub_82AADAA8(ctx, base);
	// 82AAB88C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB890: 4B71AED9  bl 0x821c6768
	ctx.lr = 0x82AAB894;
	sub_821C6768(ctx, base);
	// 82AAB894: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x82AAB898; continue 'dispatch;
            }
            0x82AAB898 => {
    //   block [0x82AAB898..0x82AAB8E8)
	// 82AAB898: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAB89C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB8A0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAB8A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AAB8A8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAB8AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAB8B0: 4082FFE8  bne 0x82aab898
	if !ctx.cr[0].eq {
	pc = 0x82AAB898; continue 'dispatch;
	}
	// 82AAB8B4: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AAB8B8: 4B773A09  bl 0x8221f2c0
	ctx.lr = 0x82AAB8BC;
	sub_8221F2C0(ctx, base);
	// 82AAB8BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAB8C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAB8C4: 409A002C  bne cr6, 0x82aab8f0
	if !ctx.cr[6].eq {
	pc = 0x82AAB8F0; continue 'dispatch;
	}
	// 82AAB8C8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAB8CC: 814B6F6C  lwz r10, 0x6f6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AAB8D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAB8D4: 419A0014  beq cr6, 0x82aab8e8
	if ctx.cr[6].eq {
	pc = 0x82AAB8E8; continue 'dispatch;
	}
	// 82AAB8D8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AAB8DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AAB8E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAB8E4: 4E800421  bctrl
	ctx.lr = 0x82AAB8E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AAB8E8 => {
    //   block [0x82AAB8E8..0x82AAB8F0)
	// 82AAB8E8: 48216AC1  bl 0x82cc23a8
	ctx.lr = 0x82AAB8EC;
	sub_82CC23A8(ctx, base);
	// 82AAB8EC: 48000008  b 0x82aab8f4
	pc = 0x82AAB8F4; continue 'dispatch;
            }
            0x82AAB8F0 => {
    //   block [0x82AAB8F0..0x82AAB8F4)
	// 82AAB8F0: 931F0000  stw r24, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x82AAB8F4; continue 'dispatch;
            }
            0x82AAB8F4 => {
    //   block [0x82AAB8F4..0x82AAB900)
	// 82AAB8F4: 357F0004  addic. r11, r31, 4
	ctx.xer.ca = (ctx.r[31].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB8F8: 41820008  beq 0x82aab900
	if ctx.cr[0].eq {
	pc = 0x82AAB900; continue 'dispatch;
	}
	// 82AAB8FC: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x82AAB900; continue 'dispatch;
            }
            0x82AAB900 => {
    //   block [0x82AAB900..0x82AAB90C)
	// 82AAB900: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB904: 41820008  beq 0x82aab90c
	if ctx.cr[0].eq {
	pc = 0x82AAB90C; continue 'dispatch;
	}
	// 82AAB908: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x82AAB90C; continue 'dispatch;
            }
            0x82AAB90C => {
    //   block [0x82AAB90C..0x82AAB954)
	// 82AAB90C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AAB910: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AAB914: 9B1F0015  stb r24, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[24].u8 ) };
	// 82AAB918: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 82AAB91C: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 82AAB920: 9BDF0015  stb r30, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 82AAB924: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AAB928: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AAB92C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AAB930: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB934: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AAB938: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AAB93C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AAB940: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82AAB944: 930100A8  stw r24, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[24].u32 ) };
	// 82AAB948: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB94C: 91210080  stw r9, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 82AAB950: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	pc = 0x82AAB954; continue 'dispatch;
            }
            0x82AAB954 => {
    //   block [0x82AAB954..0x82AAB968)
	// 82AAB954: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AAB958: 419A0010  beq cr6, 0x82aab968
	if ctx.cr[6].eq {
	pc = 0x82AAB968; continue 'dispatch;
	}
	// 82AAB95C: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82AAB960: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAB964: 419A0008  beq cr6, 0x82aab96c
	if ctx.cr[6].eq {
	pc = 0x82AAB96C; continue 'dispatch;
	}
	pc = 0x82AAB968; continue 'dispatch;
            }
            0x82AAB968 => {
    //   block [0x82AAB968..0x82AAB96C)
	// 82AAB968: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AAB96C; continue 'dispatch;
            }
            0x82AAB96C => {
    //   block [0x82AAB96C..0x82AAB980)
	// 82AAB96C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AAB970: 419A00E0  beq cr6, 0x82aaba50
	if ctx.cr[6].eq {
	pc = 0x82AABA50; continue 'dispatch;
	}
	// 82AAB974: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AAB978: 409A0008  bne cr6, 0x82aab980
	if !ctx.cr[6].eq {
	pc = 0x82AAB980; continue 'dispatch;
	}
	// 82AAB97C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AAB980; continue 'dispatch;
            }
            0x82AAB980 => {
    //   block [0x82AAB980..0x82AAB990)
	// 82AAB980: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAB984: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAB988: 409A0008  bne cr6, 0x82aab990
	if !ctx.cr[6].eq {
	pc = 0x82AAB990; continue 'dispatch;
	}
	// 82AAB98C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AAB990; continue 'dispatch;
            }
            0x82AAB990 => {
    //   block [0x82AAB990..0x82AAB9A0)
	// 82AAB990: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82AAB994: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAB998: 409A0008  bne cr6, 0x82aab9a0
	if !ctx.cr[6].eq {
	pc = 0x82AAB9A0; continue 'dispatch;
	}
	// 82AAB99C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AAB9A0; continue 'dispatch;
            }
            0x82AAB9A0 => {
    //   block [0x82AAB9A0..0x82AAB9CC)
	// 82AAB9A0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAB9A4: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82AAB9A8: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82AAB9AC: 4B744895  bl 0x821f0240
	ctx.lr = 0x82AAB9B0;
	sub_821F0240(ctx, base);
	// 82AAB9B0: 80C100A4  lwz r6, 0xa4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AAB9B4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AAB9B8: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAB9BC: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAB9C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAB9C4: 409A003C  bne cr6, 0x82aaba00
	if !ctx.cr[6].eq {
	pc = 0x82AABA00; continue 'dispatch;
	}
	// 82AAB9C8: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	pc = 0x82AAB9CC; continue 'dispatch;
            }
            0x82AAB9CC => {
    //   block [0x82AAB9CC..0x82AAB9F0)
	// 82AAB9CC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAB9D0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82AAB9D4: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AAB9D8: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82AAB9DC: 54E507FE  clrlwi r5, r7, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 82AAB9E0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82AAB9E4: 419A000C  beq cr6, 0x82aab9f0
	if ctx.cr[6].eq {
	pc = 0x82AAB9F0; continue 'dispatch;
	}
	// 82AAB9E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB9EC: 48000008  b 0x82aab9f4
	pc = 0x82AAB9F4; continue 'dispatch;
            }
            0x82AAB9F0 => {
    //   block [0x82AAB9F0..0x82AAB9F4)
	// 82AAB9F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AAB9F4; continue 'dispatch;
            }
            0x82AAB9F4 => {
    //   block [0x82AAB9F4..0x82AABA00)
	// 82AAB9F4: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAB9F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AAB9FC: 419AFFD0  beq cr6, 0x82aab9cc
	if ctx.cr[6].eq {
	pc = 0x82AAB9CC; continue 'dispatch;
	}
	pc = 0x82AABA00; continue 'dispatch;
            }
            0x82AABA00 => {
    //   block [0x82AABA00..0x82AABA1C)
	// 82AABA00: 38E10088  addi r7, r1, 0x88
	ctx.r[7].s64 = ctx.r[1].s64 + 136;
	// 82AABA04: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82AABA08: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AABA0C: 4BA3CC7D  bl 0x824e8688
	ctx.lr = 0x82AABA10;
	sub_824E8688(ctx, base);
	// 82AABA10: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82AABA14: 4B71AD55  bl 0x821c6768
	ctx.lr = 0x82AABA18;
	sub_821C6768(ctx, base);
	// 82AABA18: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82AABA1C; continue 'dispatch;
            }
            0x82AABA1C => {
    //   block [0x82AABA1C..0x82AABA50)
	// 82AABA1C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AABA20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABA24: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AABA28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AABA2C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABA30: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABA34: 4082FFE8  bne 0x82aaba1c
	if !ctx.cr[0].eq {
	pc = 0x82AABA1C; continue 'dispatch;
	}
	// 82AABA38: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AABA3C: 9301008C  stw r24, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[24].u32 ) };
	// 82AABA40: 4BAAAE19  bl 0x82556858
	ctx.lr = 0x82AABA44;
	sub_82556858(ctx, base);
	// 82AABA44: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AABA48: 81210080  lwz r9, 0x80(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AABA4C: 4BFFFF08  b 0x82aab954
	pc = 0x82AAB954; continue 'dispatch;
            }
            0x82AABA50 => {
    //   block [0x82AABA50..0x82AABA78)
	// 82AABA50: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AABA54: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82AABA58: 930100C0  stw r24, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[24].u32 ) };
	// 82AABA5C: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82AABA60: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABA64: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82AABA68: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AABA6C: EBE10088  ld r31, 0x88(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82AABA70: FBE100C4  std r31, 0xc4(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[31].u64 ) };
	// 82AABA74: 3BCB4A00  addi r30, r11, 0x4a00
	ctx.r[30].s64 = ctx.r[11].s64 + 18944;
	pc = 0x82AABA78; continue 'dispatch;
            }
            0x82AABA78 => {
    //   block [0x82AABA78..0x82AABA90)
	// 82AABA78: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82AABA7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABA80: 419A0010  beq cr6, 0x82aaba90
	if ctx.cr[6].eq {
	pc = 0x82AABA90; continue 'dispatch;
	}
	// 82AABA84: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82AABA88: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AABA8C: 419A0008  beq cr6, 0x82aaba94
	if ctx.cr[6].eq {
	pc = 0x82AABA94; continue 'dispatch;
	}
	pc = 0x82AABA90; continue 'dispatch;
            }
            0x82AABA90 => {
    //   block [0x82AABA90..0x82AABA94)
	// 82AABA90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AABA94; continue 'dispatch;
            }
            0x82AABA94 => {
    //   block [0x82AABA94..0x82AABACC)
	// 82AABA94: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82AABA98: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AABA9C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AABAA0: 419A01B8  beq cr6, 0x82aabc58
	if ctx.cr[6].eq {
	pc = 0x82AABC58; continue 'dispatch;
	}
	// 82AABAA4: FBE10080  std r31, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u64 ) };
	// 82AABAA8: 9B21008A  stb r25, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[25].u8 ) };
	// 82AABAAC: 9B210089  stb r25, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[25].u8 ) };
	// 82AABAB0: 9B210088  stb r25, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u8 ) };
	// 82AABAB4: 9B21008B  stb r25, 0x8b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(139 as u32), ctx.r[25].u8 ) };
	// 82AABAB8: 48008A41  bl 0x82ab44f8
	ctx.lr = 0x82AABABC;
	sub_82AB44F8(ctx, base);
	// 82AABABC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AABAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABAC4: 409A0008  bne cr6, 0x82aabacc
	if !ctx.cr[6].eq {
	pc = 0x82AABACC; continue 'dispatch;
	}
	// 82AABAC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AABACC; continue 'dispatch;
            }
            0x82AABACC => {
    //   block [0x82AABACC..0x82AABAE0)
	// 82AABACC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AABAD0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AABAD4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AABAD8: 409A0008  bne cr6, 0x82aabae0
	if !ctx.cr[6].eq {
	pc = 0x82AABAE0; continue 'dispatch;
	}
	// 82AABADC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AABAE0; continue 'dispatch;
            }
            0x82AABAE0 => {
    //   block [0x82AABAE0..0x82AABB00)
	// 82AABAE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AABAE4: FBE10080  std r31, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u64 ) };
	// 82AABAE8: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82AABAEC: 48008A0D  bl 0x82ab44f8
	ctx.lr = 0x82AABAF0;
	sub_82AB44F8(ctx, base);
	// 82AABAF0: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AABAF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABAF8: 409A0008  bne cr6, 0x82aabb00
	if !ctx.cr[6].eq {
	pc = 0x82AABB00; continue 'dispatch;
	}
	// 82AABAFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AABB00; continue 'dispatch;
            }
            0x82AABB00 => {
    //   block [0x82AABB00..0x82AABB14)
	// 82AABB00: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AABB04: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AABB08: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AABB0C: 409A0008  bne cr6, 0x82aabb14
	if !ctx.cr[6].eq {
	pc = 0x82AABB14; continue 'dispatch;
	}
	// 82AABB10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AABB14; continue 'dispatch;
            }
            0x82AABB14 => {
    //   block [0x82AABB14..0x82AABB20)
	// 82AABB14: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AABB18: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82AABB1C: 93010070  stw r24, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[24].u32 ) };
	pc = 0x82AABB20; continue 'dispatch;
            }
            0x82AABB20 => {
    //   block [0x82AABB20..0x82AABB68)
	// 82AABB20: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AABB24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABB28: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AABB2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AABB30: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABB34: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABB38: 4082FFE8  bne 0x82aabb20
	if !ctx.cr[0].eq {
	pc = 0x82AABB20; continue 'dispatch;
	}
	// 82AABB3C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82AABB40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABB44: 4B73830D  bl 0x821e3e50
	ctx.lr = 0x82AABB48;
	sub_821E3E50(ctx, base);
	// 82AABB48: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AABB4C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AABB50: 4B7446F1  bl 0x821f0240
	ctx.lr = 0x82AABB54;
	sub_821F0240(ctx, base);
	// 82AABB54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AABB58: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AABB5C: 4B72EE65  bl 0x821da9c0
	ctx.lr = 0x82AABB60;
	sub_821DA9C0(ctx, base);
	// 82AABB60: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82AABB64: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	pc = 0x82AABB68; continue 'dispatch;
            }
            0x82AABB68 => {
    //   block [0x82AABB68..0x82AABB98)
	// 82AABB68: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82AABB6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABB70: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82AABB74: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82AABB78: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABB7C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABB80: 4082FFE8  bne 0x82aabb68
	if !ctx.cr[0].eq {
	pc = 0x82AABB68; continue 'dispatch;
	}
	// 82AABB84: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AABB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABB8C: 419A0028  beq cr6, 0x82aabbb4
	if ctx.cr[6].eq {
	pc = 0x82AABBB4; continue 'dispatch;
	}
	// 82AABB90: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82AABB94: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82AABB98; continue 'dispatch;
            }
            0x82AABB98 => {
    //   block [0x82AABB98..0x82AABBB4)
	// 82AABB98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AABB9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABBA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AABBA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AABBA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABBAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABBB0: 4082FFE8  bne 0x82aabb98
	if !ctx.cr[0].eq {
	pc = 0x82AABB98; continue 'dispatch;
	}
	pc = 0x82AABBB4; continue 'dispatch;
            }
            0x82AABBB4 => {
    //   block [0x82AABBB4..0x82AABBD8)
	// 82AABBB4: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82AABBB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AABBBC: 4B740C3D  bl 0x821ec7f8
	ctx.lr = 0x82AABBC0;
	sub_821EC7F8(ctx, base);
	// 82AABBC0: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82AABBC4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AABBC8: 48001EE1  bl 0x82aadaa8
	ctx.lr = 0x82AABBCC;
	sub_82AADAA8(ctx, base);
	// 82AABBCC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AABBD0: 4B71AB99  bl 0x821c6768
	ctx.lr = 0x82AABBD4;
	sub_821C6768(ctx, base);
	// 82AABBD4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82AABBD8; continue 'dispatch;
            }
            0x82AABBD8 => {
    //   block [0x82AABBD8..0x82AABC00)
	// 82AABBD8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AABBDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABBE0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AABBE4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AABBE8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABBEC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABBF0: 4082FFE8  bne 0x82aabbd8
	if !ctx.cr[0].eq {
	pc = 0x82AABBD8; continue 'dispatch;
	}
	// 82AABBF4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AABBF8: 4B71AB71  bl 0x821c6768
	ctx.lr = 0x82AABBFC;
	sub_821C6768(ctx, base);
	// 82AABBFC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	pc = 0x82AABC00; continue 'dispatch;
            }
            0x82AABC00 => {
    //   block [0x82AABC00..0x82AABC2C)
	// 82AABC00: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82AABC04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABC08: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82AABC0C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82AABC10: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABC14: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABC18: 4082FFE8  bne 0x82aabc00
	if !ctx.cr[0].eq {
	pc = 0x82AABC00; continue 'dispatch;
	}
	// 82AABC1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABC20: 93010078  stw r24, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[24].u32 ) };
	// 82AABC24: 4B71AB45  bl 0x821c6768
	ctx.lr = 0x82AABC28;
	sub_821C6768(ctx, base);
	// 82AABC28: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82AABC2C; continue 'dispatch;
            }
            0x82AABC2C => {
    //   block [0x82AABC2C..0x82AABC58)
	// 82AABC2C: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 82AABC30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABC34: 7CA05828  lwarx r5, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 82AABC38: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 82AABC3C: 7CA0592D  stwcx. r5, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABC40: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABC44: 4082FFE8  bne 0x82aabc2c
	if !ctx.cr[0].eq {
	pc = 0x82AABC2C; continue 'dispatch;
	}
	// 82AABC48: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 82AABC4C: 480088AD  bl 0x82ab44f8
	ctx.lr = 0x82AABC50;
	sub_82AB44F8(ctx, base);
	// 82AABC50: EBE100C4  ld r31, 0xc4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) };
	// 82AABC54: 4BFFFE24  b 0x82aaba78
	pc = 0x82AABA78; continue 'dispatch;
            }
            0x82AABC58 => {
    //   block [0x82AABC58..0x82AABCE4)
	// 82AABC58: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AABC5C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82AABC60: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82AABC64: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82AABC68: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82AABC6C: 91210080  stw r9, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 82AABC70: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABC74: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82AABC78: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 82AABC7C: E8C10088  ld r6, 0x88(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82AABC80: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82AABC84: 48002375  bl 0x82aadff8
	ctx.lr = 0x82AABC88;
	sub_82AADFF8(ctx, base);
	// 82AABC88: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AABC8C: 4B7700AD  bl 0x8221bd38
	ctx.lr = 0x82AABC90;
	sub_8221BD38(ctx, base);
	// 82AABC90: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AABC94: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 82AABC98: 930100A4  stw r24, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[24].u32 ) };
	// 82AABC9C: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 82AABCA0: 930100A8  stw r24, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[24].u32 ) };
	// 82AABCA4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82AABCA8: 90C10080  stw r6, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 82AABCAC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AABCB0: 90E10088  stw r7, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 82AABCB4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABCB8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82AABCBC: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82AABCC0: E8C10088  ld r6, 0x88(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82AABCC4: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82AABCC8: 480081C1  bl 0x82ab3e88
	ctx.lr = 0x82AABCCC;
	sub_82AB3E88(ctx, base);
	// 82AABCCC: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AABCD0: 4B770069  bl 0x8221bd38
	ctx.lr = 0x82AABCD4;
	sub_8221BD38(ctx, base);
	// 82AABCD4: 930100B4  stw r24, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[24].u32 ) };
	// 82AABCD8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AABCDC: 930100B8  stw r24, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[24].u32 ) };
	// 82AABCE0: 4B71AA89  bl 0x821c6768
	ctx.lr = 0x82AABCE4;
	sub_821C6768(ctx, base);
	pc = 0x82AABCE4; continue 'dispatch;
            }
            0x82AABCE4 => {
    //   block [0x82AABCE4..0x82AABD08)
	// 82AABCE4: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 82AABCE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABCEC: 7C80D028  lwarx r4, 0, r26
	// lwarx
	let ea = ctx.r[26].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 82AABCF0: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 82AABCF4: 7C80D12D  stwcx. r4, 0, r26
	// stwcx.
	let addr = ctx.r[26].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABCF8: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABCFC: 4082FFE8  bne 0x82aabce4
	if !ctx.cr[0].eq {
	pc = 0x82AABCE4; continue 'dispatch;
	}
	// 82AABD00: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82AABD04: 481FD72C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABD08 size=220
    let mut pc: u32 = 0x82AABD08;
    'dispatch: loop {
        match pc {
            0x82AABD08 => {
    //   block [0x82AABD08..0x82AABDE4)
	// 82AABD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABD0C: 481FD701  bl 0x82ca940c
	ctx.lr = 0x82AABD10;
	sub_82CA93D0(ctx, base);
	// 82AABD10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABD14: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82AABD18: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AABD1C: 3BCBAA88  addi r30, r11, -0x5578
	ctx.r[30].s64 = ctx.r[11].s64 + -21880;
	// 82AABD20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AABD24: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 82AABD28: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 82AABD2C: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82AABD30: 9BE10053  stb r31, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[31].u8 ) };
	// 82AABD34: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AABD38: 4B8A2F89  bl 0x8234ecc0
	ctx.lr = 0x82AABD3C;
	sub_8234ECC0(ctx, base);
	// 82AABD3C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AABD40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AABD44: 388A8488  addi r4, r10, -0x7b78
	ctx.r[4].s64 = ctx.r[10].s64 + -31608;
	// 82AABD48: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AABD4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABD50: 4B781181  bl 0x8222ced0
	ctx.lr = 0x82AABD54;
	sub_8222CED0(ctx, base);
	// 82AABD54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AABD58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABD5C: 4B740A9D  bl 0x821ec7f8
	ctx.lr = 0x82AABD60;
	sub_821EC7F8(ctx, base);
	// 82AABD60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AABD64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABD68: 48001D41  bl 0x82aadaa8
	ctx.lr = 0x82AABD6C;
	sub_82AADAA8(ctx, base);
	// 82AABD6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABD70: 4B769069  bl 0x82214dd8
	ctx.lr = 0x82AABD74;
	sub_82214DD8(ctx, base);
	// 82AABD74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AABD78: 4B769061  bl 0x82214dd8
	ctx.lr = 0x82AABD7C;
	sub_82214DD8(ctx, base);
	// 82AABD7C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AABD80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AABD84: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AABD88: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 82AABD8C: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 82AABD90: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82AABD94: 9BE10053  stb r31, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[31].u8 ) };
	// 82AABD98: 480925B9  bl 0x82b3e350
	ctx.lr = 0x82AABD9C;
	sub_82B3E350(ctx, base);
	// 82AABD9C: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AABDA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AABDA4: 38898498  addi r4, r9, -0x7b68
	ctx.r[4].s64 = ctx.r[9].s64 + -31592;
	// 82AABDA8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AABDAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABDB0: 4B781121  bl 0x8222ced0
	ctx.lr = 0x82AABDB4;
	sub_8222CED0(ctx, base);
	// 82AABDB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AABDB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABDBC: 4B740A3D  bl 0x821ec7f8
	ctx.lr = 0x82AABDC0;
	sub_821EC7F8(ctx, base);
	// 82AABDC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AABDC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABDC8: 48001CE1  bl 0x82aadaa8
	ctx.lr = 0x82AABDCC;
	sub_82AADAA8(ctx, base);
	// 82AABDCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABDD0: 4B769009  bl 0x82214dd8
	ctx.lr = 0x82AABDD4;
	sub_82214DD8(ctx, base);
	// 82AABDD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AABDD8: 4B769001  bl 0x82214dd8
	ctx.lr = 0x82AABDDC;
	sub_82214DD8(ctx, base);
	// 82AABDDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AABDE0: 481FD67C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABDE8 size=672
    let mut pc: u32 = 0x82AABDE8;
    'dispatch: loop {
        match pc {
            0x82AABDE8 => {
    //   block [0x82AABDE8..0x82AABE0C)
	// 82AABDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABDEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AABDF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AABDF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AABDF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABDFC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AABE00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AABE04: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82AABE08: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	pc = 0x82AABE0C; continue 'dispatch;
            }
            0x82AABE0C => {
    //   block [0x82AABE0C..0x82AAC088)
	// 82AABE0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AABE10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABE14: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AABE18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AABE1C: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AABE20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AABE24: 4082FFE8  bne 0x82aabe0c
	if !ctx.cr[0].eq {
	pc = 0x82AABE0C; continue 'dispatch;
	}
	// 82AABE28: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82AABE2C: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 82AABE30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABE34: 388584AC  addi r4, r5, -0x7b54
	ctx.r[4].s64 = ctx.r[5].s64 + -31572;
	// 82AABE38: C8260D38  lfd f1, 0xd38(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(3384 as u32) ) };
	// 82AABE3C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AABE40: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AABE44: 4B73800D  bl 0x821e3e50
	ctx.lr = 0x82AABE48;
	sub_821E3E50(ctx, base);
	// 82AABE48: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AABE4C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABE50: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABE54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABE58: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABE5C: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABE60: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABE64: 48001C45  bl 0x82aadaa8
	ctx.lr = 0x82AABE68;
	sub_82AADAA8(ctx, base);
	// 82AABE68: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AABE6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AABE70: 388484D0  addi r4, r4, -0x7b30
	ctx.r[4].s64 = ctx.r[4].s64 + -31536;
	// 82AABE74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABE78: 4B737FD9  bl 0x821e3e50
	ctx.lr = 0x82AABE7C;
	sub_821E3E50(ctx, base);
	// 82AABE7C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABE80: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABE84: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABE88: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABE8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABE90: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABE94: 48001C15  bl 0x82aadaa8
	ctx.lr = 0x82AABE98;
	sub_82AADAA8(ctx, base);
	// 82AABE98: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AABE9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABEA0: 3BCB84F4  addi r30, r11, -0x7b0c
	ctx.r[30].s64 = ctx.r[11].s64 + -31500;
	// 82AABEA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AABEA8: 4B737FA9  bl 0x821e3e50
	ctx.lr = 0x82AABEAC;
	sub_821E3E50(ctx, base);
	// 82AABEAC: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABEB0: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABEB4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABEB8: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABEBC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABEC0: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABEC4: 48001BE5  bl 0x82aadaa8
	ctx.lr = 0x82AABEC8;
	sub_82AADAA8(ctx, base);
	// 82AABEC8: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AABECC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AABED0: 388A8510  addi r4, r10, -0x7af0
	ctx.r[4].s64 = ctx.r[10].s64 + -31472;
	// 82AABED4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABED8: 4B737F79  bl 0x821e3e50
	ctx.lr = 0x82AABEDC;
	sub_821E3E50(ctx, base);
	// 82AABEDC: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABEE0: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABEE4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABEE8: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABEEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABEF0: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABEF4: 48001BB5  bl 0x82aadaa8
	ctx.lr = 0x82AABEF8;
	sub_82AADAA8(ctx, base);
	// 82AABEF8: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AABEFC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AABF00: 38898530  addi r4, r9, -0x7ad0
	ctx.r[4].s64 = ctx.r[9].s64 + -31440;
	// 82AABF04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABF08: 4B737F49  bl 0x821e3e50
	ctx.lr = 0x82AABF0C;
	sub_821E3E50(ctx, base);
	// 82AABF0C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABF10: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABF14: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABF18: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABF1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABF20: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABF24: 48001B85  bl 0x82aadaa8
	ctx.lr = 0x82AABF28;
	sub_82AADAA8(ctx, base);
	// 82AABF28: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AABF2C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AABF30: 38888550  addi r4, r8, -0x7ab0
	ctx.r[4].s64 = ctx.r[8].s64 + -31408;
	// 82AABF34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABF38: 4B737F19  bl 0x821e3e50
	ctx.lr = 0x82AABF3C;
	sub_821E3E50(ctx, base);
	// 82AABF3C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABF40: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABF44: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABF48: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABF4C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABF50: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABF54: 48001B55  bl 0x82aadaa8
	ctx.lr = 0x82AABF58;
	sub_82AADAA8(ctx, base);
	// 82AABF58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AABF5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABF60: 4B737EF1  bl 0x821e3e50
	ctx.lr = 0x82AABF64;
	sub_821E3E50(ctx, base);
	// 82AABF64: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABF68: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABF6C: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABF70: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABF74: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABF78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABF7C: 48001B2D  bl 0x82aadaa8
	ctx.lr = 0x82AABF80;
	sub_82AADAA8(ctx, base);
	// 82AABF80: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AABF84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AABF88: 38878570  addi r4, r7, -0x7a90
	ctx.r[4].s64 = ctx.r[7].s64 + -31376;
	// 82AABF8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABF90: 4B737EC1  bl 0x821e3e50
	ctx.lr = 0x82AABF94;
	sub_821E3E50(ctx, base);
	// 82AABF94: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABF98: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABF9C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABFA0: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABFA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABFA8: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABFAC: 48001AFD  bl 0x82aadaa8
	ctx.lr = 0x82AABFB0;
	sub_82AADAA8(ctx, base);
	// 82AABFB0: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AABFB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AABFB8: 3886858C  addi r4, r6, -0x7a74
	ctx.r[4].s64 = ctx.r[6].s64 + -31348;
	// 82AABFBC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABFC0: 4B737E91  bl 0x821e3e50
	ctx.lr = 0x82AABFC4;
	sub_821E3E50(ctx, base);
	// 82AABFC4: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABFC8: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABFCC: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AABFD0: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AABFD4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABFD8: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AABFDC: 48001ACD  bl 0x82aadaa8
	ctx.lr = 0x82AABFE0;
	sub_82AADAA8(ctx, base);
	// 82AABFE0: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AABFE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AABFE8: 388485A8  addi r4, r4, -0x7a58
	ctx.r[4].s64 = ctx.r[4].s64 + -31320;
	// 82AABFEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AABFF0: 4B737E61  bl 0x821e3e50
	ctx.lr = 0x82AABFF4;
	sub_821E3E50(ctx, base);
	// 82AABFF4: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AABFF8: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AABFFC: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC000: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC004: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC008: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC00C: 48001A9D  bl 0x82aadaa8
	ctx.lr = 0x82AAC010;
	sub_82AADAA8(ctx, base);
	// 82AAC010: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAC014: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC018: 4B737E39  bl 0x821e3e50
	ctx.lr = 0x82AAC01C;
	sub_821E3E50(ctx, base);
	// 82AAC01C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC020: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC024: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC028: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC02C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC030: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC034: 48001A75  bl 0x82aadaa8
	ctx.lr = 0x82AAC038;
	sub_82AADAA8(ctx, base);
	// 82AAC038: 3C608210  lis r3, -0x7df0
	ctx.r[3].s64 = -2112880640;
	// 82AAC03C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAC040: 388385C4  addi r4, r3, -0x7a3c
	ctx.r[4].s64 = ctx.r[3].s64 + -31292;
	// 82AAC044: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC048: 4B737E09  bl 0x821e3e50
	ctx.lr = 0x82AAC04C;
	sub_821E3E50(ctx, base);
	// 82AAC04C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC050: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC054: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC058: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC05C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC060: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC064: 48001A45  bl 0x82aadaa8
	ctx.lr = 0x82AAC068;
	sub_82AADAA8(ctx, base);
	// 82AAC068: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC06C: 4B768D6D  bl 0x82214dd8
	ctx.lr = 0x82AAC070;
	sub_82214DD8(ctx, base);
	// 82AAC070: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAC074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAC078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAC07C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAC080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAC084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAC088 size=380
    let mut pc: u32 = 0x82AAC088;
    'dispatch: loop {
        match pc {
            0x82AAC088 => {
    //   block [0x82AAC088..0x82AAC0AC)
	// 82AAC088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC08C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAC090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAC094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAC098: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC09C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAC0A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AAC0A4: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82AAC0A8: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	pc = 0x82AAC0AC; continue 'dispatch;
            }
            0x82AAC0AC => {
    //   block [0x82AAC0AC..0x82AAC204)
	// 82AAC0AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC0B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC0B4: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC0B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC0BC: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC0C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC0C4: 4082FFE8  bne 0x82aac0ac
	if !ctx.cr[0].eq {
	pc = 0x82AAC0AC; continue 'dispatch;
	}
	// 82AAC0C8: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAC0CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAC0D0: 388685DC  addi r4, r6, -0x7a24
	ctx.r[4].s64 = ctx.r[6].s64 + -31268;
	// 82AAC0D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC0D8: 4B737D79  bl 0x821e3e50
	ctx.lr = 0x82AAC0DC;
	sub_821E3E50(ctx, base);
	// 82AAC0DC: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AAC0E0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC0E4: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC0E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC0EC: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC0F0: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC0F4: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC0F8: 480019B1  bl 0x82aadaa8
	ctx.lr = 0x82AAC0FC;
	sub_82AADAA8(ctx, base);
	// 82AAC0FC: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAC100: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAC104: 38848600  addi r4, r4, -0x7a00
	ctx.r[4].s64 = ctx.r[4].s64 + -31232;
	// 82AAC108: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC10C: 4B737D45  bl 0x821e3e50
	ctx.lr = 0x82AAC110;
	sub_821E3E50(ctx, base);
	// 82AAC110: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC114: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC118: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC11C: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC120: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC124: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC128: 48001981  bl 0x82aadaa8
	ctx.lr = 0x82AAC12C;
	sub_82AADAA8(ctx, base);
	// 82AAC12C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAC130: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC134: 3BCB84F4  addi r30, r11, -0x7b0c
	ctx.r[30].s64 = ctx.r[11].s64 + -31500;
	// 82AAC138: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAC13C: 4B737D15  bl 0x821e3e50
	ctx.lr = 0x82AAC140;
	sub_821E3E50(ctx, base);
	// 82AAC140: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC144: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC148: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC14C: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC150: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC154: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC158: 48001951  bl 0x82aadaa8
	ctx.lr = 0x82AAC15C;
	sub_82AADAA8(ctx, base);
	// 82AAC15C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAC160: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAC164: 388A8620  addi r4, r10, -0x79e0
	ctx.r[4].s64 = ctx.r[10].s64 + -31200;
	// 82AAC168: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC16C: 4B737CE5  bl 0x821e3e50
	ctx.lr = 0x82AAC170;
	sub_821E3E50(ctx, base);
	// 82AAC170: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC174: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC178: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC17C: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC180: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC184: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC188: 48001921  bl 0x82aadaa8
	ctx.lr = 0x82AAC18C;
	sub_82AADAA8(ctx, base);
	// 82AAC18C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAC190: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC194: 4B737CBD  bl 0x821e3e50
	ctx.lr = 0x82AAC198;
	sub_821E3E50(ctx, base);
	// 82AAC198: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC19C: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC1A0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC1A4: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC1A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC1AC: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC1B0: 480018F9  bl 0x82aadaa8
	ctx.lr = 0x82AAC1B4;
	sub_82AADAA8(ctx, base);
	// 82AAC1B4: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AAC1B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAC1BC: 3889863C  addi r4, r9, -0x79c4
	ctx.r[4].s64 = ctx.r[9].s64 + -31172;
	// 82AAC1C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC1C4: 4B737C8D  bl 0x821e3e50
	ctx.lr = 0x82AAC1C8;
	sub_821E3E50(ctx, base);
	// 82AAC1C8: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC1CC: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC1D0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC1D4: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC1D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC1DC: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC1E0: 480018C9  bl 0x82aadaa8
	ctx.lr = 0x82AAC1E4;
	sub_82AADAA8(ctx, base);
	// 82AAC1E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC1E8: 4B768BF1  bl 0x82214dd8
	ctx.lr = 0x82AAC1EC;
	sub_82214DD8(ctx, base);
	// 82AAC1EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAC1F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAC1F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAC1F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAC1FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAC200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAC208 size=836
    let mut pc: u32 = 0x82AAC208;
    'dispatch: loop {
        match pc {
            0x82AAC208 => {
    //   block [0x82AAC208..0x82AAC22C)
	// 82AAC208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAC210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAC214: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82AAC218: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC21C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAC220: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AAC224: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82AAC228: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	pc = 0x82AAC22C; continue 'dispatch;
            }
            0x82AAC22C => {
    //   block [0x82AAC22C..0x82AAC54C)
	// 82AAC22C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC230: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC234: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC238: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC23C: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC240: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC244: 4082FFE8  bne 0x82aac22c
	if !ctx.cr[0].eq {
	pc = 0x82AAC22C; continue 'dispatch;
	}
	// 82AAC248: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82AAC24C: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 82AAC250: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC254: 3885865C  addi r4, r5, -0x79a4
	ctx.r[4].s64 = ctx.r[5].s64 + -31140;
	// 82AAC258: CBE60D38  lfd f31, 0xd38(r6)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(3384 as u32) ) };
	// 82AAC25C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC260: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC264: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC268: 4B737BE9  bl 0x821e3e50
	ctx.lr = 0x82AAC26C;
	sub_821E3E50(ctx, base);
	// 82AAC26C: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AAC270: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC274: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC278: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC27C: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC280: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC284: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC288: 48001821  bl 0x82aadaa8
	ctx.lr = 0x82AAC28C;
	sub_82AADAA8(ctx, base);
	// 82AAC28C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC290: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC294: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC298: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAC29C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC2A0: 38848680  addi r4, r4, -0x7980
	ctx.r[4].s64 = ctx.r[4].s64 + -31104;
	// 82AAC2A4: 4B737BAD  bl 0x821e3e50
	ctx.lr = 0x82AAC2A8;
	sub_821E3E50(ctx, base);
	// 82AAC2A8: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC2AC: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC2B0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC2B4: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC2B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC2BC: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC2C0: 480017E9  bl 0x82aadaa8
	ctx.lr = 0x82AAC2C4;
	sub_82AADAA8(ctx, base);
	// 82AAC2C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC2C8: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC2CC: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC2D0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAC2D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC2D8: 388B8698  addi r4, r11, -0x7968
	ctx.r[4].s64 = ctx.r[11].s64 + -31080;
	// 82AAC2DC: 4B737B75  bl 0x821e3e50
	ctx.lr = 0x82AAC2E0;
	sub_821E3E50(ctx, base);
	// 82AAC2E0: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC2E4: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC2E8: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC2EC: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC2F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC2F4: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC2F8: 480017B1  bl 0x82aadaa8
	ctx.lr = 0x82AAC2FC;
	sub_82AADAA8(ctx, base);
	// 82AAC2FC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC300: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC304: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC308: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAC30C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC310: 388A86B8  addi r4, r10, -0x7948
	ctx.r[4].s64 = ctx.r[10].s64 + -31048;
	// 82AAC314: 4B737B3D  bl 0x821e3e50
	ctx.lr = 0x82AAC318;
	sub_821E3E50(ctx, base);
	// 82AAC318: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC31C: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC320: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC324: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC328: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC32C: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC330: 48001779  bl 0x82aadaa8
	ctx.lr = 0x82AAC334;
	sub_82AADAA8(ctx, base);
	// 82AAC334: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC338: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC33C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC340: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AAC344: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC348: 388986D4  addi r4, r9, -0x792c
	ctx.r[4].s64 = ctx.r[9].s64 + -31020;
	// 82AAC34C: 4B737B05  bl 0x821e3e50
	ctx.lr = 0x82AAC350;
	sub_821E3E50(ctx, base);
	// 82AAC350: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC354: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC358: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC35C: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC360: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC364: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC368: 48001741  bl 0x82aadaa8
	ctx.lr = 0x82AAC36C;
	sub_82AADAA8(ctx, base);
	// 82AAC36C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC370: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC374: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC378: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAC37C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC380: 388886F0  addi r4, r8, -0x7910
	ctx.r[4].s64 = ctx.r[8].s64 + -30992;
	// 82AAC384: 4B737ACD  bl 0x821e3e50
	ctx.lr = 0x82AAC388;
	sub_821E3E50(ctx, base);
	// 82AAC388: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC38C: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC390: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC394: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC398: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC39C: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC3A0: 48001709  bl 0x82aadaa8
	ctx.lr = 0x82AAC3A4;
	sub_82AADAA8(ctx, base);
	// 82AAC3A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC3A8: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC3AC: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AAC3B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC3B4: 38878714  addi r4, r7, -0x78ec
	ctx.r[4].s64 = ctx.r[7].s64 + -30956;
	// 82AAC3B8: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC3BC: 4B737A95  bl 0x821e3e50
	ctx.lr = 0x82AAC3C0;
	sub_821E3E50(ctx, base);
	// 82AAC3C0: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC3C4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC3C8: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC3CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC3D0: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC3D4: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC3D8: 480016D1  bl 0x82aadaa8
	ctx.lr = 0x82AAC3DC;
	sub_82AADAA8(ctx, base);
	// 82AAC3DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC3E0: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC3E4: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAC3E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC3EC: 38868738  addi r4, r6, -0x78c8
	ctx.r[4].s64 = ctx.r[6].s64 + -30920;
	// 82AAC3F0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC3F4: 4B737A5D  bl 0x821e3e50
	ctx.lr = 0x82AAC3F8;
	sub_821E3E50(ctx, base);
	// 82AAC3F8: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC3FC: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC400: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC404: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC408: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC40C: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC410: 48001699  bl 0x82aadaa8
	ctx.lr = 0x82AAC414;
	sub_82AADAA8(ctx, base);
	// 82AAC414: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC418: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC41C: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAC420: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC424: 38848754  addi r4, r4, -0x78ac
	ctx.r[4].s64 = ctx.r[4].s64 + -30892;
	// 82AAC428: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC42C: 4B737A25  bl 0x821e3e50
	ctx.lr = 0x82AAC430;
	sub_821E3E50(ctx, base);
	// 82AAC430: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC434: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC438: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC43C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC440: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC444: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC448: 48001661  bl 0x82aadaa8
	ctx.lr = 0x82AAC44C;
	sub_82AADAA8(ctx, base);
	// 82AAC44C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC450: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC454: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC458: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAC45C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC460: 388B876C  addi r4, r11, -0x7894
	ctx.r[4].s64 = ctx.r[11].s64 + -30868;
	// 82AAC464: 4B7379ED  bl 0x821e3e50
	ctx.lr = 0x82AAC468;
	sub_821E3E50(ctx, base);
	// 82AAC468: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC46C: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC470: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC474: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC478: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC47C: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC480: 48001629  bl 0x82aadaa8
	ctx.lr = 0x82AAC484;
	sub_82AADAA8(ctx, base);
	// 82AAC484: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC488: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC48C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC490: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAC494: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC498: 388A8788  addi r4, r10, -0x7878
	ctx.r[4].s64 = ctx.r[10].s64 + -30840;
	// 82AAC49C: 4B7379B5  bl 0x821e3e50
	ctx.lr = 0x82AAC4A0;
	sub_821E3E50(ctx, base);
	// 82AAC4A0: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC4A4: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC4A8: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC4AC: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC4B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC4B4: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC4B8: 480015F1  bl 0x82aadaa8
	ctx.lr = 0x82AAC4BC;
	sub_82AADAA8(ctx, base);
	// 82AAC4BC: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AAC4C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC4C4: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC4C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC4CC: 388987A4  addi r4, r9, -0x785c
	ctx.r[4].s64 = ctx.r[9].s64 + -30812;
	// 82AAC4D0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC4D4: 4B73797D  bl 0x821e3e50
	ctx.lr = 0x82AAC4D8;
	sub_821E3E50(ctx, base);
	// 82AAC4D8: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC4DC: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC4E0: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC4E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC4E8: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC4EC: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC4F0: 480015B9  bl 0x82aadaa8
	ctx.lr = 0x82AAC4F4;
	sub_82AADAA8(ctx, base);
	// 82AAC4F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC4F8: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC4FC: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC500: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAC504: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC508: 388887C4  addi r4, r8, -0x783c
	ctx.r[4].s64 = ctx.r[8].s64 + -30780;
	// 82AAC50C: 4B737945  bl 0x821e3e50
	ctx.lr = 0x82AAC510;
	sub_821E3E50(ctx, base);
	// 82AAC510: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAC514: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAC518: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAC51C: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAC520: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC524: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAC528: 48001581  bl 0x82aadaa8
	ctx.lr = 0x82AAC52C;
	sub_82AADAA8(ctx, base);
	// 82AAC52C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC530: 4B7688A9  bl 0x82214dd8
	ctx.lr = 0x82AAC534;
	sub_82214DD8(ctx, base);
	// 82AAC534: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAC538: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAC53C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAC540: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAC544: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAC548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAC550 size=144
    let mut pc: u32 = 0x82AAC550;
    'dispatch: loop {
        match pc {
            0x82AAC550 => {
    //   block [0x82AAC550..0x82AAC56C)
	// 82AAC550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAC558: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC55C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAC560: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AAC564: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82AAC568: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	pc = 0x82AAC56C; continue 'dispatch;
            }
            0x82AAC56C => {
    //   block [0x82AAC56C..0x82AAC5E0)
	// 82AAC56C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC570: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC574: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC578: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC57C: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC580: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC584: 4082FFE8  bne 0x82aac56c
	if !ctx.cr[0].eq {
	pc = 0x82AAC56C; continue 'dispatch;
	}
	// 82AAC588: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC58C: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAC590: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAC594: 388687DC  addi r4, r6, -0x7824
	ctx.r[4].s64 = ctx.r[6].s64 + -30756;
	// 82AAC598: 81650014  lwz r11, 0x14(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAC59C: 814B0D50  lwz r10, 0xd50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3408 as u32) ) } as u64;
	// 82AAC5A0: 80AA00F0  lwz r5, 0xf0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AAC5A4: 4B7378AD  bl 0x821e3e50
	ctx.lr = 0x82AAC5A8;
	sub_821E3E50(ctx, base);
	// 82AAC5A8: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82AAC5AC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAC5B0: 99610072  stb r11, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[11].u8 ) };
	// 82AAC5B4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAC5B8: 99610071  stb r11, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[11].u8 ) };
	// 82AAC5BC: 99610070  stb r11, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82AAC5C0: 99610073  stb r11, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[11].u8 ) };
	// 82AAC5C4: 480014E5  bl 0x82aadaa8
	ctx.lr = 0x82AAC5C8;
	sub_82AADAA8(ctx, base);
	// 82AAC5C8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAC5CC: 4B76880D  bl 0x82214dd8
	ctx.lr = 0x82AAC5D0;
	sub_82214DD8(ctx, base);
	// 82AAC5D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAC5D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAC5D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAC5DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAC5E0 size=164
    let mut pc: u32 = 0x82AAC5E0;
    'dispatch: loop {
        match pc {
            0x82AAC5E0 => {
    //   block [0x82AAC5E0..0x82AAC648)
	// 82AAC5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC5E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAC5E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAC5EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC5F0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAC5F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAC5F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAC5FC: 388B87FC  addi r4, r11, -0x7804
	ctx.r[4].s64 = ctx.r[11].s64 + -30724;
	// 82AAC600: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC604: 4B7808CD  bl 0x8222ced0
	ctx.lr = 0x82AAC608;
	sub_8222CED0(ctx, base);
	// 82AAC608: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82AAC60C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC610: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AAC614: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC618: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82AAC61C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82AAC620: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82AAC624: 48001485  bl 0x82aadaa8
	ctx.lr = 0x82AAC628;
	sub_82AADAA8(ctx, base);
	// 82AAC628: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC62C: 4B7687AD  bl 0x82214dd8
	ctx.lr = 0x82AAC630;
	sub_82214DD8(ctx, base);
	// 82AAC630: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82AAC634: 816A5730  lwz r11, 0x5730(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22320 as u32) ) } as u64;
	// 82AAC638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC63C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AAC640: 419A0024  beq cr6, 0x82aac664
	if ctx.cr[6].eq {
	pc = 0x82AAC664; continue 'dispatch;
	}
	// 82AAC644: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82AAC648; continue 'dispatch;
            }
            0x82AAC648 => {
    //   block [0x82AAC648..0x82AAC664)
	// 82AAC648: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC64C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC650: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC654: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC658: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC65C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC660: 4082FFE8  bne 0x82aac648
	if !ctx.cr[0].eq {
	pc = 0x82AAC648; continue 'dispatch;
	}
	pc = 0x82AAC664; continue 'dispatch;
            }
            0x82AAC664 => {
    //   block [0x82AAC664..0x82AAC684)
	// 82AAC664: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC668: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC66C: 48087C95  bl 0x82b34300
	ctx.lr = 0x82AAC670;
	sub_82B34300(ctx, base);
	// 82AAC670: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAC674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAC678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAC67C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAC680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAC688 size=356
    let mut pc: u32 = 0x82AAC688;
    'dispatch: loop {
        match pc {
            0x82AAC688 => {
    //   block [0x82AAC688..0x82AAC6BC)
	// 82AAC688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAC690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAC694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAC698: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC69C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AAC6A0: 3BCB5718  addi r30, r11, 0x5718
	ctx.r[30].s64 = ctx.r[11].s64 + 22296;
	// 82AAC6A4: 816B5718  lwz r11, 0x5718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22296 as u32) ) } as u64;
	// 82AAC6A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC6AC: 419A0010  beq cr6, 0x82aac6bc
	if ctx.cr[6].eq {
	pc = 0x82AAC6BC; continue 'dispatch;
	}
	// 82AAC6B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC6B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAC6B8: 409A0044  bne cr6, 0x82aac6fc
	if !ctx.cr[6].eq {
	pc = 0x82AAC6FC; continue 'dispatch;
	}
	pc = 0x82AAC6BC; continue 'dispatch;
            }
            0x82AAC6BC => {
    //   block [0x82AAC6BC..0x82AAC6FC)
	// 82AAC6BC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAC6C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAC6C4: 388B8810  addi r4, r11, -0x77f0
	ctx.r[4].s64 = ctx.r[11].s64 + -30704;
	// 82AAC6C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC6CC: 4B780805  bl 0x8222ced0
	ctx.lr = 0x82AAC6D0;
	sub_8222CED0(ctx, base);
	// 82AAC6D0: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82AAC6D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC6D8: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AAC6DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC6E0: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82AAC6E4: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82AAC6E8: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82AAC6EC: 480013BD  bl 0x82aadaa8
	ctx.lr = 0x82AAC6F0;
	sub_82AADAA8(ctx, base);
	// 82AAC6F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC6F4: 4B7686E5  bl 0x82214dd8
	ctx.lr = 0x82AAC6F8;
	sub_82214DD8(ctx, base);
	// 82AAC6F8: 480000DC  b 0x82aac7d4
	pc = 0x82AAC7D4; continue 'dispatch;
            }
            0x82AAC6FC => {
    //   block [0x82AAC6FC..0x82AAC7D4)
	// 82AAC6FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAC700: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC704: 4BFE0EA5  bl 0x82a8d5a8
	ctx.lr = 0x82AAC708;
	sub_82A8D5A8(ctx, base);
	// 82AAC708: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AAC70C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAC710: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC714: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AAC718: 4B7723D9  bl 0x8221eaf0
	ctx.lr = 0x82AAC71C;
	sub_8221EAF0(ctx, base);
	// 82AAC71C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AAC720: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 82AAC724: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAC728: 3BEABC68  addi r31, r10, -0x4398
	ctx.r[31].s64 = ctx.r[10].s64 + -17304;
	// 82AAC72C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82AAC730: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82AAC734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC738: C01FD828  lfs f0, -0x27d8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-10200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAC73C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82AAC7D4; continue 'dispatch;
            }
            0x82AAC7D4 => {
    //   block [0x82AAC7D4..0x82AAC7EC)
	// 82AAC7D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AAC7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAC7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAC7E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAC7E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAC7E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAC7F0 size=840
    let mut pc: u32 = 0x82AAC7F0;
    'dispatch: loop {
        match pc {
            0x82AAC7F0 => {
    //   block [0x82AAC7F0..0x82AAC860)
	// 82AAC7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC7F4: 481FCC11  bl 0x82ca9404
	ctx.lr = 0x82AAC7F8;
	sub_82CA93D0(ctx, base);
	// 82AAC7F8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82AAC7FC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC800: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAC804: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AAC808: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAC80C: 388B884C  addi r4, r11, -0x77b4
	ctx.r[4].s64 = ctx.r[11].s64 + -30644;
	// 82AAC810: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAC814: 4B7806BD  bl 0x8222ced0
	ctx.lr = 0x82AAC818;
	sub_8222CED0(ctx, base);
	// 82AAC818: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 82AAC81C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAC820: 9BC10072  stb r30, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[30].u8 ) };
	// 82AAC824: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAC828: 9BC10071  stb r30, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[30].u8 ) };
	// 82AAC82C: 9BC10070  stb r30, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u8 ) };
	// 82AAC830: 9BC10073  stb r30, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[30].u8 ) };
	// 82AAC834: 48001275  bl 0x82aadaa8
	ctx.lr = 0x82AAC838;
	sub_82AADAA8(ctx, base);
	// 82AAC838: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAC83C: 4B76859D  bl 0x82214dd8
	ctx.lr = 0x82AAC840;
	sub_82214DD8(ctx, base);
	// 82AAC840: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC844: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AAC848: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82AAC84C: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82AAC850: 38E87088  addi r7, r8, 0x7088
	ctx.r[7].s64 = ctx.r[8].s64 + 28808;
	// 82AAC854: 80A60014  lwz r5, 0x14(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAC858: 81650E5C  lwz r11, 0xe5c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3676 as u32) ) } as u64;
	// 82AAC85C: 3BEB1C48  addi r31, r11, 0x1c48
	ctx.r[31].s64 = ctx.r[11].s64 + 7240;
	pc = 0x82AAC860; continue 'dispatch;
            }
            0x82AAC860 => {
    //   block [0x82AAC860..0x82AACAFC)
	// 82AAC860: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC864: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC868: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC86C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC870: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC874: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC878: 4082FFE8  bne 0x82aac860
	if !ctx.cr[0].eq {
	pc = 0x82AAC860; continue 'dispatch;
	}
	// 82AAC87C: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAC880: 80AB1C48  lwz r5, 0x1c48(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7240 as u32) ) } as u64;
	// 82AAC884: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC888: 3884885C  addi r4, r4, -0x77a4
	ctx.r[4].s64 = ctx.r[4].s64 + -30628;
	// 82AAC88C: 4B7375C5  bl 0x821e3e50
	ctx.lr = 0x82AAC890;
	sub_821E3E50(ctx, base);
	// 82AAC890: 9BC1007A  stb r30, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[30].u8 ) };
	// 82AAC894: 9BC10079  stb r30, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[30].u8 ) };
	// 82AAC898: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AAC89C: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 82AAC8A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC8A4: 9BC1007B  stb r30, 0x7b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(123 as u32), ctx.r[30].u8 ) };
	// 82AAC8A8: 480012B9  bl 0x82aadb60
	ctx.lr = 0x82AAC8AC;
	sub_82AADB60(ctx, base);
	// 82AAC8AC: C81F0010  lfd f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 82AAC8B0: C9BF0018  lfd f13, 0x18(r31)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 82AAC8B4: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAC8B8: FD80682A  fadd f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 + ctx.f[13].f64;
	// 82AAC8BC: C97F0020  lfd f11, 0x20(r31)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 82AAC8C0: C95F0028  lfd f10, 0x28(r31)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 82AAC8C4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAC8C8: C93F0030  lfd f9, 0x30(r31)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	// 82AAC8CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC8D0: C91F0038  lfd f8, 0x38(r31)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	// 82AAC8D4: 388A8868  addi r4, r10, -0x7798
	ctx.r[4].s64 = ctx.r[10].s64 + -30616;
	// 82AAC8D8: C8FF0040  lfd f7, 0x40(r31)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	// 82AAC8DC: C8DF0048  lfd f6, 0x48(r31)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	// 82AAC8E0: C8BF0050  lfd f5, 0x50(r31)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	// 82AAC8E4: C89F0058  lfd f4, 0x58(r31)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	// 82AAC8E8: CBEB0EB8  lfd f31, 0xeb8(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3768 as u32) ) };
	// 82AAC8EC: C83F0008  lfd f1, 8(r31)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 82AAC8F0: FC6C582A  fadd f3, f12, f11
	ctx.f[3].f64 = ctx.f[12].f64 + ctx.f[11].f64;
	// 82AAC8F4: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC8F8: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC8FC: FC43502A  fadd f2, f3, f10
	ctx.f[2].f64 = ctx.f[3].f64 + ctx.f[10].f64;
	// 82AAC900: FC02482A  fadd f0, f2, f9
	ctx.f[0].f64 = ctx.f[2].f64 + ctx.f[9].f64;
	// 82AAC904: FDA0402A  fadd f13, f0, f8
	ctx.f[13].f64 = ctx.f[0].f64 + ctx.f[8].f64;
	// 82AAC908: FD8D382A  fadd f12, f13, f7
	ctx.f[12].f64 = ctx.f[13].f64 + ctx.f[7].f64;
	// 82AAC90C: FD6C302A  fadd f11, f12, f6
	ctx.f[11].f64 = ctx.f[12].f64 + ctx.f[6].f64;
	// 82AAC910: FD4B282A  fadd f10, f11, f5
	ctx.f[10].f64 = ctx.f[11].f64 + ctx.f[5].f64;
	// 82AAC914: FD2A202A  fadd f9, f10, f4
	ctx.f[9].f64 = ctx.f[10].f64 + ctx.f[4].f64;
	// 82AAC918: FC4907F2  fmul f2, f9, f31
	ctx.f[2].f64 = ctx.f[9].f64 * ctx.f[31].f64;
	// 82AAC91C: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 82AAC920: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 82AAC924: 4B73752D  bl 0x821e3e50
	ctx.lr = 0x82AAC928;
	sub_821E3E50(ctx, base);
	// 82AAC928: 9BC1007A  stb r30, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[30].u8 ) };
	// 82AAC92C: 9BC10079  stb r30, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[30].u8 ) };
	// 82AAC930: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AAC934: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 82AAC938: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC93C: 9BC1007B  stb r30, 0x7b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(123 as u32), ctx.r[30].u8 ) };
	// 82AAC940: 48001221  bl 0x82aadb60
	ctx.lr = 0x82AAC944;
	sub_82AADB60(ctx, base);
	// 82AAC944: C91F0070  lfd f8, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	// 82AAC948: C8FF0078  lfd f7, 0x78(r31)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	// 82AAC94C: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AAC950: FCC8382A  fadd f6, f8, f7
	ctx.f[6].f64 = ctx.f[8].f64 + ctx.f[7].f64;
	// 82AAC954: C8BF0080  lfd f5, 0x80(r31)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	// 82AAC958: C89F0088  lfd f4, 0x88(r31)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	// 82AAC95C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC960: C87F0090  lfd f3, 0x90(r31)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	// 82AAC964: 38898888  addi r4, r9, -0x7778
	ctx.r[4].s64 = ctx.r[9].s64 + -30584;
	// 82AAC968: C85F0098  lfd f2, 0x98(r31)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	// 82AAC96C: 3BBF0068  addi r29, r31, 0x68
	ctx.r[29].s64 = ctx.r[31].s64 + 104;
	// 82AAC970: C81F00A0  lfd f0, 0xa0(r31)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	// 82AAC974: C9BF00A8  lfd f13, 0xa8(r31)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	// 82AAC978: C99F00B0  lfd f12, 0xb0(r31)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	// 82AAC97C: C97F00B8  lfd f11, 0xb8(r31)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	// 82AAC980: C83F0068  lfd f1, 0x68(r31)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	// 82AAC984: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AAC988: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AAC98C: FD46282A  fadd f10, f6, f5
	ctx.f[10].f64 = ctx.f[6].f64 + ctx.f[5].f64;
	// 82AAC990: FD2A202A  fadd f9, f10, f4
	ctx.f[9].f64 = ctx.f[10].f64 + ctx.f[4].f64;
	// 82AAC994: FD09182A  fadd f8, f9, f3
	ctx.f[8].f64 = ctx.f[9].f64 + ctx.f[3].f64;
	// 82AAC998: FCE8102A  fadd f7, f8, f2
	ctx.f[7].f64 = ctx.f[8].f64 + ctx.f[2].f64;
	// 82AAC99C: FCC7002A  fadd f6, f7, f0
	ctx.f[6].f64 = ctx.f[7].f64 + ctx.f[0].f64;
	// 82AAC9A0: FCA6682A  fadd f5, f6, f13
	ctx.f[5].f64 = ctx.f[6].f64 + ctx.f[13].f64;
	// 82AAC9A4: FC85602A  fadd f4, f5, f12
	ctx.f[4].f64 = ctx.f[5].f64 + ctx.f[12].f64;
	// 82AAC9A8: FC64582A  fadd f3, f4, f11
	ctx.f[3].f64 = ctx.f[4].f64 + ctx.f[11].f64;
	// 82AAC9AC: FC4307F2  fmul f2, f3, f31
	ctx.f[2].f64 = ctx.f[3].f64 * ctx.f[31].f64;
	// 82AAC9B0: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 82AAC9B4: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 82AAC9B8: 4B737499  bl 0x821e3e50
	ctx.lr = 0x82AAC9BC;
	sub_821E3E50(ctx, base);
	// 82AAC9BC: 9BC1007A  stb r30, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[30].u8 ) };
	// 82AAC9C0: 9BC10079  stb r30, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[30].u8 ) };
	// 82AAC9C4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AAC9C8: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 82AAC9CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC9D0: 9BC1007B  stb r30, 0x7b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(123 as u32), ctx.r[30].u8 ) };
	// 82AAC9D4: 4800118D  bl 0x82aadb60
	ctx.lr = 0x82AAC9D8;
	sub_82AADB60(ctx, base);
	// 82AAC9D8: C85F0070  lfd f2, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	// 82AAC9DC: C83F0078  lfd f1, 0x78(r31)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	// 82AAC9E0: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC9E4: FDA2082A  fadd f13, f2, f1
	ctx.f[13].f64 = ctx.f[2].f64 + ctx.f[1].f64;
	// 82AAC9E8: C99F0080  lfd f12, 0x80(r31)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	// 82AAC9EC: C97F0088  lfd f11, 0x88(r31)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	// 82AAC9F0: 7CC507B4  extsw r5, r6
	ctx.r[5].s64 = ctx.r[6].s32 as i64;
	// 82AAC9F4: C95F0090  lfd f10, 0x90(r31)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	// 82AAC9F8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82AAC9FC: C93F0098  lfd f9, 0x98(r31)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	// 82AACA00: F8A10078  std r5, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[5].u64 ) };
	// 82AACA04: C91F00A0  lfd f8, 0xa0(r31)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	// 82AACA08: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AACA0C: C8FF00A8  lfd f7, 0xa8(r31)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	// 82AACA10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACA14: C8DF00B0  lfd f6, 0xb0(r31)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	// 82AACA18: 388788A8  addi r4, r7, -0x7758
	ctx.r[4].s64 = ctx.r[7].s64 + -30552;
	// 82AACA1C: C8BF00B8  lfd f5, 0xb8(r31)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	// 82AACA20: C8810078  lfd f4, 0x78(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82AACA24: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82AACA28: FC4D602A  fadd f2, f13, f12
	ctx.f[2].f64 = ctx.f[13].f64 + ctx.f[12].f64;
	// 82AACA2C: C8080120  lfd f0, 0x120(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(288 as u32) ) };
	// 82AACA30: FC001824  fdiv f0, f0, f3
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[3].f64;
	// 82AACA34: C83F0068  lfd f1, 0x68(r31)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	// 82AACA38: FDA2582A  fadd f13, f2, f11
	ctx.f[13].f64 = ctx.f[2].f64 + ctx.f[11].f64;
	// 82AACA3C: FC200072  fmul f1, f0, f1
	ctx.f[1].f64 = ctx.f[0].f64 * ctx.f[1].f64;
	// 82AACA40: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82AACA44: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82AACA48: FD8D502A  fadd f12, f13, f10
	ctx.f[12].f64 = ctx.f[13].f64 + ctx.f[10].f64;
	// 82AACA4C: FD6C482A  fadd f11, f12, f9
	ctx.f[11].f64 = ctx.f[12].f64 + ctx.f[9].f64;
	// 82AACA50: FD4B402A  fadd f10, f11, f8
	ctx.f[10].f64 = ctx.f[11].f64 + ctx.f[8].f64;
	// 82AACA54: FD2A382A  fadd f9, f10, f7
	ctx.f[9].f64 = ctx.f[10].f64 + ctx.f[7].f64;
	// 82AACA58: FD09302A  fadd f8, f9, f6
	ctx.f[8].f64 = ctx.f[9].f64 + ctx.f[6].f64;
	// 82AACA5C: FCE8282A  fadd f7, f8, f5
	ctx.f[7].f64 = ctx.f[8].f64 + ctx.f[5].f64;
	// 82AACA60: FCC707F2  fmul f6, f7, f31
	ctx.f[6].f64 = ctx.f[7].f64 * ctx.f[31].f64;
	// 82AACA64: FC460032  fmul f2, f6, f0
	ctx.f[2].f64 = ctx.f[6].f64 * ctx.f[0].f64;
	// 82AACA68: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 82AACA6C: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 82AACA70: 4B7373E1  bl 0x821e3e50
	ctx.lr = 0x82AACA74;
	sub_821E3E50(ctx, base);
	// 82AACA74: 9BC1007A  stb r30, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[30].u8 ) };
	// 82AACA78: 9BC10079  stb r30, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[30].u8 ) };
	// 82AACA7C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AACA80: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 82AACA84: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACA88: 9BC1007B  stb r30, 0x7b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(123 as u32), ctx.r[30].u8 ) };
	// 82AACA8C: 480010D5  bl 0x82aadb60
	ctx.lr = 0x82AACA90;
	sub_82AADB60(ctx, base);
	// 82AACA90: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82AACA94: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82AACA98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AACA9C: 3C606666  lis r3, 0x6666
	ctx.r[3].s64 = 1717960704;
	// 82AACAA0: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AACAA4: 606A6667  ori r10, r3, 0x6667
	ctx.r[10].u64 = ctx.r[3].u64 | 26215;
	// 82AACAA8: C8040D38  lfd f0, 0xd38(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(3384 as u32) ) };
	// 82AACAAC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82AACAB0: D81F0068  stfd f0, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 82AACAB4: 7C09EDAE  stfdx f0, r9, r29
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.f[0].u64) };
	// 82AACAB8: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82AACABC: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82AACAC0: 7CC75096  mulhw r6, r7, r10
	ctx.r[6].s64 = ((ctx.r[7].s32 as i64 * ctx.r[10].s32 as i64) >> 32);
	// 82AACAC4: 7CCB1670  srawi r11, r6, 2
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> 2) as i64;
	// 82AACAC8: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AACACC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AACAD0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AACAD4: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AACAD8: 54A4083C  slwi r4, r5, 1
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82AACADC: 7C643850  subf r3, r4, r7
	ctx.r[3].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 82AACAE0: 907F00C0  stw r3, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[3].u32 ) };
	// 82AACAE4: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82AACAE8: 81685730  lwz r11, 0x5730(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(22320 as u32) ) } as u64;
	// 82AACAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AACAF0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82AACAF4: 419A0024  beq cr6, 0x82aacb18
	if ctx.cr[6].eq {
	pc = 0x82AACB18; continue 'dispatch;
	}
	// 82AACAF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82AACAFC; continue 'dispatch;
            }
            0x82AACAFC => {
    //   block [0x82AACAFC..0x82AACB18)
	// 82AACAFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AACB00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACB04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AACB08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AACB0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AACB10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACB14: 4082FFE8  bne 0x82aacafc
	if !ctx.cr[0].eq {
	pc = 0x82AACAFC; continue 'dispatch;
	}
	pc = 0x82AACB18; continue 'dispatch;
            }
            0x82AACB18 => {
    //   block [0x82AACB18..0x82AACB38)
	// 82AACB18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AACB1C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACB20: 480869C9  bl 0x82b334e8
	ctx.lr = 0x82AACB24;
	sub_82B334E8(ctx, base);
	// 82AACB24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACB28: 4B7682B1  bl 0x82214dd8
	ctx.lr = 0x82AACB2C;
	sub_82214DD8(ctx, base);
	// 82AACB2C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AACB30: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82AACB34: 481FC920  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AACB38 size=164
    let mut pc: u32 = 0x82AACB38;
    'dispatch: loop {
        match pc {
            0x82AACB38 => {
    //   block [0x82AACB38..0x82AACBA0)
	// 82AACB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACB3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AACB40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AACB44: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACB48: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AACB4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AACB50: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AACB54: 388B88C8  addi r4, r11, -0x7738
	ctx.r[4].s64 = ctx.r[11].s64 + -30520;
	// 82AACB58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AACB5C: 4B780375  bl 0x8222ced0
	ctx.lr = 0x82AACB60;
	sub_8222CED0(ctx, base);
	// 82AACB60: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82AACB64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AACB68: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AACB6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AACB70: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82AACB74: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82AACB78: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82AACB7C: 48000F2D  bl 0x82aadaa8
	ctx.lr = 0x82AACB80;
	sub_82AADAA8(ctx, base);
	// 82AACB80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AACB84: 4B768255  bl 0x82214dd8
	ctx.lr = 0x82AACB88;
	sub_82214DD8(ctx, base);
	// 82AACB88: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82AACB8C: 816A5730  lwz r11, 0x5730(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22320 as u32) ) } as u64;
	// 82AACB90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AACB94: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AACB98: 419A0024  beq cr6, 0x82aacbbc
	if ctx.cr[6].eq {
	pc = 0x82AACBBC; continue 'dispatch;
	}
	// 82AACB9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82AACBA0; continue 'dispatch;
            }
            0x82AACBA0 => {
    //   block [0x82AACBA0..0x82AACBBC)
	// 82AACBA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AACBA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACBA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AACBAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AACBB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AACBB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACBB8: 4082FFE8  bne 0x82aacba0
	if !ctx.cr[0].eq {
	pc = 0x82AACBA0; continue 'dispatch;
	}
	pc = 0x82AACBBC; continue 'dispatch;
            }
            0x82AACBBC => {
    //   block [0x82AACBBC..0x82AACBDC)
	// 82AACBBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AACBC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AACBC4: 4808720D  bl 0x82b33dd0
	ctx.lr = 0x82AACBC8;
	sub_82B33DD0(ctx, base);
	// 82AACBC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AACBCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AACBD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AACBD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AACBD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AACBE0 size=540
    let mut pc: u32 = 0x82AACBE0;
    'dispatch: loop {
        match pc {
            0x82AACBE0 => {
    //   block [0x82AACBE0..0x82AACC84)
	// 82AACBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACBE4: 481FC815  bl 0x82ca93f8
	ctx.lr = 0x82AACBE8;
	sub_82CA93D0(ctx, base);
	// 82AACBE8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACBEC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AACBF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AACBF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AACBF8: 388B88D8  addi r4, r11, -0x7728
	ctx.r[4].s64 = ctx.r[11].s64 + -30504;
	// 82AACBFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACC00: 4B7802D1  bl 0x8222ced0
	ctx.lr = 0x82AACC04;
	sub_8222CED0(ctx, base);
	// 82AACC04: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AACC08: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AACC0C: 9BE10072  stb r31, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[31].u8 ) };
	// 82AACC10: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACC14: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 82AACC18: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 82AACC1C: 9BE10073  stb r31, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[31].u8 ) };
	// 82AACC20: 48000E89  bl 0x82aadaa8
	ctx.lr = 0x82AACC24;
	sub_82AADAA8(ctx, base);
	// 82AACC24: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACC28: 4B7681B1  bl 0x82214dd8
	ctx.lr = 0x82AACC2C;
	sub_82214DD8(ctx, base);
	// 82AACC2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AACC30: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AACC34: 388A0CA0  addi r4, r10, 0xca0
	ctx.r[4].s64 = ctx.r[10].s64 + 3232;
	// 82AACC38: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACC3C: 4B780295  bl 0x8222ced0
	ctx.lr = 0x82AACC40;
	sub_8222CED0(ctx, base);
	// 82AACC40: 9BE10072  stb r31, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[31].u8 ) };
	// 82AACC44: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 82AACC48: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AACC4C: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 82AACC50: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACC54: 9BE10073  stb r31, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[31].u8 ) };
	// 82AACC58: 48000E51  bl 0x82aadaa8
	ctx.lr = 0x82AACC5C;
	sub_82AADAA8(ctx, base);
	// 82AACC5C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACC60: 4B768179  bl 0x82214dd8
	ctx.lr = 0x82AACC64;
	sub_82214DD8(ctx, base);
	// 82AACC64: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AACC68: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AACC6C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AACC70: 3B8B7088  addi r28, r11, 0x7088
	ctx.r[28].s64 = ctx.r[11].s64 + 28808;
	// 82AACC74: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82AACC78: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AACC7C: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AACC80: 3B2B0D7C  addi r25, r11, 0xd7c
	ctx.r[25].s64 = ctx.r[11].s64 + 3452;
	pc = 0x82AACC84; continue 'dispatch;
            }
            0x82AACC84 => {
    //   block [0x82AACC84..0x82AACCC8)
	// 82AACC84: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AACC88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACC8C: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AACC90: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AACC94: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AACC98: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACC9C: 4082FFE8  bne 0x82aacc84
	if !ctx.cr[0].eq {
	pc = 0x82AACC84; continue 'dispatch;
	}
	// 82AACCA0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82AACCA4: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AACCA8: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AACCAC: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AACCB0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82AACCB4: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AACCB8: 3BB90004  addi r29, r25, 4
	ctx.r[29].s64 = ctx.r[25].s64 + 4;
	// 82AACCBC: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AACCC0: 3B0BFFDF  addi r24, r11, -0x21
	ctx.r[24].s64 = ctx.r[11].s64 + -33;
	// 82AACCC4: 3B6A88E8  addi r27, r10, -0x7718
	ctx.r[27].s64 = ctx.r[10].s64 + -30488;
	pc = 0x82AACCC8; continue 'dispatch;
            }
            0x82AACCC8 => {
    //   block [0x82AACCC8..0x82AACCF0)
	// 82AACCC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AACCCC: 4BFDBFDD  bl 0x82a88ca8
	ctx.lr = 0x82AACCD0;
	sub_82A88CA8(ctx, base);
	// 82AACCD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AACCD4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACCD8: 4B743569  bl 0x821f0240
	ctx.lr = 0x82AACCDC;
	sub_821F0240(ctx, base);
	// 82AACCDC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AACCE0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82AACCE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AACCE8: 419A0008  beq cr6, 0x82aaccf0
	if ctx.cr[6].eq {
	pc = 0x82AACCF0; continue 'dispatch;
	}
	// 82AACCEC: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AACCF0; continue 'dispatch;
            }
            0x82AACCF0 => {
    //   block [0x82AACCF0..0x82AACD18)
	// 82AACCF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AACCF4: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AACCF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACCFC: 4B737155  bl 0x821e3e50
	ctx.lr = 0x82AACD00;
	sub_821E3E50(ctx, base);
	// 82AACD00: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AACD04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACD08: 48000E59  bl 0x82aadb60
	ctx.lr = 0x82AACD0C;
	sub_82AADB60(ctx, base);
	// 82AACD0C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACD10: 4B719A59  bl 0x821c6768
	ctx.lr = 0x82AACD14;
	sub_821C6768(ctx, base);
	// 82AACD14: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x82AACD18; continue 'dispatch;
            }
            0x82AACD18 => {
    //   block [0x82AACD18..0x82AACD84)
	// 82AACD18: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AACD1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACD20: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AACD24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AACD28: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AACD2C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACD30: 4082FFE8  bne 0x82aacd18
	if !ctx.cr[0].eq {
	pc = 0x82AACD18; continue 'dispatch;
	}
	// 82AACD34: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82AACD38: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	// 82AACD3C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82AACD40: 2B1E0030  cmplwi cr6, r30, 0x30
	ctx.cr[6].compare_u32(ctx.r[30].u32, 48 as u32, &mut ctx.xer);
	// 82AACD44: 4198FF84  blt cr6, 0x82aaccc8
	if ctx.cr[6].lt {
	pc = 0x82AACCC8; continue 'dispatch;
	}
	// 82AACD48: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AACD4C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AACD50: 388B88F4  addi r4, r11, -0x770c
	ctx.r[4].s64 = ctx.r[11].s64 + -30476;
	// 82AACD54: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACD58: 4B780179  bl 0x8222ced0
	ctx.lr = 0x82AACD5C;
	sub_8222CED0(ctx, base);
	// 82AACD5C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AACD60: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AACD64: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AACD68: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AACD6C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACD70: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AACD74: 48000DED  bl 0x82aadb60
	ctx.lr = 0x82AACD78;
	sub_82AADB60(ctx, base);
	// 82AACD78: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACD7C: 4B7199ED  bl 0x821c6768
	ctx.lr = 0x82AACD80;
	sub_821C6768(ctx, base);
	// 82AACD80: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	pc = 0x82AACD84; continue 'dispatch;
            }
            0x82AACD84 => {
    //   block [0x82AACD84..0x82AACDD8)
	// 82AACD84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AACD88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACD8C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AACD90: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AACD94: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AACD98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACD9C: 4082FFE8  bne 0x82aacd84
	if !ctx.cr[0].eq {
	pc = 0x82AACD84; continue 'dispatch;
	}
	// 82AACDA0: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AACDA4: 80B90000  lwz r5, 0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AACDA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACDAC: 3887891C  addi r4, r7, -0x76e4
	ctx.r[4].s64 = ctx.r[7].s64 + -30436;
	// 82AACDB0: 4B7370A1  bl 0x821e3e50
	ctx.lr = 0x82AACDB4;
	sub_821E3E50(ctx, base);
	// 82AACDB4: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AACDB8: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AACDBC: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AACDC0: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AACDC4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACDC8: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AACDCC: 48000D95  bl 0x82aadb60
	ctx.lr = 0x82AACDD0;
	sub_82AADB60(ctx, base);
	// 82AACDD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACDD4: 4B719995  bl 0x821c6768
	ctx.lr = 0x82AACDD8;
	sub_821C6768(ctx, base);
	pc = 0x82AACDD8; continue 'dispatch;
            }
            0x82AACDD8 => {
    //   block [0x82AACDD8..0x82AACDFC)
	// 82AACDD8: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 82AACDDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACDE0: 7CC0E028  lwarx r6, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 82AACDE4: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 82AACDE8: 7CC0E12D  stwcx. r6, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AACDEC: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACDF0: 4082FFE8  bne 0x82aacdd8
	if !ctx.cr[0].eq {
	pc = 0x82AACDD8; continue 'dispatch;
	}
	// 82AACDF4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AACDF8: 481FC650  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AACE00 size=60
    let mut pc: u32 = 0x82AACE00;
    'dispatch: loop {
        match pc {
            0x82AACE00 => {
    //   block [0x82AACE00..0x82AACE2C)
	// 82AACE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACE04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AACE08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACE0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AACE10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AACE14: 4B742F9D  bl 0x821efdb0
	ctx.lr = 0x82AACE18;
	sub_821EFDB0(ctx, base);
	// 82AACE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AACE1C: 419A0010  beq cr6, 0x82aace2c
	if ctx.cr[6].eq {
	pc = 0x82AACE2C; continue 'dispatch;
	}
	// 82AACE20: 388300A4  addi r4, r3, 0xa4
	ctx.r[4].s64 = ctx.r[3].s64 + 164;
	// 82AACE24: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82AACE28: 48000029  bl 0x82aace50
	ctx.lr = 0x82AACE2C;
	sub_82AACE50(ctx, base);
	pc = 0x82AACE2C; continue 'dispatch;
            }
            0x82AACE2C => {
    //   block [0x82AACE2C..0x82AACE3C)
	// 82AACE2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AACE30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AACE34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AACE38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AACE50 size=684
    let mut pc: u32 = 0x82AACE50;
    'dispatch: loop {
        match pc {
            0x82AACE50 => {
    //   block [0x82AACE50..0x82AACF04)
	// 82AACE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACE54: 481FC599  bl 0x82ca93ec
	ctx.lr = 0x82AACE58;
	sub_82CA93D0(ctx, base);
	// 82AACE58: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACE5C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AACE60: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82AACE64: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AACE68: 388B892C  addi r4, r11, -0x76d4
	ctx.r[4].s64 = ctx.r[11].s64 + -30420;
	// 82AACE6C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACE70: 4B780061  bl 0x8222ced0
	ctx.lr = 0x82AACE74;
	sub_8222CED0(ctx, base);
	// 82AACE74: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AACE78: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AACE7C: 9BE10072  stb r31, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[31].u8 ) };
	// 82AACE80: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACE84: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 82AACE88: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 82AACE8C: 9BE10073  stb r31, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[31].u8 ) };
	// 82AACE90: 48000C19  bl 0x82aadaa8
	ctx.lr = 0x82AACE94;
	sub_82AADAA8(ctx, base);
	// 82AACE94: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACE98: 4B767F41  bl 0x82214dd8
	ctx.lr = 0x82AACE9C;
	sub_82214DD8(ctx, base);
	// 82AACE9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AACEA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AACEA4: 388A0CA0  addi r4, r10, 0xca0
	ctx.r[4].s64 = ctx.r[10].s64 + 3232;
	// 82AACEA8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACEAC: 4B780025  bl 0x8222ced0
	ctx.lr = 0x82AACEB0;
	sub_8222CED0(ctx, base);
	// 82AACEB0: 9BE10072  stb r31, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[31].u8 ) };
	// 82AACEB4: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 82AACEB8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AACEBC: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 82AACEC0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACEC4: 9BE10073  stb r31, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[31].u8 ) };
	// 82AACEC8: 48000BE1  bl 0x82aadaa8
	ctx.lr = 0x82AACECC;
	sub_82AADAA8(ctx, base);
	// 82AACECC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACED0: 4B767F09  bl 0x82214dd8
	ctx.lr = 0x82AACED4;
	sub_82214DD8(ctx, base);
	// 82AACED4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82AACED8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AACEDC: 3B6A5734  addi r27, r10, 0x5734
	ctx.r[27].s64 = ctx.r[10].s64 + 22324;
	// 82AACEE0: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82AACEE4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AACEE8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AACEEC: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82AACEF0: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82AACEF4: 816A5734  lwz r11, 0x5734(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22324 as u32) ) } as u64;
	// 82AACEF8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AACEFC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82AACF00: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	pc = 0x82AACF04; continue 'dispatch;
            }
            0x82AACF04 => {
    //   block [0x82AACF04..0x82AACF38)
	// 82AACF04: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AACF08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACF0C: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AACF10: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AACF14: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AACF18: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACF1C: 4082FFE8  bne 0x82aacf04
	if !ctx.cr[0].eq {
	pc = 0x82AACF04; continue 'dispatch;
	}
	// 82AACF20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82AACF24: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AACF28: 7F58D378  mr r24, r26
	ctx.r[24].u64 = ctx.r[26].u64;
	// 82AACF2C: 3AD9017C  addi r22, r25, 0x17c
	ctx.r[22].s64 = ctx.r[25].s64 + 380;
	// 82AACF30: 3AABFFDF  addi r21, r11, -0x21
	ctx.r[21].s64 = ctx.r[11].s64 + -33;
	// 82AACF34: 3AEA88E8  addi r23, r10, -0x7718
	ctx.r[23].s64 = ctx.r[10].s64 + -30488;
	pc = 0x82AACF38; continue 'dispatch;
            }
            0x82AACF38 => {
    //   block [0x82AACF38..0x82AACF6C)
	// 82AACF38: 83B60000  lwz r29, 0(r22)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AACF3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AACF40: 419A0088  beq cr6, 0x82aacfc8
	if ctx.cr[6].eq {
	pc = 0x82AACFC8; continue 'dispatch;
	}
	// 82AACF44: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82AACF48: 4BFDBD61  bl 0x82a88ca8
	ctx.lr = 0x82AACF4C;
	sub_82A88CA8(ctx, base);
	// 82AACF4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AACF50: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACF54: 4B7432ED  bl 0x821f0240
	ctx.lr = 0x82AACF58;
	sub_821F0240(ctx, base);
	// 82AACF58: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AACF5C: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 82AACF60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AACF64: 419A0008  beq cr6, 0x82aacf6c
	if ctx.cr[6].eq {
	pc = 0x82AACF6C; continue 'dispatch;
	}
	// 82AACF68: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AACF6C; continue 'dispatch;
            }
            0x82AACF6C => {
    //   block [0x82AACF6C..0x82AACFA8)
	// 82AACF6C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82AACF70: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AACF74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACF78: 4B736ED9  bl 0x821e3e50
	ctx.lr = 0x82AACF7C;
	sub_821E3E50(ctx, base);
	// 82AACF7C: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AACF80: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AACF84: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AACF88: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AACF8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AACF90: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AACF94: 48000BCD  bl 0x82aadb60
	ctx.lr = 0x82AACF98;
	sub_82AADB60(ctx, base);
	// 82AACF98: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACF9C: 7F9DE214  add r28, r29, r28
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	// 82AACFA0: 4B7197C9  bl 0x821c6768
	ctx.lr = 0x82AACFA4;
	sub_821C6768(ctx, base);
	// 82AACFA4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82AACFA8; continue 'dispatch;
            }
            0x82AACFA8 => {
    //   block [0x82AACFA8..0x82AACFC8)
	// 82AACFA8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AACFAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACFB0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AACFB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AACFB8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AACFBC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AACFC0: 4082FFE8  bne 0x82aacfa8
	if !ctx.cr[0].eq {
	pc = 0x82AACFA8; continue 'dispatch;
	}
	// 82AACFC4: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	pc = 0x82AACFC8; continue 'dispatch;
            }
            0x82AACFC8 => {
    //   block [0x82AACFC8..0x82AAD014)
	// 82AACFC8: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82AACFCC: 3AD60004  addi r22, r22, 4
	ctx.r[22].s64 = ctx.r[22].s64 + 4;
	// 82AACFD0: 2B180030  cmplwi cr6, r24, 0x30
	ctx.cr[6].compare_u32(ctx.r[24].u32, 48 as u32, &mut ctx.xer);
	// 82AACFD4: 4198FF64  blt cr6, 0x82aacf38
	if ctx.cr[6].lt {
	pc = 0x82AACF38; continue 'dispatch;
	}
	// 82AACFD8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AACFDC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AACFE0: 388B88F4  addi r4, r11, -0x770c
	ctx.r[4].s64 = ctx.r[11].s64 + -30476;
	// 82AACFE4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACFE8: 4B77FEE9  bl 0x8222ced0
	ctx.lr = 0x82AACFEC;
	sub_8222CED0(ctx, base);
	// 82AACFEC: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AACFF0: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AACFF4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AACFF8: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AACFFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAD000: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAD004: 48000B5D  bl 0x82aadb60
	ctx.lr = 0x82AAD008;
	sub_82AADB60(ctx, base);
	// 82AAD008: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAD00C: 4B71975D  bl 0x821c6768
	ctx.lr = 0x82AAD010;
	sub_821C6768(ctx, base);
	// 82AAD010: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	pc = 0x82AAD014; continue 'dispatch;
            }
            0x82AAD014 => {
    //   block [0x82AAD014..0x82AAD0D8)
	// 82AAD014: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAD018: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD01C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAD020: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AAD024: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAD028: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD02C: 4082FFE8  bne 0x82aad014
	if !ctx.cr[0].eq {
	pc = 0x82AAD014; continue 'dispatch;
	}
	// 82AAD030: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AAD034: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AAD038: 3887891C  addi r4, r7, -0x76e4
	ctx.r[4].s64 = ctx.r[7].s64 + -30436;
	// 82AAD03C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD040: 4B736E11  bl 0x821e3e50
	ctx.lr = 0x82AAD044;
	sub_821E3E50(ctx, base);
	// 82AAD044: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAD048: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAD04C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAD050: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAD054: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD058: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAD05C: 48000B05  bl 0x82aadb60
	ctx.lr = 0x82AAD060;
	sub_82AADB60(ctx, base);
	// 82AAD060: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82AAD064: 39400258  li r10, 0x258
	ctx.r[10].s64 = 600;
	// 82AAD068: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AAD06C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD070: 38868940  addi r4, r6, -0x76c0
	ctx.r[4].s64 = ctx.r[6].s64 + -30400;
	// 82AAD074: F97B0000  std r11, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AAD078: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAD07C: 80B90240  lwz r5, 0x240(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(576 as u32) ) } as u64;
	// 82AAD080: 4B736DD1  bl 0x821e3e50
	ctx.lr = 0x82AAD084;
	sub_821E3E50(ctx, base);
	// 82AAD084: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAD088: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAD08C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAD090: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAD094: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD098: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAD09C: 48000AC5  bl 0x82aadb60
	ctx.lr = 0x82AAD0A0;
	sub_82AADB60(ctx, base);
	// 82AAD0A0: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 82AAD0A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD0A8: 80B9023C  lwz r5, 0x23c(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(572 as u32) ) } as u64;
	// 82AAD0AC: 3884895C  addi r4, r4, -0x76a4
	ctx.r[4].s64 = ctx.r[4].s64 + -30372;
	// 82AAD0B0: 4B736DA1  bl 0x821e3e50
	ctx.lr = 0x82AAD0B4;
	sub_821E3E50(ctx, base);
	// 82AAD0B4: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 82AAD0B8: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82AAD0BC: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAD0C0: 9BE10074  stb r31, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u8 ) };
	// 82AAD0C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD0C8: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 82AAD0CC: 48000A95  bl 0x82aadb60
	ctx.lr = 0x82AAD0D0;
	sub_82AADB60(ctx, base);
	// 82AAD0D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD0D4: 4B719695  bl 0x821c6768
	ctx.lr = 0x82AAD0D8;
	sub_821C6768(ctx, base);
	pc = 0x82AAD0D8; continue 'dispatch;
            }
            0x82AAD0D8 => {
    //   block [0x82AAD0D8..0x82AAD0FC)
	// 82AAD0D8: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 82AAD0DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD0E0: 7C60F028  lwarx r3, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 82AAD0E4: 3863FFFF  addi r3, r3, -1
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	// 82AAD0E8: 7C60F12D  stwcx. r3, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAD0EC: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD0F0: 4082FFE8  bne 0x82aad0d8
	if !ctx.cr[0].eq {
	pc = 0x82AAD0D8; continue 'dispatch;
	}
	// 82AAD0F4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82AAD0F8: 481FC344  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAD100 size=316
    let mut pc: u32 = 0x82AAD100;
    'dispatch: loop {
        match pc {
            0x82AAD100 => {
    //   block [0x82AAD100..0x82AAD1CC)
	// 82AAD100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD108: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD10C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD110: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAD114: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD118: 388B897C  addi r4, r11, -0x7684
	ctx.r[4].s64 = ctx.r[11].s64 + -30340;
	// 82AAD11C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD120: 4B77FDB1  bl 0x8222ced0
	ctx.lr = 0x82AAD124;
	sub_8222CED0(ctx, base);
	// 82AAD124: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AAD128: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AAD12C: 9BE10082  stb r31, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[31].u8 ) };
	// 82AAD130: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD134: 9BE10081  stb r31, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[31].u8 ) };
	// 82AAD138: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82AAD13C: 9BE10083  stb r31, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[31].u8 ) };
	// 82AAD140: 48000969  bl 0x82aadaa8
	ctx.lr = 0x82AAD144;
	sub_82AADAA8(ctx, base);
	// 82AAD144: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD148: 4B767C91  bl 0x82214dd8
	ctx.lr = 0x82AAD14C;
	sub_82214DD8(ctx, base);
	// 82AAD14C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAD150: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD154: 388A88F4  addi r4, r10, -0x770c
	ctx.r[4].s64 = ctx.r[10].s64 + -30476;
	// 82AAD158: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD15C: 4B77FD75  bl 0x8222ced0
	ctx.lr = 0x82AAD160;
	sub_8222CED0(ctx, base);
	// 82AAD160: 9BE10082  stb r31, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[31].u8 ) };
	// 82AAD164: 9BE10081  stb r31, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[31].u8 ) };
	// 82AAD168: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AAD16C: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82AAD170: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD174: 9BE10083  stb r31, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[31].u8 ) };
	// 82AAD178: 480009E9  bl 0x82aadb60
	ctx.lr = 0x82AAD17C;
	sub_82AADB60(ctx, base);
	// 82AAD17C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD180: 4B767C59  bl 0x82214dd8
	ctx.lr = 0x82AAD184;
	sub_82214DD8(ctx, base);
	// 82AAD184: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AAD188: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD18C: 38890CA0  addi r4, r9, 0xca0
	ctx.r[4].s64 = ctx.r[9].s64 + 3232;
	// 82AAD190: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD194: 4B77FD3D  bl 0x8222ced0
	ctx.lr = 0x82AAD198;
	sub_8222CED0(ctx, base);
	// 82AAD198: 9BE10082  stb r31, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[31].u8 ) };
	// 82AAD19C: 9BE10081  stb r31, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[31].u8 ) };
	// 82AAD1A0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AAD1A4: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82AAD1A8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD1AC: 9BE10083  stb r31, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[31].u8 ) };
	// 82AAD1B0: 480008F9  bl 0x82aadaa8
	ctx.lr = 0x82AAD1B4;
	sub_82AADAA8(ctx, base);
	// 82AAD1B4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD1B8: 4B767C21  bl 0x82214dd8
	ctx.lr = 0x82AAD1BC;
	sub_82214DD8(ctx, base);
	// 82AAD1BC: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82AAD1C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAD1C4: 38887088  addi r4, r8, 0x7088
	ctx.r[4].s64 = ctx.r[8].s64 + 28808;
	// 82AAD1C8: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	pc = 0x82AAD1CC; continue 'dispatch;
            }
            0x82AAD1CC => {
    //   block [0x82AAD1CC..0x82AAD23C)
	// 82AAD1CC: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82AAD1D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD1D4: 7CE02028  lwarx r7, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82AAD1D8: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82AAD1DC: 7CE0212D  stwcx. r7, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAD1E0: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD1E4: 4082FFE8  bne 0x82aad1cc
	if !ctx.cr[0].eq {
	pc = 0x82AAD1CC; continue 'dispatch;
	}
	// 82AAD1E8: 3C608210  lis r3, -0x7df0
	ctx.r[3].s64 = -2112880640;
	// 82AAD1EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82AAD1F0: 38838990  addi r4, r3, -0x7670
	ctx.r[4].s64 = ctx.r[3].s64 + -30320;
	// 82AAD1F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAD1F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAD1FC: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD200: 4B736C51  bl 0x821e3e50
	ctx.lr = 0x82AAD204;
	sub_821E3E50(ctx, base);
	// 82AAD204: 9BE10082  stb r31, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[31].u8 ) };
	// 82AAD208: 9BE10081  stb r31, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[31].u8 ) };
	// 82AAD20C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AAD210: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82AAD214: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD218: 9BE10083  stb r31, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[31].u8 ) };
	// 82AAD21C: 4800088D  bl 0x82aadaa8
	ctx.lr = 0x82AAD220;
	sub_82AADAA8(ctx, base);
	// 82AAD220: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD224: 4B767BB5  bl 0x82214dd8
	ctx.lr = 0x82AAD228;
	sub_82214DD8(ctx, base);
	// 82AAD228: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AAD22C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAD240 size=508
    let mut pc: u32 = 0x82AAD240;
    'dispatch: loop {
        match pc {
            0x82AAD240 => {
    //   block [0x82AAD240..0x82AAD43C)
	// 82AAD240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD24C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD250: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AAD254: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD258: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAD25C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAD260: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD264: 388B89B8  addi r4, r11, -0x7648
	ctx.r[4].s64 = ctx.r[11].s64 + -30280;
	// 82AAD268: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD26C: 4B77FC65  bl 0x8222ced0
	ctx.lr = 0x82AAD270;
	sub_8222CED0(ctx, base);
	// 82AAD270: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AAD274: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AAD278: 9BE10082  stb r31, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[31].u8 ) };
	// 82AAD27C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD280: 9BE10081  stb r31, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[31].u8 ) };
	// 82AAD284: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82AAD288: 9BE10083  stb r31, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[31].u8 ) };
	// 82AAD28C: 4800081D  bl 0x82aadaa8
	ctx.lr = 0x82AAD290;
	sub_82AADAA8(ctx, base);
	// 82AAD290: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD294: 4B767B45  bl 0x82214dd8
	ctx.lr = 0x82AAD298;
	sub_82214DD8(ctx, base);
	// 82AAD298: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAD29C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD2A0: 388A88F4  addi r4, r10, -0x770c
	ctx.r[4].s64 = ctx.r[10].s64 + -30476;
	// 82AAD2A4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD2A8: 4B77FC29  bl 0x8222ced0
	ctx.lr = 0x82AAD2AC;
	sub_8222CED0(ctx, base);
	// 82AAD2AC: 9BE10082  stb r31, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[31].u8 ) };
	// 82AAD2B0: 9BE10081  stb r31, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[31].u8 ) };
	// 82AAD2B4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AAD2B8: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82AAD2BC: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD2C0: 9BE10083  stb r31, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[31].u8 ) };
	// 82AAD2C4: 4800089D  bl 0x82aadb60
	ctx.lr = 0x82AAD2C8;
	sub_82AADB60(ctx, base);
	// 82AAD2C8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD2CC: 4B767B0D  bl 0x82214dd8
	ctx.lr = 0x82AAD2D0;
	sub_82214DD8(ctx, base);
	// 82AAD2D0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AAD2D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD2D8: 38890CA0  addi r4, r9, 0xca0
	ctx.r[4].s64 = ctx.r[9].s64 + 3232;
	// 82AAD2DC: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD2E0: 4B77FBF1  bl 0x8222ced0
	ctx.lr = 0x82AAD2E4;
	sub_8222CED0(ctx, base);
	// 82AAD2E4: 9BE10082  stb r31, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[31].u8 ) };
	// 82AAD2E8: 9BE10081  stb r31, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[31].u8 ) };
	// 82AAD2EC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AAD2F0: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82AAD2F4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD2F8: 9BE10083  stb r31, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[31].u8 ) };
	// 82AAD2FC: 480007AD  bl 0x82aadaa8
	ctx.lr = 0x82AAD300;
	sub_82AADAA8(ctx, base);
	// 82AAD300: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD304: 4B767AD5  bl 0x82214dd8
	ctx.lr = 0x82AAD308;
	sub_82214DD8(ctx, base);
	// 82AAD308: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 82AAD30C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AAD310: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAD314: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82AAD318: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82AAD31C: 392B7088  addi r9, r11, 0x7088
	ctx.r[9].s64 = ctx.r[11].s64 + 28808;
	// 82AAD320: C0059484  lfs f0, -0x6b7c(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAD324: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82AAD328: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AAD32C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAD440 size=1220
    let mut pc: u32 = 0x82AAD440;
    'dispatch: loop {
        match pc {
            0x82AAD440 => {
    //   block [0x82AAD440..0x82AAD530)
	// 82AAD440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD444: 481FBFB9  bl 0x82ca93fc
	ctx.lr = 0x82AAD448;
	sub_82CA93D0(ctx, base);
	// 82AAD448: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82AAD44C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD450: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 82AAD454: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 82AAD458: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82AAD45C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AAD460: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAD464: 817F6F2C  lwz r11, 0x6f2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28460 as u32) ) } as u64;
	// 82AAD468: C9BE6F38  lfd f13, 0x6f38(r30)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(28472 as u32) ) };
	// 82AAD46C: C80A70C8  lfd f0, 0x70c8(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28872 as u32) ) };
	// 82AAD470: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAD474: FC00682A  fadd f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 + ctx.f[13].f64;
	// 82AAD478: D81E6F38  stfd f0, 0x6f38(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(28472 as u32), ctx.f[0].u64 ) };
	// 82AAD47C: 917F6F2C  stw r11, 0x6f2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28460 as u32), ctx.r[11].u32 ) };
	// 82AAD480: 4B7715A9  bl 0x8221ea28
	ctx.lr = 0x82AAD484;
	sub_8221EA28(ctx, base);
	// 82AAD484: C9410080  lfd f10, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82AAD488: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82AAD48C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82AAD490: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82AAD494: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAD498: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AAD49C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82AAD4A0: C80970A0  lfd f0, 0x70a0(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(28832 as u32) ) };
	// 82AAD4A4: 394A9484  addi r10, r10, -0x6b7c
	ctx.r[10].s64 = ctx.r[10].s64 + -27516;
	// 82AAD4A8: C9A870A8  lfd f13, 0x70a8(r8)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(28840 as u32) ) };
	// 82AAD4AC: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82AAD4B0: C98B6F30  lfd f12, 0x6f30(r11)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28464 as u32) ) };
	// 82AAD4B4: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 82AAD4B8: FD090028  fsub f8, f9, f0
	ctx.f[8].f64 = ctx.f[9].f64 - ctx.f[0].f64;
	// 82AAD4BC: 80EA6C9C  lwz r7, 0x6c9c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27804 as u32) ) } as u64;
	// 82AAD4C0: 80CA6CA0  lwz r6, 0x6ca0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27808 as u32) ) } as u64;
	// 82AAD4C4: 90E10088  stw r7, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 82AAD4C8: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82AAD4CC: C9610088  lfd f11, 0x88(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82AAD4D0: FDA86824  fdiv f13, f8, f13
	ctx.f[13].f64 = ctx.f[8].f64 / ctx.f[13].f64;
	// 82AAD4D4: FC0D6028  fsub f0, f13, f12
	ctx.f[0].f64 = ctx.f[13].f64 - ctx.f[12].f64;
	// 82AAD4D8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82AAD4DC: 40990054  ble cr6, 0x82aad530
	if !ctx.cr[6].gt {
	pc = 0x82AAD530; continue 'dispatch;
	}
	// 82AAD4E0: 813F6F2C  lwz r9, 0x6f2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28460 as u32) ) } as u64;
	// 82AAD4E4: C99E6F38  lfd f12, 0x6f38(r30)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(28472 as u32) ) };
	// 82AAD4E8: FD806028  fsub f12, f0, f12
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 82AAD4EC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82AAD4F0: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82AAD4F4: D9AB6F30  stfd f13, 0x6f30(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(28464 as u32), ctx.f[13].u64 ) };
	// 82AAD4F8: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82AAD4FC: F8E10088  std r7, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u64 ) };
	// 82AAD500: C9610088  lfd f11, 0x88(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82AAD504: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82AAD508: 913F6F2C  stw r9, 0x6f2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28460 as u32), ctx.r[9].u32 ) };
	// 82AAD50C: FD2A0024  fdiv f9, f10, f0
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[0].f64;
	// 82AAD510: C8080D38  lfd f0, 0xd38(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3384 as u32) ) };
	// 82AAD514: FD0A6024  fdiv f8, f10, f12
	ctx.f[8].f64 = ctx.f[10].f64 / ctx.f[12].f64;
	// 82AAD518: D81E6F38  stfd f0, 0x6f38(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(28472 as u32), ctx.f[0].u64 ) };
	// 82AAD51C: FC204818  frsp f1, f9
	ctx.f[1].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82AAD520: D03C6F28  stfs f1, 0x6f28(r28)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28456 as u32), tmp.u32 ) };
	// 82AAD524: FC004018  frsp f0, f8
	ctx.f[0].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82AAD528: D01D6F40  stfs f0, 0x6f40(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28480 as u32), tmp.u32 ) };
	// 82AAD52C: 4800000C  b 0x82aad538
	pc = 0x82AAD538; continue 'dispatch;
            }
            0x82AAD530 => {
    //   block [0x82AAD530..0x82AAD538)
	// 82AAD530: C03C6F28  lfs f1, 0x6f28(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAD534: C01D6F40  lfs f0, 0x6f40(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82AAD538; continue 'dispatch;
            }
            0x82AAD538 => {
    //   block [0x82AAD538..0x82AAD6E8)
	// 82AAD538: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAD53C: 3B6000FF  li r27, 0xff
	ctx.r[27].s64 = 255;
	// 82AAD540: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82AAD544: 409901A4  ble cr6, 0x82aad6e8
	if !ctx.cr[6].gt {
	pc = 0x82AAD6E8; continue 'dispatch;
	}
	// 82AAD548: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AAD54C: 4099019C  ble cr6, 0x82aad6e8
	if !ctx.cr[6].gt {
	pc = 0x82AAD6E8; continue 'dispatch;
	}
	// 82AAD550: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AAD554: 9B610052  stb r27, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[27].u8 ) };
	// 82AAD558: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAD55C: 9B610051  stb r27, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[27].u8 ) };
	// 82AAD560: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 82AAD564: 9B610053  stb r27, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[27].u8 ) };
	// 82AAD568: 4B741429  bl 0x821ee990
	ctx.lr = 0x82AAD56C;
	sub_821EE990(ctx, base);
	// 82AAD56C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAD570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD574: 388B8A18  addi r4, r11, -0x75e8
	ctx.r[4].s64 = ctx.r[11].s64 + -30184;
	// 82AAD578: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD57C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAD580: 4B77F951  bl 0x8222ced0
	ctx.lr = 0x82AAD584;
	sub_8222CED0(ctx, base);
	// 82AAD584: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD588: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD58C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAD590: 4B735B79  bl 0x821e3108
	ctx.lr = 0x82AAD594;
	sub_821E3108(ctx, base);
	// 82AAD594: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD598: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAD59C: 4B742CA5  bl 0x821f0240
	ctx.lr = 0x82AAD5A0;
	sub_821F0240(ctx, base);
	// 82AAD5A0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAD5A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAD5A8: 3BEA8A08  addi r31, r10, -0x75f8
	ctx.r[31].s64 = ctx.r[10].s64 + -30200;
	// 82AAD5AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD5B0: 4B72D411  bl 0x821da9c0
	ctx.lr = 0x82AAD5B4;
	sub_821DA9C0(ctx, base);
	// 82AAD5B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AAD5B8: C01C6F28  lfs f0, 0x6f28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28456 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAD5BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AAD5C0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AAD5C4: CBE90DD0  lfd f31, 0xdd0(r9)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3536 as u32) ) };
	// 82AAD5C8: FC3F0024  fdiv f1, f31, f0
	ctx.f[1].f64 = ctx.f[31].f64 / ctx.f[0].f64;
	// 82AAD5CC: 4B7413C5  bl 0x821ee990
	ctx.lr = 0x82AAD5D0;
	sub_821EE990(ctx, base);
	// 82AAD5D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAD5D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AAD5D8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82AAD5DC: 4B735B2D  bl 0x821e3108
	ctx.lr = 0x82AAD5E0;
	sub_821E3108(ctx, base);
	// 82AAD5E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD5E4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AAD5E8: 4B742C59  bl 0x821f0240
	ctx.lr = 0x82AAD5EC;
	sub_821F0240(ctx, base);
	// 82AAD5EC: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AAD5F0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AAD5F4: 38888A0C  addi r4, r8, -0x75f4
	ctx.r[4].s64 = ctx.r[8].s64 + -30196;
	// 82AAD5F8: 4B72D3C9  bl 0x821da9c0
	ctx.lr = 0x82AAD5FC;
	sub_821DA9C0(ctx, base);
	// 82AAD5FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AAD600: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAD604: C03D6F40  lfs f1, 0x6f40(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28480 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAD608: 4B741389  bl 0x821ee990
	ctx.lr = 0x82AAD60C;
	sub_821EE990(ctx, base);
	// 82AAD60C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAD610: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82AAD614: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AAD618: 4B735AF1  bl 0x821e3108
	ctx.lr = 0x82AAD61C;
	sub_821E3108(ctx, base);
	// 82AAD61C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD620: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAD624: 4B742C1D  bl 0x821f0240
	ctx.lr = 0x82AAD628;
	sub_821F0240(ctx, base);
	// 82AAD628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD62C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAD630: 4B72D391  bl 0x821da9c0
	ctx.lr = 0x82AAD634;
	sub_821DA9C0(ctx, base);
	// 82AAD634: C01D6F40  lfs f0, 0x6f40(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAD638: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AAD63C: FC3F0024  fdiv f1, f31, f0
	ctx.f[1].f64 = ctx.f[31].f64 / ctx.f[0].f64;
	// 82AAD640: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAD644: 4B74134D  bl 0x821ee990
	ctx.lr = 0x82AAD648;
	sub_821EE990(ctx, base);
	// 82AAD648: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAD64C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAD650: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AAD654: 4B735AB5  bl 0x821e3108
	ctx.lr = 0x82AAD658;
	sub_821E3108(ctx, base);
	// 82AAD658: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD65C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD660: 4B742BE1  bl 0x821f0240
	ctx.lr = 0x82AAD664;
	sub_821F0240(ctx, base);
	// 82AAD664: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AAD668: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD66C: 38878A00  addi r4, r7, -0x7600
	ctx.r[4].s64 = ctx.r[7].s64 + -30208;
	// 82AAD670: 4B72D351  bl 0x821da9c0
	ctx.lr = 0x82AAD674;
	sub_821DA9C0(ctx, base);
	// 82AAD674: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAD678: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD67C: 4800042D  bl 0x82aadaa8
	ctx.lr = 0x82AAD680;
	sub_82AADAA8(ctx, base);
	// 82AAD680: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD684: 4B767755  bl 0x82214dd8
	ctx.lr = 0x82AAD688;
	sub_82214DD8(ctx, base);
	// 82AAD688: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AAD68C: 4B76774D  bl 0x82214dd8
	ctx.lr = 0x82AAD690;
	sub_82214DD8(ctx, base);
	// 82AAD690: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAD694: 4B767745  bl 0x82214dd8
	ctx.lr = 0x82AAD698;
	sub_82214DD8(ctx, base);
	// 82AAD698: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AAD69C: 4B76773D  bl 0x82214dd8
	ctx.lr = 0x82AAD6A0;
	sub_82214DD8(ctx, base);
	// 82AAD6A0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AAD6A4: 4B767735  bl 0x82214dd8
	ctx.lr = 0x82AAD6A8;
	sub_82214DD8(ctx, base);
	// 82AAD6A8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82AAD6AC: 4B76772D  bl 0x82214dd8
	ctx.lr = 0x82AAD6B0;
	sub_82214DD8(ctx, base);
	// 82AAD6B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAD6B4: 4B767725  bl 0x82214dd8
	ctx.lr = 0x82AAD6B8;
	sub_82214DD8(ctx, base);
	// 82AAD6B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAD6BC: 4B76771D  bl 0x82214dd8
	ctx.lr = 0x82AAD6C0;
	sub_82214DD8(ctx, base);
	// 82AAD6C0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAD6C4: 4B767715  bl 0x82214dd8
	ctx.lr = 0x82AAD6C8;
	sub_82214DD8(ctx, base);
	// 82AAD6C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAD6CC: 4B76770D  bl 0x82214dd8
	ctx.lr = 0x82AAD6D0;
	sub_82214DD8(ctx, base);
	// 82AAD6D0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AAD6D4: 4B767705  bl 0x82214dd8
	ctx.lr = 0x82AAD6D8;
	sub_82214DD8(ctx, base);
	// 82AAD6D8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAD6DC: 4B7676FD  bl 0x82214dd8
	ctx.lr = 0x82AAD6E0;
	sub_82214DD8(ctx, base);
	// 82AAD6E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAD6E4: 4B7676F5  bl 0x82214dd8
	ctx.lr = 0x82AAD6E8;
	sub_82214DD8(ctx, base);
	pc = 0x82AAD6E8; continue 'dispatch;
            }
            0x82AAD6E8 => {
    //   block [0x82AAD6E8..0x82AAD740)
	// 82AAD6E8: 817A0018  lwz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAD6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAD6F0: 419A0208  beq cr6, 0x82aad8f8
	if ctx.cr[6].eq {
	pc = 0x82AAD8F8; continue 'dispatch;
	}
	// 82AAD6F4: 810B01E8  lwz r8, 0x1e8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(488 as u32) ) } as u64;
	// 82AAD6F8: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82AAD6FC: 812B0198  lwz r9, 0x198(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82AAD700: 3BEB00A4  addi r31, r11, 0xa4
	ctx.r[31].s64 = ctx.r[11].s64 + 164;
	// 82AAD704: 814B0184  lwz r10, 0x184(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(388 as u32) ) } as u64;
	// 82AAD708: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82AAD70C: 810B0170  lwz r8, 0x170(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(368 as u32) ) } as u64;
	// 82AAD710: 816B01AC  lwz r11, 0x1ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) } as u64;
	// 82AAD714: 3BDF0104  addi r30, r31, 0x104
	ctx.r[30].s64 = ctx.r[31].s64 + 260;
	// 82AAD718: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AAD71C: 813D6F60  lwz r9, 0x6f60(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28512 as u32) ) } as u64;
	// 82AAD720: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82AAD724: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AAD728: 419A002C  beq cr6, 0x82aad754
	if ctx.cr[6].eq {
	pc = 0x82AAD754; continue 'dispatch;
	}
	// 82AAD72C: 891E0000  lbz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD730: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAD734: 419A000C  beq cr6, 0x82aad740
	if ctx.cr[6].eq {
	pc = 0x82AAD740; continue 'dispatch;
	}
	// 82AAD738: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AAD73C: 913E0010  stw r9, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82AAD740; continue 'dispatch;
            }
            0x82AAD740 => {
    //   block [0x82AAD740..0x82AAD754)
	// 82AAD740: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAD744: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAD748: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AAD74C: 40990008  ble cr6, 0x82aad754
	if !ctx.cr[6].gt {
	pc = 0x82AAD754; continue 'dispatch;
	}
	// 82AAD750: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x82AAD754; continue 'dispatch;
            }
            0x82AAD754 => {
    //   block [0x82AAD754..0x82AAD774)
	// 82AAD754: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAD758: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AAD75C: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAD760: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82AAD764: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82AAD768: 419A000C  beq cr6, 0x82aad774
	if ctx.cr[6].eq {
	pc = 0x82AAD774; continue 'dispatch;
	}
	// 82AAD76C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AAD770: 913E0010  stw r9, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82AAD774; continue 'dispatch;
            }
            0x82AAD774 => {
    //   block [0x82AAD774..0x82AAD808)
	// 82AAD774: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AAD778: 809F0108  lwz r4, 0x108(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82AAD77C: 9B610052  stb r27, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[27].u8 ) };
	// 82AAD780: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82AAD784: 9B610051  stb r27, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[27].u8 ) };
	// 82AAD788: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 82AAD78C: 9B610053  stb r27, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[27].u8 ) };
	// 82AAD790: 4B8A1531  bl 0x8234ecc0
	ctx.lr = 0x82AAD794;
	sub_8234ECC0(ctx, base);
	// 82AAD794: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAD798: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AAD79C: 388B8A28  addi r4, r11, -0x75d8
	ctx.r[4].s64 = ctx.r[11].s64 + -30168;
	// 82AAD7A0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD7A4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAD7A8: 4B77F729  bl 0x8222ced0
	ctx.lr = 0x82AAD7AC;
	sub_8222CED0(ctx, base);
	// 82AAD7AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD7B0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAD7B4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AAD7B8: 4B735951  bl 0x821e3108
	ctx.lr = 0x82AAD7BC;
	sub_821E3108(ctx, base);
	// 82AAD7BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AAD7C0: 480002E9  bl 0x82aadaa8
	ctx.lr = 0x82AAD7C4;
	sub_82AADAA8(ctx, base);
	// 82AAD7C4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAD7C8: 4B767611  bl 0x82214dd8
	ctx.lr = 0x82AAD7CC;
	sub_82214DD8(ctx, base);
	// 82AAD7CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAD7D0: 4B767609  bl 0x82214dd8
	ctx.lr = 0x82AAD7D4;
	sub_82214DD8(ctx, base);
	// 82AAD7D4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AAD7D8: 4B767601  bl 0x82214dd8
	ctx.lr = 0x82AAD7DC;
	sub_82214DD8(ctx, base);
	// 82AAD7DC: 9B3E0000  stb r25, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82AAD7E0: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82AAD7E4: 397F00DC  addi r11, r31, 0xdc
	ctx.r[11].s64 = ctx.r[31].s64 + 220;
	// 82AAD7E8: 813D6F60  lwz r9, 0x6f60(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28512 as u32) ) } as u64;
	// 82AAD7EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAD7F0: 419A002C  beq cr6, 0x82aad81c
	if ctx.cr[6].eq {
	pc = 0x82AAD81C; continue 'dispatch;
	}
	// 82AAD7F4: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD7F8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAD7FC: 419A000C  beq cr6, 0x82aad808
	if ctx.cr[6].eq {
	pc = 0x82AAD808; continue 'dispatch;
	}
	// 82AAD800: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAD804: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82AAD808; continue 'dispatch;
            }
            0x82AAD808 => {
    //   block [0x82AAD808..0x82AAD81C)
	// 82AAD808: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAD80C: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82AAD810: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAD814: 40980008  bge cr6, 0x82aad81c
	if !ctx.cr[6].lt {
	pc = 0x82AAD81C; continue 'dispatch;
	}
	// 82AAD818: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	pc = 0x82AAD81C; continue 'dispatch;
            }
            0x82AAD81C => {
    //   block [0x82AAD81C..0x82AAD840)
	// 82AAD81C: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82AAD820: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 82AAD824: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAD828: 419A002C  beq cr6, 0x82aad854
	if ctx.cr[6].eq {
	pc = 0x82AAD854; continue 'dispatch;
	}
	// 82AAD82C: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD830: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAD834: 419A000C  beq cr6, 0x82aad840
	if ctx.cr[6].eq {
	pc = 0x82AAD840; continue 'dispatch;
	}
	// 82AAD838: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAD83C: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82AAD840; continue 'dispatch;
            }
            0x82AAD840 => {
    //   block [0x82AAD840..0x82AAD854)
	// 82AAD840: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAD844: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82AAD848: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAD84C: 40980008  bge cr6, 0x82aad854
	if !ctx.cr[6].lt {
	pc = 0x82AAD854; continue 'dispatch;
	}
	// 82AAD850: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	pc = 0x82AAD854; continue 'dispatch;
            }
            0x82AAD854 => {
    //   block [0x82AAD854..0x82AAD878)
	// 82AAD854: 815F00CC  lwz r10, 0xcc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AAD858: 397F00C8  addi r11, r31, 0xc8
	ctx.r[11].s64 = ctx.r[31].s64 + 200;
	// 82AAD85C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAD860: 419A002C  beq cr6, 0x82aad88c
	if ctx.cr[6].eq {
	pc = 0x82AAD88C; continue 'dispatch;
	}
	// 82AAD864: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD868: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAD86C: 419A000C  beq cr6, 0x82aad878
	if ctx.cr[6].eq {
	pc = 0x82AAD878; continue 'dispatch;
	}
	// 82AAD870: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAD874: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82AAD878; continue 'dispatch;
            }
            0x82AAD878 => {
    //   block [0x82AAD878..0x82AAD88C)
	// 82AAD878: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAD87C: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82AAD880: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAD884: 40980008  bge cr6, 0x82aad88c
	if !ctx.cr[6].lt {
	pc = 0x82AAD88C; continue 'dispatch;
	}
	// 82AAD888: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	pc = 0x82AAD88C; continue 'dispatch;
            }
            0x82AAD88C => {
    //   block [0x82AAD88C..0x82AAD8B0)
	// 82AAD88C: 815F0144  lwz r10, 0x144(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 82AAD890: 397F0140  addi r11, r31, 0x140
	ctx.r[11].s64 = ctx.r[31].s64 + 320;
	// 82AAD894: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAD898: 419A002C  beq cr6, 0x82aad8c4
	if ctx.cr[6].eq {
	pc = 0x82AAD8C4; continue 'dispatch;
	}
	// 82AAD89C: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD8A0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAD8A4: 419A000C  beq cr6, 0x82aad8b0
	if ctx.cr[6].eq {
	pc = 0x82AAD8B0; continue 'dispatch;
	}
	// 82AAD8A8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAD8AC: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82AAD8B0; continue 'dispatch;
            }
            0x82AAD8B0 => {
    //   block [0x82AAD8B0..0x82AAD8C4)
	// 82AAD8B0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAD8B4: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82AAD8B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AAD8BC: 40980008  bge cr6, 0x82aad8c4
	if !ctx.cr[6].lt {
	pc = 0x82AAD8C4; continue 'dispatch;
	}
	// 82AAD8C0: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	pc = 0x82AAD8C4; continue 'dispatch;
            }
            0x82AAD8C4 => {
    //   block [0x82AAD8C4..0x82AAD8E4)
	// 82AAD8C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAD8C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD8CC: 419A002C  beq cr6, 0x82aad8f8
	if ctx.cr[6].eq {
	pc = 0x82AAD8F8; continue 'dispatch;
	}
	// 82AAD8D0: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD8D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAD8D8: 419A000C  beq cr6, 0x82aad8e4
	if ctx.cr[6].eq {
	pc = 0x82AAD8E4; continue 'dispatch;
	}
	// 82AAD8DC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AAD8E0: 913E0010  stw r9, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82AAD8E4; continue 'dispatch;
            }
            0x82AAD8E4 => {
    //   block [0x82AAD8E4..0x82AAD8F8)
	// 82AAD8E4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAD8E8: 933E0004  stw r25, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82AAD8EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD8F0: 40980008  bge cr6, 0x82aad8f8
	if !ctx.cr[6].lt {
	pc = 0x82AAD8F8; continue 'dispatch;
	}
	// 82AAD8F4: 933E000C  stw r25, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	pc = 0x82AAD8F8; continue 'dispatch;
            }
            0x82AAD8F8 => {
    //   block [0x82AAD8F8..0x82AAD904)
	// 82AAD8F8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AAD8FC: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82AAD900: 481FBB4C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAD908 size=152
    let mut pc: u32 = 0x82AAD908;
    'dispatch: loop {
        match pc {
            0x82AAD908 => {
    //   block [0x82AAD908..0x82AAD9A0)
	// 82AAD908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD90C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD914: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD918: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAD91C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD920: 388B8A38  addi r4, r11, -0x75c8
	ctx.r[4].s64 = ctx.r[11].s64 + -30152;
	// 82AAD924: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD928: 4B77F5A9  bl 0x8222ced0
	ctx.lr = 0x82AAD92C;
	sub_8222CED0(ctx, base);
	// 82AAD92C: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82AAD930: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAD934: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 82AAD938: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD93C: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 82AAD940: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82AAD944: 9BE10053  stb r31, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[31].u8 ) };
	// 82AAD948: 48000161  bl 0x82aadaa8
	ctx.lr = 0x82AAD94C;
	sub_82AADAA8(ctx, base);
	// 82AAD94C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD950: 4B767489  bl 0x82214dd8
	ctx.lr = 0x82AAD954;
	sub_82214DD8(ctx, base);
	// 82AAD954: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82AAD958: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AAD95C: 388A88F4  addi r4, r10, -0x770c
	ctx.r[4].s64 = ctx.r[10].s64 + -30476;
	// 82AAD960: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD964: 4B77F56D  bl 0x8222ced0
	ctx.lr = 0x82AAD968;
	sub_8222CED0(ctx, base);
	// 82AAD968: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 82AAD96C: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 82AAD970: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAD974: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82AAD978: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD97C: 9BE10053  stb r31, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[31].u8 ) };
	// 82AAD980: 480001E1  bl 0x82aadb60
	ctx.lr = 0x82AAD984;
	sub_82AADB60(ctx, base);
	// 82AAD984: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD988: 4B767451  bl 0x82214dd8
	ctx.lr = 0x82AAD98C;
	sub_82214DD8(ctx, base);
	// 82AAD98C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAD990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD998: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD99C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAD9A0 size=264
    let mut pc: u32 = 0x82AAD9A0;
    'dispatch: loop {
        match pc {
            0x82AAD9A0 => {
    //   block [0x82AAD9A0..0x82AAD9D8)
	// 82AAD9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD9A4: 481FBA69  bl 0x82ca940c
	ctx.lr = 0x82AAD9A8;
	sub_82CA93D0(ctx, base);
	// 82AAD9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD9AC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AAD9B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD9B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAD9B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AAD9BC: 388B573C  addi r4, r11, 0x573c
	ctx.r[4].s64 = ctx.r[11].s64 + 22332;
	// 82AAD9C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAD9C4: 4B752DAD  bl 0x82200770
	ctx.lr = 0x82AAD9C8;
	sub_82200770(ctx, base);
	// 82AAD9C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AAD9CC: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82AAD9D0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AAD9D4: 38E87088  addi r7, r8, 0x7088
	ctx.r[7].s64 = ctx.r[8].s64 + 28808;
	pc = 0x82AAD9D8; continue 'dispatch;
            }
            0x82AAD9D8 => {
    //   block [0x82AAD9D8..0x82AADA20)
	// 82AAD9D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAD9DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD9E0: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAD9E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAD9E8: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAD9EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD9F0: 4082FFE8  bne 0x82aad9d8
	if !ctx.cr[0].eq {
	pc = 0x82AAD9D8; continue 'dispatch;
	}
	// 82AAD9F4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AAD9F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD9FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AADA00: 4B7B77A1  bl 0x822651a0
	ctx.lr = 0x82AADA04;
	sub_822651A0(ctx, base);
	// 82AADA04: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AADA08: 3BEB571C  addi r31, r11, 0x571c
	ctx.r[31].s64 = ctx.r[11].s64 + 22300;
	// 82AADA0C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AADA14: 409A000C  bne cr6, 0x82aada20
	if !ctx.cr[6].eq {
	pc = 0x82AADA20; continue 'dispatch;
	}
	// 82AADA18: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82AADA1C: 48000010  b 0x82aada2c
	pc = 0x82AADA2C; continue 'dispatch;
            }
            0x82AADA20 => {
    //   block [0x82AADA20..0x82AADA2C)
	// 82AADA20: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AADA24: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AADA28: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82AADA2C; continue 'dispatch;
            }
            0x82AADA2C => {
    //   block [0x82AADA2C..0x82AADA5C)
	// 82AADA2C: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADA30: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82AADA34: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AADA38: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AADA3C: 4098002C  bge cr6, 0x82aada68
	if !ctx.cr[6].lt {
	pc = 0x82AADA68; continue 'dispatch;
	}
	// 82AADA40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AADA44: 419A0018  beq cr6, 0x82aada5c
	if ctx.cr[6].eq {
	pc = 0x82AADA5C; continue 'dispatch;
	}
	// 82AADA48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AADA4C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AADA50: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82AADA54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AADA58: 4B7427E9  bl 0x821f0240
	ctx.lr = 0x82AADA5C;
	sub_821F0240(ctx, base);
	pc = 0x82AADA5C; continue 'dispatch;
            }
            0x82AADA5C => {
    //   block [0x82AADA5C..0x82AADA68)
	// 82AADA5C: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 82AADA60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AADA64: 48000020  b 0x82aada84
	pc = 0x82AADA84; continue 'dispatch;
            }
            0x82AADA68 => {
    //   block [0x82AADA68..0x82AADA84)
	// 82AADA68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADA6C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82AADA70: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AADA74: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82AADA78: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AADA7C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AADA80: 48000301  bl 0x82aadd80
	ctx.lr = 0x82AADA84;
	sub_82AADD80(ctx, base);
	pc = 0x82AADA84; continue 'dispatch;
            }
            0x82AADA84 => {
    //   block [0x82AADA84..0x82AADAA0)
	// 82AADA84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AADA88: 4B767351  bl 0x82214dd8
	ctx.lr = 0x82AADA8C;
	sub_82214DD8(ctx, base);
	// 82AADA8C: 89410064  lbz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AADA90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AADA94: 419A000C  beq cr6, 0x82aadaa0
	if ctx.cr[6].eq {
	pc = 0x82AADAA0; continue 'dispatch;
	}
	// 82AADA98: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AADA9C: 4880BEB9  bl 0x832b9954
	ctx.lr = 0x82AADAA0;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x82AADAA0; continue 'dispatch;
            }
            0x82AADAA0 => {
    //   block [0x82AADAA0..0x82AADAA8)
	// 82AADAA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AADAA4: 481FB9B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AADAA8 size=180
    let mut pc: u32 = 0x82AADAA8;
    'dispatch: loop {
        match pc {
            0x82AADAA8 => {
    //   block [0x82AADAA8..0x82AADB5C)
	// 82AADAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AADAB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AADAB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AADAB8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADABC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AADAC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AADAC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADAC8: 48091EA1  bl 0x82b3f968
	ctx.lr = 0x82AADACC;
	sub_82B3F968(ctx, base);
	// 82AADACC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AADAD0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AADAD4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82AADAD8: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82AADADC: 3BCB5734  addi r30, r11, 0x5734
	ctx.r[30].s64 = ctx.r[11].s64 + 22324;
	// 82AADAE0: 3888572C  addi r4, r8, 0x572c
	ctx.r[4].s64 = ctx.r[8].s64 + 22316;
	// 82AADAE4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AADAE8: C02ACBBC  lfs f1, -0x3444(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13380 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AADAEC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AADAF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AADAF4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AADAF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AADAFC: 83E95F74  lwz r31, 0x5f74(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24436 as u32) ) } as u64;
	// 82AADB00: 480BA011  bl 0x82b67b10
	ctx.lr = 0x82AADB04;
	sub_82B67B10(ctx, base);
	// 82AADB04: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AADB08: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADB0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AADB10: 480B91E1  bl 0x82b66cf0
	ctx.lr = 0x82AADB14;
	sub_82B66CF0(ctx, base);
	// 82AADB14: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AADB18: 4B718CE1  bl 0x821c67f8
	ctx.lr = 0x82AADB1C;
	sub_821C67F8(ctx, base);
	// 82AADB1C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AADB20: 4B784199  bl 0x82231cb8
	ctx.lr = 0x82AADB24;
	sub_82231CB8(ctx, base);
	// 82AADB24: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 82AADB28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADB2C: 38C72B90  addi r6, r7, 0x2b90
	ctx.r[6].s64 = ctx.r[7].s64 + 11152;
	// 82AADB30: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 82AADB34: 4B718CC5  bl 0x821c67f8
	ctx.lr = 0x82AADB38;
	sub_821C67F8(ctx, base);
	// 82AADB38: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADB3C: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82AADB40: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AADB44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AADB48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AADB4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AADB50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AADB54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AADB58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADB60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AADB60 size=216
    let mut pc: u32 = 0x82AADB60;
    'dispatch: loop {
        match pc {
            0x82AADB60 => {
    //   block [0x82AADB60..0x82AADC38)
	// 82AADB60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADB64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AADB68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AADB6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AADB70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADB74: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AADB78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AADB7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADB80: 48091DE9  bl 0x82b3f968
	ctx.lr = 0x82AADB84;
	sub_82B3F968(ctx, base);
	// 82AADB84: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AADB88: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AADB8C: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82AADB90: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82AADB94: 3BCB5734  addi r30, r11, 0x5734
	ctx.r[30].s64 = ctx.r[11].s64 + 22324;
	// 82AADB98: 38885730  addi r4, r8, 0x5730
	ctx.r[4].s64 = ctx.r[8].s64 + 22320;
	// 82AADB9C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AADBA0: C02A9490  lfs f1, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AADBA4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AADBA8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AADBAC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AADBB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AADBB4: 83E95F74  lwz r31, 0x5f74(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24436 as u32) ) } as u64;
	// 82AADBB8: 480B9F59  bl 0x82b67b10
	ctx.lr = 0x82AADBBC;
	sub_82B67B10(ctx, base);
	// 82AADBBC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AADBC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADBC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AADBC8: 480B9129  bl 0x82b66cf0
	ctx.lr = 0x82AADBCC;
	sub_82B66CF0(ctx, base);
	// 82AADBCC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AADBD0: 4B718C29  bl 0x821c67f8
	ctx.lr = 0x82AADBD4;
	sub_821C67F8(ctx, base);
	// 82AADBD4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AADBD8: 4B7840E1  bl 0x82231cb8
	ctx.lr = 0x82AADBDC;
	sub_82231CB8(ctx, base);
	// 82AADBDC: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 82AADBE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADBE4: 38C72B90  addi r6, r7, 0x2b90
	ctx.r[6].s64 = ctx.r[7].s64 + 11152;
	// 82AADBE8: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 82AADBEC: 4B718C0D  bl 0x821c67f8
	ctx.lr = 0x82AADBF0;
	sub_821C67F8(ctx, base);
	// 82AADBF0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADBF4: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 82AADBF8: 7D6407B4  extsw r4, r11
	ctx.r[4].s64 = ctx.r[11].s32 as i64;
	// 82AADBFC: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82AADC00: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AADC04: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82AADC08: C80514C8  lfd f0, 0x14c8(r5)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(5320 as u32) ) };
	// 82AADC0C: FD8D002A  fadd f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 + ctx.f[0].f64;
	// 82AADC10: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82AADC14: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 82AADC18: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AADC1C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AADC20: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AADC24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AADC28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AADC2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AADC30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AADC34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADC38 size=124
    let mut pc: u32 = 0x82AADC38;
    'dispatch: loop {
        match pc {
            0x82AADC38 => {
    //   block [0x82AADC38..0x82AADC7C)
	// 82AADC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADC3C: 481FB7D1  bl 0x82ca940c
	ctx.lr = 0x82AADC40;
	sub_82CA93D0(ctx, base);
	// 82AADC40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADC44: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AADC48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AADC4C: 3BAB571C  addi r29, r11, 0x571c
	ctx.r[29].s64 = ctx.r[11].s64 + 22300;
	// 82AADC50: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADC54: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADC58: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AADC5C: 7D491E71  srawi. r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AADC60: 4182004C  beq 0x82aadcac
	if ctx.cr[0].eq {
	pc = 0x82AADCAC; continue 'dispatch;
	}
	// 82AADC64: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 82AADC68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AADC6C: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82AADC70: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82AADC74: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82AADC78: 99410053  stb r10, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[10].u8 ) };
	pc = 0x82AADC7C; continue 'dispatch;
            }
            0x82AADC7C => {
    //   block [0x82AADC7C..0x82AADCAC)
	// 82AADC7C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82AADC80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AADC84: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82AADC88: 4BFFFE21  bl 0x82aadaa8
	ctx.lr = 0x82AADC8C;
	sub_82AADAA8(ctx, base);
	// 82AADC8C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADC90: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADC94: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82AADC98: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82AADC9C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AADCA0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AADCA4: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AADCA8: 4198FFD4  blt cr6, 0x82aadc7c
	if ctx.cr[6].lt {
	pc = 0x82AADC7C; continue 'dispatch;
	}
	pc = 0x82AADCAC; continue 'dispatch;
            }
            0x82AADCAC => {
    //   block [0x82AADCAC..0x82AADCB4)
	// 82AADCAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AADCB0: 481FB7AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADCB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADCB8 size=100
    let mut pc: u32 = 0x82AADCB8;
    'dispatch: loop {
        match pc {
            0x82AADCB8 => {
    //   block [0x82AADCB8..0x82AADCF0)
	// 82AADCB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADCBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AADCC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AADCC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADCC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AADCCC: 3BEB571C  addi r31, r11, 0x571c
	ctx.r[31].s64 = ctx.r[11].s64 + 22300;
	// 82AADCD0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADCD4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AADCD8: 419A0018  beq cr6, 0x82aadcf0
	if ctx.cr[6].eq {
	pc = 0x82AADCF0; continue 'dispatch;
	}
	// 82AADCDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADCE0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADCE4: 4B9321E5  bl 0x823dfec8
	ctx.lr = 0x82AADCE8;
	sub_823DFEC8(ctx, base);
	// 82AADCE8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADCEC: 4B76E04D  bl 0x8221bd38
	ctx.lr = 0x82AADCF0;
	sub_8221BD38(ctx, base);
	pc = 0x82AADCF0; continue 'dispatch;
            }
            0x82AADCF0 => {
    //   block [0x82AADCF0..0x82AADD1C)
	// 82AADCF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AADCF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AADCF8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AADCFC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AADD00: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AADD04: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82AADD08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AADD0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AADD10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AADD14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AADD18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADD20 size=96
    let mut pc: u32 = 0x82AADD20;
    'dispatch: loop {
        match pc {
            0x82AADD20 => {
    //   block [0x82AADD20..0x82AADD48)
	// 82AADD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADD24: 481FB6E1  bl 0x82ca9404
	ctx.lr = 0x82AADD28;
	sub_82CA93D0(ctx, base);
	// 82AADD28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADD2C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AADD30: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AADD34: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82AADD38: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82AADD3C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AADD40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AADD44: 419A002C  beq cr6, 0x82aadd70
	if ctx.cr[6].eq {
	pc = 0x82AADD70; continue 'dispatch;
	}
	pc = 0x82AADD48; continue 'dispatch;
            }
            0x82AADD48 => {
    //   block [0x82AADD48..0x82AADD64)
	// 82AADD48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AADD4C: 419A0018  beq cr6, 0x82aadd64
	if ctx.cr[6].eq {
	pc = 0x82AADD64; continue 'dispatch;
	}
	// 82AADD50: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADD54: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 82AADD58: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82AADD5C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AADD60: 4B7424E1  bl 0x821f0240
	ctx.lr = 0x82AADD64;
	sub_821F0240(ctx, base);
	pc = 0x82AADD64; continue 'dispatch;
            }
            0x82AADD64 => {
    //   block [0x82AADD64..0x82AADD70)
	// 82AADD64: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AADD68: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AADD6C: 4082FFDC  bne 0x82aadd48
	if !ctx.cr[0].eq {
	pc = 0x82AADD48; continue 'dispatch;
	}
	pc = 0x82AADD70; continue 'dispatch;
            }
            0x82AADD70 => {
    //   block [0x82AADD70..0x82AADD80)
	// 82AADD70: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AADD74: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82AADD78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AADD7C: 481FB6D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADD80 size=632
    let mut pc: u32 = 0x82AADD80;
    'dispatch: loop {
        match pc {
            0x82AADD80 => {
    //   block [0x82AADD80..0x82AADDC0)
	// 82AADD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADD84: 481FB685  bl 0x82ca9408
	ctx.lr = 0x82AADD88;
	sub_82CA93D0(ctx, base);
	// 82AADD88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADD8C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADD90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AADD94: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 82AADD98: 38860004  addi r4, r6, 4
	ctx.r[4].s64 = ctx.r[6].s64 + 4;
	// 82AADD9C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AADDA0: 4B7424A1  bl 0x821f0240
	ctx.lr = 0x82AADDA4;
	sub_821F0240(ctx, base);
	// 82AADDA4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AADDA8: 3BEB571C  addi r31, r11, 0x571c
	ctx.r[31].s64 = ctx.r[11].s64 + 22300;
	// 82AADDAC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADDB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AADDB4: 409A000C  bne cr6, 0x82aaddc0
	if !ctx.cr[6].eq {
	pc = 0x82AADDC0; continue 'dispatch;
	}
	// 82AADDB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AADDBC: 48000010  b 0x82aaddcc
	pc = 0x82AADDCC; continue 'dispatch;
            }
            0x82AADDC0 => {
    //   block [0x82AADDC0..0x82AADDCC)
	// 82AADDC0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AADDC4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AADDC8: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82AADDCC; continue 'dispatch;
            }
            0x82AADDCC => {
    //   block [0x82AADDCC..0x82AADE00)
	// 82AADDCC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADDD0: 3D201FFF  lis r9, 0x1fff
	ctx.r[9].s64 = 536805376;
	// 82AADDD4: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82AADDD8: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 82AADDDC: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82AADDE0: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82AADDE4: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 82AADDE8: 40980018  bge cr6, 0x82aade00
	if !ctx.cr[6].lt {
	pc = 0x82AADE00; continue 'dispatch;
	}
	// 82AADDEC: 4BF996DD  bl 0x82a474c8
	ctx.lr = 0x82AADDF0;
	sub_82A474C8(ctx, base);
	// 82AADDF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AADDF4: 4B766FE5  bl 0x82214dd8
	ctx.lr = 0x82AADDF8;
	sub_82214DD8(ctx, base);
	// 82AADDF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AADDFC: 481FB65C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AADE00 => {
    //   block [0x82AADE00..0x82AADE2C)
	// 82AADE00: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82AADE04: 7D081E70  srawi r8, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82AADE08: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 82AADE0C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AADE10: 409800E4  bge cr6, 0x82aadef4
	if !ctx.cr[6].lt {
	pc = 0x82AADEF4; continue 'dispatch;
	}
	// 82AADE14: 5548F87E  srwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AADE18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AADE1C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82AADE20: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AADE24: 41980008  blt cr6, 0x82aade2c
	if ctx.cr[6].lt {
	pc = 0x82AADE2C; continue 'dispatch;
	}
	// 82AADE28: 7FA85214  add r29, r8, r10
	ctx.r[29].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	pc = 0x82AADE2C; continue 'dispatch;
            }
            0x82AADE2C => {
    //   block [0x82AADE2C..0x82AADE4C)
	// 82AADE2C: 7D4B2850  subf r10, r11, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82AADE30: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AADE34: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82AADE38: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AADE3C: 40980010  bge cr6, 0x82aade4c
	if !ctx.cr[6].lt {
	pc = 0x82AADE4C; continue 'dispatch;
	}
	// 82AADE40: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82AADE44: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AADE48: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	pc = 0x82AADE4C; continue 'dispatch;
            }
            0x82AADE4C => {
    //   block [0x82AADE4C..0x82AADEC8)
	// 82AADE4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADE50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AADE54: 48002B05  bl 0x82ab0958
	ctx.lr = 0x82AADE58;
	sub_82AB0958(ctx, base);
	// 82AADE58: 8381009C  lwz r28, 0x9c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AADE5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AADE60: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADE68: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AADE6C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AADE70: 480006E1  bl 0x82aae550
	ctx.lr = 0x82AADE74;
	sub_82AAE550(ctx, base);
	// 82AADE74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AADE78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADE7C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AADE80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AADE84: 4BFFFE9D  bl 0x82aadd20
	ctx.lr = 0x82AADE88;
	sub_82AADD20(ctx, base);
	// 82AADE88: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AADE8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADE90: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADE94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AADE98: 480006B9  bl 0x82aae550
	ctx.lr = 0x82AADE9C;
	sub_82AAE550(ctx, base);
	// 82AADE9C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADEA0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADEA4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AADEA8: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82AADEAC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AADEB0: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 82AADEB4: 419A0014  beq cr6, 0x82aadec8
	if ctx.cr[6].eq {
	pc = 0x82AADEC8; continue 'dispatch;
	}
	// 82AADEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADEBC: 4B93200D  bl 0x823dfec8
	ctx.lr = 0x82AADEC0;
	sub_823DFEC8(ctx, base);
	// 82AADEC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADEC4: 4B76DE75  bl 0x8221bd38
	ctx.lr = 0x82AADEC8;
	sub_8221BD38(ctx, base);
	pc = 0x82AADEC8; continue 'dispatch;
            }
            0x82AADEC8 => {
    //   block [0x82AADEC8..0x82AADEF4)
	// 82AADEC8: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AADECC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AADED0: 578A1838  slwi r10, r28, 3
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AADED4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AADED8: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82AADEDC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AADEE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AADEE4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AADEE8: 4B766EF1  bl 0x82214dd8
	ctx.lr = 0x82AADEEC;
	sub_82214DD8(ctx, base);
	// 82AADEEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AADEF0: 481FB568  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AADEF4 => {
    //   block [0x82AADEF4..0x82AADF50)
	// 82AADEF4: 83C1009C  lwz r30, 0x9c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AADEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADEFC: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 82AADF00: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AADF04: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82AADF08: 40980074  bge cr6, 0x82aadf7c
	if !ctx.cr[6].lt {
	pc = 0x82AADF7C; continue 'dispatch;
	}
	// 82AADF0C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82AADF10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AADF14: 4800063D  bl 0x82aae550
	ctx.lr = 0x82AADF18;
	sub_82AAE550(ctx, base);
	// 82AADF18: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADF1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADF20: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82AADF24: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AADF28: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AADF2C: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82AADF30: 4BFFFDF1  bl 0x82aadd20
	ctx.lr = 0x82AADF34;
	sub_82AADD20(ctx, base);
	// 82AADF34: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADF38: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AADF3C: 3BABFFF8  addi r29, r11, -8
	ctx.r[29].s64 = ctx.r[11].s64 + -8;
	// 82AADF40: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AADF44: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AADF48: 419A00A0  beq cr6, 0x82aadfe8
	if ctx.cr[6].eq {
	pc = 0x82AADFE8; continue 'dispatch;
	}
	// 82AADF4C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82AADF50; continue 'dispatch;
            }
            0x82AADF50 => {
    //   block [0x82AADF50..0x82AADF7C)
	// 82AADF50: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AADF54: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AADF58: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82AADF5C: 4B7B7245  bl 0x822651a0
	ctx.lr = 0x82AADF60;
	sub_822651A0(ctx, base);
	// 82AADF60: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82AADF64: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AADF68: 409AFFE8  bne cr6, 0x82aadf50
	if !ctx.cr[6].eq {
	pc = 0x82AADF50; continue 'dispatch;
	}
	// 82AADF6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AADF70: 4B766E69  bl 0x82214dd8
	ctx.lr = 0x82AADF74;
	sub_82214DD8(ctx, base);
	// 82AADF74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AADF78: 481FB4E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AADF7C => {
    //   block [0x82AADF7C..0x82AADF98)
	// 82AADF7C: 3BA5FFF8  addi r29, r5, -8
	ctx.r[29].s64 = ctx.r[5].s64 + -8;
	// 82AADF80: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82AADF84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AADF88: 480005C9  bl 0x82aae550
	ctx.lr = 0x82AADF8C;
	sub_82AAE550(ctx, base);
	// 82AADF8C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AADF90: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AADF94: 419A0024  beq cr6, 0x82aadfb8
	if ctx.cr[6].eq {
	pc = 0x82AADFB8; continue 'dispatch;
	}
	pc = 0x82AADF98; continue 'dispatch;
            }
            0x82AADF98 => {
    //   block [0x82AADF98..0x82AADFB8)
	// 82AADF98: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 82AADF9C: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82AADFA0: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 82AADFA4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADFA8: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AADFAC: 4B7B71F5  bl 0x822651a0
	ctx.lr = 0x82AADFB0;
	sub_822651A0(ctx, base);
	// 82AADFB0: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AADFB4: 409AFFE4  bne cr6, 0x82aadf98
	if !ctx.cr[6].eq {
	pc = 0x82AADF98; continue 'dispatch;
	}
	pc = 0x82AADFB8; continue 'dispatch;
            }
            0x82AADFB8 => {
    //   block [0x82AADFB8..0x82AADFCC)
	// 82AADFB8: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82AADFBC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82AADFC0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AADFC4: 419A0024  beq cr6, 0x82aadfe8
	if ctx.cr[6].eq {
	pc = 0x82AADFE8; continue 'dispatch;
	}
	// 82AADFC8: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82AADFCC; continue 'dispatch;
            }
            0x82AADFCC => {
    //   block [0x82AADFCC..0x82AADFE8)
	// 82AADFCC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AADFD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AADFD4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82AADFD8: 4B7B71C9  bl 0x822651a0
	ctx.lr = 0x82AADFDC;
	sub_822651A0(ctx, base);
	// 82AADFDC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AADFE0: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AADFE4: 409AFFE8  bne cr6, 0x82aadfcc
	if !ctx.cr[6].eq {
	pc = 0x82AADFCC; continue 'dispatch;
	}
	pc = 0x82AADFE8; continue 'dispatch;
            }
            0x82AADFE8 => {
    //   block [0x82AADFE8..0x82AADFF8)
	// 82AADFE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AADFEC: 4B766DED  bl 0x82214dd8
	ctx.lr = 0x82AADFF0;
	sub_82214DD8(ctx, base);
	// 82AADFF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AADFF4: 481FB464  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADFF8 size=268
    let mut pc: u32 = 0x82AADFF8;
    'dispatch: loop {
        match pc {
            0x82AADFF8 => {
    //   block [0x82AADFF8..0x82AAE030)
	// 82AADFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADFFC: 481FB409  bl 0x82ca9404
	ctx.lr = 0x82AAE000;
	sub_82CA93D0(ctx, base);
	// 82AAE000: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE004: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAE008: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82AAE00C: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AAE010: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAE014: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82AAE018: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AAE01C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE020: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE024: 419A000C  beq cr6, 0x82aae030
	if ctx.cr[6].eq {
	pc = 0x82AAE030; continue 'dispatch;
	}
	// 82AAE028: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AAE02C: 419A0008  beq cr6, 0x82aae034
	if ctx.cr[6].eq {
	pc = 0x82AAE034; continue 'dispatch;
	}
	pc = 0x82AAE030; continue 'dispatch;
            }
            0x82AAE030 => {
    //   block [0x82AAE030..0x82AAE034)
	// 82AAE030: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AAE034; continue 'dispatch;
            }
            0x82AAE034 => {
    //   block [0x82AAE034..0x82AAE058)
	// 82AAE034: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AAE038: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AAE03C: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82AAE040: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAE044: 409A0068  bne cr6, 0x82aae0ac
	if !ctx.cr[6].eq {
	pc = 0x82AAE0AC; continue 'dispatch;
	}
	// 82AAE048: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AAE04C: 419A000C  beq cr6, 0x82aae058
	if ctx.cr[6].eq {
	pc = 0x82AAE058; continue 'dispatch;
	}
	// 82AAE050: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AAE054: 419A0008  beq cr6, 0x82aae05c
	if ctx.cr[6].eq {
	pc = 0x82AAE05C; continue 'dispatch;
	}
	pc = 0x82AAE058; continue 'dispatch;
            }
            0x82AAE058 => {
    //   block [0x82AAE058..0x82AAE05C)
	// 82AAE058: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AAE05C; continue 'dispatch;
            }
            0x82AAE05C => {
    //   block [0x82AAE05C..0x82AAE0AC)
	// 82AAE05C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AAE060: 409A004C  bne cr6, 0x82aae0ac
	if !ctx.cr[6].eq {
	pc = 0x82AAE0AC; continue 'dispatch;
	}
	// 82AAE064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAE068: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE06C: 4BFDBCBD  bl 0x82a89d28
	ctx.lr = 0x82AAE070;
	sub_82A89D28(ctx, base);
	// 82AAE070: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE074: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAE078: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AAE07C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAE080: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAE084: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE088: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AAE08C: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AAE090: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE094: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82AAE098: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE09C: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE0A0: 90DD0004  stw r6, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAE0A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAE0A8: 481FB3AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AAE0AC => {
    //   block [0x82AAE0AC..0x82AAE0BC)
	// 82AAE0AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AAE0B0: 419A000C  beq cr6, 0x82aae0bc
	if ctx.cr[6].eq {
	pc = 0x82AAE0BC; continue 'dispatch;
	}
	// 82AAE0B4: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AAE0B8: 419A0008  beq cr6, 0x82aae0c0
	if ctx.cr[6].eq {
	pc = 0x82AAE0C0; continue 'dispatch;
	}
	pc = 0x82AAE0BC; continue 'dispatch;
            }
            0x82AAE0BC => {
    //   block [0x82AAE0BC..0x82AAE0C0)
	// 82AAE0BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AAE0C0; continue 'dispatch;
            }
            0x82AAE0C0 => {
    //   block [0x82AAE0C0..0x82AAE0F4)
	// 82AAE0C0: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AAE0C4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AAE0C8: 419A002C  beq cr6, 0x82aae0f4
	if ctx.cr[6].eq {
	pc = 0x82AAE0F4; continue 'dispatch;
	}
	// 82AAE0CC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AAE0D0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82AAE0D4: 4BAA8785  bl 0x82556858
	ctx.lr = 0x82AAE0D8;
	sub_82556858(ctx, base);
	// 82AAE0D8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AAE0DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAE0E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAE0E4: 48000025  bl 0x82aae108
	ctx.lr = 0x82AAE0E8;
	sub_82AAE108(ctx, base);
	// 82AAE0E8: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82AAE0EC: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AAE0F0: 4BFFFFBC  b 0x82aae0ac
	pc = 0x82AAE0AC; continue 'dispatch;
            }
            0x82AAE0F4 => {
    //   block [0x82AAE0F4..0x82AAE104)
	// 82AAE0F4: F8BD0000  std r5, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82AAE0F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAE0FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAE100: 481FB354  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAE108 size=1096
    let mut pc: u32 = 0x82AAE108;
    'dispatch: loop {
        match pc {
            0x82AAE108 => {
    //   block [0x82AAE108..0x82AAE174)
	// 82AAE108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE10C: 481FB2F1  bl 0x82ca93fc
	ctx.lr = 0x82AAE110;
	sub_82CA93D0(ctx, base);
	// 82AAE110: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE114: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82AAE118: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AAE11C: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AAE120: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AAE124: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAE12C: 419A0048  beq cr6, 0x82aae174
	if ctx.cr[6].eq {
	pc = 0x82AAE174; continue 'dispatch;
	}
	// 82AAE130: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AAE134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAE138: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82AAE13C: 4B843E05  bl 0x822f1f40
	ctx.lr = 0x82AAE140;
	sub_822F1F40(ctx, base);
	// 82AAE140: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAE144: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAE148: 4B843C69  bl 0x822f1db0
	ctx.lr = 0x82AAE14C;
	sub_822F1DB0(ctx, base);
	// 82AAE14C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AAE150: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAE154: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82AAE158: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AAE15C: 4B843CC5  bl 0x822f1e20
	ctx.lr = 0x82AAE160;
	sub_822F1E20(ctx, base);
	// 82AAE160: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AAE164: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAE168: 4BBCD679  bl 0x8267b7e0
	ctx.lr = 0x82AAE16C;
	sub_8267B7E0(ctx, base);
	// 82AAE16C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAE170: 4B6C36A1  bl 0x82171810
	ctx.lr = 0x82AAE174;
	sub_82171810(ctx, base);
	pc = 0x82AAE174; continue 'dispatch;
            }
            0x82AAE174 => {
    //   block [0x82AAE174..0x82AAE198)
	// 82AAE174: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AAE178: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82AAE17C: 4BAA86DD  bl 0x82556858
	ctx.lr = 0x82AAE180;
	sub_82556858(ctx, base);
	// 82AAE180: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE184: 896A0015  lbz r11, 0x15(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAE18C: 419A000C  beq cr6, 0x82aae198
	if ctx.cr[6].eq {
	pc = 0x82AAE198; continue 'dispatch;
	}
	// 82AAE190: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE194: 4800002C  b 0x82aae1c0
	pc = 0x82AAE1C0; continue 'dispatch;
            }
            0x82AAE198 => {
    //   block [0x82AAE198..0x82AAE1B0)
	// 82AAE198: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE19C: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE1A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AAE1A4: 419A000C  beq cr6, 0x82aae1b0
	if ctx.cr[6].eq {
	pc = 0x82AAE1B0; continue 'dispatch;
	}
	// 82AAE1A8: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82AAE1AC: 48000014  b 0x82aae1c0
	pc = 0x82AAE1C0; continue 'dispatch;
            }
            0x82AAE1B0 => {
    //   block [0x82AAE1B0..0x82AAE1C0)
	// 82AAE1B0: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AAE1B4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AAE1B8: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE1BC: 409A00F0  bne cr6, 0x82aae2ac
	if !ctx.cr[6].eq {
	pc = 0x82AAE2AC; continue 'dispatch;
	}
	pc = 0x82AAE1C0; continue 'dispatch;
            }
            0x82AAE1C0 => {
    //   block [0x82AAE1C0..0x82AAE1D4)
	// 82AAE1C0: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE1C4: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAE1CC: 409A0008  bne cr6, 0x82aae1d4
	if !ctx.cr[6].eq {
	pc = 0x82AAE1D4; continue 'dispatch;
	}
	// 82AAE1D0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82AAE1D4; continue 'dispatch;
            }
            0x82AAE1D4 => {
    //   block [0x82AAE1D4..0x82AAE1EC)
	// 82AAE1D4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE1D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE1DC: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AAE1E0: 409A000C  bne cr6, 0x82aae1ec
	if !ctx.cr[6].eq {
	pc = 0x82AAE1EC; continue 'dispatch;
	}
	// 82AAE1E4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AAE1E8: 4800001C  b 0x82aae204
	pc = 0x82AAE204; continue 'dispatch;
            }
            0x82AAE1EC => {
    //   block [0x82AAE1EC..0x82AAE200)
	// 82AAE1EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE1F0: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AAE1F4: 409A000C  bne cr6, 0x82aae200
	if !ctx.cr[6].eq {
	pc = 0x82AAE200; continue 'dispatch;
	}
	// 82AAE1F8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82AAE1FC: 48000008  b 0x82aae204
	pc = 0x82AAE204; continue 'dispatch;
            }
            0x82AAE200 => {
    //   block [0x82AAE200..0x82AAE204)
	// 82AAE200: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82AAE204; continue 'dispatch;
            }
            0x82AAE204 => {
    //   block [0x82AAE204..0x82AAE228)
	// 82AAE204: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE208: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE20C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AAE210: 409A0044  bne cr6, 0x82aae254
	if !ctx.cr[6].eq {
	pc = 0x82AAE254; continue 'dispatch;
	}
	// 82AAE214: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAE21C: 419A000C  beq cr6, 0x82aae228
	if ctx.cr[6].eq {
	pc = 0x82AAE228; continue 'dispatch;
	}
	// 82AAE220: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82AAE224: 4800002C  b 0x82aae250
	pc = 0x82AAE250; continue 'dispatch;
            }
            0x82AAE228 => {
    //   block [0x82AAE228..0x82AAE23C)
	// 82AAE228: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE22C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82AAE230: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE234: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAE238: 409A0018  bne cr6, 0x82aae250
	if !ctx.cr[6].eq {
	pc = 0x82AAE250; continue 'dispatch;
	}
	pc = 0x82AAE23C; continue 'dispatch;
            }
            0x82AAE23C => {
    //   block [0x82AAE23C..0x82AAE250)
	// 82AAE23C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82AAE240: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE244: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE248: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAE24C: 419AFFF0  beq cr6, 0x82aae23c
	if ctx.cr[6].eq {
	pc = 0x82AAE23C; continue 'dispatch;
	}
	pc = 0x82AAE250; continue 'dispatch;
            }
            0x82AAE250 => {
    //   block [0x82AAE250..0x82AAE254)
	// 82AAE250: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82AAE254; continue 'dispatch;
            }
            0x82AAE254 => {
    //   block [0x82AAE254..0x82AAE27C)
	// 82AAE254: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE258: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE25C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AAE260: 409A00E0  bne cr6, 0x82aae340
	if !ctx.cr[6].eq {
	pc = 0x82AAE340; continue 'dispatch;
	}
	// 82AAE264: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAE26C: 419A0010  beq cr6, 0x82aae27c
	if ctx.cr[6].eq {
	pc = 0x82AAE27C; continue 'dispatch;
	}
	// 82AAE270: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82AAE274: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAE278: 480000C8  b 0x82aae340
	pc = 0x82AAE340; continue 'dispatch;
            }
            0x82AAE27C => {
    //   block [0x82AAE27C..0x82AAE290)
	// 82AAE27C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE280: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82AAE284: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE288: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAE28C: 409A0018  bne cr6, 0x82aae2a4
	if !ctx.cr[6].eq {
	pc = 0x82AAE2A4; continue 'dispatch;
	}
	pc = 0x82AAE290; continue 'dispatch;
            }
            0x82AAE290 => {
    //   block [0x82AAE290..0x82AAE2A4)
	// 82AAE290: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82AAE294: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE298: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE29C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AAE2A0: 419AFFF0  beq cr6, 0x82aae290
	if ctx.cr[6].eq {
	pc = 0x82AAE290; continue 'dispatch;
	}
	pc = 0x82AAE2A4; continue 'dispatch;
            }
            0x82AAE2A4 => {
    //   block [0x82AAE2A4..0x82AAE2AC)
	// 82AAE2A4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAE2A8: 48000098  b 0x82aae340
	pc = 0x82AAE340; continue 'dispatch;
            }
            0x82AAE2AC => {
    //   block [0x82AAE2AC..0x82AAE2CC)
	// 82AAE2AC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AAE2B0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE2B4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAE2B8: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE2BC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AAE2C0: 409A000C  bne cr6, 0x82aae2cc
	if !ctx.cr[6].eq {
	pc = 0x82AAE2CC; continue 'dispatch;
	}
	// 82AAE2C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82AAE2C8: 4800002C  b 0x82aae2f4
	pc = 0x82AAE2F4; continue 'dispatch;
            }
            0x82AAE2CC => {
    //   block [0x82AAE2CC..0x82AAE2E0)
	// 82AAE2CC: 895C0015  lbz r10, 0x15(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE2D0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE2D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAE2D8: 409A0008  bne cr6, 0x82aae2e0
	if !ctx.cr[6].eq {
	pc = 0x82AAE2E0; continue 'dispatch;
	}
	// 82AAE2DC: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82AAE2E0; continue 'dispatch;
            }
            0x82AAE2E0 => {
    //   block [0x82AAE2E0..0x82AAE2F4)
	// 82AAE2E0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82AAE2E4: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE2E8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAE2EC: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE2F0: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82AAE2F4; continue 'dispatch;
            }
            0x82AAE2F4 => {
    //   block [0x82AAE2F4..0x82AAE30C)
	// 82AAE2F4: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE2F8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE2FC: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AAE300: 409A000C  bne cr6, 0x82aae30c
	if !ctx.cr[6].eq {
	pc = 0x82AAE30C; continue 'dispatch;
	}
	// 82AAE304: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AAE308: 48000020  b 0x82aae328
	pc = 0x82AAE328; continue 'dispatch;
            }
            0x82AAE30C => {
    //   block [0x82AAE30C..0x82AAE324)
	// 82AAE30C: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE310: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE314: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AAE318: 409A000C  bne cr6, 0x82aae324
	if !ctx.cr[6].eq {
	pc = 0x82AAE324; continue 'dispatch;
	}
	// 82AAE31C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAE320: 48000008  b 0x82aae328
	pc = 0x82AAE328; continue 'dispatch;
            }
            0x82AAE324 => {
    //   block [0x82AAE324..0x82AAE328)
	// 82AAE324: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82AAE328; continue 'dispatch;
            }
            0x82AAE328 => {
    //   block [0x82AAE328..0x82AAE340)
	// 82AAE328: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE32C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAE330: 890B0014  lbz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE334: 893A0014  lbz r9, 0x14(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE338: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 82AAE33C: 991A0014  stb r8, 0x14(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAE340; continue 'dispatch;
            }
            0x82AAE340 => {
    //   block [0x82AAE340..0x82AAE364)
	// 82AAE340: 897A0014  lbz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE344: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AAE348: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AAE34C: 409A0194  bne cr6, 0x82aae4e0
	if !ctx.cr[6].eq {
	pc = 0x82AAE4E0; continue 'dispatch;
	}
	// 82AAE350: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE354: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AAE358: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE35C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAE360: 419A017C  beq cr6, 0x82aae4dc
	if ctx.cr[6].eq {
	pc = 0x82AAE4DC; continue 'dispatch;
	}
	pc = 0x82AAE364; continue 'dispatch;
            }
            0x82AAE364 => {
    //   block [0x82AAE364..0x82AAE3A4)
	// 82AAE364: 897C0014  lbz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE368: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AAE36C: 409A0170  bne cr6, 0x82aae4dc
	if !ctx.cr[6].eq {
	pc = 0x82AAE4DC; continue 'dispatch;
	}
	// 82AAE370: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE374: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AAE378: 409A00A8  bne cr6, 0x82aae420
	if !ctx.cr[6].eq {
	pc = 0x82AAE420; continue 'dispatch;
	}
	// 82AAE37C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE380: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE384: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAE388: 409A001C  bne cr6, 0x82aae3a4
	if !ctx.cr[6].eq {
	pc = 0x82AAE3A4; continue 'dispatch;
	}
	// 82AAE38C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AAE390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAE394: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AAE398: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AAE39C: 4BF0A1C5  bl 0x829b8560
	ctx.lr = 0x82AAE3A0;
	sub_829B8560(ctx, base);
	// 82AAE3A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AAE3A4; continue 'dispatch;
            }
            0x82AAE3A4 => {
    //   block [0x82AAE3A4..0x82AAE3D0)
	// 82AAE3A4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE3A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAE3AC: 409A00C8  bne cr6, 0x82aae474
	if !ctx.cr[6].eq {
	pc = 0x82AAE474; continue 'dispatch;
	}
	// 82AAE3B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE3B4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE3B8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AAE3BC: 409A0014  bne cr6, 0x82aae3d0
	if !ctx.cr[6].eq {
	pc = 0x82AAE3D0; continue 'dispatch;
	}
	// 82AAE3C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE3C4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE3C8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AAE3CC: 419A00A4  beq cr6, 0x82aae470
	if ctx.cr[6].eq {
	pc = 0x82AAE470; continue 'dispatch;
	}
	pc = 0x82AAE3D0; continue 'dispatch;
            }
            0x82AAE3D0 => {
    //   block [0x82AAE3D0..0x82AAE3FC)
	// 82AAE3D0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE3D4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE3D8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AAE3DC: 409A0020  bne cr6, 0x82aae3fc
	if !ctx.cr[6].eq {
	pc = 0x82AAE3FC; continue 'dispatch;
	}
	// 82AAE3E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE3E4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82AAE3E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AAE3EC: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AAE3F0: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AAE3F4: 4B85AA15  bl 0x82308e08
	ctx.lr = 0x82AAE3F8;
	sub_82308E08(ctx, base);
	// 82AAE3F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AAE3FC; continue 'dispatch;
            }
            0x82AAE3FC => {
    //   block [0x82AAE3FC..0x82AAE420)
	// 82AAE3FC: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAE404: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AAE408: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82AAE40C: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AAE410: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE414: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AAE418: 4BF0A149  bl 0x829b8560
	ctx.lr = 0x82AAE41C;
	sub_829B8560(ctx, base);
	// 82AAE41C: 480000C0  b 0x82aae4dc
	pc = 0x82AAE4DC; continue 'dispatch;
            }
            0x82AAE420 => {
    //   block [0x82AAE420..0x82AAE444)
	// 82AAE420: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE424: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAE428: 409A001C  bne cr6, 0x82aae444
	if !ctx.cr[6].eq {
	pc = 0x82AAE444; continue 'dispatch;
	}
	// 82AAE42C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AAE430: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAE434: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AAE438: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AAE43C: 4B85A9CD  bl 0x82308e08
	ctx.lr = 0x82AAE440;
	sub_82308E08(ctx, base);
	// 82AAE440: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AAE444; continue 'dispatch;
            }
            0x82AAE444 => {
    //   block [0x82AAE444..0x82AAE470)
	// 82AAE444: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AAE448: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAE44C: 409A0028  bne cr6, 0x82aae474
	if !ctx.cr[6].eq {
	pc = 0x82AAE474; continue 'dispatch;
	}
	// 82AAE450: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE454: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE458: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AAE45C: 409A0034  bne cr6, 0x82aae490
	if !ctx.cr[6].eq {
	pc = 0x82AAE490; continue 'dispatch;
	}
	// 82AAE460: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE464: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE468: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AAE46C: 409A0024  bne cr6, 0x82aae490
	if !ctx.cr[6].eq {
	pc = 0x82AAE490; continue 'dispatch;
	}
	pc = 0x82AAE470; continue 'dispatch;
            }
            0x82AAE470 => {
    //   block [0x82AAE470..0x82AAE474)
	// 82AAE470: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	pc = 0x82AAE474; continue 'dispatch;
            }
            0x82AAE474 => {
    //   block [0x82AAE474..0x82AAE490)
	// 82AAE474: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE478: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82AAE47C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE480: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE484: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAE488: 409AFEDC  bne cr6, 0x82aae364
	if !ctx.cr[6].eq {
	pc = 0x82AAE364; continue 'dispatch;
	}
	// 82AAE48C: 48000050  b 0x82aae4dc
	pc = 0x82AAE4DC; continue 'dispatch;
            }
            0x82AAE490 => {
    //   block [0x82AAE490..0x82AAE4BC)
	// 82AAE490: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE494: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE498: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AAE49C: 409A0020  bne cr6, 0x82aae4bc
	if !ctx.cr[6].eq {
	pc = 0x82AAE4BC; continue 'dispatch;
	}
	// 82AAE4A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE4A4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82AAE4A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AAE4AC: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AAE4B0: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AAE4B4: 4BF0A0AD  bl 0x829b8560
	ctx.lr = 0x82AAE4B8;
	sub_829B8560(ctx, base);
	// 82AAE4B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AAE4BC; continue 'dispatch;
            }
            0x82AAE4BC => {
    //   block [0x82AAE4BC..0x82AAE4DC)
	// 82AAE4BC: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAE4C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAE4C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AAE4C8: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82AAE4CC: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AAE4D0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE4D4: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AAE4D8: 4B85A931  bl 0x82308e08
	ctx.lr = 0x82AAE4DC;
	sub_82308E08(ctx, base);
	pc = 0x82AAE4DC; continue 'dispatch;
            }
            0x82AAE4DC => {
    //   block [0x82AAE4DC..0x82AAE4E0)
	// 82AAE4DC: 9BBC0014  stb r29, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	pc = 0x82AAE4E0; continue 'dispatch;
            }
            0x82AAE4E0 => {
    //   block [0x82AAE4E0..0x82AAE4F0)
	// 82AAE4E0: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 82AAE4E4: 4B718285  bl 0x821c6768
	ctx.lr = 0x82AAE4E8;
	sub_821C6768(ctx, base);
	// 82AAE4E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAE4EC: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x82AAE4F0; continue 'dispatch;
            }
            0x82AAE4F0 => {
    //   block [0x82AAE4F0..0x82AAE540)
	// 82AAE4F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAE4F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAE4F8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAE4FC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AAE500: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAE504: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAE508: 4082FFE8  bne 0x82aae4f0
	if !ctx.cr[0].eq {
	pc = 0x82AAE4F0; continue 'dispatch;
	}
	// 82AAE50C: 93DA0010  stw r30, 0x10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82AAE510: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAE514: 4B76D825  bl 0x8221bd38
	ctx.lr = 0x82AAE518;
	sub_8221BD38(ctx, base);
	// 82AAE518: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE51C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AAE520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAE524: 419A001C  beq cr6, 0x82aae540
	if ctx.cr[6].eq {
	pc = 0x82AAE540; continue 'dispatch;
	}
	// 82AAE528: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82AAE52C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82AAE530: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82AAE534: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82AAE538: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AAE53C: 481FAF10  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AAE540 => {
    //   block [0x82AAE540..0x82AAE550)
	// 82AAE540: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82AAE544: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AAE548: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AAE54C: 481FAF00  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAE550 size=88
    let mut pc: u32 = 0x82AAE550;
    'dispatch: loop {
        match pc {
            0x82AAE550 => {
    //   block [0x82AAE550..0x82AAE570)
	// 82AAE550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE554: 481FAEB9  bl 0x82ca940c
	ctx.lr = 0x82AAE558;
	sub_82CA93D0(ctx, base);
	// 82AAE558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE55C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AAE560: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82AAE564: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AAE568: 419A0034  beq cr6, 0x82aae59c
	if ctx.cr[6].eq {
	pc = 0x82AAE59C; continue 'dispatch;
	}
	// 82AAE56C: 7FDF2050  subf r30, r31, r4
	ctx.r[30].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	pc = 0x82AAE570; continue 'dispatch;
            }
            0x82AAE570 => {
    //   block [0x82AAE570..0x82AAE58C)
	// 82AAE570: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAE574: 419A0018  beq cr6, 0x82aae58c
	if ctx.cr[6].eq {
	pc = 0x82AAE58C; continue 'dispatch;
	}
	// 82AAE578: 7D7EF82E  lwzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AAE57C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82AAE580: 7C9E1A14  add r4, r30, r3
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[3].u64;
	// 82AAE584: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAE588: 4B741CB9  bl 0x821f0240
	ctx.lr = 0x82AAE58C;
	sub_821F0240(ctx, base);
	pc = 0x82AAE58C; continue 'dispatch;
            }
            0x82AAE58C => {
    //   block [0x82AAE58C..0x82AAE59C)
	// 82AAE58C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AAE590: 7D7EFA14  add r11, r30, r31
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 82AAE594: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AAE598: 409AFFD8  bne cr6, 0x82aae570
	if !ctx.cr[6].eq {
	pc = 0x82AAE570; continue 'dispatch;
	}
	pc = 0x82AAE59C; continue 'dispatch;
            }
            0x82AAE59C => {
    //   block [0x82AAE59C..0x82AAE5A8)
	// 82AAE59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAE5A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAE5A4: 481FAEB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAE5A8 size=1404
    let mut pc: u32 = 0x82AAE5A8;
    'dispatch: loop {
        match pc {
            0x82AAE5A8 => {
    //   block [0x82AAE5A8..0x82AAE6B8)
	// 82AAE5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE5AC: 481FAE59  bl 0x82ca9404
	ctx.lr = 0x82AAE5B0;
	sub_82CA93D0(ctx, base);
	// 82AAE5B0: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82AAE5B4: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82AAE5B8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE5BC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82AAE5C0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AAE5C4: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 82AAE5C8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82AAE5CC: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 82AAE5D0: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 82AAE5D4: 3CC0834C  lis r6, -0x7cb4
	ctx.r[6].s64 = -2092171264;
	// 82AAE5D8: 38FF2008  addi r7, r31, 0x2008
	ctx.r[7].s64 = ctx.r[31].s64 + 8200;
	// 82AAE5DC: 38A6DF40  addi r5, r6, -0x20c0
	ctx.r[5].s64 = ctx.r[6].s64 + -8384;
	// 82AAE5E0: 817F2004  lwz r11, 0x2004(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AAE5E4: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 82AAE5E8: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 82AAE5EC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AAE5F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAE5F4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82AAE5F8: 3860005D  li r3, 0x5d
	ctx.r[3].s64 = 93;
	// 82AAE5FC: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82AAE600: 7D0BF92E  stwx r8, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[8].u32) };
	// 82AAE604: 815F2004  lwz r10, 0x2004(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82AAE608: 813F2000  lwz r9, 0x2000(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82AAE60C: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 82AAE610: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82AAE614: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82AAE618: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AAE61C: 917F2004  stw r11, 0x2004(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8196 as u32), ctx.r[11].u32 ) };
	// 82AAE620: 915F2000  stw r10, 0x2000(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 82AAE624: 7D06392E  stwx r8, r6, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 82AAE628: 813F400C  lwz r9, 0x400c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 82AAE62C: 811F4008  lwz r8, 0x4008(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16392 as u32) ) } as u64;
	// 82AAE630: 8145003C  lwz r10, 0x3c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AAE634: 817D0364  lwz r11, 0x364(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AAE638: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82AAE63C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AAE640: 914470B8  stw r10, 0x70b8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 82AAE644: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AAE648: 913F400C  stw r9, 0x400c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16396 as u32), ctx.r[9].u32 ) };
	// 82AAE64C: 911F4008  stw r8, 0x4008(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16392 as u32), ctx.r[8].u32 ) };
	// 82AAE650: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 82AAE654: E8850010  ld r4, 0x10(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	// 82AAE658: 648B0008  oris r11, r4, 8
	ctx.r[11].u64 = ctx.r[4].u64 | 524288;
	// 82AAE65C: F9650010  std r11, 0x10(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82AAE660: 4B77DBB1  bl 0x8222c210
	ctx.lr = 0x82AAE664;
	sub_8222C210(ctx, base);
	// 82AAE664: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE668: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAE66C: 419A004C  beq cr6, 0x82aae6b8
	if ctx.cr[6].eq {
	pc = 0x82AAE6B8; continue 'dispatch;
	}
	// 82AAE670: 3860005F  li r3, 0x5f
	ctx.r[3].s64 = 95;
	// 82AAE674: 4B75A49D  bl 0x82208b10
	ctx.lr = 0x82AAE678;
	sub_82208B10(ctx, base);
	// 82AAE678: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82AAE67C: 394BDED4  addi r10, r11, -0x212c
	ctx.r[10].s64 = ctx.r[11].s64 + -8492;
	// 82AAE680: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE684: 808B0BD0  lwz r4, 0xbd0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3024 as u32) ) } as u64;
	// 82AAE688: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AAE68C: 41980034  blt cr6, 0x82aae6c0
	if ctx.cr[6].lt {
	pc = 0x82AAE6C0; continue 'dispatch;
	}
	// 82AAE690: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 82AAE694: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE698: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AAE69C: 807D0364  lwz r3, 0x364(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 82AAE6A0: 79680020  clrldi r8, r11, 0x20
	ctx.r[8].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82AAE6A4: 7927FFE6  rldicr r7, r9, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82AAE6A8: 7CE64436  srd r6, r7, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[7].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 82AAE6AC: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE6B0: 4B708831  bl 0x821b6ee0
	ctx.lr = 0x82AAE6B4;
	sub_821B6EE0(ctx, base);
	// 82AAE6B4: 4800000C  b 0x82aae6c0
	pc = 0x82AAE6C0; continue 'dispatch;
            }
            0x82AAE6B8 => {
    //   block [0x82AAE6B8..0x82AAE6C0)
	// 82AAE6B8: 38600061  li r3, 0x61
	ctx.r[3].s64 = 97;
	// 82AAE6BC: 4B75A455  bl 0x82208b10
	ctx.lr = 0x82AAE6C0;
	sub_82208B10(ctx, base);
	pc = 0x82AAE6C0; continue 'dispatch;
            }
            0x82AAE6C0 => {
    //   block [0x82AAE6C0..0x82AAEB24)
	// 82AAE6C0: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 82AAE6C4: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE6C8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82AAE6CC: C1BE0020  lfs f13, 0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE6D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AAE6D4: ED6DF82A  fadds f11, f13, f31
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82AAE6D8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82AAE6DC: ED80F02A  fadds f12, f0, f30
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82AAE6E0: 3BCBB480  addi r30, r11, -0x4b80
	ctx.r[30].s64 = ctx.r[11].s64 + -19328;
	// 82AAE6E4: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAEB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAEB28 size=80
    let mut pc: u32 = 0x82AAEB28;
    'dispatch: loop {
        match pc {
            0x82AAEB28 => {
    //   block [0x82AAEB28..0x82AAEB60)
	// 82AAEB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAEB2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAEB30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAEB34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAEB38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAEB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAEB40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAEB44: 48000035  bl 0x82aaeb78
	ctx.lr = 0x82AAEB48;
	sub_82AAEB78(ctx, base);
	// 82AAEB48: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82AAEB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAEB50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAEB54: 419A000C  beq cr6, 0x82aaeb60
	if ctx.cr[6].eq {
	pc = 0x82AAEB60; continue 'dispatch;
	}
	// 82AAEB58: 4B76D1E1  bl 0x8221bd38
	ctx.lr = 0x82AAEB5C;
	sub_8221BD38(ctx, base);
	// 82AAEB5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82AAEB60; continue 'dispatch;
            }
            0x82AAEB60 => {
    //   block [0x82AAEB60..0x82AAEB78)
	// 82AAEB60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAEB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAEB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAEB6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAEB70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAEB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAEB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAEB78 size=132
    let mut pc: u32 = 0x82AAEB78;
    'dispatch: loop {
        match pc {
            0x82AAEB78 => {
    //   block [0x82AAEB78..0x82AAEBB8)
	// 82AAEB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAEB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAEB80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAEB84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAEB88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAEB8C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AAEB90: 394B8A4C  addi r10, r11, -0x75b4
	ctx.r[10].s64 = ctx.r[11].s64 + -30132;
	// 82AAEB94: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAEB98: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAEB9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAEBA0: 419A0018  beq cr6, 0x82aaebb8
	if ctx.cr[6].eq {
	pc = 0x82AAEBB8; continue 'dispatch;
	}
	// 82AAEBA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAEBA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAEBAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAEBB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAEBB4: 4E800421  bctrl
	ctx.lr = 0x82AAEBB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AAEBB8 => {
    //   block [0x82AAEBB8..0x82AAEBFC)
	// 82AAEBB8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AAEBBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AAEBC0: 392B6CF8  addi r9, r11, 0x6cf8
	ctx.r[9].s64 = ctx.r[11].s64 + 27896;
	// 82AAEBC4: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82AAEBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAEBCC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AAEBD0: 4806BE21  bl 0x82b1a9f0
	ctx.lr = 0x82AAEBD4;
	sub_82B1A9F0(ctx, base);
	// 82AAEBD4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82AAEBD8: 4BD24399  bl 0x827d2f70
	ctx.lr = 0x82AAEBDC;
	sub_827D2F70(ctx, base);
	// 82AAEBDC: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 82AAEBE0: 38E80FD0  addi r7, r8, 0xfd0
	ctx.r[7].s64 = ctx.r[8].s64 + 4048;
	// 82AAEBE4: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82AAEBE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAEBEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAEBF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAEBF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAEBF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAEC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAEC00 size=108
    let mut pc: u32 = 0x82AAEC00;
    'dispatch: loop {
        match pc {
            0x82AAEC00 => {
    //   block [0x82AAEC00..0x82AAEC50)
	// 82AAEC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAEC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAEC08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAEC0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAEC10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAEC14: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAEC18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAEC1C: 419A0034  beq cr6, 0x82aaec50
	if ctx.cr[6].eq {
	pc = 0x82AAEC50; continue 'dispatch;
	}
	// 82AAEC20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAEC24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAEC28: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAEC2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAEC30: 4E800421  bctrl
	ctx.lr = 0x82AAEC34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAEC34: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AAEC38: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82AAEC3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAEC40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAEC44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAEC48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAEC4C: 4E800020  blr
	return;
            }
            0x82AAEC50 => {
    //   block [0x82AAEC50..0x82AAEC6C)
	// 82AAEC50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAEC54: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82AAEC58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAEC5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAEC60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAEC64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAEC68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAEC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAEC70 size=20
    let mut pc: u32 = 0x82AAEC70;
    'dispatch: loop {
        match pc {
            0x82AAEC70 => {
    //   block [0x82AAEC70..0x82AAEC84)
	// 82AAEC70: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAEC74: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AAEC78: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82AAEC7C: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82AAEC80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAEC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAEC88 size=264
    let mut pc: u32 = 0x82AAEC88;
    'dispatch: loop {
        match pc {
            0x82AAEC88 => {
    //   block [0x82AAEC88..0x82AAECB0)
	// 82AAEC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAEC8C: 481FA779  bl 0x82ca9404
	ctx.lr = 0x82AAEC90;
	sub_82CA93D0(ctx, base);
	// 82AAEC90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAEC94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAEC98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAEC9C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AAECA0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82AAECA4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82AAECA8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82AAECAC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82AAECB0; continue 'dispatch;
            }
            0x82AAECB0 => {
    //   block [0x82AAECB0..0x82AAECD4)
	// 82AAECB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAECB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAECB8: 419A001C  beq cr6, 0x82aaecd4
	if ctx.cr[6].eq {
	pc = 0x82AAECD4; continue 'dispatch;
	}
	// 82AAECBC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82AAECC0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AAECC4: 2F1E0020  cmpwi cr6, r30, 0x20
	ctx.cr[6].compare_i32(ctx.r[30].s32, 32, &mut ctx.xer);
	// 82AAECC8: 4198FFE8  blt cr6, 0x82aaecb0
	if ctx.cr[6].lt {
	pc = 0x82AAECB0; continue 'dispatch;
	}
	// 82AAECCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAECD0: 481FA784  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AAECD4 => {
    //   block [0x82AAECD4..0x82AAED0C)
	// 82AAECD4: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82AAECD8: 419A005C  beq cr6, 0x82aaed34
	if ctx.cr[6].eq {
	pc = 0x82AAED34; continue 'dispatch;
	}
	// 82AAECDC: 38600048  li r3, 0x48
	ctx.r[3].s64 = 72;
	// 82AAECE0: 4B7705E1  bl 0x8221f2c0
	ctx.lr = 0x82AAECE4;
	sub_8221F2C0(ctx, base);
	// 82AAECE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAECE8: 409A0058  bne cr6, 0x82aaed40
	if !ctx.cr[6].eq {
	pc = 0x82AAED40; continue 'dispatch;
	}
	// 82AAECEC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAECF0: 814B6F6C  lwz r10, 0x6f6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AAECF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAECF8: 419A0014  beq cr6, 0x82aaed0c
	if ctx.cr[6].eq {
	pc = 0x82AAED0C; continue 'dispatch;
	}
	// 82AAECFC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AAED00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AAED04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAED08: 4E800421  bctrl
	ctx.lr = 0x82AAED0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AAED0C => {
    //   block [0x82AAED0C..0x82AAED14)
	// 82AAED0C: 4821369D  bl 0x82cc23a8
	ctx.lr = 0x82AAED10;
	sub_82CC23A8(ctx, base);
	// 82AAED10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x82AAED14; continue 'dispatch;
            }
            0x82AAED14 => {
    //   block [0x82AAED14..0x82AAED34)
	// 82AAED14: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AAED18: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AAED1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAED20: 480016E9  bl 0x82ab0408
	ctx.lr = 0x82AAED24;
	sub_82AB0408(ctx, base);
	// 82AAED24: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AAED28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AAED2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAED30: 48000149  bl 0x82aaee78
	ctx.lr = 0x82AAED34;
	sub_82AAEE78(ctx, base);
	pc = 0x82AAED34; continue 'dispatch;
            }
            0x82AAED34 => {
    //   block [0x82AAED34..0x82AAED40)
	// 82AAED34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAED38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAED3C: 481FA718  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AAED40 => {
    //   block [0x82AAED40..0x82AAED90)
	// 82AAED40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAED44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AAED48: 7D69F030  slw r9, r11, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[11].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 82AAED4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AAED50: C80A0D38  lfd f0, 0xd38(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3384 as u32) ) };
	// 82AAED54: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82AAED58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAED5C: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AAED60: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82AAED64: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82AAED68: 93E3001C  stw r31, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82AAED6C: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82AAED70: 93E30024  stw r31, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 82AAED74: 93E30028  stw r31, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 82AAED78: 93E3002C  stw r31, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 82AAED7C: 93E30030  stw r31, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[31].u32 ) };
	// 82AAED80: 9BE30034  stb r31, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[31].u8 ) };
	// 82AAED84: D8030040  stfd f0, 0x40(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.f[0].u64 ) };
	// 82AAED88: 93E30038  stw r31, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 82AAED8C: 4BFFFF88  b 0x82aaed14
	pc = 0x82AAED14; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAED90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAED90 size=228
    let mut pc: u32 = 0x82AAED90;
    'dispatch: loop {
        match pc {
            0x82AAED90 => {
    //   block [0x82AAED90..0x82AAEDC0)
	// 82AAED90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAED94: 481FA671  bl 0x82ca9404
	ctx.lr = 0x82AAED98;
	sub_82CA93D0(ctx, base);
	// 82AAED98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAED9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAEDA0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AAEDA4: 3B7F0018  addi r27, r31, 0x18
	ctx.r[27].s64 = ctx.r[31].s64 + 24;
	// 82AAEDA8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AAEDAC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAEDB0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AAEDB4: 7D3C1671  srawi. r28, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82AAEDB8: 40810080  ble 0x82aaee38
	if !ctx.cr[0].gt {
	pc = 0x82AAEE38; continue 'dispatch;
	}
	// 82AAEDBC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82AAEDC0; continue 'dispatch;
            }
            0x82AAEDC0 => {
    //   block [0x82AAEDC0..0x82AAEDF0)
	// 82AAEDC0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAEDC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AAEDC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAEDCC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82AAEDD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AAEDD4: 4BFA20BD  bl 0x82a50e90
	ctx.lr = 0x82AAEDD8;
	sub_82A50E90(ctx, base);
	// 82AAEDD8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AAEDDC: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAEDE0: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82AAEDE4: 80A300B0  lwz r5, 0xb0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AAEDE8: 7CA43078  andc r4, r5, r6
	ctx.r[4].u64 = ctx.r[5].u64 & !ctx.r[6].u64;
	// 82AAEDEC: 908300B0  stw r4, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[4].u32 ) };
	pc = 0x82AAEDF0; continue 'dispatch;
            }
            0x82AAEDF0 => {
    //   block [0x82AAEDF0..0x82AAEE28)
	// 82AAEDF0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AAEDF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAEDF8: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AAEDFC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82AAEE00: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAEE04: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAEE08: 4082FFE8  bne 0x82aaedf0
	if !ctx.cr[0].eq {
	pc = 0x82AAEDF0; continue 'dispatch;
	}
	// 82AAEE0C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82AAEE10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAEE14: 409A0014  bne cr6, 0x82aaee28
	if !ctx.cr[6].eq {
	pc = 0x82AAEE28; continue 'dispatch;
	}
	// 82AAEE18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAEE1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAEE20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAEE24: 4E800421  bctrl
	ctx.lr = 0x82AAEE28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AAEE28 => {
    //   block [0x82AAEE28..0x82AAEE38)
	// 82AAEE28: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82AAEE2C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82AAEE30: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AAEE34: 4082FF8C  bne 0x82aaedc0
	if !ctx.cr[0].eq {
	pc = 0x82AAEDC0; continue 'dispatch;
	}
	pc = 0x82AAEE38; continue 'dispatch;
            }
            0x82AAEE38 => {
    //   block [0x82AAEE38..0x82AAEE58)
	// 82AAEE38: 93BF0030  stw r29, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 82AAEE3C: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82AAEE40: 93BF002C  stw r29, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 82AAEE44: 9BBF0034  stb r29, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u8 ) };
	// 82AAEE48: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAEE4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAEE50: 419A0008  beq cr6, 0x82aaee58
	if ctx.cr[6].eq {
	pc = 0x82AAEE58; continue 'dispatch;
	}
	// 82AAEE54: 4B76CEE5  bl 0x8221bd38
	ctx.lr = 0x82AAEE58;
	sub_8221BD38(ctx, base);
	pc = 0x82AAEE58; continue 'dispatch;
            }
            0x82AAEE58 => {
    //   block [0x82AAEE58..0x82AAEE74)
	// 82AAEE58: 93BB0004  stw r29, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AAEE5C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82AAEE60: 93BB0008  stw r29, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82AAEE64: 93BB000C  stw r29, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82AAEE68: 4B92D9C1  bl 0x823dc828
	ctx.lr = 0x82AAEE6C;
	sub_823DC828(ctx, base);
	// 82AAEE6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAEE70: 481FA5E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAEE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAEE78 size=708
    let mut pc: u32 = 0x82AAEE78;
    'dispatch: loop {
        match pc {
            0x82AAEE78 => {
    //   block [0x82AAEE78..0x82AAEF00)
	// 82AAEE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAEE7C: 481FA56D  bl 0x82ca93e8
	ctx.lr = 0x82AAEE80;
	sub_82CA93D0(ctx, base);
	// 82AAEE80: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAEE84: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82AAEE88: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82AAEE8C: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 82AAEE90: 3BF60004  addi r31, r22, 4
	ctx.r[31].s64 = ctx.r[22].s64 + 4;
	// 82AAEE94: 8176000C  lwz r11, 0xc(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAEE98: 81560008  lwz r10, 8(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAEE9C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AAEEA0: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82AAEEA4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82AAEEA8: 409A028C  bne cr6, 0x82aaf134
	if !ctx.cr[6].eq {
	pc = 0x82AAF134; continue 'dispatch;
	}
	// 82AAEEAC: 81570014  lwz r10, 0x14(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAEEB0: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 82AAEEB4: 4198004C  blt cr6, 0x82aaef00
	if ctx.cr[6].lt {
	pc = 0x82AAEF00; continue 'dispatch;
	}
	// 82AAEEB8: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAEEBC: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82AAEEC0: 81370004  lwz r9, 4(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAEEC4: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 82AAEEC8: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 82AAEECC: 38A90004  addi r5, r9, 4
	ctx.r[5].s64 = ctx.r[9].s64 + 4;
	// 82AAEED0: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAEED4: 98880000  stb r4, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 82AAEED8: 886B0001  lbz r3, 1(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAEEDC: 98680001  stb r3, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 82AAEEE0: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAEEE4: 99480002  stb r10, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 82AAEEE8: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAEEEC: 99280003  stb r9, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 82AAEEF0: 90D7000C  stw r6, 0xc(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82AAEEF4: 90F70014  stw r7, 0x14(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82AAEEF8: 90B70004  stw r5, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82AAEEFC: 48000014  b 0x82aaef10
	pc = 0x82AAEF10; continue 'dispatch;
            }
            0x82AAEF00 => {
    //   block [0x82AAEF00..0x82AAEF10)
	// 82AAEF00: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAEF04: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAEF08: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82AAEF0C: 4BF71FDD  bl 0x82a20ee8
	ctx.lr = 0x82AAEF10;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAEF10; continue 'dispatch;
            }
            0x82AAEF10 => {
    //   block [0x82AAEF10..0x82AAEF48)
	// 82AAEF10: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAEF14: 89770018  lbz r11, 0x18(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAEF18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAEF1C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82AAEF20: 419A0028  beq cr6, 0x82aaef48
	if ctx.cr[6].eq {
	pc = 0x82AAEF48; continue 'dispatch;
	}
	// 82AAEF24: 8901005B  lbz r8, 0x5b(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82AAEF28: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AAEF2C: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AAEF30: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAEF34: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 82AAEF38: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82AAEF3C: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 82AAEF40: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82AAEF44: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82AAEF48; continue 'dispatch;
            }
            0x82AAEF48 => {
    //   block [0x82AAEF48..0x82AAEF98)
	// 82AAEF48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAEF4C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AAEF50: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAEF54: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AAEF58: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AAEF5C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82AAEF60: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AAEF64: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AAEF68: 40990030  ble cr6, 0x82aaef98
	if !ctx.cr[6].gt {
	pc = 0x82AAEF98; continue 'dispatch;
	}
	// 82AAEF6C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82AAEF70: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AAEF74: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AAEF78: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AAEF7C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82AAEF80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAEF84: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AAEF88: 7CA8E850  subf r5, r8, r29
	ctx.r[5].s64 = ctx.r[29].s64 - ctx.r[8].s64;
	// 82AAEF8C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AAEF90: 4BFE2C79  bl 0x82a91c08
	ctx.lr = 0x82AAEF94;
	sub_82A91C08(ctx, base);
	// 82AAEF94: 48000040  b 0x82aaefd4
	pc = 0x82AAEFD4; continue 'dispatch;
            }
            0x82AAEF98 => {
    //   block [0x82AAEF98..0x82AAEFD4)
	// 82AAEF98: 4098003C  bge cr6, 0x82aaefd4
	if !ctx.cr[6].lt {
	pc = 0x82AAEFD4; continue 'dispatch;
	}
	// 82AAEF9C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AAEFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAEFA4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82AAEFA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAEFAC: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82AAEFB0: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AAEFB4: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82AAEFB8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AAEFBC: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AAEFC0: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AAEFC4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82AAEFC8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AAEFCC: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AAEFD0: 48001551  bl 0x82ab0520
	ctx.lr = 0x82AAEFD4;
	sub_82AB0520(ctx, base);
	pc = 0x82AAEFD4; continue 'dispatch;
            }
            0x82AAEFD4 => {
    //   block [0x82AAEFD4..0x82AAF004)
	// 82AAEFD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAEFD8: 4B708B41  bl 0x821b7b18
	ctx.lr = 0x82AAEFDC;
	sub_821B7B18(ctx, base);
	// 82AAEFDC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAEFE0: 40990110  ble cr6, 0x82aaf0f0
	if !ctx.cr[6].gt {
	pc = 0x82AAF0F0; continue 'dispatch;
	}
	// 82AAEFE4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AAEFE8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AAEFEC: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82AAEFF0: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82AAEFF4: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 82AAEFF8: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 82AAEFFC: 3B2B70F8  addi r25, r11, 0x70f8
	ctx.r[25].s64 = ctx.r[11].s64 + 28920;
	// 82AAF000: 3B0A1160  addi r24, r10, 0x1160
	ctx.r[24].s64 = ctx.r[10].s64 + 4448;
	pc = 0x82AAF004; continue 'dispatch;
            }
            0x82AAF004 => {
    //   block [0x82AAF004..0x82AAF04C)
	// 82AAF004: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82AAF008: 4B770251  bl 0x8221f258
	ctx.lr = 0x82AAF00C;
	sub_8221F258(ctx, base);
	// 82AAF00C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAF010: 419A003C  beq cr6, 0x82aaf04c
	if ctx.cr[6].eq {
	pc = 0x82AAF04C; continue 'dispatch;
	}
	// 82AAF014: 93030000  stw r24, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82AAF018: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAF01C: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AAF020: 93C3001C  stw r30, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82AAF024: 93C30020  stw r30, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82AAF028: 93C30024  stw r30, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82AAF02C: 93C3002C  stw r30, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82AAF030: 93C30030  stw r30, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82AAF034: 93C30034  stw r30, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82AAF038: 93230038  stw r25, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[25].u32 ) };
	// 82AAF03C: 93C3003C  stw r30, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82AAF040: 93C30040  stw r30, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82AAF044: 93C30044  stw r30, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82AAF048: 48000008  b 0x82aaf050
	pc = 0x82AAF050; continue 'dispatch;
            }
            0x82AAF04C => {
    //   block [0x82AAF04C..0x82AAF050)
	// 82AAF04C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82AAF050; continue 'dispatch;
            }
            0x82AAF050 => {
    //   block [0x82AAF050..0x82AAF09C)
	// 82AAF050: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF054: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82AAF058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF05C: 4B708ABD  bl 0x821b7b18
	ctx.lr = 0x82AAF060;
	sub_821B7B18(ctx, base);
	// 82AAF060: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AAF064: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAF068: 419A003C  beq cr6, 0x82aaf0a4
	if ctx.cr[6].eq {
	pc = 0x82AAF0A4; continue 'dispatch;
	}
	// 82AAF06C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AAF070: 4B7701E9  bl 0x8221f258
	ctx.lr = 0x82AAF074;
	sub_8221F258(ctx, base);
	// 82AAF074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAF078: 419A0024  beq cr6, 0x82aaf09c
	if ctx.cr[6].eq {
	pc = 0x82AAF09C; continue 'dispatch;
	}
	// 82AAF07C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF080: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 82AAF084: 92A30000  stw r21, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 82AAF088: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAF08C: 39099238  addi r8, r9, -0x6dc8
	ctx.r[8].s64 = ctx.r[9].s64 + -28104;
	// 82AAF090: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AAF094: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAF098: 48000008  b 0x82aaf0a0
	pc = 0x82AAF0A0; continue 'dispatch;
            }
            0x82AAF09C => {
    //   block [0x82AAF09C..0x82AAF0A0)
	// 82AAF09C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82AAF0A0; continue 'dispatch;
            }
            0x82AAF0A0 => {
    //   block [0x82AAF0A0..0x82AAF0A4)
	// 82AAF0A0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82AAF0A4; continue 'dispatch;
            }
            0x82AAF0A4 => {
    //   block [0x82AAF0A4..0x82AAF0F0)
	// 82AAF0A4: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF0A8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82AAF0AC: 7FEBE02E  lwzx r31, r11, r28
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82AAF0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF0B4: 4800066D  bl 0x82aaf720
	ctx.lr = 0x82AAF0B8;
	sub_82AAF720(ctx, base);
	// 82AAF0B8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAF0BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AAF0C0: 807AFA0C  lwz r3, -0x5f4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 82AAF0C4: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82AAF0C8: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF0CC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82AAF0D0: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF0D4: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 82AAF0D8: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF0DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AAF0E0: 4B731C41  bl 0x821e0d20
	ctx.lr = 0x82AAF0E4;
	sub_821E0D20(ctx, base);
	// 82AAF0E4: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82AAF0E8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82AAF0EC: 4082FF18  bne 0x82aaf004
	if !ctx.cr[0].eq {
	pc = 0x82AAF004; continue 'dispatch;
	}
	pc = 0x82AAF0F0; continue 'dispatch;
            }
            0x82AAF0F0 => {
    //   block [0x82AAF0F0..0x82AAF118)
	// 82AAF0F0: 81740008  lwz r11, 8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF0F4: 38760018  addi r3, r22, 0x18
	ctx.r[3].s64 = ctx.r[22].s64 + 24;
	// 82AAF0F8: 81540004  lwz r10, 4(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF0FC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AAF100: 7D3F1670  srawi r31, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82AAF104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAF108: 4BFA3389  bl 0x82a52490
	ctx.lr = 0x82AAF10C;
	sub_82A52490(ctx, base);
	// 82AAF10C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAF110: 40990024  ble cr6, 0x82aaf134
	if !ctx.cr[6].gt {
	pc = 0x82AAF134; continue 'dispatch;
	}
	// 82AAF114: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82AAF118; continue 'dispatch;
            }
            0x82AAF118 => {
    //   block [0x82AAF118..0x82AAF134)
	// 82AAF118: 81540004  lwz r10, 4(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF11C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAF120: 8136001C  lwz r9, 0x1c(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAF124: 7D1E502E  lwzx r8, r30, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AAF128: 7D1E492E  stwx r8, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 82AAF12C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AAF130: 4082FFE8  bne 0x82aaf118
	if !ctx.cr[0].eq {
	pc = 0x82AAF118; continue 'dispatch;
	}
	pc = 0x82AAF134; continue 'dispatch;
            }
            0x82AAF134 => {
    //   block [0x82AAF134..0x82AAF13C)
	// 82AAF134: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AAF138: 481FA300  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAF140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAF140 size=80
    let mut pc: u32 = 0x82AAF140;
    'dispatch: loop {
        match pc {
            0x82AAF140 => {
    //   block [0x82AAF140..0x82AAF178)
	// 82AAF140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAF144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAF148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAF14C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAF150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAF154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAF158: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAF15C: 48000515  bl 0x82aaf670
	ctx.lr = 0x82AAF160;
	sub_82AAF670(ctx, base);
	// 82AAF160: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82AAF164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAF16C: 419A000C  beq cr6, 0x82aaf178
	if ctx.cr[6].eq {
	pc = 0x82AAF178; continue 'dispatch;
	}
	// 82AAF170: 4B76CBC9  bl 0x8221bd38
	ctx.lr = 0x82AAF174;
	sub_8221BD38(ctx, base);
	// 82AAF174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82AAF178; continue 'dispatch;
            }
            0x82AAF178 => {
    //   block [0x82AAF178..0x82AAF190)
	// 82AAF178: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAF17C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAF180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAF184: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAF188: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAF18C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAF190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAF190 size=296
    let mut pc: u32 = 0x82AAF190;
    'dispatch: loop {
        match pc {
            0x82AAF190 => {
    //   block [0x82AAF190..0x82AAF200)
	// 82AAF190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAF194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAF198: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAF19C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAF1A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAF1A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAF1A8: 4B76F881  bl 0x8221ea28
	ctx.lr = 0x82AAF1AC;
	sub_8221EA28(ctx, base);
	// 82AAF1AC: C9610050  lfd f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AAF1B0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82AAF1B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AAF1B8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82AAF1BC: 811F0038  lwz r8, 0x38(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AAF1C0: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AAF1C4: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 82AAF1C8: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 82AAF1CC: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 82AAF1D0: C9891640  lfd f12, 0x1640(r9)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5696 as u32) ) };
	// 82AAF1D4: FD2A0028  fsub f9, f10, f0
	ctx.f[9].f64 = ctx.f[10].f64 - ctx.f[0].f64;
	// 82AAF1D8: FD096824  fdiv f8, f9, f13
	ctx.f[8].f64 = ctx.f[9].f64 / ctx.f[13].f64;
	// 82AAF1DC: FC28602A  fadd f1, f8, f12
	ctx.f[1].f64 = ctx.f[8].f64 + ctx.f[12].f64;
	// 82AAF1E0: 419A008C  beq cr6, 0x82aaf26c
	if ctx.cr[6].eq {
	pc = 0x82AAF26C; continue 'dispatch;
	}
	// 82AAF1E4: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 82AAF1E8: 419A0018  beq cr6, 0x82aaf200
	if ctx.cr[6].eq {
	pc = 0x82AAF200; continue 'dispatch;
	}
	// 82AAF1EC: 2F080003  cmpwi cr6, r8, 3
	ctx.cr[6].compare_i32(ctx.r[8].s32, 3, &mut ctx.xer);
	// 82AAF1F0: 409A0084  bne cr6, 0x82aaf274
	if !ctx.cr[6].eq {
	pc = 0x82AAF274; continue 'dispatch;
	}
	// 82AAF1F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF1F8: 480001F1  bl 0x82aaf3e8
	ctx.lr = 0x82AAF1FC;
	sub_82AAF3E8(ctx, base);
	// 82AAF1FC: 48000078  b 0x82aaf274
	pc = 0x82AAF274; continue 'dispatch;
            }
            0x82AAF200 => {
    //   block [0x82AAF200..0x82AAF21C)
	// 82AAF200: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF204: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAF208: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF20C: 7CE95050  subf r7, r9, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AAF210: 7CE91E71  srawi. r9, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AAF214: 40810028  ble 0x82aaf23c
	if !ctx.cr[0].gt {
	pc = 0x82AAF23C; continue 'dispatch;
	}
	// 82AAF218: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AAF21C; continue 'dispatch;
            }
            0x82AAF21C => {
    //   block [0x82AAF21C..0x82AAF23C)
	// 82AAF21C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF220: 80C70040  lwz r6, 0x40(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AAF224: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82AAF228: 409A0030  bne cr6, 0x82aaf258
	if !ctx.cr[6].eq {
	pc = 0x82AAF258; continue 'dispatch;
	}
	// 82AAF22C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAF230: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AAF234: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AAF238: 4198FFE4  blt cr6, 0x82aaf21c
	if ctx.cr[6].lt {
	pc = 0x82AAF21C; continue 'dispatch;
	}
	pc = 0x82AAF23C; continue 'dispatch;
            }
            0x82AAF23C => {
    //   block [0x82AAF23C..0x82AAF240)
	// 82AAF23C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AAF240; continue 'dispatch;
            }
            0x82AAF240 => {
    //   block [0x82AAF240..0x82AAF258)
	// 82AAF240: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AAF244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAF248: 419A0018  beq cr6, 0x82aaf260
	if ctx.cr[6].eq {
	pc = 0x82AAF260; continue 'dispatch;
	}
	// 82AAF24C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF250: 480002F9  bl 0x82aaf548
	ctx.lr = 0x82AAF254;
	sub_82AAF548(ctx, base);
	// 82AAF254: 48000020  b 0x82aaf274
	pc = 0x82AAF274; continue 'dispatch;
            }
            0x82AAF258 => {
    //   block [0x82AAF258..0x82AAF260)
	// 82AAF258: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAF25C: 4BFFFFE4  b 0x82aaf240
	pc = 0x82AAF240; continue 'dispatch;
            }
            0x82AAF260 => {
    //   block [0x82AAF260..0x82AAF26C)
	// 82AAF260: 39680001  addi r11, r8, 1
	ctx.r[11].s64 = ctx.r[8].s64 + 1;
	// 82AAF264: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82AAF268: 4800000C  b 0x82aaf274
	pc = 0x82AAF274; continue 'dispatch;
            }
            0x82AAF26C => {
    //   block [0x82AAF26C..0x82AAF274)
	// 82AAF26C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF270: 48000049  bl 0x82aaf2b8
	ctx.lr = 0x82AAF274;
	sub_82AAF2B8(ctx, base);
	pc = 0x82AAF274; continue 'dispatch;
            }
            0x82AAF274 => {
    //   block [0x82AAF274..0x82AAF298)
	// 82AAF274: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AAF278: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAF27C: 409A001C  bne cr6, 0x82aaf298
	if !ctx.cr[6].eq {
	pc = 0x82AAF298; continue 'dispatch;
	}
	// 82AAF280: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AAF284: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAF288: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAF28C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAF290: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAF294: 4E800020  blr
	return;
            }
            0x82AAF298 => {
    //   block [0x82AAF298..0x82AAF2B8)
	// 82AAF298: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82AAF29C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AAF2A0: 5543E7BC  rlwinm r3, r10, 0x1c, 0x1e, 0x1e
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82AAF2A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAF2A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAF2AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAF2B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAF2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAF2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAF2B8 size=300
    let mut pc: u32 = 0x82AAF2B8;
    'dispatch: loop {
        match pc {
            0x82AAF2B8 => {
    //   block [0x82AAF2B8..0x82AAF2F8)
	// 82AAF2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAF2BC: 481FA145  bl 0x82ca9400
	ctx.lr = 0x82AAF2C0;
	sub_82CA93D0(ctx, base);
	// 82AAF2C0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82AAF2C4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAF2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAF2CC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AAF2D0: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 82AAF2D4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF2D8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF2DC: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AAF2E0: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AAF2E4: 7D1A1E70  srawi r26, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82AAF2E8: 7F09D000  cmpw cr6, r9, r26
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82AAF2EC: 409800E0  bge cr6, 0x82aaf3cc
	if !ctx.cr[6].lt {
	pc = 0x82AAF3CC; continue 'dispatch;
	}
	// 82AAF2F0: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 82AAF2F4: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x82AAF2F8; continue 'dispatch;
            }
            0x82AAF2F8 => {
    //   block [0x82AAF2F8..0x82AAF320)
	// 82AAF2F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF2FC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF300: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AAF304: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF308: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AAF30C: 7FC9502E  lwzx r30, r9, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AAF310: 815E004C  lwz r10, 0x4c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82AAF314: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AAF318: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AAF31C: 40990024  ble cr6, 0x82aaf340
	if !ctx.cr[6].gt {
	pc = 0x82AAF340; continue 'dispatch;
	}
	pc = 0x82AAF320; continue 'dispatch;
            }
            0x82AAF320 => {
    //   block [0x82AAF320..0x82AAF340)
	// 82AAF320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF324: 48000225  bl 0x82aaf548
	ctx.lr = 0x82AAF328;
	sub_82AAF548(ctx, base);
	// 82AAF328: 815E004C  lwz r10, 0x4c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82AAF32C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF330: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AAF334: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AAF338: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAF33C: 4199FFE4  bgt cr6, 0x82aaf320
	if ctx.cr[6].gt {
	pc = 0x82AAF320; continue 'dispatch;
	}
	pc = 0x82AAF340; continue 'dispatch;
            }
            0x82AAF340 => {
    //   block [0x82AAF340..0x82AAF37C)
	// 82AAF340: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AAF344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAF348: 419A0034  beq cr6, 0x82aaf37c
	if ctx.cr[6].eq {
	pc = 0x82AAF37C; continue 'dispatch;
	}
	// 82AAF34C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AAF350: 807E0044  lwz r3, 0x44(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82AAF354: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AAF358: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82AAF35C: 389E0040  addi r4, r30, 0x40
	ctx.r[4].s64 = ctx.r[30].s64 + 64;
	// 82AAF360: 80BE0048  lwz r5, 0x48(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82AAF364: 481B9AED  bl 0x82c68e50
	ctx.lr = 0x82AAF368;
	sub_82C68E50(ctx, base);
	// 82AAF368: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AAF36C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAF370: 419A000C  beq cr6, 0x82aaf37c
	if ctx.cr[6].eq {
	pc = 0x82AAF37C; continue 'dispatch;
	}
	// 82AAF374: 815E004C  lwz r10, 0x4c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82AAF378: 48000008  b 0x82aaf380
	pc = 0x82AAF380; continue 'dispatch;
            }
            0x82AAF37C => {
    //   block [0x82AAF37C..0x82AAF380)
	// 82AAF37C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82AAF380; continue 'dispatch;
            }
            0x82AAF380 => {
    //   block [0x82AAF380..0x82AAF3CC)
	// 82AAF380: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAF388: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AAF38C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82AAF390: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF394: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82AAF398: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAF39C: 4B76F68D  bl 0x8221ea28
	ctx.lr = 0x82AAF3A0;
	sub_8221EA28(ctx, base);
	// 82AAF3A0: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AAF3A4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82AAF3A8: C81C70A0  lfd f0, 0x70a0(r28)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(28832 as u32) ) };
	// 82AAF3AC: C9BB70A8  lfd f13, 0x70a8(r27)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28840 as u32) ) };
	// 82AAF3B0: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 82AAF3B4: FD2A6824  fdiv f9, f10, f13
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 82AAF3B8: FF09F800  fcmpu cr6, f9, f31
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[31].f64);
	// 82AAF3BC: 4199001C  bgt cr6, 0x82aaf3d8
	if ctx.cr[6].gt {
	pc = 0x82AAF3D8; continue 'dispatch;
	}
	// 82AAF3C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF3C4: 7F0BD000  cmpw cr6, r11, r26
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82AAF3C8: 4198FF30  blt cr6, 0x82aaf2f8
	if ctx.cr[6].lt {
	pc = 0x82AAF2F8; continue 'dispatch;
	}
	pc = 0x82AAF3CC; continue 'dispatch;
            }
            0x82AAF3CC => {
    //   block [0x82AAF3CC..0x82AAF3D8)
	// 82AAF3CC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AAF3D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAF3D4: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	pc = 0x82AAF3D8; continue 'dispatch;
            }
            0x82AAF3D8 => {
    //   block [0x82AAF3D8..0x82AAF3E4)
	// 82AAF3D8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AAF3DC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82AAF3E0: 481FA070  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAF3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAF3E8 size=348
    let mut pc: u32 = 0x82AAF3E8;
    'dispatch: loop {
        match pc {
            0x82AAF3E8 => {
    //   block [0x82AAF3E8..0x82AAF42C)
	// 82AAF3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAF3EC: 481FA011  bl 0x82ca93fc
	ctx.lr = 0x82AAF3F0;
	sub_82CA93D0(ctx, base);
	// 82AAF3F0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82AAF3F4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAF3F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAF3FC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AAF400: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AAF404: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAF408: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AAF40C: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AAF410: 7D191670  srawi r25, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[25].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82AAF414: 7F09C800  cmpw cr6, r9, r25
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82AAF418: 409800CC  bge cr6, 0x82aaf4e4
	if !ctx.cr[6].lt {
	pc = 0x82AAF4E4; continue 'dispatch;
	}
	// 82AAF41C: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 82AAF420: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AAF424: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 82AAF428: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x82AAF42C; continue 'dispatch;
            }
            0x82AAF42C => {
    //   block [0x82AAF42C..0x82AAF498)
	// 82AAF42C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AAF430: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AAF434: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAF438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAF43C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AAF440: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AAF444: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82AAF448: 4BFA1A49  bl 0x82a50e90
	ctx.lr = 0x82AAF44C;
	sub_82A50E90(ctx, base);
	// 82AAF44C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF450: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAF454: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AAF458: 80DE00B0  lwz r6, 0xb0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AAF45C: 7CC53B78  or r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 | ctx.r[7].u64;
	// 82AAF460: 90BE00B0  stw r5, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[5].u32 ) };
	// 82AAF464: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF468: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82AAF46C: 909D0004  stw r4, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AAF470: 4B76F5B9  bl 0x8221ea28
	ctx.lr = 0x82AAF474;
	sub_8221EA28(ctx, base);
	// 82AAF474: C9810058  lfd f12, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AAF478: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82AAF47C: C81C70A0  lfd f0, 0x70a0(r28)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(28832 as u32) ) };
	// 82AAF480: C9BB70A8  lfd f13, 0x70a8(r27)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28840 as u32) ) };
	// 82AAF484: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82AAF488: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 82AAF48C: FD2A6824  fdiv f9, f10, f13
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 82AAF490: FF09F800  fcmpu cr6, f9, f31
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[31].f64);
	// 82AAF494: 41990068  bgt cr6, 0x82aaf4fc
	if ctx.cr[6].gt {
	pc = 0x82AAF4FC; continue 'dispatch;
	}
	pc = 0x82AAF498; continue 'dispatch;
            }
            0x82AAF498 => {
    //   block [0x82AAF498..0x82AAF4D4)
	// 82AAF498: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAF49C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAF4A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAF4A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AAF4A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAF4AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAF4B0: 4082FFE8  bne 0x82aaf498
	if !ctx.cr[0].eq {
	pc = 0x82AAF498; continue 'dispatch;
	}
	// 82AAF4B4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82AAF4B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAF4BC: 409A0018  bne cr6, 0x82aaf4d4
	if !ctx.cr[6].eq {
	pc = 0x82AAF4D4; continue 'dispatch;
	}
	// 82AAF4C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF4C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAF4C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF4CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAF4D0: 4E800421  bctrl
	ctx.lr = 0x82AAF4D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AAF4D4 => {
    //   block [0x82AAF4D4..0x82AAF4E4)
	// 82AAF4D4: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AAF4D8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82AAF4DC: 7F0BC800  cmpw cr6, r11, r25
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82AAF4E0: 4198FF4C  blt cr6, 0x82aaf42c
	if ctx.cr[6].lt {
	pc = 0x82AAF42C; continue 'dispatch;
	}
	pc = 0x82AAF4E4; continue 'dispatch;
            }
            0x82AAF4E4 => {
    //   block [0x82AAF4E4..0x82AAF4F0)
	// 82AAF4E4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AAF4E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAF4EC: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	pc = 0x82AAF4F0; continue 'dispatch;
            }
            0x82AAF4F0 => {
    //   block [0x82AAF4F0..0x82AAF4FC)
	// 82AAF4F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AAF4F4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82AAF4F8: 481F9F54  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AAF4FC => {
    //   block [0x82AAF4FC..0x82AAF544)
	// 82AAF4FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAF500: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAF504: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAF508: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AAF50C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAF510: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAF514: 4082FFE8  bne 0x82aaf4fc
	if !ctx.cr[0].eq {
	pc = 0x82AAF4FC; continue 'dispatch;
	}
	// 82AAF518: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82AAF51C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAF520: 409AFFD0  bne cr6, 0x82aaf4f0
	if !ctx.cr[6].eq {
	pc = 0x82AAF4F0; continue 'dispatch;
	}
	// 82AAF524: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAF52C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF530: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAF534: 4E800421  bctrl
	ctx.lr = 0x82AAF538;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAF538: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AAF53C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82AAF540: 481F9F0C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAF548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAF548 size=296
    let mut pc: u32 = 0x82AAF548;
    'dispatch: loop {
        match pc {
            0x82AAF548 => {
    //   block [0x82AAF548..0x82AAF588)
	// 82AAF548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAF54C: 481F9EB5  bl 0x82ca9400
	ctx.lr = 0x82AAF550;
	sub_82CA93D0(ctx, base);
	// 82AAF550: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82AAF554: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAF558: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAF55C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAF560: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82AAF564: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF568: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF56C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AAF570: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAF574: 408100F0  ble 0x82aaf664
	if !ctx.cr[0].gt {
	pc = 0x82AAF664; continue 'dispatch;
	}
	// 82AAF578: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AAF57C: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82AAF580: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 82AAF584: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x82AAF588; continue 'dispatch;
            }
            0x82AAF588 => {
    //   block [0x82AAF588..0x82AAF5B8)
	// 82AAF588: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF58C: 7FDD582E  lwzx r30, r29, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AAF590: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AAF594: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82AAF598: 419A0020  beq cr6, 0x82aaf5b8
	if ctx.cr[6].eq {
	pc = 0x82AAF5B8; continue 'dispatch;
	}
	// 82AAF59C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF5A0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF5A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAF5A8: 4E800421  bctrl
	ctx.lr = 0x82AAF5AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAF5AC: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82AAF5B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAF5B4: 419A0008  beq cr6, 0x82aaf5bc
	if ctx.cr[6].eq {
	pc = 0x82AAF5BC; continue 'dispatch;
	}
            }
            0x82AAF5B8 => {
    //   block [0x82AAF5B8..0x82AAF5BC)
	// 82AAF5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AAF5BC; continue 'dispatch;
            }
            0x82AAF5BC => {
    //   block [0x82AAF5BC..0x82AAF630)
	// 82AAF5BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AAF5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAF5C4: 419A006C  beq cr6, 0x82aaf630
	if ctx.cr[6].eq {
	pc = 0x82AAF630; continue 'dispatch;
	}
	// 82AAF5C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAF5CC: 4B76F45D  bl 0x8221ea28
	ctx.lr = 0x82AAF5D0;
	sub_8221EA28(ctx, base);
	// 82AAF5D0: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AAF5D4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82AAF5D8: C81C70A0  lfd f0, 0x70a0(r28)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(28832 as u32) ) };
	// 82AAF5DC: C9BB70A8  lfd f13, 0x70a8(r27)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28840 as u32) ) };
	// 82AAF5E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAF5E4: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 82AAF5E8: FFEA6824  fdiv f31, f10, f13
	ctx.f[31].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 82AAF5EC: 48000995  bl 0x82aaff80
	ctx.lr = 0x82AAF5F0;
	sub_82AAFF80(ctx, base);
	// 82AAF5F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAF5F4: 4B76F435  bl 0x8221ea28
	ctx.lr = 0x82AAF5F8;
	sub_8221EA28(ctx, base);
	// 82AAF5F8: C9210058  lfd f9, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AAF5FC: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82AAF600: C81C70A0  lfd f0, 0x70a0(r28)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(28832 as u32) ) };
	// 82AAF604: C9BB70A8  lfd f13, 0x70a8(r27)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28840 as u32) ) };
	// 82AAF608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAF60C: C8FF0040  lfd f7, 0x40(r31)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	// 82AAF610: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF614: FCC80028  fsub f6, f8, f0
	ctx.f[6].f64 = ctx.f[8].f64 - ctx.f[0].f64;
	// 82AAF618: FCA66824  fdiv f5, f6, f13
	ctx.f[5].f64 = ctx.f[6].f64 / ctx.f[13].f64;
	// 82AAF61C: FC85F828  fsub f4, f5, f31
	ctx.f[4].f64 = ctx.f[5].f64 - ctx.f[31].f64;
	// 82AAF620: FC64382A  fadd f3, f4, f7
	ctx.f[3].f64 = ctx.f[4].f64 + ctx.f[7].f64;
	// 82AAF624: D87F0040  stfd f3, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.f[3].u64 ) };
	// 82AAF628: 48000AB1  bl 0x82ab00d8
	ctx.lr = 0x82AAF62C;
	sub_82AB00D8(ctx, base);
	// 82AAF62C: 4800002C  b 0x82aaf658
	pc = 0x82AAF658; continue 'dispatch;
            }
            0x82AAF630 => {
    //   block [0x82AAF630..0x82AAF658)
	// 82AAF630: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AAF634: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82AAF638: 419A0020  beq cr6, 0x82aaf658
	if ctx.cr[6].eq {
	pc = 0x82AAF658; continue 'dispatch;
	}
	// 82AAF63C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF640: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAF644: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAF648: 4E800421  bctrl
	ctx.lr = 0x82AAF64C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAF64C: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF650: 7D034A14  add r8, r3, r9
	ctx.r[8].u64 = ctx.r[3].u64 + ctx.r[9].u64;
	// 82AAF654: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
            }
            0x82AAF658 => {
    //   block [0x82AAF658..0x82AAF664)
	// 82AAF658: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82AAF65C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82AAF660: 4082FF28  bne 0x82aaf588
	if !ctx.cr[0].eq {
	pc = 0x82AAF588; continue 'dispatch;
	}
	pc = 0x82AAF664; continue 'dispatch;
            }
            0x82AAF664 => {
    //   block [0x82AAF664..0x82AAF670)
	// 82AAF664: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AAF668: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82AAF66C: 481F9DE4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAF670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAF670 size=176
    let mut pc: u32 = 0x82AAF670;
    'dispatch: loop {
        match pc {
            0x82AAF670 => {
    //   block [0x82AAF670..0x82AAF6C0)
	// 82AAF670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAF674: 481F9D95  bl 0x82ca9408
	ctx.lr = 0x82AAF678;
	sub_82CA93D0(ctx, base);
	// 82AAF678: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAF67C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAF680: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAF684: 394B1160  addi r10, r11, 0x1160
	ctx.r[10].s64 = ctx.r[11].s64 + 4448;
	// 82AAF688: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAF68C: 48000C2D  bl 0x82ab02b8
	ctx.lr = 0x82AAF690;
	sub_82AB02B8(ctx, base);
	// 82AAF690: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82AAF694: 3BDF0038  addi r30, r31, 0x38
	ctx.r[30].s64 = ctx.r[31].s64 + 56;
	// 82AAF698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAF69C: 8069FA0C  lwz r3, -0x5f4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 82AAF6A0: 480B1DE1  bl 0x82b61480
	ctx.lr = 0x82AAF6A4;
	sub_82B61480(ctx, base);
	// 82AAF6A4: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AAF6A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAF6AC: 419A0014  beq cr6, 0x82aaf6c0
	if ctx.cr[6].eq {
	pc = 0x82AAF6C0; continue 'dispatch;
	}
	// 82AAF6B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF6B4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAF6B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAF6BC: 4E800421  bctrl
	ctx.lr = 0x82AAF6C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AAF6C0 => {
    //   block [0x82AAF6C0..0x82AAF6DC)
	// 82AAF6C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAF6C4: 480B0A65  bl 0x82b60128
	ctx.lr = 0x82AAF6C8;
	sub_82B60128(ctx, base);
	// 82AAF6C8: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AAF6CC: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 82AAF6D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAF6D4: 419A0008  beq cr6, 0x82aaf6dc
	if ctx.cr[6].eq {
	pc = 0x82AAF6DC; continue 'dispatch;
	}
	// 82AAF6D8: 4B76C661  bl 0x8221bd38
	ctx.lr = 0x82AAF6DC;
	sub_8221BD38(ctx, base);
	pc = 0x82AAF6DC; continue 'dispatch;
            }
            0x82AAF6DC => {
    //   block [0x82AAF6DC..0x82AAF700)
	// 82AAF6DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AAF6E0: 3B9F0018  addi r28, r31, 0x18
	ctx.r[28].s64 = ctx.r[31].s64 + 24;
	// 82AAF6E4: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AAF6E8: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AAF6EC: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AAF6F0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAF6F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAF6F8: 419A0008  beq cr6, 0x82aaf700
	if ctx.cr[6].eq {
	pc = 0x82AAF700; continue 'dispatch;
	}
	// 82AAF6FC: 4B76C63D  bl 0x8221bd38
	ctx.lr = 0x82AAF700;
	sub_8221BD38(ctx, base);
	pc = 0x82AAF700; continue 'dispatch;
            }
            0x82AAF700 => {
    //   block [0x82AAF700..0x82AAF720)
	// 82AAF700: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAF704: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AAF708: 93DC0008  stw r30, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AAF70C: 394B9950  addi r10, r11, -0x66b0
	ctx.r[10].s64 = ctx.r[11].s64 + -26288;
	// 82AAF710: 93DC000C  stw r30, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AAF714: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAF718: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAF71C: 481F9D3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAF720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAF720 size=2144
    let mut pc: u32 = 0x82AAF720;
    'dispatch: loop {
        match pc {
            0x82AAF720 => {
    //   block [0x82AAF720..0x82AAF770)
	// 82AAF720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAF724: 481F9CD9  bl 0x82ca93fc
	ctx.lr = 0x82AAF728;
	sub_82CA93D0(ctx, base);
	// 82AAF728: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAF72C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAF730: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AAF734: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF738: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82AAF73C: 41980034  blt cr6, 0x82aaf770
	if ctx.cr[6].lt {
	pc = 0x82AAF770; continue 'dispatch;
	}
	// 82AAF740: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82AAF744: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF748: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF74C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82AAF750: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82AAF754: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 82AAF758: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF75C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAF760: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAF764: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAF768: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAF76C: 48000014  b 0x82aaf780
	pc = 0x82AAF780; continue 'dispatch;
            }
            0x82AAF770 => {
    //   block [0x82AAF770..0x82AAF780)
	// 82AAF770: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AAF774: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAF778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF77C: 4BF7176D  bl 0x82a20ee8
	ctx.lr = 0x82AAF780;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAF780; continue 'dispatch;
            }
            0x82AAF780 => {
    //   block [0x82AAF780..0x82AAF7FC)
	// 82AAF780: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AAF784: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAF788: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAF78C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82AAF790: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82AAF794: 69190001  xori r25, r8, 1
	ctx.r[25].u64 = ctx.r[8].u64 ^ 1;
	// 82AAF798: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82AAF79C: 4BF72ABD  bl 0x82a22258
	ctx.lr = 0x82AAF7A0;
	sub_82A22258(ctx, base);
	// 82AAF7A0: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF7A4: 90FA0044  stw r7, 0x44(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(68 as u32), ctx.r[7].u32 ) };
	// 82AAF7A8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF7AC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAF7B0: 4198004C  blt cr6, 0x82aaf7fc
	if ctx.cr[6].lt {
	pc = 0x82AAF7FC; continue 'dispatch;
	}
	// 82AAF7B4: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAF7B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF7BC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82AAF7C0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF7C4: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAF7C8: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAF7CC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF7D0: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAF7D4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAF7D8: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAF7DC: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAF7E0: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAF7E4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAF7E8: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAF7EC: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAF7F0: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAF7F4: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAF7F8: 48000014  b 0x82aaf80c
	pc = 0x82AAF80C; continue 'dispatch;
            }
            0x82AAF7FC => {
    //   block [0x82AAF7FC..0x82AAF80C)
	// 82AAF7FC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAF800: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AAF804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF808: 4BF716E1  bl 0x82a20ee8
	ctx.lr = 0x82AAF80C;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAF80C; continue 'dispatch;
            }
            0x82AAF80C => {
    //   block [0x82AAF80C..0x82AAF840)
	// 82AAF80C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AAF810: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAF814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAF818: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAF81C: 419A0024  beq cr6, 0x82aaf840
	if ctx.cr[6].eq {
	pc = 0x82AAF840; continue 'dispatch;
	}
	// 82AAF820: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAF824: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAF828: 89210063  lbz r9, 0x63(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(99 as u32) ) } as u64;
	// 82AAF82C: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AAF830: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAF834: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAF838: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAF83C: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAF840; continue 'dispatch;
            }
            0x82AAF840 => {
    //   block [0x82AAF840..0x82AAF89C)
	// 82AAF840: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAF844: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AAF848: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF84C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAF850: 4198004C  blt cr6, 0x82aaf89c
	if ctx.cr[6].lt {
	pc = 0x82AAF89C; continue 'dispatch;
	}
	// 82AAF854: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAF858: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF85C: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 82AAF860: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF864: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAF868: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAF86C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF870: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAF874: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAF878: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAF87C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAF880: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAF884: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAF888: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAF88C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAF890: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAF894: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAF898: 48000014  b 0x82aaf8ac
	pc = 0x82AAF8AC; continue 'dispatch;
            }
            0x82AAF89C => {
    //   block [0x82AAF89C..0x82AAF8AC)
	// 82AAF89C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAF8A0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82AAF8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF8A8: 4BF71641  bl 0x82a20ee8
	ctx.lr = 0x82AAF8AC;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAF8AC; continue 'dispatch;
            }
            0x82AAF8AC => {
    //   block [0x82AAF8AC..0x82AAF8E0)
	// 82AAF8AC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AAF8B0: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAF8B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAF8B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAF8BC: 419A0024  beq cr6, 0x82aaf8e0
	if ctx.cr[6].eq {
	pc = 0x82AAF8E0; continue 'dispatch;
	}
	// 82AAF8C0: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAF8C4: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAF8C8: 89210067  lbz r9, 0x67(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(103 as u32) ) } as u64;
	// 82AAF8CC: 89010064  lbz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AAF8D0: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAF8D4: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAF8D8: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAF8DC: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAF8E0; continue 'dispatch;
            }
            0x82AAF8E0 => {
    //   block [0x82AAF8E0..0x82AAF93C)
	// 82AAF8E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAF8E4: 917A000C  stw r11, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AAF8E8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF8EC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAF8F0: 4198004C  blt cr6, 0x82aaf93c
	if ctx.cr[6].lt {
	pc = 0x82AAF93C; continue 'dispatch;
	}
	// 82AAF8F4: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAF8F8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF8FC: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 82AAF900: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF904: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAF908: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAF90C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF910: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAF914: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAF918: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAF91C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAF920: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAF924: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAF928: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAF92C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAF930: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAF934: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAF938: 48000014  b 0x82aaf94c
	pc = 0x82AAF94C; continue 'dispatch;
            }
            0x82AAF93C => {
    //   block [0x82AAF93C..0x82AAF94C)
	// 82AAF93C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAF940: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82AAF944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF948: 4BF715A1  bl 0x82a20ee8
	ctx.lr = 0x82AAF94C;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAF94C; continue 'dispatch;
            }
            0x82AAF94C => {
    //   block [0x82AAF94C..0x82AAF980)
	// 82AAF94C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AAF950: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAF954: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAF958: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAF95C: 419A0024  beq cr6, 0x82aaf980
	if ctx.cr[6].eq {
	pc = 0x82AAF980; continue 'dispatch;
	}
	// 82AAF960: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAF964: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAF968: 8921006B  lbz r9, 0x6b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(107 as u32) ) } as u64;
	// 82AAF96C: 89010068  lbz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AAF970: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAF974: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAF978: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAF97C: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAF980; continue 'dispatch;
            }
            0x82AAF980 => {
    //   block [0x82AAF980..0x82AAF9DC)
	// 82AAF980: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAF984: 917A0010  stw r11, 0x10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82AAF988: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAF98C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAF990: 4198004C  blt cr6, 0x82aaf9dc
	if ctx.cr[6].lt {
	pc = 0x82AAF9DC; continue 'dispatch;
	}
	// 82AAF994: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAF998: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAF99C: 3901006C  addi r8, r1, 0x6c
	ctx.r[8].s64 = ctx.r[1].s64 + 108;
	// 82AAF9A0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAF9A4: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAF9A8: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAF9AC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAF9B0: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAF9B4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAF9B8: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAF9BC: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAF9C0: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAF9C4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAF9C8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAF9CC: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAF9D0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAF9D4: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAF9D8: 48000014  b 0x82aaf9ec
	pc = 0x82AAF9EC; continue 'dispatch;
            }
            0x82AAF9DC => {
    //   block [0x82AAF9DC..0x82AAF9EC)
	// 82AAF9DC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAF9E0: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82AAF9E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAF9E8: 4BF71501  bl 0x82a20ee8
	ctx.lr = 0x82AAF9EC;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAF9EC; continue 'dispatch;
            }
            0x82AAF9EC => {
    //   block [0x82AAF9EC..0x82AAFA20)
	// 82AAF9EC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AAF9F0: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAF9F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAF9F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAF9FC: 419A0024  beq cr6, 0x82aafa20
	if ctx.cr[6].eq {
	pc = 0x82AAFA20; continue 'dispatch;
	}
	// 82AAFA00: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAFA04: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAFA08: 8921006F  lbz r9, 0x6f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82AAFA0C: 8901006C  lbz r8, 0x6c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AAFA10: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAFA14: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAFA18: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAFA1C: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAFA20; continue 'dispatch;
            }
            0x82AAFA20 => {
    //   block [0x82AAFA20..0x82AAFA7C)
	// 82AAFA20: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAFA24: 917A0014  stw r11, 0x14(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82AAFA28: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAFA2C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAFA30: 4198004C  blt cr6, 0x82aafa7c
	if ctx.cr[6].lt {
	pc = 0x82AAFA7C; continue 'dispatch;
	}
	// 82AAFA34: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAFA38: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAFA3C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82AAFA40: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAFA44: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAFA48: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAFA4C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFA50: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAFA54: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAFA58: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAFA5C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAFA60: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAFA64: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAFA68: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAFA6C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAFA70: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAFA74: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAFA78: 48000014  b 0x82aafa8c
	pc = 0x82AAFA8C; continue 'dispatch;
            }
            0x82AAFA7C => {
    //   block [0x82AAFA7C..0x82AAFA8C)
	// 82AAFA7C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAFA80: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAFA84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAFA88: 4BF71461  bl 0x82a20ee8
	ctx.lr = 0x82AAFA8C;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAFA8C; continue 'dispatch;
            }
            0x82AAFA8C => {
    //   block [0x82AAFA8C..0x82AAFAC4)
	// 82AAFA8C: 83C10070  lwz r30, 0x70(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AAFA90: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAFA94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAFA98: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82AAFA9C: 419A0028  beq cr6, 0x82aafac4
	if ctx.cr[6].eq {
	pc = 0x82AAFAC4; continue 'dispatch;
	}
	// 82AAFAA0: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAFAA4: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAFAA8: 89210073  lbz r9, 0x73(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(115 as u32) ) } as u64;
	// 82AAFAAC: 89010070  lbz r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AAFAB0: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAFAB4: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAFAB8: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAFABC: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	// 82AAFAC0: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x82AAFAC4; continue 'dispatch;
            }
            0x82AAFAC4 => {
    //   block [0x82AAFAC4..0x82AAFB18)
	// 82AAFAC4: 817A001C  lwz r11, 0x1c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAFAC8: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82AAFACC: 815A0020  lwz r10, 0x20(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AAFAD0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AAFAD4: 389A0018  addi r4, r26, 0x18
	ctx.r[4].s64 = ctx.r[26].s64 + 24;
	// 82AAFAD8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AAFADC: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 82AAFAE0: 7D2943D6  divw r9, r9, r8
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 82AAFAE4: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AAFAE8: 40990030  ble cr6, 0x82aafb18
	if !ctx.cr[6].gt {
	pc = 0x82AAFB18; continue 'dispatch;
	}
	// 82AAFAEC: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAFAF0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AAFAF4: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82AAFAF8: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82AAFAFC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AAFB00: 7D0943D6  divw r8, r9, r8
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 82AAFB04: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 82AAFB08: 7CA8F050  subf r5, r8, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[8].s64;
	// 82AAFB0C: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82AAFB10: 48000B29  bl 0x82ab0638
	ctx.lr = 0x82AAFB14;
	sub_82AB0638(ctx, base);
	// 82AAFB14: 48000044  b 0x82aafb58
	pc = 0x82AAFB58; continue 'dispatch;
            }
            0x82AAFB18 => {
    //   block [0x82AAFB18..0x82AAFB58)
	// 82AAFB18: 40980040  bge cr6, 0x82aafb58
	if !ctx.cr[6].lt {
	pc = 0x82AAFB58; continue 'dispatch;
	}
	// 82AAFB1C: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 82AAFB20: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AAFB24: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82AAFB28: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AAFB2C: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82AAFB30: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82AAFB34: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AAFB38: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AAFB3C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AAFB40: E8C10090  ld r6, 0x90(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82AAFB44: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AAFB48: F9010090  std r8, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u64 ) };
	// 82AAFB4C: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 82AAFB50: E8A10090  ld r5, 0x90(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82AAFB54: 48000935  bl 0x82ab0488
	ctx.lr = 0x82AAFB58;
	sub_82AB0488(ctx, base);
	pc = 0x82AAFB58; continue 'dispatch;
            }
            0x82AAFB58 => {
    //   block [0x82AAFB58..0x82AAFB70)
	// 82AAFB58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAFB5C: 387A0028  addi r3, r26, 0x28
	ctx.r[3].s64 = ctx.r[26].s64 + 40;
	// 82AAFB60: 4BFDF8A1  bl 0x82a8f400
	ctx.lr = 0x82AAFB64;
	sub_82A8F400(ctx, base);
	// 82AAFB64: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AAFB68: 409902C4  ble cr6, 0x82aafe2c
	if !ctx.cr[6].gt {
	pc = 0x82AAFE2C; continue 'dispatch;
	}
	// 82AAFB6C: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	pc = 0x82AAFB70; continue 'dispatch;
            }
            0x82AAFB70 => {
    //   block [0x82AAFB70..0x82AAFBE4)
	// 82AAFB70: 817A001C  lwz r11, 0x1c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAFB74: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82AAFB78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAFB7C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AAFB80: 7F9D5A14  add r28, r29, r11
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AAFB84: 4BF726D5  bl 0x82a22258
	ctx.lr = 0x82AAFB88;
	sub_82A22258(ctx, base);
	// 82AAFB88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFB8C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAFB90: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAFB94: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAFB98: 4198004C  blt cr6, 0x82aafbe4
	if ctx.cr[6].lt {
	pc = 0x82AAFBE4; continue 'dispatch;
	}
	// 82AAFB9C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAFBA0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAFBA4: 39010074  addi r8, r1, 0x74
	ctx.r[8].s64 = ctx.r[1].s64 + 116;
	// 82AAFBA8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAFBAC: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAFBB0: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAFBB4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFBB8: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAFBBC: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAFBC0: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAFBC4: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAFBC8: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAFBCC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAFBD0: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAFBD4: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAFBD8: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAFBDC: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAFBE0: 48000014  b 0x82aafbf4
	pc = 0x82AAFBF4; continue 'dispatch;
            }
            0x82AAFBE4 => {
    //   block [0x82AAFBE4..0x82AAFBF4)
	// 82AAFBE4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAFBE8: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AAFBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAFBF0: 4BF712F9  bl 0x82a20ee8
	ctx.lr = 0x82AAFBF4;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAFBF4; continue 'dispatch;
            }
            0x82AAFBF4 => {
    //   block [0x82AAFBF4..0x82AAFC28)
	// 82AAFBF4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AAFBF8: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAFBFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAFC00: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAFC04: 419A0024  beq cr6, 0x82aafc28
	if ctx.cr[6].eq {
	pc = 0x82AAFC28; continue 'dispatch;
	}
	// 82AAFC08: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAFC0C: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAFC10: 89210077  lbz r9, 0x77(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82AAFC14: 89010074  lbz r8, 0x74(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AAFC18: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAFC1C: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAFC20: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAFC24: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAFC28; continue 'dispatch;
            }
            0x82AAFC28 => {
    //   block [0x82AAFC28..0x82AAFC84)
	// 82AAFC28: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAFC2C: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AAFC30: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAFC34: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAFC38: 4198004C  blt cr6, 0x82aafc84
	if ctx.cr[6].lt {
	pc = 0x82AAFC84; continue 'dispatch;
	}
	// 82AAFC3C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAFC40: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAFC44: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 82AAFC48: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAFC4C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAFC50: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAFC54: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFC58: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAFC5C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAFC60: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAFC64: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAFC68: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAFC6C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAFC70: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAFC74: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAFC78: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAFC7C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAFC80: 48000014  b 0x82aafc94
	pc = 0x82AAFC94; continue 'dispatch;
            }
            0x82AAFC84 => {
    //   block [0x82AAFC84..0x82AAFC94)
	// 82AAFC84: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAFC88: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AAFC8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAFC90: 4BF71259  bl 0x82a20ee8
	ctx.lr = 0x82AAFC94;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAFC94; continue 'dispatch;
            }
            0x82AAFC94 => {
    //   block [0x82AAFC94..0x82AAFCC8)
	// 82AAFC94: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AAFC98: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAFC9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAFCA0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAFCA4: 419A0024  beq cr6, 0x82aafcc8
	if ctx.cr[6].eq {
	pc = 0x82AAFCC8; continue 'dispatch;
	}
	// 82AAFCA8: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAFCAC: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAFCB0: 8921007B  lbz r9, 0x7b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(123 as u32) ) } as u64;
	// 82AAFCB4: 89010078  lbz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AAFCB8: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAFCBC: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAFCC0: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAFCC4: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAFCC8; continue 'dispatch;
            }
            0x82AAFCC8 => {
    //   block [0x82AAFCC8..0x82AAFD24)
	// 82AAFCC8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAFCCC: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AAFCD0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAFCD4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAFCD8: 4198004C  blt cr6, 0x82aafd24
	if ctx.cr[6].lt {
	pc = 0x82AAFD24; continue 'dispatch;
	}
	// 82AAFCDC: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAFCE0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAFCE4: 3901007C  addi r8, r1, 0x7c
	ctx.r[8].s64 = ctx.r[1].s64 + 124;
	// 82AAFCE8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAFCEC: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAFCF0: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAFCF4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFCF8: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAFCFC: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAFD00: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAFD04: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAFD08: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAFD0C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAFD10: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAFD14: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAFD18: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAFD1C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAFD20: 48000014  b 0x82aafd34
	pc = 0x82AAFD34; continue 'dispatch;
            }
            0x82AAFD24 => {
    //   block [0x82AAFD24..0x82AAFD34)
	// 82AAFD24: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAFD28: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82AAFD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAFD30: 4BF711B9  bl 0x82a20ee8
	ctx.lr = 0x82AAFD34;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAFD34; continue 'dispatch;
            }
            0x82AAFD34 => {
    //   block [0x82AAFD34..0x82AAFD68)
	// 82AAFD34: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AAFD38: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAFD3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAFD40: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAFD44: 419A0024  beq cr6, 0x82aafd68
	if ctx.cr[6].eq {
	pc = 0x82AAFD68; continue 'dispatch;
	}
	// 82AAFD48: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAFD4C: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAFD50: 8921007F  lbz r9, 0x7f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(127 as u32) ) } as u64;
	// 82AAFD54: 8901007C  lbz r8, 0x7c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AAFD58: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAFD5C: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAFD60: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAFD64: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAFD68; continue 'dispatch;
            }
            0x82AAFD68 => {
    //   block [0x82AAFD68..0x82AAFDC4)
	// 82AAFD68: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAFD6C: 917C000C  stw r11, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AAFD70: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAFD74: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAFD78: 4198004C  blt cr6, 0x82aafdc4
	if ctx.cr[6].lt {
	pc = 0x82AAFDC4; continue 'dispatch;
	}
	// 82AAFD7C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAFD80: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAFD84: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82AAFD88: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAFD8C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAFD90: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAFD94: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFD98: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAFD9C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAFDA0: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAFDA4: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAFDA8: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAFDAC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAFDB0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAFDB4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAFDB8: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAFDBC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAFDC0: 48000014  b 0x82aafdd4
	pc = 0x82AAFDD4; continue 'dispatch;
            }
            0x82AAFDC4 => {
    //   block [0x82AAFDC4..0x82AAFDD4)
	// 82AAFDC4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAFDC8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AAFDCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAFDD0: 4BF71119  bl 0x82a20ee8
	ctx.lr = 0x82AAFDD4;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAFDD4; continue 'dispatch;
            }
            0x82AAFDD4 => {
    //   block [0x82AAFDD4..0x82AAFE08)
	// 82AAFDD4: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AAFDD8: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAFDDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAFDE0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAFDE4: 419A0024  beq cr6, 0x82aafe08
	if ctx.cr[6].eq {
	pc = 0x82AAFE08; continue 'dispatch;
	}
	// 82AAFDE8: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAFDEC: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAFDF0: 89210083  lbz r9, 0x83(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(131 as u32) ) } as u64;
	// 82AAFDF4: 89010080  lbz r8, 0x80(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AAFDF8: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAFDFC: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAFE00: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAFE04: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAFE08; continue 'dispatch;
            }
            0x82AAFE08 => {
    //   block [0x82AAFE08..0x82AAFE2C)
	// 82AAFE08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAFE0C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AAFE10: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFE14: 3BBD0014  addi r29, r29, 0x14
	ctx.r[29].s64 = ctx.r[29].s64 + 20;
	// 82AAFE18: 917C0010  stw r11, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82AAFE1C: 813A002C  lwz r9, 0x2c(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AAFE20: 7D5B492E  stwx r10, r27, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82AAFE24: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82AAFE28: 4082FD48  bne 0x82aafb70
	if !ctx.cr[0].eq {
	pc = 0x82AAFB70; continue 'dispatch;
	}
	pc = 0x82AAFE2C; continue 'dispatch;
            }
            0x82AAFE2C => {
    //   block [0x82AAFE2C..0x82AAFE80)
	// 82AAFE2C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAFE30: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAFE34: 4198004C  blt cr6, 0x82aafe80
	if ctx.cr[6].lt {
	pc = 0x82AAFE80; continue 'dispatch;
	}
	// 82AAFE38: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAFE3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAFE40: 39010084  addi r8, r1, 0x84
	ctx.r[8].s64 = ctx.r[1].s64 + 132;
	// 82AAFE44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAFE48: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAFE4C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAFE50: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFE54: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAFE58: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAFE5C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAFE60: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAFE64: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAFE68: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAFE6C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAFE70: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAFE74: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAFE78: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAFE7C: 48000014  b 0x82aafe90
	pc = 0x82AAFE90; continue 'dispatch;
            }
            0x82AAFE80 => {
    //   block [0x82AAFE80..0x82AAFE90)
	// 82AAFE80: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAFE84: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82AAFE88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAFE8C: 4BF7105D  bl 0x82a20ee8
	ctx.lr = 0x82AAFE90;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAFE90; continue 'dispatch;
            }
            0x82AAFE90 => {
    //   block [0x82AAFE90..0x82AAFEC4)
	// 82AAFE90: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AAFE94: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAFE98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAFE9C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAFEA0: 419A0024  beq cr6, 0x82aafec4
	if ctx.cr[6].eq {
	pc = 0x82AAFEC4; continue 'dispatch;
	}
	// 82AAFEA4: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAFEA8: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAFEAC: 89210087  lbz r9, 0x87(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(135 as u32) ) } as u64;
	// 82AAFEB0: 89010084  lbz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AAFEB4: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAFEB8: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAFEBC: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAFEC0: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82AAFEC4; continue 'dispatch;
            }
            0x82AAFEC4 => {
    //   block [0x82AAFEC4..0x82AAFF20)
	// 82AAFEC4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAFEC8: 917A0048  stw r11, 0x48(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82AAFECC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAFED0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AAFED4: 4198004C  blt cr6, 0x82aaff20
	if ctx.cr[6].lt {
	pc = 0x82AAFF20; continue 'dispatch;
	}
	// 82AAFED8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AAFEDC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAFEE0: 39010088  addi r8, r1, 0x88
	ctx.r[8].s64 = ctx.r[1].s64 + 136;
	// 82AAFEE4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAFEE8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AAFEEC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AAFEF0: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFEF4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AAFEF8: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AAFEFC: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AAFF00: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AAFF04: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AAFF08: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AAFF0C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AAFF10: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AAFF14: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AAFF18: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AAFF1C: 48000014  b 0x82aaff30
	pc = 0x82AAFF30; continue 'dispatch;
            }
            0x82AAFF20 => {
    //   block [0x82AAFF20..0x82AAFF30)
	// 82AAFF20: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AAFF24: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82AAFF28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAFF2C: 4BF70FBD  bl 0x82a20ee8
	ctx.lr = 0x82AAFF30;
	sub_82A20EE8(ctx, base);
	pc = 0x82AAFF30; continue 'dispatch;
            }
            0x82AAFF30 => {
    //   block [0x82AAFF30..0x82AAFF74)
	// 82AAFF30: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82AAFF34: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAFF38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAFF3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAFF40: 419A0034  beq cr6, 0x82aaff74
	if ctx.cr[6].eq {
	pc = 0x82AAFF74; continue 'dispatch;
	}
	// 82AAFF44: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82AAFF48: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82AAFF4C: 8921008B  lbz r9, 0x8b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(139 as u32) ) } as u64;
	// 82AAFF50: 89010088  lbz r8, 0x88(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82AAFF54: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82AAFF58: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82AAFF5C: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82AAFF60: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	// 82AAFF64: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAFF68: 90FA004C  stw r7, 0x4c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(76 as u32), ctx.r[7].u32 ) };
	// 82AAFF6C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AAFF70: 481F94DC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AAFF74 => {
    //   block [0x82AAFF74..0x82AAFF80)
	// 82AAFF74: 917A004C  stw r11, 0x4c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82AAFF78: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AAFF7C: 481F94D0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAFF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAFF80 size=344
    let mut pc: u32 = 0x82AAFF80;
    'dispatch: loop {
        match pc {
            0x82AAFF80 => {
    //   block [0x82AAFF80..0x82AB004C)
	// 82AAFF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAFF84: 481F9489  bl 0x82ca940c
	ctx.lr = 0x82AAFF88;
	sub_82CA93D0(ctx, base);
	// 82AAFF88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAFF8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAFF90: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AAFF94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFF98: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAFF9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AAFFA0: 4E800421  bctrl
	ctx.lr = 0x82AAFFA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAFFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAFFA8: 83DF0040  lwz r30, 0x40(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AAFFAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAFFB0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFFB4: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AAFFB8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82AAFFBC: 4E800421  bctrl
	ctx.lr = 0x82AAFFC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAFFC0: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFFC4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AAFFC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAFFCC: 80A70018  lwz r5, 0x18(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAFFD0: 83A60000  lwz r29, 0(r6)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAFFD4: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 82AAFFD8: 4E800421  bctrl
	ctx.lr = 0x82AAFFDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAFFDC: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 82AAFFE0: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AAFFE4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AAFFE8: 39442B60  addi r10, r4, 0x2b60
	ctx.r[10].s64 = ctx.r[4].s64 + 11104;
	// 82AAFFEC: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82AAFFF0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82AAFFF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAFFF8: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82AAFFFC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82AB0000: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AB0004: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 82AB0008: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AB000C: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82AB0010: 419A0054  beq cr6, 0x82ab0064
	if ctx.cr[6].eq {
	pc = 0x82AB0064; continue 'dispatch;
	}
	// 82AB0014: 894B0026  lbz r10, 0x26(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(38 as u32) ) } as u64;
	// 82AB0018: 554906F6  rlwinm r9, r10, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB001C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB0020: 409A0044  bne cr6, 0x82ab0064
	if !ctx.cr[6].eq {
	pc = 0x82AB0064; continue 'dispatch;
	}
	// 82AB0024: 554A0030  rlwinm r10, r10, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB0028: A08B0020  lhz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB002C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB0030: 419A001C  beq cr6, 0x82ab004c
	if ctx.cr[6].eq {
	pc = 0x82AB004C; continue 'dispatch;
	}
	// 82AB0034: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82AB0038: A0AB0024  lhz r5, 0x24(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB003C: 38CB001C  addi r6, r11, 0x1c
	ctx.r[6].s64 = ctx.r[11].s64 + 28;
	// 82AB0040: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB0044: 480AFD6D  bl 0x82b5fdb0
	ctx.lr = 0x82AB0048;
	sub_82B5FDB0(ctx, base);
	// 82AB0048: 4800001C  b 0x82ab0064
	pc = 0x82AB0064; continue 'dispatch;
            }
            0x82AB004C => {
    //   block [0x82AB004C..0x82AB0064)
	// 82AB004C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AB0050: A0CB0024  lhz r6, 0x24(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB0054: 38EB001C  addi r7, r11, 0x1c
	ctx.r[7].s64 = ctx.r[11].s64 + 28;
	// 82AB0058: A0AB0022  lhz r5, 0x22(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(34 as u32) ) } as u64;
	// 82AB005C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB0060: 480AFB49  bl 0x82b5fba8
	ctx.lr = 0x82AB0064;
	sub_82B5FBA8(ctx, base);
	pc = 0x82AB0064; continue 'dispatch;
            }
            0x82AB0064 => {
    //   block [0x82AB0064..0x82AB0080)
	// 82AB0064: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB0068: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB006C: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AB0070: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB0074: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AB0078: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82AB007C: 419A0020  beq cr6, 0x82ab009c
	if ctx.cr[6].eq {
	pc = 0x82AB009C; continue 'dispatch;
	}
	pc = 0x82AB0080; continue 'dispatch;
            }
            0x82AB0080 => {
    //   block [0x82AB0080..0x82AB009C)
	// 82AB0080: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AB0084: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB0088: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB008C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB0090: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB0094: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB0098: 4082FFE8  bne 0x82ab0080
	if !ctx.cr[0].eq {
	pc = 0x82AB0080; continue 'dispatch;
	}
	pc = 0x82AB009C; continue 'dispatch;
            }
            0x82AB009C => {
    //   block [0x82AB009C..0x82AB00D0)
	// 82AB009C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AB00A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AB00A4: 480DD0CD  bl 0x82b8d170
	ctx.lr = 0x82AB00A8;
	sub_82B8D170(ctx, base);
	// 82AB00A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB00AC: 4B707A6D  bl 0x821b7b18
	ctx.lr = 0x82AB00B0;
	sub_821B7B18(ctx, base);
	// 82AB00B0: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB00B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB00B8: 419A0018  beq cr6, 0x82ab00d0
	if ctx.cr[6].eq {
	pc = 0x82AB00D0; continue 'dispatch;
	}
	// 82AB00BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB00C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB00C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB00C8: 4E800421  bctrl
	ctx.lr = 0x82AB00CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB00CC: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
            }
            0x82AB00D0 => {
    //   block [0x82AB00D0..0x82AB00D8)
	// 82AB00D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB00D4: 481F9388  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB00D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AB00D8 size=476
    let mut pc: u32 = 0x82AB00D8;
    'dispatch: loop {
        match pc {
            0x82AB00D8 => {
    //   block [0x82AB00D8..0x82AB0280)
	// 82AB00D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB00DC: 481F931D  bl 0x82ca93f8
	ctx.lr = 0x82AB00E0;
	sub_82CA93D0(ctx, base);
	// 82AB00E0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB00E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB00E8: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82AB00EC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AB00F0: 3B3F0018  addi r25, r31, 0x18
	ctx.r[25].s64 = ctx.r[31].s64 + 24;
	// 82AB00F4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82AB00F8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB00FC: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AB0100: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82AB0104: 7D6853D7  divw. r11, r8, r10
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB0108: 40810178  ble 0x82ab0280
	if !ctx.cr[0].gt {
	pc = 0x82AB0280; continue 'dispatch;
	}
	// 82AB010C: 3B9F0038  addi r28, r31, 0x38
	ctx.r[28].s64 = ctx.r[31].s64 + 56;
	// 82AB0110: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82AB0114: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82AB0118: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AB011C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB0120: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB0124: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AB0128: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB012C: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 82AB0130: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82AB0134: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 82AB0138: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 82AB013C: F8E10068  std r7, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u64 ) };
	// 82AB0140: C9A10068  lfd f13, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AB0144: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0148: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AB014C: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0150: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82AB0154: 80C4000C  lwz r6, 0xc(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB0158: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 82AB015C: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB0160: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82AB0164: 7D053050  subf r8, r5, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 82AB0168: FCC05818  frsp f6, f11
	ctx.f[6].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82AB016C: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AB0170: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB0174: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 82AB0178: 7CC707B4  extsw r7, r6
	ctx.r[7].s64 = ctx.r[6].s32 as i64;
	// 82AB017C: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 82AB0180: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82AB0184: 7CA607B4  extsw r6, r5
	ctx.r[6].s64 = ctx.r[5].s32 as i64;
	// 82AB0188: C9210070  lfd f9, 0x70(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AB018C: F9210078  std r9, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u64 ) };
	// 82AB0190: C9010078  lfd f8, 0x78(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82AB0194: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82AB0198: C8A10088  lfd f5, 0x88(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82AB019C: F8E10080  std r7, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u64 ) };
	// 82AB01A0: C8E10080  lfd f7, 0x80(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82AB01A4: FC603E9C  fcfid f3, f7
	ctx.f[3].f64 = (ctx.f[7].s64 as f64);
	// 82AB01A8: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82AB01AC: FC40469C  fcfid f2, f8
	ctx.f[2].f64 = (ctx.f[8].s64 as f64);
	// 82AB01B0: 80A40010  lwz r5, 0x10(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB01B4: FC204E9C  fcfid f1, f9
	ctx.f[1].f64 = (ctx.f[9].s64 as f64);
	// 82AB01B8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB01BC: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82AB01C0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82AB01C4: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82AB01C8: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82AB01CC: FDA01818  frsp f13, f3
	ctx.f[13].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82AB01D0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AB01D4: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82AB01D8: FD801018  frsp f12, f2
	ctx.f[12].f64 = (ctx.f[2].f64 as f32) as f64;
	// 82AB01DC: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82AB01E0: FC002018  frsp f0, f4
	ctx.f[0].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82AB01E4: ED0D3024  fdivs f8, f13, f6
	ctx.f[8].f64 = ((ctx.f[13].f64 / ctx.f[6].f64) as f32) as f64;
	// 82AB01E8: D1010094  stfs f8, 0x94(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AB01EC: ECEC5024  fdivs f7, f12, f10
	ctx.f[7].f64 = ((ctx.f[12].f64 / ctx.f[10].f64) as f32) as f64;
	// 82AB01F0: D0E10090  stfs f7, 0x90(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AB01F4: ECCB3024  fdivs f6, f11, f6
	ctx.f[6].f64 = ((ctx.f[11].f64 / ctx.f[6].f64) as f32) as f64;
	// 82AB01F8: D0C1009C  stfs f6, 0x9c(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82AB01FC: ED205024  fdivs f9, f0, f10
	ctx.f[9].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82AB0200: D1210098  stfs f9, 0x98(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AB0204: 4B6FB895  bl 0x821aba98
	ctx.lr = 0x82AB0208;
	sub_821ABA98(ctx, base);
	// 82AB0208: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 82AB020C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82AB0210: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AB0214: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x82AB0280; continue 'dispatch;
            }
            0x82AB0280 => {
    //   block [0x82AB0280..0x82AB02B4)
	// 82AB0280: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0284: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AB0288: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB028C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB0290: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 82AB0294: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82AB0298: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AB029C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AB02A0: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AB02A4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB02A8: 480001E1  bl 0x82ab0488
	ctx.lr = 0x82AB02AC;
	sub_82AB0488(ctx, base);
	// 82AB02AC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82AB02B0: 481F9198  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB02B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB02B8 size=268
    let mut pc: u32 = 0x82AB02B8;
    'dispatch: loop {
        match pc {
            0x82AB02B8 => {
    //   block [0x82AB02B8..0x82AB03C4)
	// 82AB02B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB02BC: 481F913D  bl 0x82ca93f8
	ctx.lr = 0x82AB02C0;
	sub_82CA93D0(ctx, base);
	// 82AB02C0: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB03C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB03C8 size=60
    let mut pc: u32 = 0x82AB03C8;
    'dispatch: loop {
        match pc {
            0x82AB03C8 => {
    //   block [0x82AB03C8..0x82AB0404)
	// 82AB03C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB03CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB03D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB03D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB03D8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AB03DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AB03E0: 388B844C  addi r4, r11, -0x7bb4
	ctx.r[4].s64 = ctx.r[11].s64 + -31668;
	// 82AB03E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB03E8: 4B77CAE9  bl 0x8222ced0
	ctx.lr = 0x82AB03EC;
	sub_8222CED0(ctx, base);
	// 82AB03EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB03F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AB03F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB03F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB03FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB0400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB0408 size=128
    let mut pc: u32 = 0x82AB0408;
    'dispatch: loop {
        match pc {
            0x82AB0408 => {
    //   block [0x82AB0408..0x82AB0468)
	// 82AB0408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB040C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB0410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AB0414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB0418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB041C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB0420: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB0424: 4B7076F5  bl 0x821b7b18
	ctx.lr = 0x82AB0428;
	sub_821B7B18(ctx, base);
	// 82AB0428: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AB042C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB0430: 419A0040  beq cr6, 0x82ab0470
	if ctx.cr[6].eq {
	pc = 0x82AB0470; continue 'dispatch;
	}
	// 82AB0434: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AB0438: 4B76EE21  bl 0x8221f258
	ctx.lr = 0x82AB043C;
	sub_8221F258(ctx, base);
	// 82AB043C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB0440: 419A0028  beq cr6, 0x82ab0468
	if ctx.cr[6].eq {
	pc = 0x82AB0468; continue 'dispatch;
	}
	// 82AB0444: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0448: 3D2082AB  lis r9, -0x7d55
	ctx.r[9].s64 = -2102722560;
	// 82AB044C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AB0450: 38E905F8  addi r7, r9, 0x5f8
	ctx.r[7].s64 = ctx.r[9].s64 + 1528;
	// 82AB0454: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AB0458: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AB045C: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AB0460: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB0464: 48000008  b 0x82ab046c
	pc = 0x82AB046C; continue 'dispatch;
            }
            0x82AB0468 => {
    //   block [0x82AB0468..0x82AB046C)
	// 82AB0468: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AB046C; continue 'dispatch;
            }
            0x82AB046C => {
    //   block [0x82AB046C..0x82AB0470)
	// 82AB046C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB0470; continue 'dispatch;
            }
            0x82AB0470 => {
    //   block [0x82AB0470..0x82AB0488)
	// 82AB0470: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB0474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB0478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB047C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AB0480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB0484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB0488 size=148
    let mut pc: u32 = 0x82AB0488;
    'dispatch: loop {
        match pc {
            0x82AB0488 => {
    //   block [0x82AB0488..0x82AB04D0)
	// 82AB0488: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82AB048C: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82AB0490: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82AB0494: 80E10024  lwz r7, 0x24(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB0498: 8161002C  lwz r11, 0x2c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB049C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB04A0: 419A0070  beq cr6, 0x82ab0510
	if ctx.cr[6].eq {
	pc = 0x82AB0510; continue 'dispatch;
	}
	// 82AB04A4: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB04A8: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 82AB04AC: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB04B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB04B4: 7D284BD6  divw r9, r8, r9
	ctx.r[9].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82AB04B8: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AB04BC: 7CC94214  add r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82AB04C0: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB04C4: 7CC93A14  add r6, r9, r7
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 82AB04C8: 419A0044  beq cr6, 0x82ab050c
	if ctx.cr[6].eq {
	pc = 0x82AB050C; continue 'dispatch;
	}
	// 82AB04CC: 7D2B3850  subf r9, r11, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	pc = 0x82AB04D0; continue 'dispatch;
            }
            0x82AB04D0 => {
    //   block [0x82AB04D0..0x82AB050C)
	// 82AB04D0: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB04D4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82AB04D8: 7FE94214  add r31, r9, r8
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82AB04DC: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82AB04E0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB04E4: 7CE9412E  stwx r7, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u32) };
	// 82AB04E8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB04EC: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AB04F0: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB04F4: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82AB04F8: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB04FC: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82AB0500: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82AB0504: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB0508: 409AFFC8  bne cr6, 0x82ab04d0
	if !ctx.cr[6].eq {
	pc = 0x82AB04D0; continue 'dispatch;
	}
	pc = 0x82AB050C; continue 'dispatch;
            }
            0x82AB050C => {
    //   block [0x82AB050C..0x82AB0510)
	// 82AB050C: 90C40008  stw r6, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82AB0510; continue 'dispatch;
            }
            0x82AB0510 => {
    //   block [0x82AB0510..0x82AB051C)
	// 82AB0510: F8A30000  std r5, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82AB0514: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82AB0518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB0520 size=216
    let mut pc: u32 = 0x82AB0520;
    'dispatch: loop {
        match pc {
            0x82AB0520 => {
    //   block [0x82AB0520..0x82AB0578)
	// 82AB0520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB0524: 481F8ECD  bl 0x82ca93f0
	ctx.lr = 0x82AB0528;
	sub_82CA93D0(ctx, base);
	// 82AB0528: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB052C: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82AB0530: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82AB0534: FAC100D0  std r22, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[22].u64 ) };
	// 82AB0538: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82AB053C: F8C100D8  std r6, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[6].u64 ) };
	// 82AB0540: 814100D4  lwz r10, 0xd4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AB0544: 816100DC  lwz r11, 0xdc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82AB0548: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB054C: 419A009C  beq cr6, 0x82ab05e8
	if ctx.cr[6].eq {
	pc = 0x82AB05E8; continue 'dispatch;
	}
	// 82AB0550: 83590008  lwz r26, 8(r25)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0554: 7D2BD050  subf r9, r11, r26
	ctx.r[9].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 82AB0558: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB055C: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AB0560: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB0564: 7F095214  add r24, r9, r10
	ctx.r[24].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AB0568: 419A0058  beq cr6, 0x82ab05c0
	if ctx.cr[6].eq {
	pc = 0x82AB05C0; continue 'dispatch;
	}
	// 82AB056C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82AB0570: 3BEA0004  addi r31, r10, 4
	ctx.r[31].s64 = ctx.r[10].s64 + 4;
	// 82AB0574: 7F6A5850  subf r27, r10, r11
	ctx.r[27].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	pc = 0x82AB0578; continue 'dispatch;
            }
            0x82AB0578 => {
    //   block [0x82AB0578..0x82AB05B0)
	// 82AB0578: 7FDFD82E  lwzx r30, r31, r27
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82AB057C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0580: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0584: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB0588: 419A0028  beq cr6, 0x82ab05b0
	if ctx.cr[6].eq {
	pc = 0x82AB05B0; continue 'dispatch;
	}
	// 82AB058C: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 82AB0590: 4B707589  bl 0x821b7b18
	ctx.lr = 0x82AB0594;
	sub_821B7B18(ctx, base);
	// 82AB0594: 939FFFFC  stw r28, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[28].u32 ) };
	// 82AB0598: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AB059C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB05A0: 419A0010  beq cr6, 0x82ab05b0
	if ctx.cr[6].eq {
	pc = 0x82AB05B0; continue 'dispatch;
	}
	// 82AB05A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB05A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB05AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB05B0; continue 'dispatch;
            }
            0x82AB05B0 => {
    //   block [0x82AB05B0..0x82AB05C0)
	// 82AB05B0: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82AB05B4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AB05B8: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB05BC: 409AFFBC  bne cr6, 0x82ab0578
	if !ctx.cr[6].eq {
	pc = 0x82AB0578; continue 'dispatch;
	}
	pc = 0x82AB05C0; continue 'dispatch;
            }
            0x82AB05C0 => {
    //   block [0x82AB05C0..0x82AB05D0)
	// 82AB05C0: 83D90008  lwz r30, 8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB05C4: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 82AB05C8: 7F18F040  cmplw cr6, r24, r30
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB05CC: 419A0018  beq cr6, 0x82ab05e4
	if ctx.cr[6].eq {
	pc = 0x82AB05E4; continue 'dispatch;
	}
	pc = 0x82AB05D0; continue 'dispatch;
            }
            0x82AB05D0 => {
    //   block [0x82AB05D0..0x82AB05E4)
	// 82AB05D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB05D4: 4B707545  bl 0x821b7b18
	ctx.lr = 0x82AB05D8;
	sub_821B7B18(ctx, base);
	// 82AB05D8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AB05DC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB05E0: 409AFFF0  bne cr6, 0x82ab05d0
	if !ctx.cr[6].eq {
	pc = 0x82AB05D0; continue 'dispatch;
	}
	pc = 0x82AB05E4; continue 'dispatch;
            }
            0x82AB05E4 => {
    //   block [0x82AB05E4..0x82AB05E8)
	// 82AB05E4: 93190008  stw r24, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	pc = 0x82AB05E8; continue 'dispatch;
            }
            0x82AB05E8 => {
    //   block [0x82AB05E8..0x82AB05F8)
	// 82AB05E8: FAD70000  std r22, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[22].u64 ) };
	// 82AB05EC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82AB05F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AB05F4: 481F8E4C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB05F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB05F8 size=60
    let mut pc: u32 = 0x82AB05F8;
    'dispatch: loop {
        match pc {
            0x82AB05F8 => {
    //   block [0x82AB05F8..0x82AB0620)
	// 82AB05F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB05FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB0600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB0604: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB0608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB060C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB0610: 419A0010  beq cr6, 0x82ab0620
	if ctx.cr[6].eq {
	pc = 0x82AB0620; continue 'dispatch;
	}
	// 82AB0614: 4BFFE77D  bl 0x82aaed90
	ctx.lr = 0x82AB0618;
	sub_82AAED90(ctx, base);
	// 82AB0618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB061C: 4B76B71D  bl 0x8221bd38
	ctx.lr = 0x82AB0620;
	sub_8221BD38(ctx, base);
	pc = 0x82AB0620; continue 'dispatch;
            }
            0x82AB0620 => {
    //   block [0x82AB0620..0x82AB0634)
	// 82AB0620: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AB0624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB0628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB062C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB0630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB0638 size=800
    let mut pc: u32 = 0x82AB0638;
    'dispatch: loop {
        match pc {
            0x82AB0638 => {
    //   block [0x82AB0638..0x82AB0690)
	// 82AB0638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB063C: 481F8DB1  bl 0x82ca93ec
	ctx.lr = 0x82AB0640;
	sub_82CA93D0(ctx, base);
	// 82AB0640: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB0644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB0648: 82A60000  lwz r21, 0(r6)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB064C: 83260004  lwz r25, 4(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0650: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AB0654: 83060008  lwz r24, 8(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0658: 3B400014  li r26, 0x14
	ctx.r[26].s64 = 20;
	// 82AB065C: 82E6000C  lwz r23, 0xc(r6)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB0660: 82C60010  lwz r22, 0x10(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB0664: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0668: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82AB066C: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 82AB0670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB0674: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82AB0678: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 82AB067C: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 82AB0680: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 82AB0684: 409A000C  bne cr6, 0x82ab0690
	if !ctx.cr[6].eq {
	pc = 0x82AB0690; continue 'dispatch;
	}
	// 82AB0688: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB068C: 48000010  b 0x82ab069c
	pc = 0x82AB069C; continue 'dispatch;
            }
            0x82AB0690 => {
    //   block [0x82AB0690..0x82AB069C)
	// 82AB0690: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB0694: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB0698: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82AB069C; continue 'dispatch;
            }
            0x82AB069C => {
    //   block [0x82AB069C..0x82AB06D0)
	// 82AB069C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB06A0: 419A02B0  beq cr6, 0x82ab0950
	if ctx.cr[6].eq {
	pc = 0x82AB0950; continue 'dispatch;
	}
	// 82AB06A4: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB06A8: 3D400CCC  lis r10, 0xccc
	ctx.r[10].s64 = 214695936;
	// 82AB06AC: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82AB06B0: 614ACCCC  ori r10, r10, 0xcccc
	ctx.r[10].u64 = ctx.r[10].u64 | 52428;
	// 82AB06B4: 7D68D3D6  divw r11, r8, r26
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[26].s32;
	// 82AB06B8: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB06BC: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB06C0: 40980010  bge cr6, 0x82ab06d0
	if !ctx.cr[6].lt {
	pc = 0x82AB06D0; continue 'dispatch;
	}
	// 82AB06C4: 4BF96E05  bl 0x82a474c8
	ctx.lr = 0x82AB06C8;
	sub_82A474C8(ctx, base);
	// 82AB06C8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB06CC: 481F8D70  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB06D0 => {
    //   block [0x82AB06D0..0x82AB06F4)
	// 82AB06D0: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AB06D4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB06D8: 409800FC  bge cr6, 0x82ab07d4
	if !ctx.cr[6].lt {
	pc = 0x82AB07D4; continue 'dispatch;
	}
	// 82AB06DC: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB06E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AB06E4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB06E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB06EC: 41980008  blt cr6, 0x82ab06f4
	if ctx.cr[6].lt {
	pc = 0x82AB06F4; continue 'dispatch;
	}
	// 82AB06F0: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82AB06F4; continue 'dispatch;
            }
            0x82AB06F4 => {
    //   block [0x82AB06F4..0x82AB0700)
	// 82AB06F4: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB06F8: 40980008  bge cr6, 0x82ab0700
	if !ctx.cr[6].lt {
	pc = 0x82AB0700; continue 'dispatch;
	}
	// 82AB06FC: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	pc = 0x82AB0700; continue 'dispatch;
            }
            0x82AB0700 => {
    //   block [0x82AB0700..0x82AB073C)
	// 82AB0700: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AB0704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB0708: 4B9B2C21  bl 0x82463328
	ctx.lr = 0x82AB070C;
	sub_82463328(ctx, base);
	// 82AB070C: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AB0710: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB0714: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0718: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AB071C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AB0720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB0724: 480002A5  bl 0x82ab09c8
	ctx.lr = 0x82AB0728;
	sub_82AB09C8(ctx, base);
	// 82AB0728: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82AB072C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 82AB0730: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB0734: 419A002C  beq cr6, 0x82ab0760
	if ctx.cr[6].eq {
	pc = 0x82AB0760; continue 'dispatch;
	}
	// 82AB0738: 396A000C  addi r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 + 12;
	pc = 0x82AB073C; continue 'dispatch;
            }
            0x82AB073C => {
    //   block [0x82AB073C..0x82AB0758)
	// 82AB073C: 352BFFF4  addic. r9, r11, -0xc
	ctx.xer.ca = (ctx.r[11].u32 > (!(-12 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + -12;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB0740: 41820018  beq 0x82ab0758
	if ctx.cr[0].eq {
	pc = 0x82AB0758; continue 'dispatch;
	}
	// 82AB0744: 92ABFFF4  stw r21, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[21].u32 ) };
	// 82AB0748: 932BFFF8  stw r25, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[25].u32 ) };
	// 82AB074C: 930BFFFC  stw r24, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[24].u32 ) };
	// 82AB0750: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82AB0754: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	pc = 0x82AB0758; continue 'dispatch;
            }
            0x82AB0758 => {
    //   block [0x82AB0758..0x82AB0760)
	// 82AB0758: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82AB075C: 4200FFE0  bdnz 0x82ab073c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AB073C; continue 'dispatch;
	}
	pc = 0x82AB0760; continue 'dispatch;
            }
            0x82AB0760 => {
    //   block [0x82AB0760..0x82AB07A0)
	// 82AB0760: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB0764: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0768: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AB076C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82AB0770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB0774: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB0778: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB077C: 4800024D  bl 0x82ab09c8
	ctx.lr = 0x82AB0780;
	sub_82AB09C8(ctx, base);
	// 82AB0780: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0784: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB078C: 7D235050  subf r9, r3, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 82AB0790: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 82AB0794: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AB0798: 419A0008  beq cr6, 0x82ab07a0
	if ctx.cr[6].eq {
	pc = 0x82AB07A0; continue 'dispatch;
	}
	// 82AB079C: 4B76B59D  bl 0x8221bd38
	ctx.lr = 0x82AB07A0;
	sub_8221BD38(ctx, base);
	pc = 0x82AB07A0; continue 'dispatch;
            }
            0x82AB07A0 => {
    //   block [0x82AB07A0..0x82AB07D4)
	// 82AB07A0: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB07A4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AB07A8: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB07AC: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82AB07B0: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82AB07B4: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB07B8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB07BC: 7CEBEA14  add r7, r11, r29
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AB07C0: 7D0AEA14  add r8, r10, r29
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82AB07C4: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82AB07C8: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82AB07CC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB07D0: 481F8C6C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB07D4 => {
    //   block [0x82AB07D4..0x82AB081C)
	// 82AB07D4: 83A100EC  lwz r29, 0xec(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AB07D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB07DC: 7D7D2850  subf r11, r29, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[29].s64;
	// 82AB07E0: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 82AB07E4: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB07E8: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB07EC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82AB07F0: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82AB07F4: 409800B0  bge cr6, 0x82ab08a4
	if !ctx.cr[6].lt {
	pc = 0x82AB08A4; continue 'dispatch;
	}
	// 82AB07F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AB07FC: 7CDCEA14  add r6, r28, r29
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 82AB0800: 480001C9  bl 0x82ab09c8
	ctx.lr = 0x82AB0804;
	sub_82AB09C8(ctx, base);
	// 82AB0804: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0808: 7D3D5050  subf r9, r29, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 82AB080C: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 82AB0810: 7D28F051  subf. r9, r8, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB0814: 41820034  beq 0x82ab0848
	if ctx.cr[0].eq {
	pc = 0x82AB0848; continue 'dispatch;
	}
	// 82AB0818: 396A000C  addi r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 + 12;
	pc = 0x82AB081C; continue 'dispatch;
            }
            0x82AB081C => {
    //   block [0x82AB081C..0x82AB0838)
	// 82AB081C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB0820: 419A0018  beq cr6, 0x82ab0838
	if ctx.cr[6].eq {
	pc = 0x82AB0838; continue 'dispatch;
	}
	// 82AB0824: 92AA0000  stw r21, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 82AB0828: 932BFFF8  stw r25, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[25].u32 ) };
	// 82AB082C: 930BFFFC  stw r24, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[24].u32 ) };
	// 82AB0830: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82AB0834: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	pc = 0x82AB0838; continue 'dispatch;
            }
            0x82AB0838 => {
    //   block [0x82AB0838..0x82AB0848)
	// 82AB0838: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB083C: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82AB0840: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82AB0844: 4082FFD8  bne 0x82ab081c
	if !ctx.cr[0].eq {
	pc = 0x82AB081C; continue 'dispatch;
	}
	pc = 0x82AB0848; continue 'dispatch;
            }
            0x82AB0848 => {
    //   block [0x82AB0848..0x82AB0864)
	// 82AB0848: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB084C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82AB0850: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82AB0854: 7D3C5050  subf r9, r28, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[28].s64;
	// 82AB0858: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB085C: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB0860: 419A00F0  beq cr6, 0x82ab0950
	if ctx.cr[6].eq {
	pc = 0x82AB0950; continue 'dispatch;
	}
	pc = 0x82AB0864; continue 'dispatch;
            }
            0x82AB0864 => {
    //   block [0x82AB0864..0x82AB08A4)
	// 82AB0864: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82AB0868: 92AB0000  stw r21, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 82AB086C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82AB0870: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82AB0874: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB0878: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB087C: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0880: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0884: 808A000C  lwz r4, 0xc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB0888: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82AB088C: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB0890: 90A80008  stw r5, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82AB0894: 9088000C  stw r4, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82AB0898: 409AFFCC  bne cr6, 0x82ab0864
	if !ctx.cr[6].eq {
	pc = 0x82AB0864; continue 'dispatch;
	}
	// 82AB089C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB08A0: 481F8B9C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB08A4 => {
    //   block [0x82AB08A4..0x82AB08CC)
	// 82AB08A4: 7FDC2850  subf r30, r28, r5
	ctx.r[30].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 82AB08A8: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82AB08AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB08B0: 48000119  bl 0x82ab09c8
	ctx.lr = 0x82AB08B4;
	sub_82AB09C8(ctx, base);
	// 82AB08B4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AB08B8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82AB08BC: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB08C0: 419A0048  beq cr6, 0x82ab0908
	if ctx.cr[6].eq {
	pc = 0x82AB0908; continue 'dispatch;
	}
	// 82AB08C4: 7D7C4A14  add r11, r28, r9
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[9].u64;
	// 82AB08C8: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	pc = 0x82AB08CC; continue 'dispatch;
            }
            0x82AB08CC => {
    //   block [0x82AB08CC..0x82AB0908)
	// 82AB08CC: 3929FFEC  addi r9, r9, -0x14
	ctx.r[9].s64 = ctx.r[9].s64 + -20;
	// 82AB08D0: 396BFFEC  addi r11, r11, -0x14
	ctx.r[11].s64 = ctx.r[11].s64 + -20;
	// 82AB08D4: 394AFFEC  addi r10, r10, -0x14
	ctx.r[10].s64 = ctx.r[10].s64 + -20;
	// 82AB08D8: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AB08DC: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB08E0: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AB08E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB08E8: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AB08EC: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB08F0: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82AB08F4: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB08F8: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82AB08FC: 808A000C  lwz r4, 0xc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB0900: 908B0010  stw r4, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 82AB0904: 409AFFC8  bne cr6, 0x82ab08cc
	if !ctx.cr[6].eq {
	pc = 0x82AB08CC; continue 'dispatch;
	}
	pc = 0x82AB0908; continue 'dispatch;
            }
            0x82AB0908 => {
    //   block [0x82AB0908..0x82AB0918)
	// 82AB0908: 7D5CEA14  add r10, r28, r29
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 82AB090C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82AB0910: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB0914: 419A003C  beq cr6, 0x82ab0950
	if ctx.cr[6].eq {
	pc = 0x82AB0950; continue 'dispatch;
	}
	pc = 0x82AB0918; continue 'dispatch;
            }
            0x82AB0918 => {
    //   block [0x82AB0918..0x82AB0950)
	// 82AB0918: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 82AB091C: 92AB0000  stw r21, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 82AB0920: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82AB0924: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82AB0928: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB092C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0930: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0934: 80A90008  lwz r5, 8(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0938: 8089000C  lwz r4, 0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB093C: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82AB0940: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB0944: 90A80008  stw r5, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82AB0948: 9088000C  stw r4, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82AB094C: 409AFFCC  bne cr6, 0x82ab0918
	if !ctx.cr[6].eq {
	pc = 0x82AB0918; continue 'dispatch;
	}
	pc = 0x82AB0950; continue 'dispatch;
            }
            0x82AB0950 => {
    //   block [0x82AB0950..0x82AB0958)
	// 82AB0950: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB0954: 481F8AE8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB0958 size=112
    let mut pc: u32 = 0x82AB0958;
    'dispatch: loop {
        match pc {
            0x82AB0958 => {
    //   block [0x82AB0958..0x82AB09AC)
	// 82AB0958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB095C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB0960: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB0964: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB0968: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AB096C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB0970: 419A003C  beq cr6, 0x82ab09ac
	if ctx.cr[6].eq {
	pc = 0x82AB09AC; continue 'dispatch;
	}
	// 82AB0974: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82AB0978: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82AB097C: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 82AB0980: 4098002C  bge cr6, 0x82ab09ac
	if !ctx.cr[6].lt {
	pc = 0x82AB09AC; continue 'dispatch;
	}
	// 82AB0984: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AB0988: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB098C: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82AB0990: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AB0994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB0998: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AB099C: 4B841485  bl 0x822f1e20
	ctx.lr = 0x82AB09A0;
	sub_822F1E20(ctx, base);
	// 82AB09A0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82AB09A4: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82AB09A8: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82AB09AC; continue 'dispatch;
            }
            0x82AB09AC => {
    //   block [0x82AB09AC..0x82AB09C8)
	// 82AB09AC: 57E31838  slwi r3, r31, 3
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB09B0: 4B76E8A9  bl 0x8221f258
	ctx.lr = 0x82AB09B4;
	sub_8221F258(ctx, base);
	// 82AB09B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB09B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB09BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB09C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB09C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB09C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB09C8 size=100
    let mut pc: u32 = 0x82AB09C8;
    'dispatch: loop {
        match pc {
            0x82AB09C8 => {
    //   block [0x82AB09C8..0x82AB09E0)
	// 82AB09C8: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82AB09CC: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AB09D0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AB09D4: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 82AB09D8: 3964000C  addi r11, r4, 0xc
	ctx.r[11].s64 = ctx.r[4].s64 + 12;
	// 82AB09DC: 7D241850  subf r9, r4, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x82AB09E0; continue 'dispatch;
            }
            0x82AB09E0 => {
    //   block [0x82AB09E0..0x82AB0A10)
	// 82AB09E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB09E4: 419A002C  beq cr6, 0x82ab0a10
	if ctx.cr[6].eq {
	pc = 0x82AB0A10; continue 'dispatch;
	}
	// 82AB09E8: 810BFFF4  lwz r8, -0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82AB09EC: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AB09F0: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB09F4: 90EAFFF4  stw r7, -0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-12 as u32), ctx.r[7].u32 ) };
	// 82AB09F8: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AB09FC: 90CAFFF8  stw r6, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 82AB0A00: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0A04: 7C89592E  stwx r4, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 82AB0A08: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0A0C: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82AB0A10; continue 'dispatch;
            }
            0x82AB0A10 => {
    //   block [0x82AB0A10..0x82AB0A2C)
	// 82AB0A10: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82AB0A14: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 82AB0A18: 390BFFF4  addi r8, r11, -0xc
	ctx.r[8].s64 = ctx.r[11].s64 + -12;
	// 82AB0A1C: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82AB0A20: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AB0A24: 409AFFBC  bne cr6, 0x82ab09e0
	if !ctx.cr[6].eq {
	pc = 0x82AB09E0; continue 'dispatch;
	}
	// 82AB0A28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AB0A30 size=464
    let mut pc: u32 = 0x82AB0A30;
    'dispatch: loop {
        match pc {
            0x82AB0A30 => {
    //   block [0x82AB0A30..0x82AB0C00)
	// 82AB0A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB0A34: 481F89D9  bl 0x82ca940c
	ctx.lr = 0x82AB0A38;
	sub_82CA93D0(ctx, base);
	// 82AB0A38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB0A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB0A40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AB0A44: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AB0A48: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AB0A4C: 909F001C  stw r4, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82AB0A50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AB0A54: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AB0A58: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82AB0A5C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AB0A60: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 82AB0A64: 90BF0020  stw r5, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[5].u32 ) };
	// 82AB0A68: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AB0A6C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82AB0A70: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AB0A74: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB0A78: 38E88A68  addi r7, r8, -0x7598
	ctx.r[7].s64 = ctx.r[8].s64 + -30104;
	// 82AB0A7C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AB0A80: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB0C00 size=80
    let mut pc: u32 = 0x82AB0C00;
    'dispatch: loop {
        match pc {
            0x82AB0C00 => {
    //   block [0x82AB0C00..0x82AB0C38)
	// 82AB0C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB0C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB0C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AB0C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB0C10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB0C14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB0C18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB0C1C: 48000035  bl 0x82ab0c50
	ctx.lr = 0x82AB0C20;
	sub_82AB0C50(ctx, base);
	// 82AB0C20: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82AB0C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB0C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB0C2C: 419A000C  beq cr6, 0x82ab0c38
	if ctx.cr[6].eq {
	pc = 0x82AB0C38; continue 'dispatch;
	}
	// 82AB0C30: 4B76B109  bl 0x8221bd38
	ctx.lr = 0x82AB0C34;
	sub_8221BD38(ctx, base);
	// 82AB0C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82AB0C38; continue 'dispatch;
            }
            0x82AB0C38 => {
    //   block [0x82AB0C38..0x82AB0C50)
	// 82AB0C38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB0C3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB0C40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB0C44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AB0C48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB0C4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB0C50 size=232
    let mut pc: u32 = 0x82AB0C50;
    'dispatch: loop {
        match pc {
            0x82AB0C50 => {
    //   block [0x82AB0C50..0x82AB0CA4)
	// 82AB0C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB0C54: 481F87B9  bl 0x82ca940c
	ctx.lr = 0x82AB0C58;
	sub_82CA93D0(ctx, base);
	// 82AB0C58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB0C5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB0C60: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AB0C64: 394B8A68  addi r10, r11, -0x7598
	ctx.r[10].s64 = ctx.r[11].s64 + -30104;
	// 82AB0C68: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB0C6C: 480020DD  bl 0x82ab2d48
	ctx.lr = 0x82AB0C70;
	sub_82AB2D48(ctx, base);
	// 82AB0C70: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82AB0C74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB0C78: 3869AA88  addi r3, r9, -0x5578
	ctx.r[3].s64 = ctx.r[9].s64 + -21880;
	// 82AB0C7C: 4BF72B9D  bl 0x82a23818
	ctx.lr = 0x82AB0C80;
	sub_82A23818(ctx, base);
	// 82AB0C80: 387F00DC  addi r3, r31, 0xdc
	ctx.r[3].s64 = ctx.r[31].s64 + 220;
	// 82AB0C84: 48002DCD  bl 0x82ab3a50
	ctx.lr = 0x82AB0C88;
	sub_82AB3A50(ctx, base);
	// 82AB0C88: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 82AB0C8C: 4B706E8D  bl 0x821b7b18
	ctx.lr = 0x82AB0C90;
	sub_821B7B18(ctx, base);
	// 82AB0C90: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82AB0C94: 3BDF00C4  addi r30, r31, 0xc4
	ctx.r[30].s64 = ctx.r[31].s64 + 196;
	// 82AB0C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB0C9C: 419A0008  beq cr6, 0x82ab0ca4
	if ctx.cr[6].eq {
	pc = 0x82AB0CA4; continue 'dispatch;
	}
	// 82AB0CA0: 4B76B099  bl 0x8221bd38
	ctx.lr = 0x82AB0CA4;
	sub_8221BD38(ctx, base);
	pc = 0x82AB0CA4; continue 'dispatch;
            }
            0x82AB0CA4 => {
    //   block [0x82AB0CA4..0x82AB0CC4)
	// 82AB0CA4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AB0CA8: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AB0CAC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82AB0CB0: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82AB0CB4: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AB0CB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB0CBC: 419A0040  beq cr6, 0x82ab0cfc
	if ctx.cr[6].eq {
	pc = 0x82AB0CFC; continue 'dispatch;
	}
	// 82AB0CC0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB0CC4; continue 'dispatch;
            }
            0x82AB0CC4 => {
    //   block [0x82AB0CC4..0x82AB0CF8)
	// 82AB0CC4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB0CC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB0CCC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB0CD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB0CD4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB0CD8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB0CDC: 4082FFE8  bne 0x82ab0cc4
	if !ctx.cr[0].eq {
	pc = 0x82AB0CC4; continue 'dispatch;
	}
	// 82AB0CE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB0CE4: 409A0014  bne cr6, 0x82ab0cf8
	if !ctx.cr[6].eq {
	pc = 0x82AB0CF8; continue 'dispatch;
	}
	// 82AB0CE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0CEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0CF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB0CF4: 4E800421  bctrl
	ctx.lr = 0x82AB0CF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB0CF8 => {
    //   block [0x82AB0CF8..0x82AB0CFC)
	// 82AB0CF8: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	pc = 0x82AB0CFC; continue 'dispatch;
            }
            0x82AB0CFC => {
    //   block [0x82AB0CFC..0x82AB0D24)
	// 82AB0CFC: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 82AB0D00: 4B869E59  bl 0x8231ab58
	ctx.lr = 0x82AB0D04;
	sub_8231AB58(ctx, base);
	// 82AB0D04: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AB0D08: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB0D0C: 394B2B98  addi r10, r11, 0x2b98
	ctx.r[10].s64 = ctx.r[11].s64 + 11160;
	// 82AB0D10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB0D14: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB0D18: 419A000C  beq cr6, 0x82ab0d24
	if ctx.cr[6].eq {
	pc = 0x82AB0D24; continue 'dispatch;
	}
	// 82AB0D1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB0D20: 4BF72AF9  bl 0x82a23818
	ctx.lr = 0x82AB0D24;
	sub_82A23818(ctx, base);
	pc = 0x82AB0D24; continue 'dispatch;
            }
            0x82AB0D24 => {
    //   block [0x82AB0D24..0x82AB0D38)
	// 82AB0D24: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AB0D28: 394B0FD0  addi r10, r11, 0xfd0
	ctx.r[10].s64 = ctx.r[11].s64 + 4048;
	// 82AB0D2C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB0D30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB0D34: 481F8728  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB0D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB0D38 size=1064
    let mut pc: u32 = 0x82AB0D38;
    'dispatch: loop {
        match pc {
            0x82AB0D38 => {
    //   block [0x82AB0D38..0x82AB0DC8)
	// 82AB0D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB0D3C: 481F86C1  bl 0x82ca93fc
	ctx.lr = 0x82AB0D40;
	sub_82CA93D0(ctx, base);
	// 82AB0D40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB0D44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB0D48: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AB0D4C: 48001FFD  bl 0x82ab2d48
	ctx.lr = 0x82AB0D50;
	sub_82AB2D48(ctx, base);
	// 82AB0D50: E95B0080  ld r10, 0x80(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(128 as u32) ) };
	// 82AB0D54: 389B00B0  addi r4, r27, 0xb0
	ctx.r[4].s64 = ctx.r[27].s64 + 176;
	// 82AB0D58: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 82AB0D5C: 397B0080  addi r11, r27, 0x80
	ctx.r[11].s64 = ctx.r[27].s64 + 128;
	// 82AB0D60: F95F0080  std r10, 0x80(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[10].u64 ) };
	// 82AB0D64: E93B0088  ld r9, 0x88(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(136 as u32) ) };
	// 82AB0D68: F93F0088  std r9, 0x88(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[9].u64 ) };
	// 82AB0D6C: E91B0090  ld r8, 0x90(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) };
	// 82AB0D70: F91F0090  std r8, 0x90(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[8].u64 ) };
	// 82AB0D74: E8FB0098  ld r7, 0x98(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(152 as u32) ) };
	// 82AB0D78: F8FF0098  std r7, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[7].u64 ) };
	// 82AB0D7C: E8DB00A0  ld r6, 0xa0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(160 as u32) ) };
	// 82AB0D80: F8DF00A0  std r6, 0xa0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[6].u64 ) };
	// 82AB0D84: E8BB00A8  ld r5, 0xa8(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(168 as u32) ) };
	// 82AB0D88: F8BF00A8  std r5, 0xa8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[5].u64 ) };
	// 82AB0D8C: 480003D5  bl 0x82ab1160
	ctx.lr = 0x82AB0D90;
	sub_82AB1160(ctx, base);
	// 82AB0D90: 389B0048  addi r4, r27, 0x48
	ctx.r[4].s64 = ctx.r[27].s64 + 72;
	// 82AB0D94: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 82AB0D98: 48002AF1  bl 0x82ab3888
	ctx.lr = 0x82AB0D9C;
	sub_82AB3888(ctx, base);
	// 82AB0D9C: 817B0074  lwz r11, 0x74(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AB0DA0: 3C803FFF  lis r4, 0x3fff
	ctx.r[4].s64 = 1073676288;
	// 82AB0DA4: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 82AB0DA8: 6083FFFF  ori r3, r4, 0xffff
	ctx.r[3].u64 = ctx.r[4].u64 | 65535;
	// 82AB0DAC: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AB0DB0: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AB0DB4: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82AB0DB8: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82AB0DBC: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB0DC0: 40990008  ble cr6, 0x82ab0dc8
	if !ctx.cr[6].gt {
	pc = 0x82AB0DC8; continue 'dispatch;
	}
	// 82AB0DC4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82AB0DC8; continue 'dispatch;
            }
            0x82AB0DC8 => {
    //   block [0x82AB0DC8..0x82AB0DE8)
	// 82AB0DC8: 4B76E491  bl 0x8221f258
	ctx.lr = 0x82AB0DCC;
	sub_8221F258(ctx, base);
	// 82AB0DCC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AB0DD0: 907F0058  stw r3, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82AB0DD4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AB0DD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB0DDC: 40990050  ble cr6, 0x82ab0e2c
	if !ctx.cr[6].gt {
	pc = 0x82AB0E2C; continue 'dispatch;
	}
	// 82AB0DE0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AB0DE4: 3F80834A  lis r28, -0x7cb6
	ctx.r[28].s64 = -2092302336;
	pc = 0x82AB0DE8; continue 'dispatch;
            }
            0x82AB0DE8 => {
    //   block [0x82AB0DE8..0x82AB0DFC)
	// 82AB0DE8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AB0DEC: 41980010  blt cr6, 0x82ab0dfc
	if ctx.cr[6].lt {
	pc = 0x82AB0DFC; continue 'dispatch;
	}
	// 82AB0DF0: 817B0058  lwz r11, 0x58(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB0DF4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82AB0DF8: 48000008  b 0x82ab0e00
	pc = 0x82AB0E00; continue 'dispatch;
            }
            0x82AB0DFC => {
    //   block [0x82AB0DFC..0x82AB0E00)
	// 82AB0DFC: 807C5760  lwz r3, 0x5760(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(22368 as u32) ) } as u64;
	pc = 0x82AB0E00; continue 'dispatch;
            }
            0x82AB0E00 => {
    //   block [0x82AB0E00..0x82AB0E2C)
	// 82AB0E00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0E04: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0E08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB0E0C: 4E800421  bctrl
	ctx.lr = 0x82AB0E10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB0E10: 813F0058  lwz r9, 0x58(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB0E14: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82AB0E18: 7C7E492E  stwx r3, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	// 82AB0E1C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AB0E20: 811F0028  lwz r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AB0E24: 7F1D4000  cmpw cr6, r29, r8
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82AB0E28: 4198FFC0  blt cr6, 0x82ab0de8
	if ctx.cr[6].lt {
	pc = 0x82AB0DE8; continue 'dispatch;
	}
            }
            0x82AB0E2C => {
    //   block [0x82AB0E2C..0x82AB0E58)
	// 82AB0E2C: 83DB002C  lwz r30, 0x2c(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB0E30: 3D600124  lis r11, 0x124
	ctx.r[11].s64 = 19136512;
	// 82AB0E34: 616A9249  ori r10, r11, 0x9249
	ctx.r[10].u64 = ctx.r[11].u64 | 37449;
	// 82AB0E38: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB0E3C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82AB0E40: 41990018  bgt cr6, 0x82ab0e58
	if ctx.cr[6].gt {
	pc = 0x82AB0E58; continue 'dispatch;
	}
	// 82AB0E44: 1D7E00E0  mulli r11, r30, 0xe0
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 224 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AB0E48: 3940FFEF  li r10, -0x11
	ctx.r[10].s64 = -17;
	// 82AB0E4C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82AB0E50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB0E54: 40990008  ble cr6, 0x82ab0e5c
	if !ctx.cr[6].gt {
	pc = 0x82AB0E5C; continue 'dispatch;
	}
	pc = 0x82AB0E58; continue 'dispatch;
            }
            0x82AB0E58 => {
    //   block [0x82AB0E58..0x82AB0E5C)
	// 82AB0E58: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82AB0E5C; continue 'dispatch;
            }
            0x82AB0E5C => {
    //   block [0x82AB0E5C..0x82AB0E88)
	// 82AB0E5C: 4B76E465  bl 0x8221f2c0
	ctx.lr = 0x82AB0E60;
	sub_8221F2C0(ctx, base);
	// 82AB0E60: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 82AB0E64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB0E68: 409A0214  bne cr6, 0x82ab107c
	if !ctx.cr[6].eq {
	pc = 0x82AB107C; continue 'dispatch;
	}
	// 82AB0E6C: 817A6F6C  lwz r11, 0x6f6c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AB0E70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB0E74: 419A0014  beq cr6, 0x82ab0e88
	if ctx.cr[6].eq {
	pc = 0x82AB0E88; continue 'dispatch;
	}
	// 82AB0E78: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB0E7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AB0E80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AB0E84: 4E800421  bctrl
	ctx.lr = 0x82AB0E88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB0E88 => {
    //   block [0x82AB0E88..0x82AB0E90)
	// 82AB0E88: 48211521  bl 0x82cc23a8
	ctx.lr = 0x82AB0E8C;
	sub_82CC23A8(ctx, base);
	// 82AB0E8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AB0E90; continue 'dispatch;
            }
            0x82AB0E90 => {
    //   block [0x82AB0E90..0x82AB0EA8)
	// 82AB0E90: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB0E94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AB0E98: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AB0E9C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB0EA0: 40990054  ble cr6, 0x82ab0ef4
	if !ctx.cr[6].gt {
	pc = 0x82AB0EF4; continue 'dispatch;
	}
	// 82AB0EA4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82AB0EA8; continue 'dispatch;
            }
            0x82AB0EA8 => {
    //   block [0x82AB0EA8..0x82AB0EF4)
	// 82AB0EA8: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB0EAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AB0EB0: 817B005C  lwz r11, 0x5c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB0EB4: 7F9D5214  add r28, r29, r10
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82AB0EB8: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AB0EBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB0EC0: 48079871  bl 0x82b2a730
	ctx.lr = 0x82AB0EC4;
	sub_82B2A730(ctx, base);
	// 82AB0EC4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0EC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AB0ECC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB0ED0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB0ED4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0ED8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB0EDC: 4E800421  bctrl
	ctx.lr = 0x82AB0EE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB0EE0: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB0EE4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82AB0EE8: 3BBD00E0  addi r29, r29, 0xe0
	ctx.r[29].s64 = ctx.r[29].s64 + 224;
	// 82AB0EEC: 7F1E4800  cmpw cr6, r30, r9
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AB0EF0: 4198FFB8  blt cr6, 0x82ab0ea8
	if ctx.cr[6].lt {
	pc = 0x82AB0EA8; continue 'dispatch;
	}
            }
            0x82AB0EF4 => {
    //   block [0x82AB0EF4..0x82AB0F20)
	// 82AB0EF4: 83DB0030  lwz r30, 0x30(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB0EF8: 3D6001A4  lis r11, 0x1a4
	ctx.r[11].s64 = 27525120;
	// 82AB0EFC: 616A1A41  ori r10, r11, 0x1a41
	ctx.r[10].u64 = ctx.r[11].u64 | 6721;
	// 82AB0F00: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB0F04: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82AB0F08: 41990018  bgt cr6, 0x82ab0f20
	if ctx.cr[6].gt {
	pc = 0x82AB0F20; continue 'dispatch;
	}
	// 82AB0F0C: 1D7E009C  mulli r11, r30, 0x9c
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 156 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AB0F10: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82AB0F14: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82AB0F18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB0F1C: 40990008  ble cr6, 0x82ab0f24
	if !ctx.cr[6].gt {
	pc = 0x82AB0F24; continue 'dispatch;
	}
	pc = 0x82AB0F20; continue 'dispatch;
            }
            0x82AB0F20 => {
    //   block [0x82AB0F20..0x82AB0F24)
	// 82AB0F20: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82AB0F24; continue 'dispatch;
            }
            0x82AB0F24 => {
    //   block [0x82AB0F24..0x82AB0F4C)
	// 82AB0F24: 4B76E39D  bl 0x8221f2c0
	ctx.lr = 0x82AB0F28;
	sub_8221F2C0(ctx, base);
	// 82AB0F28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB0F2C: 409A017C  bne cr6, 0x82ab10a8
	if !ctx.cr[6].eq {
	pc = 0x82AB10A8; continue 'dispatch;
	}
	// 82AB0F30: 817A6F6C  lwz r11, 0x6f6c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AB0F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB0F38: 419A0014  beq cr6, 0x82ab0f4c
	if ctx.cr[6].eq {
	pc = 0x82AB0F4C; continue 'dispatch;
	}
	// 82AB0F3C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB0F40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AB0F44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AB0F48: 4E800421  bctrl
	ctx.lr = 0x82AB0F4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB0F4C => {
    //   block [0x82AB0F4C..0x82AB0F54)
	// 82AB0F4C: 4821145D  bl 0x82cc23a8
	ctx.lr = 0x82AB0F50;
	sub_82CC23A8(ctx, base);
	// 82AB0F50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AB0F54; continue 'dispatch;
            }
            0x82AB0F54 => {
    //   block [0x82AB0F54..0x82AB0F6C)
	// 82AB0F54: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB0F58: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AB0F5C: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AB0F60: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB0F64: 40990054  ble cr6, 0x82ab0fb8
	if !ctx.cr[6].gt {
	pc = 0x82AB0FB8; continue 'dispatch;
	}
	// 82AB0F68: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82AB0F6C; continue 'dispatch;
            }
            0x82AB0F6C => {
    //   block [0x82AB0F6C..0x82AB0FB8)
	// 82AB0F6C: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB0F70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AB0F74: 817B0060  lwz r11, 0x60(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB0F78: 7F9D5214  add r28, r29, r10
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82AB0F7C: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AB0F80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB0F84: 48074C8D  bl 0x82b25c10
	ctx.lr = 0x82AB0F88;
	sub_82B25C10(ctx, base);
	// 82AB0F88: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB0F8C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AB0F90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB0F94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB0F98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB0F9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB0FA0: 4E800421  bctrl
	ctx.lr = 0x82AB0FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB0FA4: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB0FA8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82AB0FAC: 3BBD009C  addi r29, r29, 0x9c
	ctx.r[29].s64 = ctx.r[29].s64 + 156;
	// 82AB0FB0: 7F1E4800  cmpw cr6, r30, r9
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AB0FB4: 4198FFB8  blt cr6, 0x82ab0f6c
	if ctx.cr[6].lt {
	pc = 0x82AB0F6C; continue 'dispatch;
	}
            }
            0x82AB0FB8 => {
    //   block [0x82AB0FB8..0x82AB0FF0)
	// 82AB0FB8: 817B006C  lwz r11, 0x6c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AB0FBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB0FC0: 419A0170  beq cr6, 0x82ab1130
	if ctx.cr[6].eq {
	pc = 0x82AB1130; continue 'dispatch;
	}
	// 82AB0FC4: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 82AB0FC8: 4B76E2F9  bl 0x8221f2c0
	ctx.lr = 0x82AB0FCC;
	sub_8221F2C0(ctx, base);
	// 82AB0FCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB0FD0: 409A0104  bne cr6, 0x82ab10d4
	if !ctx.cr[6].eq {
	pc = 0x82AB10D4; continue 'dispatch;
	}
	// 82AB0FD4: 817A6F6C  lwz r11, 0x6f6c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AB0FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB0FDC: 419A0014  beq cr6, 0x82ab0ff0
	if ctx.cr[6].eq {
	pc = 0x82AB0FF0; continue 'dispatch;
	}
	// 82AB0FE0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB0FE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AB0FE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AB0FEC: 4E800421  bctrl
	ctx.lr = 0x82AB0FF0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB0FF0 => {
    //   block [0x82AB0FF0..0x82AB0FF8)
	// 82AB0FF0: 482113B9  bl 0x82cc23a8
	ctx.lr = 0x82AB0FF4;
	sub_82CC23A8(ctx, base);
	// 82AB0FF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82AB0FF8; continue 'dispatch;
            }
            0x82AB0FF8 => {
    //   block [0x82AB0FF8..0x82AB1008)
	// 82AB0FF8: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AB0FFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB1000: 419A0044  beq cr6, 0x82ab1044
	if ctx.cr[6].eq {
	pc = 0x82AB1044; continue 'dispatch;
	}
	// 82AB1004: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB1008; continue 'dispatch;
            }
            0x82AB1008 => {
    //   block [0x82AB1008..0x82AB103C)
	// 82AB1008: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB100C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB1010: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB1014: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB1018: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB101C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB1020: 4082FFE8  bne 0x82ab1008
	if !ctx.cr[0].eq {
	pc = 0x82AB1008; continue 'dispatch;
	}
	// 82AB1024: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB1028: 409A0014  bne cr6, 0x82ab103c
	if !ctx.cr[6].eq {
	pc = 0x82AB103C; continue 'dispatch;
	}
	// 82AB102C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB1030: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB1034: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB1038: 4E800421  bctrl
	ctx.lr = 0x82AB103C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB103C => {
    //   block [0x82AB103C..0x82AB1044)
	// 82AB103C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB1040: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB1044; continue 'dispatch;
            }
            0x82AB1044 => {
    //   block [0x82AB1044..0x82AB107C)
	// 82AB1044: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82AB1048: 57CB003E  slwi r11, r30, 0
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB104C: 3D400555  lis r10, 0x555
	ctx.r[10].s64 = 89456640;
	// 82AB1050: 61495555  ori r9, r10, 0x5555
	ctx.r[9].u64 = ctx.r[10].u64 | 21845;
	// 82AB1054: 80EB002C  lwz r7, 0x2c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB1058: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB105C: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82AB1060: 7CDE1E70  srawi r30, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 82AB1064: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB1068: 4199007C  bgt cr6, 0x82ab10e4
	if ctx.cr[6].gt {
	pc = 0x82AB10E4; continue 'dispatch;
	}
	// 82AB106C: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB1070: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82AB1074: 55632036  slwi r3, r11, 4
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB1078: 48000070  b 0x82ab10e8
	pc = 0x82AB10E8; continue 'dispatch;
            }
            0x82AB107C => {
    //   block [0x82AB107C..0x82AB1090)
	// 82AB107C: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 82AB1080: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AB1084: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB1088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB108C: 41800014  blt 0x82ab10a0
	if ctx.cr[0].lt {
	pc = 0x82AB10A0; continue 'dispatch;
	}
	pc = 0x82AB1090; continue 'dispatch;
            }
            0x82AB1090 => {
    //   block [0x82AB1090..0x82AB10A0)
	// 82AB1090: 48079389  bl 0x82b2a418
	ctx.lr = 0x82AB1094;
	sub_82B2A418(ctx, base);
	// 82AB1094: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB1098: 386300E0  addi r3, r3, 0xe0
	ctx.r[3].s64 = ctx.r[3].s64 + 224;
	// 82AB109C: 4080FFF4  bge 0x82ab1090
	if !ctx.cr[0].lt {
	pc = 0x82AB1090; continue 'dispatch;
	}
	pc = 0x82AB10A0; continue 'dispatch;
            }
            0x82AB10A0 => {
    //   block [0x82AB10A0..0x82AB10A8)
	// 82AB10A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82AB10A4: 4BFFFDEC  b 0x82ab0e90
	pc = 0x82AB0E90; continue 'dispatch;
            }
            0x82AB10A8 => {
    //   block [0x82AB10A8..0x82AB10BC)
	// 82AB10A8: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 82AB10AC: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AB10B0: 349EFFFF  addic. r4, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AB10B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB10B8: 41800014  blt 0x82ab10cc
	if ctx.cr[0].lt {
	pc = 0x82AB10CC; continue 'dispatch;
	}
	pc = 0x82AB10BC; continue 'dispatch;
            }
            0x82AB10BC => {
    //   block [0x82AB10BC..0x82AB10CC)
	// 82AB10BC: 480749E5  bl 0x82b25aa0
	ctx.lr = 0x82AB10C0;
	sub_82B25AA0(ctx, base);
	// 82AB10C0: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AB10C4: 3863009C  addi r3, r3, 0x9c
	ctx.r[3].s64 = ctx.r[3].s64 + 156;
	// 82AB10C8: 4080FFF4  bge 0x82ab10bc
	if !ctx.cr[0].lt {
	pc = 0x82AB10BC; continue 'dispatch;
	}
	pc = 0x82AB10CC; continue 'dispatch;
            }
            0x82AB10CC => {
    //   block [0x82AB10CC..0x82AB10D4)
	// 82AB10CC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82AB10D0: 4BFFFE84  b 0x82ab0f54
	pc = 0x82AB0F54; continue 'dispatch;
            }
            0x82AB10D4 => {
    //   block [0x82AB10D4..0x82AB10E4)
	// 82AB10D4: 809B006C  lwz r4, 0x6c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AB10D8: 4BE0A829  bl 0x828bb900
	ctx.lr = 0x82AB10DC;
	sub_828BB900(ctx, base);
	// 82AB10DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB10E0: 4BFFFF18  b 0x82ab0ff8
	pc = 0x82AB0FF8; continue 'dispatch;
            }
            0x82AB10E4 => {
    //   block [0x82AB10E4..0x82AB10E8)
	// 82AB10E4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82AB10E8; continue 'dispatch;
            }
            0x82AB10E8 => {
    //   block [0x82AB10E8..0x82AB1110)
	// 82AB10E8: 4B76E1D9  bl 0x8221f2c0
	ctx.lr = 0x82AB10EC;
	sub_8221F2C0(ctx, base);
	// 82AB10EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB10F0: 409A0028  bne cr6, 0x82ab1118
	if !ctx.cr[6].eq {
	pc = 0x82AB1118; continue 'dispatch;
	}
	// 82AB10F4: 817A6F6C  lwz r11, 0x6f6c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AB10F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB10FC: 419A0014  beq cr6, 0x82ab1110
	if ctx.cr[6].eq {
	pc = 0x82AB1110; continue 'dispatch;
	}
	// 82AB1100: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB1104: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AB1108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AB110C: 4E800421  bctrl
	ctx.lr = 0x82AB1110;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB1110 => {
    //   block [0x82AB1110..0x82AB1118)
	// 82AB1110: 48211299  bl 0x82cc23a8
	ctx.lr = 0x82AB1114;
	sub_82CC23A8(ctx, base);
	// 82AB1114: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82AB1118; continue 'dispatch;
            }
            0x82AB1118 => {
    //   block [0x82AB1118..0x82AB1130)
	// 82AB1118: 907F0070  stw r3, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 82AB111C: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB1120: 809B0070  lwz r4, 0x70(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AB1124: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82AB1128: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82AB112C: 4B75736D  bl 0x82208498
	ctx.lr = 0x82AB1130;
	sub_82208498(ctx, base);
	pc = 0x82AB1130; continue 'dispatch;
            }
            0x82AB1130 => {
    //   block [0x82AB1130..0x82AB1160)
	// 82AB1130: 817B003C  lwz r11, 0x3c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB1134: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82AB1138: 895B0044  lbz r10, 0x44(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 82AB113C: 995F0044  stb r10, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82AB1140: 893B0045  lbz r9, 0x45(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(69 as u32) ) } as u64;
	// 82AB1144: 993F0045  stb r9, 0x45(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(69 as u32), ctx.r[9].u8 ) };
	// 82AB1148: 891B0047  lbz r8, 0x47(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(71 as u32) ) } as u64;
	// 82AB114C: 991F0047  stb r8, 0x47(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(71 as u32), ctx.r[8].u8 ) };
	// 82AB1150: 88FB0046  lbz r7, 0x46(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(70 as u32) ) } as u64;
	// 82AB1154: 98FF0046  stb r7, 0x46(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(70 as u32), ctx.r[7].u8 ) };
	// 82AB1158: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB115C: 481F82F0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB1160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB1160 size=100
    let mut pc: u32 = 0x82AB1160;
    'dispatch: loop {
        match pc {
            0x82AB1160 => {
    //   block [0x82AB1160..0x82AB11C4)
	// 82AB1160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB1164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB1168: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB116C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB1170: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82AB1174: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB1178: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 82AB117C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82AB1180: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB1184: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB1188: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB118C: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AB1190: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB1194: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82AB1198: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB119C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB11A0: 80CB0010  lwz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB11A4: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82AB11A8: 4B998C99  bl 0x82449e40
	ctx.lr = 0x82AB11AC;
	sub_82449E40(ctx, base);
	// 82AB11AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB11B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AB11B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB11B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB11BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB11C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB11C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB11C8 size=148
    let mut pc: u32 = 0x82AB11C8;
    'dispatch: loop {
        match pc {
            0x82AB11C8 => {
    //   block [0x82AB11C8..0x82AB1200)
	// 82AB11C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB11CC: 481F823D  bl 0x82ca9408
	ctx.lr = 0x82AB11D0;
	sub_82CA93D0(ctx, base);
	// 82AB11D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB11D4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AB11D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB11DC: 578B07BC  rlwinm r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB11E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB11E4: 419A0050  beq cr6, 0x82ab1234
	if ctx.cr[6].eq {
	pc = 0x82AB1234; continue 'dispatch;
	}
	// 82AB11E8: 815EFFF0  lwz r10, -0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82AB11EC: 3BBEFFF0  addi r29, r30, -0x10
	ctx.r[29].s64 = ctx.r[30].s64 + -16;
	// 82AB11F0: 1D6A00E0  mulli r11, r10, 0xe0
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 224 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AB11F4: 37EAFFFF  addic. r31, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AB11F8: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AB11FC: 41800018  blt 0x82ab1214
	if ctx.cr[0].lt {
	pc = 0x82AB1214; continue 'dispatch;
	}
	pc = 0x82AB1200; continue 'dispatch;
            }
            0x82AB1200 => {
    //   block [0x82AB1200..0x82AB1214)
	// 82AB1200: 3BDEFF20  addi r30, r30, -0xe0
	ctx.r[30].s64 = ctx.r[30].s64 + -224;
	// 82AB1204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB1208: 48079459  bl 0x82b2a660
	ctx.lr = 0x82AB120C;
	sub_82B2A660(ctx, base);
	// 82AB120C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AB1210: 4080FFF0  bge 0x82ab1200
	if !ctx.cr[0].lt {
	pc = 0x82AB1200; continue 'dispatch;
	}
	pc = 0x82AB1214; continue 'dispatch;
            }
            0x82AB1214 => {
    //   block [0x82AB1214..0x82AB1228)
	// 82AB1214: 578B07FE  clrlwi r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82AB1218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB121C: 419A000C  beq cr6, 0x82ab1228
	if ctx.cr[6].eq {
	pc = 0x82AB1228; continue 'dispatch;
	}
	// 82AB1220: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB1224: 4B76AB15  bl 0x8221bd38
	ctx.lr = 0x82AB1228;
	sub_8221BD38(ctx, base);
	pc = 0x82AB1228; continue 'dispatch;
            }
            0x82AB1228 => {
    //   block [0x82AB1228..0x82AB1234)
	// 82AB1228: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB122C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB1230: 481F8228  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB1234 => {
    //   block [0x82AB1234..0x82AB1250)
	// 82AB1234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB1238: 48079429  bl 0x82b2a660
	ctx.lr = 0x82AB123C;
	sub_82B2A660(ctx, base);
	// 82AB123C: 578B07FE  clrlwi r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82AB1240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB1244: 419A000C  beq cr6, 0x82ab1250
	if ctx.cr[6].eq {
	pc = 0x82AB1250; continue 'dispatch;
	}
	// 82AB1248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB124C: 4B76AAED  bl 0x8221bd38
	ctx.lr = 0x82AB1250;
	sub_8221BD38(ctx, base);
	pc = 0x82AB1250; continue 'dispatch;
            }
            0x82AB1250 => {
    //   block [0x82AB1250..0x82AB125C)
	// 82AB1250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB1254: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB1258: 481F8200  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB1260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB1260 size=148
    let mut pc: u32 = 0x82AB1260;
    'dispatch: loop {
        match pc {
            0x82AB1260 => {
    //   block [0x82AB1260..0x82AB1298)
	// 82AB1260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB1264: 481F81A5  bl 0x82ca9408
	ctx.lr = 0x82AB1268;
	sub_82CA93D0(ctx, base);
	// 82AB1268: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB126C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AB1270: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB1274: 578B07BC  rlwinm r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB1278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB127C: 419A0050  beq cr6, 0x82ab12cc
	if ctx.cr[6].eq {
	pc = 0x82AB12CC; continue 'dispatch;
	}
	// 82AB1280: 815EFFFC  lwz r10, -4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AB1284: 3BBEFFFC  addi r29, r30, -4
	ctx.r[29].s64 = ctx.r[30].s64 + -4;
	// 82AB1288: 1D6A009C  mulli r11, r10, 0x9c
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 156 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AB128C: 37EAFFFF  addic. r31, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AB1290: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AB1294: 41800018  blt 0x82ab12ac
	if ctx.cr[0].lt {
	pc = 0x82AB12AC; continue 'dispatch;
	}
	pc = 0x82AB1298; continue 'dispatch;
            }
            0x82AB1298 => {
    //   block [0x82AB1298..0x82AB12AC)
	// 82AB1298: 3BDEFF64  addi r30, r30, -0x9c
	ctx.r[30].s64 = ctx.r[30].s64 + -156;
	// 82AB129C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB12A0: 480748B1  bl 0x82b25b50
	ctx.lr = 0x82AB12A4;
	sub_82B25B50(ctx, base);
	// 82AB12A4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AB12A8: 4080FFF0  bge 0x82ab1298
	if !ctx.cr[0].lt {
	pc = 0x82AB1298; continue 'dispatch;
	}
	pc = 0x82AB12AC; continue 'dispatch;
            }
            0x82AB12AC => {
    //   block [0x82AB12AC..0x82AB12C0)
	// 82AB12AC: 578B07FE  clrlwi r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82AB12B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB12B4: 419A000C  beq cr6, 0x82ab12c0
	if ctx.cr[6].eq {
	pc = 0x82AB12C0; continue 'dispatch;
	}
	// 82AB12B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB12BC: 4B76AA7D  bl 0x8221bd38
	ctx.lr = 0x82AB12C0;
	sub_8221BD38(ctx, base);
	pc = 0x82AB12C0; continue 'dispatch;
            }
            0x82AB12C0 => {
    //   block [0x82AB12C0..0x82AB12CC)
	// 82AB12C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB12C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB12C8: 481F8190  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB12CC => {
    //   block [0x82AB12CC..0x82AB12E8)
	// 82AB12CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB12D0: 48074881  bl 0x82b25b50
	ctx.lr = 0x82AB12D4;
	sub_82B25B50(ctx, base);
	// 82AB12D4: 578B07FE  clrlwi r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82AB12D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB12DC: 419A000C  beq cr6, 0x82ab12e8
	if ctx.cr[6].eq {
	pc = 0x82AB12E8; continue 'dispatch;
	}
	// 82AB12E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB12E4: 4B76AA55  bl 0x8221bd38
	ctx.lr = 0x82AB12E8;
	sub_8221BD38(ctx, base);
	pc = 0x82AB12E8; continue 'dispatch;
            }
            0x82AB12E8 => {
    //   block [0x82AB12E8..0x82AB12F4)
	// 82AB12E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB12EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB12F0: 481F8168  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB12F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AB12F8 size=1088
    let mut pc: u32 = 0x82AB12F8;
    'dispatch: loop {
        match pc {
            0x82AB12F8 => {
    //   block [0x82AB12F8..0x82AB1334)
	// 82AB12F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB12FC: 481F80F9  bl 0x82ca93f4
	ctx.lr = 0x82AB1300;
	sub_82CA93D0(ctx, base);
	// 82AB1300: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82AB1304: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB1308: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AB130C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82AB1310: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AB1314: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82AB1318: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 82AB131C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB1320: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB1324: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB1328: 7D1B1E71  srawi. r27, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82AB132C: 40810038  ble 0x82ab1364
	if !ctx.cr[0].gt {
	pc = 0x82AB1364; continue 'dispatch;
	}
	// 82AB1330: 8119002C  lwz r8, 0x2c(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	pc = 0x82AB1334; continue 'dispatch;
            }
            0x82AB1334 => {
    //   block [0x82AB1334..0x82AB1364)
	// 82AB1334: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB1338: 80EA002C  lwz r7, 0x2c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB133C: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82AB1340: 409A03EC  bne cr6, 0x82ab172c
	if !ctx.cr[6].eq {
	pc = 0x82AB172C; continue 'dispatch;
	}
	// 82AB1344: 80F90030  lwz r7, 0x30(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB1348: 80CA0030  lwz r6, 0x30(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB134C: 7F073000  cmpw cr6, r7, r6
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82AB1350: 409A03DC  bne cr6, 0x82ab172c
	if !ctx.cr[6].eq {
	pc = 0x82AB172C; continue 'dispatch;
	}
	// 82AB1354: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AB1358: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB135C: 7F09D800  cmpw cr6, r9, r27
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82AB1360: 4198FFD4  blt cr6, 0x82ab1334
	if ctx.cr[6].lt {
	pc = 0x82AB1334; continue 'dispatch;
	}
	pc = 0x82AB1364; continue 'dispatch;
            }
            0x82AB1364 => {
    //   block [0x82AB1364..0x82AB138C)
	// 82AB1364: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AB1368: 8159002C  lwz r10, 0x2c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB136C: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82AB1370: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB1374: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AB1378: 409901B0  ble cr6, 0x82ab1528
	if !ctx.cr[6].gt {
	pc = 0x82AB1528; continue 'dispatch;
	}
	// 82AB137C: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82AB1380: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82AB1384: EB410050  ld r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB1388: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x82AB138C; continue 'dispatch;
            }
            0x82AB138C => {
    //   block [0x82AB138C..0x82AB13B8)
	// 82AB138C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AB1390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB1394: 4800304D  bl 0x82ab43e0
	ctx.lr = 0x82AB1398;
	sub_82AB43E0(ctx, base);
	// 82AB1398: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB139C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB13A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB13A4: 419A0038  beq cr6, 0x82ab13dc
	if ctx.cr[6].eq {
	pc = 0x82AB13DC; continue 'dispatch;
	}
	// 82AB13A8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82AB13AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82AB13B0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AB13B4: 419A001C  beq cr6, 0x82ab13d0
	if ctx.cr[6].eq {
	pc = 0x82AB13D0; continue 'dispatch;
	}
	pc = 0x82AB13B8; continue 'dispatch;
            }
            0x82AB13B8 => {
    //   block [0x82AB13B8..0x82AB13C4)
	// 82AB13B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB13BC: 419A0008  beq cr6, 0x82ab13c4
	if ctx.cr[6].eq {
	pc = 0x82AB13C4; continue 'dispatch;
	}
	// 82AB13C0: FB4B0000  std r26, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	pc = 0x82AB13C4; continue 'dispatch;
            }
            0x82AB13C4 => {
    //   block [0x82AB13C4..0x82AB13D0)
	// 82AB13C4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB13C8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB13CC: 4082FFEC  bne 0x82ab13b8
	if !ctx.cr[0].eq {
	pc = 0x82AB13B8; continue 'dispatch;
	}
	pc = 0x82AB13D0; continue 'dispatch;
            }
            0x82AB13D0 => {
    //   block [0x82AB13D0..0x82AB13DC)
	// 82AB13D0: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB13D4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AB13D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB13DC; continue 'dispatch;
            }
            0x82AB13DC => {
    //   block [0x82AB13DC..0x82AB140C)
	// 82AB13DC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AB13E0: 2F1B0004  cmpwi cr6, r27, 4
	ctx.cr[6].compare_i32(ctx.r[27].s32, 4, &mut ctx.xer);
	// 82AB13E4: 419800C0  blt cr6, 0x82ab14a4
	if ctx.cr[6].lt {
	pc = 0x82AB14A4; continue 'dispatch;
	}
	// 82AB13E8: 397BFFFC  addi r11, r27, -4
	ctx.r[11].s64 = ctx.r[27].s64 + -4;
	// 82AB13EC: 7D5D00D0  neg r10, r29
	ctx.r[10].s64 = -ctx.r[29].s64;
	// 82AB13F0: 5569F0BE  srwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB13F4: 397D0008  addi r11, r29, 8
	ctx.r[11].s64 = ctx.r[29].s64 + 8;
	// 82AB13F8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AB13FC: 38EA0008  addi r7, r10, 8
	ctx.r[7].s64 = ctx.r[10].s64 + 8;
	// 82AB1400: 38CA0010  addi r6, r10, 0x10
	ctx.r[6].s64 = ctx.r[10].s64 + 16;
	// 82AB1404: 38AAFFF8  addi r5, r10, -8
	ctx.r[5].s64 = ctx.r[10].s64 + -8;
	// 82AB1408: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	pc = 0x82AB140C; continue 'dispatch;
            }
            0x82AB140C => {
    //   block [0x82AB140C..0x82AB14A4)
	// 82AB140C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB1410: 7D455A14  add r10, r5, r11
	ctx.r[10].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82AB1414: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB1418: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AB141C: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB1420: C0080004  lfs f0, 4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB1424: 8103005C  lwz r8, 0x5c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB1428: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82AB142C: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 82AB1430: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82AB1434: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB1438: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AB143C: 80680008  lwz r3, 8(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB1440: C1A8000C  lfs f13, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AB1444: 8103005C  lwz r8, 0x5c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB1448: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82AB144C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AB1450: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AB1454: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB1458: 7C683A14  add r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82AB145C: 7C63582E  lwzx r3, r3, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AB1460: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AB1464: C1880014  lfs f12, 0x14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AB1468: 8103005C  lwz r8, 0x5c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB146C: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82AB1470: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82AB1474: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AB1478: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB147C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AB1480: C16A001C  lfs f11, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AB1484: 7C683214  add r3, r8, r6
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82AB1488: 7D03582E  lwzx r8, r3, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AB148C: 8148005C  lwz r10, 0x5c(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB1490: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82AB1494: 906B0010  stw r3, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82AB1498: D16B0014  stfs f11, 0x14(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82AB149C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82AB14A0: 4082FF6C  bne 0x82ab140c
	if !ctx.cr[0].eq {
	pc = 0x82AB140C; continue 'dispatch;
	}
	pc = 0x82AB14A4; continue 'dispatch;
            }
            0x82AB14A4 => {
    //   block [0x82AB14A4..0x82AB14B4)
	// 82AB14A4: 7F04D800  cmpw cr6, r4, r27
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82AB14A8: 4098003C  bge cr6, 0x82ab14e4
	if !ctx.cr[6].lt {
	pc = 0x82AB14E4; continue 'dispatch;
	}
	// 82AB14AC: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB14B0: 7D44D850  subf r10, r4, r27
	ctx.r[10].s64 = ctx.r[27].s64 - ctx.r[4].s64;
	pc = 0x82AB14B4; continue 'dispatch;
            }
            0x82AB14B4 => {
    //   block [0x82AB14B4..0x82AB14E4)
	// 82AB14B4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB14B8: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AB14BC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB14C0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AB14C4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB14C8: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB14CC: 8127005C  lwz r9, 0x5c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB14D0: 7CC9F214  add r6, r9, r30
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82AB14D4: 7CCBE92E  stwx r6, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[6].u32) };
	// 82AB14D8: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AB14DC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB14E0: 4082FFD4  bne 0x82ab14b4
	if !ctx.cr[0].eq {
	pc = 0x82AB14B4; continue 'dispatch;
	}
	pc = 0x82AB14E4; continue 'dispatch;
            }
            0x82AB14E4 => {
    //   block [0x82AB14E4..0x82AB1508)
	// 82AB14E4: 8179005C  lwz r11, 0x5c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB14E8: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82AB14EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AB14F0: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AB14F4: 4807939D  bl 0x82b2a890
	ctx.lr = 0x82AB14F8;
	sub_82B2A890(ctx, base);
	// 82AB14F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AB14FC: 419A000C  beq cr6, 0x82ab1508
	if ctx.cr[6].eq {
	pc = 0x82AB1508; continue 'dispatch;
	}
	// 82AB1500: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB1504: 4B76A835  bl 0x8221bd38
	ctx.lr = 0x82AB1508;
	sub_8221BD38(ctx, base);
	pc = 0x82AB1508; continue 'dispatch;
            }
            0x82AB1508 => {
    //   block [0x82AB1508..0x82AB1528)
	// 82AB1508: 8179002C  lwz r11, 0x2c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB150C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82AB1510: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 82AB1514: 3BDE00E0  addi r30, r30, 0xe0
	ctx.r[30].s64 = ctx.r[30].s64 + 224;
	// 82AB1518: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 82AB151C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB1520: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 82AB1524: 4198FE68  blt cr6, 0x82ab138c
	if ctx.cr[6].lt {
	pc = 0x82AB138C; continue 'dispatch;
	}
	pc = 0x82AB1528; continue 'dispatch;
            }
            0x82AB1528 => {
    //   block [0x82AB1528..0x82AB1548)
	// 82AB1528: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB152C: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82AB1530: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB1534: 409901B0  ble cr6, 0x82ab16e4
	if !ctx.cr[6].gt {
	pc = 0x82AB16E4; continue 'dispatch;
	}
	// 82AB1538: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82AB153C: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82AB1540: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82AB1544: EB410050  ld r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	pc = 0x82AB1548; continue 'dispatch;
            }
            0x82AB1548 => {
    //   block [0x82AB1548..0x82AB1574)
	// 82AB1548: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AB154C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB1550: 48002E91  bl 0x82ab43e0
	ctx.lr = 0x82AB1554;
	sub_82AB43E0(ctx, base);
	// 82AB1554: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB1558: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB155C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB1560: 419A0038  beq cr6, 0x82ab1598
	if ctx.cr[6].eq {
	pc = 0x82AB1598; continue 'dispatch;
	}
	// 82AB1564: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82AB1568: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82AB156C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AB1570: 419A001C  beq cr6, 0x82ab158c
	if ctx.cr[6].eq {
	pc = 0x82AB158C; continue 'dispatch;
	}
	pc = 0x82AB1574; continue 'dispatch;
            }
            0x82AB1574 => {
    //   block [0x82AB1574..0x82AB1580)
	// 82AB1574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB1578: 419A0008  beq cr6, 0x82ab1580
	if ctx.cr[6].eq {
	pc = 0x82AB1580; continue 'dispatch;
	}
	// 82AB157C: FB4B0000  std r26, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	pc = 0x82AB1580; continue 'dispatch;
            }
            0x82AB1580 => {
    //   block [0x82AB1580..0x82AB158C)
	// 82AB1580: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB1584: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB1588: 4082FFEC  bne 0x82ab1574
	if !ctx.cr[0].eq {
	pc = 0x82AB1574; continue 'dispatch;
	}
	pc = 0x82AB158C; continue 'dispatch;
            }
            0x82AB158C => {
    //   block [0x82AB158C..0x82AB1598)
	// 82AB158C: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB1590: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AB1594: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB1598; continue 'dispatch;
            }
            0x82AB1598 => {
    //   block [0x82AB1598..0x82AB15C8)
	// 82AB1598: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AB159C: 2F1B0004  cmpwi cr6, r27, 4
	ctx.cr[6].compare_i32(ctx.r[27].s32, 4, &mut ctx.xer);
	// 82AB15A0: 419800C0  blt cr6, 0x82ab1660
	if ctx.cr[6].lt {
	pc = 0x82AB1660; continue 'dispatch;
	}
	// 82AB15A4: 397BFFFC  addi r11, r27, -4
	ctx.r[11].s64 = ctx.r[27].s64 + -4;
	// 82AB15A8: 7D5D00D0  neg r10, r29
	ctx.r[10].s64 = -ctx.r[29].s64;
	// 82AB15AC: 5569F0BE  srwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB15B0: 397D0008  addi r11, r29, 8
	ctx.r[11].s64 = ctx.r[29].s64 + 8;
	// 82AB15B4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AB15B8: 38EA0008  addi r7, r10, 8
	ctx.r[7].s64 = ctx.r[10].s64 + 8;
	// 82AB15BC: 38CA0010  addi r6, r10, 0x10
	ctx.r[6].s64 = ctx.r[10].s64 + 16;
	// 82AB15C0: 38AAFFF8  addi r5, r10, -8
	ctx.r[5].s64 = ctx.r[10].s64 + -8;
	// 82AB15C4: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	pc = 0x82AB15C8; continue 'dispatch;
            }
            0x82AB15C8 => {
    //   block [0x82AB15C8..0x82AB1660)
	// 82AB15C8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB15CC: 7D4B2A14  add r10, r11, r5
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82AB15D0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB15D4: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AB15D8: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB15DC: C0080004  lfs f0, 4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB15E0: 81030060  lwz r8, 0x60(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB15E4: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82AB15E8: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 82AB15EC: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82AB15F0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB15F4: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AB15F8: 80680008  lwz r3, 8(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB15FC: C1A8000C  lfs f13, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AB1600: 81030060  lwz r8, 0x60(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB1604: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82AB1608: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AB160C: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AB1610: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB1614: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82AB1618: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AB161C: 7C63382E  lwzx r3, r3, r7
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82AB1620: C1880014  lfs f12, 0x14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AB1624: 81030060  lwz r8, 0x60(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB1628: 7C68F214  add r3, r8, r30
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82AB162C: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AB1630: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AB1634: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB1638: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82AB163C: C16A001C  lfs f11, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AB1640: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82AB1644: 7D03302E  lwzx r8, r3, r6
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82AB1648: 81480060  lwz r10, 0x60(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB164C: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82AB1650: 906B0010  stw r3, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82AB1654: D16B0014  stfs f11, 0x14(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82AB1658: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82AB165C: 4082FF6C  bne 0x82ab15c8
	if !ctx.cr[0].eq {
	pc = 0x82AB15C8; continue 'dispatch;
	}
	pc = 0x82AB1660; continue 'dispatch;
            }
            0x82AB1660 => {
    //   block [0x82AB1660..0x82AB1670)
	// 82AB1660: 7F04D800  cmpw cr6, r4, r27
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82AB1664: 4098003C  bge cr6, 0x82ab16a0
	if !ctx.cr[6].lt {
	pc = 0x82AB16A0; continue 'dispatch;
	}
	// 82AB1668: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB166C: 7D44D850  subf r10, r4, r27
	ctx.r[10].s64 = ctx.r[27].s64 - ctx.r[4].s64;
	pc = 0x82AB1670; continue 'dispatch;
            }
            0x82AB1670 => {
    //   block [0x82AB1670..0x82AB16A0)
	// 82AB1670: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB1674: 7D1D5A14  add r8, r29, r11
	ctx.r[8].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AB1678: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB167C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AB1680: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB1684: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB1688: 81270060  lwz r9, 0x60(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB168C: 7CC9F214  add r6, r9, r30
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82AB1690: 7CDD592E  stwx r6, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 82AB1694: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AB1698: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB169C: 4082FFD4  bne 0x82ab1670
	if !ctx.cr[0].eq {
	pc = 0x82AB1670; continue 'dispatch;
	}
	pc = 0x82AB16A0; continue 'dispatch;
            }
            0x82AB16A0 => {
    //   block [0x82AB16A0..0x82AB16C4)
	// 82AB16A0: 81790060  lwz r11, 0x60(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB16A4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82AB16A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AB16AC: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AB16B0: 48074689  bl 0x82b25d38
	ctx.lr = 0x82AB16B4;
	sub_82B25D38(ctx, base);
	// 82AB16B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AB16B8: 419A000C  beq cr6, 0x82ab16c4
	if ctx.cr[6].eq {
	pc = 0x82AB16C4; continue 'dispatch;
	}
	// 82AB16BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB16C0: 4B76A679  bl 0x8221bd38
	ctx.lr = 0x82AB16C4;
	sub_8221BD38(ctx, base);
	pc = 0x82AB16C4; continue 'dispatch;
            }
            0x82AB16C4 => {
    //   block [0x82AB16C4..0x82AB16E4)
	// 82AB16C4: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB16C8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82AB16CC: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 82AB16D0: 3BDE009C  addi r30, r30, 0x9c
	ctx.r[30].s64 = ctx.r[30].s64 + 156;
	// 82AB16D4: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 82AB16D8: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB16DC: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 82AB16E0: 4198FE68  blt cr6, 0x82ab1548
	if ctx.cr[6].lt {
	pc = 0x82AB1548; continue 'dispatch;
	}
	pc = 0x82AB16E4; continue 'dispatch;
            }
            0x82AB16E4 => {
    //   block [0x82AB16E4..0x82AB172C)
	// 82AB16E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB16E8: 56E91838  slwi r9, r23, 3
	ctx.r[9].u32 = ctx.r[23].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB16EC: 397900B0  addi r11, r25, 0xb0
	ctx.r[11].s64 = ctx.r[25].s64 + 176;
	// 82AB16F0: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82AB16F4: 7D69502E  lwzx r11, r9, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AB16F8: 396B00B0  addi r11, r11, 0xb0
	ctx.r[11].s64 = ctx.r[11].s64 + 176;
	// 82AB16FC: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 82AB1700: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB1704: 911900B0  stw r8, 0xb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(176 as u32), ctx.r[8].u32 ) };
	// 82AB1708: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB170C: 90F900B4  stw r7, 0xb4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(180 as u32), ctx.r[7].u32 ) };
	// 82AB1710: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB1714: 90D900B8  stw r6, 0xb8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(184 as u32), ctx.r[6].u32 ) };
	// 82AB1718: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB171C: 90B900BC  stw r5, 0xbc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(188 as u32), ctx.r[5].u32 ) };
	// 82AB1720: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB1724: 917900C0  stw r11, 0xc0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82AB1728: 4B998719  bl 0x82449e40
	ctx.lr = 0x82AB172C;
	sub_82449E40(ctx, base);
	pc = 0x82AB172C; continue 'dispatch;
            }
            0x82AB172C => {
    //   block [0x82AB172C..0x82AB1738)
	// 82AB172C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AB1730: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82AB1734: 481F7D10  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB1738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB1738 size=300
    let mut pc: u32 = 0x82AB1738;
    'dispatch: loop {
        match pc {
            0x82AB1738 => {
    //   block [0x82AB1738..0x82AB1780)
	// 82AB1738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB173C: 481F7CC1  bl 0x82ca93fc
	ctx.lr = 0x82AB1740;
	sub_82CA93D0(ctx, base);
	// 82AB1740: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB1744: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82AB1748: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB174C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AB1750: 419A010C  beq cr6, 0x82ab185c
	if ctx.cr[6].eq {
	pc = 0x82AB185C; continue 'dispatch;
	}
	// 82AB1754: 897E0047  lbz r11, 0x47(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(71 as u32) ) } as u64;
	// 82AB1758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB175C: 409A0100  bne cr6, 0x82ab185c
	if !ctx.cr[6].eq {
	pc = 0x82AB185C; continue 'dispatch;
	}
	// 82AB1760: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB1764: 419A00F0  beq cr6, 0x82ab1854
	if ctx.cr[6].eq {
	pc = 0x82AB1854; continue 'dispatch;
	}
	// 82AB1768: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB176C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82AB1770: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 82AB1774: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB1778: 40990068  ble cr6, 0x82ab17e0
	if !ctx.cr[6].gt {
	pc = 0x82AB17E0; continue 'dispatch;
	}
	// 82AB177C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	pc = 0x82AB1780; continue 'dispatch;
            }
            0x82AB1780 => {
    //   block [0x82AB1780..0x82AB17C0)
	// 82AB1780: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB1784: 815A005C  lwz r10, 0x5c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB1788: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AB178C: 3BEB004C  addi r31, r11, 0x4c
	ctx.r[31].s64 = ctx.r[11].s64 + 76;
	// 82AB1790: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 82AB1794: 1D6B00E0  mulli r11, r11, 0xe0
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 224 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AB1798: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB179C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB17A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB17A4: 3B8B004C  addi r28, r11, 0x4c
	ctx.r[28].s64 = ctx.r[11].s64 + 76;
	// 82AB17A8: 419A0018  beq cr6, 0x82ab17c0
	if ctx.cr[6].eq {
	pc = 0x82AB17C0; continue 'dispatch;
	}
	// 82AB17AC: 5523003E  slwi r3, r9, 0
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB17B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB17B4: 419A000C  beq cr6, 0x82ab17c0
	if ctx.cr[6].eq {
	pc = 0x82AB17C0; continue 'dispatch;
	}
	// 82AB17B8: 480D5E11  bl 0x82b875c8
	ctx.lr = 0x82AB17BC;
	sub_82B875C8(ctx, base);
	// 82AB17BC: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	pc = 0x82AB17C0; continue 'dispatch;
            }
            0x82AB17C0 => {
    //   block [0x82AB17C0..0x82AB17E0)
	// 82AB17C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AB17C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB17C8: 480D9FC9  bl 0x82b8b790
	ctx.lr = 0x82AB17CC;
	sub_82B8B790(ctx, base);
	// 82AB17CC: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB17D0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AB17D4: 3BBD00E0  addi r29, r29, 0xe0
	ctx.r[29].s64 = ctx.r[29].s64 + 224;
	// 82AB17D8: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB17DC: 4198FFA4  blt cr6, 0x82ab1780
	if ctx.cr[6].lt {
	pc = 0x82AB1780; continue 'dispatch;
	}
	pc = 0x82AB17E0; continue 'dispatch;
            }
            0x82AB17E0 => {
    //   block [0x82AB17E0..0x82AB17F4)
	// 82AB17E0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB17E4: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 82AB17E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB17EC: 40990068  ble cr6, 0x82ab1854
	if !ctx.cr[6].gt {
	pc = 0x82AB1854; continue 'dispatch;
	}
	// 82AB17F0: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	pc = 0x82AB17F4; continue 'dispatch;
            }
            0x82AB17F4 => {
    //   block [0x82AB17F4..0x82AB1834)
	// 82AB17F4: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB17F8: 815A0060  lwz r10, 0x60(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB17FC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AB1800: 3BEB0048  addi r31, r11, 0x48
	ctx.r[31].s64 = ctx.r[11].s64 + 72;
	// 82AB1804: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AB1808: 1D6B009C  mulli r11, r11, 0x9c
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 156 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AB180C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB1810: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB1814: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB1818: 3B8B0048  addi r28, r11, 0x48
	ctx.r[28].s64 = ctx.r[11].s64 + 72;
	// 82AB181C: 419A0018  beq cr6, 0x82ab1834
	if ctx.cr[6].eq {
	pc = 0x82AB1834; continue 'dispatch;
	}
	// 82AB1820: 5523003E  slwi r3, r9, 0
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB1824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB1828: 419A000C  beq cr6, 0x82ab1834
	if ctx.cr[6].eq {
	pc = 0x82AB1834; continue 'dispatch;
	}
	// 82AB182C: 480D5D9D  bl 0x82b875c8
	ctx.lr = 0x82AB1830;
	sub_82B875C8(ctx, base);
	// 82AB1830: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	pc = 0x82AB1834; continue 'dispatch;
            }
            0x82AB1834 => {
    //   block [0x82AB1834..0x82AB1854)
	// 82AB1834: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AB1838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB183C: 480D9F55  bl 0x82b8b790
	ctx.lr = 0x82AB1840;
	sub_82B8B790(ctx, base);
	// 82AB1840: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB1844: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AB1848: 3BBD009C  addi r29, r29, 0x9c
	ctx.r[29].s64 = ctx.r[29].s64 + 156;
	// 82AB184C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB1850: 4198FFA4  blt cr6, 0x82ab17f4
	if ctx.cr[6].lt {
	pc = 0x82AB17F4; continue 'dispatch;
	}
	pc = 0x82AB1854; continue 'dispatch;
            }
            0x82AB1854 => {
    //   block [0x82AB1854..0x82AB185C)
	// 82AB1854: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AB1858: 997E0047  stb r11, 0x47(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(71 as u32), ctx.r[11].u8 ) };
	pc = 0x82AB185C; continue 'dispatch;
            }
            0x82AB185C => {
    //   block [0x82AB185C..0x82AB1864)
	// 82AB185C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB1860: 481F7BEC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB1868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AB1868 size=4552
    //   switch @ 0x82AB24A4: r11 with 4 label(s)
    //       case  0 → 0x82AB24B8
    //       case  1 → 0x82AB24E8
    //       case  2 → 0x82AB2530
    //       case  3 → 0x82AB24B8
    let mut pc: u32 = 0x82AB1868;
    'dispatch: loop {
        match pc {
            0x82AB1868 => {
    //   block [0x82AB1868..0x82AB18A4)
	// 82AB1868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB186C: 481F7B69  bl 0x82ca93d4
	ctx.lr = 0x82AB1870;
	sub_82CA93D0(ctx, base);
	// 82AB1870: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB1874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB1878: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB187C: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 82AB1880: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82AB1884: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 82AB1888: 480014C1  bl 0x82ab2d48
	ctx.lr = 0x82AB188C;
	sub_82AB2D48(ctx, base);
	// 82AB188C: 57B0063E  clrlwi r16, r29, 0x18
	ctx.r[16].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82AB1890: 9BBF0046  stb r29, 0x46(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(70 as u32), ctx.r[29].u8 ) };
	// 82AB1894: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 82AB1898: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82AB189C: 419A0008  beq cr6, 0x82ab18a4
	if ctx.cr[6].eq {
	pc = 0x82AB18A4; continue 'dispatch;
	}
	// 82AB18A0: 9ABF0047  stb r21, 0x47(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(71 as u32), ctx.r[21].u8 ) };
	pc = 0x82AB18A4; continue 'dispatch;
            }
            0x82AB18A4 => {
    //   block [0x82AB18A4..0x82AB1910)
	// 82AB18A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB18A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB18AC: 4800137D  bl 0x82ab2c28
	ctx.lr = 0x82AB18B0;
	sub_82AB2C28(ctx, base);
	// 82AB18B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB18B4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AB18B8: 4BF70059  bl 0x82a21910
	ctx.lr = 0x82AB18BC;
	sub_82A21910(ctx, base);
	// 82AB18BC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB18C0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB18C4: 4198004C  blt cr6, 0x82ab1910
	if ctx.cr[6].lt {
	pc = 0x82AB1910; continue 'dispatch;
	}
	// 82AB18C8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB18CC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB18D0: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 82AB18D4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB18D8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB18DC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB18E0: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB18E4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB18E8: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB18EC: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB18F0: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB18F4: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB18F8: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB18FC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB1900: 90FE000C  stw r7, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB1904: 913E0014  stw r9, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB1908: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB190C: 48000014  b 0x82ab1920
	pc = 0x82AB1920; continue 'dispatch;
            }
            0x82AB1910 => {
    //   block [0x82AB1910..0x82AB1920)
	// 82AB1910: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB1914: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82AB1918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB191C: 4BF6F5CD  bl 0x82a20ee8
	ctx.lr = 0x82AB1920;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB1920; continue 'dispatch;
            }
            0x82AB1920 => {
    //   block [0x82AB1920..0x82AB1954)
	// 82AB1920: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB1924: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB1928: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82AB192C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB1930: 419A0024  beq cr6, 0x82ab1954
	if ctx.cr[6].eq {
	pc = 0x82AB1954; continue 'dispatch;
	}
	// 82AB1934: 89610064  lbz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB1938: 89410065  lbz r10, 0x65(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(101 as u32) ) } as u64;
	// 82AB193C: 89210067  lbz r9, 0x67(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(103 as u32) ) } as u64;
	// 82AB1940: 89010066  lbz r8, 0x66(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(102 as u32) ) } as u64;
	// 82AB1944: 99610067  stb r11, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[11].u8 ) };
	// 82AB1948: 99410066  stb r10, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[10].u8 ) };
	// 82AB194C: 99210064  stb r9, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u8 ) };
	// 82AB1950: 99010065  stb r8, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB1954; continue 'dispatch;
            }
            0x82AB1954 => {
    //   block [0x82AB1954..0x82AB24B8)
	// 82AB1954: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AB1958: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82AB195C: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 82AB1960: 390B91A0  addi r8, r11, -0x6e60
	ctx.r[8].s64 = ctx.r[11].s64 + -28256;
	// 82AB1964: 38E000A0  li r7, 0xa0
	ctx.r[7].s64 = 160;
	// 82AB1968: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x82AB24B8; continue 'dispatch;
            }
            0x82AB24B8 => {
    //   block [0x82AB24B8..0x82AB24E8)
	// 82AB24B8: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 82AB24BC: 4B76CD9D  bl 0x8221f258
	ctx.lr = 0x82AB24C0;
	sub_8221F258(ctx, base);
	// 82AB24C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB24C4: 419A0014  beq cr6, 0x82ab24d8
	if ctx.cr[6].eq {
	pc = 0x82AB24D8; continue 'dispatch;
	}
	// 82AB24C8: 48071CD9  bl 0x82b241a0
	ctx.lr = 0x82AB24CC;
	sub_82B241A0(ctx, base);
	// 82AB24CC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB24D0: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82AB24D4: 48000084  b 0x82ab2558
	pc = 0x82AB2558; continue 'dispatch;
	// 82AB24D8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB24DC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82AB24E0: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82AB24E4: 48000074  b 0x82ab2558
	pc = 0x82AB2558; continue 'dispatch;
            }
            0x82AB24E8 => {
    //   block [0x82AB24E8..0x82AB2530)
	// 82AB24E8: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 82AB24EC: 4B76CD6D  bl 0x8221f258
	ctx.lr = 0x82AB24F0;
	sub_8221F258(ctx, base);
	// 82AB24F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB24F4: 419AFFE4  beq cr6, 0x82ab24d8
	if ctx.cr[6].eq {
	pc = 0x82AB24D8; continue 'dispatch;
	}
	// 82AB24F8: 48071CA9  bl 0x82b241a0
	ctx.lr = 0x82AB24FC;
	sub_82B241A0(ctx, base);
	// 82AB24FC: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB2500: 93230000  stw r25, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82AB2504: C1BB5D38  lfs f13, 0x5d38(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(23864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AB2508: 92A300B0  stw r21, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[21].u32 ) };
	// 82AB250C: D00300BC  stfs f0, 0xbc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82AB2510: 92A300B8  stw r21, 0xb8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), ctx.r[21].u32 ) };
	// 82AB2514: D1A300C0  stfs f13, 0xc0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82AB2518: 934300B4  stw r26, 0xb4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[26].u32 ) };
	// 82AB251C: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82AB2520: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82AB2524: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB2528: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82AB252C: 4800002C  b 0x82ab2558
	pc = 0x82AB2558; continue 'dispatch;
            }
            0x82AB2530 => {
    //   block [0x82AB2530..0x82AB2A30)
	// 82AB2530: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82AB2534: 4B76CD25  bl 0x8221f258
	ctx.lr = 0x82AB2538;
	sub_8221F258(ctx, base);
	// 82AB2538: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB253C: 419AFF9C  beq cr6, 0x82ab24d8
	if ctx.cr[6].eq {
	pc = 0x82AB24D8; continue 'dispatch;
	}
	// 82AB2540: 480768E1  bl 0x82b28e20
	ctx.lr = 0x82AB2544;
	sub_82B28E20(ctx, base);
	// 82AB2544: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB2548: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82AB254C: 4800000C  b 0x82ab2558
	pc = 0x82AB2558; continue 'dispatch;
	// 82AB2550: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB2554: 7EABE12E  stwx r21, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[21].u32) };
	// 82AB2558: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB255C: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82AB2560: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB2564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB2568: 7C6BE02E  lwzx r3, r11, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82AB256C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2570: 419A000C  beq cr6, 0x82ab257c
	if ctx.cr[6].eq {
	pc = 0x82AB257C; continue 'dispatch;
	}
	// 82AB2574: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB2578: 48000008  b 0x82ab2580
	pc = 0x82AB2580; continue 'dispatch;
	// 82AB257C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB2580: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB2584: 4E800421  bctrl
	ctx.lr = 0x82AB2588;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB2588: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AB258C: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82AB2590: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82AB2594: 7F175800  cmpw cr6, r23, r11
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB2598: 4198FD30  blt cr6, 0x82ab22c8
	if ctx.cr[6].lt {
	pc = 0x82AB22C8; continue 'dispatch;
	}
	// 82AB259C: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 82AB25A0: 7EB8AB78  mr r24, r21
	ctx.r[24].u64 = ctx.r[21].u64;
	// 82AB25A4: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82AB25A8: 419A0014  beq cr6, 0x82ab25bc
	if ctx.cr[6].eq {
	pc = 0x82AB25BC; continue 'dispatch;
	}
	// 82AB25AC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB25B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB25B4: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82AB25B8: 409A0008  bne cr6, 0x82ab25c0
	if !ctx.cr[6].eq {
	pc = 0x82AB25C0; continue 'dispatch;
	}
	// 82AB25BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AB25C0: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB25C4: 5579063E  clrlwi r25, r11, 0x18
	ctx.r[25].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AB25C8: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82AB25CC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB25D0: 40990088  ble cr6, 0x82ab2658
	if !ctx.cr[6].gt {
	pc = 0x82AB2658; continue 'dispatch;
	}
	// 82AB25D4: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 82AB25D8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB25DC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AB25E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB25E4: 7FABD214  add r29, r11, r26
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82AB25E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB25EC: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82AB25F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB25F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB25F8: 4E800421  bctrl
	ctx.lr = 0x82AB25FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB25FC: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 82AB2600: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 82AB2604: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AB2608: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82AB260C: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 82AB2610: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB2614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB2618: 48078909  bl 0x82b2af20
	ctx.lr = 0x82AB261C;
	sub_82B2AF20(ctx, base);
	// 82AB261C: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AB2620: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB2624: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AB2628: 813F0040  lwz r9, 0x40(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB262C: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82AB2630: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB2634: 7F0BC214  add r24, r11, r24
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82AB2638: 911F003C  stw r8, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 82AB263C: 3B5A00E0  addi r26, r26, 0xe0
	ctx.r[26].s64 = ctx.r[26].s64 + 224;
	// 82AB2640: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AB2644: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82AB2648: 90FF0040  stw r7, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	// 82AB264C: 80DF002C  lwz r6, 0x2c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB2650: 7F1B3000  cmpw cr6, r27, r6
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82AB2654: 4198FF84  blt cr6, 0x82ab25d8
	if ctx.cr[6].lt {
	pc = 0x82AB25D8; continue 'dispatch;
	}
	// 82AB2658: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB265C: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82AB2660: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2664: 40990080  ble cr6, 0x82ab26e4
	if !ctx.cr[6].gt {
	pc = 0x82AB26E4; continue 'dispatch;
	}
	// 82AB2668: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 82AB266C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB2670: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AB2674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB2678: 7FABD214  add r29, r11, r26
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82AB267C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB2680: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82AB2684: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB2688: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB268C: 4E800421  bctrl
	ctx.lr = 0x82AB2690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB2690: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 82AB2694: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 82AB2698: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 82AB269C: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82AB26A0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 82AB26A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB26A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB26AC: 48073DB5  bl 0x82b26460
	ctx.lr = 0x82AB26B0;
	sub_82B26460(ctx, base);
	// 82AB26B0: 815D007C  lwz r10, 0x7c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AB26B4: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB26B8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AB26BC: 813F0040  lwz r9, 0x40(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB26C0: 3B5A009C  addi r26, r26, 0x9c
	ctx.r[26].s64 = ctx.r[26].s64 + 156;
	// 82AB26C4: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AB26C8: 911F003C  stw r8, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 82AB26CC: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AB26D0: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82AB26D4: 90FF0040  stw r7, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	// 82AB26D8: 80DF0030  lwz r6, 0x30(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB26DC: 7F1B3000  cmpw cr6, r27, r6
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82AB26E0: 4198FF8C  blt cr6, 0x82ab266c
	if ctx.cr[6].lt {
	pc = 0x82AB266C; continue 'dispatch;
	}
	// 82AB26E4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AB26E8: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82AB26EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB26F0: 40990080  ble cr6, 0x82ab2770
	if !ctx.cr[6].gt {
	pc = 0x82AB2770; continue 'dispatch;
	}
	// 82AB26F4: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 82AB26F8: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AB26FC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AB2700: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB2704: 7FABD214  add r29, r11, r26
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82AB2708: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB270C: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82AB2710: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB2714: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB2718: 4E800421  bctrl
	ctx.lr = 0x82AB271C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB271C: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 82AB2720: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82AB2724: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AB2728: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB272C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB2730: 48082B79  bl 0x82b352a8
	ctx.lr = 0x82AB2734;
	sub_82B352A8(ctx, base);
	// 82AB2734: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AB2738: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB273C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AB2740: 813F0040  lwz r9, 0x40(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB2744: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82AB2748: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB274C: 7F0BC214  add r24, r11, r24
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82AB2750: 911F003C  stw r8, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 82AB2754: 3B5A00F0  addi r26, r26, 0xf0
	ctx.r[26].s64 = ctx.r[26].s64 + 240;
	// 82AB2758: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AB275C: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82AB2760: 90FF0040  stw r7, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	// 82AB2764: 80DF0038  lwz r6, 0x38(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AB2768: 7F1B3000  cmpw cr6, r27, r6
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82AB276C: 4198FF8C  blt cr6, 0x82ab26f8
	if ctx.cr[6].lt {
	pc = 0x82AB26F8; continue 'dispatch;
	}
	// 82AB2770: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AB2774: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82AB2778: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB277C: 40990058  ble cr6, 0x82ab27d4
	if !ctx.cr[6].gt {
	pc = 0x82AB27D4; continue 'dispatch;
	}
	// 82AB2780: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 82AB2784: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB2788: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82AB278C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB2790: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82AB2794: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB2798: 7FEBE12E  stwx r31, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[31].u32) };
	// 82AB279C: 4807021D  bl 0x82b229b8
	ctx.lr = 0x82AB27A0;
	sub_82B229B8(ctx, base);
	// 82AB27A0: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB27A4: 813F003C  lwz r9, 0x3c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB27A8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AB27AC: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB27B0: 3B9C0034  addi r28, r28, 0x34
	ctx.r[28].s64 = ctx.r[28].s64 + 52;
	// 82AB27B4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82AB27B8: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82AB27BC: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB27C0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB27C4: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82AB27C8: 813F0034  lwz r9, 0x34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AB27CC: 7F1B4800  cmpw cr6, r27, r9
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AB27D0: 4198FFB4  blt cr6, 0x82ab2784
	if ctx.cr[6].lt {
	pc = 0x82AB2784; continue 'dispatch;
	}
	// 82AB27D4: 55EB063E  clrlwi r11, r15, 0x18
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0x000000FFu64;
	// 82AB27D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB27DC: 419A022C  beq cr6, 0x82ab2a08
	if ctx.cr[6].eq {
	pc = 0x82AB2A08; continue 'dispatch;
	}
	// 82AB27E0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AB27E4: 4B76CADD  bl 0x8221f2c0
	ctx.lr = 0x82AB27E8;
	sub_8221F2C0(ctx, base);
	// 82AB27E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB27EC: 409A0130  bne cr6, 0x82ab291c
	if !ctx.cr[6].eq {
	pc = 0x82AB291C; continue 'dispatch;
	}
	// 82AB27F0: 81716F6C  lwz r11, 0x6f6c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AB27F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB27F8: 419A0014  beq cr6, 0x82ab280c
	if ctx.cr[6].eq {
	pc = 0x82AB280C; continue 'dispatch;
	}
	// 82AB27FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB2800: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AB2804: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AB2808: 4E800421  bctrl
	ctx.lr = 0x82AB280C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB280C: 4820FB9D  bl 0x82cc23a8
	ctx.lr = 0x82AB2810;
	sub_82CC23A8(ctx, base);
	// 82AB2810: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 82AB2814: 3B9F00D4  addi r28, r31, 0xd4
	ctx.r[28].s64 = ctx.r[31].s64 + 212;
	// 82AB2818: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB281C: 4B7052FD  bl 0x821b7b18
	ctx.lr = 0x82AB2820;
	sub_821B7B18(ctx, base);
	// 82AB2820: 93BF00D4  stw r29, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 82AB2824: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AB2828: 419A003C  beq cr6, 0x82ab2864
	if ctx.cr[6].eq {
	pc = 0x82AB2864; continue 'dispatch;
	}
	// 82AB282C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AB2830: 4B76CA91  bl 0x8221f2c0
	ctx.lr = 0x82AB2834;
	sub_8221F2C0(ctx, base);
	// 82AB2834: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB2838: 409A00F8  bne cr6, 0x82ab2930
	if !ctx.cr[6].eq {
	pc = 0x82AB2930; continue 'dispatch;
	}
	// 82AB283C: 81716F6C  lwz r11, 0x6f6c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82AB2840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB2844: 419A0014  beq cr6, 0x82ab2858
	if ctx.cr[6].eq {
	pc = 0x82AB2858; continue 'dispatch;
	}
	// 82AB2848: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB284C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AB2850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AB2854: 4E800421  bctrl
	ctx.lr = 0x82AB2858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB2858: 4820FB51  bl 0x82cc23a8
	ctx.lr = 0x82AB285C;
	sub_82CC23A8(ctx, base);
	// 82AB285C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82AB2860: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB2864: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82AB2868: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB286C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 82AB2870: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB2874: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AB2878: 480D8FA9  bl 0x82b8b820
	ctx.lr = 0x82AB287C;
	sub_82B8B820(ctx, base);
	// 82AB287C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB2880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB2884: 419A0184  beq cr6, 0x82ab2a08
	if ctx.cr[6].eq {
	pc = 0x82AB2A08; continue 'dispatch;
	}
	// 82AB2888: 3D400300  lis r10, 0x300
	ctx.r[10].s64 = 50331648;
	// 82AB288C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2890: 92A10054  stw r21, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	// 82AB2894: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AB2898: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AB289C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AB28A0: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82AB28A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AB28A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB28AC: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82AB28B0: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB28B4: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB28B8: 552B003A  rlwinm r11, r9, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB28BC: 54EA01BA  rlwinm r10, r7, 0, 6, 0x1d
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB28C0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82AB28C4: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82AB28C8: 4B743A39  bl 0x821f6300
	ctx.lr = 0x82AB28CC;
	sub_821F6300(ctx, base);
	// 82AB28CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB28D0: 419A0158  beq cr6, 0x82ab2a28
	if ctx.cr[6].eq {
	pc = 0x82AB2A28; continue 'dispatch;
	}
	// 82AB28D4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB28D8: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB28DC: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB28E0: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82AB28E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AB28E8: 4199006C  bgt cr6, 0x82ab2954
	if ctx.cr[6].gt {
	pc = 0x82AB2954; continue 'dispatch;
	}
	// 82AB28EC: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB28F0: 481F6B91  bl 0x82ca9480
	ctx.lr = 0x82AB28F4;
	sub_82CA9480(ctx, base);
	// 82AB28F4: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB28F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB28FC: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB2900: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82AB2904: 7D3D5A14  add r9, r29, r11
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AB2908: 7CFD4050  subf r7, r29, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 82AB290C: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82AB2910: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AB2914: 90FE0014  stw r7, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82AB2918: 48000048  b 0x82ab2960
	pc = 0x82AB2960; continue 'dispatch;
	// 82AB291C: 92A30000  stw r21, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 82AB2920: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB2924: 92A30004  stw r21, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	// 82AB2928: 9AA30008  stb r21, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[21].u8 ) };
	// 82AB292C: 4BFFFEE8  b 0x82ab2814
	pc = 0x82AB2814; continue 'dispatch;
	// 82AB2930: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2934: 3D2082A5  lis r9, -0x7d5b
	ctx.r[9].s64 = -2103115776;
	// 82AB2938: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AB293C: 38E97968  addi r7, r9, 0x7968
	ctx.r[7].s64 = ctx.r[9].s64 + 31080;
	// 82AB2940: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AB2944: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AB2948: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AB294C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB2950: 4BFFFF10  b 0x82ab2860
	pc = 0x82AB2860; continue 'dispatch;
	// 82AB2954: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AB2958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB295C: 4BF6E58D  bl 0x82a20ee8
	ctx.lr = 0x82AB2960;
	sub_82A20EE8(ctx, base);
	// 82AB2960: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2964: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 82AB2968: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB296C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB2970: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB2974: 54A8003A  rlwinm r8, r5, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB2978: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82AB297C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB2980: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AB2984: 7CEA4A14  add r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82AB2988: 7CE0592D  stwcx. r7, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB298C: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB2990: 4082FFE8  bne 0x82ab2978
	if !ctx.cr[0].eq {
	pc = 0x82AB2978; continue 'dispatch;
	}
	// 82AB2994: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82AB2998: 5544052E  rlwinm r4, r10, 0, 0x14, 0x17
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB299C: 2B040100  cmplwi cr6, r4, 0x100
	ctx.cr[6].compare_u32(ctx.r[4].u32, 256 as u32, &mut ctx.xer);
	// 82AB29A0: 409A0064  bne cr6, 0x82ab2a04
	if !ctx.cr[6].eq {
	pc = 0x82AB2A04; continue 'dispatch;
	}
	// 82AB29A4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB29A8: 3D20FFFF  lis r9, -1
	ctx.r[9].s64 = -65536;
	// 82AB29AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB29B0: 419A0054  beq cr6, 0x82ab2a04
	if ctx.cr[6].eq {
	pc = 0x82AB2A04; continue 'dispatch;
	}
	// 82AB29B4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB29B8: 5547843E  srwi r7, r10, 0x10
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shr(16);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82AB29BC: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB29C0: 5549043E  clrlwi r9, r10, 0x10
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82AB29C4: 54C50294  rlwinm r5, r6, 0, 0xa, 0xa
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB29C8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82AB29CC: 409A001C  bne cr6, 0x82ab29e8
	if !ctx.cr[6].eq {
	pc = 0x82AB29E8; continue 'dispatch;
	}
	// 82AB29D0: 550B653E  srwi r11, r8, 0x14
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB29D4: 550A00FE  clrlwi r10, r8, 3
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x1FFFFFFFu64;
	// 82AB29D8: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 82AB29DC: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB29E0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB29E4: 3D0AC000  addis r8, r10, -0x4000
	ctx.r[8].s64 = ctx.r[10].s64 + -1073741824;
	// 82AB29E8: 550B0030  rlwinm r11, r8, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB29EC: 55293830  slwi r9, r9, 7
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB29F0: 54EA3830  slwi r10, r7, 7
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(7);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB29F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AB29F8: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AB29FC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AB2A00: 4B71EB09  bl 0x821d1508
	ctx.lr = 0x82AB2A04;
	sub_821D1508(ctx, base);
	// 82AB2A04: 7C0004AC  sync
	// 82AB2A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2A0C: 480005DD  bl 0x82ab2fe8
	ctx.lr = 0x82AB2A10;
	sub_82AB2FE8(ctx, base);
	// 82AB2A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2A14: 480006DD  bl 0x82ab30f0
	ctx.lr = 0x82AB2A18;
	sub_82AB30F0(ctx, base);
	// 82AB2A18: 48000809  bl 0x82ab3220
	ctx.lr = 0x82AB2A1C;
	sub_82AB3220(ctx, base);
	// 82AB2A1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2A20: 480004E9  bl 0x82ab2f08
	ctx.lr = 0x82AB2A24;
	sub_82AB2F08(ctx, base);
	// 82AB2A24: 480000ED  bl 0x82ab2b10
	ctx.lr = 0x82AB2A28;
	sub_82AB2B10(ctx, base);
	// 82AB2A28: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82AB2A2C: 481F69F8  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB2A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB2A30 size=188
    let mut pc: u32 = 0x82AB2A30;
    'dispatch: loop {
        match pc {
            0x82AB2A30 => {
    //   block [0x82AB2A30..0x82AB2A70)
	// 82AB2A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB2A34: 481F69D1  bl 0x82ca9404
	ctx.lr = 0x82AB2A38;
	sub_82CA93D0(ctx, base);
	// 82AB2A38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB2A3C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AB2A40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB2A44: 576B07BC  rlwinm r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB2A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB2A4C: 419A0064  beq cr6, 0x82ab2ab0
	if ctx.cr[6].eq {
	pc = 0x82AB2AB0; continue 'dispatch;
	}
	// 82AB2A50: 815FFFF0  lwz r10, -0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82AB2A54: 3B9FFFF0  addi r28, r31, -0x10
	ctx.r[28].s64 = ctx.r[31].s64 + -16;
	// 82AB2A58: 1D6A00F0  mulli r11, r10, 0xf0
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 240 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AB2A5C: 37CAFFFF  addic. r30, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB2A60: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AB2A64: 4180002C  blt 0x82ab2a90
	if ctx.cr[0].lt {
	pc = 0x82AB2A90; continue 'dispatch;
	}
	// 82AB2A68: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AB2A6C: 3BAB93B0  addi r29, r11, -0x6c50
	ctx.r[29].s64 = ctx.r[11].s64 + -27728;
	pc = 0x82AB2A70; continue 'dispatch;
            }
            0x82AB2A70 => {
    //   block [0x82AB2A70..0x82AB2A90)
	// 82AB2A70: 3BFFFF10  addi r31, r31, -0xf0
	ctx.r[31].s64 = ctx.r[31].s64 + -240;
	// 82AB2A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2A78: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AB2A7C: 480791BD  bl 0x82b2bc38
	ctx.lr = 0x82AB2A80;
	sub_82B2BC38(ctx, base);
	// 82AB2A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2A84: 48077BDD  bl 0x82b2a660
	ctx.lr = 0x82AB2A88;
	sub_82B2A660(ctx, base);
	// 82AB2A88: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB2A8C: 4080FFE4  bge 0x82ab2a70
	if !ctx.cr[0].lt {
	pc = 0x82AB2A70; continue 'dispatch;
	}
	pc = 0x82AB2A90; continue 'dispatch;
            }
            0x82AB2A90 => {
    //   block [0x82AB2A90..0x82AB2AA4)
	// 82AB2A90: 576B07FE  clrlwi r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 82AB2A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB2A98: 419A000C  beq cr6, 0x82ab2aa4
	if ctx.cr[6].eq {
	pc = 0x82AB2AA4; continue 'dispatch;
	}
	// 82AB2A9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB2AA0: 4B769299  bl 0x8221bd38
	ctx.lr = 0x82AB2AA4;
	sub_8221BD38(ctx, base);
	pc = 0x82AB2AA4; continue 'dispatch;
            }
            0x82AB2AA4 => {
    //   block [0x82AB2AA4..0x82AB2AB0)
	// 82AB2AA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB2AA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB2AAC: 481F69A8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB2AB0 => {
    //   block [0x82AB2AB0..0x82AB2AE0)
	// 82AB2AB0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AB2AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2AB8: 394B93B0  addi r10, r11, -0x6c50
	ctx.r[10].s64 = ctx.r[11].s64 + -27728;
	// 82AB2ABC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB2AC0: 48079179  bl 0x82b2bc38
	ctx.lr = 0x82AB2AC4;
	sub_82B2BC38(ctx, base);
	// 82AB2AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2AC8: 48077B99  bl 0x82b2a660
	ctx.lr = 0x82AB2ACC;
	sub_82B2A660(ctx, base);
	// 82AB2ACC: 576907FE  clrlwi r9, r27, 0x1f
	ctx.r[9].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 82AB2AD0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB2AD4: 419A000C  beq cr6, 0x82ab2ae0
	if ctx.cr[6].eq {
	pc = 0x82AB2AE0; continue 'dispatch;
	}
	// 82AB2AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2ADC: 4B76925D  bl 0x8221bd38
	ctx.lr = 0x82AB2AE0;
	sub_8221BD38(ctx, base);
	pc = 0x82AB2AE0; continue 'dispatch;
            }
            0x82AB2AE0 => {
    //   block [0x82AB2AE0..0x82AB2AEC)
	// 82AB2AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB2AE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB2AE8: 481F696C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB2AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB2AF0 size=32
    let mut pc: u32 = 0x82AB2AF0;
    'dispatch: loop {
        match pc {
            0x82AB2AF0 => {
    //   block [0x82AB2AF0..0x82AB2B10)
	// 82AB2AF0: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AB2AF4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82AB2AF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AB2AFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB2B00: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2B04: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AB2B08: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82AB2B0C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB2B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB2B10 size=276
    let mut pc: u32 = 0x82AB2B10;
    'dispatch: loop {
        match pc {
            0x82AB2B10 => {
    //   block [0x82AB2B10..0x82AB2B48)
	// 82AB2B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB2B14: 481F68D5  bl 0x82ca93e8
	ctx.lr = 0x82AB2B18;
	sub_82CA93D0(ctx, base);
	// 82AB2B18: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB2B1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB2B20: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82AB2B24: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB2B28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2B2C: 409900F0  ble cr6, 0x82ab2c1c
	if !ctx.cr[6].gt {
	pc = 0x82AB2C1C; continue 'dispatch;
	}
	// 82AB2B30: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82AB2B34: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82AB2B38: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 82AB2B3C: 6179FFFF  ori r25, r11, 0xffff
	ctx.r[25].u64 = ctx.r[11].u64 | 65535;
	// 82AB2B40: 3EA0834A  lis r21, -0x7cb6
	ctx.r[21].s64 = -2092302336;
	// 82AB2B44: 3A80FFFF  li r20, -1
	ctx.r[20].s64 = -1;
	pc = 0x82AB2B48; continue 'dispatch;
            }
            0x82AB2B48 => {
    //   block [0x82AB2B48..0x82AB2B78)
	// 82AB2B48: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB2B4C: 7D785A14  add r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 82AB2B50: 834B0094  lwz r26, 0x94(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AB2B54: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AB2B58: 419A00B0  beq cr6, 0x82ab2c08
	if ctx.cr[6].eq {
	pc = 0x82AB2C08; continue 'dispatch;
	}
	// 82AB2B5C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2B60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2B64: 41980014  blt cr6, 0x82ab2b78
	if ctx.cr[6].lt {
	pc = 0x82AB2B78; continue 'dispatch;
	}
	// 82AB2B68: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB2B6C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB2B70: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AB2B74: 48000008  b 0x82ab2b7c
	pc = 0x82AB2B7C; continue 'dispatch;
            }
            0x82AB2B78 => {
    //   block [0x82AB2B78..0x82AB2B7C)
	// 82AB2B78: 80755760  lwz r3, 0x5760(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(22368 as u32) ) } as u64;
	pc = 0x82AB2B7C; continue 'dispatch;
            }
            0x82AB2B7C => {
    //   block [0x82AB2B7C..0x82AB2BBC)
	// 82AB2B7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2B80: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB2B84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB2B88: 4E800421  bctrl
	ctx.lr = 0x82AB2B8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB2B8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AB2B90: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2B94: 9AFC0008  stb r23, 8(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[23].u8 ) };
	// 82AB2B98: 81090030  lwz r8, 0x30(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB2B9C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82AB2BA0: 4E800421  bctrl
	ctx.lr = 0x82AB2BA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB2BA4: 83DF0028  lwz r30, 0x28(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AB2BA8: 3B7E0001  addi r27, r30, 1
	ctx.r[27].s64 = ctx.r[30].s64 + 1;
	// 82AB2BAC: 7F1BC840  cmplw cr6, r27, r25
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82AB2BB0: 5763103A  slwi r3, r27, 2
	ctx.r[3].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB2BB4: 40990008  ble cr6, 0x82ab2bbc
	if !ctx.cr[6].gt {
	pc = 0x82AB2BBC; continue 'dispatch;
	}
	// 82AB2BB8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
            }
            0x82AB2BBC => {
    //   block [0x82AB2BBC..0x82AB2BD4)
	// 82AB2BBC: 4B76C69D  bl 0x8221f258
	ctx.lr = 0x82AB2BC0;
	sub_8221F258(ctx, base);
	// 82AB2BC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB2BC4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB2BC8: 419A0024  beq cr6, 0x82ab2bec
	if ctx.cr[6].eq {
	pc = 0x82AB2BEC; continue 'dispatch;
	}
	// 82AB2BCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB2BD0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x82AB2BD4; continue 'dispatch;
            }
            0x82AB2BD4 => {
    //   block [0x82AB2BD4..0x82AB2BEC)
	// 82AB2BD4: 813F0058  lwz r9, 0x58(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB2BD8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB2BDC: 7D0B482E  lwzx r8, r11, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AB2BE0: 7D0BE92E  stwx r8, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 82AB2BE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AB2BE8: 4082FFEC  bne 0x82ab2bd4
	if !ctx.cr[0].eq {
	pc = 0x82AB2BD4; continue 'dispatch;
	}
	pc = 0x82AB2BEC; continue 'dispatch;
            }
            0x82AB2BEC => {
    //   block [0x82AB2BEC..0x82AB2C08)
	// 82AB2BEC: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB2BF0: 7F8BE92E  stwx r28, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[28].u32) };
	// 82AB2BF4: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB2BF8: 4B769141  bl 0x8221bd38
	ctx.lr = 0x82AB2BFC;
	sub_8221BD38(ctx, base);
	// 82AB2BFC: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82AB2C00: 937F0028  stw r27, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[27].u32 ) };
	// 82AB2C04: 93DA0014  stw r30, 0x14(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	pc = 0x82AB2C08; continue 'dispatch;
            }
            0x82AB2C08 => {
    //   block [0x82AB2C08..0x82AB2C1C)
	// 82AB2C08: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB2C0C: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82AB2C10: 3B18009C  addi r24, r24, 0x9c
	ctx.r[24].s64 = ctx.r[24].s64 + 156;
	// 82AB2C14: 7F165800  cmpw cr6, r22, r11
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB2C18: 4198FF30  blt cr6, 0x82ab2b48
	if ctx.cr[6].lt {
	pc = 0x82AB2B48; continue 'dispatch;
	}
	pc = 0x82AB2C1C; continue 'dispatch;
            }
            0x82AB2C1C => {
    //   block [0x82AB2C1C..0x82AB2C24)
	// 82AB2C1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AB2C20: 481F6818  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB2C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB2C28 size=284
    let mut pc: u32 = 0x82AB2C28;
    'dispatch: loop {
        match pc {
            0x82AB2C28 => {
    //   block [0x82AB2C28..0x82AB2CE4)
	// 82AB2C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB2C2C: 481F67E1  bl 0x82ca940c
	ctx.lr = 0x82AB2C30;
	sub_82CA93D0(ctx, base);
	// 82AB2C30: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB2C34: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82AB2C38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AB2C3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AB2C40: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82AB2C44: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 82AB2C48: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AB2C4C: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 82AB2C50: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82AB2C54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB2C58: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82AB2C5C: 38E838C0  addi r7, r8, 0x38c0
	ctx.r[7].s64 = ctx.r[8].s64 + 14528;
	// 82AB2C60: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AB2C64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB2C68: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82AB2C6C: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82AB2C70: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AB2C74: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AB2C78: 93E90004  stw r31, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82AB2C7C: 93E90008  stw r31, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82AB2C80: 93E9000C  stw r31, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AB2C84: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82AB2C88: 93E100E0  stw r31, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[31].u32 ) };
	// 82AB2C8C: 93E100E4  stw r31, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[31].u32 ) };
	// 82AB2C90: 93E100E8  stw r31, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[31].u32 ) };
	// 82AB2C94: 9BE10088  stb r31, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u8 ) };
	// 82AB2C98: 9BE10089  stb r31, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[31].u8 ) };
	// 82AB2C9C: 9BE1008A  stb r31, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[31].u8 ) };
	// 82AB2CA0: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 82AB2CA4: 9BE100B9  stb r31, 0xb9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(185 as u32), ctx.r[31].u8 ) };
	// 82AB2CA8: 480C7E21  bl 0x82b7aac8
	ctx.lr = 0x82AB2CAC;
	sub_82B7AAC8(ctx, base);
	// 82AB2CAC: 80C10080  lwz r6, 0x80(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AB2CB0: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AB2CB4: 7C853050  subf r4, r5, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 82AB2CB8: 54830038  rlwinm r3, r4, 0, 0, 0x1c
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB2CBC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82AB2CC0: 40990074  ble cr6, 0x82ab2d34
	if !ctx.cr[6].gt {
	pc = 0x82AB2D34; continue 'dispatch;
	}
	// 82AB2CC4: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 82AB2CC8: 4B76C591  bl 0x8221f258
	ctx.lr = 0x82AB2CCC;
	sub_8221F258(ctx, base);
	// 82AB2CCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB2CD0: 419A0014  beq cr6, 0x82ab2ce4
	if ctx.cr[6].eq {
	pc = 0x82AB2CE4; continue 'dispatch;
	}
	// 82AB2CD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AB2CD8: 4BE08C29  bl 0x828bb900
	ctx.lr = 0x82AB2CDC;
	sub_828BB900(ctx, base);
	// 82AB2CDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB2CE0: 48000008  b 0x82ab2ce8
	pc = 0x82AB2CE8; continue 'dispatch;
            }
            0x82AB2CE4 => {
    //   block [0x82AB2CE4..0x82AB2CE8)
	// 82AB2CE4: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	pc = 0x82AB2CE8; continue 'dispatch;
            }
            0x82AB2CE8 => {
    //   block [0x82AB2CE8..0x82AB2CF8)
	// 82AB2CE8: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AB2CEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB2CF0: 419A0040  beq cr6, 0x82ab2d30
	if ctx.cr[6].eq {
	pc = 0x82AB2D30; continue 'dispatch;
	}
	// 82AB2CF4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB2CF8; continue 'dispatch;
            }
            0x82AB2CF8 => {
    //   block [0x82AB2CF8..0x82AB2D2C)
	// 82AB2CF8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB2CFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB2D00: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB2D04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB2D08: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB2D0C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB2D10: 4082FFE8  bne 0x82ab2cf8
	if !ctx.cr[0].eq {
	pc = 0x82AB2CF8; continue 'dispatch;
	}
	// 82AB2D14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2D18: 409A0014  bne cr6, 0x82ab2d2c
	if !ctx.cr[6].eq {
	pc = 0x82AB2D2C; continue 'dispatch;
	}
	// 82AB2D1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2D20: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB2D24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB2D28: 4E800421  bctrl
	ctx.lr = 0x82AB2D2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB2D2C => {
    //   block [0x82AB2D2C..0x82AB2D30)
	// 82AB2D2C: 93FE006C  stw r31, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	pc = 0x82AB2D30; continue 'dispatch;
            }
            0x82AB2D30 => {
    //   block [0x82AB2D30..0x82AB2D34)
	// 82AB2D30: 93BE006C  stw r29, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	pc = 0x82AB2D34; continue 'dispatch;
            }
            0x82AB2D34 => {
    //   block [0x82AB2D34..0x82AB2D44)
	// 82AB2D34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB2D38: 4BAC97C9  bl 0x8257c500
	ctx.lr = 0x82AB2D3C;
	sub_8257C500(ctx, base);
	// 82AB2D3C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82AB2D40: 481F671C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB2D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB2D48 size=448
    let mut pc: u32 = 0x82AB2D48;
    'dispatch: loop {
        match pc {
            0x82AB2D48 => {
    //   block [0x82AB2D48..0x82AB2D70)
	// 82AB2D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB2D4C: 481F66B9  bl 0x82ca9404
	ctx.lr = 0x82AB2D50;
	sub_82CA93D0(ctx, base);
	// 82AB2D50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB2D54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB2D58: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AB2D5C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82AB2D60: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AB2D64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2D68: 40990040  ble cr6, 0x82ab2da8
	if !ctx.cr[6].gt {
	pc = 0x82AB2DA8; continue 'dispatch;
	}
	// 82AB2D6C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x82AB2D70; continue 'dispatch;
            }
            0x82AB2D70 => {
    //   block [0x82AB2D70..0x82AB2D94)
	// 82AB2D70: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB2D74: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AB2D78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB2D7C: 419A0018  beq cr6, 0x82ab2d94
	if ctx.cr[6].eq {
	pc = 0x82AB2D94; continue 'dispatch;
	}
	// 82AB2D80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2D84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AB2D88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2D8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB2D90: 4E800421  bctrl
	ctx.lr = 0x82AB2D94;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB2D94 => {
    //   block [0x82AB2D94..0x82AB2DA8)
	// 82AB2D94: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AB2D98: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82AB2D9C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82AB2DA0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB2DA4: 4198FFCC  blt cr6, 0x82ab2d70
	if ctx.cr[6].lt {
	pc = 0x82AB2D70; continue 'dispatch;
	}
	pc = 0x82AB2DA8; continue 'dispatch;
            }
            0x82AB2DA8 => {
    //   block [0x82AB2DA8..0x82AB2DEC)
	// 82AB2DA8: 807E0058  lwz r3, 0x58(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB2DAC: 4B768F8D  bl 0x8221bd38
	ctx.lr = 0x82AB2DB0;
	sub_8221BD38(ctx, base);
	// 82AB2DB0: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB2DB4: 939E0058  stw r28, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82AB2DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB2DBC: 419A0034  beq cr6, 0x82ab2df0
	if ctx.cr[6].eq {
	pc = 0x82AB2DF0; continue 'dispatch;
	}
	// 82AB2DC0: 814BFFF0  lwz r10, -0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82AB2DC4: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 82AB2DC8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB2DCC: 419A0020  beq cr6, 0x82ab2dec
	if ctx.cr[6].eq {
	pc = 0x82AB2DEC; continue 'dispatch;
	}
	// 82AB2DD0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2DD4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AB2DD8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB2DDC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2DE0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82AB2DE4: 4E800421  bctrl
	ctx.lr = 0x82AB2DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB2DE8: 48000008  b 0x82ab2df0
	pc = 0x82AB2DF0; continue 'dispatch;
            }
            0x82AB2DEC => {
    //   block [0x82AB2DEC..0x82AB2DF0)
	// 82AB2DEC: 4B768F4D  bl 0x8221bd38
	ctx.lr = 0x82AB2DF0;
	sub_8221BD38(ctx, base);
	pc = 0x82AB2DF0; continue 'dispatch;
            }
            0x82AB2DF0 => {
    //   block [0x82AB2DF0..0x82AB2E2C)
	// 82AB2DF0: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB2DF4: 939E005C  stw r28, 0x5c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82AB2DF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB2DFC: 419A0034  beq cr6, 0x82ab2e30
	if ctx.cr[6].eq {
	pc = 0x82AB2E30; continue 'dispatch;
	}
	// 82AB2E00: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AB2E04: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AB2E08: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB2E0C: 419A0020  beq cr6, 0x82ab2e2c
	if ctx.cr[6].eq {
	pc = 0x82AB2E2C; continue 'dispatch;
	}
	// 82AB2E10: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2E14: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AB2E18: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB2E1C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2E20: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82AB2E24: 4E800421  bctrl
	ctx.lr = 0x82AB2E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB2E28: 48000008  b 0x82ab2e30
	pc = 0x82AB2E30; continue 'dispatch;
            }
            0x82AB2E2C => {
    //   block [0x82AB2E2C..0x82AB2E30)
	// 82AB2E2C: 4B768F0D  bl 0x8221bd38
	ctx.lr = 0x82AB2E30;
	sub_8221BD38(ctx, base);
	pc = 0x82AB2E30; continue 'dispatch;
            }
            0x82AB2E30 => {
    //   block [0x82AB2E30..0x82AB2E5C)
	// 82AB2E30: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB2E34: 939E0060  stw r28, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82AB2E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB2E3C: 419A005C  beq cr6, 0x82ab2e98
	if ctx.cr[6].eq {
	pc = 0x82AB2E98; continue 'dispatch;
	}
	// 82AB2E40: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AB2E44: 3B6BFFFC  addi r27, r11, -4
	ctx.r[27].s64 = ctx.r[11].s64 + -4;
	// 82AB2E48: 1D490034  mulli r10, r9, 0x34
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 52 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82AB2E4C: 37A9FFFF  addic. r29, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AB2E50: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AB2E54: 4180003C  blt 0x82ab2e90
	if ctx.cr[0].lt {
	pc = 0x82AB2E90; continue 'dispatch;
	}
	// 82AB2E58: 3BEB001C  addi r31, r11, 0x1c
	ctx.r[31].s64 = ctx.r[11].s64 + 28;
	pc = 0x82AB2E5C; continue 'dispatch;
            }
            0x82AB2E5C => {
    //   block [0x82AB2E5C..0x82AB2E74)
	// 82AB2E5C: 3BFFFFCC  addi r31, r31, -0x34
	ctx.r[31].s64 = ctx.r[31].s64 + -52;
	// 82AB2E60: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB2E64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB2E68: 419A000C  beq cr6, 0x82ab2e74
	if ctx.cr[6].eq {
	pc = 0x82AB2E74; continue 'dispatch;
	}
	// 82AB2E6C: 480D475D  bl 0x82b875c8
	ctx.lr = 0x82AB2E70;
	sub_82B875C8(ctx, base);
	// 82AB2E70: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x82AB2E74; continue 'dispatch;
            }
            0x82AB2E74 => {
    //   block [0x82AB2E74..0x82AB2E88)
	// 82AB2E74: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2E78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB2E7C: 419A000C  beq cr6, 0x82ab2e88
	if ctx.cr[6].eq {
	pc = 0x82AB2E88; continue 'dispatch;
	}
	// 82AB2E80: 480D4749  bl 0x82b875c8
	ctx.lr = 0x82AB2E84;
	sub_82B875C8(ctx, base);
	// 82AB2E84: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82AB2E88; continue 'dispatch;
            }
            0x82AB2E88 => {
    //   block [0x82AB2E88..0x82AB2E90)
	// 82AB2E88: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AB2E8C: 4080FFD0  bge 0x82ab2e5c
	if !ctx.cr[0].lt {
	pc = 0x82AB2E5C; continue 'dispatch;
	}
	pc = 0x82AB2E90; continue 'dispatch;
            }
            0x82AB2E90 => {
    //   block [0x82AB2E90..0x82AB2E98)
	// 82AB2E90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB2E94: 4B768EA5  bl 0x8221bd38
	ctx.lr = 0x82AB2E98;
	sub_8221BD38(ctx, base);
	pc = 0x82AB2E98; continue 'dispatch;
            }
            0x82AB2E98 => {
    //   block [0x82AB2E98..0x82AB2ED4)
	// 82AB2E98: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AB2E9C: 939E0064  stw r28, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82AB2EA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB2EA4: 419A0034  beq cr6, 0x82ab2ed8
	if ctx.cr[6].eq {
	pc = 0x82AB2ED8; continue 'dispatch;
	}
	// 82AB2EA8: 814BFFF0  lwz r10, -0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82AB2EAC: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 82AB2EB0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB2EB4: 419A0020  beq cr6, 0x82ab2ed4
	if ctx.cr[6].eq {
	pc = 0x82AB2ED4; continue 'dispatch;
	}
	// 82AB2EB8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2EBC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AB2EC0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB2EC4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB2EC8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82AB2ECC: 4E800421  bctrl
	ctx.lr = 0x82AB2ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB2ED0: 48000008  b 0x82ab2ed8
	pc = 0x82AB2ED8; continue 'dispatch;
            }
            0x82AB2ED4 => {
    //   block [0x82AB2ED4..0x82AB2ED8)
	// 82AB2ED4: 4B768E65  bl 0x8221bd38
	ctx.lr = 0x82AB2ED8;
	sub_8221BD38(ctx, base);
	pc = 0x82AB2ED8; continue 'dispatch;
            }
            0x82AB2ED8 => {
    //   block [0x82AB2ED8..0x82AB2F08)
	// 82AB2ED8: 939E0068  stw r28, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82AB2EDC: 807E0070  lwz r3, 0x70(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AB2EE0: 4B768E59  bl 0x8221bd38
	ctx.lr = 0x82AB2EE4;
	sub_8221BD38(ctx, base);
	// 82AB2EE4: 939E0070  stw r28, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82AB2EE8: 939E0028  stw r28, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[28].u32 ) };
	// 82AB2EEC: 939E002C  stw r28, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[28].u32 ) };
	// 82AB2EF0: 939E0030  stw r28, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[28].u32 ) };
	// 82AB2EF4: 939E0034  stw r28, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[28].u32 ) };
	// 82AB2EF8: 939E0038  stw r28, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[28].u32 ) };
	// 82AB2EFC: 939E0074  stw r28, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 82AB2F00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB2F04: 481F6550  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB2F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB2F08 size=220
    let mut pc: u32 = 0x82AB2F08;
    'dispatch: loop {
        match pc {
            0x82AB2F08 => {
    //   block [0x82AB2F08..0x82AB2F20)
	// 82AB2F08: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB2F0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB2F10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2F14: 419A000C  beq cr6, 0x82ab2f20
	if ctx.cr[6].eq {
	pc = 0x82AB2F20; continue 'dispatch;
	}
	// 82AB2F18: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82AB2F1C: 4800003C  b 0x82ab2f58
	pc = 0x82AB2F58; continue 'dispatch;
            }
            0x82AB2F20 => {
    //   block [0x82AB2F20..0x82AB2F34)
	// 82AB2F20: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB2F24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2F28: 419A000C  beq cr6, 0x82ab2f34
	if ctx.cr[6].eq {
	pc = 0x82AB2F34; continue 'dispatch;
	}
	// 82AB2F2C: 3940001C  li r10, 0x1c
	ctx.r[10].s64 = 28;
	// 82AB2F30: 48000028  b 0x82ab2f58
	pc = 0x82AB2F58; continue 'dispatch;
            }
            0x82AB2F34 => {
    //   block [0x82AB2F34..0x82AB2F48)
	// 82AB2F34: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AB2F38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2F3C: 419A000C  beq cr6, 0x82ab2f48
	if ctx.cr[6].eq {
	pc = 0x82AB2F48; continue 'dispatch;
	}
	// 82AB2F40: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 82AB2F44: 48000014  b 0x82ab2f58
	pc = 0x82AB2F58; continue 'dispatch;
            }
            0x82AB2F48 => {
    //   block [0x82AB2F48..0x82AB2F58)
	// 82AB2F48: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AB2F4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB2F50: 419A0008  beq cr6, 0x82ab2f58
	if ctx.cr[6].eq {
	pc = 0x82AB2F58; continue 'dispatch;
	}
	// 82AB2F54: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	pc = 0x82AB2F58; continue 'dispatch;
            }
            0x82AB2F58 => {
    //   block [0x82AB2F58..0x82AB2F7C)
	// 82AB2F58: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82AB2F5C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AB2F60: 81230020  lwz r9, 0x20(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB2F64: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB2F68: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB2F6C: 419A0010  beq cr6, 0x82ab2f7c
	if ctx.cr[6].eq {
	pc = 0x82AB2F7C; continue 'dispatch;
	}
	// 82AB2F70: 89230046  lbz r9, 0x46(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(70 as u32) ) } as u64;
	// 82AB2F74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB2F78: 409A000C  bne cr6, 0x82ab2f84
	if !ctx.cr[6].eq {
	pc = 0x82AB2F84; continue 'dispatch;
	}
	pc = 0x82AB2F7C; continue 'dispatch;
            }
            0x82AB2F7C => {
    //   block [0x82AB2F7C..0x82AB2F84)
	// 82AB2F7C: 8123003C  lwz r9, 0x3c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB2F80: 7D0951D6  mullw r8, r9, r10
	ctx.r[8].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	pc = 0x82AB2F84; continue 'dispatch;
            }
            0x82AB2F84 => {
    //   block [0x82AB2F84..0x82AB2FB0)
	// 82AB2F84: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB2F88: 81230040  lwz r9, 0x40(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB2F8C: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82AB2F90: 814300D4  lwz r10, 0xd4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AB2F94: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB2F98: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB2F9C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82AB2FA0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82AB2FA4: 419A000C  beq cr6, 0x82ab2fb0
	if ctx.cr[6].eq {
	pc = 0x82AB2FB0; continue 'dispatch;
	}
	// 82AB2FA8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB2FAC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x82AB2FB0; continue 'dispatch;
            }
            0x82AB2FB0 => {
    //   block [0x82AB2FB0..0x82AB2FDC)
	// 82AB2FB0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB2FB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB2FB8: 419A0024  beq cr6, 0x82ab2fdc
	if ctx.cr[6].eq {
	pc = 0x82AB2FDC; continue 'dispatch;
	}
	// 82AB2FBC: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB2FC0: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB2FC4: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82AB2FC8: 90EA0024  stw r7, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[7].u32 ) };
	// 82AB2FCC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB2FD0: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB2FD4: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AB2FD8: 90CA0024  stw r6, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[6].u32 ) };
	pc = 0x82AB2FDC; continue 'dispatch;
            }
            0x82AB2FDC => {
    //   block [0x82AB2FDC..0x82AB2FE4)
	// 82AB2FDC: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82AB2FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB2FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB2FE8 size=260
    let mut pc: u32 = 0x82AB2FE8;
    'dispatch: loop {
        match pc {
            0x82AB2FE8 => {
    //   block [0x82AB2FE8..0x82AB3034)
	// 82AB2FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB2FEC: 481F6421  bl 0x82ca940c
	ctx.lr = 0x82AB2FF0;
	sub_82CA93D0(ctx, base);
	// 82AB2FF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB2FF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB2FF8: 83DD006C  lwz r30, 0x6c(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AB2FFC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB3000: 419A00E4  beq cr6, 0x82ab30e4
	if ctx.cr[6].eq {
	pc = 0x82AB30E4; continue 'dispatch;
	}
	// 82AB3004: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB3008: 3D400555  lis r10, 0x555
	ctx.r[10].s64 = 89456640;
	// 82AB300C: 813E002C  lwz r9, 0x2c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB3010: 61485555  ori r8, r10, 0x5555
	ctx.r[8].u64 = ctx.r[10].u64 | 21845;
	// 82AB3014: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82AB3018: 7CFF1E70  srawi r31, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB301C: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB3020: 41990014  bgt cr6, 0x82ab3034
	if ctx.cr[6].gt {
	pc = 0x82AB3034; continue 'dispatch;
	}
	// 82AB3024: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB3028: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82AB302C: 55632036  slwi r3, r11, 4
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB3030: 48000008  b 0x82ab3038
	pc = 0x82AB3038; continue 'dispatch;
            }
            0x82AB3034 => {
    //   block [0x82AB3034..0x82AB3038)
	// 82AB3034: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82AB3038; continue 'dispatch;
            }
            0x82AB3038 => {
    //   block [0x82AB3038..0x82AB307C)
	// 82AB3038: 4B76C221  bl 0x8221f258
	ctx.lr = 0x82AB303C;
	sub_8221F258(ctx, base);
	// 82AB303C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AB3040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB3044: 917D0070  stw r11, 0x70(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AB3048: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82AB304C: 480C7965  bl 0x82b7a9b0
	ctx.lr = 0x82AB3050;
	sub_82B7A9B0(ctx, base);
	// 82AB3050: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB3054: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AB3058: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AB305C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB3060: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AB3064: 4BA35D6D  bl 0x824e8dd0
	ctx.lr = 0x82AB3068;
	sub_824E8DD0(ctx, base);
	// 82AB3068: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB306C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AB3070: 40990038  ble cr6, 0x82ab30a8
	if !ctx.cr[6].gt {
	pc = 0x82AB30A8; continue 'dispatch;
	}
	// 82AB3074: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB3078: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x82AB307C; continue 'dispatch;
            }
            0x82AB307C => {
    //   block [0x82AB307C..0x82AB309C)
	// 82AB307C: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB3080: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AB3084: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82AB3088: 419A0014  beq cr6, 0x82ab309c
	if ctx.cr[6].eq {
	pc = 0x82AB309C; continue 'dispatch;
	}
	// 82AB308C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB3090: 7D4B182E  lwzx r10, r11, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82AB3094: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB3098: 7D4B192E  stwx r10, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	pc = 0x82AB309C; continue 'dispatch;
            }
            0x82AB309C => {
    //   block [0x82AB309C..0x82AB30A8)
	// 82AB309C: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82AB30A0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AB30A4: 4082FFD8  bne 0x82ab307c
	if !ctx.cr[0].eq {
	pc = 0x82AB307C; continue 'dispatch;
	}
	pc = 0x82AB30A8; continue 'dispatch;
            }
            0x82AB30A8 => {
    //   block [0x82AB30A8..0x82AB30B8)
	// 82AB30A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB30AC: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AB30B0: 40990028  ble cr6, 0x82ab30d8
	if !ctx.cr[6].gt {
	pc = 0x82AB30D8; continue 'dispatch;
	}
	// 82AB30B4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x82AB30B8; continue 'dispatch;
            }
            0x82AB30B8 => {
    //   block [0x82AB30B8..0x82AB30D8)
	// 82AB30B8: 917D0074  stw r11, 0x74(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AB30BC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB30C0: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82AB30C4: 41990014  bgt cr6, 0x82ab30d8
	if ctx.cr[6].gt {
	pc = 0x82AB30D8; continue 'dispatch;
	}
	// 82AB30C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB30CC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AB30D0: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82AB30D4: 4198FFE4  blt cr6, 0x82ab30b8
	if ctx.cr[6].lt {
	pc = 0x82AB30B8; continue 'dispatch;
	}
	pc = 0x82AB30D8; continue 'dispatch;
            }
            0x82AB30D8 => {
    //   block [0x82AB30D8..0x82AB30E4)
	// 82AB30D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB30DC: 419A0008  beq cr6, 0x82ab30e4
	if ctx.cr[6].eq {
	pc = 0x82AB30E4; continue 'dispatch;
	}
	// 82AB30E0: 4B768C59  bl 0x8221bd38
	ctx.lr = 0x82AB30E4;
	sub_8221BD38(ctx, base);
	pc = 0x82AB30E4; continue 'dispatch;
            }
            0x82AB30E4 => {
    //   block [0x82AB30E4..0x82AB30EC)
	// 82AB30E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB30E8: 481F6374  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB30F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB30F0 size=300
    let mut pc: u32 = 0x82AB30F0;
    'dispatch: loop {
        match pc {
            0x82AB30F0 => {
    //   block [0x82AB30F0..0x82AB3120)
	// 82AB30F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB30F4: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB30F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AB30FC: 9143003C  stw r10, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 82AB3100: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82AB3104: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82AB3108: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB310C: 99430044  stb r10, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82AB3110: 99430045  stb r10, 0x45(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(69 as u32), ctx.r[10].u8 ) };
	// 82AB3114: 40990050  ble cr6, 0x82ab3164
	if !ctx.cr[6].gt {
	pc = 0x82AB3164; continue 'dispatch;
	}
	// 82AB3118: 8163005C  lwz r11, 0x5c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB311C: 396B0084  addi r11, r11, 0x84
	ctx.r[11].s64 = ctx.r[11].s64 + 132;
	pc = 0x82AB3120; continue 'dispatch;
            }
            0x82AB3120 => {
    //   block [0x82AB3120..0x82AB3130)
	// 82AB3120: 810BFFBC  lwz r8, -0x44(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-68 as u32) ) } as u64;
	// 82AB3124: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82AB3128: 419A0008  beq cr6, 0x82ab3130
	if ctx.cr[6].eq {
	pc = 0x82AB3130; continue 'dispatch;
	}
	// 82AB312C: 98A30044  stb r5, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[5].u8 ) };
	pc = 0x82AB3130; continue 'dispatch;
            }
            0x82AB3130 => {
    //   block [0x82AB3130..0x82AB3164)
	// 82AB3130: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3134: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AB3138: 8103003C  lwz r8, 0x3c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB313C: 80E30040  lwz r7, 0x40(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB3140: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82AB3144: 9103003C  stw r8, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 82AB3148: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AB314C: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82AB3150: 90E30040  stw r7, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	// 82AB3154: 396B00E0  addi r11, r11, 0xe0
	ctx.r[11].s64 = ctx.r[11].s64 + 224;
	// 82AB3158: 80C3002C  lwz r6, 0x2c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB315C: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82AB3160: 4198FFC0  blt cr6, 0x82ab3120
	if ctx.cr[6].lt {
	pc = 0x82AB3120; continue 'dispatch;
	}
	pc = 0x82AB3164; continue 'dispatch;
            }
            0x82AB3164 => {
    //   block [0x82AB3164..0x82AB317C)
	// 82AB3164: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB3168: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82AB316C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB3170: 40990060  ble cr6, 0x82ab31d0
	if !ctx.cr[6].gt {
	pc = 0x82AB31D0; continue 'dispatch;
	}
	// 82AB3174: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB3178: 396B0094  addi r11, r11, 0x94
	ctx.r[11].s64 = ctx.r[11].s64 + 148;
	pc = 0x82AB317C; continue 'dispatch;
            }
            0x82AB317C => {
    //   block [0x82AB317C..0x82AB318C)
	// 82AB317C: 810BFFAC  lwz r8, -0x54(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-84 as u32) ) } as u64;
	// 82AB3180: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82AB3184: 419A0008  beq cr6, 0x82ab318c
	if ctx.cr[6].eq {
	pc = 0x82AB318C; continue 'dispatch;
	}
	// 82AB3188: 98A30044  stb r5, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[5].u8 ) };
	pc = 0x82AB318C; continue 'dispatch;
            }
            0x82AB318C => {
    //   block [0x82AB318C..0x82AB319C)
	// 82AB318C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3190: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82AB3194: 419A0008  beq cr6, 0x82ab319c
	if ctx.cr[6].eq {
	pc = 0x82AB319C; continue 'dispatch;
	}
	// 82AB3198: 98A30045  stb r5, 0x45(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(69 as u32), ctx.r[5].u8 ) };
	pc = 0x82AB319C; continue 'dispatch;
            }
            0x82AB319C => {
    //   block [0x82AB319C..0x82AB31D0)
	// 82AB319C: 810BFFE8  lwz r8, -0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 82AB31A0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AB31A4: 80C3003C  lwz r6, 0x3c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB31A8: 80E30040  lwz r7, 0x40(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB31AC: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82AB31B0: 9103003C  stw r8, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 82AB31B4: 810BFFEC  lwz r8, -0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82AB31B8: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82AB31BC: 90E30040  stw r7, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	// 82AB31C0: 396B009C  addi r11, r11, 0x9c
	ctx.r[11].s64 = ctx.r[11].s64 + 156;
	// 82AB31C4: 80C30030  lwz r6, 0x30(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB31C8: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82AB31CC: 4198FFB0  blt cr6, 0x82ab317c
	if ctx.cr[6].lt {
	pc = 0x82AB317C; continue 'dispatch;
	}
	pc = 0x82AB31D0; continue 'dispatch;
            }
            0x82AB31D0 => {
    //   block [0x82AB31D0..0x82AB31E4)
	// 82AB31D0: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AB31D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB31D8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82AB31DC: 81630068  lwz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AB31E0: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	pc = 0x82AB31E4; continue 'dispatch;
            }
            0x82AB31E4 => {
    //   block [0x82AB31E4..0x82AB321C)
	// 82AB31E4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB31E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB31EC: 80E3003C  lwz r7, 0x3c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB31F0: 81230040  lwz r9, 0x40(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82AB31F4: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82AB31F8: 9103003C  stw r8, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 82AB31FC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3200: 396B00F0  addi r11, r11, 0xf0
	ctx.r[11].s64 = ctx.r[11].s64 + 240;
	// 82AB3204: 7CE94214  add r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82AB3208: 90E30040  stw r7, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	// 82AB320C: 80C30038  lwz r6, 0x38(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AB3210: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82AB3214: 4198FFD0  blt cr6, 0x82ab31e4
	if ctx.cr[6].lt {
	pc = 0x82AB31E4; continue 'dispatch;
	}
	// 82AB3218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB3220 size=276
    let mut pc: u32 = 0x82AB3220;
    'dispatch: loop {
        match pc {
            0x82AB3220 => {
    //   block [0x82AB3220..0x82AB3248)
	// 82AB3220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB3224: 481F61DD  bl 0x82ca9400
	ctx.lr = 0x82AB3228;
	sub_82CA93D0(ctx, base);
	// 82AB3228: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB322C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB3230: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 82AB3234: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AB3238: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB323C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB3240: 40990070  ble cr6, 0x82ab32b0
	if !ctx.cr[6].gt {
	pc = 0x82AB32B0; continue 'dispatch;
	}
	// 82AB3244: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82AB3248; continue 'dispatch;
            }
            0x82AB3248 => {
    //   block [0x82AB3248..0x82AB326C)
	// 82AB3248: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB324C: 7D5C5A14  add r10, r28, r11
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82AB3250: 816A003C  lwz r11, 0x3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB3254: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB3258: 41980014  blt cr6, 0x82ab326c
	if ctx.cr[6].lt {
	pc = 0x82AB326C; continue 'dispatch;
	}
	// 82AB325C: 813E0058  lwz r9, 0x58(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB3260: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AB3264: 7FA9402E  lwzx r29, r9, r8
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82AB3268: 48000008  b 0x82ab3270
	pc = 0x82AB3270; continue 'dispatch;
            }
            0x82AB326C => {
    //   block [0x82AB326C..0x82AB3270)
	// 82AB326C: 83BA5760  lwz r29, 0x5760(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(22368 as u32) ) } as u64;
	pc = 0x82AB3270; continue 'dispatch;
            }
            0x82AB3270 => {
    //   block [0x82AB3270..0x82AB32B0)
	// 82AB3270: 3BEA000C  addi r31, r10, 0xc
	ctx.r[31].s64 = ctx.r[10].s64 + 12;
	// 82AB3274: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AB3278: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82AB327C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3280: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AB3284: 48076AFD  bl 0x82b29d80
	ctx.lr = 0x82AB3288;
	sub_82B29D80(ctx, base);
	// 82AB3288: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82AB328C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AB3290: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AB3294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3298: 48076AE9  bl 0x82b29d80
	ctx.lr = 0x82AB329C;
	sub_82B29D80(ctx, base);
	// 82AB329C: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AB32A0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AB32A4: 3B9C00E0  addi r28, r28, 0xe0
	ctx.r[28].s64 = ctx.r[28].s64 + 224;
	// 82AB32A8: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB32AC: 4198FF9C  blt cr6, 0x82ab3248
	if ctx.cr[6].lt {
	pc = 0x82AB3248; continue 'dispatch;
	}
	pc = 0x82AB32B0; continue 'dispatch;
            }
            0x82AB32B0 => {
    //   block [0x82AB32B0..0x82AB32C4)
	// 82AB32B0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB32B4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AB32B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB32BC: 40990070  ble cr6, 0x82ab332c
	if !ctx.cr[6].gt {
	pc = 0x82AB332C; continue 'dispatch;
	}
	// 82AB32C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82AB32C4; continue 'dispatch;
            }
            0x82AB32C4 => {
    //   block [0x82AB32C4..0x82AB32E8)
	// 82AB32C4: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB32C8: 7D4BE214  add r10, r11, r28
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82AB32CC: 816A003C  lwz r11, 0x3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB32D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB32D4: 41980014  blt cr6, 0x82ab32e8
	if ctx.cr[6].lt {
	pc = 0x82AB32E8; continue 'dispatch;
	}
	// 82AB32D8: 813E0058  lwz r9, 0x58(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB32DC: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AB32E0: 7FA8482E  lwzx r29, r8, r9
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AB32E4: 48000008  b 0x82ab32ec
	pc = 0x82AB32EC; continue 'dispatch;
            }
            0x82AB32E8 => {
    //   block [0x82AB32E8..0x82AB32EC)
	// 82AB32E8: 83BA5760  lwz r29, 0x5760(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(22368 as u32) ) } as u64;
	pc = 0x82AB32EC; continue 'dispatch;
            }
            0x82AB32EC => {
    //   block [0x82AB32EC..0x82AB332C)
	// 82AB32EC: 3BEA000C  addi r31, r10, 0xc
	ctx.r[31].s64 = ctx.r[10].s64 + 12;
	// 82AB32F0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AB32F4: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82AB32F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB32FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AB3300: 48076A81  bl 0x82b29d80
	ctx.lr = 0x82AB3304;
	sub_82B29D80(ctx, base);
	// 82AB3304: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82AB3308: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AB330C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AB3310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3314: 48076A6D  bl 0x82b29d80
	ctx.lr = 0x82AB3318;
	sub_82B29D80(ctx, base);
	// 82AB3318: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB331C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82AB3320: 3B9C009C  addi r28, r28, 0x9c
	ctx.r[28].s64 = ctx.r[28].s64 + 156;
	// 82AB3324: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB3328: 4198FF9C  blt cr6, 0x82ab32c4
	if ctx.cr[6].lt {
	pc = 0x82AB32C4; continue 'dispatch;
	}
	pc = 0x82AB332C; continue 'dispatch;
            }
            0x82AB332C => {
    //   block [0x82AB332C..0x82AB3334)
	// 82AB332C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB3330: 481F6120  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AB3338 size=1188
    let mut pc: u32 = 0x82AB3338;
    'dispatch: loop {
        match pc {
            0x82AB3338 => {
    //   block [0x82AB3338..0x82AB33A0)
	// 82AB3338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB333C: 481F60CD  bl 0x82ca9408
	ctx.lr = 0x82AB3340;
	sub_82CA93D0(ctx, base);
	// 82AB3340: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB3344: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AB3348: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AB334C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB3350: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB3354: 4198004C  blt cr6, 0x82ab33a0
	if ctx.cr[6].lt {
	pc = 0x82AB33A0; continue 'dispatch;
	}
	// 82AB3358: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB335C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB3360: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82AB3364: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3368: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB336C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB3370: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3374: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB3378: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB337C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB3380: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB3384: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB3388: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB338C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB3390: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB3394: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB3398: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB339C: 48000014  b 0x82ab33b0
	pc = 0x82AB33B0; continue 'dispatch;
            }
            0x82AB33A0 => {
    //   block [0x82AB33A0..0x82AB33B0)
	// 82AB33A0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB33A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AB33A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB33AC: 4BF6DB3D  bl 0x82a20ee8
	ctx.lr = 0x82AB33B0;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB33B0; continue 'dispatch;
            }
            0x82AB33B0 => {
    //   block [0x82AB33B0..0x82AB33E4)
	// 82AB33B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB33B4: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB33B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB33BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AB33C0: 419A0024  beq cr6, 0x82ab33e4
	if ctx.cr[6].eq {
	pc = 0x82AB33E4; continue 'dispatch;
	}
	// 82AB33C4: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AB33C8: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AB33CC: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82AB33D0: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB33D4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AB33D8: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82AB33DC: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82AB33E0: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB33E4; continue 'dispatch;
            }
            0x82AB33E4 => {
    //   block [0x82AB33E4..0x82AB3440)
	// 82AB33E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB33E8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AB33EC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB33F0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB33F4: 4198004C  blt cr6, 0x82ab3440
	if ctx.cr[6].lt {
	pc = 0x82AB3440; continue 'dispatch;
	}
	// 82AB33F8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB33FC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB3400: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82AB3404: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3408: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB340C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB3410: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3414: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB3418: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB341C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB3420: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB3424: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB3428: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB342C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB3430: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB3434: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB3438: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB343C: 48000014  b 0x82ab3450
	pc = 0x82AB3450; continue 'dispatch;
            }
            0x82AB3440 => {
    //   block [0x82AB3440..0x82AB3450)
	// 82AB3440: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB3444: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AB3448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB344C: 4BF6DA9D  bl 0x82a20ee8
	ctx.lr = 0x82AB3450;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB3450; continue 'dispatch;
            }
            0x82AB3450 => {
    //   block [0x82AB3450..0x82AB3484)
	// 82AB3450: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB3454: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB3458: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB345C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AB3460: 419A0024  beq cr6, 0x82ab3484
	if ctx.cr[6].eq {
	pc = 0x82AB3484; continue 'dispatch;
	}
	// 82AB3464: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AB3468: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AB346C: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82AB3470: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB3474: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AB3478: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82AB347C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82AB3480: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB3484; continue 'dispatch;
            }
            0x82AB3484 => {
    //   block [0x82AB3484..0x82AB34E0)
	// 82AB3484: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB3488: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB348C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB3490: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB3494: 4198004C  blt cr6, 0x82ab34e0
	if ctx.cr[6].lt {
	pc = 0x82AB34E0; continue 'dispatch;
	}
	// 82AB3498: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB349C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB34A0: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
	// 82AB34A4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB34A8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB34AC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB34B0: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB34B4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB34B8: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB34BC: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB34C0: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB34C4: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB34C8: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB34CC: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB34D0: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB34D4: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB34D8: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB34DC: 48000014  b 0x82ab34f0
	pc = 0x82AB34F0; continue 'dispatch;
            }
            0x82AB34E0 => {
    //   block [0x82AB34E0..0x82AB34F0)
	// 82AB34E0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB34E4: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82AB34E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB34EC: 4BF6D9FD  bl 0x82a20ee8
	ctx.lr = 0x82AB34F0;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB34F0; continue 'dispatch;
            }
            0x82AB34F0 => {
    //   block [0x82AB34F0..0x82AB3524)
	// 82AB34F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB34F4: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB34F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB34FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AB3500: 419A0024  beq cr6, 0x82ab3524
	if ctx.cr[6].eq {
	pc = 0x82AB3524; continue 'dispatch;
	}
	// 82AB3504: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AB3508: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AB350C: 8921005F  lbz r9, 0x5f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82AB3510: 8901005C  lbz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB3514: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AB3518: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82AB351C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82AB3520: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB3524; continue 'dispatch;
            }
            0x82AB3524 => {
    //   block [0x82AB3524..0x82AB3580)
	// 82AB3524: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB3528: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB352C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB3530: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB3534: 4198004C  blt cr6, 0x82ab3580
	if ctx.cr[6].lt {
	pc = 0x82AB3580; continue 'dispatch;
	}
	// 82AB3538: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB353C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB3540: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82AB3544: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3548: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB354C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB3550: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3554: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB3558: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB355C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB3560: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB3564: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB3568: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB356C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB3570: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB3574: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB3578: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB357C: 48000014  b 0x82ab3590
	pc = 0x82AB3590; continue 'dispatch;
            }
            0x82AB3580 => {
    //   block [0x82AB3580..0x82AB3590)
	// 82AB3580: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB3584: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AB3588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB358C: 4BF6D95D  bl 0x82a20ee8
	ctx.lr = 0x82AB3590;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB3590; continue 'dispatch;
            }
            0x82AB3590 => {
    //   block [0x82AB3590..0x82AB35C4)
	// 82AB3590: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB3594: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB3598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB359C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AB35A0: 419A0024  beq cr6, 0x82ab35c4
	if ctx.cr[6].eq {
	pc = 0x82AB35C4; continue 'dispatch;
	}
	// 82AB35A4: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AB35A8: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AB35AC: 89210063  lbz r9, 0x63(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(99 as u32) ) } as u64;
	// 82AB35B0: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB35B4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AB35B8: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82AB35BC: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82AB35C0: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB35C4; continue 'dispatch;
            }
            0x82AB35C4 => {
    //   block [0x82AB35C4..0x82AB3620)
	// 82AB35C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB35C8: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AB35CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB35D0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB35D4: 4198004C  blt cr6, 0x82ab3620
	if ctx.cr[6].lt {
	pc = 0x82AB3620; continue 'dispatch;
	}
	// 82AB35D8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB35DC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB35E0: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 82AB35E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB35E8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB35EC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB35F0: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB35F4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB35F8: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB35FC: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB3600: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB3604: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB3608: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB360C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB3610: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB3614: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB3618: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB361C: 48000014  b 0x82ab3630
	pc = 0x82AB3630; continue 'dispatch;
            }
            0x82AB3620 => {
    //   block [0x82AB3620..0x82AB3630)
	// 82AB3620: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB3624: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82AB3628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB362C: 4BF6D8BD  bl 0x82a20ee8
	ctx.lr = 0x82AB3630;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB3630; continue 'dispatch;
            }
            0x82AB3630 => {
    //   block [0x82AB3630..0x82AB3664)
	// 82AB3630: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB3634: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB3638: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB363C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AB3640: 419A0024  beq cr6, 0x82ab3664
	if ctx.cr[6].eq {
	pc = 0x82AB3664; continue 'dispatch;
	}
	// 82AB3644: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AB3648: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AB364C: 89210067  lbz r9, 0x67(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(103 as u32) ) } as u64;
	// 82AB3650: 89010064  lbz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB3654: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AB3658: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82AB365C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82AB3660: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB3664; continue 'dispatch;
            }
            0x82AB3664 => {
    //   block [0x82AB3664..0x82AB36C4)
	// 82AB3664: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB3668: 3B9E0014  addi r28, r30, 0x14
	ctx.r[28].s64 = ctx.r[30].s64 + 20;
	// 82AB366C: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82AB3670: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB3674: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB3678: 4198004C  blt cr6, 0x82ab36c4
	if ctx.cr[6].lt {
	pc = 0x82AB36C4; continue 'dispatch;
	}
	// 82AB367C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB3680: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB3684: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 82AB3688: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB368C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB3690: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB3694: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3698: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB369C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB36A0: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB36A4: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB36A8: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB36AC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB36B0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB36B4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB36B8: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB36BC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB36C0: 48000014  b 0x82ab36d4
	pc = 0x82AB36D4; continue 'dispatch;
            }
            0x82AB36C4 => {
    //   block [0x82AB36C4..0x82AB36D4)
	// 82AB36C4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB36C8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82AB36CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB36D0: 4BF6D819  bl 0x82a20ee8
	ctx.lr = 0x82AB36D4;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB36D4; continue 'dispatch;
            }
            0x82AB36D4 => {
    //   block [0x82AB36D4..0x82AB370C)
	// 82AB36D4: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AB36D8: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB36DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB36E0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AB36E4: 419A0028  beq cr6, 0x82ab370c
	if ctx.cr[6].eq {
	pc = 0x82AB370C; continue 'dispatch;
	}
	// 82AB36E8: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AB36EC: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AB36F0: 8921006B  lbz r9, 0x6b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(107 as u32) ) } as u64;
	// 82AB36F4: 89010068  lbz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AB36F8: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82AB36FC: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82AB3700: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82AB3704: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	// 82AB3708: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82AB370C; continue 'dispatch;
            }
            0x82AB370C => {
    //   block [0x82AB370C..0x82AB3724)
	// 82AB370C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB3710: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB3714: 480000CD  bl 0x82ab37e0
	ctx.lr = 0x82AB3718;
	sub_82AB37E0(ctx, base);
	// 82AB3718: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB371C: 409900B8  ble cr6, 0x82ab37d4
	if !ctx.cr[6].gt {
	pc = 0x82AB37D4; continue 'dispatch;
	}
	// 82AB3720: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82AB3724; continue 'dispatch;
            }
            0x82AB3724 => {
    //   block [0x82AB3724..0x82AB3778)
	// 82AB3724: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB3728: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB372C: 4198004C  blt cr6, 0x82ab3778
	if ctx.cr[6].lt {
	pc = 0x82AB3778; continue 'dispatch;
	}
	// 82AB3730: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB3734: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB3738: 3901006C  addi r8, r1, 0x6c
	ctx.r[8].s64 = ctx.r[1].s64 + 108;
	// 82AB373C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3740: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB3744: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB3748: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB374C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB3750: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB3754: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB3758: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB375C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB3760: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB3764: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB3768: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB376C: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB3770: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB3774: 48000014  b 0x82ab3788
	pc = 0x82AB3788; continue 'dispatch;
            }
            0x82AB3778 => {
    //   block [0x82AB3778..0x82AB3788)
	// 82AB3778: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB377C: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82AB3780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3784: 4BF6D765  bl 0x82a20ee8
	ctx.lr = 0x82AB3788;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB3788; continue 'dispatch;
            }
            0x82AB3788 => {
    //   block [0x82AB3788..0x82AB37BC)
	// 82AB3788: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB378C: C001006C  lfs f0, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB3790: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AB3794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3798: 419A0024  beq cr6, 0x82ab37bc
	if ctx.cr[6].eq {
	pc = 0x82AB37BC; continue 'dispatch;
	}
	// 82AB379C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB37A0: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82AB37A4: 89210053  lbz r9, 0x53(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 82AB37A8: 89010052  lbz r8, 0x52(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82AB37AC: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82AB37B0: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82AB37B4: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82AB37B8: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB37BC; continue 'dispatch;
            }
            0x82AB37BC => {
    //   block [0x82AB37BC..0x82AB37D4)
	// 82AB37BC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB37C0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB37C4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB37C8: 7C1D5D2E  stfsx f0, r29, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82AB37CC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82AB37D0: 4082FF54  bne 0x82ab3724
	if !ctx.cr[0].eq {
	pc = 0x82AB3724; continue 'dispatch;
	}
	pc = 0x82AB37D4; continue 'dispatch;
            }
            0x82AB37D4 => {
    //   block [0x82AB37D4..0x82AB37DC)
	// 82AB37D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB37D8: 481F5C80  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB37E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AB37E0 size=168
    let mut pc: u32 = 0x82AB37E0;
    'dispatch: loop {
        match pc {
            0x82AB37E0 => {
    //   block [0x82AB37E0..0x82AB383C)
	// 82AB37E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB37E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB37E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AB37EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB37F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB37F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB37F8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82AB37FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3800: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB3804: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB3808: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AB380C: 7D0A2850  subf r8, r10, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82AB3810: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82AB3814: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB3818: 40990024  ble cr6, 0x82ab383c
	if !ctx.cr[6].gt {
	pc = 0x82AB383C; continue 'dispatch;
	}
	// 82AB381C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB3820: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82AB3824: 7CAB2050  subf r5, r11, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82AB3828: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AB382C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AB3830: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AB3834: 4BF5BCC5  bl 0x82a0f4f8
	ctx.lr = 0x82AB3838;
	sub_82A0F4F8(ctx, base);
	// 82AB3838: 48000038  b 0x82ab3870
	pc = 0x82AB3870; continue 'dispatch;
            }
            0x82AB383C => {
    //   block [0x82AB383C..0x82AB386C)
	// 82AB383C: 40980034  bge cr6, 0x82ab3870
	if !ctx.cr[6].lt {
	pc = 0x82AB3870; continue 'dispatch;
	}
	// 82AB3840: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB3844: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB3848: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82AB384C: 419A0024  beq cr6, 0x82ab3870
	if ctx.cr[6].eq {
	pc = 0x82AB3870; continue 'dispatch;
	}
	// 82AB3850: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 82AB3854: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB3858: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82AB385C: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82AB3860: 4081000C  ble 0x82ab386c
	if !ctx.cr[0].gt {
	pc = 0x82AB386C; continue 'dispatch;
	}
	// 82AB3864: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82AB3868: 481F67C1  bl 0x82caa028
	ctx.lr = 0x82AB386C;
	sub_82CAA028(ctx, base);
	pc = 0x82AB386C; continue 'dispatch;
            }
            0x82AB386C => {
    //   block [0x82AB386C..0x82AB3870)
	// 82AB386C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82AB3870; continue 'dispatch;
            }
            0x82AB3870 => {
    //   block [0x82AB3870..0x82AB3888)
	// 82AB3870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB3874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB3878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB387C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AB3880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB3884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB3888 size=452
    let mut pc: u32 = 0x82AB3888;
    'dispatch: loop {
        match pc {
            0x82AB3888 => {
    //   block [0x82AB3888..0x82AB38CC)
	// 82AB3888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB388C: 481F5B7D  bl 0x82ca9408
	ctx.lr = 0x82AB3890;
	sub_82CA93D0(ctx, base);
	// 82AB3890: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB3894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB3898: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AB389C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AB38A0: 419A01A0  beq cr6, 0x82ab3a40
	if ctx.cr[6].eq {
	pc = 0x82AB3A40; continue 'dispatch;
	}
	// 82AB38A4: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB38A8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB38AC: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 82AB38B0: 7D681671  srawi. r8, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82AB38B4: 40820018  bne 0x82ab38cc
	if !ctx.cr[0].eq {
	pc = 0x82AB38CC; continue 'dispatch;
	}
	// 82AB38B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB38BC: 4B97F9B5  bl 0x82433270
	ctx.lr = 0x82AB38C0;
	sub_82433270(ctx, base);
	// 82AB38C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB38C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB38C8: 481F5B90  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB38CC => {
    //   block [0x82AB38CC..0x82AB3928)
	// 82AB38CC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB38D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB38D4: 7D4B2050  subf r10, r11, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82AB38D8: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82AB38DC: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB38E0: 41990048  bgt cr6, 0x82ab3928
	if ctx.cr[6].gt {
	pc = 0x82AB3928; continue 'dispatch;
	}
	// 82AB38E4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82AB38E8: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82AB38EC: 4B6BDD55  bl 0x82171640
	ctx.lr = 0x82AB38F0;
	sub_82171640(ctx, base);
	// 82AB38F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AB38F4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB38F8: 4B821291  bl 0x822d4b88
	ctx.lr = 0x82AB38FC;
	sub_822D4B88(ctx, base);
	// 82AB38FC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB3900: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3908: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB390C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AB3910: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82AB3914: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB3918: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AB391C: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82AB3920: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB3924: 481F5B34  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB3928 => {
    //   block [0x82AB3928..0x82AB393C)
	// 82AB3928: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AB392C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3930: 409A000C  bne cr6, 0x82ab393c
	if !ctx.cr[6].eq {
	pc = 0x82AB393C; continue 'dispatch;
	}
	// 82AB3934: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82AB3938: 48000010  b 0x82ab3948
	pc = 0x82AB3948; continue 'dispatch;
            }
            0x82AB393C => {
    //   block [0x82AB393C..0x82AB3948)
	// 82AB393C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB3940: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB3944: 7CE91670  srawi r9, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 2) as i64;
	pc = 0x82AB3948; continue 'dispatch;
            }
            0x82AB3948 => {
    //   block [0x82AB3948..0x82AB3978)
	// 82AB3948: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB394C: 41990060  bgt cr6, 0x82ab39ac
	if ctx.cr[6].gt {
	pc = 0x82AB39AC; continue 'dispatch;
	}
	// 82AB3950: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3954: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB3958: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82AB395C: 7FCA1A14  add r30, r10, r3
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82AB3960: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB3964: 4B6BDCDD  bl 0x82171640
	ctx.lr = 0x82AB3968;
	sub_82171640(ctx, base);
	// 82AB3968: 839D0008  lwz r28, 8(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB396C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB3970: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB3974: 419A00C8  beq cr6, 0x82ab3a3c
	if ctx.cr[6].eq {
	pc = 0x82AB3A3C; continue 'dispatch;
	}
	pc = 0x82AB3978; continue 'dispatch;
            }
            0x82AB3978 => {
    //   block [0x82AB3978..0x82AB398C)
	// 82AB3978: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AB397C: 419A0010  beq cr6, 0x82ab398c
	if ctx.cr[6].eq {
	pc = 0x82AB398C; continue 'dispatch;
	}
	// 82AB3980: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB3984: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB3988: 4B73C8B9  bl 0x821f0240
	ctx.lr = 0x82AB398C;
	sub_821F0240(ctx, base);
	pc = 0x82AB398C; continue 'dispatch;
            }
            0x82AB398C => {
    //   block [0x82AB398C..0x82AB39AC)
	// 82AB398C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AB3990: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82AB3994: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB3998: 409AFFE0  bne cr6, 0x82ab3978
	if !ctx.cr[6].eq {
	pc = 0x82AB3978; continue 'dispatch;
	}
	// 82AB399C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82AB39A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB39A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB39A8: 481F5AB0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB39AC => {
    //   block [0x82AB39AC..0x82AB39C8)
	// 82AB39AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB39B0: 419A0018  beq cr6, 0x82ab39c8
	if ctx.cr[6].eq {
	pc = 0x82AB39C8; continue 'dispatch;
	}
	// 82AB39B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AB39B8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB39BC: 4B8211CD  bl 0x822d4b88
	ctx.lr = 0x82AB39C0;
	sub_822D4B88(ctx, base);
	// 82AB39C0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB39C4: 4B768375  bl 0x8221bd38
	ctx.lr = 0x82AB39C8;
	sub_8221BD38(ctx, base);
	pc = 0x82AB39C8; continue 'dispatch;
            }
            0x82AB39C8 => {
    //   block [0x82AB39C8..0x82AB39F0)
	// 82AB39C8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB39CC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB39D0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AB39D4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB39D8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AB39DC: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AB39E0: 7D241671  srawi. r4, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82AB39E4: 4082000C  bne 0x82ab39f0
	if !ctx.cr[0].eq {
	pc = 0x82AB39F0; continue 'dispatch;
	}
	// 82AB39E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB39EC: 4800000C  b 0x82ab39f8
	pc = 0x82AB39F8; continue 'dispatch;
            }
            0x82AB39F0 => {
    //   block [0x82AB39F0..0x82AB39F8)
	// 82AB39F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB39F4: 4B86DA65  bl 0x82321458
	ctx.lr = 0x82AB39F8;
	sub_82321458(ctx, base);
	pc = 0x82AB39F8; continue 'dispatch;
            }
            0x82AB39F8 => {
    //   block [0x82AB39F8..0x82AB3A18)
	// 82AB39F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB39FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3A00: 419A0040  beq cr6, 0x82ab3a40
	if ctx.cr[6].eq {
	pc = 0x82AB3A40; continue 'dispatch;
	}
	// 82AB3A04: 839D0008  lwz r28, 8(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB3A08: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3A0C: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3A10: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB3A14: 419A0028  beq cr6, 0x82ab3a3c
	if ctx.cr[6].eq {
	pc = 0x82AB3A3C; continue 'dispatch;
	}
	pc = 0x82AB3A18; continue 'dispatch;
            }
            0x82AB3A18 => {
    //   block [0x82AB3A18..0x82AB3A2C)
	// 82AB3A18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AB3A1C: 419A0010  beq cr6, 0x82ab3a2c
	if ctx.cr[6].eq {
	pc = 0x82AB3A2C; continue 'dispatch;
	}
	// 82AB3A20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB3A24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB3A28: 4B73C819  bl 0x821f0240
	ctx.lr = 0x82AB3A2C;
	sub_821F0240(ctx, base);
	pc = 0x82AB3A2C; continue 'dispatch;
            }
            0x82AB3A2C => {
    //   block [0x82AB3A2C..0x82AB3A3C)
	// 82AB3A2C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AB3A30: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82AB3A34: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB3A38: 409AFFE0  bne cr6, 0x82ab3a18
	if !ctx.cr[6].eq {
	pc = 0x82AB3A18; continue 'dispatch;
	}
	pc = 0x82AB3A3C; continue 'dispatch;
            }
            0x82AB3A3C => {
    //   block [0x82AB3A3C..0x82AB3A40)
	// 82AB3A3C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x82AB3A40; continue 'dispatch;
            }
            0x82AB3A40 => {
    //   block [0x82AB3A40..0x82AB3A4C)
	// 82AB3A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3A44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB3A48: 481F5A10  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB3A50 size=104
    let mut pc: u32 = 0x82AB3A50;
    'dispatch: loop {
        match pc {
            0x82AB3A50 => {
    //   block [0x82AB3A50..0x82AB3AB8)
	// 82AB3A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB3A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB3A58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB3A5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB3A60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB3A64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AB3A68: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AB3A6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB3A70: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AB3A74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3A78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3A7C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AB3A80: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB3A84: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AB3A88: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AB3A8C: 480003FD  bl 0x82ab3e88
	ctx.lr = 0x82AB3A90;
	sub_82AB3E88(ctx, base);
	// 82AB3A90: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3A94: 4B7682A5  bl 0x8221bd38
	ctx.lr = 0x82AB3A98;
	sub_8221BD38(ctx, base);
	// 82AB3A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB3A9C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB3AA0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB3AA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB3AA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB3AAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB3AB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB3AB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB3AB8 size=288
    let mut pc: u32 = 0x82AB3AB8;
    'dispatch: loop {
        match pc {
            0x82AB3AB8 => {
    //   block [0x82AB3AB8..0x82AB3AE4)
	// 82AB3AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB3ABC: 481F594D  bl 0x82ca9408
	ctx.lr = 0x82AB3AC0;
	sub_82CA93D0(ctx, base);
	// 82AB3AC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB3AC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB3AC8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AB3ACC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AB3AD0: 4B855239  bl 0x82308d08
	ctx.lr = 0x82AB3AD4;
	sub_82308D08(ctx, base);
	// 82AB3AD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB3AD8: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82AB3ADC: 409A0008  bne cr6, 0x82ab3ae4
	if !ctx.cr[6].eq {
	pc = 0x82AB3AE4; continue 'dispatch;
	}
	// 82AB3AE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3AE4; continue 'dispatch;
            }
            0x82AB3AE4 => {
    //   block [0x82AB3AE4..0x82AB3B18)
	// 82AB3AE4: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3AE8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AB3AEC: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB3AF0: 419A0028  beq cr6, 0x82ab3b18
	if ctx.cr[6].eq {
	pc = 0x82AB3B18; continue 'dispatch;
	}
	// 82AB3AF4: 38A3000C  addi r5, r3, 0xc
	ctx.r[5].s64 = ctx.r[3].s64 + 12;
	// 82AB3AF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AB3AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3B00: 4BD1F4D9  bl 0x827d2fd8
	ctx.lr = 0x82AB3B04;
	sub_827D2FD8(ctx, base);
	// 82AB3B04: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB3B08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3B0C: 409A000C  bne cr6, 0x82ab3b18
	if !ctx.cr[6].eq {
	pc = 0x82AB3B18; continue 'dispatch;
	}
	// 82AB3B10: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82AB3B14: 48000010  b 0x82ab3b24
	pc = 0x82AB3B24; continue 'dispatch;
            }
            0x82AB3B18 => {
    //   block [0x82AB3B18..0x82AB3B24)
	// 82AB3B18: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82AB3B1C: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82AB3B20: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x82AB3B24; continue 'dispatch;
            }
            0x82AB3B24 => {
    //   block [0x82AB3B24..0x82AB3B40)
	// 82AB3B24: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AB3B28: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82AB3B2C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB3B30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB3B34: 419A000C  beq cr6, 0x82ab3b40
	if ctx.cr[6].eq {
	pc = 0x82AB3B40; continue 'dispatch;
	}
	// 82AB3B38: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AB3B3C: 419A0008  beq cr6, 0x82ab3b44
	if ctx.cr[6].eq {
	pc = 0x82AB3B44; continue 'dispatch;
	}
	pc = 0x82AB3B40; continue 'dispatch;
            }
            0x82AB3B40 => {
    //   block [0x82AB3B40..0x82AB3B44)
	// 82AB3B40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3B44; continue 'dispatch;
            }
            0x82AB3B44 => {
    //   block [0x82AB3B44..0x82AB3BB0)
	// 82AB3B44: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB3B48: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB3B4C: 409A0064  bne cr6, 0x82ab3bb0
	if !ctx.cr[6].eq {
	pc = 0x82AB3BB0; continue 'dispatch;
	}
	// 82AB3B50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AB3B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB3B58: 4B73C6E9  bl 0x821f0240
	ctx.lr = 0x82AB3B5C;
	sub_821F0240(ctx, base);
	// 82AB3B5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB3B60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AB3B64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB3B68: 4B73C6D9  bl 0x821f0240
	ctx.lr = 0x82AB3B6C;
	sub_821F0240(ctx, base);
	// 82AB3B6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB3B70: 9B810064  stb r28, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u8 ) };
	// 82AB3B74: 4B761265  bl 0x82214dd8
	ctx.lr = 0x82AB3B78;
	sub_82214DD8(ctx, base);
	// 82AB3B78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AB3B7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AB3B80: 4B73C6C1  bl 0x821f0240
	ctx.lr = 0x82AB3B84;
	sub_821F0240(ctx, base);
	// 82AB3B84: 9B81005C  stb r28, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u8 ) };
	// 82AB3B88: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AB3B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB3B90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AB3B94: 4800016D  bl 0x82ab3d00
	ctx.lr = 0x82AB3B98;
	sub_82AB3D00(ctx, base);
	// 82AB3B98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AB3B9C: 4B76123D  bl 0x82214dd8
	ctx.lr = 0x82AB3BA0;
	sub_82214DD8(ctx, base);
	// 82AB3BA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AB3BA4: 4B761235  bl 0x82214dd8
	ctx.lr = 0x82AB3BA8;
	sub_82214DD8(ctx, base);
	// 82AB3BA8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB3BAC: 481F58AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB3BB0 => {
    //   block [0x82AB3BB0..0x82AB3BBC)
	// 82AB3BB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB3BB4: 409A0008  bne cr6, 0x82ab3bbc
	if !ctx.cr[6].eq {
	pc = 0x82AB3BBC; continue 'dispatch;
	}
	// 82AB3BB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3BBC; continue 'dispatch;
            }
            0x82AB3BBC => {
    //   block [0x82AB3BBC..0x82AB3BCC)
	// 82AB3BBC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3BC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB3BC4: 409A0008  bne cr6, 0x82ab3bcc
	if !ctx.cr[6].eq {
	pc = 0x82AB3BCC; continue 'dispatch;
	}
	// 82AB3BC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3BCC; continue 'dispatch;
            }
            0x82AB3BCC => {
    //   block [0x82AB3BCC..0x82AB3BD8)
	// 82AB3BCC: 9B8B0010  stb r28, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[28].u8 ) };
	// 82AB3BD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB3BD4: 481F5884  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB3BD8 size=292
    let mut pc: u32 = 0x82AB3BD8;
    'dispatch: loop {
        match pc {
            0x82AB3BD8 => {
    //   block [0x82AB3BD8..0x82AB3C00)
	// 82AB3BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB3BDC: 481F5831  bl 0x82ca940c
	ctx.lr = 0x82AB3BE0;
	sub_82CA93D0(ctx, base);
	// 82AB3BE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB3BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB3BE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AB3BEC: 4B85511D  bl 0x82308d08
	ctx.lr = 0x82AB3BF0;
	sub_82308D08(ctx, base);
	// 82AB3BF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB3BF4: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82AB3BF8: 409A0008  bne cr6, 0x82ab3c00
	if !ctx.cr[6].eq {
	pc = 0x82AB3C00; continue 'dispatch;
	}
	// 82AB3BFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3C00; continue 'dispatch;
            }
            0x82AB3C00 => {
    //   block [0x82AB3C00..0x82AB3C34)
	// 82AB3C00: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3C04: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AB3C08: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB3C0C: 419A0028  beq cr6, 0x82ab3c34
	if ctx.cr[6].eq {
	pc = 0x82AB3C34; continue 'dispatch;
	}
	// 82AB3C10: 38A3000C  addi r5, r3, 0xc
	ctx.r[5].s64 = ctx.r[3].s64 + 12;
	// 82AB3C14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AB3C18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3C1C: 4BD1F3BD  bl 0x827d2fd8
	ctx.lr = 0x82AB3C20;
	sub_827D2FD8(ctx, base);
	// 82AB3C20: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB3C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3C28: 409A000C  bne cr6, 0x82ab3c34
	if !ctx.cr[6].eq {
	pc = 0x82AB3C34; continue 'dispatch;
	}
	// 82AB3C2C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82AB3C30: 48000010  b 0x82ab3c40
	pc = 0x82AB3C40; continue 'dispatch;
            }
            0x82AB3C34 => {
    //   block [0x82AB3C34..0x82AB3C40)
	// 82AB3C34: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82AB3C38: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82AB3C3C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x82AB3C40; continue 'dispatch;
            }
            0x82AB3C40 => {
    //   block [0x82AB3C40..0x82AB3C5C)
	// 82AB3C40: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82AB3C44: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82AB3C48: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB3C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3C50: 419A000C  beq cr6, 0x82ab3c5c
	if ctx.cr[6].eq {
	pc = 0x82AB3C5C; continue 'dispatch;
	}
	// 82AB3C54: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AB3C58: 419A0008  beq cr6, 0x82ab3c60
	if ctx.cr[6].eq {
	pc = 0x82AB3C60; continue 'dispatch;
	}
	pc = 0x82AB3C5C; continue 'dispatch;
            }
            0x82AB3C5C => {
    //   block [0x82AB3C5C..0x82AB3C60)
	// 82AB3C5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3C60; continue 'dispatch;
            }
            0x82AB3C60 => {
    //   block [0x82AB3C60..0x82AB3CD4)
	// 82AB3C60: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB3C64: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB3C68: 409A006C  bne cr6, 0x82ab3cd4
	if !ctx.cr[6].eq {
	pc = 0x82AB3CD4; continue 'dispatch;
	}
	// 82AB3C6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AB3C70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB3C74: 4B73C5CD  bl 0x821f0240
	ctx.lr = 0x82AB3C78;
	sub_821F0240(ctx, base);
	// 82AB3C78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB3C7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AB3C80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AB3C84: 4B73C5BD  bl 0x821f0240
	ctx.lr = 0x82AB3C88;
	sub_821F0240(ctx, base);
	// 82AB3C88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AB3C8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB3C90: 9BC10064  stb r30, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u8 ) };
	// 82AB3C94: 4B761145  bl 0x82214dd8
	ctx.lr = 0x82AB3C98;
	sub_82214DD8(ctx, base);
	// 82AB3C98: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AB3C9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AB3CA0: 4B73C5A1  bl 0x821f0240
	ctx.lr = 0x82AB3CA4;
	sub_821F0240(ctx, base);
	// 82AB3CA4: 9BC1005C  stb r30, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u8 ) };
	// 82AB3CA8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AB3CAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB3CB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AB3CB4: 4800004D  bl 0x82ab3d00
	ctx.lr = 0x82AB3CB8;
	sub_82AB3D00(ctx, base);
	// 82AB3CB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AB3CBC: 4B76111D  bl 0x82214dd8
	ctx.lr = 0x82AB3CC0;
	sub_82214DD8(ctx, base);
	// 82AB3CC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AB3CC4: 4B761115  bl 0x82214dd8
	ctx.lr = 0x82AB3CC8;
	sub_82214DD8(ctx, base);
	// 82AB3CC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AB3CCC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB3CD0: 481F578C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB3CD4 => {
    //   block [0x82AB3CD4..0x82AB3CE0)
	// 82AB3CD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3CD8: 409A0008  bne cr6, 0x82ab3ce0
	if !ctx.cr[6].eq {
	pc = 0x82AB3CE0; continue 'dispatch;
	}
	// 82AB3CDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3CE0; continue 'dispatch;
            }
            0x82AB3CE0 => {
    //   block [0x82AB3CE0..0x82AB3CF0)
	// 82AB3CE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3CE4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB3CE8: 409A0008  bne cr6, 0x82ab3cf0
	if !ctx.cr[6].eq {
	pc = 0x82AB3CF0; continue 'dispatch;
	}
	// 82AB3CEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3CF0; continue 'dispatch;
            }
            0x82AB3CF0 => {
    //   block [0x82AB3CF0..0x82AB3CFC)
	// 82AB3CF0: 886A0010  lbz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB3CF4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB3CF8: 481F5764  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB3D00 size=388
    let mut pc: u32 = 0x82AB3D00;
    'dispatch: loop {
        match pc {
            0x82AB3D00 => {
    //   block [0x82AB3D00..0x82AB3D38)
	// 82AB3D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB3D04: 481F56F5  bl 0x82ca93f8
	ctx.lr = 0x82AB3D08;
	sub_82CA93D0(ctx, base);
	// 82AB3D08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB3D0C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82AB3D10: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82AB3D14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB3D18: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82AB3D1C: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82AB3D20: 839A0004  lwz r28, 4(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3D24: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3D28: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB3D2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3D30: 409A0078  bne cr6, 0x82ab3da8
	if !ctx.cr[6].eq {
	pc = 0x82AB3DA8; continue 'dispatch;
	}
	// 82AB3D34: 83790000  lwz r27, 0(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AB3D38; continue 'dispatch;
            }
            0x82AB3D38 => {
    //   block [0x82AB3D38..0x82AB3D50)
	// 82AB3D38: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB3D3C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82AB3D40: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82AB3D44: 409A000C  bne cr6, 0x82ab3d50
	if !ctx.cr[6].eq {
	pc = 0x82AB3D50; continue 'dispatch;
	}
	// 82AB3D48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB3D4C: 48000034  b 0x82ab3d80
	pc = 0x82AB3D80; continue 'dispatch;
            }
            0x82AB3D50 => {
    //   block [0x82AB3D50..0x82AB3D60)
	// 82AB3D50: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AB3D54: 409A000C  bne cr6, 0x82ab3d60
	if !ctx.cr[6].eq {
	pc = 0x82AB3D60; continue 'dispatch;
	}
	// 82AB3D58: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82AB3D5C: 48000024  b 0x82ab3d80
	pc = 0x82AB3D80; continue 'dispatch;
            }
            0x82AB3D60 => {
    //   block [0x82AB3D60..0x82AB3D80)
	// 82AB3D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3D64: 419A001C  beq cr6, 0x82ab3d80
	if ctx.cr[6].eq {
	pc = 0x82AB3D80; continue 'dispatch;
	}
	// 82AB3D68: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3D6C: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3D70: 4B7B9A89  bl 0x8226d7f8
	ctx.lr = 0x82AB3D74;
	sub_8226D7F8(ctx, base);
	// 82AB3D74: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82AB3D78: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AB3D7C: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x82AB3D80; continue 'dispatch;
            }
            0x82AB3D80 => {
    //   block [0x82AB3D80..0x82AB3D98)
	// 82AB3D80: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AB3D84: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82AB3D88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB3D8C: 419A000C  beq cr6, 0x82ab3d98
	if ctx.cr[6].eq {
	pc = 0x82AB3D98; continue 'dispatch;
	}
	// 82AB3D90: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3D94: 48000008  b 0x82ab3d9c
	pc = 0x82AB3D9C; continue 'dispatch;
            }
            0x82AB3D98 => {
    //   block [0x82AB3D98..0x82AB3D9C)
	// 82AB3D98: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AB3D9C; continue 'dispatch;
            }
            0x82AB3D9C => {
    //   block [0x82AB3D9C..0x82AB3DA8)
	// 82AB3D9C: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB3DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3DA4: 419AFF94  beq cr6, 0x82ab3d38
	if ctx.cr[6].eq {
	pc = 0x82AB3D38; continue 'dispatch;
	}
	pc = 0x82AB3DA8; continue 'dispatch;
            }
            0x82AB3DA8 => {
    //   block [0x82AB3DA8..0x82AB3E08)
	// 82AB3DA8: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82AB3DAC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82AB3DB0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82AB3DB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3DB8: 419A0054  beq cr6, 0x82ab3e0c
	if ctx.cr[6].eq {
	pc = 0x82AB3E0C; continue 'dispatch;
	}
	// 82AB3DBC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3DC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB3DC4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3DC8: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB3DCC: 409A003C  bne cr6, 0x82ab3e08
	if !ctx.cr[6].eq {
	pc = 0x82AB3E08; continue 'dispatch;
	}
	// 82AB3DD0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82AB3DD4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82AB3DD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AB3DDC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AB3DE0: 4B6DA299  bl 0x8218e078
	ctx.lr = 0x82AB3DE4;
	sub_8218E078(ctx, base);
	// 82AB3DE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AB3DE8: 9B1D0008  stb r24, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[24].u8 ) };
	// 82AB3DEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB3DF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3DF4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3DF8: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB3DFC: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AB3E00: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB3E04: 481F5644  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB3E08 => {
    //   block [0x82AB3E08..0x82AB3E0C)
	// 82AB3E08: 480006F1  bl 0x82ab44f8
	ctx.lr = 0x82AB3E0C;
	sub_82AB44F8(ctx, base);
	pc = 0x82AB3E0C; continue 'dispatch;
            }
            0x82AB3E0C => {
    //   block [0x82AB3E0C..0x82AB3E68)
	// 82AB3E0C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB3E10: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82AB3E14: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AB3E18: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82AB3E1C: 4BD1F1BD  bl 0x827d2fd8
	ctx.lr = 0x82AB3E20;
	sub_827D2FD8(ctx, base);
	// 82AB3E20: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB3E24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB3E28: 419A0040  beq cr6, 0x82ab3e68
	if ctx.cr[6].eq {
	pc = 0x82AB3E68; continue 'dispatch;
	}
	// 82AB3E2C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82AB3E30: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82AB3E34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AB3E38: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AB3E3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB3E40: 4B6DA239  bl 0x8218e078
	ctx.lr = 0x82AB3E44;
	sub_8218E078(ctx, base);
	// 82AB3E44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AB3E48: 9B1D0008  stb r24, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[24].u8 ) };
	// 82AB3E4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB3E50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3E54: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3E58: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB3E5C: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AB3E60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB3E64: 481F55E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB3E68 => {
    //   block [0x82AB3E68..0x82AB3E84)
	// 82AB3E68: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB3E6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB3E70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB3E74: 995D0008  stb r10, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82AB3E78: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AB3E7C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB3E80: 481F55C8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB3E88 size=268
    let mut pc: u32 = 0x82AB3E88;
    'dispatch: loop {
        match pc {
            0x82AB3E88 => {
    //   block [0x82AB3E88..0x82AB3EC0)
	// 82AB3E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB3E8C: 481F5579  bl 0x82ca9404
	ctx.lr = 0x82AB3E90;
	sub_82CA93D0(ctx, base);
	// 82AB3E90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB3E94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AB3E98: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82AB3E9C: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AB3EA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB3EA4: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82AB3EA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB3EAC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3EB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3EB4: 419A000C  beq cr6, 0x82ab3ec0
	if ctx.cr[6].eq {
	pc = 0x82AB3EC0; continue 'dispatch;
	}
	// 82AB3EB8: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AB3EBC: 419A0008  beq cr6, 0x82ab3ec4
	if ctx.cr[6].eq {
	pc = 0x82AB3EC4; continue 'dispatch;
	}
	pc = 0x82AB3EC0; continue 'dispatch;
            }
            0x82AB3EC0 => {
    //   block [0x82AB3EC0..0x82AB3EC4)
	// 82AB3EC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3EC4; continue 'dispatch;
            }
            0x82AB3EC4 => {
    //   block [0x82AB3EC4..0x82AB3EE8)
	// 82AB3EC4: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AB3EC8: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AB3ECC: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82AB3ED0: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB3ED4: 409A0068  bne cr6, 0x82ab3f3c
	if !ctx.cr[6].eq {
	pc = 0x82AB3F3C; continue 'dispatch;
	}
	// 82AB3ED8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB3EDC: 419A000C  beq cr6, 0x82ab3ee8
	if ctx.cr[6].eq {
	pc = 0x82AB3EE8; continue 'dispatch;
	}
	// 82AB3EE0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AB3EE4: 419A0008  beq cr6, 0x82ab3eec
	if ctx.cr[6].eq {
	pc = 0x82AB3EEC; continue 'dispatch;
	}
	pc = 0x82AB3EE8; continue 'dispatch;
            }
            0x82AB3EE8 => {
    //   block [0x82AB3EE8..0x82AB3EEC)
	// 82AB3EE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3EEC; continue 'dispatch;
            }
            0x82AB3EEC => {
    //   block [0x82AB3EEC..0x82AB3F3C)
	// 82AB3EEC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB3EF0: 409A004C  bne cr6, 0x82ab3f3c
	if !ctx.cr[6].eq {
	pc = 0x82AB3F3C; continue 'dispatch;
	}
	// 82AB3EF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB3EF8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3EFC: 4B818365  bl 0x822cc260
	ctx.lr = 0x82AB3F00;
	sub_822CC260(ctx, base);
	// 82AB3F00: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3F04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB3F08: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AB3F0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB3F10: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AB3F14: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3F18: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB3F1C: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AB3F20: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3F24: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82AB3F28: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB3F2C: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB3F30: 90DD0004  stw r6, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB3F34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB3F38: 481F551C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB3F3C => {
    //   block [0x82AB3F3C..0x82AB3F4C)
	// 82AB3F3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB3F40: 419A000C  beq cr6, 0x82ab3f4c
	if ctx.cr[6].eq {
	pc = 0x82AB3F4C; continue 'dispatch;
	}
	// 82AB3F44: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB3F48: 419A0008  beq cr6, 0x82ab3f50
	if ctx.cr[6].eq {
	pc = 0x82AB3F50; continue 'dispatch;
	}
	pc = 0x82AB3F4C; continue 'dispatch;
            }
            0x82AB3F4C => {
    //   block [0x82AB3F4C..0x82AB3F50)
	// 82AB3F4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB3F50; continue 'dispatch;
            }
            0x82AB3F50 => {
    //   block [0x82AB3F50..0x82AB3F84)
	// 82AB3F50: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AB3F54: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB3F58: 419A002C  beq cr6, 0x82ab3f84
	if ctx.cr[6].eq {
	pc = 0x82AB3F84; continue 'dispatch;
	}
	// 82AB3F5C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AB3F60: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82AB3F64: 4BAA28F5  bl 0x82556858
	ctx.lr = 0x82AB3F68;
	sub_82556858(ctx, base);
	// 82AB3F68: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AB3F6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB3F70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB3F74: 48000025  bl 0x82ab3f98
	ctx.lr = 0x82AB3F78;
	sub_82AB3F98(ctx, base);
	// 82AB3F78: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82AB3F7C: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AB3F80: 4BFFFFBC  b 0x82ab3f3c
	pc = 0x82AB3F3C; continue 'dispatch;
            }
            0x82AB3F84 => {
    //   block [0x82AB3F84..0x82AB3F94)
	// 82AB3F84: F8BD0000  std r5, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82AB3F88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB3F8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB3F90: 481F54C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB3F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB3F98 size=1096
    let mut pc: u32 = 0x82AB3F98;
    'dispatch: loop {
        match pc {
            0x82AB3F98 => {
    //   block [0x82AB3F98..0x82AB4004)
	// 82AB3F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB3F9C: 481F5461  bl 0x82ca93fc
	ctx.lr = 0x82AB3FA0;
	sub_82CA93D0(ctx, base);
	// 82AB3FA0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB3FA4: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82AB3FA8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AB3FAC: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AB3FB0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AB3FB4: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB3FB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB3FBC: 419A0048  beq cr6, 0x82ab4004
	if ctx.cr[6].eq {
	pc = 0x82AB4004; continue 'dispatch;
	}
	// 82AB3FC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AB3FC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB3FC8: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82AB3FCC: 4B83DF75  bl 0x822f1f40
	ctx.lr = 0x82AB3FD0;
	sub_822F1F40(ctx, base);
	// 82AB3FD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AB3FD4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB3FD8: 4B83DDD9  bl 0x822f1db0
	ctx.lr = 0x82AB3FDC;
	sub_822F1DB0(ctx, base);
	// 82AB3FDC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AB3FE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB3FE4: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82AB3FE8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AB3FEC: 4B83DE35  bl 0x822f1e20
	ctx.lr = 0x82AB3FF0;
	sub_822F1E20(ctx, base);
	// 82AB3FF0: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AB3FF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB3FF8: 4BBC77E9  bl 0x8267b7e0
	ctx.lr = 0x82AB3FFC;
	sub_8267B7E0(ctx, base);
	// 82AB3FFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB4000: 4B6BD811  bl 0x82171810
	ctx.lr = 0x82AB4004;
	sub_82171810(ctx, base);
	pc = 0x82AB4004; continue 'dispatch;
            }
            0x82AB4004 => {
    //   block [0x82AB4004..0x82AB4028)
	// 82AB4004: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AB4008: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82AB400C: 4BAA284D  bl 0x82556858
	ctx.lr = 0x82AB4010;
	sub_82556858(ctx, base);
	// 82AB4010: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4014: 896A0015  lbz r11, 0x15(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB401C: 419A000C  beq cr6, 0x82ab4028
	if ctx.cr[6].eq {
	pc = 0x82AB4028; continue 'dispatch;
	}
	// 82AB4020: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4024: 4800002C  b 0x82ab4050
	pc = 0x82AB4050; continue 'dispatch;
            }
            0x82AB4028 => {
    //   block [0x82AB4028..0x82AB4040)
	// 82AB4028: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB402C: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4030: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB4034: 419A000C  beq cr6, 0x82ab4040
	if ctx.cr[6].eq {
	pc = 0x82AB4040; continue 'dispatch;
	}
	// 82AB4038: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82AB403C: 48000014  b 0x82ab4050
	pc = 0x82AB4050; continue 'dispatch;
            }
            0x82AB4040 => {
    //   block [0x82AB4040..0x82AB4050)
	// 82AB4040: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AB4044: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB4048: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB404C: 409A00F0  bne cr6, 0x82ab413c
	if !ctx.cr[6].eq {
	pc = 0x82AB413C; continue 'dispatch;
	}
	pc = 0x82AB4050; continue 'dispatch;
            }
            0x82AB4050 => {
    //   block [0x82AB4050..0x82AB4064)
	// 82AB4050: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4054: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB405C: 409A0008  bne cr6, 0x82ab4064
	if !ctx.cr[6].eq {
	pc = 0x82AB4064; continue 'dispatch;
	}
	// 82AB4060: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82AB4064; continue 'dispatch;
            }
            0x82AB4064 => {
    //   block [0x82AB4064..0x82AB407C)
	// 82AB4064: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4068: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB406C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB4070: 409A000C  bne cr6, 0x82ab407c
	if !ctx.cr[6].eq {
	pc = 0x82AB407C; continue 'dispatch;
	}
	// 82AB4074: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AB4078: 4800001C  b 0x82ab4094
	pc = 0x82AB4094; continue 'dispatch;
            }
            0x82AB407C => {
    //   block [0x82AB407C..0x82AB4090)
	// 82AB407C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4080: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB4084: 409A000C  bne cr6, 0x82ab4090
	if !ctx.cr[6].eq {
	pc = 0x82AB4090; continue 'dispatch;
	}
	// 82AB4088: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82AB408C: 48000008  b 0x82ab4094
	pc = 0x82AB4094; continue 'dispatch;
            }
            0x82AB4090 => {
    //   block [0x82AB4090..0x82AB4094)
	// 82AB4090: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82AB4094; continue 'dispatch;
            }
            0x82AB4094 => {
    //   block [0x82AB4094..0x82AB40B8)
	// 82AB4094: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4098: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB409C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB40A0: 409A0044  bne cr6, 0x82ab40e4
	if !ctx.cr[6].eq {
	pc = 0x82AB40E4; continue 'dispatch;
	}
	// 82AB40A4: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB40A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB40AC: 419A000C  beq cr6, 0x82ab40b8
	if ctx.cr[6].eq {
	pc = 0x82AB40B8; continue 'dispatch;
	}
	// 82AB40B0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82AB40B4: 4800002C  b 0x82ab40e0
	pc = 0x82AB40E0; continue 'dispatch;
            }
            0x82AB40B8 => {
    //   block [0x82AB40B8..0x82AB40CC)
	// 82AB40B8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB40BC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82AB40C0: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB40C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AB40C8: 409A0018  bne cr6, 0x82ab40e0
	if !ctx.cr[6].eq {
	pc = 0x82AB40E0; continue 'dispatch;
	}
	pc = 0x82AB40CC; continue 'dispatch;
            }
            0x82AB40CC => {
    //   block [0x82AB40CC..0x82AB40E0)
	// 82AB40CC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82AB40D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB40D4: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB40D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AB40DC: 419AFFF0  beq cr6, 0x82ab40cc
	if ctx.cr[6].eq {
	pc = 0x82AB40CC; continue 'dispatch;
	}
	pc = 0x82AB40E0; continue 'dispatch;
            }
            0x82AB40E0 => {
    //   block [0x82AB40E0..0x82AB40E4)
	// 82AB40E0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82AB40E4; continue 'dispatch;
            }
            0x82AB40E4 => {
    //   block [0x82AB40E4..0x82AB410C)
	// 82AB40E4: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB40E8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB40EC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB40F0: 409A00E0  bne cr6, 0x82ab41d0
	if !ctx.cr[6].eq {
	pc = 0x82AB41D0; continue 'dispatch;
	}
	// 82AB40F4: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB40F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB40FC: 419A0010  beq cr6, 0x82ab410c
	if ctx.cr[6].eq {
	pc = 0x82AB410C; continue 'dispatch;
	}
	// 82AB4100: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82AB4104: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB4108: 480000C8  b 0x82ab41d0
	pc = 0x82AB41D0; continue 'dispatch;
            }
            0x82AB410C => {
    //   block [0x82AB410C..0x82AB4120)
	// 82AB410C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4110: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82AB4114: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4118: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AB411C: 409A0018  bne cr6, 0x82ab4134
	if !ctx.cr[6].eq {
	pc = 0x82AB4134; continue 'dispatch;
	}
	pc = 0x82AB4120; continue 'dispatch;
            }
            0x82AB4120 => {
    //   block [0x82AB4120..0x82AB4134)
	// 82AB4120: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82AB4124: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4128: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB412C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AB4130: 419AFFF0  beq cr6, 0x82ab4120
	if ctx.cr[6].eq {
	pc = 0x82AB4120; continue 'dispatch;
	}
	pc = 0x82AB4134; continue 'dispatch;
            }
            0x82AB4134 => {
    //   block [0x82AB4134..0x82AB413C)
	// 82AB4134: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB4138: 48000098  b 0x82ab41d0
	pc = 0x82AB41D0; continue 'dispatch;
            }
            0x82AB413C => {
    //   block [0x82AB413C..0x82AB415C)
	// 82AB413C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB4140: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4144: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB4148: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB414C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB4150: 409A000C  bne cr6, 0x82ab415c
	if !ctx.cr[6].eq {
	pc = 0x82AB415C; continue 'dispatch;
	}
	// 82AB4154: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82AB4158: 4800002C  b 0x82ab4184
	pc = 0x82AB4184; continue 'dispatch;
            }
            0x82AB415C => {
    //   block [0x82AB415C..0x82AB4170)
	// 82AB415C: 895C0015  lbz r10, 0x15(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4160: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4164: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB4168: 409A0008  bne cr6, 0x82ab4170
	if !ctx.cr[6].eq {
	pc = 0x82AB4170; continue 'dispatch;
	}
	// 82AB416C: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82AB4170; continue 'dispatch;
            }
            0x82AB4170 => {
    //   block [0x82AB4170..0x82AB4184)
	// 82AB4170: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82AB4174: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4178: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB417C: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4180: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB4184; continue 'dispatch;
            }
            0x82AB4184 => {
    //   block [0x82AB4184..0x82AB419C)
	// 82AB4184: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4188: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB418C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB4190: 409A000C  bne cr6, 0x82ab419c
	if !ctx.cr[6].eq {
	pc = 0x82AB419C; continue 'dispatch;
	}
	// 82AB4194: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB4198: 48000020  b 0x82ab41b8
	pc = 0x82AB41B8; continue 'dispatch;
            }
            0x82AB419C => {
    //   block [0x82AB419C..0x82AB41B4)
	// 82AB419C: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB41A0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB41A4: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AB41A8: 409A000C  bne cr6, 0x82ab41b4
	if !ctx.cr[6].eq {
	pc = 0x82AB41B4; continue 'dispatch;
	}
	// 82AB41AC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AB41B0: 48000008  b 0x82ab41b8
	pc = 0x82AB41B8; continue 'dispatch;
            }
            0x82AB41B4 => {
    //   block [0x82AB41B4..0x82AB41B8)
	// 82AB41B4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB41B8; continue 'dispatch;
            }
            0x82AB41B8 => {
    //   block [0x82AB41B8..0x82AB41D0)
	// 82AB41B8: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB41BC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AB41C0: 890B0014  lbz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB41C4: 893A0014  lbz r9, 0x14(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB41C8: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 82AB41CC: 991A0014  stb r8, 0x14(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB41D0; continue 'dispatch;
            }
            0x82AB41D0 => {
    //   block [0x82AB41D0..0x82AB41F4)
	// 82AB41D0: 897A0014  lbz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB41D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AB41D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AB41DC: 409A0194  bne cr6, 0x82ab4370
	if !ctx.cr[6].eq {
	pc = 0x82AB4370; continue 'dispatch;
	}
	// 82AB41E0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB41E4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AB41E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB41EC: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB41F0: 419A017C  beq cr6, 0x82ab436c
	if ctx.cr[6].eq {
	pc = 0x82AB436C; continue 'dispatch;
	}
	pc = 0x82AB41F4; continue 'dispatch;
            }
            0x82AB41F4 => {
    //   block [0x82AB41F4..0x82AB4234)
	// 82AB41F4: 897C0014  lbz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB41F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AB41FC: 409A0170  bne cr6, 0x82ab436c
	if !ctx.cr[6].eq {
	pc = 0x82AB436C; continue 'dispatch;
	}
	// 82AB4200: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4204: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB4208: 409A00A8  bne cr6, 0x82ab42b0
	if !ctx.cr[6].eq {
	pc = 0x82AB42B0; continue 'dispatch;
	}
	// 82AB420C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4210: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4214: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB4218: 409A001C  bne cr6, 0x82ab4234
	if !ctx.cr[6].eq {
	pc = 0x82AB4234; continue 'dispatch;
	}
	// 82AB421C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AB4220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB4224: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AB4228: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB422C: 4BF04335  bl 0x829b8560
	ctx.lr = 0x82AB4230;
	sub_829B8560(ctx, base);
	// 82AB4230: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AB4234; continue 'dispatch;
            }
            0x82AB4234 => {
    //   block [0x82AB4234..0x82AB4260)
	// 82AB4234: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4238: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB423C: 409A00C8  bne cr6, 0x82ab4304
	if !ctx.cr[6].eq {
	pc = 0x82AB4304; continue 'dispatch;
	}
	// 82AB4240: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4244: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4248: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AB424C: 409A0014  bne cr6, 0x82ab4260
	if !ctx.cr[6].eq {
	pc = 0x82AB4260; continue 'dispatch;
	}
	// 82AB4250: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4254: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4258: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AB425C: 419A00A4  beq cr6, 0x82ab4300
	if ctx.cr[6].eq {
	pc = 0x82AB4300; continue 'dispatch;
	}
	pc = 0x82AB4260; continue 'dispatch;
            }
            0x82AB4260 => {
    //   block [0x82AB4260..0x82AB428C)
	// 82AB4260: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4264: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4268: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AB426C: 409A0020  bne cr6, 0x82ab428c
	if !ctx.cr[6].eq {
	pc = 0x82AB428C; continue 'dispatch;
	}
	// 82AB4270: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4274: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82AB4278: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB427C: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AB4280: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AB4284: 4B854B85  bl 0x82308e08
	ctx.lr = 0x82AB4288;
	sub_82308E08(ctx, base);
	// 82AB4288: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AB428C; continue 'dispatch;
            }
            0x82AB428C => {
    //   block [0x82AB428C..0x82AB42B0)
	// 82AB428C: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB4294: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB4298: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82AB429C: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AB42A0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB42A4: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AB42A8: 4BF042B9  bl 0x829b8560
	ctx.lr = 0x82AB42AC;
	sub_829B8560(ctx, base);
	// 82AB42AC: 480000C0  b 0x82ab436c
	pc = 0x82AB436C; continue 'dispatch;
            }
            0x82AB42B0 => {
    //   block [0x82AB42B0..0x82AB42D4)
	// 82AB42B0: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB42B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB42B8: 409A001C  bne cr6, 0x82ab42d4
	if !ctx.cr[6].eq {
	pc = 0x82AB42D4; continue 'dispatch;
	}
	// 82AB42BC: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AB42C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB42C4: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AB42C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB42CC: 4B854B3D  bl 0x82308e08
	ctx.lr = 0x82AB42D0;
	sub_82308E08(ctx, base);
	// 82AB42D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AB42D4; continue 'dispatch;
            }
            0x82AB42D4 => {
    //   block [0x82AB42D4..0x82AB4300)
	// 82AB42D4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB42D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB42DC: 409A0028  bne cr6, 0x82ab4304
	if !ctx.cr[6].eq {
	pc = 0x82AB4304; continue 'dispatch;
	}
	// 82AB42E0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB42E4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB42E8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AB42EC: 409A0034  bne cr6, 0x82ab4320
	if !ctx.cr[6].eq {
	pc = 0x82AB4320; continue 'dispatch;
	}
	// 82AB42F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB42F4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB42F8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AB42FC: 409A0024  bne cr6, 0x82ab4320
	if !ctx.cr[6].eq {
	pc = 0x82AB4320; continue 'dispatch;
	}
	pc = 0x82AB4300; continue 'dispatch;
            }
            0x82AB4300 => {
    //   block [0x82AB4300..0x82AB4304)
	// 82AB4300: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	pc = 0x82AB4304; continue 'dispatch;
            }
            0x82AB4304 => {
    //   block [0x82AB4304..0x82AB4320)
	// 82AB4304: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4308: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82AB430C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4310: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4314: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB4318: 409AFEDC  bne cr6, 0x82ab41f4
	if !ctx.cr[6].eq {
	pc = 0x82AB41F4; continue 'dispatch;
	}
	// 82AB431C: 48000050  b 0x82ab436c
	pc = 0x82AB436C; continue 'dispatch;
            }
            0x82AB4320 => {
    //   block [0x82AB4320..0x82AB434C)
	// 82AB4320: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4324: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4328: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AB432C: 409A0020  bne cr6, 0x82ab434c
	if !ctx.cr[6].eq {
	pc = 0x82AB434C; continue 'dispatch;
	}
	// 82AB4330: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4334: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82AB4338: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB433C: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AB4340: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82AB4344: 4BF0421D  bl 0x829b8560
	ctx.lr = 0x82AB4348;
	sub_829B8560(ctx, base);
	// 82AB4348: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82AB434C; continue 'dispatch;
            }
            0x82AB434C => {
    //   block [0x82AB434C..0x82AB436C)
	// 82AB434C: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB4354: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB4358: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82AB435C: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AB4360: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4364: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82AB4368: 4B854AA1  bl 0x82308e08
	ctx.lr = 0x82AB436C;
	sub_82308E08(ctx, base);
	pc = 0x82AB436C; continue 'dispatch;
            }
            0x82AB436C => {
    //   block [0x82AB436C..0x82AB4370)
	// 82AB436C: 9BBC0014  stb r29, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	pc = 0x82AB4370; continue 'dispatch;
            }
            0x82AB4370 => {
    //   block [0x82AB4370..0x82AB4380)
	// 82AB4370: 387A000C  addi r3, r26, 0xc
	ctx.r[3].s64 = ctx.r[26].s64 + 12;
	// 82AB4374: 4B7123F5  bl 0x821c6768
	ctx.lr = 0x82AB4378;
	sub_821C6768(ctx, base);
	// 82AB4378: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AB437C: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x82AB4380; continue 'dispatch;
            }
            0x82AB4380 => {
    //   block [0x82AB4380..0x82AB43D0)
	// 82AB4380: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AB4384: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4388: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AB438C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AB4390: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB4394: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4398: 4082FFE8  bne 0x82ab4380
	if !ctx.cr[0].eq {
	pc = 0x82AB4380; continue 'dispatch;
	}
	// 82AB439C: 93DA000C  stw r30, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AB43A0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AB43A4: 4B767995  bl 0x8221bd38
	ctx.lr = 0x82AB43A8;
	sub_8221BD38(ctx, base);
	// 82AB43A8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB43AC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AB43B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB43B4: 419A001C  beq cr6, 0x82ab43d0
	if ctx.cr[6].eq {
	pc = 0x82AB43D0; continue 'dispatch;
	}
	// 82AB43B8: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82AB43BC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82AB43C0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82AB43C4: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82AB43C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AB43CC: 481F5080  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB43D0 => {
    //   block [0x82AB43D0..0x82AB43E0)
	// 82AB43D0: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82AB43D4: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AB43D8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AB43DC: 481F5070  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB43E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB43E0 size=280
    let mut pc: u32 = 0x82AB43E0;
    'dispatch: loop {
        match pc {
            0x82AB43E0 => {
    //   block [0x82AB43E0..0x82AB4418)
	// 82AB43E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB43E4: 481F5029  bl 0x82ca940c
	ctx.lr = 0x82AB43E8;
	sub_82CA93D0(ctx, base);
	// 82AB43E8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB43EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB43F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB43F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB43F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB43FC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB4400: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB4404: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AB4408: 409A0010  bne cr6, 0x82ab4418
	if !ctx.cr[6].eq {
	pc = 0x82AB4418; continue 'dispatch;
	}
	// 82AB440C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AB4410: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB4414: 481F5048  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB4418 => {
    //   block [0x82AB4418..0x82AB4488)
	// 82AB4418: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 82AB441C: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 82AB4420: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB4424: 40990064  ble cr6, 0x82ab4488
	if !ctx.cr[6].gt {
	pc = 0x82AB4488; continue 'dispatch;
	}
	// 82AB4428: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82AB442C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AB4430: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AB4434: 388B1A9C  addi r4, r11, 0x1a9c
	ctx.r[4].s64 = ctx.r[11].s64 + 6812;
	// 82AB4438: 4B83DB09  bl 0x822f1f40
	ctx.lr = 0x82AB443C;
	sub_822F1F40(ctx, base);
	// 82AB443C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AB4440: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AB4444: 4B83D96D  bl 0x822f1db0
	ctx.lr = 0x82AB4448;
	sub_822F1DB0(ctx, base);
	// 82AB4448: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AB444C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AB4450: 3BEA1720  addi r31, r10, 0x1720
	ctx.r[31].s64 = ctx.r[10].s64 + 5920;
	// 82AB4454: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82AB4458: 4B83D9C9  bl 0x822f1e20
	ctx.lr = 0x82AB445C;
	sub_822F1E20(ctx, base);
	// 82AB445C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82AB4460: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AB4464: 4BBC737D  bl 0x8267b7e0
	ctx.lr = 0x82AB4468;
	sub_8267B7E0(ctx, base);
	// 82AB4468: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AB446C: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 82AB4470: 4198007C  blt cr6, 0x82ab44ec
	if ctx.cr[6].lt {
	pc = 0x82AB44EC; continue 'dispatch;
	}
	// 82AB4474: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AB4478: 4B7678C1  bl 0x8221bd38
	ctx.lr = 0x82AB447C;
	sub_8221BD38(ctx, base);
	// 82AB447C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AB4480: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB4484: 481F4FD8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB4488 => {
    //   block [0x82AB4488..0x82AB449C)
	// 82AB4488: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82AB448C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB4490: 409A000C  bne cr6, 0x82ab449c
	if !ctx.cr[6].eq {
	pc = 0x82AB449C; continue 'dispatch;
	}
	// 82AB4494: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82AB4498: 48000038  b 0x82ab44d0
	pc = 0x82AB44D0; continue 'dispatch;
            }
            0x82AB449C => {
    //   block [0x82AB449C..0x82AB44D0)
	// 82AB449C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82AB44A0: 7D2AF396  divwu r9, r10, r30
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[30].u32;
	// 82AB44A4: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 82AB44A8: 40980028  bge cr6, 0x82ab44d0
	if !ctx.cr[6].lt {
	pc = 0x82AB44D0; continue 'dispatch;
	}
	// 82AB44AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AB44B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AB44B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB44B8: 392A1714  addi r9, r10, 0x1714
	ctx.r[9].s64 = ctx.r[10].s64 + 5908;
	// 82AB44BC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AB44C0: 4B83D961  bl 0x822f1e20
	ctx.lr = 0x82AB44C4;
	sub_822F1E20(ctx, base);
	// 82AB44C4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82AB44C8: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82AB44CC: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82AB44D0; continue 'dispatch;
            }
            0x82AB44D0 => {
    //   block [0x82AB44D0..0x82AB44EC)
	// 82AB44D0: 57A31838  slwi r3, r29, 3
	ctx.r[3].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB44D4: 4B76AD85  bl 0x8221f258
	ctx.lr = 0x82AB44D8;
	sub_8221F258(ctx, base);
	// 82AB44D8: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB44DC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82AB44E0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82AB44E4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AB44E8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB44EC; continue 'dispatch;
            }
            0x82AB44EC => {
    //   block [0x82AB44EC..0x82AB44F8)
	// 82AB44EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AB44F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB44F4: 481F4F68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB44F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB44F8 size=60
    let mut pc: u32 = 0x82AB44F8;
    'dispatch: loop {
        match pc {
            0x82AB44F8 => {
    //   block [0x82AB44F8..0x82AB4508)
	// 82AB44F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB44FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB4500: 409A0008  bne cr6, 0x82ab4508
	if !ctx.cr[6].eq {
	pc = 0x82AB4508; continue 'dispatch;
	}
	// 82AB4504: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB4508; continue 'dispatch;
            }
            0x82AB4508 => {
    //   block [0x82AB4508..0x82AB4534)
	// 82AB4508: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB450C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4510: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB4514: 419A0020  beq cr6, 0x82ab4534
	if ctx.cr[6].eq {
		sub_82AB4534(ctx, base);
		return;
	}
	// 82AB4518: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB451C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB4520: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB4528: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AB452C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82AB4530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB4534(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB4534 size=60
    let mut pc: u32 = 0x82AB4534;
    'dispatch: loop {
        match pc {
            0x82AB4534 => {
    //   block [0x82AB4534..0x82AB4554)
	// 82AB4534: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4538: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB453C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB4540: 409A0030  bne cr6, 0x82ab4570
	if !ctx.cr[6].eq {
		sub_82AB4570(ctx, base);
		return;
	}
	// 82AB4544: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4548: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB454C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB4550: 409A0018  bne cr6, 0x82ab4568
	if !ctx.cr[6].eq {
	pc = 0x82AB4568; continue 'dispatch;
	}
	pc = 0x82AB4554; continue 'dispatch;
            }
            0x82AB4554 => {
    //   block [0x82AB4554..0x82AB4568)
	// 82AB4554: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82AB4558: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB455C: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4560: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB4564: 419AFFF0  beq cr6, 0x82ab4554
	if ctx.cr[6].eq {
	pc = 0x82AB4554; continue 'dispatch;
	}
	pc = 0x82AB4568; continue 'dispatch;
            }
            0x82AB4568 => {
    //   block [0x82AB4568..0x82AB4570)
	// 82AB4568: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AB456C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB4570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB4570 size=80
    let mut pc: u32 = 0x82AB4570;
    'dispatch: loop {
        match pc {
            0x82AB4570 => {
    //   block [0x82AB4570..0x82AB4580)
	// 82AB4570: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4574: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB4578: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB457C: 409A002C  bne cr6, 0x82ab45a8
	if !ctx.cr[6].eq {
	pc = 0x82AB45A8; continue 'dispatch;
	}
	pc = 0x82AB4580; continue 'dispatch;
            }
            0x82AB4580 => {
    //   block [0x82AB4580..0x82AB45A8)
	// 82AB4580: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4584: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4588: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB458C: 409A001C  bne cr6, 0x82ab45a8
	if !ctx.cr[6].eq {
	pc = 0x82AB45A8; continue 'dispatch;
	}
	// 82AB4590: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB4594: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB4598: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB459C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB45A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB45A4: 419AFFDC  beq cr6, 0x82ab4580
	if ctx.cr[6].eq {
	pc = 0x82AB4580; continue 'dispatch;
	}
	pc = 0x82AB45A8; continue 'dispatch;
            }
            0x82AB45A8 => {
    //   block [0x82AB45A8..0x82AB45C0)
	// 82AB45A8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB45AC: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82AB45B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB45B4: 409AFF78  bne cr6, 0x82ab452c
	if !ctx.cr[6].eq {
		sub_82AB44F8(ctx, base);
		return;
	}
	// 82AB45B8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB45BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB45C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB45C0 size=80
    let mut pc: u32 = 0x82AB45C0;
    'dispatch: loop {
        match pc {
            0x82AB45C0 => {
    //   block [0x82AB45C0..0x82AB45F8)
	// 82AB45C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB45C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB45C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AB45CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB45D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB45D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB45D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB45DC: 48000035  bl 0x82ab4610
	ctx.lr = 0x82AB45E0;
	sub_82AB4610(ctx, base);
	// 82AB45E0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82AB45E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB45E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB45EC: 419A000C  beq cr6, 0x82ab45f8
	if ctx.cr[6].eq {
	pc = 0x82AB45F8; continue 'dispatch;
	}
	// 82AB45F0: 4B767749  bl 0x8221bd38
	ctx.lr = 0x82AB45F4;
	sub_8221BD38(ctx, base);
	// 82AB45F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82AB45F8; continue 'dispatch;
            }
            0x82AB45F8 => {
    //   block [0x82AB45F8..0x82AB4610)
	// 82AB45F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB45FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB4600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB4604: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AB4608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB460C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB4610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB4610 size=220
    let mut pc: u32 = 0x82AB4610;
    'dispatch: loop {
        match pc {
            0x82AB4610 => {
    //   block [0x82AB4610..0x82AB4634)
	// 82AB4610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB4614: 481F4DF5  bl 0x82ca9408
	ctx.lr = 0x82AB4618;
	sub_82CA93D0(ctx, base);
	// 82AB4618: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB461C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB4620: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82AB4624: 3BFD00B0  addi r31, r29, 0xb0
	ctx.r[31].s64 = ctx.r[29].s64 + 176;
	// 82AB4628: 394B8B20  addi r10, r11, -0x74e0
	ctx.r[10].s64 = ctx.r[11].s64 + -29920;
	// 82AB462C: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 82AB4630: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82AB4634; continue 'dispatch;
            }
            0x82AB4634 => {
    //   block [0x82AB4634..0x82AB4654)
	// 82AB4634: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82AB4638: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB463C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB4640: 419A0014  beq cr6, 0x82ab4654
	if ctx.cr[6].eq {
	pc = 0x82AB4654; continue 'dispatch;
	}
	// 82AB4644: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4648: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB464C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4650: 4E800421  bctrl
	ctx.lr = 0x82AB4654;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB4654 => {
    //   block [0x82AB4654..0x82AB4668)
	// 82AB4654: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB4658: 4080FFDC  bge 0x82ab4634
	if !ctx.cr[0].lt {
	pc = 0x82AB4634; continue 'dispatch;
	}
	// 82AB465C: 3BFD00A4  addi r31, r29, 0xa4
	ctx.r[31].s64 = ctx.r[29].s64 + 164;
	// 82AB4660: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 82AB4664: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82AB4668; continue 'dispatch;
            }
            0x82AB4668 => {
    //   block [0x82AB4668..0x82AB467C)
	// 82AB4668: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82AB466C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB4674: 419A0040  beq cr6, 0x82ab46b4
	if ctx.cr[6].eq {
	pc = 0x82AB46B4; continue 'dispatch;
	}
	// 82AB4678: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB467C; continue 'dispatch;
            }
            0x82AB467C => {
    //   block [0x82AB467C..0x82AB46B0)
	// 82AB467C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB4680: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4684: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB4688: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB468C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB4690: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4694: 4082FFE8  bne 0x82ab467c
	if !ctx.cr[0].eq {
	pc = 0x82AB467C; continue 'dispatch;
	}
	// 82AB4698: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB469C: 409A0014  bne cr6, 0x82ab46b0
	if !ctx.cr[6].eq {
	pc = 0x82AB46B0; continue 'dispatch;
	}
	// 82AB46A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB46A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB46A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB46AC: 4E800421  bctrl
	ctx.lr = 0x82AB46B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB46B0 => {
    //   block [0x82AB46B0..0x82AB46B4)
	// 82AB46B0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82AB46B4; continue 'dispatch;
            }
            0x82AB46B4 => {
    //   block [0x82AB46B4..0x82AB46EC)
	// 82AB46B4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB46B8: 4080FFB0  bge 0x82ab4668
	if !ctx.cr[0].lt {
	pc = 0x82AB4668; continue 'dispatch;
	}
	// 82AB46BC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82AB46C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB46C4: 394B6CF8  addi r10, r11, 0x6cf8
	ctx.r[10].s64 = ctx.r[11].s64 + 27896;
	// 82AB46C8: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB46CC: 48066325  bl 0x82b1a9f0
	ctx.lr = 0x82AB46D0;
	sub_82B1A9F0(ctx, base);
	// 82AB46D0: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 82AB46D4: 4BD1E89D  bl 0x827d2f70
	ctx.lr = 0x82AB46D8;
	sub_827D2F70(ctx, base);
	// 82AB46D8: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AB46DC: 39090FD0  addi r8, r9, 0xfd0
	ctx.r[8].s64 = ctx.r[9].s64 + 4048;
	// 82AB46E0: 911D0000  stw r8, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AB46E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB46E8: 481F4D70  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB46F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB46F0 size=116
    let mut pc: u32 = 0x82AB46F0;
    'dispatch: loop {
        match pc {
            0x82AB46F0 => {
    //   block [0x82AB46F0..0x82AB4714)
	// 82AB46F0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82AB46F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AB46F8: 816A0098  lwz r11, 0x98(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AB46FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB4700: 419A0014  beq cr6, 0x82ab4714
	if ctx.cr[6].eq {
	pc = 0x82AB4714; continue 'dispatch;
	}
	// 82AB4704: 892B0047  lbz r9, 0x47(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 82AB4708: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB470C: 419A0008  beq cr6, 0x82ab4714
	if ctx.cr[6].eq {
	pc = 0x82AB4714; continue 'dispatch;
	}
	// 82AB4710: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82AB4714; continue 'dispatch;
            }
            0x82AB4714 => {
    //   block [0x82AB4714..0x82AB473C)
	// 82AB4714: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82AB4718: 816A009C  lwz r11, 0x9c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AB471C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB4720: 419A001C  beq cr6, 0x82ab473c
	if ctx.cr[6].eq {
	pc = 0x82AB473C; continue 'dispatch;
	}
	// 82AB4724: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB4728: 419A0014  beq cr6, 0x82ab473c
	if ctx.cr[6].eq {
	pc = 0x82AB473C; continue 'dispatch;
	}
	// 82AB472C: 892B0047  lbz r9, 0x47(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 82AB4730: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB4734: 419A0008  beq cr6, 0x82ab473c
	if ctx.cr[6].eq {
	pc = 0x82AB473C; continue 'dispatch;
	}
	// 82AB4738: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	pc = 0x82AB473C; continue 'dispatch;
            }
            0x82AB473C => {
    //   block [0x82AB473C..0x82AB4764)
	// 82AB473C: 814A00A0  lwz r10, 0xa0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(160 as u32) ) } as u64;
	// 82AB4740: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB4744: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AB4748: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB474C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AB4750: 896A0047  lbz r11, 0x47(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(71 as u32) ) } as u64;
	// 82AB4754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB4758: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82AB475C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82AB4760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB4768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB4768 size=128
    let mut pc: u32 = 0x82AB4768;
    'dispatch: loop {
        match pc {
            0x82AB4768 => {
    //   block [0x82AB4768..0x82AB4784)
	// 82AB4768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB476C: 481F4C9D  bl 0x82ca9408
	ctx.lr = 0x82AB4770;
	sub_82CA93D0(ctx, base);
	// 82AB4770: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB4774: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB4778: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AB477C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AB4780: 3BBE00A4  addi r29, r30, 0xa4
	ctx.r[29].s64 = ctx.r[30].s64 + 164;
	pc = 0x82AB4784; continue 'dispatch;
            }
            0x82AB4784 => {
    //   block [0x82AB4784..0x82AB47AC)
	// 82AB4784: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB478C: 419A0020  beq cr6, 0x82ab47ac
	if ctx.cr[6].eq {
	pc = 0x82AB47AC; continue 'dispatch;
	}
	// 82AB4790: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4794: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB4798: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB479C: 4E800421  bctrl
	ctx.lr = 0x82AB47A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB47A0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82AB47A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AB47A8: 419A0008  beq cr6, 0x82ab47b0
	if ctx.cr[6].eq {
	pc = 0x82AB47B0; continue 'dispatch;
	}
            }
            0x82AB47AC => {
    //   block [0x82AB47AC..0x82AB47B0)
	// 82AB47AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AB47B0; continue 'dispatch;
            }
            0x82AB47B0 => {
    //   block [0x82AB47B0..0x82AB47CC)
	// 82AB47B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AB47B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB47B8: 419A0014  beq cr6, 0x82ab47cc
	if ctx.cr[6].eq {
	pc = 0x82AB47CC; continue 'dispatch;
	}
	// 82AB47BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB47C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB47C4: 4800020D  bl 0x82ab49d0
	ctx.lr = 0x82AB47C8;
	sub_82AB49D0(ctx, base);
	// 82AB47C8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82AB47CC; continue 'dispatch;
            }
            0x82AB47CC => {
    //   block [0x82AB47CC..0x82AB47E8)
	// 82AB47CC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82AB47D0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82AB47D4: 2F1F0003  cmpwi cr6, r31, 3
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3, &mut ctx.xer);
	// 82AB47D8: 4198FFAC  blt cr6, 0x82ab4784
	if ctx.cr[6].lt {
	pc = 0x82AB4784; continue 'dispatch;
	}
	// 82AB47DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB47E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB47E4: 481F4C74  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB47E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB47E8 size=124
    let mut pc: u32 = 0x82AB47E8;
    'dispatch: loop {
        match pc {
            0x82AB47E8 => {
    //   block [0x82AB47E8..0x82AB4808)
	// 82AB47E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB47EC: 481F4C19  bl 0x82ca9404
	ctx.lr = 0x82AB47F0;
	sub_82CA93D0(ctx, base);
	// 82AB47F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB47F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AB47F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AB47FC: 3BFB00A4  addi r31, r27, 0xa4
	ctx.r[31].s64 = ctx.r[27].s64 + 164;
	// 82AB4800: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82AB4804: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	pc = 0x82AB4808; continue 'dispatch;
            }
            0x82AB4808 => {
    //   block [0x82AB4808..0x82AB4834)
	// 82AB4808: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB480C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB4810: 419A0028  beq cr6, 0x82ab4838
	if ctx.cr[6].eq {
	pc = 0x82AB4838; continue 'dispatch;
	}
	// 82AB4814: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB4818: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB481C: 419A0018  beq cr6, 0x82ab4834
	if ctx.cr[6].eq {
	pc = 0x82AB4834; continue 'dispatch;
	}
	// 82AB4820: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4824: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4828: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB482C: 4E800421  bctrl
	ctx.lr = 0x82AB4830;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4830: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
            }
            0x82AB4834 => {
    //   block [0x82AB4834..0x82AB4838)
	// 82AB4834: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82AB4838; continue 'dispatch;
            }
            0x82AB4838 => {
    //   block [0x82AB4838..0x82AB4858)
	// 82AB4838: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AB483C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82AB4840: 4082FFC8  bne 0x82ab4808
	if !ctx.cr[0].eq {
	pc = 0x82AB4808; continue 'dispatch;
	}
	// 82AB4844: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82AB4848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB484C: 419A000C  beq cr6, 0x82ab4858
	if ctx.cr[6].eq {
	pc = 0x82AB4858; continue 'dispatch;
	}
	// 82AB4850: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB4854: 4BF9CF95  bl 0x82a517e8
	ctx.lr = 0x82AB4858;
	sub_82A517E8(ctx, base);
	pc = 0x82AB4858; continue 'dispatch;
            }
            0x82AB4858 => {
    //   block [0x82AB4858..0x82AB4864)
	// 82AB4858: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB485C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB4860: 481F4BF4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB4868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB4868 size=360
    let mut pc: u32 = 0x82AB4868;
    'dispatch: loop {
        match pc {
            0x82AB4868 => {
    //   block [0x82AB4868..0x82AB489C)
	// 82AB4868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB486C: 481F4BA1  bl 0x82ca940c
	ctx.lr = 0x82AB4870;
	sub_82CA93D0(ctx, base);
	// 82AB4870: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB4874: 7C8BFE70  srawi r11, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 82AB4878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB487C: 7D6A2038  and r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 82AB4880: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB4884: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82AB4888: 391F00A4  addi r8, r31, 0xa4
	ctx.r[8].s64 = ctx.r[31].s64 + 164;
	// 82AB488C: 216A0002  subfic r11, r10, 2
	ctx.xer.ca = ctx.r[10].u32 <= 2 as u32;
	ctx.r[11].s64 = (2 as i64) - ctx.r[10].s64;
	// 82AB4890: 7D67FE70  srawi r7, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 82AB4894: 7CEB5838  and r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[11].u64;
	// 82AB4898: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x82AB489C; continue 'dispatch;
            }
            0x82AB489C => {
    //   block [0x82AB489C..0x82AB48BC)
	// 82AB489C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB48A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB48A4: 409A00C4  bne cr6, 0x82ab4968
	if !ctx.cr[6].eq {
	pc = 0x82AB4968; continue 'dispatch;
	}
	// 82AB48A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AB48AC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82AB48B0: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 82AB48B4: 4198FFE8  blt cr6, 0x82ab489c
	if ctx.cr[6].lt {
	pc = 0x82AB489C; continue 'dispatch;
	}
	// 82AB48B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82AB48BC; continue 'dispatch;
            }
            0x82AB48BC => {
    //   block [0x82AB48BC..0x82AB48D4)
	// 82AB48BC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AB48C0: 894B6F25  lbz r10, 0x6f25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28453 as u32) ) } as u64;
	// 82AB48C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB48C8: 419A000C  beq cr6, 0x82ab48d4
	if ctx.cr[6].eq {
	pc = 0x82AB48D4; continue 'dispatch;
	}
	// 82AB48CC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB48D0: 481B46D9  bl 0x82c68fa8
	ctx.lr = 0x82AB48D4;
	sub_82C68FA8(ctx, base);
	pc = 0x82AB48D4; continue 'dispatch;
            }
            0x82AB48D4 => {
    //   block [0x82AB48D4..0x82AB48E8)
	// 82AB48D4: 80BF0094  lwz r5, 0x94(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AB48D8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB48DC: 40990020  ble cr6, 0x82ab48fc
	if !ctx.cr[6].gt {
	pc = 0x82AB48FC; continue 'dispatch;
	}
	// 82AB48E0: 395F0054  addi r10, r31, 0x54
	ctx.r[10].s64 = ctx.r[31].s64 + 84;
	// 82AB48E4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82AB48E8; continue 'dispatch;
            }
            0x82AB48E8 => {
    //   block [0x82AB48E8..0x82AB48FC)
	// 82AB48E8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB48EC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB48F0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AB48F4: 7CA92A14  add r5, r9, r5
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 82AB48F8: 4082FFF0  bne 0x82ab48e8
	if !ctx.cr[0].eq {
	pc = 0x82AB48E8; continue 'dispatch;
	}
	pc = 0x82AB48FC; continue 'dispatch;
            }
            0x82AB48FC => {
    //   block [0x82AB48FC..0x82AB493C)
	// 82AB48FC: 397E0029  addi r11, r30, 0x29
	ctx.r[11].s64 = ctx.r[30].s64 + 41;
	// 82AB4900: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4904: 395E0015  addi r10, r30, 0x15
	ctx.r[10].s64 = ctx.r[30].s64 + 21;
	// 82AB4908: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB490C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB4910: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AB4914: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AB4918: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AB491C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB4920: 7CC9F82E  lwzx r6, r9, r31
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AB4924: 481B452D  bl 0x82c68e50
	ctx.lr = 0x82AB4928;
	sub_82C68E50(ctx, base);
	// 82AB4928: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB492C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AB4930: 419A0098  beq cr6, 0x82ab49c8
	if ctx.cr[6].eq {
	pc = 0x82AB49C8; continue 'dispatch;
	}
	// 82AB4934: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB4938: 397F0098  addi r11, r31, 0x98
	ctx.r[11].s64 = ctx.r[31].s64 + 152;
	pc = 0x82AB493C; continue 'dispatch;
            }
            0x82AB493C => {
    //   block [0x82AB493C..0x82AB4954)
	// 82AB493C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4940: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB4944: 419A0010  beq cr6, 0x82ab4954
	if ctx.cr[6].eq {
	pc = 0x82AB4954; continue 'dispatch;
	}
	// 82AB4948: 89290047  lbz r9, 0x47(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(71 as u32) ) } as u64;
	// 82AB494C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB4950: 409A0020  bne cr6, 0x82ab4970
	if !ctx.cr[6].eq {
	pc = 0x82AB4970; continue 'dispatch;
	}
	pc = 0x82AB4954; continue 'dispatch;
            }
            0x82AB4954 => {
    //   block [0x82AB4954..0x82AB4968)
	// 82AB4954: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB4958: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AB495C: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82AB4960: 4198FFDC  blt cr6, 0x82ab493c
	if ctx.cr[6].lt {
	pc = 0x82AB493C; continue 'dispatch;
	}
	// 82AB4964: 4800001C  b 0x82ab4980
	pc = 0x82AB4980; continue 'dispatch;
            }
            0x82AB4968 => {
    //   block [0x82AB4968..0x82AB4970)
	// 82AB4968: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AB496C: 4BFFFF50  b 0x82ab48bc
	pc = 0x82AB48BC; continue 'dispatch;
            }
            0x82AB4970 => {
    //   block [0x82AB4970..0x82AB4980)
	// 82AB4970: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 82AB4974: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 82AB4978: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82AB497C: 409A001C  bne cr6, 0x82ab4998
	if !ctx.cr[6].eq {
	pc = 0x82AB4998; continue 'dispatch;
	}
	pc = 0x82AB4980; continue 'dispatch;
            }
            0x82AB4980 => {
    //   block [0x82AB4980..0x82AB4998)
	// 82AB4980: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4984: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AB4988: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB498C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB4990: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4994: 4E800421  bctrl
	ctx.lr = 0x82AB4998;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB4998 => {
    //   block [0x82AB4998..0x82AB49C8)
	// 82AB4998: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82AB499C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB49A0: 409A0028  bne cr6, 0x82ab49c8
	if !ctx.cr[6].eq {
	pc = 0x82AB49C8; continue 'dispatch;
	}
	// 82AB49A4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AB49A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB49AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AB49B0: 386BF9F0  addi r3, r11, -0x610
	ctx.r[3].s64 = ctx.r[11].s64 + -1552;
	// 82AB49B4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82AB49B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB49BC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AB49C0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AB49C4: 4BF9E67D  bl 0x82a53040
	ctx.lr = 0x82AB49C8;
	sub_82A53040(ctx, base);
	pc = 0x82AB49C8; continue 'dispatch;
            }
            0x82AB49C8 => {
    //   block [0x82AB49C8..0x82AB49D0)
	// 82AB49C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB49CC: 481F4A90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB49D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB49D0 size=572
    let mut pc: u32 = 0x82AB49D0;
    'dispatch: loop {
        match pc {
            0x82AB49D0 => {
    //   block [0x82AB49D0..0x82AB4A38)
	// 82AB49D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB49D4: 481F4A31  bl 0x82ca9404
	ctx.lr = 0x82AB49D8;
	sub_82CA93D0(ctx, base);
	// 82AB49D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB49DC: 7C8BFE70  srawi r11, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 82AB49E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB49E4: 7D6A2038  and r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 82AB49E8: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82AB49EC: 216A0002  subfic r11, r10, 2
	ctx.xer.ca = ctx.r[10].u32 <= 2 as u32;
	ctx.r[11].s64 = (2 as i64) - ctx.r[10].s64;
	// 82AB49F0: 7D69FE70  srawi r9, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 82AB49F4: 7D2B5838  and r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 82AB49F8: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AB49FC: 391E0029  addi r8, r30, 0x29
	ctx.r[8].s64 = ctx.r[30].s64 + 41;
	// 82AB4A00: 551D103A  slwi r29, r8, 2
	ctx.r[29].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82AB4A04: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AB4A08: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4A0C: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB4A10: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82AB4A14: 4E800421  bctrl
	ctx.lr = 0x82AB4A18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4A18: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82AB4A1C: 419A001C  beq cr6, 0x82ab4a38
	if ctx.cr[6].eq {
	pc = 0x82AB4A38; continue 'dispatch;
	}
	// 82AB4A20: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AB4A24: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AB4A28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4A2C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB4A30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4A34: 4E800421  bctrl
	ctx.lr = 0x82AB4A38;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB4A38 => {
    //   block [0x82AB4A38..0x82AB4A78)
	// 82AB4A38: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AB4A3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4A40: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB4A44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4A48: 4E800421  bctrl
	ctx.lr = 0x82AB4A4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4A4C: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82AB4A50: 4B76A809  bl 0x8221f258
	ctx.lr = 0x82AB4A54;
	sub_8221F258(ctx, base);
	// 82AB4A54: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AB4A58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB4A5C: 419A001C  beq cr6, 0x82ab4a78
	if ctx.cr[6].eq {
	pc = 0x82AB4A78; continue 'dispatch;
	}
	// 82AB4A60: 38DF0014  addi r6, r31, 0x14
	ctx.r[6].s64 = ctx.r[31].s64 + 20;
	// 82AB4A64: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AB4A68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB4A6C: 4BFFBFC5  bl 0x82ab0a30
	ctx.lr = 0x82AB4A70;
	sub_82AB0A30(ctx, base);
	// 82AB4A70: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AB4A74: 48000008  b 0x82ab4a7c
	pc = 0x82AB4A7C; continue 'dispatch;
            }
            0x82AB4A78 => {
    //   block [0x82AB4A78..0x82AB4A7C)
	// 82AB4A78: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	pc = 0x82AB4A7C; continue 'dispatch;
            }
            0x82AB4A7C => {
    //   block [0x82AB4A7C..0x82AB4A94)
	// 82AB4A7C: 397E0026  addi r11, r30, 0x26
	ctx.r[11].s64 = ctx.r[30].s64 + 38;
	// 82AB4A80: 557E103A  slwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82AB4A84: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AB4A88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB4A8C: 419A0040  beq cr6, 0x82ab4acc
	if ctx.cr[6].eq {
	pc = 0x82AB4ACC; continue 'dispatch;
	}
	// 82AB4A90: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB4A94; continue 'dispatch;
            }
            0x82AB4A94 => {
    //   block [0x82AB4A94..0x82AB4AC8)
	// 82AB4A94: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB4A98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4A9C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB4AA0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB4AA4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB4AA8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4AAC: 4082FFE8  bne 0x82ab4a94
	if !ctx.cr[0].eq {
	pc = 0x82AB4A94; continue 'dispatch;
	}
	// 82AB4AB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB4AB4: 409A0014  bne cr6, 0x82ab4ac8
	if !ctx.cr[6].eq {
	pc = 0x82AB4AC8; continue 'dispatch;
	}
	// 82AB4AB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4ABC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4AC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4AC4: 4E800421  bctrl
	ctx.lr = 0x82AB4AC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB4AC8 => {
    //   block [0x82AB4AC8..0x82AB4ACC)
	// 82AB4AC8: 7F9EF92E  stwx r28, r30, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32), ctx.r[28].u32) };
	pc = 0x82AB4ACC; continue 'dispatch;
            }
            0x82AB4ACC => {
    //   block [0x82AB4ACC..0x82AB4B78)
	// 82AB4ACC: 7F7EF92E  stwx r27, r30, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32), ctx.r[27].u32) };
	// 82AB4AD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB4AD4: 7F7DF82E  lwzx r27, r29, r31
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AB4AD8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AB4ADC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4AE0: 7FDEF82E  lwzx r30, r30, r31
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AB4AE4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4AE8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4AEC: 4E800421  bctrl
	ctx.lr = 0x82AB4AF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4AF0: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4AF4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82AB4AF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AB4AFC: 80E90018  lwz r7, 0x18(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB4B00: 83680000  lwz r27, 0(r8)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4B04: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82AB4B08: 4E800421  bctrl
	ctx.lr = 0x82AB4B0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4B0C: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 82AB4B10: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82AB4B14: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AB4B18: 38A62B60  addi r5, r6, 0x2b60
	ctx.r[5].s64 = ctx.r[6].s64 + 11104;
	// 82AB4B1C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82AB4B20: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82AB4B24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB4B28: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 82AB4B2C: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 82AB4B30: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82AB4B34: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82AB4B38: 9B810078  stb r28, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u8 ) };
	// 82AB4B3C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4B40: 80FF0090  lwz r7, 0x90(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AB4B44: 88DF0080  lbz r6, 0x80(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AB4B48: 88BF006E  lbz r5, 0x6e(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(110 as u32) ) } as u64;
	// 82AB4B4C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4B50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4B54: 4E800421  bctrl
	ctx.lr = 0x82AB4B58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4B58: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AB4B5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB4B60: 419A0018  beq cr6, 0x82ab4b78
	if ctx.cr[6].eq {
	pc = 0x82AB4B78; continue 'dispatch;
	}
	// 82AB4B64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4B68: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4B6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4B70: 4E800421  bctrl
	ctx.lr = 0x82AB4B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4B74: 7F9DF92E  stwx r28, r29, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32), ctx.r[28].u32) };
            }
            0x82AB4B78 => {
    //   block [0x82AB4B78..0x82AB4B80)
	// 82AB4B78: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82AB4B7C: 395F00A4  addi r10, r31, 0xa4
	ctx.r[10].s64 = ctx.r[31].s64 + 164;
	pc = 0x82AB4B80; continue 'dispatch;
            }
            0x82AB4B80 => {
    //   block [0x82AB4B80..0x82AB4BA0)
	// 82AB4B80: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4B84: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB4B88: 409A0018  bne cr6, 0x82ab4ba0
	if !ctx.cr[6].eq {
	pc = 0x82AB4BA0; continue 'dispatch;
	}
	// 82AB4B8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB4B90: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AB4B94: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82AB4B98: 4198FFE8  blt cr6, 0x82ab4b80
	if ctx.cr[6].lt {
	pc = 0x82AB4B80; continue 'dispatch;
	}
	// 82AB4B9C: 48000008  b 0x82ab4ba4
	pc = 0x82AB4BA4; continue 'dispatch;
            }
            0x82AB4BA0 => {
    //   block [0x82AB4BA0..0x82AB4BA4)
	// 82AB4BA0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82AB4BA4; continue 'dispatch;
            }
            0x82AB4BA4 => {
    //   block [0x82AB4BA4..0x82AB4BB8)
	// 82AB4BA4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82AB4BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB4BAC: 409A000C  bne cr6, 0x82ab4bb8
	if !ctx.cr[6].eq {
	pc = 0x82AB4BB8; continue 'dispatch;
	}
	// 82AB4BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB4BB4: 4BF9CC35  bl 0x82a517e8
	ctx.lr = 0x82AB4BB8;
	sub_82A517E8(ctx, base);
	pc = 0x82AB4BB8; continue 'dispatch;
            }
            0x82AB4BB8 => {
    //   block [0x82AB4BB8..0x82AB4C0C)
	// 82AB4BB8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AB4BBC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82AB4BC0: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 82AB4BC4: 3D200240  lis r9, 0x240
	ctx.r[9].s64 = 37748736;
	// 82AB4BC8: 3868AA88  addi r3, r8, -0x5578
	ctx.r[3].s64 = ctx.r[8].s64 + -21880;
	// 82AB4BCC: 816B6E2C  lwz r11, 0x6e2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28204 as u32) ) } as u64;
	// 82AB4BD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AB4BD4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AB4BD8: 3CEBFFD8  addis r7, r11, -0x28
	ctx.r[7].s64 = ctx.r[11].s64 + -2621440;
	// 82AB4BDC: 816A1620  lwz r11, 0x1620(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5664 as u32) ) } as u64;
	// 82AB4BE0: 7CE4FE70  srawi r4, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 82AB4BE4: 7C8A3838  and r10, r4, r7
	ctx.r[10].u64 = ctx.r[4].u64 & ctx.r[7].u64;
	// 82AB4BE8: 7D0A3850  subf r8, r10, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 82AB4BEC: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82AB4BF0: 7CE4FE70  srawi r4, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 82AB4BF4: 7C8B3838  and r11, r4, r7
	ctx.r[11].u64 = ctx.r[4].u64 & ctx.r[7].u64;
	// 82AB4BF8: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB4BFC: 7C885050  subf r4, r8, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82AB4C00: 4B6CC5A9  bl 0x821811a8
	ctx.lr = 0x82AB4C04;
	sub_821811A8(ctx, base);
	// 82AB4C04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AB4C08: 481F484C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB4C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB4C10 size=436
    let mut pc: u32 = 0x82AB4C10;
    'dispatch: loop {
        match pc {
            0x82AB4C10 => {
    //   block [0x82AB4C10..0x82AB4CB4)
	// 82AB4C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB4C14: 481F47F9  bl 0x82ca940c
	ctx.lr = 0x82AB4C18;
	sub_82CA93D0(ctx, base);
	// 82AB4C18: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB4C1C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB4C20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AB4C24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB4C28: 3BA00110  li r29, 0x110
	ctx.r[29].s64 = 272;
	// 82AB4C2C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AB4C30: 808BF7D8  lwz r4, -0x828(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2088 as u32) ) } as u64;
	// 82AB4C34: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AB4C38: 419A0084  beq cr6, 0x82ab4cbc
	if ctx.cr[6].eq {
	pc = 0x82AB4CBC; continue 'dispatch;
	}
	// 82AB4C3C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4C40: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82AB4C44: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82AB4C48: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AB4C4C: B3E10084  sth r31, 0x84(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u16 ) };
	// 82AB4C50: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82AB4C54: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82AB4C58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AB4C5C: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 82AB4C60: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82AB4C64: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4C68: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB4C6C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82AB4C70: 4E800421  bctrl
	ctx.lr = 0x82AB4C74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4C74: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB4C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB4C7C: 419A0038  beq cr6, 0x82ab4cb4
	if ctx.cr[6].eq {
	pc = 0x82AB4CB4; continue 'dispatch;
	}
	// 82AB4C80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4C84: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB4C88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4C8C: 4E800421  bctrl
	ctx.lr = 0x82AB4C90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4C90: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB4C94: 547D003E  slwi r29, r3, 0
	ctx.r[29].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82AB4C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB4C9C: 419A0018  beq cr6, 0x82ab4cb4
	if ctx.cr[6].eq {
	pc = 0x82AB4CB4; continue 'dispatch;
	}
	// 82AB4CA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4CA4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB4CA8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4CAC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82AB4CB0: 4E800421  bctrl
	ctx.lr = 0x82AB4CB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB4CB4 => {
    //   block [0x82AB4CB4..0x82AB4CBC)
	// 82AB4CB4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AB4CB8: 4B83D601  bl 0x822f22b8
	ctx.lr = 0x82AB4CBC;
	sub_822F22B8(ctx, base);
	pc = 0x82AB4CBC; continue 'dispatch;
            }
            0x82AB4CBC => {
    //   block [0x82AB4CBC..0x82AB4D00)
	// 82AB4CBC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AB4CC0: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4CC4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AB4CC8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AB4CCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AB4CD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AB4CD4: 481B417D  bl 0x82c68e50
	ctx.lr = 0x82AB4CD8;
	sub_82C68E50(ctx, base);
	// 82AB4CD8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB4CDC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB4CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB4CE4: 409A0028  bne cr6, 0x82ab4d0c
	if !ctx.cr[6].eq {
	pc = 0x82AB4D0C; continue 'dispatch;
	}
	// 82AB4CE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB4CEC: 419A0014  beq cr6, 0x82ab4d00
	if ctx.cr[6].eq {
	pc = 0x82AB4D00; continue 'dispatch;
	}
	// 82AB4CF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4CF4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4CF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4CFC: 4E800421  bctrl
	ctx.lr = 0x82AB4D00;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB4D00 => {
    //   block [0x82AB4D00..0x82AB4D0C)
	// 82AB4D00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AB4D04: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB4D08: 481F4754  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB4D0C => {
    //   block [0x82AB4D0C..0x82AB4DB8)
	// 82AB4D0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4D10: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB4D14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4D18: 4E800421  bctrl
	ctx.lr = 0x82AB4D1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4D1C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB4D20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AB4D24: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AB4D28: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4D2C: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4D30: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82AB4D34: 4E800421  bctrl
	ctx.lr = 0x82AB4D38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4D38: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4D3C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AB4D40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB4D44: 80A70018  lwz r5, 0x18(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB4D48: 83A60000  lwz r29, 0(r6)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4D4C: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 82AB4D50: 4E800421  bctrl
	ctx.lr = 0x82AB4D54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4D54: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 82AB4D58: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82AB4D5C: 39642B60  addi r11, r4, 0x2b60
	ctx.r[11].s64 = ctx.r[4].s64 + 11104;
	// 82AB4D60: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82AB4D64: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82AB4D68: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AB4D6C: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82AB4D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB4D74: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AB4D78: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82AB4D7C: 9BE10078  stb r31, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u8 ) };
	// 82AB4D80: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AB4D84: 48000045  bl 0x82ab4dc8
	ctx.lr = 0x82AB4D88;
	sub_82AB4DC8(ctx, base);
	// 82AB4D88: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82AB4D8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB4D90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB4D94: 392A2B90  addi r9, r10, 0x2b90
	ctx.r[9].s64 = ctx.r[10].s64 + 11152;
	// 82AB4D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB4D9C: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82AB4DA0: 419A0018  beq cr6, 0x82ab4db8
	if ctx.cr[6].eq {
	pc = 0x82AB4DB8; continue 'dispatch;
	}
	// 82AB4DA4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4DA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AB4DAC: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4DB0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82AB4DB4: 4E800421  bctrl
	ctx.lr = 0x82AB4DB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB4DB8 => {
    //   block [0x82AB4DB8..0x82AB4DC4)
	// 82AB4DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB4DBC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AB4DC0: 481F469C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB4DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB4DC8 size=1260
    let mut pc: u32 = 0x82AB4DC8;
    'dispatch: loop {
        match pc {
            0x82AB4DC8 => {
    //   block [0x82AB4DC8..0x82AB4E28)
	// 82AB4DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB4DCC: 481F4631  bl 0x82ca93fc
	ctx.lr = 0x82AB4DD0;
	sub_82CA93D0(ctx, base);
	// 82AB4DD0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB4DD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AB4DD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AB4DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB4DE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4DE4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB4DE8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB4DEC: 4E800421  bctrl
	ctx.lr = 0x82AB4DF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB4DF0: 392100A8  addi r9, r1, 0xa8
	ctx.r[9].s64 = ctx.r[1].s64 + 168;
	// 82AB4DF4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AB4DF8: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4DFC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AB4E00: 2F070008  cmpwi cr6, r7, 8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 8, &mut ctx.xer);
	// 82AB4E04: 93490000  stw r26, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82AB4E08: 93490004  stw r26, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82AB4E0C: 9B490008  stb r26, 8(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82AB4E10: 4198004C  blt cr6, 0x82ab4e5c
	if ctx.cr[6].lt {
	pc = 0x82AB4E5C; continue 'dispatch;
	}
	// 82AB4E14: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB4E18: 394100A8  addi r10, r1, 0xa8
	ctx.r[10].s64 = ctx.r[1].s64 + 168;
	// 82AB4E1C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82AB4E20: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82AB4E24: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
            }
            0x82AB4E28 => {
    //   block [0x82AB4E28..0x82AB4E5C)
	// 82AB4E28: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4E2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB4E30: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82AB4E34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB4E38: 4200FFF0  bdnz 0x82ab4e28
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AB4E28; continue 'dispatch;
	}
	// 82AB4E3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4E40: 39480008  addi r10, r8, 8
	ctx.r[10].s64 = ctx.r[8].s64 + 8;
	// 82AB4E44: 3927FFF8  addi r9, r7, -8
	ctx.r[9].s64 = ctx.r[7].s64 + -8;
	// 82AB4E48: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 82AB4E4C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82AB4E50: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB4E54: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AB4E58: 48000014  b 0x82ab4e6c
	pc = 0x82AB4E6C; continue 'dispatch;
            }
            0x82AB4E5C => {
    //   block [0x82AB4E5C..0x82AB4E6C)
	// 82AB4E5C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82AB4E60: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 82AB4E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB4E68: 4BF6C081  bl 0x82a20ee8
	ctx.lr = 0x82AB4E6C;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB4E6C; continue 'dispatch;
            }
            0x82AB4E6C => {
    //   block [0x82AB4E6C..0x82AB4E7C)
	// 82AB4E6C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AB4E70: 396100A8  addi r11, r1, 0xa8
	ctx.r[11].s64 = ctx.r[1].s64 + 168;
	// 82AB4E74: 390A92F4  addi r8, r10, -0x6d0c
	ctx.r[8].s64 = ctx.r[10].s64 + -27916;
	// 82AB4E78: 3948000C  addi r10, r8, 0xc
	ctx.r[10].s64 = ctx.r[8].s64 + 12;
	pc = 0x82AB4E7C; continue 'dispatch;
            }
            0x82AB4E7C => {
    //   block [0x82AB4E7C..0x82AB4EA0)
	// 82AB4E7C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4E80: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4E84: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB4E88: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82AB4E8C: 419A0014  beq cr6, 0x82ab4ea0
	if ctx.cr[6].eq {
	pc = 0x82AB4EA0; continue 'dispatch;
	}
	// 82AB4E90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB4E94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB4E98: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB4E9C: 419AFFE0  beq cr6, 0x82ab4e7c
	if ctx.cr[6].eq {
	pc = 0x82AB4E7C; continue 'dispatch;
	}
	pc = 0x82AB4EA0; continue 'dispatch;
            }
            0x82AB4EA0 => {
    //   block [0x82AB4EA0..0x82AB4EC0)
	// 82AB4EA0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AB4EA4: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82AB4EA8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB4EAC: 3BAB7088  addi r29, r11, 0x7088
	ctx.r[29].s64 = ctx.r[11].s64 + 28808;
	// 82AB4EB0: 3B8A2B88  addi r28, r10, 0x2b88
	ctx.r[28].s64 = ctx.r[10].s64 + 11144;
	// 82AB4EB4: 409A00BC  bne cr6, 0x82ab4f70
	if !ctx.cr[6].eq {
	pc = 0x82AB4F70; continue 'dispatch;
	}
	// 82AB4EB8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82AB4EBC: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	pc = 0x82AB4EC0; continue 'dispatch;
            }
            0x82AB4EC0 => {
    //   block [0x82AB4EC0..0x82AB4F1C)
	// 82AB4EC0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB4EC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4EC8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB4ECC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB4ED0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB4ED4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4ED8: 4082FFE8  bne 0x82ab4ec0
	if !ctx.cr[0].eq {
	pc = 0x82AB4EC0; continue 'dispatch;
	}
	// 82AB4EDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AB4EE0: 80BB0014  lwz r5, 0x14(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4EE4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB4EE8: 4B72EF69  bl 0x821e3e50
	ctx.lr = 0x82AB4EEC;
	sub_821E3E50(ctx, base);
	// 82AB4EEC: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AB4EF0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AB4EF4: 38888A80  addi r4, r8, -0x7580
	ctx.r[4].s64 = ctx.r[8].s64 + -30080;
	// 82AB4EF8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB4EFC: 4B777FD5  bl 0x8222ced0
	ctx.lr = 0x82AB4F00;
	sub_8222CED0(ctx, base);
	// 82AB4F00: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AB4F04: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB4F08: 4B7378F1  bl 0x821ec7f8
	ctx.lr = 0x82AB4F0C;
	sub_821EC7F8(ctx, base);
	// 82AB4F0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB4F10: 4B75FEC9  bl 0x82214dd8
	ctx.lr = 0x82AB4F14;
	sub_82214DD8(ctx, base);
	// 82AB4F14: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB4F18: 4B75FEC1  bl 0x82214dd8
	ctx.lr = 0x82AB4F1C;
	sub_82214DD8(ctx, base);
	pc = 0x82AB4F1C; continue 'dispatch;
            }
            0x82AB4F1C => {
    //   block [0x82AB4F1C..0x82AB4F70)
	// 82AB4F1C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4F20: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB4F24: 419800F8  blt cr6, 0x82ab501c
	if ctx.cr[6].lt {
	pc = 0x82AB501C; continue 'dispatch;
	}
	// 82AB4F28: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB4F2C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB4F30: 39010074  addi r8, r1, 0x74
	ctx.r[8].s64 = ctx.r[1].s64 + 116;
	// 82AB4F34: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB4F38: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB4F3C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB4F40: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4F44: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB4F48: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB4F4C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB4F50: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB4F54: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB4F58: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB4F5C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB4F60: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB4F64: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB4F68: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB4F6C: 480000C0  b 0x82ab502c
	pc = 0x82AB502C; continue 'dispatch;
            }
            0x82AB4F70 => {
    //   block [0x82AB4F70..0x82AB4F78)
	// 82AB4F70: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82AB4F74: 396100A8  addi r11, r1, 0xa8
	ctx.r[11].s64 = ctx.r[1].s64 + 168;
	pc = 0x82AB4F78; continue 'dispatch;
            }
            0x82AB4F78 => {
    //   block [0x82AB4F78..0x82AB4F9C)
	// 82AB4F78: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4F7C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB4F80: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB4F84: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82AB4F88: 419A0014  beq cr6, 0x82ab4f9c
	if ctx.cr[6].eq {
	pc = 0x82AB4F9C; continue 'dispatch;
	}
	// 82AB4F8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB4F90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB4F94: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB4F98: 419AFFE0  beq cr6, 0x82ab4f78
	if ctx.cr[6].eq {
	pc = 0x82AB4F78; continue 'dispatch;
	}
	pc = 0x82AB4F9C; continue 'dispatch;
            }
            0x82AB4F9C => {
    //   block [0x82AB4F9C..0x82AB4FB0)
	// 82AB4F9C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB4FA0: 419AFF7C  beq cr6, 0x82ab4f1c
	if ctx.cr[6].eq {
	pc = 0x82AB4F1C; continue 'dispatch;
	}
	// 82AB4FA4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82AB4FA8: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82AB4FAC: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x82AB4FB0; continue 'dispatch;
            }
            0x82AB4FB0 => {
    //   block [0x82AB4FB0..0x82AB501C)
	// 82AB4FB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AB4FB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4FB8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AB4FBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB4FC0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB4FC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB4FC8: 4082FFE8  bne 0x82ab4fb0
	if !ctx.cr[0].eq {
	pc = 0x82AB4FB0; continue 'dispatch;
	}
	// 82AB4FCC: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 82AB4FD0: 80BB0014  lwz r5, 0x14(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB4FD4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB4FD8: 38872B88  addi r4, r7, 0x2b88
	ctx.r[4].s64 = ctx.r[7].s64 + 11144;
	// 82AB4FDC: 4B72EE75  bl 0x821e3e50
	ctx.lr = 0x82AB4FE0;
	sub_821E3E50(ctx, base);
	// 82AB4FE0: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AB4FE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AB4FE8: 38868AB4  addi r4, r6, -0x754c
	ctx.r[4].s64 = ctx.r[6].s64 + -30028;
	// 82AB4FEC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB4FF0: 4B777EE1  bl 0x8222ced0
	ctx.lr = 0x82AB4FF4;
	sub_8222CED0(ctx, base);
	// 82AB4FF4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AB4FF8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB4FFC: 4B7377FD  bl 0x821ec7f8
	ctx.lr = 0x82AB5000;
	sub_821EC7F8(ctx, base);
	// 82AB5000: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB5004: 4B75FDD5  bl 0x82214dd8
	ctx.lr = 0x82AB5008;
	sub_82214DD8(ctx, base);
	// 82AB5008: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB500C: 4B75FDCD  bl 0x82214dd8
	ctx.lr = 0x82AB5010;
	sub_82214DD8(ctx, base);
	// 82AB5010: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AB5014: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AB5018: 481F4434  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB501C => {
    //   block [0x82AB501C..0x82AB502C)
	// 82AB501C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB5020: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AB5024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB5028: 4BF6BEC1  bl 0x82a20ee8
	ctx.lr = 0x82AB502C;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB502C; continue 'dispatch;
            }
            0x82AB502C => {
    //   block [0x82AB502C..0x82AB5064)
	// 82AB502C: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AB5030: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB5034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB5038: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AB503C: 419A0028  beq cr6, 0x82ab5064
	if ctx.cr[6].eq {
	pc = 0x82AB5064; continue 'dispatch;
	}
	// 82AB5040: 89210072  lbz r9, 0x72(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(114 as u32) ) } as u64;
	// 82AB5044: 89610074  lbz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AB5048: 89410071  lbz r10, 0x71(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(113 as u32) ) } as u64;
	// 82AB504C: 89010077  lbz r8, 0x77(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82AB5050: 99210071  stb r9, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[9].u8 ) };
	// 82AB5054: 99610073  stb r11, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[11].u8 ) };
	// 82AB5058: 99410072  stb r10, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[10].u8 ) };
	// 82AB505C: 99010070  stb r8, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u8 ) };
	// 82AB5060: 83C10070  lwz r30, 0x70(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x82AB5064; continue 'dispatch;
            }
            0x82AB5064 => {
    //   block [0x82AB5064..0x82AB50CC)
	// 82AB5064: 2F1E0021  cmpwi cr6, r30, 0x21
	ctx.cr[6].compare_i32(ctx.r[30].s32, 33, &mut ctx.xer);
	// 82AB5068: 419800EC  blt cr6, 0x82ab5154
	if ctx.cr[6].lt {
	pc = 0x82AB5154; continue 'dispatch;
	}
	// 82AB506C: 2F1E0024  cmpwi cr6, r30, 0x24
	ctx.cr[6].compare_i32(ctx.r[30].s32, 36, &mut ctx.xer);
	// 82AB5070: 419900E4  bgt cr6, 0x82ab5154
	if ctx.cr[6].gt {
	pc = 0x82AB5154; continue 'dispatch;
	}
	// 82AB5074: 93DB0090  stw r30, 0x90(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 82AB5078: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB507C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AB5080: 4198004C  blt cr6, 0x82ab50cc
	if ctx.cr[6].lt {
	pc = 0x82AB50CC; continue 'dispatch;
	}
	// 82AB5084: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82AB5088: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB508C: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 82AB5090: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5094: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82AB5098: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82AB509C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB50A0: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82AB50A4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82AB50A8: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82AB50AC: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82AB50B0: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82AB50B4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82AB50B8: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82AB50BC: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82AB50C0: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82AB50C4: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB50C8: 48000014  b 0x82ab50dc
	pc = 0x82AB50DC; continue 'dispatch;
            }
            0x82AB50CC => {
    //   block [0x82AB50CC..0x82AB50DC)
	// 82AB50CC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82AB50D0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AB50D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB50D8: 4BF6BE11  bl 0x82a20ee8
	ctx.lr = 0x82AB50DC;
	sub_82A20EE8(ctx, base);
	pc = 0x82AB50DC; continue 'dispatch;
            }
            0x82AB50DC => {
    //   block [0x82AB50DC..0x82AB5110)
	// 82AB50DC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AB50E0: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB50E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB50E8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AB50EC: 419A0024  beq cr6, 0x82ab5110
	if ctx.cr[6].eq {
	pc = 0x82AB5110; continue 'dispatch;
	}
	// 82AB50F0: 89610071  lbz r11, 0x71(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(113 as u32) ) } as u64;
	// 82AB50F4: 89410072  lbz r10, 0x72(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(114 as u32) ) } as u64;
	// 82AB50F8: 8921007B  lbz r9, 0x7b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(123 as u32) ) } as u64;
	// 82AB50FC: 89010078  lbz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AB5100: 99610072  stb r11, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[11].u8 ) };
	// 82AB5104: 99410071  stb r10, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[10].u8 ) };
	// 82AB5108: 99210070  stb r9, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u8 ) };
	// 82AB510C: 99010073  stb r8, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[8].u8 ) };
	pc = 0x82AB5110; continue 'dispatch;
            }
            0x82AB5110 => {
    //   block [0x82AB5110..0x82AB5154)
	// 82AB5110: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB5118: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB511C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB5120: 4E800421  bctrl
	ctx.lr = 0x82AB5124;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB5124: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AB5128: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AB512C: 7D194850  subf r8, r25, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[25].s64;
	// 82AB5130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB5134: 7CE34214  add r7, r3, r8
	ctx.r[7].u64 = ctx.r[3].u64 + ctx.r[8].u64;
	// 82AB5138: 387B0020  addi r3, r27, 0x20
	ctx.r[3].s64 = ctx.r[27].s64 + 32;
	// 82AB513C: 90FB0094  stw r7, 0x94(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82AB5140: 480DA079  bl 0x82b8f1b8
	ctx.lr = 0x82AB5144;
	sub_82B8F1B8(ctx, base);
	// 82AB5144: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AB5148: 9B5B006E  stb r26, 0x6e(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(110 as u32), ctx.r[26].u8 ) };
	// 82AB514C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AB5150: 481F42FC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB5154 => {
    //   block [0x82AB5154..0x82AB5158)
	// 82AB5154: 93410088  stw r26, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[26].u32 ) };
	pc = 0x82AB5158; continue 'dispatch;
            }
            0x82AB5158 => {
    //   block [0x82AB5158..0x82AB52B4)
	// 82AB5158: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB515C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB5160: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB5164: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB5168: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB516C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB5170: 4082FFE8  bne 0x82ab5158
	if !ctx.cr[0].eq {
	pc = 0x82AB5158; continue 'dispatch;
	}
	// 82AB5174: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AB5178: 80BB0014  lwz r5, 0x14(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB517C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB5180: 4B72ECD1  bl 0x821e3e50
	ctx.lr = 0x82AB5184;
	sub_821E3E50(ctx, base);
	// 82AB5184: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AB5188: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82AB518C: 4B899B35  bl 0x8234ecc0
	ctx.lr = 0x82AB5190;
	sub_8234ECC0(ctx, base);
	// 82AB5190: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82AB5194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB5198: 38898B04  addi r4, r9, -0x74fc
	ctx.r[4].s64 = ctx.r[9].s64 + -29948;
	// 82AB519C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82AB51A0: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AB51A4: 4B777D2D  bl 0x8222ced0
	ctx.lr = 0x82AB51A8;
	sub_8222CED0(ctx, base);
	// 82AB51A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB51AC: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AB51B0: 4B737649  bl 0x821ec7f8
	ctx.lr = 0x82AB51B4;
	sub_821EC7F8(ctx, base);
	// 82AB51B4: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82AB51B8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AB51BC: 4B73B085  bl 0x821f0240
	ctx.lr = 0x82AB51C0;
	sub_821F0240(ctx, base);
	// 82AB51C0: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82AB51C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AB51C8: 38888AEC  addi r4, r8, -0x7514
	ctx.r[4].s64 = ctx.r[8].s64 + -29972;
	// 82AB51CC: 4B7257F5  bl 0x821da9c0
	ctx.lr = 0x82AB51D0;
	sub_821DA9C0(ctx, base);
	// 82AB51D0: 38800021  li r4, 0x21
	ctx.r[4].s64 = 33;
	// 82AB51D4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AB51D8: 4B899AE9  bl 0x8234ecc0
	ctx.lr = 0x82AB51DC;
	sub_8234ECC0(ctx, base);
	// 82AB51DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AB51E0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AB51E4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AB51E8: 4B72DF21  bl 0x821e3108
	ctx.lr = 0x82AB51EC;
	sub_821E3108(ctx, base);
	// 82AB51EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AB51F0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AB51F4: 4B73B04D  bl 0x821f0240
	ctx.lr = 0x82AB51F8;
	sub_821F0240(ctx, base);
	// 82AB51F8: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82AB51FC: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AB5200: 38878ADC  addi r4, r7, -0x7524
	ctx.r[4].s64 = ctx.r[7].s64 + -29988;
	// 82AB5204: 4B7257BD  bl 0x821da9c0
	ctx.lr = 0x82AB5208;
	sub_821DA9C0(ctx, base);
	// 82AB5208: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 82AB520C: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82AB5210: 4B899AB1  bl 0x8234ecc0
	ctx.lr = 0x82AB5214;
	sub_8234ECC0(ctx, base);
	// 82AB5214: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AB5218: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82AB521C: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82AB5220: 4B72DEE9  bl 0x821e3108
	ctx.lr = 0x82AB5224;
	sub_821E3108(ctx, base);
	// 82AB5224: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AB5228: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB522C: 4B73B015  bl 0x821f0240
	ctx.lr = 0x82AB5230;
	sub_821F0240(ctx, base);
	// 82AB5230: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82AB5234: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB5238: 38868AD4  addi r4, r6, -0x752c
	ctx.r[4].s64 = ctx.r[6].s64 + -29996;
	// 82AB523C: 4B725785  bl 0x821da9c0
	ctx.lr = 0x82AB5240;
	sub_821DA9C0(ctx, base);
	// 82AB5240: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82AB5244: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AB5248: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AB524C: 4B72DEBD  bl 0x821e3108
	ctx.lr = 0x82AB5250;
	sub_821E3108(ctx, base);
	// 82AB5250: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB5254: 4B75FB85  bl 0x82214dd8
	ctx.lr = 0x82AB5258;
	sub_82214DD8(ctx, base);
	// 82AB5258: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82AB525C: 4B75FB7D  bl 0x82214dd8
	ctx.lr = 0x82AB5260;
	sub_82214DD8(ctx, base);
	// 82AB5260: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AB5264: 4B75FB75  bl 0x82214dd8
	ctx.lr = 0x82AB5268;
	sub_82214DD8(ctx, base);
	// 82AB5268: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AB526C: 4B75FB6D  bl 0x82214dd8
	ctx.lr = 0x82AB5270;
	sub_82214DD8(ctx, base);
	// 82AB5270: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AB5274: 4B75FB65  bl 0x82214dd8
	ctx.lr = 0x82AB5278;
	sub_82214DD8(ctx, base);
	// 82AB5278: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AB527C: 4B75FB5D  bl 0x82214dd8
	ctx.lr = 0x82AB5280;
	sub_82214DD8(ctx, base);
	// 82AB5280: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82AB5284: 4B75FB55  bl 0x82214dd8
	ctx.lr = 0x82AB5288;
	sub_82214DD8(ctx, base);
	// 82AB5288: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AB528C: 4B75FB4D  bl 0x82214dd8
	ctx.lr = 0x82AB5290;
	sub_82214DD8(ctx, base);
	// 82AB5290: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82AB5294: 4B75FB45  bl 0x82214dd8
	ctx.lr = 0x82AB5298;
	sub_82214DD8(ctx, base);
	// 82AB5298: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AB529C: 4B75FB3D  bl 0x82214dd8
	ctx.lr = 0x82AB52A0;
	sub_82214DD8(ctx, base);
	// 82AB52A0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AB52A4: 4B75FB35  bl 0x82214dd8
	ctx.lr = 0x82AB52A8;
	sub_82214DD8(ctx, base);
	// 82AB52A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AB52AC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82AB52B0: 481F419C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB52B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB52B8 size=296
    let mut pc: u32 = 0x82AB52B8;
    'dispatch: loop {
        match pc {
            0x82AB52B8 => {
    //   block [0x82AB52B8..0x82AB5300)
	// 82AB52B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB52BC: 481F4145  bl 0x82ca9400
	ctx.lr = 0x82AB52C0;
	sub_82CA93D0(ctx, base);
	// 82AB52C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB52C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB52C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AB52CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB52D0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB52D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB52D8: 4E800421  bctrl
	ctx.lr = 0x82AB52DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB52DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AB52E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB52E4: 4BFFFAE5  bl 0x82ab4dc8
	ctx.lr = 0x82AB52E8;
	sub_82AB4DC8(ctx, base);
	// 82AB52E8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB52EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB52F0: 409A0010  bne cr6, 0x82ab5300
	if !ctx.cr[6].eq {
	pc = 0x82AB5300; continue 'dispatch;
	}
	// 82AB52F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AB52F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB52FC: 481F4154  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB5300 => {
    //   block [0x82AB5300..0x82AB5318)
	// 82AB5300: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB5304: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AB5308: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82AB530C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB5310: 409900C4  ble cr6, 0x82ab53d4
	if !ctx.cr[6].gt {
	pc = 0x82AB53D4; continue 'dispatch;
	}
	// 82AB5314: 3BDF0098  addi r30, r31, 0x98
	ctx.r[30].s64 = ctx.r[31].s64 + 152;
	pc = 0x82AB5318; continue 'dispatch;
            }
            0x82AB5318 => {
    //   block [0x82AB5318..0x82AB534C)
	// 82AB5318: 817EFFBC  lwz r11, -0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-68 as u32) ) } as u64;
	// 82AB531C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB5320: 409900A0  ble cr6, 0x82ab53c0
	if !ctx.cr[6].gt {
	pc = 0x82AB53C0; continue 'dispatch;
	}
	// 82AB5324: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82AB5328: 4B769F31  bl 0x8221f258
	ctx.lr = 0x82AB532C;
	sub_8221F258(ctx, base);
	// 82AB532C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB5330: 419A001C  beq cr6, 0x82ab534c
	if ctx.cr[6].eq {
	pc = 0x82AB534C; continue 'dispatch;
	}
	// 82AB5334: 38DF0014  addi r6, r31, 0x14
	ctx.r[6].s64 = ctx.r[31].s64 + 20;
	// 82AB5338: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AB533C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB5340: 4BFFB6F1  bl 0x82ab0a30
	ctx.lr = 0x82AB5344;
	sub_82AB0A30(ctx, base);
	// 82AB5344: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB5348: 48000008  b 0x82ab5350
	pc = 0x82AB5350; continue 'dispatch;
            }
            0x82AB534C => {
    //   block [0x82AB534C..0x82AB5350)
	// 82AB534C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x82AB5350; continue 'dispatch;
            }
            0x82AB5350 => {
    //   block [0x82AB5350..0x82AB5360)
	// 82AB5350: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB5358: 419A0040  beq cr6, 0x82ab5398
	if ctx.cr[6].eq {
	pc = 0x82AB5398; continue 'dispatch;
	}
	// 82AB535C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB5360; continue 'dispatch;
            }
            0x82AB5360 => {
    //   block [0x82AB5360..0x82AB5394)
	// 82AB5360: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB5364: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB5368: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB536C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB5370: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB5374: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB5378: 4082FFE8  bne 0x82ab5360
	if !ctx.cr[0].eq {
	pc = 0x82AB5360; continue 'dispatch;
	}
	// 82AB537C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB5380: 409A0014  bne cr6, 0x82ab5394
	if !ctx.cr[6].eq {
	pc = 0x82AB5394; continue 'dispatch;
	}
	// 82AB5384: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5388: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB538C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB5390: 4E800421  bctrl
	ctx.lr = 0x82AB5394;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB5394 => {
    //   block [0x82AB5394..0x82AB5398)
	// 82AB5394: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82AB5398; continue 'dispatch;
            }
            0x82AB5398 => {
    //   block [0x82AB5398..0x82AB53C0)
	// 82AB5398: 57A3003E  slwi r3, r29, 0
	ctx.r[3].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB539C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AB53A0: 80FF0090  lwz r7, 0x90(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AB53A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AB53A8: 88DF0080  lbz r6, 0x80(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AB53AC: 88BF006E  lbz r5, 0x6e(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(110 as u32) ) } as u64;
	// 82AB53B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB53B4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB53B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB53BC: 4E800421  bctrl
	ctx.lr = 0x82AB53C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB53C0 => {
    //   block [0x82AB53C0..0x82AB53D4)
	// 82AB53C0: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB53C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82AB53C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AB53CC: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82AB53D0: 4198FF48  blt cr6, 0x82ab5318
	if ctx.cr[6].lt {
	pc = 0x82AB5318; continue 'dispatch;
	}
	pc = 0x82AB53D4; continue 'dispatch;
            }
            0x82AB53D4 => {
    //   block [0x82AB53D4..0x82AB53E0)
	// 82AB53D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AB53D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB53DC: 481F4074  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB53E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB53E0 size=84
    let mut pc: u32 = 0x82AB53E0;
    'dispatch: loop {
        match pc {
            0x82AB53E0 => {
    //   block [0x82AB53E0..0x82AB53E8)
	// 82AB53E0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB53E4: 39630098  addi r11, r3, 0x98
	ctx.r[11].s64 = ctx.r[3].s64 + 152;
	pc = 0x82AB53E8; continue 'dispatch;
            }
            0x82AB53E8 => {
    //   block [0x82AB53E8..0x82AB5400)
	// 82AB53E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB53EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB53F0: 419A0010  beq cr6, 0x82ab5400
	if ctx.cr[6].eq {
	pc = 0x82AB5400; continue 'dispatch;
	}
	// 82AB53F4: 894A0047  lbz r10, 0x47(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(71 as u32) ) } as u64;
	// 82AB53F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB53FC: 409A001C  bne cr6, 0x82ab5418
	if !ctx.cr[6].eq {
	pc = 0x82AB5418; continue 'dispatch;
	}
	pc = 0x82AB5400; continue 'dispatch;
            }
            0x82AB5400 => {
    //   block [0x82AB5400..0x82AB5418)
	// 82AB5400: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AB5404: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AB5408: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 82AB540C: 4198FFDC  blt cr6, 0x82ab53e8
	if ctx.cr[6].lt {
	pc = 0x82AB53E8; continue 'dispatch;
	}
	// 82AB5410: 3D207FFF  lis r9, 0x7fff
	ctx.r[9].s64 = 2147418112;
	// 82AB5414: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	pc = 0x82AB5418; continue 'dispatch;
            }
            0x82AB5418 => {
    //   block [0x82AB5418..0x82AB5434)
	// 82AB5418: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 82AB541C: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 82AB5420: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AB5424: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82AB5428: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82AB542C: 68E30001  xori r3, r7, 1
	ctx.r[3].u64 = ctx.r[7].u64 ^ 1;
	// 82AB5430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB5438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB5438 size=168
    let mut pc: u32 = 0x82AB5438;
    'dispatch: loop {
        match pc {
            0x82AB5438 => {
    //   block [0x82AB5438..0x82AB5460)
	// 82AB5438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB543C: 481F3FD1  bl 0x82ca940c
	ctx.lr = 0x82AB5440;
	sub_82CA93D0(ctx, base);
	// 82AB5440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB5444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB5448: 480652F1  bl 0x82b1a738
	ctx.lr = 0x82AB544C;
	sub_82B1A738(ctx, base);
	// 82AB544C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB5450: 480653D1  bl 0x82b1a820
	ctx.lr = 0x82AB5454;
	sub_82B1A820(ctx, base);
	// 82AB5454: 3BFF00A4  addi r31, r31, 0xa4
	ctx.r[31].s64 = ctx.r[31].s64 + 164;
	// 82AB5458: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 82AB545C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82AB5460; continue 'dispatch;
            }
            0x82AB5460 => {
    //   block [0x82AB5460..0x82AB5470)
	// 82AB5460: 807FFFF4  lwz r3, -0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82AB5464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB5468: 419A0040  beq cr6, 0x82ab54a8
	if ctx.cr[6].eq {
	pc = 0x82AB54A8; continue 'dispatch;
	}
	// 82AB546C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB5470; continue 'dispatch;
            }
            0x82AB5470 => {
    //   block [0x82AB5470..0x82AB54A4)
	// 82AB5470: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB5474: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB5478: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB547C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB5480: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB5484: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB5488: 4082FFE8  bne 0x82ab5470
	if !ctx.cr[0].eq {
	pc = 0x82AB5470; continue 'dispatch;
	}
	// 82AB548C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB5490: 409A0014  bne cr6, 0x82ab54a4
	if !ctx.cr[6].eq {
	pc = 0x82AB54A4; continue 'dispatch;
	}
	// 82AB5494: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5498: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB549C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB54A0: 4E800421  bctrl
	ctx.lr = 0x82AB54A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB54A4 => {
    //   block [0x82AB54A4..0x82AB54A8)
	// 82AB54A4: 93DFFFF4  stw r30, -0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-12 as u32), ctx.r[30].u32 ) };
	pc = 0x82AB54A8; continue 'dispatch;
            }
            0x82AB54A8 => {
    //   block [0x82AB54A8..0x82AB54CC)
	// 82AB54A8: 93DFFFF4  stw r30, -0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-12 as u32), ctx.r[30].u32 ) };
	// 82AB54AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB54B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB54B4: 419A0018  beq cr6, 0x82ab54cc
	if ctx.cr[6].eq {
	pc = 0x82AB54CC; continue 'dispatch;
	}
	// 82AB54B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB54BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB54C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB54C4: 4E800421  bctrl
	ctx.lr = 0x82AB54C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB54C8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            0x82AB54CC => {
    //   block [0x82AB54CC..0x82AB54E0)
	// 82AB54CC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AB54D0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82AB54D4: 4082FF8C  bne 0x82ab5460
	if !ctx.cr[0].eq {
	pc = 0x82AB5460; continue 'dispatch;
	}
	// 82AB54D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB54DC: 481F3F80  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB54E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB54E0 size=292
    let mut pc: u32 = 0x82AB54E0;
    'dispatch: loop {
        match pc {
            0x82AB54E0 => {
    //   block [0x82AB54E0..0x82AB5554)
	// 82AB54E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB54E4: 481F3F25  bl 0x82ca9408
	ctx.lr = 0x82AB54E8;
	sub_82CA93D0(ctx, base);
	// 82AB54E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB54EC: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82AB54F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB54F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AB54F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB54FC: 409A0058  bne cr6, 0x82ab5554
	if !ctx.cr[6].eq {
	pc = 0x82AB5554; continue 'dispatch;
	}
	// 82AB5500: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82AB5504: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82AB5508: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	pc = 0x82AB5554; continue 'dispatch;
            }
            0x82AB5554 => {
    //   block [0x82AB5554..0x82AB5604)
	// 82AB5554: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB5558: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB555C: 409A0020  bne cr6, 0x82ab557c
	if !ctx.cr[6].eq {
	pc = 0x82AB557C; continue 'dispatch;
	}
	// 82AB5560: 897C0046  lbz r11, 0x46(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(70 as u32) ) } as u64;
	// 82AB5564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB5568: 419A0014  beq cr6, 0x82ab557c
	if ctx.cr[6].eq {
	pc = 0x82AB557C; continue 'dispatch;
	}
	// 82AB556C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB5570: 4BFFF181  bl 0x82ab46f0
	ctx.lr = 0x82AB5574;
	sub_82AB46F0(ctx, base);
	// 82AB5574: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82AB5578: 4199FFB8  bgt cr6, 0x82ab5530
	if ctx.cr[6].gt {
	pc = 0x82AB5530; continue 'dispatch;
	}
	// 82AB557C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB5580: 480651B9  bl 0x82b1a738
	ctx.lr = 0x82AB5584;
	sub_82B1A738(ctx, base);
	// 82AB5584: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AB5588: 3BFF0098  addi r31, r31, 0x98
	ctx.r[31].s64 = ctx.r[31].s64 + 152;
	// 82AB558C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB5590: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 82AB5594: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5598: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB559C: 409A0054  bne cr6, 0x82ab55f0
	if !ctx.cr[6].eq {
	pc = 0x82AB55F0; continue 'dispatch;
	}
	// 82AB55A0: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82AB55A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB55A8: 419A0040  beq cr6, 0x82ab55e8
	if ctx.cr[6].eq {
	pc = 0x82AB55E8; continue 'dispatch;
	}
	// 82AB55AC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82AB55B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB55B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB55B8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB55BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB55C0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB55C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB55C8: 4082FFE8  bne 0x82ab55b0
	if !ctx.cr[0].eq {
	pc = 0x82AB55B0; continue 'dispatch;
	}
	// 82AB55CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB55D0: 409A0014  bne cr6, 0x82ab55e4
	if !ctx.cr[6].eq {
	pc = 0x82AB55E4; continue 'dispatch;
	}
	// 82AB55D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB55D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB55DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB55E0: 4E800421  bctrl
	ctx.lr = 0x82AB55E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB55E4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AB55E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AB55EC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AB55F0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AB55F4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82AB55F8: 4082FF9C  bne 0x82ab5594
	if !ctx.cr[0].eq {
	pc = 0x82AB5594; continue 'dispatch;
	}
	// 82AB55FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB5600: 481F3E58  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB5608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB5608 size=224
    let mut pc: u32 = 0x82AB5608;
    'dispatch: loop {
        match pc {
            0x82AB5608 => {
    //   block [0x82AB5608..0x82AB563C)
	// 82AB5608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB560C: 481F3DF9  bl 0x82ca9404
	ctx.lr = 0x82AB5610;
	sub_82CA93D0(ctx, base);
	// 82AB5610: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB5614: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB5618: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AB561C: 3BEB5784  addi r31, r11, 0x5784
	ctx.r[31].s64 = ctx.r[11].s64 + 22404;
	// 82AB5620: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AB5624: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5628: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB562C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB5630: 7D491E71  srawi. r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AB5634: 418200AC  beq 0x82ab56e0
	if ctx.cr[0].eq {
	pc = 0x82AB56E0; continue 'dispatch;
	}
	// 82AB5638: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82AB563C; continue 'dispatch;
            }
            0x82AB563C => {
    //   block [0x82AB563C..0x82AB5650)
	// 82AB563C: 7FBE5A14  add r29, r30, r11
	ctx.r[29].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82AB5640: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 82AB5644: 409A000C  bne cr6, 0x82ab5650
	if !ctx.cr[6].eq {
	pc = 0x82AB5650; continue 'dispatch;
	}
	// 82AB5648: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB564C: 480ED17D  bl 0x82ba27c8
	ctx.lr = 0x82AB5650;
	sub_82BA27C8(ctx, base);
	pc = 0x82AB5650; continue 'dispatch;
            }
            0x82AB5650 => {
    //   block [0x82AB5650..0x82AB56B4)
	// 82AB5650: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5654: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB5658: 4B740C19  bl 0x821f6270
	ctx.lr = 0x82AB565C;
	sub_821F6270(ctx, base);
	// 82AB565C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82AB5660: 419A0060  beq cr6, 0x82ab56c0
	if ctx.cr[6].eq {
	pc = 0x82AB56C0; continue 'dispatch;
	}
	// 82AB5664: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5668: 48088161  bl 0x82b3d7c8
	ctx.lr = 0x82AB566C;
	sub_82B3D7C8(ctx, base);
	// 82AB566C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5670: 4B7666C9  bl 0x8221bd38
	ctx.lr = 0x82AB5674;
	sub_8221BD38(ctx, base);
	// 82AB5674: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB5678: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB567C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82AB5680: 7D3E5214  add r9, r30, r10
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82AB5684: 810BFFF8  lwz r8, -8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB5688: 7D1E512E  stwx r8, r30, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 82AB568C: 80EBFFFC  lwz r7, -4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82AB5690: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AB5694: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5698: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB569C: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB56A0: 54C50038  rlwinm r5, r6, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82AB56A4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82AB56A8: 419A000C  beq cr6, 0x82ab56b4
	if ctx.cr[6].eq {
	pc = 0x82AB56B4; continue 'dispatch;
	}
	// 82AB56AC: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82AB56B0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82AB56B4; continue 'dispatch;
            }
            0x82AB56B4 => {
    //   block [0x82AB56B4..0x82AB56C0)
	// 82AB56B4: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 82AB56B8: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82AB56BC: 4800000C  b 0x82ab56c8
	pc = 0x82AB56C8; continue 'dispatch;
            }
            0x82AB56C0 => {
    //   block [0x82AB56C0..0x82AB56C8)
	// 82AB56C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB56C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82AB56C8; continue 'dispatch;
            }
            0x82AB56C8 => {
    //   block [0x82AB56C8..0x82AB56E0)
	// 82AB56C8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB56CC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82AB56D0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AB56D4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82AB56D8: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB56DC: 4198FF60  blt cr6, 0x82ab563c
	if ctx.cr[6].lt {
	pc = 0x82AB563C; continue 'dispatch;
	}
	pc = 0x82AB56E0; continue 'dispatch;
            }
            0x82AB56E0 => {
    //   block [0x82AB56E0..0x82AB56E8)
	// 82AB56E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB56E4: 481F3D70  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB5708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB5708 size=220
    let mut pc: u32 = 0x82AB5708;
    'dispatch: loop {
        match pc {
            0x82AB5708 => {
    //   block [0x82AB5708..0x82AB5758)
	// 82AB5708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB570C: 481F3CFD  bl 0x82ca9408
	ctx.lr = 0x82AB5710;
	sub_82CA93D0(ctx, base);
	// 82AB5710: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB5714: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB5718: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82AB571C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82AB5720: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82AB5724: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AB5728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB572C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AB5730: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AB5734: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AB5738: 99610064  stb r11, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 82AB573C: 4B770CC5  bl 0x82226400
	ctx.lr = 0x82AB5740;
	sub_82226400(ctx, base);
	// 82AB5740: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB5744: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB5748: 419A0090  beq cr6, 0x82ab57d8
	if ctx.cr[6].eq {
	pc = 0x82AB57D8; continue 'dispatch;
	}
	// 82AB574C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB5750: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 82AB5754: 3BAB5774  addi r29, r11, 0x5774
	ctx.r[29].s64 = ctx.r[11].s64 + 22388;
	pc = 0x82AB5758; continue 'dispatch;
            }
            0x82AB5758 => {
    //   block [0x82AB5758..0x82AB57B0)
	// 82AB5758: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB575C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AB5760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB5764: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB5768: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB576C: 4E800421  bctrl
	ctx.lr = 0x82AB5770;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB5770: 807E6F44  lwz r3, 0x6f44(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28484 as u32) ) } as u64;
	// 82AB5774: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AB5778: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB577C: 81090060  lwz r8, 0x60(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AB5780: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82AB5784: 4E800421  bctrl
	ctx.lr = 0x82AB5788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB5788: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AB578C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82AB5790: 419A0020  beq cr6, 0x82ab57b0
	if ctx.cr[6].eq {
	pc = 0x82AB57B0; continue 'dispatch;
	}
	// 82AB5794: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5798: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AB579C: 809E6F44  lwz r4, 0x6f44(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28484 as u32) ) } as u64;
	// 82AB57A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB57A4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82AB57A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB57AC: 4E800421  bctrl
	ctx.lr = 0x82AB57B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB57B0 => {
    //   block [0x82AB57B0..0x82AB57D0)
	// 82AB57B0: 83FF0034  lwz r31, 0x34(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AB57B4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AB57B8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB57BC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AB57C0: 409A0010  bne cr6, 0x82ab57d0
	if !ctx.cr[6].eq {
	pc = 0x82AB57D0; continue 'dispatch;
	}
	// 82AB57C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB57C8: 4B770C39  bl 0x82226400
	ctx.lr = 0x82AB57CC;
	sub_82226400(ctx, base);
	// 82AB57CC: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x82AB57D0; continue 'dispatch;
            }
            0x82AB57D0 => {
    //   block [0x82AB57D0..0x82AB57D8)
	// 82AB57D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB57D4: 409AFF84  bne cr6, 0x82ab5758
	if !ctx.cr[6].eq {
	pc = 0x82AB5758; continue 'dispatch;
	}
	pc = 0x82AB57D8; continue 'dispatch;
            }
            0x82AB57D8 => {
    //   block [0x82AB57D8..0x82AB57E4)
	// 82AB57D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB57DC: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82AB57E0: 481F3C78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB57E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB57E8 size=312
    let mut pc: u32 = 0x82AB57E8;
    'dispatch: loop {
        match pc {
            0x82AB57E8 => {
    //   block [0x82AB57E8..0x82AB5870)
	// 82AB57E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB57EC: 481F3C1D  bl 0x82ca9408
	ctx.lr = 0x82AB57F0;
	sub_82CA93D0(ctx, base);
	// 82AB57F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB57F4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB57F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB57FC: 3B8B5774  addi r28, r11, 0x5774
	ctx.r[28].s64 = ctx.r[11].s64 + 22388;
	// 82AB5800: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB5804: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB5808: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82AB580C: 4B994CB5  bl 0x8244a4c0
	ctx.lr = 0x82AB5810;
	sub_8244A4C0(ctx, base);
	// 82AB5810: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5814: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82AB5818: 409A0090  bne cr6, 0x82ab58a8
	if !ctx.cr[6].eq {
	pc = 0x82AB58A8; continue 'dispatch;
	}
	// 82AB581C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82AB5820: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB5824: 3D2082AB  lis r9, -0x7d55
	ctx.r[9].s64 = -2102722560;
	// 82AB5828: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AB582C: 386956E8  addi r3, r9, 0x56e8
	ctx.r[3].s64 = ctx.r[9].s64 + 22248;
	// 82AB5830: 916A6F44  stw r11, 0x6f44(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28484 as u32), ctx.r[11].u32 ) };
	// 82AB5834: 48001D45  bl 0x82ab7578
	ctx.lr = 0x82AB5838;
	sub_82AB7578(ctx, base);
	// 82AB5838: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB583C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5840: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB5844: 7D0A1671  srawi. r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB5848: 418200D0  beq 0x82ab5918
	if ctx.cr[0].eq {
	pc = 0x82AB5918; continue 'dispatch;
	}
	// 82AB584C: 57E906BE  clrlwi r9, r31, 0x1a
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 82AB5850: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AB5854: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AB5858: 7CE64836  sld r6, r7, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[7].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82AB585C: 7D044836  sld r4, r8, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = (ctx.r[8].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82AB5860: 57E5E8F8  rlwinm r5, r31, 0x1d, 3, 0x1c
	ctx.r[5].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 82AB5864: 7CC330F8  nor r3, r6, r6
	ctx.r[3].u64 = !(ctx.r[6].u64 | ctx.r[6].u64);
	// 82AB5868: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB586C: 48000008  b 0x82ab5874
	pc = 0x82AB5874; continue 'dispatch;
            }
            0x82AB5870 => {
    //   block [0x82AB5870..0x82AB5874)
	// 82AB5870: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82AB5874; continue 'dispatch;
            }
            0x82AB5874 => {
    //   block [0x82AB5874..0x82AB58A8)
	// 82AB5874: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AB5878: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB587C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82AB5880: 7D654214  add r11, r5, r8
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[8].u64;
	// 82AB5884: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 82AB5888: E8CB0008  ld r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82AB588C: 7C663038  and r6, r3, r6
	ctx.r[6].u64 = ctx.r[3].u64 & ctx.r[6].u64;
	// 82AB5890: 7CC62378  or r6, r6, r4
	ctx.r[6].u64 = ctx.r[6].u64 | ctx.r[4].u64;
	// 82AB5894: F8CB0008  std r6, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u64 ) };
	// 82AB5898: 98E80019  stb r7, 0x19(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(25 as u32), ctx.r[7].u8 ) };
	// 82AB589C: 4082FFD4  bne 0x82ab5870
	if !ctx.cr[0].eq {
	pc = 0x82AB5870; continue 'dispatch;
	}
	// 82AB58A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB58A4: 481F3BB4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB58A8 => {
    //   block [0x82AB58A8..0x82AB58E4)
	// 82AB58A8: 817E01DC  lwz r11, 0x1dc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(476 as u32) ) } as u64;
	// 82AB58AC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82AB58B0: 811E01D8  lwz r8, 0x1d8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(472 as u32) ) } as u64;
	// 82AB58B4: 387E01D4  addi r3, r30, 0x1d4
	ctx.r[3].s64 = ctx.r[30].s64 + 468;
	// 82AB58B8: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82AB58BC: 7CEA1671  srawi. r10, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB58C0: 93C96F44  stw r30, 0x6f44(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28484 as u32), ctx.r[30].u32 ) };
	// 82AB58C4: 41820050  beq 0x82ab5914
	if ctx.cr[0].eq {
	pc = 0x82AB5914; continue 'dispatch;
	}
	// 82AB58C8: 57EB06BE  clrlwi r11, r31, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 82AB58CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AB58D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB58D4: 7CE85836  sld r8, r7, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = (ctx.r[7].u64) << ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82AB58D8: 57E5E8F8  rlwinm r5, r31, 0x1d, 3, 0x1c
	ctx.r[5].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 82AB58DC: 7D245836  sld r4, r9, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = (ctx.r[9].u64) << ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82AB58E0: 7D1F40F8  nor r31, r8, r8
	ctx.r[31].u64 = !(ctx.r[8].u64 | ctx.r[8].u64);
	pc = 0x82AB58E4; continue 'dispatch;
            }
            0x82AB58E4 => {
    //   block [0x82AB58E4..0x82AB5914)
	// 82AB58E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB58E8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB58EC: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AB58F0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82AB58F4: 7D654214  add r11, r5, r8
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[8].u64;
	// 82AB58F8: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 82AB58FC: E8CB0008  ld r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82AB5900: 7CC6F838  and r6, r6, r31
	ctx.r[6].u64 = ctx.r[6].u64 & ctx.r[31].u64;
	// 82AB5904: 7CC62378  or r6, r6, r4
	ctx.r[6].u64 = ctx.r[6].u64 | ctx.r[4].u64;
	// 82AB5908: F8CB0008  std r6, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u64 ) };
	// 82AB590C: 98E80019  stb r7, 0x19(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(25 as u32), ctx.r[7].u8 ) };
	// 82AB5910: 4082FFD4  bne 0x82ab58e4
	if !ctx.cr[0].eq {
	pc = 0x82AB58E4; continue 'dispatch;
	}
	pc = 0x82AB5914; continue 'dispatch;
            }
            0x82AB5914 => {
    //   block [0x82AB5914..0x82AB5918)
	// 82AB5914: 4B994BAD  bl 0x8244a4c0
	ctx.lr = 0x82AB5918;
	sub_8244A4C0(ctx, base);
	pc = 0x82AB5918; continue 'dispatch;
            }
            0x82AB5918 => {
    //   block [0x82AB5918..0x82AB5920)
	// 82AB5918: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB591C: 481F3B3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB5920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB5920 size=164
    let mut pc: u32 = 0x82AB5920;
    'dispatch: loop {
        match pc {
            0x82AB5920 => {
    //   block [0x82AB5920..0x82AB5970)
	// 82AB5920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB5924: 481F3AE9  bl 0x82ca940c
	ctx.lr = 0x82AB5928;
	sub_82CA93D0(ctx, base);
	// 82AB5928: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB592C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB5930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB5934: 386B5774  addi r3, r11, 0x5774
	ctx.r[3].s64 = ctx.r[11].s64 + 22388;
	// 82AB5938: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB593C: 4B994B85  bl 0x8244a4c0
	ctx.lr = 0x82AB5940;
	sub_8244A4C0(ctx, base);
	// 82AB5940: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5944: 2F0A000A  cmpwi cr6, r10, 0xa
	ctx.cr[6].compare_i32(ctx.r[10].s32, 10, &mut ctx.xer);
	// 82AB5948: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82AB594C: 409A0024  bne cr6, 0x82ab5970
	if !ctx.cr[6].eq {
	pc = 0x82AB5970; continue 'dispatch;
	}
	// 82AB5950: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB5954: 3D2082AB  lis r9, -0x7d55
	ctx.r[9].s64 = -2102722560;
	// 82AB5958: 916A6F44  stw r11, 0x6f44(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28484 as u32), ctx.r[11].u32 ) };
	// 82AB595C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB5960: 386956E8  addi r3, r9, 0x56e8
	ctx.r[3].s64 = ctx.r[9].s64 + 22248;
	// 82AB5964: 48001C15  bl 0x82ab7578
	ctx.lr = 0x82AB5968;
	sub_82AB7578(ctx, base);
	// 82AB5968: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB596C: 481F3AF0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB5970 => {
    //   block [0x82AB5970..0x82AB598C)
	// 82AB5970: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 82AB5974: 93CA6F44  stw r30, 0x6f44(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28484 as u32), ctx.r[30].u32 ) };
	// 82AB5978: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82AB597C: 3BEB0020  addi r31, r11, 0x20
	ctx.r[31].s64 = ctx.r[11].s64 + 32;
	// 82AB5980: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82AB5984: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 82AB5988: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	pc = 0x82AB598C; continue 'dispatch;
            }
            0x82AB598C => {
    //   block [0x82AB598C..0x82AB59B0)
	// 82AB598C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5990: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AB5994: 419A001C  beq cr6, 0x82ab59b0
	if ctx.cr[6].eq {
	pc = 0x82AB59B0; continue 'dispatch;
	}
	// 82AB5998: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 82AB599C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AB59A0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AB59A4: 60A5FFFF  ori r5, r5, 0xffff
	ctx.r[5].u64 = ctx.r[5].u64 | 65535;
	// 82AB59A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AB59AC: 48001D45  bl 0x82ab76f0
	ctx.lr = 0x82AB59B0;
	sub_82AB76F0(ctx, base);
	pc = 0x82AB59B0; continue 'dispatch;
            }
            0x82AB59B0 => {
    //   block [0x82AB59B0..0x82AB59C4)
	// 82AB59B0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB59B4: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 82AB59B8: 4082FFD4  bne 0x82ab598c
	if !ctx.cr[0].eq {
	pc = 0x82AB598C; continue 'dispatch;
	}
	// 82AB59BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB59C0: 481F3A9C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB59C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB59C8 size=240
    let mut pc: u32 = 0x82AB59C8;
    'dispatch: loop {
        match pc {
            0x82AB59C8 => {
    //   block [0x82AB59C8..0x82AB5A20)
	// 82AB59C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB59CC: 481F3A2D  bl 0x82ca93f8
	ctx.lr = 0x82AB59D0;
	sub_82CA93D0(ctx, base);
	// 82AB59D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB59D4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82AB59D8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AB59DC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AB59E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB59E4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82AB59E8: 4BFFFF39  bl 0x82ab5920
	ctx.lr = 0x82AB59EC;
	sub_82AB5920(ctx, base);
	// 82AB59EC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB59F0: 3BAB5774  addi r29, r11, 0x5774
	ctx.r[29].s64 = ctx.r[11].s64 + 22388;
	// 82AB59F4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB59F8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB59FC: 839F01A0  lwz r28, 0x1a0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82AB5A00: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB5A04: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB5A08: 418200A8  beq 0x82ab5ab0
	if ctx.cr[0].eq {
	pc = 0x82AB5AB0; continue 'dispatch;
	}
	// 82AB5A0C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 82AB5A10: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AB5A14: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82AB5A18: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AB5A1C: 813A6F44  lwz r9, 0x6f44(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28484 as u32) ) } as u64;
	pc = 0x82AB5A20; continue 'dispatch;
            }
            0x82AB5A20 => {
    //   block [0x82AB5A20..0x82AB5A4C)
	// 82AB5A20: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5A24: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82AB5A28: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AB5A2C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB5A30: 419A001C  beq cr6, 0x82ab5a4c
	if ctx.cr[6].eq {
	pc = 0x82AB5A4C; continue 'dispatch;
	}
	// 82AB5A34: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB5A38: 419A0014  beq cr6, 0x82ab5a4c
	if ctx.cr[6].eq {
	pc = 0x82AB5A4C; continue 'dispatch;
	}
	// 82AB5A3C: 7D4AE050  subf r10, r10, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[10].s64;
	// 82AB5A40: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82AB5A44: 550ADFFE  rlwinm r10, r8, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82AB5A48: 48000008  b 0x82ab5a50
	pc = 0x82AB5A50; continue 'dispatch;
            }
            0x82AB5A4C => {
    //   block [0x82AB5A4C..0x82AB5A50)
	// 82AB5A4C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82AB5A50; continue 'dispatch;
            }
            0x82AB5A50 => {
    //   block [0x82AB5A50..0x82AB5AA4)
	// 82AB5A50: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82AB5A54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB5A58: 419A004C  beq cr6, 0x82ab5aa4
	if ctx.cr[6].eq {
	pc = 0x82AB5AA4; continue 'dispatch;
	}
	// 82AB5A5C: 57CAD1BE  srwi r10, r30, 6
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shr(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB5A60: 57C806BE  clrlwi r8, r30, 0x1a
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x0000003Fu64;
	// 82AB5A64: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82AB5A68: 7FE64036  sld r6, r31, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[31].u64) << ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 82AB5A6C: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB5A70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB5A74: 7CAA582A  ldx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 82AB5A78: 7CA43078  andc r4, r5, r6
	ctx.r[4].u64 = ctx.r[5].u64 & !ctx.r[6].u64;
	// 82AB5A7C: 7C833378  or r3, r4, r6
	ctx.r[3].u64 = ctx.r[4].u64 | ctx.r[6].u64;
	// 82AB5A80: 7C6A592A  stdx r3, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u64) };
	// 82AB5A84: 9BEB0019  stb r31, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[31].u8 ) };
	// 82AB5A88: 419A001C  beq cr6, 0x82ab5aa4
	if ctx.cr[6].eq {
	pc = 0x82AB5AA4; continue 'dispatch;
	}
	// 82AB5A8C: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82AB5A90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AB5A94: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AB5A98: 386901D4  addi r3, r9, 0x1d4
	ctx.r[3].s64 = ctx.r[9].s64 + 468;
	// 82AB5A9C: 4B726265  bl 0x821dbd00
	ctx.lr = 0x82AB5AA0;
	sub_821DBD00(ctx, base);
	// 82AB5AA0: 813A6F44  lwz r9, 0x6f44(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28484 as u32) ) } as u64;
	pc = 0x82AB5AA4; continue 'dispatch;
            }
            0x82AB5AA4 => {
    //   block [0x82AB5AA4..0x82AB5AB0)
	// 82AB5AA4: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82AB5AA8: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82AB5AAC: 4082FF74  bne 0x82ab5a20
	if !ctx.cr[0].eq {
	pc = 0x82AB5A20; continue 'dispatch;
	}
	pc = 0x82AB5AB0; continue 'dispatch;
            }
            0x82AB5AB0 => {
    //   block [0x82AB5AB0..0x82AB5AB8)
	// 82AB5AB0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB5AB4: 481F3994  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB5AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AB5AB8 size=212
    let mut pc: u32 = 0x82AB5AB8;
    'dispatch: loop {
        match pc {
            0x82AB5AB8 => {
    //   block [0x82AB5AB8..0x82AB5AE8)
	// 82AB5AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB5ABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB5AC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB5AC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB5AC8: 896400A2  lbz r11, 0xa2(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(162 as u32) ) } as u64;
	// 82AB5ACC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB5AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB5AD4: 419A0014  beq cr6, 0x82ab5ae8
	if ctx.cr[6].eq {
	pc = 0x82AB5AE8; continue 'dispatch;
	}
	// 82AB5AD8: 816400A4  lwz r11, 0xa4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AB5ADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB5AE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AB5AE4: 419A0008  beq cr6, 0x82ab5aec
	if ctx.cr[6].eq {
	pc = 0x82AB5AEC; continue 'dispatch;
	}
	pc = 0x82AB5AE8; continue 'dispatch;
            }
            0x82AB5AE8 => {
    //   block [0x82AB5AE8..0x82AB5AEC)
	// 82AB5AE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AB5AEC; continue 'dispatch;
            }
            0x82AB5AEC => {
    //   block [0x82AB5AEC..0x82AB5B1C)
	// 82AB5AEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AB5AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB5AF4: 419A006C  beq cr6, 0x82ab5b60
	if ctx.cr[6].eq {
	pc = 0x82AB5B60; continue 'dispatch;
	}
	// 82AB5AF8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5AFC: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82AB5B00: 409A001C  bne cr6, 0x82ab5b1c
	if !ctx.cr[6].eq {
	pc = 0x82AB5B1C; continue 'dispatch;
	}
	// 82AB5B04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AB5B08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AB5B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB5B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB5B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB5B18: 4E800020  blr
	return;
            }
            0x82AB5B1C => {
    //   block [0x82AB5B1C..0x82AB5B34)
	// 82AB5B1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AB5B20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AB5B24: 4B73A28D  bl 0x821efdb0
	ctx.lr = 0x82AB5B28;
	sub_821EFDB0(ctx, base);
	// 82AB5B28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB5B2C: 419A0008  beq cr6, 0x82ab5b34
	if ctx.cr[6].eq {
	pc = 0x82AB5B34; continue 'dispatch;
	}
	// 82AB5B30: 80A300A0  lwz r5, 0xa0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	pc = 0x82AB5B34; continue 'dispatch;
            }
            0x82AB5B34 => {
    //   block [0x82AB5B34..0x82AB5B60)
	// 82AB5B34: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AB5B38: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82AB5B3C: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82AB5B40: 7D0A4810  subfc r8, r10, r9
	ctx.xer.ca = ctx.r[9].u32 >= ctx.r[10].u32;
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82AB5B44: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82AB5B48: 54E307FE  clrlwi r3, r7, 0x1f
	ctx.r[3].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 82AB5B4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AB5B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB5B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB5B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB5B5C: 4E800020  blr
	return;
            }
            0x82AB5B60 => {
    //   block [0x82AB5B60..0x82AB5B8C)
	// 82AB5B60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB5B64: 388402F0  addi r4, r4, 0x2f0
	ctx.r[4].s64 = ctx.r[4].s64 + 752;
	// 82AB5B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB5B6C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB5B70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB5B74: 4E800421  bctrl
	ctx.lr = 0x82AB5B78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AB5B78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AB5B7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB5B80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB5B84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB5B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB5B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AB5B90 size=916
    let mut pc: u32 = 0x82AB5B90;
    'dispatch: loop {
        match pc {
            0x82AB5B90 => {
    //   block [0x82AB5B90..0x82AB5BE4)
	// 82AB5B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB5B94: 481F3869  bl 0x82ca93fc
	ctx.lr = 0x82AB5B98;
	sub_82CA93D0(ctx, base);
	// 82AB5B98: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB5B9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB5BA0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB5BA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AB5BA8: 3BBE0028  addi r29, r30, 0x28
	ctx.r[29].s64 = ctx.r[30].s64 + 40;
	// 82AB5BAC: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AB5BB0: 3B7E0004  addi r27, r30, 4
	ctx.r[27].s64 = ctx.r[30].s64 + 4;
	// 82AB5BB4: 909E0000  stw r4, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82AB5BB8: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 82AB5BBC: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82AB5BC0: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AB5BC4: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82AB5BC8: FBFE0018  std r31, 0x18(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 82AB5BCC: FBFE0020  std r31, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 82AB5BD0: 997E0028  stb r11, 0x28(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[11].u8 ) };
	// 82AB5BD4: 4B769685  bl 0x8221f258
	ctx.lr = 0x82AB5BD8;
	sub_8221F258(ctx, base);
	// 82AB5BD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB5BDC: 419A0008  beq cr6, 0x82ab5be4
	if ctx.cr[6].eq {
	pc = 0x82AB5BE4; continue 'dispatch;
	}
	// 82AB5BE0: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82AB5BE4; continue 'dispatch;
            }
            0x82AB5BE4 => {
    //   block [0x82AB5BE4..0x82AB5BF0)
	// 82AB5BE4: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB5BE8: 41820008  beq 0x82ab5bf0
	if ctx.cr[0].eq {
	pc = 0x82AB5BF0; continue 'dispatch;
	}
	// 82AB5BEC: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82AB5BF0; continue 'dispatch;
            }
            0x82AB5BF0 => {
    //   block [0x82AB5BF0..0x82AB5C38)
	// 82AB5BF0: 907C0004  stw r3, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82AB5BF4: 38600048  li r3, 0x48
	ctx.r[3].s64 = 72;
	// 82AB5BF8: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82AB5BFC: 3B5D0010  addi r26, r29, 0x10
	ctx.r[26].s64 = ctx.r[29].s64 + 16;
	// 82AB5C00: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5C04: 93FD0014  stw r31, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82AB5C08: 93FD0018  stw r31, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82AB5C0C: 93FD001C  stw r31, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82AB5C10: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82AB5C14: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AB5C18: 4B769641  bl 0x8221f258
	ctx.lr = 0x82AB5C1C;
	sub_8221F258(ctx, base);
	// 82AB5C1C: 39230048  addi r9, r3, 0x48
	ctx.r[9].s64 = ctx.r[3].s64 + 72;
	// 82AB5C20: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 82AB5C24: 907D0014  stw r3, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82AB5C28: 913D001C  stw r9, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82AB5C2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AB5C30: E9210060  ld r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AB5C34: 907D0018  stw r3, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	pc = 0x82AB5C38; continue 'dispatch;
            }
            0x82AB5C38 => {
    //   block [0x82AB5C38..0x82AB5C44)
	// 82AB5C38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB5C3C: 419A0008  beq cr6, 0x82ab5c44
	if ctx.cr[6].eq {
	pc = 0x82AB5C44; continue 'dispatch;
	}
	// 82AB5C40: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x82AB5C44; continue 'dispatch;
            }
            0x82AB5C44 => {
    //   block [0x82AB5C44..0x82AB5F24)
	// 82AB5C44: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB5C48: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB5C4C: 4082FFEC  bne 0x82ab5c38
	if !ctx.cr[0].eq {
	pc = 0x82AB5C38; continue 'dispatch;
	}
	// 82AB5C50: 39630048  addi r11, r3, 0x48
	ctx.r[11].s64 = ctx.r[3].s64 + 72;
	// 82AB5C54: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82AB5C58: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB5C5C: 387E005C  addi r3, r30, 0x5c
	ctx.r[3].s64 = ctx.r[30].s64 + 92;
	// 82AB5C60: 933D0020  stw r25, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[25].u32 ) };
	// 82AB5C64: 933D0024  stw r25, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[25].u32 ) };
	// 82AB5C68: 93FE0050  stw r31, 0x50(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AB5C6C: 93FE0054  stw r31, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AB5C70: 93FE0058  stw r31, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AB5C74: 480002B5  bl 0x82ab5f28
	ctx.lr = 0x82AB5C78;
	sub_82AB5F28(ctx, base);
	// 82AB5C78: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82AB5C7C: 93FE113C  stw r31, 0x113c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4412 as u32), ctx.r[31].u32 ) };
	// 82AB5C80: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82AB5C84: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB5C88: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB5C8C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82AB5C90: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82AB5C94: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82AB5C98: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AB5C9C: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB5CA0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AB5CA4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB5F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB5F28 size=580
    let mut pc: u32 = 0x82AB5F28;
    'dispatch: loop {
        match pc {
            0x82AB5F28 => {
    //   block [0x82AB5F28..0x82AB611C)
	// 82AB5F28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB5F2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AB5F30: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB5F34: 99430000  stb r10, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82AB5F38: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB5F3C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AB5F40: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82AB5F44: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82AB5F48: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82AB5F4C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82AB5F50: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82AB5F54: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82AB5F58: 99430028  stb r10, 0x28(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 82AB5F5C: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82AB5F60: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82AB5F64: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82AB5F68: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82AB5F6C: 9943003C  stb r10, 0x3c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u8 ) };
	// 82AB5F70: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82AB5F74: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82AB5F78: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82AB5F7C: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82AB5F80: 99430050  stb r10, 0x50(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82AB5F84: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AB5F88: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AB5F8C: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AB5F90: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AB5F94: 99430064  stb r10, 0x64(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[10].u8 ) };
	// 82AB5F98: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AB5F9C: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AB5FA0: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AB5FA4: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AB5FA8: 99430078  stb r10, 0x78(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[10].u8 ) };
	// 82AB5FAC: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82AB5FB0: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82AB5FB4: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AB5FB8: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82AB5FBC: 9943008C  stb r10, 0x8c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 82AB5FC0: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82AB5FC4: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82AB5FC8: 91630098  stw r11, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AB5FCC: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82AB5FD0: 994300A0  stb r10, 0xa0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[10].u8 ) };
	// 82AB5FD4: 916300A4  stw r11, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82AB5FD8: 916300A8  stw r11, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82AB5FDC: 916300AC  stw r11, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82AB5FE0: 916300B0  stw r11, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82AB5FE4: 994300B4  stb r10, 0xb4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[10].u8 ) };
	// 82AB5FE8: 916300B8  stw r11, 0xb8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82AB5FEC: 916300BC  stw r11, 0xbc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82AB5FF0: 916300C0  stw r11, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82AB5FF4: 916300C4  stw r11, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82AB5FF8: 994300C8  stb r10, 0xc8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[10].u8 ) };
	// 82AB5FFC: 916300CC  stw r11, 0xcc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82AB6000: 916300D0  stw r11, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82AB6004: 916300D4  stw r11, 0xd4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82AB6008: 916300D8  stw r11, 0xd8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82AB600C: 994300DC  stb r10, 0xdc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), ctx.r[10].u8 ) };
	// 82AB6010: 916300E0  stw r11, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 82AB6014: 916300E4  stw r11, 0xe4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82AB6018: 916300E8  stw r11, 0xe8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82AB601C: 916300EC  stw r11, 0xec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82AB6020: 994300F0  stb r10, 0xf0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[10].u8 ) };
	// 82AB6024: 916300F4  stw r11, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82AB6028: 916300F8  stw r11, 0xf8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82AB602C: 916300FC  stw r11, 0xfc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82AB6030: 91630100  stw r11, 0x100(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82AB6034: 99430104  stb r10, 0x104(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), ctx.r[10].u8 ) };
	// 82AB6038: 91630108  stw r11, 0x108(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82AB603C: 9163010C  stw r11, 0x10c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 82AB6040: 91630110  stw r11, 0x110(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82AB6044: 91630114  stw r11, 0x114(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82AB6048: 99430118  stb r10, 0x118(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), ctx.r[10].u8 ) };
	// 82AB604C: 9163011C  stw r11, 0x11c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 82AB6050: 91630120  stw r11, 0x120(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82AB6054: 91630124  stw r11, 0x124(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 82AB6058: 91630128  stw r11, 0x128(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 82AB605C: 9943012C  stb r10, 0x12c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(300 as u32), ctx.r[10].u8 ) };
	// 82AB6060: 91630130  stw r11, 0x130(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82AB6064: 91630134  stw r11, 0x134(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82AB6068: 91630138  stw r11, 0x138(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 82AB606C: 9163013C  stw r11, 0x13c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82AB6070: 390301E0  addi r8, r3, 0x1e0
	ctx.r[8].s64 = ctx.r[3].s64 + 480;
	// 82AB6074: 99430140  stb r10, 0x140(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), ctx.r[10].u8 ) };
	// 82AB6078: 38E0003F  li r7, 0x3f
	ctx.r[7].s64 = 63;
	// 82AB607C: 91630144  stw r11, 0x144(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 82AB6080: 3928001C  addi r9, r8, 0x1c
	ctx.r[9].s64 = ctx.r[8].s64 + 28;
	// 82AB6084: 91630148  stw r11, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82AB6088: 9163014C  stw r11, 0x14c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 82AB608C: 91630150  stw r11, 0x150(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82AB6090: 99430154  stb r10, 0x154(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), ctx.r[10].u8 ) };
	// 82AB6094: 91630158  stw r11, 0x158(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82AB6098: 9163015C  stw r11, 0x15c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82AB609C: 91630160  stw r11, 0x160(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82AB60A0: 91630164  stw r11, 0x164(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 82AB60A4: 99430168  stb r10, 0x168(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(360 as u32), ctx.r[10].u8 ) };
	// 82AB60A8: 9163016C  stw r11, 0x16c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82AB60AC: 91630170  stw r11, 0x170(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 82AB60B0: 91630174  stw r11, 0x174(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82AB60B4: 91630178  stw r11, 0x178(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82AB60B8: 9943017C  stb r10, 0x17c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(380 as u32), ctx.r[10].u8 ) };
	// 82AB60BC: 91630180  stw r11, 0x180(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82AB60C0: 91630184  stw r11, 0x184(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82AB60C4: 91630188  stw r11, 0x188(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82AB60C8: 9163018C  stw r11, 0x18c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82AB60CC: 99430190  stb r10, 0x190(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(400 as u32), ctx.r[10].u8 ) };
	// 82AB60D0: 91630194  stw r11, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82AB60D4: 91630198  stw r11, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82AB60D8: 9163019C  stw r11, 0x19c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	// 82AB60DC: 916301A0  stw r11, 0x1a0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 82AB60E0: 994301A4  stb r10, 0x1a4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[10].u8 ) };
	// 82AB60E4: 916301A8  stw r11, 0x1a8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82AB60E8: 916301AC  stw r11, 0x1ac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 82AB60EC: 916301B0  stw r11, 0x1b0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82AB60F0: 916301B4  stw r11, 0x1b4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 82AB60F4: 994301B8  stb r10, 0x1b8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(440 as u32), ctx.r[10].u8 ) };
	// 82AB60F8: 916301BC  stw r11, 0x1bc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82AB60FC: 916301C0  stw r11, 0x1c0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82AB6100: 916301C4  stw r11, 0x1c4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 82AB6104: 916301C8  stw r11, 0x1c8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 82AB6108: 994301CC  stb r10, 0x1cc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(460 as u32), ctx.r[10].u8 ) };
	// 82AB610C: 916301D0  stw r11, 0x1d0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 82AB6110: 916301D4  stw r11, 0x1d4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82AB6114: 916301D8  stw r11, 0x1d8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 82AB6118: 916301DC  stw r11, 0x1dc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(476 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB611C; continue 'dispatch;
            }
            0x82AB611C => {
    //   block [0x82AB611C..0x82AB616C)
	// 82AB611C: 99480000  stb r10, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82AB6120: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82AB6124: 9169FFE8  stw r11, -0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-24 as u32), ctx.r[11].u32 ) };
	// 82AB6128: 3908003C  addi r8, r8, 0x3c
	ctx.r[8].s64 = ctx.r[8].s64 + 60;
	// 82AB612C: 9169FFEC  stw r11, -0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-20 as u32), ctx.r[11].u32 ) };
	// 82AB6130: 9169FFF0  stw r11, -0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82AB6134: 9169FFF4  stw r11, -0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82AB6138: 9949FFF8  stb r10, -8(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8 as u32), ctx.r[10].u8 ) };
	// 82AB613C: 9169FFFC  stw r11, -4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 82AB6140: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AB6144: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB6148: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB614C: 9949000C  stb r10, 0xc(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 82AB6150: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82AB6154: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82AB6158: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82AB615C: 9169001C  stw r11, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82AB6160: 3929003C  addi r9, r9, 0x3c
	ctx.r[9].s64 = ctx.r[9].s64 + 60;
	// 82AB6164: 4080FFB8  bge 0x82ab611c
	if !ctx.cr[0].lt {
	pc = 0x82AB611C; continue 'dispatch;
	}
	// 82AB6168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB6170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB6170 size=300
    let mut pc: u32 = 0x82AB6170;
    'dispatch: loop {
        match pc {
            0x82AB6170 => {
    //   block [0x82AB6170..0x82AB619C)
	// 82AB6170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB6174: 481F3295  bl 0x82ca9408
	ctx.lr = 0x82AB6178;
	sub_82CA93D0(ctx, base);
	// 82AB6178: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB617C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AB6180: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AB6184: 4BFFF485  bl 0x82ab5608
	ctx.lr = 0x82AB6188;
	sub_82AB5608(ctx, base);
	// 82AB6188: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB618C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AB6190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB6194: 419A0040  beq cr6, 0x82ab61d4
	if ctx.cr[6].eq {
	pc = 0x82AB61D4; continue 'dispatch;
	}
	// 82AB6198: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB619C; continue 'dispatch;
            }
            0x82AB619C => {
    //   block [0x82AB619C..0x82AB61D0)
	// 82AB619C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB61A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB61A4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB61A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB61AC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB61B0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB61B4: 4082FFE8  bne 0x82ab619c
	if !ctx.cr[0].eq {
	pc = 0x82AB619C; continue 'dispatch;
	}
	// 82AB61B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB61BC: 409A0014  bne cr6, 0x82ab61d0
	if !ctx.cr[6].eq {
	pc = 0x82AB61D0; continue 'dispatch;
	}
	// 82AB61C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB61C4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB61C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB61CC: 4E800421  bctrl
	ctx.lr = 0x82AB61D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB61D0 => {
    //   block [0x82AB61D0..0x82AB61D4)
	// 82AB61D0: 93BC0058  stw r29, 0x58(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	pc = 0x82AB61D4; continue 'dispatch;
            }
            0x82AB61D4 => {
    //   block [0x82AB61D4..0x82AB61F0)
	// 82AB61D4: 83FC0054  lwz r31, 0x54(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB61D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB61DC: 419A0014  beq cr6, 0x82ab61f0
	if ctx.cr[6].eq {
	pc = 0x82AB61F0; continue 'dispatch;
	}
	// 82AB61E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB61E4: 48067E6D  bl 0x82b1e050
	ctx.lr = 0x82AB61E8;
	sub_82B1E050(ctx, base);
	// 82AB61E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB61EC: 4B765B4D  bl 0x8221bd38
	ctx.lr = 0x82AB61F0;
	sub_8221BD38(ctx, base);
	pc = 0x82AB61F0; continue 'dispatch;
            }
            0x82AB61F0 => {
    //   block [0x82AB61F0..0x82AB6204)
	// 82AB61F0: 93BC0054  stw r29, 0x54(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AB61F4: 807C0050  lwz r3, 0x50(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB61F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB61FC: 419A0040  beq cr6, 0x82ab623c
	if ctx.cr[6].eq {
	pc = 0x82AB623C; continue 'dispatch;
	}
	// 82AB6200: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82AB6204; continue 'dispatch;
            }
            0x82AB6204 => {
    //   block [0x82AB6204..0x82AB6238)
	// 82AB6204: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82AB6208: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB620C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82AB6210: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB6214: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB6218: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB621C: 4082FFE8  bne 0x82ab6204
	if !ctx.cr[0].eq {
	pc = 0x82AB6204; continue 'dispatch;
	}
	// 82AB6220: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB6224: 409A0014  bne cr6, 0x82ab6238
	if !ctx.cr[6].eq {
	pc = 0x82AB6238; continue 'dispatch;
	}
	// 82AB6228: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB622C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6230: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82AB6234: 4E800421  bctrl
	ctx.lr = 0x82AB6238;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82AB6238 => {
    //   block [0x82AB6238..0x82AB623C)
	// 82AB6238: 93BC0050  stw r29, 0x50(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	pc = 0x82AB623C; continue 'dispatch;
            }
            0x82AB623C => {
    //   block [0x82AB623C..0x82AB6254)
	// 82AB623C: 807C003C  lwz r3, 0x3c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AB6240: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 82AB6244: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82AB6248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB624C: 419A0008  beq cr6, 0x82ab6254
	if ctx.cr[6].eq {
	pc = 0x82AB6254; continue 'dispatch;
	}
	// 82AB6250: 4B765AE9  bl 0x8221bd38
	ctx.lr = 0x82AB6254;
	sub_8221BD38(ctx, base);
	pc = 0x82AB6254; continue 'dispatch;
            }
            0x82AB6254 => {
    //   block [0x82AB6254..0x82AB6288)
	// 82AB6254: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AB6258: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82AB625C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82AB6260: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82AB6264: 480012AD  bl 0x82ab7510
	ctx.lr = 0x82AB6268;
	sub_82AB7510(ctx, base);
	// 82AB6268: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB626C: 4B765ACD  bl 0x8221bd38
	ctx.lr = 0x82AB6270;
	sub_8221BD38(ctx, base);
	// 82AB6270: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82AB6274: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB6278: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82AB627C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB6280: 419A0008  beq cr6, 0x82ab6288
	if ctx.cr[6].eq {
	pc = 0x82AB6288; continue 'dispatch;
	}
	// 82AB6284: 4B765AB5  bl 0x8221bd38
	ctx.lr = 0x82AB6288;
	sub_8221BD38(ctx, base);
	pc = 0x82AB6288; continue 'dispatch;
            }
            0x82AB6288 => {
    //   block [0x82AB6288..0x82AB629C)
	// 82AB6288: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AB628C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82AB6290: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82AB6294: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB6298: 481F31C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB62A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB62A0 size=188
    let mut pc: u32 = 0x82AB62A0;
    'dispatch: loop {
        match pc {
            0x82AB62A0 => {
    //   block [0x82AB62A0..0x82AB62C4)
	// 82AB62A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB62A4: 481F3169  bl 0x82ca940c
	ctx.lr = 0x82AB62A8;
	sub_82CA93D0(ctx, base);
	// 82AB62A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB62AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB62B0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AB62B4: 3BFE002C  addi r31, r30, 0x2c
	ctx.r[31].s64 = ctx.r[30].s64 + 44;
	// 82AB62B8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82AB62BC: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AB62C0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	pc = 0x82AB62C4; continue 'dispatch;
            }
            0x82AB62C4 => {
    //   block [0x82AB62C4..0x82AB62CC)
	// 82AB62C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB62C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB62CC; continue 'dispatch;
            }
            0x82AB62CC => {
    //   block [0x82AB62CC..0x82AB62E0)
	// 82AB62CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB62D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AB62D4: 419A000C  beq cr6, 0x82ab62e0
	if ctx.cr[6].eq {
	pc = 0x82AB62E0; continue 'dispatch;
	}
	// 82AB62D8: 7F08F840  cmplw cr6, r8, r31
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AB62DC: 419A0008  beq cr6, 0x82ab62e4
	if ctx.cr[6].eq {
	pc = 0x82AB62E4; continue 'dispatch;
	}
	pc = 0x82AB62E0; continue 'dispatch;
            }
            0x82AB62E0 => {
    //   block [0x82AB62E0..0x82AB62E4)
	// 82AB62E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB62E4; continue 'dispatch;
            }
            0x82AB62E4 => {
    //   block [0x82AB62E4..0x82AB62F8)
	// 82AB62E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB62E8: 419A0064  beq cr6, 0x82ab634c
	if ctx.cr[6].eq {
	pc = 0x82AB634C; continue 'dispatch;
	}
	// 82AB62EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82AB62F0: 409A0008  bne cr6, 0x82ab62f8
	if !ctx.cr[6].eq {
	pc = 0x82AB62F8; continue 'dispatch;
	}
	// 82AB62F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB62F8; continue 'dispatch;
            }
            0x82AB62F8 => {
    //   block [0x82AB62F8..0x82AB6308)
	// 82AB62F8: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB62FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6300: 409A0008  bne cr6, 0x82ab6308
	if !ctx.cr[6].eq {
	pc = 0x82AB6308; continue 'dispatch;
	}
	// 82AB6304: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6308; continue 'dispatch;
            }
            0x82AB6308 => {
    //   block [0x82AB6308..0x82AB633C)
	// 82AB6308: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AB630C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6310: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82AB6314: 409A0028  bne cr6, 0x82ab633c
	if !ctx.cr[6].eq {
	pc = 0x82AB633C; continue 'dispatch;
	}
	// 82AB6318: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 82AB631C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB6320: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AB6324: 48000BB5  bl 0x82ab6ed8
	ctx.lr = 0x82AB6328;
	sub_82AB6ED8(ctx, base);
	// 82AB6328: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82AB632C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82AB6330: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB6334: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB6338: 4BFFFF94  b 0x82ab62cc
	pc = 0x82AB62CC; continue 'dispatch;
            }
            0x82AB633C => {
    //   block [0x82AB633C..0x82AB634C)
	// 82AB633C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6340: 409AFF84  bne cr6, 0x82ab62c4
	if !ctx.cr[6].eq {
	pc = 0x82AB62C4; continue 'dispatch;
	}
	// 82AB6344: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82AB6348: 4BFFFF7C  b 0x82ab62c4
	pc = 0x82AB62C4; continue 'dispatch;
            }
            0x82AB634C => {
    //   block [0x82AB634C..0x82AB635C)
	// 82AB634C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB6350: 4BFFF2B9  bl 0x82ab5608
	ctx.lr = 0x82AB6354;
	sub_82AB5608(ctx, base);
	// 82AB6354: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB6358: 481F3104  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB6360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AB6360 size=360
    let mut pc: u32 = 0x82AB6360;
    'dispatch: loop {
        match pc {
            0x82AB6360 => {
    //   block [0x82AB6360..0x82AB64C8)
	// 82AB6360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB6364: 481F3099  bl 0x82ca93fc
	ctx.lr = 0x82AB6368;
	sub_82CA93D0(ctx, base);
	// 82AB6368: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB64C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB64C8 size=204
    let mut pc: u32 = 0x82AB64C8;
    'dispatch: loop {
        match pc {
            0x82AB64C8 => {
    //   block [0x82AB64C8..0x82AB64F0)
	// 82AB64C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB64CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB64D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB64D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB64D8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82AB64DC: 3BEB19D8  addi r31, r11, 0x19d8
	ctx.r[31].s64 = ctx.r[11].s64 + 6616;
	// 82AB64E0: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AB64E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB64E8: 419A0008  beq cr6, 0x82ab64f0
	if ctx.cr[6].eq {
	pc = 0x82AB64F0; continue 'dispatch;
	}
	// 82AB64EC: 4B76584D  bl 0x8221bd38
	ctx.lr = 0x82AB64F0;
	sub_8221BD38(ctx, base);
	pc = 0x82AB64F0; continue 'dispatch;
            }
            0x82AB64F0 => {
    //   block [0x82AB64F0..0x82AB6518)
	// 82AB64F0: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB64F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB64F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB64FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB6500: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82AB6504: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82AB6508: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB650C: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 82AB6510: 419A0008  beq cr6, 0x82ab6518
	if ctx.cr[6].eq {
	pc = 0x82AB6518; continue 'dispatch;
	}
	// 82AB6514: 4B765825  bl 0x8221bd38
	ctx.lr = 0x82AB6518;
	sub_8221BD38(ctx, base);
	pc = 0x82AB6518; continue 'dispatch;
            }
            0x82AB6518 => {
    //   block [0x82AB6518..0x82AB6540)
	// 82AB6518: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB651C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB6520: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB6524: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB6528: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82AB652C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AB6530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB6534: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82AB6538: 419A0008  beq cr6, 0x82ab6540
	if ctx.cr[6].eq {
	pc = 0x82AB6540; continue 'dispatch;
	}
	// 82AB653C: 4B7657FD  bl 0x8221bd38
	ctx.lr = 0x82AB6540;
	sub_8221BD38(ctx, base);
	pc = 0x82AB6540; continue 'dispatch;
            }
            0x82AB6540 => {
    //   block [0x82AB6540..0x82AB6568)
	// 82AB6540: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6544: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB6548: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB654C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB6550: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82AB6554: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82AB6558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB655C: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82AB6560: 419A0008  beq cr6, 0x82ab6568
	if ctx.cr[6].eq {
	pc = 0x82AB6568; continue 'dispatch;
	}
	// 82AB6564: 4B7657D5  bl 0x8221bd38
	ctx.lr = 0x82AB6568;
	sub_8221BD38(ctx, base);
	pc = 0x82AB6568; continue 'dispatch;
            }
            0x82AB6568 => {
    //   block [0x82AB6568..0x82AB6594)
	// 82AB6568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AB656C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB6570: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB6574: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AB6578: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB657C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82AB6580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AB6584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB6588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB658C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB6590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB6598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB6598 size=212
    let mut pc: u32 = 0x82AB6598;
    'dispatch: loop {
        match pc {
            0x82AB6598 => {
    //   block [0x82AB6598..0x82AB65E0)
	// 82AB6598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB659C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB65A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AB65A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB65A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB65AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB65B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB65B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AB65B8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82AB65BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB65C0: 4B73FCB1  bl 0x821f6270
	ctx.lr = 0x82AB65C4;
	sub_821F6270(ctx, base);
	// 82AB65C4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82AB65C8: 419A0018  beq cr6, 0x82ab65e0
	if ctx.cr[6].eq {
	pc = 0x82AB65E0; continue 'dispatch;
	}
	// 82AB65CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB65D0: 480871F9  bl 0x82b3d7c8
	ctx.lr = 0x82AB65D4;
	sub_82B3D7C8(ctx, base);
	// 82AB65D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB65D8: 4B765761  bl 0x8221bd38
	ctx.lr = 0x82AB65DC;
	sub_8221BD38(ctx, base);
	// 82AB65DC: 48000078  b 0x82ab6654
	pc = 0x82AB6654; continue 'dispatch;
            }
            0x82AB65E0 => {
    //   block [0x82AB65E0..0x82AB65FC)
	// 82AB65E0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB65E4: 386B5784  addi r3, r11, 0x5784
	ctx.r[3].s64 = ctx.r[11].s64 + 22404;
	// 82AB65E8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB65EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB65F0: 409A000C  bne cr6, 0x82ab65fc
	if !ctx.cr[6].eq {
	pc = 0x82AB65FC; continue 'dispatch;
	}
	// 82AB65F4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB65F8: 48000010  b 0x82ab6608
	pc = 0x82AB6608; continue 'dispatch;
            }
            0x82AB65FC => {
    //   block [0x82AB65FC..0x82AB6608)
	// 82AB65FC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB6600: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB6604: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	pc = 0x82AB6608; continue 'dispatch;
            }
            0x82AB6608 => {
    //   block [0x82AB6608..0x82AB662C)
	// 82AB6608: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB660C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB6610: 7D481E70  srawi r8, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AB6614: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB6618: 40980020  bge cr6, 0x82ab6638
	if !ctx.cr[6].lt {
	pc = 0x82AB6638; continue 'dispatch;
	}
	// 82AB661C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6620: 419A000C  beq cr6, 0x82ab662c
	if ctx.cr[6].eq {
	pc = 0x82AB662C; continue 'dispatch;
	}
	// 82AB6624: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB6628: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x82AB662C; continue 'dispatch;
            }
            0x82AB662C => {
    //   block [0x82AB662C..0x82AB6638)
	// 82AB662C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB6630: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB6634: 48000020  b 0x82ab6654
	pc = 0x82AB6654; continue 'dispatch;
            }
            0x82AB6638 => {
    //   block [0x82AB6638..0x82AB6654)
	// 82AB6638: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB663C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AB6640: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AB6644: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AB6648: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AB664C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AB6650: 48000BD9  bl 0x82ab7228
	ctx.lr = 0x82AB6654;
	sub_82AB7228(ctx, base);
	pc = 0x82AB6654; continue 'dispatch;
            }
            0x82AB6654 => {
    //   block [0x82AB6654..0x82AB666C)
	// 82AB6654: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB6658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB665C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB6660: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AB6664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB6668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB6670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AB6670 size=232
    let mut pc: u32 = 0x82AB6670;
    'dispatch: loop {
        match pc {
            0x82AB6670 => {
    //   block [0x82AB6670..0x82AB6758)
	// 82AB6670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB6674: 481F2D99  bl 0x82ca940c
	ctx.lr = 0x82AB6678;
	sub_82CA93D0(ctx, base);
	// 82AB6678: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AB667C: C00401C4  lfs f0, 0x1c4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AB6680: 39400120  li r10, 0x120
	ctx.r[10].s64 = 288;
	// 82AB6684: C1A40140  lfs f13, 0x140(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AB6688: 392B91A0  addi r9, r11, -0x6e60
	ctx.r[9].s64 = ctx.r[11].s64 + -28256;
	// 82AB668C: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AB6690: 3901FFA0  addi r8, r1, -0x60
	ctx.r[8].s64 = ctx.r[1].s64 + -96;
	// 82AB6694: D181FFA0  stfs f12, -0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 82AB6698: 38E1FFB0  addi r7, r1, -0x50
	ctx.r[7].s64 = ctx.r[1].s64 + -80;
	// 82AB669C: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB6758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB6758 size=124
    let mut pc: u32 = 0x82AB6758;
    'dispatch: loop {
        match pc {
            0x82AB6758 => {
    //   block [0x82AB6758..0x82AB67D4)
	// 82AB6758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB675C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB6760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AB6764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB6768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB676C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB6770: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AB6774: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB6778: 4BFFF071  bl 0x82ab57e8
	ctx.lr = 0x82AB677C;
	sub_82AB57E8(ctx, base);
	// 82AB677C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB6780: 57C92834  slwi r9, r30, 5
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB6784: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AB6788: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82AB678C: 57CBD1BE  srwi r11, r30, 6
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB6790: 57C906BE  clrlwi r9, r30, 0x1a
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x0000003Fu64;
	// 82AB6794: 38EB0003  addi r7, r11, 3
	ctx.r[7].s64 = ctx.r[11].s64 + 3;
	// 82AB6798: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AB679C: 910A0010  stw r8, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82AB67A0: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB67A4: 7CC54836  sld r5, r6, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = (ctx.r[6].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82AB67A8: 7D044836  sld r4, r8, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = (ctx.r[8].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82AB67AC: 7C6BF82A  ldx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	// 82AB67B0: 7C6A2878  andc r10, r3, r5
	ctx.r[10].u64 = ctx.r[3].u64 & !ctx.r[5].u64;
	// 82AB67B4: 7D492378  or r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82AB67B8: 7D2BF92A  stdx r9, r11, r31
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u64) };
	// 82AB67BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB67C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB67C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB67C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AB67CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB67D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB67D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB67D8 size=204
    let mut pc: u32 = 0x82AB67D8;
    'dispatch: loop {
        match pc {
            0x82AB67D8 => {
    //   block [0x82AB67D8..0x82AB6820)
	// 82AB67D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB67DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AB67E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AB67E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AB67E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB67EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB67F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB67F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB67F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AB67FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB6800: 4B7B75D9  bl 0x8226ddd8
	ctx.lr = 0x82AB6804;
	sub_8226DDD8(ctx, base);
	// 82AB6804: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB6808: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB680C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AB6810: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB6814: 419A000C  beq cr6, 0x82ab6820
	if ctx.cr[6].eq {
	pc = 0x82AB6820; continue 'dispatch;
	}
	// 82AB6818: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB681C: 419A0008  beq cr6, 0x82ab6824
	if ctx.cr[6].eq {
	pc = 0x82AB6824; continue 'dispatch;
	}
	pc = 0x82AB6820; continue 'dispatch;
            }
            0x82AB6820 => {
    //   block [0x82AB6820..0x82AB6824)
	// 82AB6820: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6824; continue 'dispatch;
            }
            0x82AB6824 => {
    //   block [0x82AB6824..0x82AB686C)
	// 82AB6824: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB6828: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB682C: 409A0040  bne cr6, 0x82ab686c
	if !ctx.cr[6].eq {
	pc = 0x82AB686C; continue 'dispatch;
	}
	// 82AB6830: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82AB6834: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB6838: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82AB683C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82AB6840: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AB6844: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AB6848: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82AB684C: 4800005D  bl 0x82ab68a8
	ctx.lr = 0x82AB6850;
	sub_82AB68A8(ctx, base);
	// 82AB6850: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82AB6854: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB6858: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82AB685C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82AB6860: 480AF791  bl 0x82b65ff0
	ctx.lr = 0x82AB6864;
	sub_82B65FF0(ctx, base);
	// 82AB6864: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB6868: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82AB686C; continue 'dispatch;
            }
            0x82AB686C => {
    //   block [0x82AB686C..0x82AB6878)
	// 82AB686C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB6870: 409A0008  bne cr6, 0x82ab6878
	if !ctx.cr[6].eq {
	pc = 0x82AB6878; continue 'dispatch;
	}
	// 82AB6874: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6878; continue 'dispatch;
            }
            0x82AB6878 => {
    //   block [0x82AB6878..0x82AB6888)
	// 82AB6878: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB687C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6880: 409A0008  bne cr6, 0x82ab6888
	if !ctx.cr[6].eq {
	pc = 0x82AB6888; continue 'dispatch;
	}
	// 82AB6884: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6888; continue 'dispatch;
            }
            0x82AB6888 => {
    //   block [0x82AB6888..0x82AB68A4)
	// 82AB6888: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82AB688C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AB6890: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AB6894: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AB6898: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AB689C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AB68A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB68A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB68A8 size=1580
    let mut pc: u32 = 0x82AB68A8;
    'dispatch: loop {
        match pc {
            0x82AB68A8 => {
    //   block [0x82AB68A8..0x82AB68F0)
	// 82AB68A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB68AC: 481F2B3D  bl 0x82ca93e8
	ctx.lr = 0x82AB68B0;
	sub_82CA93D0(ctx, base);
	// 82AB68B0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB68B4: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82AB68B8: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82AB68BC: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 82AB68C0: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB68C4: 81580024  lwz r10, 0x24(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB68C8: 5569F0BE  srwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB68CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB68D0: 419903BC  bgt cr6, 0x82ab6c8c
	if ctx.cr[6].gt {
	pc = 0x82AB6C8C; continue 'dispatch;
	}
	// 82AB68D4: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB68D8: 3BD80010  addi r30, r24, 0x10
	ctx.r[30].s64 = ctx.r[24].s64 + 16;
	// 82AB68DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB68E0: 419A0010  beq cr6, 0x82ab68f0
	if ctx.cr[6].eq {
	pc = 0x82AB68F0; continue 'dispatch;
	}
	// 82AB68E4: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB68E8: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB68EC: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	pc = 0x82AB68F0; continue 'dispatch;
            }
            0x82AB68F0 => {
    //   block [0x82AB68F0..0x82AB6914)
	// 82AB68F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB68F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB68F8: 41990054  bgt cr6, 0x82ab694c
	if ctx.cr[6].gt {
	pc = 0x82AB694C; continue 'dispatch;
	}
	// 82AB68FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6904: 419A0010  beq cr6, 0x82ab6914
	if ctx.cr[6].eq {
	pc = 0x82AB6914; continue 'dispatch;
	}
	// 82AB6908: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB690C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB6910: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x82AB6914; continue 'dispatch;
            }
            0x82AB6914 => {
    //   block [0x82AB6914..0x82AB694C)
	// 82AB6914: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB6918: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82AB691C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB6920: 39580004  addi r10, r24, 4
	ctx.r[10].s64 = ctx.r[24].s64 + 4;
	// 82AB6924: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AB6928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AB692C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AB6930: 91780020  stw r11, 0x20(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82AB6934: 388B0002  addi r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 2;
	// 82AB6938: 81180008  lwz r8, 8(r24)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB693C: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82AB6940: E8A90000  ld r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82AB6944: 4BE14AAD  bl 0x828cb3f0
	ctx.lr = 0x82AB6948;
	sub_828CB3F0(ctx, base);
	// 82AB6948: 4800001C  b 0x82ab6964
	pc = 0x82AB6964; continue 'dispatch;
            }
            0x82AB694C => {
    //   block [0x82AB694C..0x82AB6964)
	// 82AB694C: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB6950: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6954: 40980010  bge cr6, 0x82ab6964
	if !ctx.cr[6].lt {
	pc = 0x82AB6964; continue 'dispatch;
	}
	// 82AB6958: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB695C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB6960: 91780020  stw r11, 0x20(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB6964; continue 'dispatch;
            }
            0x82AB6964 => {
    //   block [0x82AB6964..0x82AB6998)
	// 82AB6964: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB6968: 81580024  lwz r10, 0x24(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB696C: 5569F87E  srwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AB6970: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6974: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AB6978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB697C: 3B2AFFFF  addi r25, r10, -1
	ctx.r[25].s64 = ctx.r[10].s64 + -1;
	// 82AB6980: 419A0018  beq cr6, 0x82ab6998
	if ctx.cr[6].eq {
	pc = 0x82AB6998; continue 'dispatch;
	}
	// 82AB6984: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB6988: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB698C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AB6990: 7F195040  cmplw cr6, r25, r10
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6994: 41980008  blt cr6, 0x82ab699c
	if ctx.cr[6].lt {
	pc = 0x82AB699C; continue 'dispatch;
	}
	pc = 0x82AB6998; continue 'dispatch;
            }
            0x82AB6998 => {
    //   block [0x82AB6998..0x82AB699C)
	// 82AB6998: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB699C; continue 'dispatch;
            }
            0x82AB699C => {
    //   block [0x82AB699C..0x82AB69BC)
	// 82AB699C: 57361838  slwi r22, r25, 3
	ctx.r[22].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[22].u64 = ctx.r[22].u32 as u64;
	// 82AB69A0: 3B980004  addi r28, r24, 4
	ctx.r[28].s64 = ctx.r[24].s64 + 4;
	// 82AB69A4: 7D765A14  add r11, r22, r11
	ctx.r[11].u64 = ctx.r[22].u64 + ctx.r[11].u64;
	// 82AB69A8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AB69AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB69B0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AB69B4: 409A0008  bne cr6, 0x82ab69bc
	if !ctx.cr[6].eq {
	pc = 0x82AB69BC; continue 'dispatch;
	}
	// 82AB69B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB69BC; continue 'dispatch;
            }
            0x82AB69BC => {
    //   block [0x82AB69BC..0x82AB69C4)
	// 82AB69BC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82AB69C0: 3AF90001  addi r23, r25, 1
	ctx.r[23].s64 = ctx.r[25].s64 + 1;
	pc = 0x82AB69C4; continue 'dispatch;
            }
            0x82AB69C4 => {
    //   block [0x82AB69C4..0x82AB69D4)
	// 82AB69C4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AB69C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82AB69CC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB69D0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82AB69D4; continue 'dispatch;
            }
            0x82AB69D4 => {
    //   block [0x82AB69D4..0x82AB69F4)
	// 82AB69D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB69D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB69DC: 419A0018  beq cr6, 0x82ab69f4
	if ctx.cr[6].eq {
	pc = 0x82AB69F4; continue 'dispatch;
	}
	// 82AB69E0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB69E4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB69E8: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AB69EC: 7F175040  cmplw cr6, r23, r10
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB69F0: 41980008  blt cr6, 0x82ab69f8
	if ctx.cr[6].lt {
	pc = 0x82AB69F8; continue 'dispatch;
	}
	pc = 0x82AB69F4; continue 'dispatch;
            }
            0x82AB69F4 => {
    //   block [0x82AB69F4..0x82AB69F8)
	// 82AB69F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB69F8; continue 'dispatch;
            }
            0x82AB69F8 => {
    //   block [0x82AB69F8..0x82AB6A18)
	// 82AB69F8: 56EA1838  slwi r10, r23, 3
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB69FC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AB6A00: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6A04: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AB6A08: 419A0278  beq cr6, 0x82ab6c80
	if ctx.cr[6].eq {
	pc = 0x82AB6C80; continue 'dispatch;
	}
	// 82AB6A0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB6A10: 409A0008  bne cr6, 0x82ab6a18
	if !ctx.cr[6].eq {
	pc = 0x82AB6A18; continue 'dispatch;
	}
	// 82AB6A14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6A18; continue 'dispatch;
            }
            0x82AB6A18 => {
    //   block [0x82AB6A18..0x82AB6A28)
	// 82AB6A18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6A1C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6A20: 409A0008  bne cr6, 0x82ab6a28
	if !ctx.cr[6].eq {
	pc = 0x82AB6A28; continue 'dispatch;
	}
	// 82AB6A24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6A28; continue 'dispatch;
            }
            0x82AB6A28 => {
    //   block [0x82AB6A28..0x82AB6A54)
	// 82AB6A28: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 82AB6A2C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82AB6A30: 4B7B7579  bl 0x8226dfa8
	ctx.lr = 0x82AB6A34;
	sub_8226DFA8(ctx, base);
	// 82AB6A34: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB6A38: 7C6A5838  and r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 & ctx.r[11].u64;
	// 82AB6A3C: 7F0AC840  cmplw cr6, r10, r25
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82AB6A40: 409A0020  bne cr6, 0x82ab6a60
	if !ctx.cr[6].eq {
	pc = 0x82AB6A60; continue 'dispatch;
	}
	// 82AB6A44: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6A48: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6A4C: 409A0008  bne cr6, 0x82ab6a54
	if !ctx.cr[6].eq {
	pc = 0x82AB6A54; continue 'dispatch;
	}
	// 82AB6A50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6A54; continue 'dispatch;
            }
            0x82AB6A54 => {
    //   block [0x82AB6A54..0x82AB6A60)
	// 82AB6A54: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB6A58: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AB6A5C: 4BFFFF78  b 0x82ab69d4
	pc = 0x82AB69D4; continue 'dispatch;
            }
            0x82AB6A60 => {
    //   block [0x82AB6A60..0x82AB6A7C)
	// 82AB6A60: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB6A64: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6A68: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6A6C: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB6A70: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82AB6A74: 409A0008  bne cr6, 0x82ab6a7c
	if !ctx.cr[6].eq {
	pc = 0x82AB6A7C; continue 'dispatch;
	}
	// 82AB6A78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6A7C; continue 'dispatch;
            }
            0x82AB6A7C => {
    //   block [0x82AB6A7C..0x82AB6A94)
	// 82AB6A7C: 837D0000  lwz r27, 0(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB6A80: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB6A84: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB6A88: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82AB6A8C: 419A0008  beq cr6, 0x82ab6a94
	if ctx.cr[6].eq {
	pc = 0x82AB6A94; continue 'dispatch;
	}
	// 82AB6A90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6A94; continue 'dispatch;
            }
            0x82AB6A94 => {
    //   block [0x82AB6A94..0x82AB6AA4)
	// 82AB6A94: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6A98: 419A0144  beq cr6, 0x82ab6bdc
	if ctx.cr[6].eq {
	pc = 0x82AB6BDC; continue 'dispatch;
	}
	// 82AB6A9C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82AB6AA0: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	pc = 0x82AB6AA4; continue 'dispatch;
            }
            0x82AB6AA4 => {
    //   block [0x82AB6AA4..0x82AB6AC4)
	// 82AB6AA4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6AAC: 419A0018  beq cr6, 0x82ab6ac4
	if ctx.cr[6].eq {
	pc = 0x82AB6AC4; continue 'dispatch;
	}
	// 82AB6AB0: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB6AB4: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB6AB8: 7CE91E70  srawi r9, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB6ABC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB6AC0: 41980008  blt cr6, 0x82ab6ac8
	if ctx.cr[6].lt {
	pc = 0x82AB6AC8; continue 'dispatch;
	}
	pc = 0x82AB6AC4; continue 'dispatch;
            }
            0x82AB6AC4 => {
    //   block [0x82AB6AC4..0x82AB6AC8)
	// 82AB6AC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6AC8; continue 'dispatch;
            }
            0x82AB6AC8 => {
    //   block [0x82AB6AC8..0x82AB6B00)
	// 82AB6AC8: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82AB6ACC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6AD0: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AB6AD4: 409A004C  bne cr6, 0x82ab6b20
	if !ctx.cr[6].eq {
	pc = 0x82AB6B20; continue 'dispatch;
	}
	// 82AB6AD8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6ADC: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82AB6AE0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82AB6AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6AE8: 419A0018  beq cr6, 0x82ab6b00
	if ctx.cr[6].eq {
	pc = 0x82AB6B00; continue 'dispatch;
	}
	// 82AB6AEC: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB6AF0: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB6AF4: 7CE91E70  srawi r9, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB6AF8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB6AFC: 41980008  blt cr6, 0x82ab6b04
	if ctx.cr[6].lt {
	pc = 0x82AB6B04; continue 'dispatch;
	}
	pc = 0x82AB6B00; continue 'dispatch;
            }
            0x82AB6B00 => {
    //   block [0x82AB6B00..0x82AB6B04)
	// 82AB6B00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6B04; continue 'dispatch;
            }
            0x82AB6B04 => {
    //   block [0x82AB6B04..0x82AB6B20)
	// 82AB6B04: E9210060  ld r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AB6B08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB6B0C: 7D28592A  stdx r9, r8, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	// 82AB6B10: 419A0010  beq cr6, 0x82ab6b20
	if ctx.cr[6].eq {
	pc = 0x82AB6B20; continue 'dispatch;
	}
	// 82AB6B14: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AB6B18: 3908FFF8  addi r8, r8, -8
	ctx.r[8].s64 = ctx.r[8].s64 + -8;
	// 82AB6B1C: 4BFFFF88  b 0x82ab6aa4
	pc = 0x82AB6AA4; continue 'dispatch;
            }
            0x82AB6B20 => {
    //   block [0x82AB6B20..0x82AB6B38)
	// 82AB6B20: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B24: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB6B28: 419A0010  beq cr6, 0x82ab6b38
	if ctx.cr[6].eq {
	pc = 0x82AB6B38; continue 'dispatch;
	}
	// 82AB6B2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AB6B30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB6B34: 4800066D  bl 0x82ab71a0
	ctx.lr = 0x82AB6B38;
	sub_82AB71A0(ctx, base);
	pc = 0x82AB6B38; continue 'dispatch;
            }
            0x82AB6B38 => {
    //   block [0x82AB6B38..0x82AB6B88)
	// 82AB6B38: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B3C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82AB6B40: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82AB6B44: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B48: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AB6B4C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B50: 93A90000  stw r29, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AB6B54: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B58: 80FB0004  lwz r7, 4(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B5C: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82AB6B60: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B64: 90DB0004  stw r6, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82AB6B68: 911D0004  stw r8, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AB6B6C: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B70: 54A4003E  slwi r4, r5, 0
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82AB6B74: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B78: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82AB6B7C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AB6B80: 409A0008  bne cr6, 0x82ab6b88
	if !ctx.cr[6].eq {
	pc = 0x82AB6B88; continue 'dispatch;
	}
	// 82AB6B84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6B88; continue 'dispatch;
            }
            0x82AB6B88 => {
    //   block [0x82AB6B88..0x82AB6BC4)
	// 82AB6B88: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B8C: E9010068  ld r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82AB6B90: 81580024  lwz r10, 0x24(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB6B94: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6B98: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82AB6B9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB6BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6BA4: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82AB6BA8: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82AB6BAC: 419A0018  beq cr6, 0x82ab6bc4
	if ctx.cr[6].eq {
	pc = 0x82AB6BC4; continue 'dispatch;
	}
	// 82AB6BB0: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB6BB4: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB6BB8: 7D091E70  srawi r9, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82AB6BBC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB6BC0: 41980008  blt cr6, 0x82ab6bc8
	if ctx.cr[6].lt {
	pc = 0x82AB6BC8; continue 'dispatch;
	}
	pc = 0x82AB6BC4; continue 'dispatch;
            }
            0x82AB6BC4 => {
    //   block [0x82AB6BC4..0x82AB6BC8)
	// 82AB6BC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6BC8; continue 'dispatch;
            }
            0x82AB6BC8 => {
    //   block [0x82AB6BC8..0x82AB6BDC)
	// 82AB6BC8: E9210070  ld r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82AB6BCC: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AB6BD0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB6BD4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB6BD8: 7D28592A  stdx r9, r8, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	pc = 0x82AB6BDC; continue 'dispatch;
            }
            0x82AB6BDC => {
    //   block [0x82AB6BDC..0x82AB6BEC)
	// 82AB6BDC: 81580024  lwz r10, 0x24(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB6BE0: 7F195040  cmplw cr6, r25, r10
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6BE4: 40980084  bge cr6, 0x82ab6c68
	if !ctx.cr[6].lt {
	pc = 0x82AB6C68; continue 'dispatch;
	}
	// 82AB6BE8: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x82AB6BEC; continue 'dispatch;
            }
            0x82AB6BEC => {
    //   block [0x82AB6BEC..0x82AB6C10)
	// 82AB6BEC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6BF0: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6BF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6BF8: 419A0018  beq cr6, 0x82ab6c10
	if ctx.cr[6].eq {
	pc = 0x82AB6C10; continue 'dispatch;
	}
	// 82AB6BFC: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB6C00: 7CCB4850  subf r6, r11, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB6C04: 7CC91E70  srawi r9, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 82AB6C08: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB6C0C: 41980008  blt cr6, 0x82ab6c14
	if ctx.cr[6].lt {
	pc = 0x82AB6C14; continue 'dispatch;
	}
	pc = 0x82AB6C10; continue 'dispatch;
            }
            0x82AB6C10 => {
    //   block [0x82AB6C10..0x82AB6C14)
	// 82AB6C10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6C14; continue 'dispatch;
            }
            0x82AB6C14 => {
    //   block [0x82AB6C14..0x82AB6C4C)
	// 82AB6C14: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82AB6C18: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6C1C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB6C20: 409A0048  bne cr6, 0x82ab6c68
	if !ctx.cr[6].eq {
	pc = 0x82AB6C68; continue 'dispatch;
	}
	// 82AB6C24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6C28: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82AB6C2C: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82AB6C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6C34: 419A0018  beq cr6, 0x82ab6c4c
	if ctx.cr[6].eq {
	pc = 0x82AB6C4C; continue 'dispatch;
	}
	// 82AB6C38: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB6C3C: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB6C40: 7D091E70  srawi r9, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82AB6C44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB6C48: 41980008  blt cr6, 0x82ab6c50
	if ctx.cr[6].lt {
	pc = 0x82AB6C50; continue 'dispatch;
	}
	pc = 0x82AB6C4C; continue 'dispatch;
            }
            0x82AB6C4C => {
    //   block [0x82AB6C4C..0x82AB6C50)
	// 82AB6C4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6C50; continue 'dispatch;
            }
            0x82AB6C50 => {
    //   block [0x82AB6C50..0x82AB6C68)
	// 82AB6C50: E9210078  ld r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82AB6C54: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82AB6C58: 7F195040  cmplw cr6, r25, r10
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6C5C: 7D27592A  stdx r9, r7, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	// 82AB6C60: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 82AB6C64: 4198FF88  blt cr6, 0x82ab6bec
	if ctx.cr[6].lt {
	pc = 0x82AB6BEC; continue 'dispatch;
	}
	pc = 0x82AB6C68; continue 'dispatch;
            }
            0x82AB6C68 => {
    //   block [0x82AB6C68..0x82AB6C78)
	// 82AB6C68: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6C6C: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82AB6C70: 419A0008  beq cr6, 0x82ab6c78
	if ctx.cr[6].eq {
	pc = 0x82AB6C78; continue 'dispatch;
	}
	// 82AB6C74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6C78; continue 'dispatch;
            }
            0x82AB6C78 => {
    //   block [0x82AB6C78..0x82AB6C80)
	// 82AB6C78: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6C7C: 409AFD48  bne cr6, 0x82ab69c4
	if !ctx.cr[6].eq {
	pc = 0x82AB69C4; continue 'dispatch;
	}
	pc = 0x82AB6C80; continue 'dispatch;
            }
            0x82AB6C80 => {
    //   block [0x82AB6C80..0x82AB6C8C)
	// 82AB6C80: 81780024  lwz r11, 0x24(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB6C84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AB6C88: 91780024  stw r11, 0x24(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	pc = 0x82AB6C8C; continue 'dispatch;
            }
            0x82AB6C8C => {
    //   block [0x82AB6C8C..0x82AB6CB8)
	// 82AB6C8C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82AB6C90: 83F80020  lwz r31, 0x20(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB6C94: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82AB6C98: 4B7B7311  bl 0x8226dfa8
	ctx.lr = 0x82AB6C9C;
	sub_8226DFA8(ctx, base);
	// 82AB6C9C: 81780024  lwz r11, 0x24(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB6CA0: 7C68F838  and r8, r3, r31
	ctx.r[8].u64 = ctx.r[3].u64 & ctx.r[31].u64;
	// 82AB6CA4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB6CA8: 41990010  bgt cr6, 0x82ab6cb8
	if ctx.cr[6].gt {
	pc = 0x82AB6CB8; continue 'dispatch;
	}
	// 82AB6CAC: 57EBF87E  srwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB6CB0: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82AB6CB4: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	pc = 0x82AB6CB8; continue 'dispatch;
            }
            0x82AB6CB8 => {
    //   block [0x82AB6CB8..0x82AB6CE0)
	// 82AB6CB8: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB6CBC: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82AB6CC0: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 82AB6CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6CC8: 419A0018  beq cr6, 0x82ab6ce0
	if ctx.cr[6].eq {
	pc = 0x82AB6CE0; continue 'dispatch;
	}
	// 82AB6CCC: 81380018  lwz r9, 0x18(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB6CD0: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB6CD4: 7CE91E70  srawi r9, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB6CD8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB6CDC: 41980008  blt cr6, 0x82ab6ce4
	if ctx.cr[6].lt {
	pc = 0x82AB6CE4; continue 'dispatch;
	}
	pc = 0x82AB6CE0; continue 'dispatch;
            }
            0x82AB6CE0 => {
    //   block [0x82AB6CE0..0x82AB6CE4)
	// 82AB6CE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6CE4; continue 'dispatch;
            }
            0x82AB6CE4 => {
    //   block [0x82AB6CE4..0x82AB6D04)
	// 82AB6CE4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB6CE8: 38780004  addi r3, r24, 4
	ctx.r[3].s64 = ctx.r[24].s64 + 4;
	// 82AB6CEC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AB6CF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AB6CF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6CF8: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82AB6CFC: 409A0008  bne cr6, 0x82ab6d04
	if !ctx.cr[6].eq {
	pc = 0x82AB6D04; continue 'dispatch;
	}
	// 82AB6D00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6D04; continue 'dispatch;
            }
            0x82AB6D04 => {
    //   block [0x82AB6D04..0x82AB6D20)
	// 82AB6D04: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82AB6D08: 551D1838  slwi r29, r8, 3
	ctx.r[29].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82AB6D0C: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82AB6D10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82AB6D14: 81580014  lwz r10, 0x14(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB6D18: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AB6D1C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82AB6D20; continue 'dispatch;
            }
            0x82AB6D20 => {
    //   block [0x82AB6D20..0x82AB6D3C)
	// 82AB6D20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB6D24: 419A0018  beq cr6, 0x82ab6d3c
	if ctx.cr[6].eq {
	pc = 0x82AB6D3C; continue 'dispatch;
	}
	// 82AB6D28: 81780018  lwz r11, 0x18(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB6D2C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB6D30: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AB6D34: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6D38: 41980008  blt cr6, 0x82ab6d40
	if ctx.cr[6].lt {
	pc = 0x82AB6D40; continue 'dispatch;
	}
	pc = 0x82AB6D3C; continue 'dispatch;
            }
            0x82AB6D3C => {
    //   block [0x82AB6D3C..0x82AB6D40)
	// 82AB6D3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6D40; continue 'dispatch;
            }
            0x82AB6D40 => {
    //   block [0x82AB6D40..0x82AB6D5C)
	// 82AB6D40: 7D7D5214  add r11, r29, r10
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82AB6D44: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6D48: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AB6D4C: 419A0098  beq cr6, 0x82ab6de4
	if ctx.cr[6].eq {
	pc = 0x82AB6DE4; continue 'dispatch;
	}
	// 82AB6D50: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB6D54: 409A0008  bne cr6, 0x82ab6d5c
	if !ctx.cr[6].eq {
	pc = 0x82AB6D5C; continue 'dispatch;
	}
	// 82AB6D58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6D5C; continue 'dispatch;
            }
            0x82AB6D5C => {
    //   block [0x82AB6D5C..0x82AB6D78)
	// 82AB6D5C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6D60: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6D64: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6D68: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AB6D6C: 409A000C  bne cr6, 0x82ab6d78
	if !ctx.cr[6].eq {
	pc = 0x82AB6D78; continue 'dispatch;
	}
	// 82AB6D70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82AB6D74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6D78; continue 'dispatch;
            }
            0x82AB6D78 => {
    //   block [0x82AB6D78..0x82AB6D90)
	// 82AB6D78: E9750000  ld r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	// 82AB6D7C: E93F0008  ld r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 82AB6D80: 7F2B4840  cmpld cr6, r11, r9
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[9].u64, &mut ctx.xer);
	// 82AB6D84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AB6D88: 41980008  blt cr6, 0x82ab6d90
	if ctx.cr[6].lt {
	pc = 0x82AB6D90; continue 'dispatch;
	}
	// 82AB6D8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AB6D90; continue 'dispatch;
            }
            0x82AB6D90 => {
    //   block [0x82AB6D90..0x82AB6DAC)
	// 82AB6D90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AB6D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6D98: 409AFF88  bne cr6, 0x82ab6d20
	if !ctx.cr[6].eq {
	pc = 0x82AB6D20; continue 'dispatch;
	}
	// 82AB6D9C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6DA0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6DA4: 409A0008  bne cr6, 0x82ab6dac
	if !ctx.cr[6].eq {
	pc = 0x82AB6DAC; continue 'dispatch;
	}
	// 82AB6DA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6DAC; continue 'dispatch;
            }
            0x82AB6DAC => {
    //   block [0x82AB6DAC..0x82AB6DC4)
	// 82AB6DAC: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 82AB6DB0: E9350000  ld r9, 0(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	// 82AB6DB4: 7F2B4840  cmpld cr6, r11, r9
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[9].u64, &mut ctx.xer);
	// 82AB6DB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AB6DBC: 41980008  blt cr6, 0x82ab6dc4
	if ctx.cr[6].lt {
	pc = 0x82AB6DC4; continue 'dispatch;
	}
	// 82AB6DC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82AB6DC4; continue 'dispatch;
            }
            0x82AB6DC4 => {
    //   block [0x82AB6DC4..0x82AB6DDC)
	// 82AB6DC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AB6DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6DCC: 419A00D0  beq cr6, 0x82ab6e9c
	if ctx.cr[6].eq {
	pc = 0x82AB6E9C; continue 'dispatch;
	}
	// 82AB6DD0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6DD4: 409A0008  bne cr6, 0x82ab6ddc
	if !ctx.cr[6].eq {
	pc = 0x82AB6DDC; continue 'dispatch;
	}
	// 82AB6DD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6DDC; continue 'dispatch;
            }
            0x82AB6DDC => {
    //   block [0x82AB6DDC..0x82AB6DE4)
	// 82AB6DDC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB6DE0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x82AB6DE4; continue 'dispatch;
            }
            0x82AB6DE4 => {
    //   block [0x82AB6DE4..0x82AB6E00)
	// 82AB6DE4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB6DE8: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 82AB6DEC: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82AB6DF0: 48000301  bl 0x82ab70f0
	ctx.lr = 0x82AB6DF4;
	sub_82AB70F0(ctx, base);
	// 82AB6DF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AB6DF8: 409A0008  bne cr6, 0x82ab6e00
	if !ctx.cr[6].eq {
	pc = 0x82AB6E00; continue 'dispatch;
	}
	// 82AB6DFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6E00; continue 'dispatch;
            }
            0x82AB6E00 => {
    //   block [0x82AB6E00..0x82AB6E1C)
	// 82AB6E00: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AB6E04: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6E08: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6E0C: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82AB6E10: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6E14: 409A0008  bne cr6, 0x82ab6e1c
	if !ctx.cr[6].eq {
	pc = 0x82AB6E1C; continue 'dispatch;
	}
	// 82AB6E18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6E1C; continue 'dispatch;
            }
            0x82AB6E1C => {
    //   block [0x82AB6E1C..0x82AB6E20)
	// 82AB6E1C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x82AB6E20; continue 'dispatch;
            }
            0x82AB6E20 => {
    //   block [0x82AB6E20..0x82AB6E40)
	// 82AB6E20: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB6E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6E28: 419A0018  beq cr6, 0x82ab6e40
	if ctx.cr[6].eq {
	pc = 0x82AB6E40; continue 'dispatch;
	}
	// 82AB6E2C: 81580018  lwz r10, 0x18(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB6E30: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB6E34: 7CCA1E70  srawi r10, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 82AB6E38: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6E3C: 41980008  blt cr6, 0x82ab6e44
	if ctx.cr[6].lt {
	pc = 0x82AB6E44; continue 'dispatch;
	}
	pc = 0x82AB6E40; continue 'dispatch;
            }
            0x82AB6E40 => {
    //   block [0x82AB6E40..0x82AB6E44)
	// 82AB6E40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6E44; continue 'dispatch;
            }
            0x82AB6E44 => {
    //   block [0x82AB6E44..0x82AB6E7C)
	// 82AB6E44: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AB6E48: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6E4C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82AB6E50: 409A0068  bne cr6, 0x82ab6eb8
	if !ctx.cr[6].eq {
	pc = 0x82AB6EB8; continue 'dispatch;
	}
	// 82AB6E54: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB6E58: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82AB6E5C: 90E10078  stw r7, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 82AB6E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6E64: 419A0018  beq cr6, 0x82ab6e7c
	if ctx.cr[6].eq {
	pc = 0x82AB6E7C; continue 'dispatch;
	}
	// 82AB6E68: 81580018  lwz r10, 0x18(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB6E6C: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB6E70: 7CCA1E70  srawi r10, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 82AB6E74: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6E78: 41980008  blt cr6, 0x82ab6e80
	if ctx.cr[6].lt {
	pc = 0x82AB6E80; continue 'dispatch;
	}
	pc = 0x82AB6E7C; continue 'dispatch;
            }
            0x82AB6E7C => {
    //   block [0x82AB6E7C..0x82AB6E80)
	// 82AB6E7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6E80; continue 'dispatch;
            }
            0x82AB6E80 => {
    //   block [0x82AB6E80..0x82AB6E9C)
	// 82AB6E80: E9410078  ld r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82AB6E84: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AB6E88: 7D49592A  stdx r10, r9, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u64) };
	// 82AB6E8C: 419A002C  beq cr6, 0x82ab6eb8
	if ctx.cr[6].eq {
	pc = 0x82AB6EB8; continue 'dispatch;
	}
	// 82AB6E90: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 82AB6E94: 3929FFF8  addi r9, r9, -8
	ctx.r[9].s64 = ctx.r[9].s64 + -8;
	// 82AB6E98: 4BFFFF88  b 0x82ab6e20
	pc = 0x82AB6E20; continue 'dispatch;
            }
            0x82AB6E9C => {
    //   block [0x82AB6E9C..0x82AB6EB8)
	// 82AB6E9C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB6EA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB6EA4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82AB6EA8: 99540008  stb r10, 8(r20)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[20].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82AB6EAC: F9740000  std r11, 0(r20)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AB6EB0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82AB6EB4: 481F2584  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB6EB8 => {
    //   block [0x82AB6EB8..0x82AB6ED4)
	// 82AB6EB8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AB6EBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AB6EC0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82AB6EC4: 99540008  stb r10, 8(r20)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[20].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82AB6EC8: F9740000  std r11, 0(r20)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AB6ECC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82AB6ED0: 481F2568  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB6ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB6ED8 size=348
    let mut pc: u32 = 0x82AB6ED8;
    'dispatch: loop {
        match pc {
            0x82AB6ED8 => {
    //   block [0x82AB6ED8..0x82AB6F04)
	// 82AB6ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB6EDC: 481F2529  bl 0x82ca9404
	ctx.lr = 0x82AB6EE0;
	sub_82CA93D0(ctx, base);
	// 82AB6EE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB6EE4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82AB6EE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AB6EEC: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82AB6EF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AB6EF4: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82AB6EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6EFC: 409A0008  bne cr6, 0x82ab6f04
	if !ctx.cr[6].eq {
	pc = 0x82AB6F04; continue 'dispatch;
	}
	// 82AB6F00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6F04; continue 'dispatch;
            }
            0x82AB6F04 => {
    //   block [0x82AB6F04..0x82AB6F18)
	// 82AB6F04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6F08: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AB6F0C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6F10: 409A0008  bne cr6, 0x82ab6f18
	if !ctx.cr[6].eq {
	pc = 0x82AB6F18; continue 'dispatch;
	}
	// 82AB6F14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6F18; continue 'dispatch;
            }
            0x82AB6F18 => {
    //   block [0x82AB6F18..0x82AB6F44)
	// 82AB6F18: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 82AB6F1C: 83DF0020  lwz r30, 0x20(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AB6F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB6F24: 4B7B7085  bl 0x8226dfa8
	ctx.lr = 0x82AB6F28;
	sub_8226DFA8(ctx, base);
	// 82AB6F28: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AB6F2C: 7C6BF038  and r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[30].u64;
	// 82AB6F30: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6F34: 41990010  bgt cr6, 0x82ab6f44
	if ctx.cr[6].gt {
	pc = 0x82AB6F44; continue 'dispatch;
	}
	// 82AB6F38: 57CAF87E  srwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB6F3C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB6F40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82AB6F44; continue 'dispatch;
            }
            0x82AB6F44 => {
    //   block [0x82AB6F44..0x82AB6F4C)
	// 82AB6F44: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82AB6F48: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x82AB6F4C; continue 'dispatch;
            }
            0x82AB6F4C => {
    //   block [0x82AB6F4C..0x82AB6F6C)
	// 82AB6F4C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB6F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6F54: 419A0018  beq cr6, 0x82ab6f6c
	if ctx.cr[6].eq {
	pc = 0x82AB6F6C; continue 'dispatch;
	}
	// 82AB6F58: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB6F5C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB6F60: 7CEA1E70  srawi r10, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB6F64: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6F68: 41980008  blt cr6, 0x82ab6f70
	if ctx.cr[6].lt {
	pc = 0x82AB6F70; continue 'dispatch;
	}
	pc = 0x82AB6F6C; continue 'dispatch;
            }
            0x82AB6F6C => {
    //   block [0x82AB6F6C..0x82AB6F70)
	// 82AB6F6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6F70; continue 'dispatch;
            }
            0x82AB6F70 => {
    //   block [0x82AB6F70..0x82AB6FA0)
	// 82AB6F70: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82AB6F74: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6F78: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82AB6F7C: 409A009C  bne cr6, 0x82ab7018
	if !ctx.cr[6].eq {
	pc = 0x82AB7018; continue 'dispatch;
	}
	// 82AB6F80: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB6F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB6F88: 419A0018  beq cr6, 0x82ab6fa0
	if ctx.cr[6].eq {
	pc = 0x82AB6FA0; continue 'dispatch;
	}
	// 82AB6F8C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB6F90: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AB6F94: 7CEA1E70  srawi r10, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB6F98: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB6F9C: 41980008  blt cr6, 0x82ab6fa4
	if ctx.cr[6].lt {
	pc = 0x82AB6FA4; continue 'dispatch;
	}
	pc = 0x82AB6FA0; continue 'dispatch;
            }
            0x82AB6FA0 => {
    //   block [0x82AB6FA0..0x82AB6FA4)
	// 82AB6FA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6FA4; continue 'dispatch;
            }
            0x82AB6FA4 => {
    //   block [0x82AB6FA4..0x82AB6FBC)
	// 82AB6FA4: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82AB6FA8: 357F0004  addic. r11, r31, 4
	ctx.xer.ca = (ctx.r[31].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB6FAC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6FB0: 4082000C  bne 0x82ab6fbc
	if !ctx.cr[0].eq {
	pc = 0x82AB6FBC; continue 'dispatch;
	}
	// 82AB6FB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82AB6FB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6FBC; continue 'dispatch;
            }
            0x82AB6FBC => {
    //   block [0x82AB6FBC..0x82AB6FCC)
	// 82AB6FBC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB6FC0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AB6FC4: 409A0008  bne cr6, 0x82ab6fcc
	if !ctx.cr[6].eq {
	pc = 0x82AB6FCC; continue 'dispatch;
	}
	// 82AB6FC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6FCC; continue 'dispatch;
            }
            0x82AB6FCC => {
    //   block [0x82AB6FCC..0x82AB6FF8)
	// 82AB6FCC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB6FD0: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AB6FD4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AB6FD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB6FDC: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82AB6FE0: 419A0018  beq cr6, 0x82ab6ff8
	if ctx.cr[6].eq {
	pc = 0x82AB6FF8; continue 'dispatch;
	}
	// 82AB6FE4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AB6FE8: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB6FEC: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB6FF0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB6FF4: 41980008  blt cr6, 0x82ab6ffc
	if ctx.cr[6].lt {
	pc = 0x82AB6FFC; continue 'dispatch;
	}
	pc = 0x82AB6FF8; continue 'dispatch;
            }
            0x82AB6FF8 => {
    //   block [0x82AB6FF8..0x82AB6FFC)
	// 82AB6FF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB6FFC; continue 'dispatch;
            }
            0x82AB6FFC => {
    //   block [0x82AB6FFC..0x82AB7018)
	// 82AB6FFC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AB7000: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB7004: 7D68512A  stdx r11, r8, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u64) };
	// 82AB7008: 419A0010  beq cr6, 0x82ab7018
	if ctx.cr[6].eq {
	pc = 0x82AB7018; continue 'dispatch;
	}
	// 82AB700C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82AB7010: 3908FFF8  addi r8, r8, -8
	ctx.r[8].s64 = ctx.r[8].s64 + -8;
	// 82AB7014: 4BFFFF38  b 0x82ab6f4c
	pc = 0x82AB6F4C; continue 'dispatch;
            }
            0x82AB7018 => {
    //   block [0x82AB7018..0x82AB7034)
	// 82AB7018: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AB701C: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82AB7020: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB7024: 48000015  bl 0x82ab7038
	ctx.lr = 0x82AB7028;
	sub_82AB7038(ctx, base);
	// 82AB7028: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AB702C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB7030: 481F2424  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB7038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB7038 size=180
    let mut pc: u32 = 0x82AB7038;
    'dispatch: loop {
        match pc {
            0x82AB7038 => {
    //   block [0x82AB7038..0x82AB7064)
	// 82AB7038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB703C: 481F23D1  bl 0x82ca940c
	ctx.lr = 0x82AB7040;
	sub_82CA93D0(ctx, base);
	// 82AB7040: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB7044: F8A100A0  std r5, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u64 ) };
	// 82AB7048: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB704C: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82AB7050: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB7054: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82AB7058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB705C: 409A0008  bne cr6, 0x82ab7064
	if !ctx.cr[6].eq {
	pc = 0x82AB7064; continue 'dispatch;
	}
	// 82AB7060: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB7064; continue 'dispatch;
            }
            0x82AB7064 => {
    //   block [0x82AB7064..0x82AB7078)
	// 82AB7064: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7068: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AB706C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB7070: 409A0008  bne cr6, 0x82ab7078
	if !ctx.cr[6].eq {
	pc = 0x82AB7078; continue 'dispatch;
	}
	// 82AB7074: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82AB7078; continue 'dispatch;
            }
            0x82AB7078 => {
    //   block [0x82AB7078..0x82AB70D8)
	// 82AB7078: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB707C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AB7080: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7084: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB7088: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82AB708C: 419A004C  beq cr6, 0x82ab70d8
	if ctx.cr[6].eq {
	pc = 0x82AB70D8; continue 'dispatch;
	}
	// 82AB7090: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7094: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82AB7098: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB709C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB70A0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB70A4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB70A8: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AB70AC: 480AEF45  bl 0x82b65ff0
	ctx.lr = 0x82AB70B0;
	sub_82B65FF0(ctx, base);
	// 82AB70B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB70B4: 4B764C85  bl 0x8221bd38
	ctx.lr = 0x82AB70B8;
	sub_8221BD38(ctx, base);
	// 82AB70B8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB70BC: E8E100A0  ld r7, 0xa0(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82AB70C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB70C4: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 82AB70C8: 90DE0008  stw r6, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82AB70CC: F8FD0000  std r7, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 82AB70D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB70D4: 481F2388  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB70D8 => {
    //   block [0x82AB70D8..0x82AB70EC)
	// 82AB70D8: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82AB70DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB70E0: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AB70E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB70E8: 481F2374  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB70F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB70F0 size=176
    let mut pc: u32 = 0x82AB70F0;
    'dispatch: loop {
        match pc {
            0x82AB70F0 => {
    //   block [0x82AB70F0..0x82AB7128)
	// 82AB70F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB70F4: 481F230D  bl 0x82ca9400
	ctx.lr = 0x82AB70F8;
	sub_82CA93D0(ctx, base);
	// 82AB70F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB70FC: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82AB7100: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AB7104: 836100AC  lwz r27, 0xac(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82AB7108: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AB710C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AB7110: 839B0004  lwz r28, 4(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7114: 4B768145  bl 0x8221f258
	ctx.lr = 0x82AB7118;
	sub_8221F258(ctx, base);
	// 82AB7118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB711C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AB7120: 419A0008  beq cr6, 0x82ab7128
	if ctx.cr[6].eq {
	pc = 0x82AB7128; continue 'dispatch;
	}
	// 82AB7124: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82AB7128; continue 'dispatch;
            }
            0x82AB7128 => {
    //   block [0x82AB7128..0x82AB7138)
	// 82AB7128: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82AB712C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AB7130: 419A0008  beq cr6, 0x82ab7138
	if ctx.cr[6].eq {
	pc = 0x82AB7138; continue 'dispatch;
	}
	// 82AB7134: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82AB7138; continue 'dispatch;
            }
            0x82AB7138 => {
    //   block [0x82AB7138..0x82AB7164)
	// 82AB7138: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AB713C: 41820044  beq 0x82ab7180
	if ctx.cr[0].eq {
	pc = 0x82AB7180; continue 'dispatch;
	}
	// 82AB7140: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB7144: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB7148: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB714C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AB7150: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB7154: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB7158: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB715C: 419A0024  beq cr6, 0x82ab7180
	if ctx.cr[6].eq {
	pc = 0x82AB7180; continue 'dispatch;
	}
	// 82AB7160: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	pc = 0x82AB7164; continue 'dispatch;
            }
            0x82AB7164 => {
    //   block [0x82AB7164..0x82AB7180)
	// 82AB7164: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AB7168: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB716C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AB7170: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AB7174: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AB7178: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AB717C: 4082FFE8  bne 0x82ab7164
	if !ctx.cr[0].eq {
	pc = 0x82AB7164; continue 'dispatch;
	}
	pc = 0x82AB7180; continue 'dispatch;
            }
            0x82AB7180 => {
    //   block [0x82AB7180..0x82AB71A0)
	// 82AB7180: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AB7184: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AB7188: 48000019  bl 0x82ab71a0
	ctx.lr = 0x82AB718C;
	sub_82AB71A0(ctx, base);
	// 82AB718C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82AB7190: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB7194: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AB7198: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AB719C: 481F22B4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB71A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB71A0 size=132
    let mut pc: u32 = 0x82AB71A0;
    'dispatch: loop {
        match pc {
            0x82AB71A0 => {
    //   block [0x82AB71A0..0x82AB7210)
	// 82AB71A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB71A4: 481F2269  bl 0x82ca940c
	ctx.lr = 0x82AB71A8;
	sub_82CA93D0(ctx, base);
	// 82AB71A8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB71AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AB71B0: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82AB71B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AB71B8: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 82AB71BC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB71C0: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82AB71C4: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82AB71C8: 40980048  bge cr6, 0x82ab7210
	if !ctx.cr[6].lt {
	pc = 0x82AB7210; continue 'dispatch;
	}
	// 82AB71CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AB71D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB71D4: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82AB71D8: 4B83AD69  bl 0x822f1f40
	ctx.lr = 0x82AB71DC;
	sub_822F1F40(ctx, base);
	// 82AB71DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AB71E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB71E4: 4B83ABCD  bl 0x822f1db0
	ctx.lr = 0x82AB71E8;
	sub_822F1DB0(ctx, base);
	// 82AB71E8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AB71EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB71F0: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82AB71F4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82AB71F8: 4B83AC29  bl 0x822f1e20
	ctx.lr = 0x82AB71FC;
	sub_822F1E20(ctx, base);
	// 82AB71FC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82AB7200: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AB7204: 4BBC45DD  bl 0x8267b7e0
	ctx.lr = 0x82AB7208;
	sub_8267B7E0(ctx, base);
	// 82AB7208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB720C: 4B6BA605  bl 0x82171810
	ctx.lr = 0x82AB7210;
	sub_82171810(ctx, base);
	pc = 0x82AB7210; continue 'dispatch;
            }
            0x82AB7210 => {
    //   block [0x82AB7210..0x82AB7224)
	// 82AB7210: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB7214: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AB7218: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AB721C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AB7220: 481F223C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB7228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB7228 size=744
    let mut pc: u32 = 0x82AB7228;
    'dispatch: loop {
        match pc {
            0x82AB7228 => {
    //   block [0x82AB7228..0x82AB7258)
	// 82AB7228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB722C: 481F21DD  bl 0x82ca9408
	ctx.lr = 0x82AB7230;
	sub_82CA93D0(ctx, base);
	// 82AB7230: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB7234: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82AB7238: EBE60000  ld r31, 0(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 82AB723C: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 82AB7240: 3BAB5784  addi r29, r11, 0x5784
	ctx.r[29].s64 = ctx.r[11].s64 + 22404;
	// 82AB7244: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7248: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB724C: 409A000C  bne cr6, 0x82ab7258
	if !ctx.cr[6].eq {
	pc = 0x82AB7258; continue 'dispatch;
	}
	// 82AB7250: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AB7254: 48000010  b 0x82ab7264
	pc = 0x82AB7264; continue 'dispatch;
            }
            0x82AB7258 => {
    //   block [0x82AB7258..0x82AB7264)
	// 82AB7258: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AB725C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB7260: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	pc = 0x82AB7264; continue 'dispatch;
            }
            0x82AB7264 => {
    //   block [0x82AB7264..0x82AB7290)
	// 82AB7264: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB7268: 3D001FFF  lis r8, 0x1fff
	ctx.r[8].s64 = 536805376;
	// 82AB726C: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB7270: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 82AB7274: 7CE61E70  srawi r6, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB7278: 7CA64050  subf r5, r6, r8
	ctx.r[5].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 82AB727C: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 82AB7280: 40980010  bge cr6, 0x82ab7290
	if !ctx.cr[6].lt {
	pc = 0x82AB7290; continue 'dispatch;
	}
	// 82AB7284: 4BF90245  bl 0x82a474c8
	ctx.lr = 0x82AB7288;
	sub_82A474C8(ctx, base);
	// 82AB7288: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB728C: 481F21CC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB7290 => {
    //   block [0x82AB7290..0x82AB72BC)
	// 82AB7290: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB7294: 7CE71E70  srawi r7, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82AB7298: 38C70001  addi r6, r7, 1
	ctx.r[6].s64 = ctx.r[7].s64 + 1;
	// 82AB729C: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82AB72A0: 40980128  bge cr6, 0x82ab73c8
	if !ctx.cr[6].lt {
	pc = 0x82AB73C8; continue 'dispatch;
	}
	// 82AB72A4: 5527F87E  srwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82AB72A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AB72AC: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82AB72B0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB72B4: 41980008  blt cr6, 0x82ab72bc
	if ctx.cr[6].lt {
	pc = 0x82AB72BC; continue 'dispatch;
	}
	// 82AB72B8: 7F874A14  add r28, r7, r9
	ctx.r[28].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	pc = 0x82AB72BC; continue 'dispatch;
            }
            0x82AB72BC => {
    //   block [0x82AB72BC..0x82AB72DC)
	// 82AB72BC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB72C0: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82AB72C4: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 82AB72C8: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB72CC: 40980010  bge cr6, 0x82ab72dc
	if !ctx.cr[6].lt {
	pc = 0x82AB72DC; continue 'dispatch;
	}
	// 82AB72D0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AB72D4: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AB72D8: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	pc = 0x82AB72DC; continue 'dispatch;
            }
            0x82AB72DC => {
    //   block [0x82AB72DC..0x82AB7300)
	// 82AB72DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AB72E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AB72E4: 4BFF9675  bl 0x82ab0958
	ctx.lr = 0x82AB72E8;
	sub_82AB0958(ctx, base);
	// 82AB72E8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB72EC: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AB72F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AB72F4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82AB72F8: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AB72FC: 419A0030  beq cr6, 0x82ab732c
	if ctx.cr[6].eq {
	pc = 0x82AB732C; continue 'dispatch;
	}
	pc = 0x82AB7300; continue 'dispatch;
            }
            0x82AB7300 => {
    //   block [0x82AB7300..0x82AB7318)
	// 82AB7300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB7304: 419A0014  beq cr6, 0x82ab7318
	if ctx.cr[6].eq {
	pc = 0x82AB7318; continue 'dispatch;
	}
	// 82AB7308: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB730C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AB7310: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7314: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82AB7318; continue 'dispatch;
            }
            0x82AB7318 => {
    //   block [0x82AB7318..0x82AB732C)
	// 82AB7318: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AB731C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB7320: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AB7324: 409AFFDC  bne cr6, 0x82ab7300
	if !ctx.cr[6].eq {
	pc = 0x82AB7300; continue 'dispatch;
	}
	// 82AB7328: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82AB732C; continue 'dispatch;
            }
            0x82AB732C => {
    //   block [0x82AB732C..0x82AB733C)
	// 82AB732C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB7330: 419A000C  beq cr6, 0x82ab733c
	if ctx.cr[6].eq {
	pc = 0x82AB733C; continue 'dispatch;
	}
	// 82AB7334: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82AB7338: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82AB733C; continue 'dispatch;
            }
            0x82AB733C => {
    //   block [0x82AB733C..0x82AB7358)
	// 82AB733C: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB7340: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 82AB7344: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB7348: 419A0040  beq cr6, 0x82ab7388
	if ctx.cr[6].eq {
	pc = 0x82AB7388; continue 'dispatch;
	}
	// 82AB734C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82AB7350: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82AB7354: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	pc = 0x82AB7358; continue 'dispatch;
            }
            0x82AB7358 => {
    //   block [0x82AB7358..0x82AB7370)
	// 82AB7358: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AB735C: 419A0014  beq cr6, 0x82ab7370
	if ctx.cr[6].eq {
	pc = 0x82AB7370; continue 'dispatch;
	}
	// 82AB7360: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB7364: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AB7368: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB736C: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82AB7370; continue 'dispatch;
            }
            0x82AB7370 => {
    //   block [0x82AB7370..0x82AB7388)
	// 82AB7370: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB7374: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AB7378: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB737C: 409AFFDC  bne cr6, 0x82ab7358
	if !ctx.cr[6].eq {
	pc = 0x82AB7358; continue 'dispatch;
	}
	// 82AB7380: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AB7384: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82AB7388; continue 'dispatch;
            }
            0x82AB7388 => {
    //   block [0x82AB7388..0x82AB73A4)
	// 82AB7388: 7D6A4050  subf r11, r10, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82AB738C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB7390: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82AB7394: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82AB7398: 419A000C  beq cr6, 0x82ab73a4
	if ctx.cr[6].eq {
	pc = 0x82AB73A4; continue 'dispatch;
	}
	// 82AB739C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82AB73A0: 4B764999  bl 0x8221bd38
	ctx.lr = 0x82AB73A4;
	sub_8221BD38(ctx, base);
	pc = 0x82AB73A4; continue 'dispatch;
            }
            0x82AB73A4 => {
    //   block [0x82AB73A4..0x82AB73C8)
	// 82AB73A4: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AB73A8: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AB73AC: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AB73B0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82AB73B4: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82AB73B8: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AB73BC: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB73C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB73C4: 481F2094  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB73C8 => {
    //   block [0x82AB73C8..0x82AB73EC)
	// 82AB73C8: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AB73CC: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82AB73D0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AB73D4: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82AB73D8: 409800A0  bge cr6, 0x82ab7478
	if !ctx.cr[6].lt {
	pc = 0x82AB7478; continue 'dispatch;
	}
	// 82AB73DC: 39470008  addi r10, r7, 8
	ctx.r[10].s64 = ctx.r[7].s64 + 8;
	// 82AB73E0: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB73E4: 419A0034  beq cr6, 0x82ab7418
	if ctx.cr[6].eq {
	pc = 0x82AB7418; continue 'dispatch;
	}
	// 82AB73E8: 392AFFF8  addi r9, r10, -8
	ctx.r[9].s64 = ctx.r[10].s64 + -8;
	pc = 0x82AB73EC; continue 'dispatch;
            }
            0x82AB73EC => {
    //   block [0x82AB73EC..0x82AB7404)
	// 82AB73EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB73F0: 419A0014  beq cr6, 0x82ab7404
	if ctx.cr[6].eq {
	pc = 0x82AB7404; continue 'dispatch;
	}
	// 82AB73F4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB73F8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AB73FC: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7400: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	pc = 0x82AB7404; continue 'dispatch;
            }
            0x82AB7404 => {
    //   block [0x82AB7404..0x82AB7418)
	// 82AB7404: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AB7408: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AB740C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB7410: 409AFFDC  bne cr6, 0x82ab73ec
	if !ctx.cr[6].eq {
	pc = 0x82AB73EC; continue 'dispatch;
	}
	// 82AB7414: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AB7418; continue 'dispatch;
            }
            0x82AB7418 => {
    //   block [0x82AB7418..0x82AB742C)
	// 82AB7418: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82AB741C: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82AB7420: 21490001  subfic r10, r9, 1
	ctx.xer.ca = ctx.r[9].u32 <= 1 as u32;
	ctx.r[10].s64 = (1 as i64) - ctx.r[9].s64;
	// 82AB7424: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB7428: 419A0020  beq cr6, 0x82ab7448
	if ctx.cr[6].eq {
	pc = 0x82AB7448; continue 'dispatch;
	}
	pc = 0x82AB742C; continue 'dispatch;
            }
            0x82AB742C => {
    //   block [0x82AB742C..0x82AB7438)
	// 82AB742C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AB7430: 419A0008  beq cr6, 0x82ab7438
	if ctx.cr[6].eq {
	pc = 0x82AB7438; continue 'dispatch;
	}
	// 82AB7434: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	pc = 0x82AB7438; continue 'dispatch;
            }
            0x82AB7438 => {
    //   block [0x82AB7438..0x82AB7448)
	// 82AB7438: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AB743C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB7440: 4082FFEC  bne 0x82ab742c
	if !ctx.cr[0].eq {
	pc = 0x82AB742C; continue 'dispatch;
	}
	// 82AB7444: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82AB7448; continue 'dispatch;
            }
            0x82AB7448 => {
    //   block [0x82AB7448..0x82AB7460)
	// 82AB7448: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 82AB744C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82AB7450: 392AFFF8  addi r9, r10, -8
	ctx.r[9].s64 = ctx.r[10].s64 + -8;
	// 82AB7454: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB7458: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB745C: 419A00AC  beq cr6, 0x82ab7508
	if ctx.cr[6].eq {
	pc = 0x82AB7508; continue 'dispatch;
	}
	pc = 0x82AB7460; continue 'dispatch;
            }
            0x82AB7460 => {
    //   block [0x82AB7460..0x82AB7478)
	// 82AB7460: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82AB7464: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB7468: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AB746C: 409AFFF4  bne cr6, 0x82ab7460
	if !ctx.cr[6].eq {
	pc = 0x82AB7460; continue 'dispatch;
	}
	// 82AB7470: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB7474: 481F1FE4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82AB7478 => {
    //   block [0x82AB7478..0x82AB748C)
	// 82AB7478: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82AB747C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82AB7480: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82AB7484: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB7488: 419A002C  beq cr6, 0x82ab74b4
	if ctx.cr[6].eq {
	pc = 0x82AB74B4; continue 'dispatch;
	}
	pc = 0x82AB748C; continue 'dispatch;
            }
            0x82AB748C => {
    //   block [0x82AB748C..0x82AB74A4)
	// 82AB748C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AB7490: 419A0014  beq cr6, 0x82ab74a4
	if ctx.cr[6].eq {
	pc = 0x82AB74A4; continue 'dispatch;
	}
	// 82AB7494: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB7498: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82AB749C: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB74A0: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	pc = 0x82AB74A4; continue 'dispatch;
            }
            0x82AB74A4 => {
    //   block [0x82AB74A4..0x82AB74B4)
	// 82AB74A4: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82AB74A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AB74AC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB74B0: 409AFFDC  bne cr6, 0x82ab748c
	if !ctx.cr[6].eq {
	pc = 0x82AB748C; continue 'dispatch;
	}
	pc = 0x82AB74B4; continue 'dispatch;
            }
            0x82AB74B4 => {
    //   block [0x82AB74B4..0x82AB74C8)
	// 82AB74B4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82AB74B8: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB74BC: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB74C0: 419A0028  beq cr6, 0x82ab74e8
	if ctx.cr[6].eq {
	pc = 0x82AB74E8; continue 'dispatch;
	}
	// 82AB74C4: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	pc = 0x82AB74C8; continue 'dispatch;
            }
            0x82AB74C8 => {
    //   block [0x82AB74C8..0x82AB74E8)
	// 82AB74C8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82AB74CC: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82AB74D0: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AB74D4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB74D8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AB74DC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB74E0: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82AB74E4: 409AFFE4  bne cr6, 0x82ab74c8
	if !ctx.cr[6].eq {
	pc = 0x82AB74C8; continue 'dispatch;
	}
	pc = 0x82AB74E8; continue 'dispatch;
            }
            0x82AB74E8 => {
    //   block [0x82AB74E8..0x82AB74F8)
	// 82AB74E8: 39470008  addi r10, r7, 8
	ctx.r[10].s64 = ctx.r[7].s64 + 8;
	// 82AB74EC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82AB74F0: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB74F4: 419A0014  beq cr6, 0x82ab7508
	if ctx.cr[6].eq {
	pc = 0x82AB7508; continue 'dispatch;
	}
	pc = 0x82AB74F8; continue 'dispatch;
            }
            0x82AB74F8 => {
    //   block [0x82AB74F8..0x82AB7508)
	// 82AB74F8: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82AB74FC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82AB7500: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AB7504: 409AFFF4  bne cr6, 0x82ab74f8
	if !ctx.cr[6].eq {
	pc = 0x82AB74F8; continue 'dispatch;
	}
	pc = 0x82AB7508; continue 'dispatch;
            }
            0x82AB7508 => {
    //   block [0x82AB7508..0x82AB7510)
	// 82AB7508: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB750C: 481F1F4C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB7510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB7510 size=100
    let mut pc: u32 = 0x82AB7510;
    'dispatch: loop {
        match pc {
            0x82AB7510 => {
    //   block [0x82AB7510..0x82AB7548)
	// 82AB7510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB7514: 481F1EF9  bl 0x82ca940c
	ctx.lr = 0x82AB7518;
	sub_82CA93D0(ctx, base);
	// 82AB7518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB751C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AB7520: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AB7524: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7528: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB752C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AB7530: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7534: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AB7538: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB753C: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AB7540: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AB7544: 419A0028  beq cr6, 0x82ab756c
	if ctx.cr[6].eq {
	pc = 0x82AB756C; continue 'dispatch;
	}
	pc = 0x82AB7548; continue 'dispatch;
            }
            0x82AB7548 => {
    //   block [0x82AB7548..0x82AB756C)
	// 82AB7548: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82AB754C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB7550: 480AEAA1  bl 0x82b65ff0
	ctx.lr = 0x82AB7554;
	sub_82B65FF0(ctx, base);
	// 82AB7554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AB7558: 4B7647E1  bl 0x8221bd38
	ctx.lr = 0x82AB755C;
	sub_8221BD38(ctx, base);
	// 82AB755C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AB7560: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82AB7564: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AB7568: 409AFFE0  bne cr6, 0x82ab7548
	if !ctx.cr[6].eq {
	pc = 0x82AB7548; continue 'dispatch;
	}
	pc = 0x82AB756C; continue 'dispatch;
            }
            0x82AB756C => {
    //   block [0x82AB756C..0x82AB7574)
	// 82AB756C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AB7570: 481F1EEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AB7578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AB7578 size=96
    let mut pc: u32 = 0x82AB7578;
    'dispatch: loop {
        match pc {
            0x82AB7578 => {
    //   block [0x82AB7578..0x82AB75A0)
	// 82AB7578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AB757C: 481F1E91  bl 0x82ca940c
	ctx.lr = 0x82AB7580;
	sub_82CA93D0(ctx, base);
	// 82AB7580: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AB7584: 3D4082AB  lis r10, -0x7d55
	ctx.r[10].s64 = -2102722560;
	// 82AB7588: 39640040  addi r11, r4, 0x40
	ctx.r[11].s64 = ctx.r[4].s64 + 64;
	// 82AB758C: 392A56E8  addi r9, r10, 0x56e8
	ctx.r[9].s64 = ctx.r[10].s64 + 22248;
	// 82AB7590: 3BEB0020  addi r31, r11, 0x20
	ctx.r[31].s64 = ctx.r[11].s64 + 32;
	// 82AB7594: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AB7598: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 82AB759C: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	pc = 0x82AB75A0; continue 'dispatch;
            }
            0x82AB75A0 => {
    //   block [0x82AB75A0..0x82AB75C4)
	// 82AB75A0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AB75A4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AB75A8: 419A001C  beq cr6, 0x82ab75c4
	if ctx.cr[6].eq {
	pc = 0x82AB75C4; continue 'dispatch;
	}
	// 82AB75AC: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 82AB75B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AB75B4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AB75B8: 60A5FFFF  ori r5, r5, 0xffff
	ctx.r[5].u64 = ctx.r[5].u64 | 65535;
	// 82AB75BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AB75C0: 48000019  bl 0x82ab75d8
	ctx.lr = 0x82AB75C4;
	sub_82AB75D8(ctx, base);
	pc = 0x82AB75C4; continue 'dispatch;
            }
            0x82AB75C4 => {
    //   block [0x82AB75C4..0x82AB75D8)
	// 82AB75C4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AB75C8: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 82AB75CC: 4082FFD4  bne 0x82ab75a0
	if !ctx.cr[0].eq {
	pc = 0x82AB75A0; continue 'dispatch;
	}
	// 82AB75D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AB75D4: 481F1E88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


