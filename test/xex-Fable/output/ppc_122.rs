pub fn sub_82C5B970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5B970 size=8
    let mut pc: u32 = 0x82C5B970;
    'dispatch: loop {
        match pc {
            0x82C5B970 => {
    //   block [0x82C5B970..0x82C5B978)
	// 82C5B970: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82C5B974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5B978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5B978 size=8
    let mut pc: u32 = 0x82C5B978;
    'dispatch: loop {
        match pc {
            0x82C5B978 => {
    //   block [0x82C5B978..0x82C5B980)
	// 82C5B978: 38640030  addi r3, r4, 0x30
	ctx.r[3].s64 = ctx.r[4].s64 + 48;
	// 82C5B97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5B980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5B980 size=80
    let mut pc: u32 = 0x82C5B980;
    'dispatch: loop {
        match pc {
            0x82C5B980 => {
    //   block [0x82C5B980..0x82C5B9B8)
	// 82C5B980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5B984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5B988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5B98C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5B990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5B994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5B998: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5B99C: 48001585  bl 0x82c5cf20
	ctx.lr = 0x82C5B9A0;
	sub_82C5CF20(ctx, base);
	// 82C5B9A0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C5B9A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5B9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5B9AC: 419A000C  beq cr6, 0x82c5b9b8
	if ctx.cr[6].eq {
	pc = 0x82C5B9B8; continue 'dispatch;
	}
	// 82C5B9B0: 4BBE9E01  bl 0x828457b0
	ctx.lr = 0x82C5B9B4;
	sub_828457B0(ctx, base);
	// 82C5B9B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C5B9B8; continue 'dispatch;
            }
            0x82C5B9B8 => {
    //   block [0x82C5B9B8..0x82C5B9D0)
	// 82C5B9B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5B9BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5B9C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5B9C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5B9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5B9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5B9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5B9D0 size=68
    let mut pc: u32 = 0x82C5B9D0;
    'dispatch: loop {
        match pc {
            0x82C5B9D0 => {
    //   block [0x82C5B9D0..0x82C5BA14)
	// 82C5B9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5B9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5B9D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5B9DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5B9E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5B9E4: 48001525  bl 0x82c5cf08
	ctx.lr = 0x82C5B9E8;
	sub_82C5CF08(ctx, base);
	// 82C5B9E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5B9EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C5B9F0: 392BD19C  addi r9, r11, -0x2e64
	ctx.r[9].s64 = ctx.r[11].s64 + -11876;
	// 82C5B9F4: 915F0088  stw r10, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82C5B9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5B9FC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5BA00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5BA04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BA08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5BA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5BA18 size=96
    let mut pc: u32 = 0x82C5BA18;
    'dispatch: loop {
        match pc {
            0x82C5BA18 => {
    //   block [0x82C5BA18..0x82C5BA60)
	// 82C5BA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BA1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BA20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5BA24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5BA28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BA2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BA30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5BA34: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C5BA38: 394BD1CC  addi r10, r11, -0x2e34
	ctx.r[10].s64 = ctx.r[11].s64 + -11828;
	// 82C5BA3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5BA40: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5BA44: 4BFF215D  bl 0x82c4dba0
	ctx.lr = 0x82C5BA48;
	sub_82C4DBA0(ctx, base);
	// 82C5BA48: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C5BA4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5BA50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C5BA54: 419A000C  beq cr6, 0x82c5ba60
	if ctx.cr[6].eq {
	pc = 0x82C5BA60; continue 'dispatch;
	}
	// 82C5BA58: 4BBE9D59  bl 0x828457b0
	ctx.lr = 0x82C5BA5C;
	sub_828457B0(ctx, base);
	// 82C5BA5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C5BA60; continue 'dispatch;
            }
            0x82C5BA60 => {
    //   block [0x82C5BA60..0x82C5BA78)
	// 82C5BA60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5BA64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BA68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BA6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5BA70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5BA74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5BA78 size=60
    let mut pc: u32 = 0x82C5BA78;
    'dispatch: loop {
        match pc {
            0x82C5BA78 => {
    //   block [0x82C5BA78..0x82C5BAB4)
	// 82C5BA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BA7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BA80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BA84: D021007C  stfs f1, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82C5BA88: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5BA8C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82C5BA90: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 82C5BA94: 38630038  addi r3, r3, 0x38
	ctx.r[3].s64 = ctx.r[3].s64 + 56;
	// 82C5BA98: 816B5164  lwz r11, 0x5164(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20836 as u32) ) } as u64;
	// 82C5BA9C: 808B005C  lwz r4, 0x5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C5BAA0: 4BFB76F1  bl 0x82c13190
	ctx.lr = 0x82C5BAA4;
	sub_82C13190(ctx, base);
	// 82C5BAA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5BAA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BAAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BAB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5BAB8 size=60
    let mut pc: u32 = 0x82C5BAB8;
    'dispatch: loop {
        match pc {
            0x82C5BAB8 => {
    //   block [0x82C5BAB8..0x82C5BAF4)
	// 82C5BAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BAC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BAC4: D021007C  stfs f1, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82C5BAC8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5BACC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82C5BAD0: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 82C5BAD4: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 82C5BAD8: 816B5164  lwz r11, 0x5164(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20836 as u32) ) } as u64;
	// 82C5BADC: 808B005C  lwz r4, 0x5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C5BAE0: 4BFB76B1  bl 0x82c13190
	ctx.lr = 0x82C5BAE4;
	sub_82C13190(ctx, base);
	// 82C5BAE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5BAE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BAEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BAF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5BAF8 size=148
    let mut pc: u32 = 0x82C5BAF8;
    'dispatch: loop {
        match pc {
            0x82C5BAF8 => {
    //   block [0x82C5BAF8..0x82C5BB50)
	// 82C5BAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BAFC: 4804D909  bl 0x82ca9404
	ctx.lr = 0x82C5BB00;
	sub_82CA93D0(ctx, base);
	// 82C5BB00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BB04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5BB08: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5BB0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C5BB10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5BB14: 8B9E004C  lbz r28, 0x4c(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C5BB18: 7F8B0034  cntlzw r11, r28
	ctx.r[11].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 82C5BB1C: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82C5BB20: 995E004C  stb r10, 0x4c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[10].u8 ) };
	// 82C5BB24: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5BB28: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5BB2C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C5BB30: 4E800421  bctrl
	ctx.lr = 0x82C5BB34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5BB34: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 82C5BB38: 4BFF1481  bl 0x82c4cfb8
	ctx.lr = 0x82C5BB3C;
	sub_82C4CFB8(ctx, base);
	// 82C5BB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BB40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5BB44: 419A0040  beq cr6, 0x82c5bb84
	if ctx.cr[6].eq {
	pc = 0x82C5BB84; continue 'dispatch;
	}
	// 82C5BB48: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82C5BB4C: 3B7E0004  addi r27, r30, 4
	ctx.r[27].s64 = ctx.r[30].s64 + 4;
            }
            0x82C5BB50 => {
    //   block [0x82C5BB50..0x82C5BB68)
	// 82C5BB50: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5BB54: 8963004C  lbz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C5BB58: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C5BB5C: 409A000C  bne cr6, 0x82c5bb68
	if !ctx.cr[6].eq {
	pc = 0x82C5BB68; continue 'dispatch;
	}
	// 82C5BB60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C5BB64: 4BFFFF95  bl 0x82c5baf8
	ctx.lr = 0x82C5BB68;
	sub_82C5BAF8(ctx, base);
	pc = 0x82C5BB68; continue 'dispatch;
            }
            0x82C5BB68 => {
    //   block [0x82C5BB68..0x82C5BB84)
	// 82C5BB68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C5BB6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C5BB70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C5BB74: 4BFF19D5  bl 0x82c4d548
	ctx.lr = 0x82C5BB78;
	sub_82C4D548(ctx, base);
	// 82C5BB78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BB7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5BB80: 409AFFD0  bne cr6, 0x82c5bb50
	if !ctx.cr[6].eq {
	pc = 0x82C5BB50; continue 'dispatch;
	}
	pc = 0x82C5BB84; continue 'dispatch;
            }
            0x82C5BB84 => {
    //   block [0x82C5BB84..0x82C5BB8C)
	// 82C5BB84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5BB88: 4804D8CC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5BB90 size=88
    let mut pc: u32 = 0x82C5BB90;
    'dispatch: loop {
        match pc {
            0x82C5BB90 => {
    //   block [0x82C5BB90..0x82C5BBCC)
	// 82C5BB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BB94: 4804D879  bl 0x82ca940c
	ctx.lr = 0x82C5BB98;
	sub_82CA93D0(ctx, base);
	// 82C5BB98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BB9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5BBA0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82C5BBA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5BBA8: 4B5C36B1  bl 0x8221f258
	ctx.lr = 0x82C5BBAC;
	sub_8221F258(ctx, base);
	// 82C5BBAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BBB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5BBB4: 419A0018  beq cr6, 0x82c5bbcc
	if ctx.cr[6].eq {
	pc = 0x82C5BBCC; continue 'dispatch;
	}
	// 82C5BBB8: 4BFF1ED9  bl 0x82c4da90
	ctx.lr = 0x82C5BBBC;
	sub_82C4DA90(ctx, base);
	// 82C5BBBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5BBC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C5BBC4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C5BBC8: 48000008  b 0x82c5bbd0
	pc = 0x82C5BBD0; continue 'dispatch;
            }
            0x82C5BBCC => {
    //   block [0x82C5BBCC..0x82C5BBD0)
	// 82C5BBCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x82C5BBD0; continue 'dispatch;
            }
            0x82C5BBD0 => {
    //   block [0x82C5BBD0..0x82C5BBE8)
	// 82C5BBD0: 93A50014  stw r29, 0x14(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82C5BBD4: 389E001C  addi r4, r30, 0x1c
	ctx.r[4].s64 = ctx.r[30].s64 + 28;
	// 82C5BBD8: 38640004  addi r3, r4, 4
	ctx.r[3].s64 = ctx.r[4].s64 + 4;
	// 82C5BBDC: 4BFF16E5  bl 0x82c4d2c0
	ctx.lr = 0x82C5BBE0;
	sub_82C4D2C0(ctx, base);
	// 82C5BBE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5BBE4: 4804D878  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5BBE8 size=116
    let mut pc: u32 = 0x82C5BBE8;
    'dispatch: loop {
        match pc {
            0x82C5BBE8 => {
    //   block [0x82C5BBE8..0x82C5BC2C)
	// 82C5BBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BBEC: 4804D81D  bl 0x82ca9408
	ctx.lr = 0x82C5BBF0;
	sub_82CA93D0(ctx, base);
	// 82C5BBF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BBF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5BBF8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5BBFC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C5BC00: 895E004C  lbz r10, 0x4c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C5BC04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5BC08: 419A004C  beq cr6, 0x82c5bc54
	if ctx.cr[6].eq {
	pc = 0x82C5BC54; continue 'dispatch;
	}
	// 82C5BC0C: 9BBE004C  stb r29, 0x4c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[29].u8 ) };
	// 82C5BC10: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 82C5BC14: 4BFF13A5  bl 0x82c4cfb8
	ctx.lr = 0x82C5BC18;
	sub_82C4CFB8(ctx, base);
	// 82C5BC18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BC1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5BC20: 419A0034  beq cr6, 0x82c5bc54
	if ctx.cr[6].eq {
	pc = 0x82C5BC54; continue 'dispatch;
	}
	// 82C5BC24: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82C5BC28: 3B9E0004  addi r28, r30, 4
	ctx.r[28].s64 = ctx.r[30].s64 + 4;
	pc = 0x82C5BC2C; continue 'dispatch;
            }
            0x82C5BC2C => {
    //   block [0x82C5BC2C..0x82C5BC54)
	// 82C5BC2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C5BC30: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5BC34: 4BFFFFB5  bl 0x82c5bbe8
	ctx.lr = 0x82C5BC38;
	sub_82C5BBE8(ctx, base);
	// 82C5BC38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C5BC3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C5BC40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C5BC44: 4BFF1905  bl 0x82c4d548
	ctx.lr = 0x82C5BC48;
	sub_82C4D548(ctx, base);
	// 82C5BC48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BC4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5BC50: 409AFFDC  bne cr6, 0x82c5bc2c
	if !ctx.cr[6].eq {
	pc = 0x82C5BC2C; continue 'dispatch;
	}
	pc = 0x82C5BC54; continue 'dispatch;
            }
            0x82C5BC54 => {
    //   block [0x82C5BC54..0x82C5BC5C)
	// 82C5BC54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5BC58: 4804D800  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5BC60 size=68
    let mut pc: u32 = 0x82C5BC60;
    'dispatch: loop {
        match pc {
            0x82C5BC60 => {
    //   block [0x82C5BC60..0x82C5BCA4)
	// 82C5BC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BC68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BC6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5BC70: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82C5BC74: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5BC78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C5BC7C: 392AD108  addi r9, r10, -0x2ef8
	ctx.r[9].s64 = ctx.r[10].s64 + -12024;
	// 82C5BC80: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5BC84: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C5BC88: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C5BC8C: 4BFFFE6D  bl 0x82c5baf8
	ctx.lr = 0x82C5BC90;
	sub_82C5BAF8(ctx, base);
	// 82C5BC90: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5BC94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5BC98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BC9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BCA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5BCA8 size=68
    let mut pc: u32 = 0x82C5BCA8;
    'dispatch: loop {
        match pc {
            0x82C5BCA8 => {
    //   block [0x82C5BCA8..0x82C5BCEC)
	// 82C5BCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BCAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BCB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BCB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5BCB8: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82C5BCBC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5BCC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C5BCC4: 392AD110  addi r9, r10, -0x2ef0
	ctx.r[9].s64 = ctx.r[10].s64 + -12016;
	// 82C5BCC8: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5BCCC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C5BCD0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C5BCD4: 4BFFFE25  bl 0x82c5baf8
	ctx.lr = 0x82C5BCD8;
	sub_82C5BAF8(ctx, base);
	// 82C5BCD8: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5BCDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5BCE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BCE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BCE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5BCF0 size=60
    let mut pc: u32 = 0x82C5BCF0;
    'dispatch: loop {
        match pc {
            0x82C5BCF0 => {
    //   block [0x82C5BCF0..0x82C5BD2C)
	// 82C5BCF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BCF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BCF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BCFC: D021007C  stfs f1, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82C5BD00: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5BD04: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82C5BD08: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 82C5BD0C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82C5BD10: 816B5164  lwz r11, 0x5164(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20836 as u32) ) } as u64;
	// 82C5BD14: 808B005C  lwz r4, 0x5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C5BD18: 4BFB7479  bl 0x82c13190
	ctx.lr = 0x82C5BD1C;
	sub_82C13190(ctx, base);
	// 82C5BD1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5BD20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BD24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BD28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5BD30 size=120
    let mut pc: u32 = 0x82C5BD30;
    'dispatch: loop {
        match pc {
            0x82C5BD30 => {
    //   block [0x82C5BD30..0x82C5BD90)
	// 82C5BD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BD34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BD38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5BD3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5BD40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BD44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BD48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5BD4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5BD50: 394BD130  addi r10, r11, -0x2ed0
	ctx.r[10].s64 = ctx.r[11].s64 + -11984;
	// 82C5BD54: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82C5BD58: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5BD5C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82C5BD60: 4BFB2721  bl 0x82c0e480
	ctx.lr = 0x82C5BD64;
	sub_82C0E480(ctx, base);
	// 82C5BD64: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C5BD68: 4BF3B111  bl 0x82b96e78
	ctx.lr = 0x82C5BD6C;
	sub_82B96E78(ctx, base);
	// 82C5BD6C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C5BD70: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C5BD74: 38E9D090  addi r7, r9, -0x2f70
	ctx.r[7].s64 = ctx.r[9].s64 + -12144;
	// 82C5BD78: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C5BD7C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C5BD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5BD84: 419A000C  beq cr6, 0x82c5bd90
	if ctx.cr[6].eq {
	pc = 0x82C5BD90; continue 'dispatch;
	}
	// 82C5BD88: 4BBE9A29  bl 0x828457b0
	ctx.lr = 0x82C5BD8C;
	sub_828457B0(ctx, base);
	// 82C5BD8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C5BD90; continue 'dispatch;
            }
            0x82C5BD90 => {
    //   block [0x82C5BD90..0x82C5BDA8)
	// 82C5BD90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5BD94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BD98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BD9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5BDA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5BDA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5BDA8 size=88
    let mut pc: u32 = 0x82C5BDA8;
    'dispatch: loop {
        match pc {
            0x82C5BDA8 => {
    //   block [0x82C5BDA8..0x82C5BDDC)
	// 82C5BDA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BDAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BDB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BDB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5BDB8: D021007C  stfs f1, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82C5BDBC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82C5BDC0: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5BDC4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5BDC8: 41980014  blt cr6, 0x82c5bddc
	if ctx.cr[6].lt {
	pc = 0x82C5BDDC; continue 'dispatch;
	}
	// 82C5BDCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5BDD0: C00B0A4C  lfs f0, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5BDD4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5BDD8: 40990008  ble cr6, 0x82c5bde0
	if !ctx.cr[6].gt {
	pc = 0x82C5BDE0; continue 'dispatch;
	}
	pc = 0x82C5BDDC; continue 'dispatch;
            }
            0x82C5BDDC => {
    //   block [0x82C5BDDC..0x82C5BDE0)
	// 82C5BDDC: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	pc = 0x82C5BDE0; continue 'dispatch;
            }
            0x82C5BDE0 => {
    //   block [0x82C5BDE0..0x82C5BE00)
	// 82C5BDE0: 8083005C  lwz r4, 0x5c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C5BDE4: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 82C5BDE8: 3863002C  addi r3, r3, 0x2c
	ctx.r[3].s64 = ctx.r[3].s64 + 44;
	// 82C5BDEC: 4BFB73A5  bl 0x82c13190
	ctx.lr = 0x82C5BDF0;
	sub_82C13190(ctx, base);
	// 82C5BDF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5BDF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BDF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BDFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5BE00 size=96
    let mut pc: u32 = 0x82C5BE00;
    'dispatch: loop {
        match pc {
            0x82C5BE00 => {
    //   block [0x82C5BE00..0x82C5BE48)
	// 82C5BE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BE04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BE08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5BE0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5BE10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BE14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BE18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5BE1C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C5BE20: 394BD1A4  addi r10, r11, -0x2e5c
	ctx.r[10].s64 = ctx.r[11].s64 + -11868;
	// 82C5BE24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5BE28: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5BE2C: 4BFF1D75  bl 0x82c4dba0
	ctx.lr = 0x82C5BE30;
	sub_82C4DBA0(ctx, base);
	// 82C5BE30: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C5BE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5BE38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C5BE3C: 419A000C  beq cr6, 0x82c5be48
	if ctx.cr[6].eq {
	pc = 0x82C5BE48; continue 'dispatch;
	}
	// 82C5BE40: 4BBE9971  bl 0x828457b0
	ctx.lr = 0x82C5BE44;
	sub_828457B0(ctx, base);
	// 82C5BE44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C5BE48; continue 'dispatch;
            }
            0x82C5BE48 => {
    //   block [0x82C5BE48..0x82C5BE60)
	// 82C5BE48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5BE4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BE50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BE54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5BE58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5BE5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5BE60 size=112
    let mut pc: u32 = 0x82C5BE60;
    'dispatch: loop {
        match pc {
            0x82C5BE60 => {
    //   block [0x82C5BE60..0x82C5BED0)
	// 82C5BE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BE64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BE68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5BE6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BE70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BE74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5BE78: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5BE7C: 392BD1F4  addi r9, r11, -0x2e0c
	ctx.r[9].s64 = ctx.r[11].s64 + -11788;
	// 82C5BE80: 390AD1A4  addi r8, r10, -0x2e5c
	ctx.r[8].s64 = ctx.r[10].s64 + -11868;
	// 82C5BE84: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5BE88: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82C5BE8C: 911F001C  stw r8, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 82C5BE90: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C5BE94: 4BFF1D0D  bl 0x82c4dba0
	ctx.lr = 0x82C5BE98;
	sub_82C4DBA0(ctx, base);
	// 82C5BE98: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C5BE9C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82C5BEA0: 38C7D1CC  addi r6, r7, -0x2e34
	ctx.r[6].s64 = ctx.r[7].s64 + -11828;
	// 82C5BEA4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C5BEA8: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82C5BEAC: 4BFF1CF5  bl 0x82c4dba0
	ctx.lr = 0x82C5BEB0;
	sub_82C4DBA0(ctx, base);
	// 82C5BEB0: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82C5BEB4: 3885A0E8  addi r4, r5, -0x5f18
	ctx.r[4].s64 = ctx.r[5].s64 + -24344;
	// 82C5BEB8: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C5BEBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5BEC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BEC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BEC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5BECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5BED0 size=116
    let mut pc: u32 = 0x82C5BED0;
    'dispatch: loop {
        match pc {
            0x82C5BED0 => {
    //   block [0x82C5BED0..0x82C5BF2C)
	// 82C5BED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5BEDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5BEE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BEE4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C5BEE8: 3BE3001C  addi r31, r3, 0x1c
	ctx.r[31].s64 = ctx.r[3].s64 + 28;
	// 82C5BEEC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82C5BEF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C5BEF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5BEF8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C5BEFC: 4BFF12DD  bl 0x82c4d1d8
	ctx.lr = 0x82C5BF00;
	sub_82C4D1D8(ctx, base);
	// 82C5BF00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5BF04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5BF08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C5BF0C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C5BF10: 4BFF1B29  bl 0x82c4da38
	ctx.lr = 0x82C5BF14;
	sub_82C4DA38(ctx, base);
	// 82C5BF14: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C5BF18: 419A0014  beq cr6, 0x82c5bf2c
	if ctx.cr[6].eq {
	pc = 0x82C5BF2C; continue 'dispatch;
	}
	// 82C5BF1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5BF20: 4BF3AF59  bl 0x82b96e78
	ctx.lr = 0x82C5BF24;
	sub_82B96E78(ctx, base);
	// 82C5BF24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5BF28: 4BBE9889  bl 0x828457b0
	ctx.lr = 0x82C5BF2C;
	sub_828457B0(ctx, base);
	pc = 0x82C5BF2C; continue 'dispatch;
            }
            0x82C5BF2C => {
    //   block [0x82C5BF2C..0x82C5BF44)
	// 82C5BF2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5BF30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5BF34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5BF38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5BF3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5BF40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5BF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5BF48 size=200
    let mut pc: u32 = 0x82C5BF48;
    'dispatch: loop {
        match pc {
            0x82C5BF48 => {
    //   block [0x82C5BF48..0x82C5C010)
	// 82C5BF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5BF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5BF50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5BF54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5BF58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5BF5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5BF60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5BF64: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5BF68: 392BD1F4  addi r9, r11, -0x2e0c
	ctx.r[9].s64 = ctx.r[11].s64 + -11788;
	// 82C5BF6C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C5BF70: 390AD1CC  addi r8, r10, -0x2e34
	ctx.r[8].s64 = ctx.r[10].s64 + -11828;
	// 82C5BF74: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5BF78: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C5BF7C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82C5BF80: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82C5BF84: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82C5BF88: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C5BF8C: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82C5BF90: 4BFF1B19  bl 0x82c4daa8
	ctx.lr = 0x82C5BF94;
	sub_82C4DAA8(ctx, base);
	// 82C5BF94: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C5BF98: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82C5BF9C: 38A7D1CC  addi r5, r7, -0x2e34
	ctx.r[5].s64 = ctx.r[7].s64 + -11828;
	// 82C5BFA0: 3886D1A4  addi r4, r6, -0x2e5c
	ctx.r[4].s64 = ctx.r[6].s64 + -11868;
	// 82C5BFA4: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 82C5BFA8: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82C5BFAC: 909F001C  stw r4, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82C5BFB0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C5BFB4: 4BFF1AF5  bl 0x82c4daa8
	ctx.lr = 0x82C5BFB8;
	sub_82C4DAA8(ctx, base);
	// 82C5BFB8: 3C608201  lis r3, -0x7dff
	ctx.r[3].s64 = -2113863680;
	// 82C5BFBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5BFC0: 3943D1A4  addi r10, r3, -0x2e5c
	ctx.r[10].s64 = ctx.r[3].s64 + -11868;
	// 82C5BFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5BFC8: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C5BFCC: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82C5BFD0: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5BFD4: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82C5BFD8: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82C5BFDC: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82C5BFE0: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82C5BFE4: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82C5BFE8: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82C5BFEC: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82C5BFF0: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82C5BFF4: 9BDF004C  stb r30, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u8 ) };
	// 82C5BFF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5BFFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C004: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5C008: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5C00C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5C010 size=80
    let mut pc: u32 = 0x82C5C010;
    'dispatch: loop {
        match pc {
            0x82C5C010 => {
    //   block [0x82C5C010..0x82C5C048)
	// 82C5C010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5C018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5C01C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5C020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5C028: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5C02C: 4BFFFE35  bl 0x82c5be60
	ctx.lr = 0x82C5C030;
	sub_82C5BE60(ctx, base);
	// 82C5C030: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C5C034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5C038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5C03C: 419A000C  beq cr6, 0x82c5c048
	if ctx.cr[6].eq {
	pc = 0x82C5C048; continue 'dispatch;
	}
	// 82C5C040: 4BBE9771  bl 0x828457b0
	ctx.lr = 0x82C5C044;
	sub_828457B0(ctx, base);
	// 82C5C044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C5C048; continue 'dispatch;
            }
            0x82C5C048 => {
    //   block [0x82C5C048..0x82C5C060)
	// 82C5C048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5C04C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C054: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5C058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5C05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5C060 size=616
    let mut pc: u32 = 0x82C5C060;
    'dispatch: loop {
        match pc {
            0x82C5C060 => {
    //   block [0x82C5C060..0x82C5C170)
	// 82C5C060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C064: 4804D399  bl 0x82ca93fc
	ctx.lr = 0x82C5C068;
	sub_82CA93D0(ctx, base);
	// 82C5C068: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82C5C06C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82C5C070: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C074: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5C078: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5C07C: 39030010  addi r8, r3, 0x10
	ctx.r[8].s64 = ctx.r[3].s64 + 16;
	// 82C5C080: 3BCB5168  addi r30, r11, 0x5168
	ctx.r[30].s64 = ctx.r[11].s64 + 20840;
	// 82C5C084: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82C5C088: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C5C08C: 816B5168  lwz r11, 0x5168(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20840 as u32) ) } as u64;
	// 82C5C090: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C5C094: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C5C098: 613BBB80  ori r27, r9, 0xbb80
	ctx.r[27].u64 = ctx.r[9].u64 | 48000;
	// 82C5C09C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82C5C0A0: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C5C0A4: 3B800005  li r28, 5
	ctx.r[28].s64 = 5;
	// 82C5C0A8: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82C5C0AC: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 82C5C0B0: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82C5C0B4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C5C0B8: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82C5C0BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C5C0C0: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82C5C0C4: 38A10108  addi r5, r1, 0x108
	ctx.r[5].s64 = ctx.r[1].s64 + 264;
	// 82C5C0C8: 9BA10128  stb r29, 0x128(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[29].u8 ) };
	// 82C5C0CC: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 82C5C0D0: 90E1012C  stw r7, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[7].u32 ) };
	// 82C5C0D4: 39210128  addi r9, r1, 0x128
	ctx.r[9].s64 = ctx.r[1].s64 + 296;
	// 82C5C0D8: 9BE10060  stb r31, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	// 82C5C0DC: 39010120  addi r8, r1, 0x120
	ctx.r[8].s64 = ctx.r[1].s64 + 288;
	// 82C5C0E0: 9BE10061  stb r31, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[31].u8 ) };
	// 82C5C0E4: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	// 82C5C0E8: 9BE10068  stb r31, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u8 ) };
	// 82C5C0EC: 9BA10069  stb r29, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[29].u8 ) };
	// 82C5C0F0: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 82C5C0F4: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 82C5C0F8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82C5C0FC: 9B410071  stb r26, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[26].u8 ) };
	// 82C5C100: 9BE10078  stb r31, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u8 ) };
	// 82C5C104: 9B210079  stb r25, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[25].u8 ) };
	// 82C5C108: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82C5C10C: 9B810081  stb r28, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[28].u8 ) };
	// 82C5C110: 9B810108  stb r28, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[28].u8 ) };
	// 82C5C114: 90C1010C  stw r6, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[6].u32 ) };
	// 82C5C118: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82C5C11C: 90A10114  stw r5, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[5].u32 ) };
	// 82C5C120: 9BA10120  stb r29, 0x120(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[29].u8 ) };
	// 82C5C124: 91410124  stw r10, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[10].u32 ) };
	// 82C5C128: 9BE100C0  stb r31, 0xc0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u8 ) };
	// 82C5C12C: 936100C4  stw r27, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[27].u32 ) };
	// 82C5C130: 9BA100C1  stb r29, 0xc1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(193 as u32), ctx.r[29].u8 ) };
	// 82C5C134: 9BA100C8  stb r29, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u8 ) };
	// 82C5C138: 9B8100C9  stb r28, 0xc9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(201 as u32), ctx.r[28].u8 ) };
	// 82C5C13C: 9B2100CA  stb r25, 0xca(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(202 as u32), ctx.r[25].u8 ) };
	// 82C5C140: 912100CC  stw r9, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[9].u32 ) };
	// 82C5C144: 910100D0  stw r8, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[8].u32 ) };
	// 82C5C148: 93E100D4  stw r31, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[31].u32 ) };
	// 82C5C14C: 93E100D8  stw r31, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[31].u32 ) };
	// 82C5C150: 4807DA11  bl 0x82cd9b60
	ctx.lr = 0x82C5C154;
	sub_82CD9B60(ctx, base);
	// 82C5C154: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C5C158: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5C15C: C3C70C18  lfs f30, 0xc18(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C5C160: 40980010  bge cr6, 0x82c5c170
	if !ctx.cr[6].lt {
	pc = 0x82C5C170; continue 'dispatch;
	}
	// 82C5C164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5C168: 907E000C  stw r3, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82C5C16C: 48000094  b 0x82c5c200
	pc = 0x82C5C200; continue 'dispatch;
            }
            0x82C5C170 => {
    //   block [0x82C5C170..0x82C5C200)
	// 82C5C170: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5C174: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5C178: 419A0088  beq cr6, 0x82c5c200
	if ctx.cr[6].eq {
	pc = 0x82C5C200; continue 'dispatch;
	}
	// 82C5C17C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5C180: D3C10158  stfs f30, 0x158(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 82C5C184: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5C188: D3E1015C  stfs f31, 0x15c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 82C5C18C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C5C190: 93E10154  stw r31, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[31].u32 ) };
	// 82C5C194: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C5C198: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82C5C19C: 3960D8F0  li r11, -0x2710
	ctx.r[11].s64 = -10000;
	// 82C5C1A0: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5C1A4: 38A10150  addi r5, r1, 0x150
	ctx.r[5].s64 = ctx.r[1].s64 + 336;
	// 82C5C1A8: C1890B80  lfs f12, 0xb80(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2944 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5C1AC: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82C5C1B0: C168B010  lfs f11, -0x4ff0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-20464 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5C1B4: C0070AA4  lfs f0, 0xaa4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5C1B8: 90A10130  stw r5, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[5].u32 ) };
	// 82C5C1BC: C146B00C  lfs f10, -0x4ff4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-20468 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5C1C0: 90810134  stw r4, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[4].u32 ) };
	// 82C5C1C4: D1A10160  stfs f13, 0x160(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82C5C1C8: 91610150  stw r11, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82C5C1CC: D1810168  stfs f12, 0x168(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82C5C1D0: 91610164  stw r11, 0x164(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 82C5C1D4: D1610170  stfs f11, 0x170(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 82C5C1D8: 9161016C  stw r11, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82C5C1DC: D0010174  stfs f0, 0x174(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82C5C1E0: 38E10130  addi r7, r1, 0x130
	ctx.r[7].s64 = ctx.r[1].s64 + 304;
	// 82C5C1E4: D0010178  stfs f0, 0x178(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 82C5C1E8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82C5C1EC: D141017C  stfs f10, 0x17c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 82C5C1F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C5C1F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5C1F8: 4807D121  bl 0x82cd9318
	ctx.lr = 0x82C5C1FC;
	sub_82CD9318(ctx, base);
	// 82C5C1FC: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82C5C200; continue 'dispatch;
            }
            0x82C5C200 => {
    //   block [0x82C5C200..0x82C5C2B8)
	// 82C5C200: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5C204: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82C5C208: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82C5C20C: 90610148  stw r3, 0x148(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[3].u32 ) };
	// 82C5C210: 39010100  addi r8, r1, 0x100
	ctx.r[8].s64 = ctx.r[1].s64 + 256;
	// 82C5C214: D3C10094  stfs f30, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82C5C218: 38E10140  addi r7, r1, 0x140
	ctx.r[7].s64 = ctx.r[1].s64 + 320;
	// 82C5C21C: D3C1009C  stfs f30, 0x9c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82C5C220: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82C5C224: D3C100A4  stfs f30, 0xa4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82C5C228: 38A10118  addi r5, r1, 0x118
	ctx.r[5].s64 = ctx.r[1].s64 + 280;
	// 82C5C22C: D3C100AC  stfs f30, 0xac(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82C5C230: D3C100B4  stfs f30, 0xb4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82C5C234: 9BE10090  stb r31, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u8 ) };
	// 82C5C238: 9BE10091  stb r31, 0x91(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(145 as u32), ctx.r[31].u8 ) };
	// 82C5C23C: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 82C5C240: 9BA10098  stb r29, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u8 ) };
	// 82C5C244: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82C5C248: 9BE10099  stb r31, 0x99(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(153 as u32), ctx.r[31].u8 ) };
	// 82C5C24C: 9B4100A0  stb r26, 0xa0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[26].u8 ) };
	// 82C5C250: 9BE100A1  stb r31, 0xa1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(161 as u32), ctx.r[31].u8 ) };
	// 82C5C254: 9B2100A8  stb r25, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[25].u8 ) };
	// 82C5C258: 9BE100A9  stb r31, 0xa9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(169 as u32), ctx.r[31].u8 ) };
	// 82C5C25C: 9B8100B0  stb r28, 0xb0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u8 ) };
	// 82C5C260: 9BE100B1  stb r31, 0xb1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(177 as u32), ctx.r[31].u8 ) };
	// 82C5C264: 9B810100  stb r28, 0x100(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[28].u8 ) };
	// 82C5C268: 91210104  stw r9, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[9].u32 ) };
	// 82C5C26C: 91610140  stw r11, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82C5C270: 93E10144  stw r31, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[31].u32 ) };
	// 82C5C274: 9101014C  stw r8, 0x14c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[8].u32 ) };
	// 82C5C278: 9B410118  stb r26, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[26].u8 ) };
	// 82C5C27C: 90E1011C  stw r7, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[7].u32 ) };
	// 82C5C280: 9BE100E0  stb r31, 0xe0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[31].u8 ) };
	// 82C5C284: 936100E4  stw r27, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[27].u32 ) };
	// 82C5C288: 994100E1  stb r10, 0xe1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(225 as u32), ctx.r[10].u8 ) };
	// 82C5C28C: 9B4100E8  stb r26, 0xe8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[26].u8 ) };
	// 82C5C290: 994100E9  stb r10, 0xe9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(233 as u32), ctx.r[10].u8 ) };
	// 82C5C294: 98C100EA  stb r6, 0xea(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(234 as u32), ctx.r[6].u8 ) };
	// 82C5C298: 93E100EC  stw r31, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[31].u32 ) };
	// 82C5C29C: 90A100F0  stw r5, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[5].u32 ) };
	// 82C5C2A0: 93E100F4  stw r31, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[31].u32 ) };
	// 82C5C2A4: 93E100F8  stw r31, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[31].u32 ) };
	// 82C5C2A8: 4807D8B9  bl 0x82cd9b60
	ctx.lr = 0x82C5C2AC;
	sub_82CD9B60(ctx, base);
	// 82C5C2AC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5C2B0: 40980008  bge cr6, 0x82c5c2b8
	if !ctx.cr[6].lt {
	pc = 0x82C5C2B8; continue 'dispatch;
	}
	// 82C5C2B4: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82C5C2B8; continue 'dispatch;
            }
            0x82C5C2B8 => {
    //   block [0x82C5C2B8..0x82C5C2C8)
	// 82C5C2B8: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82C5C2BC: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82C5C2C0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C5C2C4: 4804D188  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5C2C8 size=488
    let mut pc: u32 = 0x82C5C2C8;
    'dispatch: loop {
        match pc {
            0x82C5C2C8 => {
    //   block [0x82C5C2C8..0x82C5C2E8)
	// 82C5C2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C2CC: 4804D135  bl 0x82ca9400
	ctx.lr = 0x82C5C2D0;
	sub_82CA93D0(ctx, base);
	// 82C5C2D0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C2D4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 82C5C2D8: 39610094  addi r11, r1, 0x94
	ctx.r[11].s64 = ctx.r[1].s64 + 148;
	// 82C5C2DC: 392A627C  addi r9, r10, 0x627c
	ctx.r[9].s64 = ctx.r[10].s64 + 25212;
	// 82C5C2E0: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82C5C2E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C5C2E8; continue 'dispatch;
            }
            0x82C5C2E8 => {
    //   block [0x82C5C2E8..0x82C5C380)
	// 82C5C2E8: 89090000  lbz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5C2EC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C5C2F0: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C5C2F4: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82C5C2F8: 990BFFFC  stb r8, -4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[8].u8 ) };
	// 82C5C2FC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82C5C300: 4082FFE8  bne 0x82c5c2e8
	if !ctx.cr[0].eq {
	pc = 0x82C5C2E8; continue 'dispatch;
	}
	// 82C5C304: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82C5C308: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 82C5C30C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82C5C310: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82C5C314: 617BBB80  ori r27, r11, 0xbb80
	ctx.r[27].u64 = ctx.r[11].u64 | 48000;
	// 82C5C318: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82C5C31C: 3B800006  li r28, 6
	ctx.r[28].s64 = 6;
	// 82C5C320: 9BA10058  stb r29, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82C5C324: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82C5C328: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 82C5C32C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82C5C330: 9B810071  stb r28, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[28].u8 ) };
	// 82C5C334: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82C5C338: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82C5C33C: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 82C5C340: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82C5C344: 9BA10078  stb r29, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u8 ) };
	// 82C5C348: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5C34C: 9B810079  stb r28, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[28].u8 ) };
	// 82C5C350: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C5C354: 98E1007A  stb r7, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[7].u8 ) };
	// 82C5C358: 3BCB5168  addi r30, r11, 0x5168
	ctx.r[30].s64 = ctx.r[11].s64 + 20840;
	// 82C5C35C: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82C5C360: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82C5C364: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C5C368: 4807D7F9  bl 0x82cd9b60
	ctx.lr = 0x82C5C36C;
	sub_82CD9B60(ctx, base);
	// 82C5C36C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5C370: 40980010  bge cr6, 0x82c5c380
	if !ctx.cr[6].lt {
	pc = 0x82C5C380; continue 'dispatch;
	}
	// 82C5C374: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C5C378: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5C37C: 48000008  b 0x82c5c384
	pc = 0x82C5C384; continue 'dispatch;
            }
            0x82C5C380 => {
    //   block [0x82C5C380..0x82C5C384)
	// 82C5C380: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C5C384; continue 'dispatch;
            }
            0x82C5C384 => {
    //   block [0x82C5C384..0x82C5C3FC)
	// 82C5C384: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C5C388: 39610098  addi r11, r1, 0x98
	ctx.r[11].s64 = ctx.r[1].s64 + 152;
	// 82C5C38C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C5C390: 9BA10060  stb r29, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 82C5C394: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82C5C398: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C5C39C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82C5C3A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C5C3A4: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82C5C3A8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82C5C3AC: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	// 82C5C3B0: 9BA10068  stb r29, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u8 ) };
	// 82C5C3B4: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82C5C3B8: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82C5C3BC: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 82C5C3C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C5C3C4: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 82C5C3C8: 9B810071  stb r28, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[28].u8 ) };
	// 82C5C3CC: 9BA10078  stb r29, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u8 ) };
	// 82C5C3D0: 9B810079  stb r28, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[28].u8 ) };
	// 82C5C3D4: 9B41007A  stb r26, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[26].u8 ) };
	// 82C5C3D8: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82C5C3DC: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 82C5C3E0: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82C5C3E4: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82C5C3E8: 4807D779  bl 0x82cd9b60
	ctx.lr = 0x82C5C3EC;
	sub_82CD9B60(ctx, base);
	// 82C5C3EC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5C3F0: 4098000C  bge cr6, 0x82c5c3fc
	if !ctx.cr[6].lt {
	pc = 0x82C5C3FC; continue 'dispatch;
	}
	// 82C5C3F4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C5C3F8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C5C3FC; continue 'dispatch;
            }
            0x82C5C3FC => {
    //   block [0x82C5C3FC..0x82C5C484)
	// 82C5C3FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82C5C400: 4BFFFC61  bl 0x82c5c060
	ctx.lr = 0x82C5C404;
	sub_82C5C060(ctx, base);
	// 82C5C404: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C5C408: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5C40C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82C5C410: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82C5C414: 9BA10068  stb r29, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u8 ) };
	// 82C5C418: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82C5C41C: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82C5C420: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C5C424: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C5C428: 38A100A8  addi r5, r1, 0xa8
	ctx.r[5].s64 = ctx.r[1].s64 + 168;
	// 82C5C42C: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C5C430: 9BA10060  stb r29, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 82C5C434: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82C5C438: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82C5C43C: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 82C5C440: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C5C444: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 82C5C448: 9B810071  stb r28, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[28].u8 ) };
	// 82C5C44C: 9BA10078  stb r29, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u8 ) };
	// 82C5C450: 9B810079  stb r28, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[28].u8 ) };
	// 82C5C454: 9B41007A  stb r26, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[26].u8 ) };
	// 82C5C458: 90E1007C  stw r7, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 82C5C45C: 90C10080  stw r6, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 82C5C460: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82C5C464: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82C5C468: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 82C5C46C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C5C470: 4807D6F1  bl 0x82cd9b60
	ctx.lr = 0x82C5C474;
	sub_82CD9B60(ctx, base);
	// 82C5C474: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5C478: 4098000C  bge cr6, 0x82c5c484
	if !ctx.cr[6].lt {
	pc = 0x82C5C484; continue 'dispatch;
	}
	// 82C5C47C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C5C480: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82C5C484; continue 'dispatch;
            }
            0x82C5C484 => {
    //   block [0x82C5C484..0x82C5C4A8)
	// 82C5C484: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 82C5C488: 389E0014  addi r4, r30, 0x14
	ctx.r[4].s64 = ctx.r[30].s64 + 20;
	// 82C5C48C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C5C490: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C5C494: 4807D6CD  bl 0x82cd9b60
	ctx.lr = 0x82C5C498;
	sub_82CD9B60(ctx, base);
	// 82C5C498: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5C49C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5C4A0: 40980008  bge cr6, 0x82c5c4a8
	if !ctx.cr[6].lt {
	pc = 0x82C5C4A8; continue 'dispatch;
	}
	// 82C5C4A4: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	pc = 0x82C5C4A8; continue 'dispatch;
            }
            0x82C5C4A8 => {
    //   block [0x82C5C4A8..0x82C5C4B0)
	// 82C5C4A8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C5C4AC: 4804CFA4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5C4B0 size=160
    let mut pc: u32 = 0x82C5C4B0;
    'dispatch: loop {
        match pc {
            0x82C5C4B0 => {
    //   block [0x82C5C4B0..0x82C5C4D0)
	// 82C5C4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5C4B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5C4BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C4C0: 3FE08333  lis r31, -0x7ccd
	ctx.r[31].s64 = -2093809664;
	// 82C5C4C4: 897F5180  lbz r11, 0x5180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20864 as u32) ) } as u64;
	// 82C5C4C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5C4CC: 419A001C  beq cr6, 0x82c5c4e8
	if ctx.cr[6].eq {
	pc = 0x82C5C4E8; continue 'dispatch;
	}
	pc = 0x82C5C4D0; continue 'dispatch;
            }
            0x82C5C4D0 => {
    //   block [0x82C5C4D0..0x82C5C4E8)
	// 82C5C4D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5C4D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5C4D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C4DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C4E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5C4E4: 4E800020  blr
	return;
            }
            0x82C5C4E8 => {
    //   block [0x82C5C4E8..0x82C5C550)
	// 82C5C4E8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82C5C4EC: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82C5C4F0: 392B627C  addi r9, r11, 0x627c
	ctx.r[9].s64 = ctx.r[11].s64 + 25212;
	// 82C5C4F4: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82C5C4F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C5C4FC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82C5C500: 4807D4F9  bl 0x82cd99f8
	ctx.lr = 0x82C5C504;
	sub_82CD99F8(ctx, base);
	// 82C5C504: 7C680034  cntlzw r8, r3
	ctx.r[8].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C5C508: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 82C5C50C: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 82C5C510: 68C50001  xori r5, r6, 1
	ctx.r[5].u64 = ctx.r[6].u64 ^ 1;
	// 82C5C514: 54A4063E  clrlwi r4, r5, 0x18
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82C5C518: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C5C51C: 419AFFB4  beq cr6, 0x82c5c4d0
	if ctx.cr[6].eq {
	pc = 0x82C5C4D0; continue 'dispatch;
	}
	// 82C5C520: 4BFFFDA9  bl 0x82c5c2c8
	ctx.lr = 0x82C5C524;
	sub_82C5C2C8(ctx, base);
	// 82C5C524: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C5C528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5C52C: 419AFFA4  beq cr6, 0x82c5c4d0
	if ctx.cr[6].eq {
	pc = 0x82C5C4D0; continue 'dispatch;
	}
	// 82C5C530: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C5C534: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5C538: 997F5180  stb r11, 0x5180(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20864 as u32), ctx.r[11].u8 ) };
	// 82C5C53C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5C540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C548: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5C54C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5C550 size=268
    let mut pc: u32 = 0x82C5C550;
    'dispatch: loop {
        match pc {
            0x82C5C550 => {
    //   block [0x82C5C550..0x82C5C58C)
	// 82C5C550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C554: 4804CEB1  bl 0x82ca9404
	ctx.lr = 0x82C5C558;
	sub_82CA93D0(ctx, base);
	// 82C5C558: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C55C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5C560: 806B5170  lwz r3, 0x5170(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20848 as u32) ) } as u64;
	// 82C5C564: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5C568: 419A00EC  beq cr6, 0x82c5c654
	if ctx.cr[6].eq {
	pc = 0x82C5C654; continue 'dispatch;
	}
	// 82C5C56C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5C570: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5C574: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5C578: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5C57C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5C580: 4098000C  bge cr6, 0x82c5c58c
	if !ctx.cr[6].lt {
	pc = 0x82C5C58C; continue 'dispatch;
	}
	// 82C5C584: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82C5C588: 48000010  b 0x82c5c598
	pc = 0x82C5C598; continue 'dispatch;
            }
            0x82C5C58C => {
    //   block [0x82C5C58C..0x82C5C598)
	// 82C5C58C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82C5C590: 40990008  ble cr6, 0x82c5c598
	if !ctx.cr[6].gt {
	pc = 0x82C5C598; continue 'dispatch;
	}
	// 82C5C594: FC206890  fmr f1, f13
	ctx.f[1].f64 = ctx.f[13].f64;
	pc = 0x82C5C598; continue 'dispatch;
            }
            0x82C5C598 => {
    //   block [0x82C5C598..0x82C5C654)
	// 82C5C598: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C5C59C: EC0D0828  fsubs f0, f13, f1
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82C5C5A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C5C5A4: D0210084  stfs f1, 0x84(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82C5C5A8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82C5C5AC: D021008C  stfs f1, 0x8c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82C5C5B0: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82C5C5B4: D0210094  stfs f1, 0x94(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82C5C5B8: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82C5C5BC: D021009C  stfs f1, 0x9c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82C5C5C0: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82C5C5C4: D02100A4  stfs f1, 0xa4(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82C5C5C8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 82C5C5CC: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82C5C5D0: 3BE100B0  addi r31, r1, 0xb0
	ctx.r[31].s64 = ctx.r[1].s64 + 176;
	// 82C5C5D4: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82C5C5D8: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 82C5C5DC: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82C5C5E0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82C5C5E4: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82C5C5E8: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82C5C5EC: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82C5C5F0: 3B610070  addi r27, r1, 0x70
	ctx.r[27].s64 = ctx.r[1].s64 + 112;
	// 82C5C5F4: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82C5C5F8: 992100B0  stb r9, 0xb0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[9].u8 ) };
	// 82C5C5FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C5C600: 994100B8  stb r10, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u8 ) };
	// 82C5C604: 996100C0  stb r11, 0xc0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
	// 82C5C608: 98C100C8  stb r6, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[6].u8 ) };
	// 82C5C60C: 98E100D0  stb r7, 0xd0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[7].u8 ) };
	// 82C5C610: 990100D8  stb r8, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[8].u8 ) };
	// 82C5C614: 99210080  stb r9, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u8 ) };
	// 82C5C618: 99410088  stb r10, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u8 ) };
	// 82C5C61C: 99610090  stb r11, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 82C5C620: 98C10098  stb r6, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[6].u8 ) };
	// 82C5C624: 98E100A0  stb r7, 0xa0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u8 ) };
	// 82C5C628: 98A10050  stb r5, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u8 ) };
	// 82C5C62C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C5C630: 99010058  stb r8, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u8 ) };
	// 82C5C634: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82C5C638: 99210070  stb r9, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u8 ) };
	// 82C5C63C: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82C5C640: 99410078  stb r10, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u8 ) };
	// 82C5C644: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 82C5C648: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82C5C64C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82C5C650: 4807CD91  bl 0x82cd93e0
	ctx.lr = 0x82C5C654;
	sub_82CD93E0(ctx, base);
	pc = 0x82C5C654; continue 'dispatch;
            }
            0x82C5C654 => {
    //   block [0x82C5C654..0x82C5C65C)
	// 82C5C654: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82C5C658: 4804CDFC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5C660 size=388
    let mut pc: u32 = 0x82C5C660;
    'dispatch: loop {
        match pc {
            0x82C5C660 => {
    //   block [0x82C5C660..0x82C5C6BC)
	// 82C5C660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5C668: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C66C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5C670: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82C5C674: 396B5168  addi r11, r11, 0x5168
	ctx.r[11].s64 = ctx.r[11].s64 + 20840;
	// 82C5C678: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5C67C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5C680: 419A0150  beq cr6, 0x82c5c7d0
	if ctx.cr[6].eq {
	pc = 0x82C5C7D0; continue 'dispatch;
	}
	// 82C5C684: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C5C688: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82C5C68C: 41990144  bgt cr6, 0x82c5c7d0
	if ctx.cr[6].gt {
	pc = 0x82C5C7D0; continue 'dispatch;
	}
	// 82C5C690: 3D8082C6  lis r12, -0x7d3a
	ctx.r[12].s64 = -2100953088;
	// 82C5C694: 398CC6A8  addi r12, r12, -0x3958
	ctx.r[12].s64 = ctx.r[12].s64 + -14680;
	// 82C5C698: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82C5C69C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82C5C6A0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82C5C6A4: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
	pc = 0x82C5C6BC; continue 'dispatch;
		},
		1 => {
	pc = 0x82C5C6F8; continue 'dispatch;
		},
		2 => {
	pc = 0x82C5C7AC; continue 'dispatch;
		},
		3 => {
	pc = 0x82C5C734; continue 'dispatch;
		},
		4 => {
	pc = 0x82C5C770; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82C5C6A8: 82C5C6BC  lwz r22, -0x3944(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14660 as u32) ) } as u64;
	// 82C5C6AC: 82C5C6F8  lwz r22, -0x3908(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14600 as u32) ) } as u64;
	// 82C5C6B0: 82C5C7AC  lwz r22, -0x3854(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14420 as u32) ) } as u64;
	// 82C5C6B4: 82C5C734  lwz r22, -0x38cc(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14540 as u32) ) } as u64;
	// 82C5C6B8: 82C5C770  lwz r22, -0x3890(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14480 as u32) ) } as u64;
            }
            0x82C5C6BC => {
    //   block [0x82C5C6BC..0x82C5C6F8)
	// 82C5C6BC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5C6C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5C6C4: 419A010C  beq cr6, 0x82c5c7d0
	if ctx.cr[6].eq {
	pc = 0x82C5C7D0; continue 'dispatch;
	}
	// 82C5C6C8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C5C6CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C5C6D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5C6D4: 4807CC45  bl 0x82cd9318
	ctx.lr = 0x82C5C6D8;
	sub_82CD9318(ctx, base);
	// 82C5C6D8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C5C6DC: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C5C6E0: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C5C6E4: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82C5C6E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5C6EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C6F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C6F4: 4E800020  blr
	return;
            }
            0x82C5C6F8 => {
    //   block [0x82C5C6F8..0x82C5C734)
	// 82C5C6F8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5C6FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5C700: 419A00D0  beq cr6, 0x82c5c7d0
	if ctx.cr[6].eq {
	pc = 0x82C5C7D0; continue 'dispatch;
	}
	// 82C5C704: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C5C708: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C5C70C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5C710: 4807CC09  bl 0x82cd9318
	ctx.lr = 0x82C5C714;
	sub_82CD9318(ctx, base);
	// 82C5C714: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C5C718: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C5C71C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C5C720: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82C5C724: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5C728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C72C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C730: 4E800020  blr
	return;
            }
            0x82C5C734 => {
    //   block [0x82C5C734..0x82C5C770)
	// 82C5C734: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5C738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5C73C: 419A0094  beq cr6, 0x82c5c7d0
	if ctx.cr[6].eq {
	pc = 0x82C5C7D0; continue 'dispatch;
	}
	// 82C5C740: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C5C744: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C5C748: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5C74C: 4807CBCD  bl 0x82cd9318
	ctx.lr = 0x82C5C750;
	sub_82CD9318(ctx, base);
	// 82C5C750: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C5C754: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C5C758: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C5C75C: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82C5C760: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5C764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C76C: 4E800020  blr
	return;
            }
            0x82C5C770 => {
    //   block [0x82C5C770..0x82C5C7AC)
	// 82C5C770: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5C774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5C778: 419A0058  beq cr6, 0x82c5c7d0
	if ctx.cr[6].eq {
	pc = 0x82C5C7D0; continue 'dispatch;
	}
	// 82C5C77C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C5C780: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C5C784: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5C788: 4807CB91  bl 0x82cd9318
	ctx.lr = 0x82C5C78C;
	sub_82CD9318(ctx, base);
	// 82C5C78C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C5C790: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C5C794: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C5C798: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82C5C79C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5C7A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C7A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C7A8: 4E800020  blr
	return;
            }
            0x82C5C7AC => {
    //   block [0x82C5C7AC..0x82C5C7D0)
	// 82C5C7AC: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82C5C7B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5C7B4: 409A001C  bne cr6, 0x82c5c7d0
	if !ctx.cr[6].eq {
	pc = 0x82C5C7D0; continue 'dispatch;
	}
	// 82C5C7B8: 4BFFFD99  bl 0x82c5c550
	ctx.lr = 0x82C5C7BC;
	sub_82C5C550(ctx, base);
	// 82C5C7BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5C7C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5C7C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C7C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C7CC: 4E800020  blr
	return;
            }
            0x82C5C7D0 => {
    //   block [0x82C5C7D0..0x82C5C7E4)
	// 82C5C7D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5C7D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5C7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C7E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5C7E8 size=112
    let mut pc: u32 = 0x82C5C7E8;
    'dispatch: loop {
        match pc {
            0x82C5C7E8 => {
    //   block [0x82C5C7E8..0x82C5C830)
	// 82C5C7E8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5C7EC: 396B5168  addi r11, r11, 0x5168
	ctx.r[11].s64 = ctx.r[11].s64 + 20840;
	// 82C5C7F0: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5C7F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5C7F8: 419A0060  beq cr6, 0x82c5c858
	if ctx.cr[6].eq {
		sub_82C5C858(ctx, base);
		return;
	}
	// 82C5C7FC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82C5C800: 41990058  bgt cr6, 0x82c5c858
	if ctx.cr[6].gt {
		sub_82C5C858(ctx, base);
		return;
	}
	// 82C5C804: 3D8082C6  lis r12, -0x7d3a
	ctx.r[12].s64 = -2100953088;
	// 82C5C808: 398CC81C  addi r12, r12, -0x37e4
	ctx.r[12].s64 = ctx.r[12].s64 + -14308;
	// 82C5C80C: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82C5C810: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82C5C814: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82C5C818: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
	pc = 0x82C5C830; continue 'dispatch;
		},
		1 => {
	pc = 0x82C5C838; continue 'dispatch;
		},
		2 => {
	pc = 0x82C5C840; continue 'dispatch;
		},
		3 => {
	pc = 0x82C5C848; continue 'dispatch;
		},
		4 => {
	pc = 0x82C5C850; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82C5C81C: 82C5C830  lwz r22, -0x37d0(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14288 as u32) ) } as u64;
	// 82C5C820: 82C5C838  lwz r22, -0x37c8(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14280 as u32) ) } as u64;
	// 82C5C824: 82C5C840  lwz r22, -0x37c0(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14272 as u32) ) } as u64;
	// 82C5C828: 82C5C848  lwz r22, -0x37b8(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14264 as u32) ) } as u64;
	// 82C5C82C: 82C5C850  lwz r22, -0x37b0(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14256 as u32) ) } as u64;
            }
            0x82C5C830 => {
    //   block [0x82C5C830..0x82C5C838)
	// 82C5C830: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5C834: 4E800020  blr
	return;
            }
            0x82C5C838 => {
    //   block [0x82C5C838..0x82C5C840)
	// 82C5C838: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5C83C: 4E800020  blr
	return;
            }
            0x82C5C840 => {
    //   block [0x82C5C840..0x82C5C848)
	// 82C5C840: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5C844: 4E800020  blr
	return;
            }
            0x82C5C848 => {
    //   block [0x82C5C848..0x82C5C850)
	// 82C5C848: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5C84C: 4E800020  blr
	return;
            }
            0x82C5C850 => {
    //   block [0x82C5C850..0x82C5C858)
	// 82C5C850: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5C854: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5C858 size=8
    let mut pc: u32 = 0x82C5C858;
    'dispatch: loop {
        match pc {
            0x82C5C858 => {
    //   block [0x82C5C858..0x82C5C860)
	// 82C5C858: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5C85C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5C860 size=100
    let mut pc: u32 = 0x82C5C860;
    'dispatch: loop {
        match pc {
            0x82C5C860 => {
    //   block [0x82C5C860..0x82C5C888)
	// 82C5C860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5C868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5C86C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5C870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C874: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C5C878: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5C87C: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82C5C880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5C884: 409A0028  bne cr6, 0x82c5c8ac
	if !ctx.cr[6].eq {
	pc = 0x82C5C8AC; continue 'dispatch;
	}
	pc = 0x82C5C888; continue 'dispatch;
            }
            0x82C5C888 => {
    //   block [0x82C5C888..0x82C5C8AC)
	// 82C5C888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5C88C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5C890: 4BFFFFD1  bl 0x82c5c860
	ctx.lr = 0x82C5C894;
	sub_82C5C860(ctx, base);
	// 82C5C894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5C898: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5C89C: 4BBE8F15  bl 0x828457b0
	ctx.lr = 0x82C5C8A0;
	sub_828457B0(ctx, base);
	// 82C5C8A0: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82C5C8A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5C8A8: 419AFFE0  beq cr6, 0x82c5c888
	if ctx.cr[6].eq {
	pc = 0x82C5C888; continue 'dispatch;
	}
	pc = 0x82C5C8AC; continue 'dispatch;
            }
            0x82C5C8AC => {
    //   block [0x82C5C8AC..0x82C5C8C4)
	// 82C5C8AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5C8B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C8B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C8B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5C8BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5C8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5C8C8 size=84
    let mut pc: u32 = 0x82C5C8C8;
    'dispatch: loop {
        match pc {
            0x82C5C8C8 => {
    //   block [0x82C5C8C8..0x82C5C91C)
	// 82C5C8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5C8D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5C8D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C8D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5C8DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5C8E0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5C8E4: 4BFFFF7D  bl 0x82c5c860
	ctx.lr = 0x82C5C8E8;
	sub_82C5C860(ctx, base);
	// 82C5C8E8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5C8EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C5C8F0: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C5C8F4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5C8F8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C5C8FC: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C5C900: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5C904: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C5C908: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5C90C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5C910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5C914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5C918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5C920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5C920 size=368
    let mut pc: u32 = 0x82C5C920;
    'dispatch: loop {
        match pc {
            0x82C5C920 => {
    //   block [0x82C5C920..0x82C5C9E0)
	// 82C5C920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5C924: 4804CAE9  bl 0x82ca940c
	ctx.lr = 0x82C5C928;
	sub_82CA93D0(ctx, base);
	// 82C5C928: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C5C92C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5C930: 906100E4  stw r3, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[3].u32 ) };
	// 82C5C934: 3FC08333  lis r30, -0x7ccd
	ctx.r[30].s64 = -2093809664;
	// 82C5C938: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 82C5C93C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82C5C940: 409A00A8  bne cr6, 0x82c5c9e8
	if !ctx.cr[6].eq {
	pc = 0x82C5C9E8; continue 'dispatch;
	}
	// 82C5C944: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5C948: 807E5174  lwz r3, 0x5174(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20852 as u32) ) } as u64;
	// 82C5C94C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5C950: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C5C954: 419A008C  beq cr6, 0x82c5c9e0
	if ctx.cr[6].eq {
	pc = 0x82C5C9E0; continue 'dispatch;
	}
	// 82C5C958: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5C95C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82C5C960: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5C964: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C5C968: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5C96C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C5C970: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C5C974: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82C5C978: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5C97C: 3960D8F0  li r11, -0x2710
	ctx.r[11].s64 = -10000;
	// 82C5C980: C18A0BFC  lfs f12, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5C984: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C5C988: C1690B80  lfs f11, 0xb80(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2944 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5C98C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C5C990: C148B010  lfs f10, -0x4ff0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-20464 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5C994: C0070AA4  lfs f0, 0xaa4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5C998: 90A10074  stw r5, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[5].u32 ) };
	// 82C5C99C: C126B00C  lfs f9, -0x4ff4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-20468 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C5C9A0: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C5C9A4: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82C5C9A8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82C5C9AC: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82C5C9B0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82C5C9B4: D1610088  stfs f11, 0x88(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82C5C9B8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82C5C9BC: D1410090  stfs f10, 0x90(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82C5C9C0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C5C9C4: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82C5C9C8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82C5C9CC: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82C5C9D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C5C9D4: D121009C  stfs f9, 0x9c(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82C5C9D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5C9DC: 4807C93D  bl 0x82cd9318
	ctx.lr = 0x82C5C9E0;
	sub_82CD9318(ctx, base);
	pc = 0x82C5C9E0; continue 'dispatch;
            }
            0x82C5C9E0 => {
    //   block [0x82C5C9E0..0x82C5C9E8)
	// 82C5C9E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C5C9E4: 4BFFFB6D  bl 0x82c5c550
	ctx.lr = 0x82C5C9E8;
	sub_82C5C550(ctx, base);
	pc = 0x82C5C9E8; continue 'dispatch;
            }
            0x82C5C9E8 => {
    //   block [0x82C5C9E8..0x82C5CA14)
	// 82C5C9E8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5C9EC: 38A100E4  addi r5, r1, 0xe4
	ctx.r[5].s64 = ctx.r[1].s64 + 228;
	// 82C5C9F0: 3BEB5184  addi r31, r11, 0x5184
	ctx.r[31].s64 = ctx.r[11].s64 + 20868;
	// 82C5C9F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C5C9F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5C9FC: 4B718A85  bl 0x82375480
	ctx.lr = 0x82C5CA00;
	sub_82375480(ctx, base);
	// 82C5CA00: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5CA04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C5CA08: 419A000C  beq cr6, 0x82c5ca14
	if ctx.cr[6].eq {
	pc = 0x82C5CA14; continue 'dispatch;
	}
	// 82C5CA0C: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C5CA10: 419A0008  beq cr6, 0x82c5ca18
	if ctx.cr[6].eq {
	pc = 0x82C5CA18; continue 'dispatch;
	}
	pc = 0x82C5CA14; continue 'dispatch;
            }
            0x82C5CA14 => {
    //   block [0x82C5CA14..0x82C5CA18)
	// 82C5CA14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CA18; continue 'dispatch;
            }
            0x82C5CA18 => {
    //   block [0x82C5CA18..0x82C5CA34)
	// 82C5CA18: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CA1C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C5CA20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5CA24: 419A0060  beq cr6, 0x82c5ca84
	if ctx.cr[6].eq {
	pc = 0x82C5CA84; continue 'dispatch;
	}
	// 82C5CA28: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C5CA2C: 409A0008  bne cr6, 0x82c5ca34
	if !ctx.cr[6].eq {
	pc = 0x82C5CA34; continue 'dispatch;
	}
	// 82C5CA30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CA34; continue 'dispatch;
            }
            0x82C5CA34 => {
    //   block [0x82C5CA34..0x82C5CA44)
	// 82C5CA34: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CA38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5CA3C: 409A0008  bne cr6, 0x82c5ca44
	if !ctx.cr[6].eq {
	pc = 0x82C5CA44; continue 'dispatch;
	}
	// 82C5CA40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CA44; continue 'dispatch;
            }
            0x82C5CA44 => {
    //   block [0x82C5CA44..0x82C5CA78)
	// 82C5CA44: 807E5174  lwz r3, 0x5174(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20852 as u32) ) } as u64;
	// 82C5CA48: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5CA4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5CA50: 419A0028  beq cr6, 0x82c5ca78
	if ctx.cr[6].eq {
	pc = 0x82C5CA78; continue 'dispatch;
	}
	// 82C5CA54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CA58: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82C5CA5C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82C5CA60: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82C5CA64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C5CA68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C5CA6C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82C5CA70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5CA74: 4807C8A5  bl 0x82cd9318
	ctx.lr = 0x82C5CA78;
	sub_82CD9318(ctx, base);
	pc = 0x82C5CA78; continue 'dispatch;
            }
            0x82C5CA78 => {
    //   block [0x82C5CA78..0x82C5CA84)
	// 82C5CA78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CA7C: C02B0034  lfs f1, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5CA80: 4BFFFAD1  bl 0x82c5c550
	ctx.lr = 0x82C5CA84;
	sub_82C5C550(ctx, base);
	pc = 0x82C5CA84; continue 'dispatch;
            }
            0x82C5CA84 => {
    //   block [0x82C5CA84..0x82C5CA90)
	// 82C5CA84: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82C5CA88: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C5CA8C: 4804C9D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5CA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5CA90 size=236
    let mut pc: u32 = 0x82C5CA90;
    'dispatch: loop {
        match pc {
            0x82C5CA90 => {
    //   block [0x82C5CA90..0x82C5CAC4)
	// 82C5CA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5CA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5CA98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5CA9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5CAA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5CAA4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5CAA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5CAAC: 3BEB5184  addi r31, r11, 0x5184
	ctx.r[31].s64 = ctx.r[11].s64 + 20868;
	// 82C5CAB0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82C5CAB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82C5CAB8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CABC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CAC0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x82C5CAC4; continue 'dispatch;
            }
            0x82C5CAC4 => {
    //   block [0x82C5CAC4..0x82C5CAD4)
	// 82C5CAC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5CAC8: 419A000C  beq cr6, 0x82c5cad4
	if ctx.cr[6].eq {
	pc = 0x82C5CAD4; continue 'dispatch;
	}
	// 82C5CACC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C5CAD0: 419A0008  beq cr6, 0x82c5cad8
	if ctx.cr[6].eq {
	pc = 0x82C5CAD8; continue 'dispatch;
	}
	pc = 0x82C5CAD4; continue 'dispatch;
            }
            0x82C5CAD4 => {
    //   block [0x82C5CAD4..0x82C5CAD8)
	// 82C5CAD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CAD8; continue 'dispatch;
            }
            0x82C5CAD8 => {
    //   block [0x82C5CAD8..0x82C5CAEC)
	// 82C5CAD8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5CADC: 419A0054  beq cr6, 0x82c5cb30
	if ctx.cr[6].eq {
	pc = 0x82C5CB30; continue 'dispatch;
	}
	// 82C5CAE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5CAE4: 409A0008  bne cr6, 0x82c5caec
	if !ctx.cr[6].eq {
	pc = 0x82C5CAEC; continue 'dispatch;
	}
	// 82C5CAE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CAEC; continue 'dispatch;
            }
            0x82C5CAEC => {
    //   block [0x82C5CAEC..0x82C5CAFC)
	// 82C5CAEC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CAF0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5CAF4: 409A0008  bne cr6, 0x82c5cafc
	if !ctx.cr[6].eq {
	pc = 0x82C5CAFC; continue 'dispatch;
	}
	// 82C5CAF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CAFC; continue 'dispatch;
            }
            0x82C5CAFC => {
    //   block [0x82C5CAFC..0x82C5CB24)
	// 82C5CAFC: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5CB00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C5CB04: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CB08: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C5CB0C: 419A0018  beq cr6, 0x82c5cb24
	if ctx.cr[6].eq {
	pc = 0x82C5CB24; continue 'dispatch;
	}
	// 82C5CB10: 4B8F9D49  bl 0x82556858
	ctx.lr = 0x82C5CB14;
	sub_82556858(ctx, base);
	// 82C5CB14: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5CB18: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5CB1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CB20: 4BFFFFA4  b 0x82c5cac4
	pc = 0x82C5CAC4; continue 'dispatch;
            }
            0x82C5CB24 => {
    //   block [0x82C5CB24..0x82C5CB30)
	// 82C5CB24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5CB28: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C5CB2C: 4BFBAC7D  bl 0x82c177a8
	ctx.lr = 0x82C5CB30;
	sub_82C177A8(ctx, base);
	pc = 0x82C5CB30; continue 'dispatch;
            }
            0x82C5CB30 => {
    //   block [0x82C5CB30..0x82C5CB5C)
	// 82C5CB30: 807E0038  lwz r3, 0x38(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C5CB34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5CB38: 419A0024  beq cr6, 0x82c5cb5c
	if ctx.cr[6].eq {
	pc = 0x82C5CB5C; continue 'dispatch;
	}
	// 82C5CB3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CB40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C5CB44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CB48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5CB4C: 4E800421  bctrl
	ctx.lr = 0x82C5CB50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5CB50: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C5CB54: 913E0038  stw r9, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82C5CB58: 4800000C  b 0x82c5cb64
	pc = 0x82C5CB64; continue 'dispatch;
            }
            0x82C5CB5C => {
    //   block [0x82C5CB5C..0x82C5CB64)
	// 82C5CB5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5CB60: 917E0038  stw r11, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	pc = 0x82C5CB64; continue 'dispatch;
            }
            0x82C5CB64 => {
    //   block [0x82C5CB64..0x82C5CB7C)
	// 82C5CB64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5CB68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5CB6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5CB70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5CB74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5CB78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5CB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5CB80 size=524
    let mut pc: u32 = 0x82C5CB80;
    'dispatch: loop {
        match pc {
            0x82C5CB80 => {
    //   block [0x82C5CB80..0x82C5CBC8)
	// 82C5CB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5CB84: 4804C881  bl 0x82ca9404
	ctx.lr = 0x82C5CB88;
	sub_82CA93D0(ctx, base);
	// 82C5CB88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5CB8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C5CB90: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C5CB94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5CB98: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82C5CB9C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C5CBA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5CBA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5CBA8: 409A0020  bne cr6, 0x82c5cbc8
	if !ctx.cr[6].eq {
	pc = 0x82C5CBC8; continue 'dispatch;
	}
	// 82C5CBAC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C5CBB0: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CBB4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C5CBB8: 4802C7B9  bl 0x82c89370
	ctx.lr = 0x82C5CBBC;
	sub_82C89370(ctx, base);
	// 82C5CBBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CBC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5CBC4: 4804C890  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5CBC8 => {
    //   block [0x82C5CBC8..0x82C5CBE4)
	// 82C5CBC8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CBCC: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C5CBD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5CBD4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CBD8: 419A000C  beq cr6, 0x82c5cbe4
	if ctx.cr[6].eq {
	pc = 0x82C5CBE4; continue 'dispatch;
	}
	// 82C5CBDC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C5CBE0: 419A0008  beq cr6, 0x82c5cbe8
	if ctx.cr[6].eq {
	pc = 0x82C5CBE8; continue 'dispatch;
	}
	pc = 0x82C5CBE4; continue 'dispatch;
            }
            0x82C5CBE4 => {
    //   block [0x82C5CBE4..0x82C5CBE8)
	// 82C5CBE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CBE8; continue 'dispatch;
            }
            0x82C5CBE8 => {
    //   block [0x82C5CBE8..0x82C5CC28)
	// 82C5CBE8: 838100B4  lwz r28, 0xb4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C5CBEC: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C5CBF0: 409A0038  bne cr6, 0x82c5cc28
	if !ctx.cr[6].eq {
	pc = 0x82C5CC28; continue 'dispatch;
	}
	// 82C5CBF4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CBF8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5CBFC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5CC00: 4098015C  bge cr6, 0x82c5cd5c
	if !ctx.cr[6].lt {
	pc = 0x82C5CD5C; continue 'dispatch;
	}
	// 82C5CC04: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C5CC08: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C5CC0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C5CC10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5CC14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CC18: 4802C759  bl 0x82c89370
	ctx.lr = 0x82C5CC1C;
	sub_82C89370(ctx, base);
	// 82C5CC1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CC20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5CC24: 4804C830  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5CC28 => {
    //   block [0x82C5CC28..0x82C5CC38)
	// 82C5CC28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5CC2C: 419A000C  beq cr6, 0x82c5cc38
	if ctx.cr[6].eq {
	pc = 0x82C5CC38; continue 'dispatch;
	}
	// 82C5CC30: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C5CC34: 419A0008  beq cr6, 0x82c5cc3c
	if ctx.cr[6].eq {
	pc = 0x82C5CC3C; continue 'dispatch;
	}
	pc = 0x82C5CC38; continue 'dispatch;
            }
            0x82C5CC38 => {
    //   block [0x82C5CC38..0x82C5CC3C)
	// 82C5CC38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CC3C; continue 'dispatch;
            }
            0x82C5CC3C => {
    //   block [0x82C5CC3C..0x82C5CC78)
	// 82C5CC3C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CC40: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5CC44: 409A0034  bne cr6, 0x82c5cc78
	if !ctx.cr[6].eq {
	pc = 0x82C5CC78; continue 'dispatch;
	}
	// 82C5CC48: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5CC4C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5CC50: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5CC54: 40980108  bge cr6, 0x82c5cd5c
	if !ctx.cr[6].lt {
	pc = 0x82C5CD5C; continue 'dispatch;
	}
	// 82C5CC58: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C5CC5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C5CC60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5CC64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CC68: 4802C709  bl 0x82c89370
	ctx.lr = 0x82C5CC6C;
	sub_82C89370(ctx, base);
	// 82C5CC6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CC70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5CC74: 4804C7E0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5CC78 => {
    //   block [0x82C5CC78..0x82C5CCC4)
	// 82C5CC78: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5CC7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5CC80: 40980058  bge cr6, 0x82c5ccd8
	if !ctx.cr[6].lt {
	pc = 0x82C5CCD8; continue 'dispatch;
	}
	// 82C5CC84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C5CC88: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82C5CC8C: 4BE5786D  bl 0x82ab44f8
	ctx.lr = 0x82C5CC90;
	sub_82AB44F8(ctx, base);
	// 82C5CC90: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5CC94: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CC98: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5CC9C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5CCA0: 40980038  bge cr6, 0x82c5ccd8
	if !ctx.cr[6].lt {
	pc = 0x82C5CCD8; continue 'dispatch;
	}
	// 82C5CCA4: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5CCA8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C5CCAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5CCB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CCB4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82C5CCB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5CCBC: 409A008C  bne cr6, 0x82c5cd48
	if !ctx.cr[6].eq {
	pc = 0x82C5CD48; continue 'dispatch;
	}
	// 82C5CCC0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x82C5CCC4; continue 'dispatch;
            }
            0x82C5CCC4 => {
    //   block [0x82C5CCC4..0x82C5CCD8)
	// 82C5CCC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C5CCC8: 4802C6A9  bl 0x82c89370
	ctx.lr = 0x82C5CCCC;
	sub_82C89370(ctx, base);
	// 82C5CCCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CCD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5CCD4: 4804C780  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5CCD8 => {
    //   block [0x82C5CCD8..0x82C5CD08)
	// 82C5CCD8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5CCDC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5CCE0: 4098007C  bge cr6, 0x82c5cd5c
	if !ctx.cr[6].lt {
	pc = 0x82C5CD5C; continue 'dispatch;
	}
	// 82C5CCE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C5CCE8: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82C5CCEC: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CCF0: 4B8F9B69  bl 0x82556858
	ctx.lr = 0x82C5CCF4;
	sub_82556858(ctx, base);
	// 82C5CCF4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5CCF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5CCFC: 419A000C  beq cr6, 0x82c5cd08
	if ctx.cr[6].eq {
	pc = 0x82C5CD08; continue 'dispatch;
	}
	// 82C5CD00: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C5CD04: 419A0008  beq cr6, 0x82c5cd0c
	if ctx.cr[6].eq {
	pc = 0x82C5CD0C; continue 'dispatch;
	}
	pc = 0x82C5CD08; continue 'dispatch;
            }
            0x82C5CD08 => {
    //   block [0x82C5CD08..0x82C5CD0C)
	// 82C5CD08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CD0C; continue 'dispatch;
            }
            0x82C5CD0C => {
    //   block [0x82C5CD0C..0x82C5CD28)
	// 82C5CD0C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5CD10: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C5CD14: 419A0014  beq cr6, 0x82c5cd28
	if ctx.cr[6].eq {
	pc = 0x82C5CD28; continue 'dispatch;
	}
	// 82C5CD18: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CD1C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5CD20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5CD24: 40980038  bge cr6, 0x82c5cd5c
	if !ctx.cr[6].lt {
	pc = 0x82C5CD5C; continue 'dispatch;
	}
	pc = 0x82C5CD28; continue 'dispatch;
            }
            0x82C5CD28 => {
    //   block [0x82C5CD28..0x82C5CD48)
	// 82C5CD28: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5CD2C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C5CD30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5CD34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CD38: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82C5CD3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5CD40: 419AFF84  beq cr6, 0x82c5ccc4
	if ctx.cr[6].eq {
	pc = 0x82C5CCC4; continue 'dispatch;
	}
	// 82C5CD44: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x82C5CD48; continue 'dispatch;
            }
            0x82C5CD48 => {
    //   block [0x82C5CD48..0x82C5CD5C)
	// 82C5CD48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C5CD4C: 4802C625  bl 0x82c89370
	ctx.lr = 0x82C5CD50;
	sub_82C89370(ctx, base);
	// 82C5CD50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CD54: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5CD58: 4804C6FC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5CD5C => {
    //   block [0x82C5CD5C..0x82C5CD8C)
	// 82C5CD5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C5CD60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5CD64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C5CD68: 4802C949  bl 0x82c896b0
	ctx.lr = 0x82C5CD6C;
	sub_82C896B0(ctx, base);
	// 82C5CD6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C5CD70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CD74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CD78: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5CD7C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CD80: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C5CD84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5CD88: 4804C6CC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5CD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5CD90 size=220
    let mut pc: u32 = 0x82C5CD90;
    'dispatch: loop {
        match pc {
            0x82C5CD90 => {
    //   block [0x82C5CD90..0x82C5CDB8)
	// 82C5CD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5CD94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5CD98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5CD9C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C5CDA0: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CDA4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CDA8: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82C5CDAC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C5CDB0: 409A0030  bne cr6, 0x82c5cde0
	if !ctx.cr[6].eq {
	pc = 0x82C5CDE0; continue 'dispatch;
	}
	// 82C5CDB4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C5CDB8; continue 'dispatch;
            }
            0x82C5CDB8 => {
    //   block [0x82C5CDB8..0x82C5CDCC)
	// 82C5CDB8: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5CDBC: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C5CDC0: 4098000C  bge cr6, 0x82c5cdcc
	if !ctx.cr[6].lt {
	pc = 0x82C5CDCC; continue 'dispatch;
	}
	// 82C5CDC4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5CDC8: 4800000C  b 0x82c5cdd4
	pc = 0x82C5CDD4; continue 'dispatch;
            }
            0x82C5CDCC => {
    //   block [0x82C5CDCC..0x82C5CDD4)
	// 82C5CDCC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C5CDD0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C5CDD4; continue 'dispatch;
            }
            0x82C5CDD4 => {
    //   block [0x82C5CDD4..0x82C5CDE0)
	// 82C5CDD4: 88EB0015  lbz r7, 0x15(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82C5CDD8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C5CDDC: 419AFFDC  beq cr6, 0x82c5cdb8
	if ctx.cr[6].eq {
	pc = 0x82C5CDB8; continue 'dispatch;
	}
	pc = 0x82C5CDE0; continue 'dispatch;
            }
            0x82C5CDE0 => {
    //   block [0x82C5CDE0..0x82C5CE08)
	// 82C5CDE0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CDE4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C5CDE8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C5CDEC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C5CDF0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C5CDF4: 419A0014  beq cr6, 0x82c5ce08
	if ctx.cr[6].eq {
	pc = 0x82C5CE08; continue 'dispatch;
	}
	// 82C5CDF8: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CDFC: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5CE00: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C5CE04: 40980038  bge cr6, 0x82c5ce3c
	if !ctx.cr[6].lt {
	pc = 0x82C5CE3C; continue 'dispatch;
	}
	pc = 0x82C5CE08; continue 'dispatch;
            }
            0x82C5CE08 => {
    //   block [0x82C5CE08..0x82C5CE3C)
	// 82C5CE08: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CE0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C5CE10: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82C5CE14: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C5CE18: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82C5CE1C: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82C5CE20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C5CE24: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C5CE28: 4BFFFD59  bl 0x82c5cb80
	ctx.lr = 0x82C5CE2C;
	sub_82C5CB80(ctx, base);
	// 82C5CE2C: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C5CE30: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82C5CE34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5CE38: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82C5CE3C; continue 'dispatch;
            }
            0x82C5CE3C => {
    //   block [0x82C5CE3C..0x82C5CE48)
	// 82C5CE3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C5CE40: 409A0008  bne cr6, 0x82c5ce48
	if !ctx.cr[6].eq {
	pc = 0x82C5CE48; continue 'dispatch;
	}
	// 82C5CE44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CE48; continue 'dispatch;
            }
            0x82C5CE48 => {
    //   block [0x82C5CE48..0x82C5CE58)
	// 82C5CE48: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CE4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5CE50: 409A0008  bne cr6, 0x82c5ce58
	if !ctx.cr[6].eq {
	pc = 0x82C5CE58; continue 'dispatch;
	}
	// 82C5CE54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CE58; continue 'dispatch;
            }
            0x82C5CE58 => {
    //   block [0x82C5CE58..0x82C5CE6C)
	// 82C5CE58: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82C5CE5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5CE60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5CE64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5CE68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5CE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5CE70 size=152
    let mut pc: u32 = 0x82C5CE70;
    'dispatch: loop {
        match pc {
            0x82C5CE70 => {
    //   block [0x82C5CE70..0x82C5CEB4)
	// 82C5CE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5CE74: 4804C599  bl 0x82ca940c
	ctx.lr = 0x82C5CE78;
	sub_82CA93D0(ctx, base);
	// 82C5CE78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5CE7C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5CE80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C5CE84: 3BCB5184  addi r30, r11, 0x5184
	ctx.r[30].s64 = ctx.r[11].s64 + 20868;
	// 82C5CE88: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C5CE8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C5CE90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C5CE94: 4B7185ED  bl 0x82375480
	ctx.lr = 0x82C5CE98;
	sub_82375480(ctx, base);
	// 82C5CE98: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C5CE9C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C5CEA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5CEA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5CEA8: 419A000C  beq cr6, 0x82c5ceb4
	if ctx.cr[6].eq {
	pc = 0x82C5CEB4; continue 'dispatch;
	}
	// 82C5CEAC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C5CEB0: 419A0008  beq cr6, 0x82c5ceb8
	if ctx.cr[6].eq {
	pc = 0x82C5CEB8; continue 'dispatch;
	}
	pc = 0x82C5CEB4; continue 'dispatch;
            }
            0x82C5CEB4 => {
    //   block [0x82C5CEB4..0x82C5CEB8)
	// 82C5CEB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C5CEB8; continue 'dispatch;
            }
            0x82C5CEB8 => {
    //   block [0x82C5CEB8..0x82C5CEE4)
	// 82C5CEB8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5CEBC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5CEC0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5CEC4: 409A003C  bne cr6, 0x82c5cf00
	if !ctx.cr[6].eq {
	pc = 0x82C5CF00; continue 'dispatch;
	}
	// 82C5CEC8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82C5CECC: 4B5C238D  bl 0x8221f258
	ctx.lr = 0x82C5CED0;
	sub_8221F258(ctx, base);
	// 82C5CED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5CED4: 419A0010  beq cr6, 0x82c5cee4
	if ctx.cr[6].eq {
	pc = 0x82C5CEE4; continue 'dispatch;
	}
	// 82C5CED8: 4BFFE6D1  bl 0x82c5b5a8
	ctx.lr = 0x82C5CEDC;
	sub_82C5B5A8(ctx, base);
	// 82C5CEDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5CEE0: 48000008  b 0x82c5cee8
	pc = 0x82C5CEE8; continue 'dispatch;
            }
            0x82C5CEE4 => {
    //   block [0x82C5CEE4..0x82C5CEE8)
	// 82C5CEE4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C5CEE8; continue 'dispatch;
            }
            0x82C5CEE8 => {
    //   block [0x82C5CEE8..0x82C5CF00)
	// 82C5CEE8: 93FD0038  stw r31, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 82C5CEEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5CEF0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C5CEF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C5CEF8: 4BFFFE99  bl 0x82c5cd90
	ctx.lr = 0x82C5CEFC;
	sub_82C5CD90(ctx, base);
	// 82C5CEFC: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x82C5CF00; continue 'dispatch;
            }
            0x82C5CF00 => {
    //   block [0x82C5CF00..0x82C5CF08)
	// 82C5CF00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5CF04: 4804C558  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5CF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5CF08 size=24
    let mut pc: u32 = 0x82C5CF08;
    'dispatch: loop {
        match pc {
            0x82C5CF08 => {
    //   block [0x82C5CF08..0x82C5CF20)
	// 82C5CF08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5CF0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C5CF10: 392BD084  addi r9, r11, -0x2f7c
	ctx.r[9].s64 = ctx.r[11].s64 + -12156;
	// 82C5CF14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C5CF18: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5CF1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5CF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5CF20 size=16
    let mut pc: u32 = 0x82C5CF20;
    'dispatch: loop {
        match pc {
            0x82C5CF20 => {
    //   block [0x82C5CF20..0x82C5CF30)
	// 82C5CF20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5CF24: 394BD084  addi r10, r11, -0x2f7c
	ctx.r[10].s64 = ctx.r[11].s64 + -12156;
	// 82C5CF28: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5CF2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5CF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5CF30 size=92
    let mut pc: u32 = 0x82C5CF30;
    'dispatch: loop {
        match pc {
            0x82C5CF30 => {
    //   block [0x82C5CF30..0x82C5CF8C)
	// 82C5CF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5CF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5CF38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5CF3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5CF40: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5CF44: 3C800008  lis r4, 8
	ctx.r[4].s64 = 524288;
	// 82C5CF48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5CF4C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82C5CF50: 6084CA00  ori r4, r4, 0xca00
	ctx.r[4].u64 = ctx.r[4].u64 | 51712;
	// 82C5CF54: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5CF58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5CF5C: 4E800421  bctrl
	ctx.lr = 0x82C5CF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5CF60: 3CA00008  lis r5, 8
	ctx.r[5].s64 = 524288;
	// 82C5CF64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5CF68: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82C5CF6C: 60A5CA00  ori r5, r5, 0xca00
	ctx.r[5].u64 = ctx.r[5].u64 | 51712;
	// 82C5CF70: 4804CA41  bl 0x82ca99b0
	ctx.lr = 0x82C5CF74;
	sub_82CA99B0(ctx, base);
	// 82C5CF74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5CF78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5CF7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5CF80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5CF84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5CF88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5CF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5CF90 size=864
    let mut pc: u32 = 0x82C5CF90;
    'dispatch: loop {
        match pc {
            0x82C5CF90 => {
    //   block [0x82C5CF90..0x82C5CFDC)
	// 82C5CF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5CF94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5CF98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5CF9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5CFA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5CFA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5CFA8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C5CFAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C5CFB0: 48081601  bl 0x82cde5b0
	ctx.lr = 0x82C5CFB4;
	sub_82CDE5B0(ctx, base);
	// 82C5CFB4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82C5CFB8: 89210051  lbz r9, 0x51(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C5CFBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C5CFC0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C5CFC4: 816B62BC  lwz r11, 0x62bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25276 as u32) ) } as u64;
	// 82C5CFC8: 419A02F4  beq cr6, 0x82c5d2bc
	if ctx.cr[6].eq {
	pc = 0x82C5D2BC; continue 'dispatch;
	}
	// 82C5CFCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5CFD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5CFD4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C5CFD8: C1AA0C14  lfs f13, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82C5CFDC; continue 'dispatch;
            }
            0x82C5CFDC => {
    //   block [0x82C5CFDC..0x82C5CFE4)
	// 82C5CFDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C5CFE0: 54A7502A  slwi r7, r5, 0xa
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(10);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x82C5CFE4; continue 'dispatch;
            }
            0x82C5CFE4 => {
    //   block [0x82C5CFE4..0x82C5D030)
	// 82C5CFE4: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5CFE8: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5CFEC: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5CFF0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C5CFF4: 7C063C2E  lfsx f0, r6, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5CFF8: 419A0038  beq cr6, 0x82c5d030
	if ctx.cr[6].eq {
	pc = 0x82C5D030; continue 'dispatch;
	}
	// 82C5CFFC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D000: 83DF0018  lwz r30, 0x18(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D004: 7D081850  subf r8, r8, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82C5D008: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C5D00C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C5D010: 7C685BD6  divw r3, r8, r11
	ctx.r[3].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	// 82C5D014: 7C6359D6  mullw r3, r3, r11
	ctx.r[3].s32 = ((ctx.r[3].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82C5D018: 7D034050  subf r8, r3, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 82C5D01C: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C5D020: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5D024: 7D63F42E  lfsx f11, r3, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5D028: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C5D02C: 4800000C  b 0x82c5d038
	pc = 0x82C5D038; continue 'dispatch;
            }
            0x82C5D030 => {
    //   block [0x82C5D030..0x82C5D038)
	// 82C5D030: ED6C682A  fadds f11, f12, f13
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C5D034: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82C5D038; continue 'dispatch;
            }
            0x82C5D038 => {
    //   block [0x82C5D038..0x82C5D0B4)
	// 82C5D038: 7C063D2E  stfsx f0, r6, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82C5D03C: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D040: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D044: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C5D048: 7D035BD6  divw r8, r3, r11
	ctx.r[8].s32 = ctx.r[3].s32 / ctx.r[11].s32;
	// 82C5D04C: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82C5D050: 7D081850  subf r8, r8, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82C5D054: 7C684A14  add r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C5D058: 5468103A  slwi r8, r3, 2
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C5D05C: 7C08352E  stfsx f0, r8, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82C5D060: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5D064: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5D068: 7CC63A14  add r6, r6, r7
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82C5D06C: C0060004  lfs f0, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D070: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C5D074: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5D078: 419A003C  beq cr6, 0x82c5d0b4
	if ctx.cr[6].eq {
	pc = 0x82C5D0B4; continue 'dispatch;
	}
	// 82C5D07C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D080: 83DF0018  lwz r30, 0x18(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D084: 7D081850  subf r8, r8, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82C5D088: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C5D08C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C5D090: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82C5D094: 7C685BD6  divw r3, r8, r11
	ctx.r[3].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	// 82C5D098: 7C6359D6  mullw r3, r3, r11
	ctx.r[3].s32 = ((ctx.r[3].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82C5D09C: 7D034050  subf r8, r3, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 82C5D0A0: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C5D0A4: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5D0A8: 7D63F42E  lfsx f11, r3, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5D0AC: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C5D0B0: 4800000C  b 0x82c5d0bc
	pc = 0x82C5D0BC; continue 'dispatch;
            }
            0x82C5D0B4 => {
    //   block [0x82C5D0B4..0x82C5D0BC)
	// 82C5D0B4: ED6C682A  fadds f11, f12, f13
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C5D0B8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82C5D0BC; continue 'dispatch;
            }
            0x82C5D0BC => {
    //   block [0x82C5D0BC..0x82C5D13C)
	// 82C5D0BC: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5D0C0: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D0C4: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D0C8: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C5D0CC: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 82C5D0D0: 7D035BD6  divw r8, r3, r11
	ctx.r[8].s32 = ctx.r[3].s32 / ctx.r[11].s32;
	// 82C5D0D4: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82C5D0D8: 7D081850  subf r8, r8, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82C5D0DC: 7C684A14  add r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C5D0E0: 5468103A  slwi r8, r3, 2
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C5D0E4: 7C08352E  stfsx f0, r8, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82C5D0E8: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5D0EC: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5D0F0: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5D0F4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C5D0F8: 7CC63A14  add r6, r6, r7
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82C5D0FC: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D100: 419A003C  beq cr6, 0x82c5d13c
	if ctx.cr[6].eq {
	pc = 0x82C5D13C; continue 'dispatch;
	}
	// 82C5D104: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D108: 83DF0018  lwz r30, 0x18(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D10C: 7D081850  subf r8, r8, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82C5D110: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C5D114: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C5D118: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 82C5D11C: 7C685BD6  divw r3, r8, r11
	ctx.r[3].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	// 82C5D120: 7C6359D6  mullw r3, r3, r11
	ctx.r[3].s32 = ((ctx.r[3].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82C5D124: 7D034050  subf r8, r3, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 82C5D128: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C5D12C: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5D130: 7D63F42E  lfsx f11, r3, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5D134: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C5D138: 4800000C  b 0x82c5d144
	pc = 0x82C5D144; continue 'dispatch;
            }
            0x82C5D13C => {
    //   block [0x82C5D13C..0x82C5D144)
	// 82C5D13C: ED6C682A  fadds f11, f12, f13
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C5D140: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82C5D144; continue 'dispatch;
            }
            0x82C5D144 => {
    //   block [0x82C5D144..0x82C5D1C4)
	// 82C5D144: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5D148: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D14C: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D150: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C5D154: 38680002  addi r3, r8, 2
	ctx.r[3].s64 = ctx.r[8].s64 + 2;
	// 82C5D158: 7D035BD6  divw r8, r3, r11
	ctx.r[8].s32 = ctx.r[3].s32 / ctx.r[11].s32;
	// 82C5D15C: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82C5D160: 7D081850  subf r8, r8, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82C5D164: 7C684A14  add r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C5D168: 5468103A  slwi r8, r3, 2
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C5D16C: 7C08352E  stfsx f0, r8, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82C5D170: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5D174: 7CC83A14  add r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82C5D178: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5D17C: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5D180: C006000C  lfs f0, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D184: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C5D188: 419A003C  beq cr6, 0x82c5d1c4
	if ctx.cr[6].eq {
	pc = 0x82C5D1C4; continue 'dispatch;
	}
	// 82C5D18C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D190: 83DF0018  lwz r30, 0x18(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D194: 7D081850  subf r8, r8, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82C5D198: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C5D19C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C5D1A0: 39080003  addi r8, r8, 3
	ctx.r[8].s64 = ctx.r[8].s64 + 3;
	// 82C5D1A4: 7C685BD6  divw r3, r8, r11
	ctx.r[3].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	// 82C5D1A8: 7C6359D6  mullw r3, r3, r11
	ctx.r[3].s32 = ((ctx.r[3].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82C5D1AC: 7D034050  subf r8, r3, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 82C5D1B0: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C5D1B4: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5D1B8: 7D63F42E  lfsx f11, r3, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5D1BC: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C5D1C0: 4800000C  b 0x82c5d1cc
	pc = 0x82C5D1CC; continue 'dispatch;
            }
            0x82C5D1C4 => {
    //   block [0x82C5D1C4..0x82C5D1CC)
	// 82C5D1C4: ED6C682A  fadds f11, f12, f13
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C5D1C8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82C5D1CC; continue 'dispatch;
            }
            0x82C5D1CC => {
    //   block [0x82C5D1CC..0x82C5D218)
	// 82C5D1CC: D006000C  stfs f0, 0xc(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5D1D0: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D1D4: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 82C5D1D8: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D1DC: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C5D1E0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C5D1E4: 39080003  addi r8, r8, 3
	ctx.r[8].s64 = ctx.r[8].s64 + 3;
	// 82C5D1E8: 2F0A00FD  cmpwi cr6, r10, 0xfd
	ctx.cr[6].compare_i32(ctx.r[10].s32, 253, &mut ctx.xer);
	// 82C5D1EC: 7C685BD6  divw r3, r8, r11
	ctx.r[3].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	// 82C5D1F0: 7C6359D6  mullw r3, r3, r11
	ctx.r[3].s32 = ((ctx.r[3].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82C5D1F4: 7D034050  subf r8, r3, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 82C5D1F8: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C5D1FC: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5D200: 7C03352E  stfsx f0, r3, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82C5D204: 4198FDE0  blt cr6, 0x82c5cfe4
	if ctx.cr[6].lt {
	pc = 0x82C5CFE4; continue 'dispatch;
	}
	// 82C5D208: 2F0A0100  cmpwi cr6, r10, 0x100
	ctx.cr[6].compare_i32(ctx.r[10].s32, 256, &mut ctx.xer);
	// 82C5D20C: 40980098  bge cr6, 0x82c5d2a4
	if !ctx.cr[6].lt {
	pc = 0x82C5D2A4; continue 'dispatch;
	}
	// 82C5D210: 7D045214  add r8, r4, r10
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 82C5D214: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x82C5D218; continue 'dispatch;
            }
            0x82C5D218 => {
    //   block [0x82C5D218..0x82C5D264)
	// 82C5D218: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5D21C: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5D220: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5D224: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C5D228: 7C08342E  lfsx f0, r8, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D22C: 419A0038  beq cr6, 0x82c5d264
	if ctx.cr[6].eq {
	pc = 0x82C5D264; continue 'dispatch;
	}
	// 82C5D230: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D234: 83DF0018  lwz r30, 0x18(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D238: 7CE71850  subf r7, r7, r3
	ctx.r[7].s64 = ctx.r[3].s64 - ctx.r[7].s64;
	// 82C5D23C: 7CE75A14  add r7, r7, r11
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82C5D240: 7CE75214  add r7, r7, r10
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82C5D244: 7C675BD6  divw r3, r7, r11
	ctx.r[3].s32 = ctx.r[7].s32 / ctx.r[11].s32;
	// 82C5D248: 7C6359D6  mullw r3, r3, r11
	ctx.r[3].s32 = ((ctx.r[3].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82C5D24C: 7CE33850  subf r7, r3, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[3].s64;
	// 82C5D250: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82C5D254: 54E3103A  slwi r3, r7, 2
	ctx.r[3].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5D258: 7D63F42E  lfsx f11, r3, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5D25C: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C5D260: 4800000C  b 0x82c5d26c
	pc = 0x82C5D26C; continue 'dispatch;
            }
            0x82C5D264 => {
    //   block [0x82C5D264..0x82C5D26C)
	// 82C5D264: ED6C682A  fadds f11, f12, f13
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C5D268: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82C5D26C; continue 'dispatch;
            }
            0x82C5D26C => {
    //   block [0x82C5D26C..0x82C5D2A4)
	// 82C5D26C: 7C08352E  stfsx f0, r8, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82C5D270: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C5D274: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82C5D278: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D27C: 7C675214  add r3, r7, r10
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82C5D280: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C5D284: 7CE35BD6  divw r7, r3, r11
	ctx.r[7].s32 = ctx.r[3].s32 / ctx.r[11].s32;
	// 82C5D288: 2F0A0100  cmpwi cr6, r10, 0x100
	ctx.cr[6].compare_i32(ctx.r[10].s32, 256, &mut ctx.xer);
	// 82C5D28C: 7CE759D6  mullw r7, r7, r11
	ctx.r[7].s32 = ((ctx.r[7].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82C5D290: 7CE71850  subf r7, r7, r3
	ctx.r[7].s64 = ctx.r[3].s64 - ctx.r[7].s64;
	// 82C5D294: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82C5D298: 5467103A  slwi r7, r3, 2
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C5D29C: 7C07352E  stfsx f0, r7, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82C5D2A0: 4198FF78  blt cr6, 0x82c5d218
	if ctx.cr[6].lt {
	pc = 0x82C5D218; continue 'dispatch;
	}
	pc = 0x82C5D2A4; continue 'dispatch;
            }
            0x82C5D2A4 => {
    //   block [0x82C5D2A4..0x82C5D2BC)
	// 82C5D2A4: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C5D2A8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82C5D2AC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82C5D2B0: 38840100  addi r4, r4, 0x100
	ctx.r[4].s64 = ctx.r[4].s64 + 256;
	// 82C5D2B4: 7F054000  cmpw cr6, r5, r8
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82C5D2B8: 4198FD24  blt cr6, 0x82c5cfdc
	if ctx.cr[6].lt {
	pc = 0x82C5CFDC; continue 'dispatch;
	}
	pc = 0x82C5D2BC; continue 'dispatch;
            }
            0x82C5D2BC => {
    //   block [0x82C5D2BC..0x82C5D2F0)
	// 82C5D2BC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D2C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D2C4: 394A0100  addi r10, r10, 0x100
	ctx.r[10].s64 = ctx.r[10].s64 + 256;
	// 82C5D2C8: 7D2A5BD6  divw r9, r10, r11
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	// 82C5D2CC: 7D0959D6  mullw r8, r9, r11
	ctx.r[8].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82C5D2D0: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82C5D2D4: 90FF001C  stw r7, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82C5D2D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D2DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5D2E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5D2E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5D2E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5D2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C5D2F0 size=36
    let mut pc: u32 = 0x82C5D2F0;
    'dispatch: loop {
        match pc {
            0x82C5D2F0 => {
    //   block [0x82C5D2F0..0x82C5D314)
	// 82C5D2F0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82C5D2F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C5D2F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D2FC: 99440000  stb r10, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82C5D300: 816B62BC  lwz r11, 0x62bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25276 as u32) ) } as u64;
	// 82C5D304: 7D694670  srawi r9, r11, 8
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 8) as i64;
	// 82C5D308: 7D090194  addze r8, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82C5D30C: B1040002  sth r8, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 82C5D310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5D318 size=136
    let mut pc: u32 = 0x82C5D318;
    'dispatch: loop {
        match pc {
            0x82C5D318 => {
    //   block [0x82C5D318..0x82C5D370)
	// 82C5D318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D31C: 4804C0ED  bl 0x82ca9408
	ctx.lr = 0x82C5D320;
	sub_82CA93D0(ctx, base);
	// 82C5D320: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5D328: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82C5D32C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5D330: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D334: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C5D338: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D33C: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C5D340: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C5D344: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C5D348: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C5D34C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C5D350: 4807BC89  bl 0x82cd8fd8
	ctx.lr = 0x82C5D354;
	sub_82CD8FD8(ctx, base);
	// 82C5D354: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82C5D358: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5D35C: 4198001C  blt cr6, 0x82c5d378
	if ctx.cr[6].lt {
	pc = 0x82C5D378; continue 'dispatch;
	}
	// 82C5D360: 419A0010  beq cr6, 0x82c5d370
	if ctx.cr[6].eq {
	pc = 0x82C5D370; continue 'dispatch;
	}
	// 82C5D364: 3FC08000  lis r30, -0x8000
	ctx.r[30].s64 = -2147483648;
	// 82C5D368: 63DE4005  ori r30, r30, 0x4005
	ctx.r[30].u64 = ctx.r[30].u64 | 16389;
	// 82C5D36C: 48000014  b 0x82c5d380
	pc = 0x82C5D380; continue 'dispatch;
            }
            0x82C5D370 => {
    //   block [0x82C5D370..0x82C5D378)
	// 82C5D370: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D374: 48000008  b 0x82c5d37c
	pc = 0x82C5D37C; continue 'dispatch;
            }
            0x82C5D378 => {
    //   block [0x82C5D378..0x82C5D37C)
	// 82C5D378: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82C5D37C; continue 'dispatch;
            }
            0x82C5D37C => {
    //   block [0x82C5D37C..0x82C5D380)
	// 82C5D37C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82C5D380; continue 'dispatch;
            }
            0x82C5D380 => {
    //   block [0x82C5D380..0x82C5D3A0)
	// 82C5D380: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C5D384: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D388: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 82C5D38C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C5D390: 4807BC49  bl 0x82cd8fd8
	ctx.lr = 0x82C5D394;
	sub_82CD8FD8(ctx, base);
	// 82C5D394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5D398: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D39C: 4804C0BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5D3A0 size=220
    let mut pc: u32 = 0x82C5D3A0;
    'dispatch: loop {
        match pc {
            0x82C5D3A0 => {
    //   block [0x82C5D3A0..0x82C5D414)
	// 82C5D3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D3A4: 4804C069  bl 0x82ca940c
	ctx.lr = 0x82C5D3A8;
	sub_82CA93D0(ctx, base);
	// 82C5D3A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D3AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5D3B0: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D3B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5D3B8: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C5D3BC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C5D3C0: 4807BC19  bl 0x82cd8fd8
	ctx.lr = 0x82C5D3C4;
	sub_82CD8FD8(ctx, base);
	// 82C5D3C4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C5D3C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5D3CC: 41980048  blt cr6, 0x82c5d414
	if ctx.cr[6].lt {
	pc = 0x82C5D414; continue 'dispatch;
	}
	// 82C5D3D0: 409A009C  bne cr6, 0x82c5d46c
	if !ctx.cr[6].eq {
	pc = 0x82C5D46C; continue 'dispatch;
	}
	// 82C5D3D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5D3D8: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D3DC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5D3E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5D3E4: 41990088  bgt cr6, 0x82c5d46c
	if ctx.cr[6].gt {
	pc = 0x82C5D46C; continue 'dispatch;
	}
	// 82C5D3E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5D3EC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5D3F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5D3F4: 41980078  blt cr6, 0x82c5d46c
	if ctx.cr[6].lt {
	pc = 0x82C5D46C; continue 'dispatch;
	}
	// 82C5D3F8: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5D3FC: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D400: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 82C5D404: 4807BBD5  bl 0x82cd8fd8
	ctx.lr = 0x82C5D408;
	sub_82CD8FD8(ctx, base);
	// 82C5D408: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D40C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5D410: 4804C04C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5D414 => {
    //   block [0x82C5D414..0x82C5D46C)
	// 82C5D414: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5D418: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D41C: 396BD220  addi r11, r11, -0x2de0
	ctx.r[11].s64 = ctx.r[11].s64 + -11744;
	// 82C5D420: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5D424: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5D428: 41990044  bgt cr6, 0x82c5d46c
	if ctx.cr[6].gt {
	pc = 0x82C5D46C; continue 'dispatch;
	}
	// 82C5D42C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5D430: C1AA0C18  lfs f13, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5D434: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5D438: 41980034  blt cr6, 0x82c5d46c
	if ctx.cr[6].lt {
	pc = 0x82C5D46C; continue 'dispatch;
	}
	// 82C5D43C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5D440: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 82C5D444: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C5D448: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C5D44C: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D450: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 82C5D454: FD80681E  fctiwz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82C5D458: 7D9E5FAE  stfiwx f12, r30, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C5D45C: 4807BB7D  bl 0x82cd8fd8
	ctx.lr = 0x82C5D460;
	sub_82CD8FD8(ctx, base);
	// 82C5D460: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D464: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5D468: 4804BFF4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5D46C => {
    //   block [0x82C5D46C..0x82C5D47C)
	// 82C5D46C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C5D470: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C5D474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5D478: 4804BFE4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5D480 size=16
    let mut pc: u32 = 0x82C5D480;
    'dispatch: loop {
        match pc {
            0x82C5D480 => {
    //   block [0x82C5D480..0x82C5D490)
	// 82C5D480: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5D484: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D488: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5D48C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5D490 size=20
    let mut pc: u32 = 0x82C5D490;
    'dispatch: loop {
        match pc {
            0x82C5D490 => {
    //   block [0x82C5D490..0x82C5D4A4)
	// 82C5D490: 3D600008  lis r11, 8
	ctx.r[11].s64 = 524288;
	// 82C5D494: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D498: 616BCA20  ori r11, r11, 0xca20
	ctx.r[11].u64 = ctx.r[11].u64 | 51744;
	// 82C5D49C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5D4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5D4A8 size=36
    let mut pc: u32 = 0x82C5D4A8;
    'dispatch: loop {
        match pc {
            0x82C5D4A8 => {
    //   block [0x82C5D4A8..0x82C5D4CC)
	// 82C5D4A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C5D4AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5D4B0: 346AFFFF  addic. r3, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5D4B4: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C5D4B8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82C5D4BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C5D4C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D4C4: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C5D4C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5D4D0 size=180
    let mut pc: u32 = 0x82C5D4D0;
    'dispatch: loop {
        match pc {
            0x82C5D4D0 => {
    //   block [0x82C5D4D0..0x82C5D554)
	// 82C5D4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D4D4: 4804BF35  bl 0x82ca9408
	ctx.lr = 0x82C5D4D8;
	sub_82CA93D0(ctx, base);
	// 82C5D4D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D4DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5D4E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C5D4E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C5D4E8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82C5D4EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5D4F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5D4F4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5D4F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5D4FC: 4E800421  bctrl
	ctx.lr = 0x82C5D500;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5D500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5D504: 419A0050  beq cr6, 0x82c5d554
	if ctx.cr[6].eq {
	pc = 0x82C5D554; continue 'dispatch;
	}
	// 82C5D508: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5D50C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5D510: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C5D514: 390BD210  addi r8, r11, -0x2df0
	ctx.r[8].s64 = ctx.r[11].s64 + -11760;
	// 82C5D518: 38E9D224  addi r7, r9, -0x2ddc
	ctx.r[7].s64 = ctx.r[9].s64 + -11740;
	// 82C5D51C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C5D520: C00BD210  lfs f0, -0x2df0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D524: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C5D528: 388012C0  li r4, 0x12c0
	ctx.r[4].s64 = 4800;
	// 82C5D52C: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5D530: C008000C  lfs f0, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D534: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82C5D538: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C5D53C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C5D540: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C5D544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5D548: 90A3001C  stw r5, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 82C5D54C: 90830014  stw r4, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 82C5D550: 48000008  b 0x82c5d558
	pc = 0x82C5D558; continue 'dispatch;
            }
            0x82C5D554 => {
    //   block [0x82C5D554..0x82C5D558)
	// 82C5D554: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C5D558; continue 'dispatch;
            }
            0x82C5D558 => {
    //   block [0x82C5D558..0x82C5D584)
	// 82C5D558: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5D55C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C5D560: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C5D564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5D568: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5D56C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5D570: 4E800421  bctrl
	ctx.lr = 0x82C5D574;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5D574: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C5D578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D57C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D580: 4804BED8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5D588 size=140
    let mut pc: u32 = 0x82C5D588;
    'dispatch: loop {
        match pc {
            0x82C5D588 => {
    //   block [0x82C5D588..0x82C5D5DC)
	// 82C5D588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D58C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5D590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5D594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5D598: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C5D59C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D5A0: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5D5A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5D5A8: 38800400  li r4, 0x400
	ctx.r[4].s64 = 1024;
	// 82C5D5AC: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82C5D5B0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5D5B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5D5B8: 4E800421  bctrl
	ctx.lr = 0x82C5D5BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5D5BC: 38A00400  li r5, 0x400
	ctx.r[5].s64 = 1024;
	// 82C5D5C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5D5C4: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82C5D5C8: 4804C3E9  bl 0x82ca99b0
	ctx.lr = 0x82C5D5CC;
	sub_82CA99B0(ctx, base);
	// 82C5D5CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5D5D0: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 82C5D5D4: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	// 82C5D5D8: C3EB0C10  lfs f31, 0xc10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3088 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
            }
            0x82C5D5DC => {
    //   block [0x82C5D5DC..0x82C5D614)
	// 82C5D5DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5D5E0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C5D5E4: 480020AD  bl 0x82c5f690
	ctx.lr = 0x82C5D5E8;
	sub_82C5F690(ctx, base);
	// 82C5D5E8: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82C5D5EC: 3BDE01DC  addi r30, r30, 0x1dc
	ctx.r[30].s64 = ctx.r[30].s64 + 476;
	// 82C5D5F0: 4082FFEC  bne 0x82c5d5dc
	if !ctx.cr[0].eq {
	pc = 0x82C5D5DC; continue 'dispatch;
	}
	// 82C5D5F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D5F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5D5FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5D600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5D604: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C5D608: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5D60C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5D610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5D618 size=176
    let mut pc: u32 = 0x82C5D618;
    'dispatch: loop {
        match pc {
            0x82C5D618 => {
    //   block [0x82C5D618..0x82C5D634)
	// 82C5D618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D61C: 4804BDF1  bl 0x82ca940c
	ctx.lr = 0x82C5D620;
	sub_82CA93D0(ctx, base);
	// 82C5D620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5D628: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C5D62C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5D630: 409A0014  bne cr6, 0x82c5d644
	if !ctx.cr[6].eq {
	pc = 0x82C5D644; continue 'dispatch;
	}
	pc = 0x82C5D634; continue 'dispatch;
            }
            0x82C5D634 => {
    //   block [0x82C5D634..0x82C5D644)
	// 82C5D634: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5D638: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5D63C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D640: 4804BE1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5D644 => {
    //   block [0x82C5D644..0x82C5D68C)
	// 82C5D644: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C5D648: 409AFFEC  bne cr6, 0x82c5d634
	if !ctx.cr[6].eq {
	pc = 0x82C5D634; continue 'dispatch;
	}
	// 82C5D64C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5D650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5D654: 419AFFE0  beq cr6, 0x82c5d634
	if ctx.cr[6].eq {
	pc = 0x82C5D634; continue 'dispatch;
	}
	// 82C5D658: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C5D65C: 48080F55  bl 0x82cde5b0
	ctx.lr = 0x82C5D660;
	sub_82CDE5B0(ctx, base);
	// 82C5D660: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5D664: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5D668: 409AFFCC  bne cr6, 0x82c5d634
	if !ctx.cr[6].eq {
	pc = 0x82C5D634; continue 'dispatch;
	}
	// 82C5D66C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C5D670: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 82C5D674: 4199FFC0  bgt cr6, 0x82c5d634
	if ctx.cr[6].gt {
	pc = 0x82C5D634; continue 'dispatch;
	}
	// 82C5D678: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C5D67C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C5D680: 4099003C  ble cr6, 0x82c5d6bc
	if !ctx.cr[6].gt {
	pc = 0x82C5D6BC; continue 'dispatch;
	}
	// 82C5D684: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C5D688: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	pc = 0x82C5D68C; continue 'dispatch;
            }
            0x82C5D68C => {
    //   block [0x82C5D68C..0x82C5D6BC)
	// 82C5D68C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5D690: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 82C5D694: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5D698: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82C5D69C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C5D6A0: 48001969  bl 0x82c5f008
	ctx.lr = 0x82C5D6A4;
	sub_82C5F008(ctx, base);
	// 82C5D6A4: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C5D6A8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C5D6AC: 3BFF0400  addi r31, r31, 0x400
	ctx.r[31].s64 = ctx.r[31].s64 + 1024;
	// 82C5D6B0: 3BDE01DC  addi r30, r30, 0x1dc
	ctx.r[30].s64 = ctx.r[30].s64 + 476;
	// 82C5D6B4: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C5D6B8: 4198FFD4  blt cr6, 0x82c5d68c
	if ctx.cr[6].lt {
	pc = 0x82C5D68C; continue 'dispatch;
	}
	pc = 0x82C5D6BC; continue 'dispatch;
            }
            0x82C5D6BC => {
    //   block [0x82C5D6BC..0x82C5D6C8)
	// 82C5D6BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D6C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D6C4: 4804BD98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5D6C8 size=20
    let mut pc: u32 = 0x82C5D6C8;
    'dispatch: loop {
        match pc {
            0x82C5D6C8 => {
    //   block [0x82C5D6C8..0x82C5D6DC)
	// 82C5D6C8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C5D6CC: 409A0010  bne cr6, 0x82c5d6dc
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C5D6DC);
		return;
	}
	// 82C5D6D0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5D6D4: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5D6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5D6F0 size=184
    let mut pc: u32 = 0x82C5D6F0;
    'dispatch: loop {
        match pc {
            0x82C5D6F0 => {
    //   block [0x82C5D6F0..0x82C5D714)
	// 82C5D6F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D6F4: 4804BD11  bl 0x82ca9404
	ctx.lr = 0x82C5D6F8;
	sub_82CA93D0(ctx, base);
	// 82C5D6F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D6FC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C5D700: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C5D704: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C5D708: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C5D70C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C5D710: 409A0014  bne cr6, 0x82c5d724
	if !ctx.cr[6].eq {
	pc = 0x82C5D724; continue 'dispatch;
	}
	pc = 0x82C5D714; continue 'dispatch;
            }
            0x82C5D714 => {
    //   block [0x82C5D714..0x82C5D724)
	// 82C5D714: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5D718: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5D71C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5D720: 4804BD34  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5D724 => {
    //   block [0x82C5D724..0x82C5D760)
	// 82C5D724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5D728: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82C5D72C: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D730: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C5D734: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C5D738: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D73C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C5D740: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C5D744: 4807B895  bl 0x82cd8fd8
	ctx.lr = 0x82C5D748;
	sub_82CD8FD8(ctx, base);
	// 82C5D748: 57E9063E  clrlwi r9, r31, 0x18
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82C5D74C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C5D750: 419A0010  beq cr6, 0x82c5d760
	if ctx.cr[6].eq {
	pc = 0x82C5D760; continue 'dispatch;
	}
	// 82C5D754: 3FC08000  lis r30, -0x8000
	ctx.r[30].s64 = -2147483648;
	// 82C5D758: 63DE4005  ori r30, r30, 0x4005
	ctx.r[30].u64 = ctx.r[30].u64 | 16389;
	// 82C5D75C: 4800002C  b 0x82c5d788
	pc = 0x82C5D788; continue 'dispatch;
            }
            0x82C5D760 => {
    //   block [0x82C5D760..0x82C5D788)
	// 82C5D760: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82C5D764: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5D768: 409AFFAC  bne cr6, 0x82c5d714
	if !ctx.cr[6].eq {
	pc = 0x82C5D714; continue 'dispatch;
	}
	// 82C5D76C: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5D770: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 82C5D774: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82C5D778: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C5D77C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C5D780: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C5D784: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82C5D788; continue 'dispatch;
            }
            0x82C5D788 => {
    //   block [0x82C5D788..0x82C5D7A8)
	// 82C5D788: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C5D78C: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D790: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 82C5D794: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C5D798: 4807B841  bl 0x82cd8fd8
	ctx.lr = 0x82C5D79C;
	sub_82CD8FD8(ctx, base);
	// 82C5D79C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5D7A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5D7A4: 4804BCB0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5D7A8 size=220
    let mut pc: u32 = 0x82C5D7A8;
    'dispatch: loop {
        match pc {
            0x82C5D7A8 => {
    //   block [0x82C5D7A8..0x82C5D7CC)
	// 82C5D7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D7AC: 4804BC5D  bl 0x82ca9408
	ctx.lr = 0x82C5D7B0;
	sub_82CA93D0(ctx, base);
	// 82C5D7B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D7B4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C5D7B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C5D7BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5D7C0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C5D7C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5D7C8: 409A0014  bne cr6, 0x82c5d7dc
	if !ctx.cr[6].eq {
	pc = 0x82C5D7DC; continue 'dispatch;
	}
	pc = 0x82C5D7CC; continue 'dispatch;
            }
            0x82C5D7CC => {
    //   block [0x82C5D7CC..0x82C5D7DC)
	// 82C5D7CC: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5D7D0: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5D7D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D7D8: 4804BC80  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5D7DC => {
    //   block [0x82C5D7DC..0x82C5D838)
	// 82C5D7DC: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D7E0: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C5D7E4: 4807B7F5  bl 0x82cd8fd8
	ctx.lr = 0x82C5D7E8;
	sub_82CD8FD8(ctx, base);
	// 82C5D7E8: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C5D7EC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5D7F0: 409A0078  bne cr6, 0x82c5d868
	if !ctx.cr[6].eq {
	pc = 0x82C5D868; continue 'dispatch;
	}
	// 82C5D7F4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82C5D7F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5D7FC: 409AFFD0  bne cr6, 0x82c5d7cc
	if !ctx.cr[6].eq {
	pc = 0x82C5D7CC; continue 'dispatch;
	}
	// 82C5D800: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5D804: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D808: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5D80C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5D810: 41980058  blt cr6, 0x82c5d868
	if ctx.cr[6].lt {
	pc = 0x82C5D868; continue 'dispatch;
	}
	// 82C5D814: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82C5D818: C1ABBDF8  lfs f13, -0x4208(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16904 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5D81C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5D820: 40980048  bge cr6, 0x82c5d868
	if !ctx.cr[6].lt {
	pc = 0x82C5D868; continue 'dispatch;
	}
	// 82C5D824: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82C5D828: 3BDD0018  addi r30, r29, 0x18
	ctx.r[30].s64 = ctx.r[29].s64 + 24;
	// 82C5D82C: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	// 82C5D830: 39800014  li r12, 0x14
	ctx.r[12].s64 = 20;
	// 82C5D834: 7C1D67AE  stfiwx f0, r29, r12
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	pc = 0x82C5D838; continue 'dispatch;
            }
            0x82C5D838 => {
    //   block [0x82C5D838..0x82C5D868)
	// 82C5D838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5D83C: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5D840: 48001BA1  bl 0x82c5f3e0
	ctx.lr = 0x82C5D844;
	sub_82C5F3E0(ctx, base);
	// 82C5D844: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82C5D848: 3BDE01DC  addi r30, r30, 0x1dc
	ctx.r[30].s64 = ctx.r[30].s64 + 476;
	// 82C5D84C: 4082FFEC  bne 0x82c5d838
	if !ctx.cr[0].eq {
	pc = 0x82C5D838; continue 'dispatch;
	}
	// 82C5D850: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D854: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 82C5D858: 4807B781  bl 0x82cd8fd8
	ctx.lr = 0x82C5D85C;
	sub_82CD8FD8(ctx, base);
	// 82C5D85C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D860: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D864: 4804BBF4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5D868 => {
    //   block [0x82C5D868..0x82C5D884)
	// 82C5D868: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5D86C: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 82C5D870: 4807B769  bl 0x82cd8fd8
	ctx.lr = 0x82C5D874;
	sub_82CD8FD8(ctx, base);
	// 82C5D874: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C5D878: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C5D87C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D880: 4804BBD8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5D888 size=20
    let mut pc: u32 = 0x82C5D888;
    'dispatch: loop {
        match pc {
            0x82C5D888 => {
    //   block [0x82C5D888..0x82C5D89C)
	// 82C5D888: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C5D88C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5D890: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82C5D894: 906A0008  stw r3, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C5D898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5D8A0 size=72
    let mut pc: u32 = 0x82C5D8A0;
    'dispatch: loop {
        match pc {
            0x82C5D8A0 => {
    //   block [0x82C5D8A0..0x82C5D8BC)
	// 82C5D8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5D8A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5D8AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5D8B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D8B4: 3BE30B40  addi r31, r3, 0xb40
	ctx.r[31].s64 = ctx.r[3].s64 + 2880;
	// 82C5D8B8: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	pc = 0x82C5D8BC; continue 'dispatch;
            }
            0x82C5D8BC => {
    //   block [0x82C5D8BC..0x82C5D8E8)
	// 82C5D8BC: 3BFFFE24  addi r31, r31, -0x1dc
	ctx.r[31].s64 = ctx.r[31].s64 + -476;
	// 82C5D8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5D8C4: 48001035  bl 0x82c5e8f8
	ctx.lr = 0x82C5D8C8;
	sub_82C5E8F8(ctx, base);
	// 82C5D8C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C5D8CC: 4080FFF0  bge 0x82c5d8bc
	if !ctx.cr[0].lt {
	pc = 0x82C5D8BC; continue 'dispatch;
	}
	// 82C5D8D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5D8D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5D8D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5D8DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5D8E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5D8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5D8E8 size=20
    let mut pc: u32 = 0x82C5D8E8;
    'dispatch: loop {
        match pc {
            0x82C5D8E8 => {
    //   block [0x82C5D8E8..0x82C5D8FC)
	// 82C5D8E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5D8EC: 409A0010  bne cr6, 0x82c5d8fc
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C5D8FC);
		return;
	}
	// 82C5D8F0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5D8F4: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5D8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5D918 size=108
    let mut pc: u32 = 0x82C5D918;
    'dispatch: loop {
        match pc {
            0x82C5D918 => {
    //   block [0x82C5D918..0x82C5D940)
	// 82C5D918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D91C: 4804BAED  bl 0x82ca9408
	ctx.lr = 0x82C5D920;
	sub_82CA93D0(ctx, base);
	// 82C5D920: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5D928: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5D92C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C5D930: 394BD248  addi r10, r11, -0x2db8
	ctx.r[10].s64 = ctx.r[11].s64 + -11704;
	// 82C5D934: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	// 82C5D938: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 82C5D93C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82C5D940; continue 'dispatch;
            }
            0x82C5D940 => {
    //   block [0x82C5D940..0x82C5D984)
	// 82C5D940: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5D944: 48001C75  bl 0x82c5f5b8
	ctx.lr = 0x82C5D948;
	sub_82C5F5B8(ctx, base);
	// 82C5D948: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C5D94C: 3BBD01DC  addi r29, r29, 0x1dc
	ctx.r[29].s64 = ctx.r[29].s64 + 476;
	// 82C5D950: 4080FFF0  bge 0x82c5d940
	if !ctx.cr[0].lt {
	pc = 0x82C5D940; continue 'dispatch;
	}
	// 82C5D954: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5D958: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82C5D95C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5D960: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82C5D964: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C5D968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5D96C: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C5D970: C00AD244  lfs f0, -0x2dbc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5D974: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C5D978: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5D97C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5D980: 4804BAD8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5D988 size=80
    let mut pc: u32 = 0x82C5D988;
    'dispatch: loop {
        match pc {
            0x82C5D988 => {
    //   block [0x82C5D988..0x82C5D9C4)
	// 82C5D988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5D990: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D994: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5D998: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C5D99C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C5D9A0: 40820024  bne 0x82c5d9c4
	if !ctx.cr[0].eq {
	pc = 0x82C5D9C4; continue 'dispatch;
	}
	// 82C5D9A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5D9A8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C5D9AC: 4BFFFEF5  bl 0x82c5d8a0
	ctx.lr = 0x82C5D9B0;
	sub_82C5D8A0(ctx, base);
	// 82C5D9B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5D9B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5D9B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5D9BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5D9C0: 4E800020  blr
	return;
            }
            0x82C5D9C4 => {
    //   block [0x82C5D9C4..0x82C5D9D8)
	// 82C5D9C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C5D9C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5D9CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5D9D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5D9D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5D9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5D9D8 size=160
    let mut pc: u32 = 0x82C5D9D8;
    'dispatch: loop {
        match pc {
            0x82C5D9D8 => {
    //   block [0x82C5D9D8..0x82C5D9F8)
	// 82C5D9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5D9DC: 4804BA2D  bl 0x82ca9408
	ctx.lr = 0x82C5D9E0;
	sub_82CA93D0(ctx, base);
	// 82C5D9E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5D9E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5D9E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5D9EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C5D9F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C5D9F4: 409A0014  bne cr6, 0x82c5da08
	if !ctx.cr[6].eq {
	pc = 0x82C5DA08; continue 'dispatch;
	}
	pc = 0x82C5D9F8; continue 'dispatch;
            }
            0x82C5D9F8 => {
    //   block [0x82C5D9F8..0x82C5DA08)
	// 82C5D9F8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5D9FC: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5DA00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5DA04: 4804BA54  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5DA08 => {
    //   block [0x82C5DA08..0x82C5DA48)
	// 82C5DA08: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C5DA0C: 419AFFEC  beq cr6, 0x82c5d9f8
	if ctx.cr[6].eq {
	pc = 0x82C5D9F8; continue 'dispatch;
	}
	// 82C5DA10: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C5DA14: 419AFFE4  beq cr6, 0x82c5d9f8
	if ctx.cr[6].eq {
	pc = 0x82C5D9F8; continue 'dispatch;
	}
	// 82C5DA18: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5DA1C: 38800B40  li r4, 0xb40
	ctx.r[4].s64 = 2880;
	// 82C5DA20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5DA24: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5DA28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5DA2C: 4E800421  bctrl
	ctx.lr = 0x82C5DA30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5DA30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5DA34: 419A0014  beq cr6, 0x82c5da48
	if ctx.cr[6].eq {
	pc = 0x82C5DA48; continue 'dispatch;
	}
	// 82C5DA38: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5DA3C: 4BFFFEDD  bl 0x82c5d918
	ctx.lr = 0x82C5DA40;
	sub_82C5D918(ctx, base);
	// 82C5DA40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5DA44: 48000008  b 0x82c5da4c
	pc = 0x82C5DA4C; continue 'dispatch;
            }
            0x82C5DA48 => {
    //   block [0x82C5DA48..0x82C5DA4C)
	// 82C5DA48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C5DA4C; continue 'dispatch;
            }
            0x82C5DA4C => {
    //   block [0x82C5DA4C..0x82C5DA78)
	// 82C5DA4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5DA50: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C5DA54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C5DA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5DA5C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5DA60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5DA64: 4E800421  bctrl
	ctx.lr = 0x82C5DA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5DA68: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C5DA6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5DA70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5DA74: 4804B9E4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5DA78 size=20
    let mut pc: u32 = 0x82C5DA78;
    'dispatch: loop {
        match pc {
            0x82C5DA78 => {
    //   block [0x82C5DA78..0x82C5DA8C)
	// 82C5DA78: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C5DA7C: 409A0010  bne cr6, 0x82c5da8c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C5DA8C);
		return;
	}
	// 82C5DA80: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5DA84: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5DA88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5DAA0 size=160
    let mut pc: u32 = 0x82C5DAA0;
    'dispatch: loop {
        match pc {
            0x82C5DAA0 => {
    //   block [0x82C5DAA0..0x82C5DAC0)
	// 82C5DAA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5DAA4: 4804B965  bl 0x82ca9408
	ctx.lr = 0x82C5DAA8;
	sub_82CA93D0(ctx, base);
	// 82C5DAA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5DAAC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C5DAB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C5DAB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5DAB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5DABC: 409A0014  bne cr6, 0x82c5dad0
	if !ctx.cr[6].eq {
	pc = 0x82C5DAD0; continue 'dispatch;
	}
	pc = 0x82C5DAC0; continue 'dispatch;
            }
            0x82C5DAC0 => {
    //   block [0x82C5DAC0..0x82C5DAD0)
	// 82C5DAC0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5DAC4: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5DAC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5DACC: 4804B98C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5DAD0 => {
    //   block [0x82C5DAD0..0x82C5DB10)
	// 82C5DAD0: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82C5DAD4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5DAD8: 409AFFE8  bne cr6, 0x82c5dac0
	if !ctx.cr[6].eq {
	pc = 0x82C5DAC0; continue 'dispatch;
	}
	// 82C5DADC: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5DAE0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C5DAE4: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C5DAE8: 4807B4F1  bl 0x82cd8fd8
	ctx.lr = 0x82C5DAEC;
	sub_82CD8FD8(ctx, base);
	// 82C5DAEC: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C5DAF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5DAF4: 4198002C  blt cr6, 0x82c5db20
	if ctx.cr[6].lt {
	pc = 0x82C5DB20; continue 'dispatch;
	}
	// 82C5DAF8: 419A0020  beq cr6, 0x82c5db18
	if ctx.cr[6].eq {
	pc = 0x82C5DB18; continue 'dispatch;
	}
	// 82C5DAFC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82C5DB00: 41980010  blt cr6, 0x82c5db10
	if ctx.cr[6].lt {
	pc = 0x82C5DB10; continue 'dispatch;
	}
	// 82C5DB04: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 82C5DB08: 639C0057  ori r28, r28, 0x57
	ctx.r[28].u64 = ctx.r[28].u64 | 87;
	// 82C5DB0C: 4800001C  b 0x82c5db28
	pc = 0x82C5DB28; continue 'dispatch;
            }
            0x82C5DB10 => {
    //   block [0x82C5DB10..0x82C5DB18)
	// 82C5DB10: C01D0168  lfs f0, 0x168(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5DB14: 48000010  b 0x82c5db24
	pc = 0x82C5DB24; continue 'dispatch;
            }
            0x82C5DB18 => {
    //   block [0x82C5DB18..0x82C5DB20)
	// 82C5DB18: C01D0164  lfs f0, 0x164(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5DB1C: 48000008  b 0x82c5db24
	pc = 0x82C5DB24; continue 'dispatch;
            }
            0x82C5DB20 => {
    //   block [0x82C5DB20..0x82C5DB24)
	// 82C5DB20: C01D0160  lfs f0, 0x160(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82C5DB24; continue 'dispatch;
            }
            0x82C5DB24 => {
    //   block [0x82C5DB24..0x82C5DB28)
	// 82C5DB24: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82C5DB28; continue 'dispatch;
            }
            0x82C5DB28 => {
    //   block [0x82C5DB28..0x82C5DB40)
	// 82C5DB28: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5DB2C: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 82C5DB30: 4807B4A9  bl 0x82cd8fd8
	ctx.lr = 0x82C5DB34;
	sub_82CD8FD8(ctx, base);
	// 82C5DB34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C5DB38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5DB3C: 4804B91C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5DB40 size=176
    let mut pc: u32 = 0x82C5DB40;
    'dispatch: loop {
        match pc {
            0x82C5DB40 => {
    //   block [0x82C5DB40..0x82C5DB60)
	// 82C5DB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5DB44: 4804B8C5  bl 0x82ca9408
	ctx.lr = 0x82C5DB48;
	sub_82CA93D0(ctx, base);
	// 82C5DB48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5DB4C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C5DB50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5DB54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5DB58: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C5DB5C: 409A0014  bne cr6, 0x82c5db70
	if !ctx.cr[6].eq {
	pc = 0x82C5DB70; continue 'dispatch;
	}
	pc = 0x82C5DB60; continue 'dispatch;
            }
            0x82C5DB60 => {
    //   block [0x82C5DB60..0x82C5DB70)
	// 82C5DB60: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5DB64: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5DB68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5DB6C: 4804B8EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5DB70 => {
    //   block [0x82C5DB70..0x82C5DBB0)
	// 82C5DB70: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82C5DB74: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5DB78: 409AFFE8  bne cr6, 0x82c5db60
	if !ctx.cr[6].eq {
	pc = 0x82C5DB60; continue 'dispatch;
	}
	// 82C5DB7C: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5DB80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C5DB84: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C5DB88: 4807B451  bl 0x82cd8fd8
	ctx.lr = 0x82C5DB8C;
	sub_82CD8FD8(ctx, base);
	// 82C5DB8C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C5DB90: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5DB94: 41980034  blt cr6, 0x82c5dbc8
	if ctx.cr[6].lt {
	pc = 0x82C5DBC8; continue 'dispatch;
	}
	// 82C5DB98: 419A0024  beq cr6, 0x82c5dbbc
	if ctx.cr[6].eq {
	pc = 0x82C5DBBC; continue 'dispatch;
	}
	// 82C5DB9C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82C5DBA0: 41980010  blt cr6, 0x82c5dbb0
	if ctx.cr[6].lt {
	pc = 0x82C5DBB0; continue 'dispatch;
	}
	// 82C5DBA4: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 82C5DBA8: 639C0057  ori r28, r28, 0x57
	ctx.r[28].u64 = ctx.r[28].u64 | 87;
	// 82C5DBAC: 4800002C  b 0x82c5dbd8
	pc = 0x82C5DBD8; continue 'dispatch;
            }
            0x82C5DBB0 => {
    //   block [0x82C5DBB0..0x82C5DBBC)
	// 82C5DBB0: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5DBB4: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82C5DBB8: 48000018  b 0x82c5dbd0
	pc = 0x82C5DBD0; continue 'dispatch;
            }
            0x82C5DBBC => {
    //   block [0x82C5DBBC..0x82C5DBC8)
	// 82C5DBBC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5DBC0: D01F0164  stfs f0, 0x164(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82C5DBC4: 4800000C  b 0x82c5dbd0
	pc = 0x82C5DBD0; continue 'dispatch;
            }
            0x82C5DBC8 => {
    //   block [0x82C5DBC8..0x82C5DBD0)
	// 82C5DBC8: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5DBCC: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	pc = 0x82C5DBD0; continue 'dispatch;
            }
            0x82C5DBD0 => {
    //   block [0x82C5DBD0..0x82C5DBD8)
	// 82C5DBD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C5DBD4: 997F016C  stb r11, 0x16c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u8 ) };
	pc = 0x82C5DBD8; continue 'dispatch;
            }
            0x82C5DBD8 => {
    //   block [0x82C5DBD8..0x82C5DBF0)
	// 82C5DBD8: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82C5DBDC: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 82C5DBE0: 4807B3F9  bl 0x82cd8fd8
	ctx.lr = 0x82C5DBE4;
	sub_82CD8FD8(ctx, base);
	// 82C5DBE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C5DBE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5DBEC: 4804B86C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5DBF0 size=20
    let mut pc: u32 = 0x82C5DBF0;
    'dispatch: loop {
        match pc {
            0x82C5DBF0 => {
    //   block [0x82C5DBF0..0x82C5DC04)
	// 82C5DBF0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C5DBF4: 409A0010  bne cr6, 0x82c5dc04
	if !ctx.cr[6].eq {
		sub_82C5DC04(ctx, base);
		return;
	}
	// 82C5DBF8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5DBFC: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5DC00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DC04(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5DC04 size=16
    let mut pc: u32 = 0x82C5DC04;
    'dispatch: loop {
        match pc {
            0x82C5DC04 => {
    //   block [0x82C5DC04..0x82C5DC14)
	// 82C5DC04: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5DC08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5DC0C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5DC10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5DC18 size=20
    let mut pc: u32 = 0x82C5DC18;
    'dispatch: loop {
        match pc {
            0x82C5DC18 => {
    //   block [0x82C5DC18..0x82C5DC2C)
	// 82C5DC18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5DC1C: 409A0010  bne cr6, 0x82c5dc2c
	if !ctx.cr[6].eq {
		sub_82C5DC2C(ctx, base);
		return;
	}
	// 82C5DC20: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5DC24: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5DC28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DC2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5DC2C size=24
    let mut pc: u32 = 0x82C5DC2C;
    'dispatch: loop {
        match pc {
            0x82C5DC2C => {
    //   block [0x82C5DC2C..0x82C5DC44)
	// 82C5DC2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C5DC30: 419AFFF0  beq cr6, 0x82c5dc20
	if ctx.cr[6].eq {
		sub_82C5DC18(ctx, base);
		return;
	}
	// 82C5DC34: 39600170  li r11, 0x170
	ctx.r[11].s64 = 368;
	// 82C5DC38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5DC3C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5DC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5DC48 size=112
    let mut pc: u32 = 0x82C5DC48;
    'dispatch: loop {
        match pc {
            0x82C5DC48 => {
    //   block [0x82C5DC48..0x82C5DC5C)
	// 82C5DC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5DC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5DC50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5DC54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5DC58: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x82C5DC5C; continue 'dispatch;
            }
            0x82C5DC5C => {
    //   block [0x82C5DC5C..0x82C5DCA0)
	// 82C5DC5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82C5DC60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82C5DC64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82C5DC68: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82C5DC6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82C5DC70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82C5DC74: 4082FFE8  bne 0x82c5dc5c
	if !ctx.cr[0].eq {
	pc = 0x82C5DC5C; continue 'dispatch;
	}
	// 82C5DC78: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82C5DC7C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82C5DC80: 409A0020  bne cr6, 0x82c5dca0
	if !ctx.cr[6].eq {
	pc = 0x82C5DCA0; continue 'dispatch;
	}
	// 82C5DC84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5DC88: 419A0018  beq cr6, 0x82c5dca0
	if ctx.cr[6].eq {
	pc = 0x82C5DCA0; continue 'dispatch;
	}
	// 82C5DC8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5DC90: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C5DC94: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5DC98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5DC9C: 4E800421  bctrl
	ctx.lr = 0x82C5DCA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C5DCA0 => {
    //   block [0x82C5DCA0..0x82C5DCB8)
	// 82C5DCA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5DCA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5DCA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5DCAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5DCB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5DCB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DCB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C5DCB8 size=492
    let mut pc: u32 = 0x82C5DCB8;
    'dispatch: loop {
        match pc {
            0x82C5DCB8 => {
    //   block [0x82C5DCB8..0x82C5DCD4)
	// 82C5DCB8: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 82C5DCBC: 41980178  blt cr6, 0x82c5de34
	if ctx.cr[6].lt {
	pc = 0x82C5DE34; continue 'dispatch;
	}
	// 82C5DCC0: 3966FFFC  addi r11, r6, -4
	ctx.r[11].s64 = ctx.r[6].s64 + -4;
	// 82C5DCC4: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C5DCC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C5DCCC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C5DCD0: 7CCA3050  subf r6, r10, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	pc = 0x82C5DCD4; continue 'dispatch;
            }
            0x82C5DCD4 => {
    //   block [0x82C5DCD4..0x82C5DE34)
	// 82C5DCD4: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5DCD8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C5DCDC: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5DCE0: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C5DCE4: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5DCE8: C1430004  lfs f10, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5DCEC: C123001C  lfs f9, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C5DCF0: C103000C  lfs f8, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C5DCF4: C0E30020  lfs f7, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C5DCF8: C0C30010  lfs f6, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C5DCFC: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5DD00: C0A30024  lfs f5, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C5DD04: C0830014  lfs f4, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C5DD08: C0640000  lfs f3, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C5DD0C: EC4B62BA  fmadds f2, f11, f10, f12
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82C5DD10: D0E30024  stfs f7, 0x24(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5DD14: EC29123A  fmadds f1, f9, f8, f2
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[8].f64 + ctx.f[2].f64) as f32) as f64);
	// 82C5DD18: D0630018  stfs f3, 0x18(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5DD1C: EC0709BC  fnmsubs f0, f7, f6, f1
	ctx.f[0].f64 = -(((ctx.f[7].f64 * ctx.f[6].f64 - ctx.f[1].f64) as f32) as f64);
	// 82C5DD20: EDA5013C  fnmsubs f13, f5, f4, f0
	ctx.f[13].f64 = -(((ctx.f[5].f64 * ctx.f[4].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C5DD24: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5DD28: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5DD2C: C183000C  lfs f12, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5DD30: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5DD34: C1430004  lfs f10, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5DD38: C1230020  lfs f9, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C5DD3C: C1030010  lfs f8, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C5DD40: C0E3001C  lfs f7, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C5DD44: C0C30024  lfs f6, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C5DD48: C0A30014  lfs f5, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C5DD4C: C0830018  lfs f4, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C5DD50: C0640004  lfs f3, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C5DD54: D083001C  stfs f4, 0x1c(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5DD58: EC470332  fmuls f2, f7, f12
	ctx.f[2].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C5DD5C: C0240004  lfs f1, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5DD60: D1230024  stfs f9, 0x24(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5DD64: EC0412FA  fmadds f0, f4, f11, f2
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[11].f64 + ctx.f[2].f64) as f32) as f64);
	// 82C5DD68: D0230018  stfs f1, 0x18(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5DD6C: EDA302BA  fmadds f13, f3, f10, f0
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C5DD70: ED896A3C  fnmsubs f12, f9, f8, f13
	ctx.f[12].f64 = -(((ctx.f[9].f64 * ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C5DD74: ED66617C  fnmsubs f11, f6, f5, f12
	ctx.f[11].f64 = -(((ctx.f[6].f64 * ctx.f[5].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C5DD78: D1630020  stfs f11, 0x20(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5DD7C: D1650004  stfs f11, 4(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5DD80: C1430008  lfs f10, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5DD84: C1230004  lfs f9, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C5DD88: C103000C  lfs f8, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C5DD8C: C0E30020  lfs f7, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C5DD90: C0C30010  lfs f6, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C5DD94: C0A30018  lfs f5, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C5DD98: C0430024  lfs f2, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5DD9C: C0230014  lfs f1, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5DDA0: C0840008  lfs f4, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C5DDA4: C063001C  lfs f3, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C5DDA8: D0A3001C  stfs f5, 0x1c(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5DDAC: EC0502B2  fmuls f0, f5, f10
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82C5DDB0: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5DDB4: D1A30018  stfs f13, 0x18(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5DDB8: ED84027A  fmadds f12, f4, f9, f0
	ctx.f[12].f64 = (((ctx.f[4].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C5DDBC: D0E30024  stfs f7, 0x24(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5DDC0: ED63623A  fmadds f11, f3, f8, f12
	ctx.f[11].f64 = (((ctx.f[3].f64 * ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64);
	// 82C5DDC4: ED4759BC  fnmsubs f10, f7, f6, f11
	ctx.f[10].f64 = -(((ctx.f[7].f64 * ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C5DDC8: ED22507C  fnmsubs f9, f2, f1, f10
	ctx.f[9].f64 = -(((ctx.f[2].f64 * ctx.f[1].f64 - ctx.f[10].f64) as f32) as f64);
	// 82C5DDCC: D1230020  stfs f9, 0x20(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5DDD0: D1250008  stfs f9, 8(r5)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5DDD4: C023000C  lfs f1, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5DDD8: C0E30008  lfs f7, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C5DDDC: C0A30004  lfs f5, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C5DDE0: C0830010  lfs f4, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C5DDE4: C0630020  lfs f3, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C5DDE8: C043001C  lfs f2, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5DDEC: C1830024  lfs f12, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5DDF0: C1630014  lfs f11, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5DDF4: C1030018  lfs f8, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C5DDF8: C0C4000C  lfs f6, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C5DDFC: D103001C  stfs f8, 0x1c(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5DE00: EC020072  fmuls f0, f2, f1
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C5DE04: EDA801FA  fmadds f13, f8, f7, f0
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C5DE08: C0E4000C  lfs f7, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C5DE0C: ED46697A  fmadds f10, f6, f5, f13
	ctx.f[10].f64 = (((ctx.f[6].f64 * ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64);
	// 82C5DE10: ED23513C  fnmsubs f9, f3, f4, f10
	ctx.f[9].f64 = -(((ctx.f[3].f64 * ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 82C5DE14: ED0C4AFC  fnmsubs f8, f12, f11, f9
	ctx.f[8].f64 = -(((ctx.f[12].f64 * ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C5DE18: D0E30018  stfs f7, 0x18(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5DE1C: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82C5DE20: D0630024  stfs f3, 0x24(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5DE24: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5DE28: D105000C  stfs f8, 0xc(r5)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5DE2C: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 82C5DE30: 4082FEA4  bne 0x82c5dcd4
	if !ctx.cr[0].eq {
	pc = 0x82C5DCD4; continue 'dispatch;
	}
	pc = 0x82C5DE34; continue 'dispatch;
            }
            0x82C5DE34 => {
    //   block [0x82C5DE34..0x82C5DE3C)
	// 82C5DE34: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C5DE38: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C5DE3C; continue 'dispatch;
            }
            0x82C5DE3C => {
    //   block [0x82C5DE3C..0x82C5DEA4)
	// 82C5DE3C: C0030018  lfs f0, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5DE40: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C5DE44: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5DE48: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C5DE4C: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5DE50: C1430004  lfs f10, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5DE54: C123001C  lfs f9, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C5DE58: C103000C  lfs f8, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C5DE5C: C0E30020  lfs f7, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C5DE60: C0C30010  lfs f6, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C5DE64: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5DE68: C0A30024  lfs f5, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C5DE6C: C0830014  lfs f4, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C5DE70: C0240000  lfs f1, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5DE74: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C5DE78: EC6B62BA  fmadds f3, f11, f10, f12
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82C5DE7C: D0230018  stfs f1, 0x18(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5DE80: EC491A3A  fmadds f2, f9, f8, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[8].f64 + ctx.f[3].f64) as f32) as f64);
	// 82C5DE84: D0E30024  stfs f7, 0x24(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5DE88: EC0711BC  fnmsubs f0, f7, f6, f2
	ctx.f[0].f64 = -(((ctx.f[7].f64 * ctx.f[6].f64 - ctx.f[2].f64) as f32) as f64);
	// 82C5DE8C: EDA5013C  fnmsubs f13, f5, f4, f0
	ctx.f[13].f64 = -(((ctx.f[5].f64 * ctx.f[4].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C5DE90: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5DE94: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5DE98: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C5DE9C: 4181FFA0  bgt 0x82c5de3c
	if ctx.cr[0].gt {
	pc = 0x82C5DE3C; continue 'dispatch;
	}
	// 82C5DEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5DEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5DEA8 size=456
    let mut pc: u32 = 0x82C5DEA8;
    'dispatch: loop {
        match pc {
            0x82C5DEA8 => {
    //   block [0x82C5DEA8..0x82C5DF6C)
	// 82C5DEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5DEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5DEB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5DEB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5DEB8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82C5DEBC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82C5DEC0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C5DEC4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5DEC8: EDA30824  fdivs f13, f3, f1
	ctx.f[13].f64 = ((ctx.f[3].f64 / ctx.f[1].f64) as f32) as f64;
	// 82C5DECC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5DED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5DED4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5DED8: C80BD290  lfd f0, -0x2d70(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-11632 as u32) ) };
	// 82C5DEDC: D03F0028  stfs f1, 0x28(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C5DEE0: D05F0030  stfs f2, 0x30(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82C5DEE4: D07F002C  stfs f3, 0x2c(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C5DEE8: D09F0034  stfs f4, 0x34(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82C5DEEC: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 82C5DEF0: FFE06018  frsp f31, f12
	ctx.f[31].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C5DEF4: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82C5DEF8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C5DEFC: 4B5DC095  bl 0x82239f90
	ctx.lr = 0x82C5DF00;
	sub_82239F90(ctx, base);
	// 82C5DF00: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C5DF04: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C5DF08: 4B5DBFA9  bl 0x82239eb0
	ctx.lr = 0x82C5DF0C;
	sub_82239EB0(ctx, base);
	// 82C5DF0C: C17F0034  lfs f11, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5DF10: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5DF14: FD4B07F2  fmul f10, f11, f31
	ctx.f[10].f64 = ctx.f[11].f64 * ctx.f[31].f64;
	// 82C5DF18: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C5DF1C: C80AD288  lfd f0, -0x2d78(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-11640 as u32) ) };
	// 82C5DF20: FD2A0032  fmul f9, f10, f0
	ctx.f[9].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82C5DF24: FC29E824  fdiv f1, f9, f29
	ctx.f[1].f64 = ctx.f[9].f64 / ctx.f[29].f64;
	// 82C5DF28: 4804FE11  bl 0x82cadd38
	ctx.lr = 0x82C5DF2C;
	sub_82CADCEC(ctx, base);
	// 82C5DF2C: FD010772  fmul f8, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = ctx.f[1].f64 * ctx.f[29].f64;
	// 82C5DF30: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5DF34: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 82C5DF38: C0090C14  lfs f0, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5DF3C: FDA04018  frsp f13, f8
	ctx.f[13].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82C5DF40: 41980094  blt cr6, 0x82c5dfd4
	if ctx.cr[6].lt {
	pc = 0x82C5DFD4; continue 'dispatch;
	}
	// 82C5DF44: 419A005C  beq cr6, 0x82c5dfa0
	if ctx.cr[6].eq {
	pc = 0x82C5DFA0; continue 'dispatch;
	}
	// 82C5DF48: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 82C5DF4C: 41980020  blt cr6, 0x82c5df6c
	if ctx.cr[6].lt {
	pc = 0x82C5DF6C; continue 'dispatch;
	}
	// 82C5DF50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5DF54: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5DF58: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5DF5C: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82C5DF60: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5DF64: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5DF68: 480000A8  b 0x82c5e010
	pc = 0x82C5E010; continue 'dispatch;
            }
            0x82C5DF6C => {
    //   block [0x82C5DF6C..0x82C5DFA0)
	// 82C5DF6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5DF70: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C5DF74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5DF78: D15F000C  stfs f10, 0xc(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5DF7C: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82C5DF80: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5DF84: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 82C5DF88: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C5DF8C: C14B0C68  lfs f10, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5DF90: ED3F02B2  fmuls f9, f31, f10
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[10].f64) as f32) as f64);
	// 82C5DF94: C18A0C18  lfs f12, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5DF98: D13F0008  stfs f9, 8(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5DF9C: 48000078  b 0x82c5e014
	pc = 0x82C5E014; continue 'dispatch;
            }
            0x82C5DFA0 => {
    //   block [0x82C5DFA0..0x82C5DFD4)
	// 82C5DFA0: ED80F828  fsubs f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82C5DFA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5DFA8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5DFAC: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82C5DFB0: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C5DFB4: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5DFB8: D15F000C  stfs f10, 0xc(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5DFBC: C1AB0C68  lfs f13, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5DFC0: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5DFC4: ED3F0372  fmuls f9, f31, f13
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C5DFC8: D13F0008  stfs f9, 8(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5DFCC: EDAC02F2  fmuls f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82C5DFD0: 48000040  b 0x82c5e010
	pc = 0x82C5E010; continue 'dispatch;
            }
            0x82C5DFD4 => {
    //   block [0x82C5DFD4..0x82C5E010)
	// 82C5DFD4: ED5F002A  fadds f10, f31, f0
	ctx.f[10].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82C5DFD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5DFDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5DFE0: ED2D002A  fadds f9, f13, f0
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82C5DFE4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5DFE8: ED006828  fsubs f8, f0, f13
	ctx.f[8].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C5DFEC: D13F0004  stfs f9, 4(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5DFF0: D11F000C  stfs f8, 0xc(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5DFF4: C1AB0C68  lfs f13, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5DFF8: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5DFFC: ECFF0372  fmuls f7, f31, f13
	ctx.f[7].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C5E000: C1890EE0  lfs f12, 0xee0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3808 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5E004: D0FF0008  stfs f7, 8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5E008: ED8CF828  fsubs f12, f12, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[31].f64) as f32) as f64);
	// 82C5E00C: EDAA02F2  fmuls f13, f10, f11
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	pc = 0x82C5E010; continue 'dispatch;
            }
            0x82C5E010 => {
    //   block [0x82C5E010..0x82C5E014)
	// 82C5E010: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	pc = 0x82C5E014; continue 'dispatch;
            }
            0x82C5E014 => {
    //   block [0x82C5E014..0x82C5E070)
	// 82C5E014: C15F0004  lfs f10, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5E018: ED205024  fdivs f9, f0, f10
	ctx.f[9].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82C5E01C: C11F0008  lfs f8, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C5E020: C0FF000C  lfs f7, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C5E024: ECC902F2  fmuls f6, f9, f11
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82C5E028: D0DF0004  stfs f6, 4(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5E02C: ECA90332  fmuls f5, f9, f12
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C5E030: D0BF0008  stfs f5, 8(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5E034: EC890372  fmuls f4, f9, f13
	ctx.f[4].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C5E038: D09F000C  stfs f4, 0xc(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5E03C: EC690232  fmuls f3, f9, f8
	ctx.f[3].f64 = (((ctx.f[9].f64 * ctx.f[8].f64) as f32) as f64);
	// 82C5E040: D07F0010  stfs f3, 0x10(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C5E044: EC4901F2  fmuls f2, f9, f7
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[7].f64) as f32) as f64);
	// 82C5E048: D05F0014  stfs f2, 0x14(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C5E04C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5E050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E058: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82C5E05C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C5E060: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C5E064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5E068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E06C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5E070 size=72
    let mut pc: u32 = 0x82C5E070;
    'dispatch: loop {
        match pc {
            0x82C5E070 => {
    //   block [0x82C5E070..0x82C5E0A4)
	// 82C5E070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5E078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5E07C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E084: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5E088: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82C5E08C: 392BD268  addi r9, r11, -0x2d98
	ctx.r[9].s64 = ctx.r[11].s64 + -11672;
	// 82C5E090: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5E094: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5E098: 419A000C  beq cr6, 0x82c5e0a4
	if ctx.cr[6].eq {
	pc = 0x82C5E0A4; continue 'dispatch;
	}
	// 82C5E09C: 4BBE7715  bl 0x828457b0
	ctx.lr = 0x82C5E0A0;
	sub_828457B0(ctx, base);
	// 82C5E0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C5E0A4; continue 'dispatch;
            }
            0x82C5E0A4 => {
    //   block [0x82C5E0A4..0x82C5E0B8)
	// 82C5E0A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E0A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E0AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E0B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E0B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5E0B8 size=260
    let mut pc: u32 = 0x82C5E0B8;
    'dispatch: loop {
        match pc {
            0x82C5E0B8 => {
    //   block [0x82C5E0B8..0x82C5E0D4)
	// 82C5E0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E0BC: 4804B351  bl 0x82ca940c
	ctx.lr = 0x82C5E0C0;
	sub_82CA93D0(ctx, base);
	// 82C5E0C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E0C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5E0C8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C5E0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5E0D0: 409A0014  bne cr6, 0x82c5e0e4
	if !ctx.cr[6].eq {
	pc = 0x82C5E0E4; continue 'dispatch;
	}
	pc = 0x82C5E0D4; continue 'dispatch;
            }
            0x82C5E0D4 => {
    //   block [0x82C5E0D4..0x82C5E0E4)
	// 82C5E0D4: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5E0D8: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5E0DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5E0E0: 4804B37C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5E0E4 => {
    //   block [0x82C5E0E4..0x82C5E10C)
	// 82C5E0E4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C5E0E8: 409AFFEC  bne cr6, 0x82c5e0d4
	if !ctx.cr[6].eq {
	pc = 0x82C5E0D4; continue 'dispatch;
	}
	// 82C5E0EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C5E0F0: 480804C1  bl 0x82cde5b0
	ctx.lr = 0x82C5E0F4;
	sub_82CDE5B0(ctx, base);
	// 82C5E0F4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5E0F8: 40980014  bge cr6, 0x82c5e10c
	if !ctx.cr[6].lt {
	pc = 0x82C5E10C; continue 'dispatch;
	}
	// 82C5E0FC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C5E100: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C5E104: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5E108: 4804B354  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5E10C => {
    //   block [0x82C5E10C..0x82C5E138)
	// 82C5E10C: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5E110: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5E114: 409AFFC0  bne cr6, 0x82c5e0d4
	if !ctx.cr[6].eq {
	pc = 0x82C5E0D4; continue 'dispatch;
	}
	// 82C5E118: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C5E11C: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82C5E120: 4199FFB4  bgt cr6, 0x82c5e0d4
	if ctx.cr[6].gt {
	pc = 0x82C5E0D4; continue 'dispatch;
	}
	// 82C5E124: 897E016C  lbz r11, 0x16c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(364 as u32) ) } as u64;
	// 82C5E128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5E12C: 419A003C  beq cr6, 0x82c5e168
	if ctx.cr[6].eq {
	pc = 0x82C5E168; continue 'dispatch;
	}
	// 82C5E130: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 82C5E134: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	pc = 0x82C5E138; continue 'dispatch;
            }
            0x82C5E138 => {
    //   block [0x82C5E138..0x82C5E168)
	// 82C5E138: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82C5E13C: C09E0168  lfs f4, 0x168(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C5E140: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5E144: C07E0164  lfs f3, 0x164(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C5E148: C05E0160  lfs f2, 0x160(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5E14C: C03E015C  lfs f1, 0x15c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5E150: 4BFFFD59  bl 0x82c5dea8
	ctx.lr = 0x82C5E154;
	sub_82C5DEA8(ctx, base);
	// 82C5E154: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82C5E158: 3BBD0038  addi r29, r29, 0x38
	ctx.r[29].s64 = ctx.r[29].s64 + 56;
	// 82C5E15C: 4082FFDC  bne 0x82c5e138
	if !ctx.cr[0].eq {
	pc = 0x82C5E138; continue 'dispatch;
	}
	// 82C5E160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5E164: 997E016C  stb r11, 0x16c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(364 as u32), ctx.r[11].u8 ) };
	pc = 0x82C5E168; continue 'dispatch;
            }
            0x82C5E168 => {
    //   block [0x82C5E168..0x82C5E180)
	// 82C5E168: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C5E16C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C5E170: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5E174: 419A003C  beq cr6, 0x82c5e1b0
	if ctx.cr[6].eq {
	pc = 0x82C5E1B0; continue 'dispatch;
	}
	// 82C5E178: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C5E17C: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	pc = 0x82C5E180; continue 'dispatch;
            }
            0x82C5E180 => {
    //   block [0x82C5E180..0x82C5E1B0)
	// 82C5E180: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5E184: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 82C5E188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5E18C: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82C5E190: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C5E194: 4BFFFB25  bl 0x82c5dcb8
	ctx.lr = 0x82C5E198;
	sub_82C5DCB8(ctx, base);
	// 82C5E198: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C5E19C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C5E1A0: 3BFF0400  addi r31, r31, 0x400
	ctx.r[31].s64 = ctx.r[31].s64 + 1024;
	// 82C5E1A4: 3BDE0038  addi r30, r30, 0x38
	ctx.r[30].s64 = ctx.r[30].s64 + 56;
	// 82C5E1A8: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C5E1AC: 4198FFD4  blt cr6, 0x82c5e180
	if ctx.cr[6].lt {
	pc = 0x82C5E180; continue 'dispatch;
	}
	pc = 0x82C5E1B0; continue 'dispatch;
            }
            0x82C5E1B0 => {
    //   block [0x82C5E1B0..0x82C5E1BC)
	// 82C5E1B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5E1B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5E1B8: 4804B2A4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C5E1C0 size=632
    let mut pc: u32 = 0x82C5E1C0;
    'dispatch: loop {
        match pc {
            0x82C5E1C0 => {
    //   block [0x82C5E1C0..0x82C5E438)
	// 82C5E1C0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5E1C4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5E1C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5E1CC: 390AD29C  addi r8, r10, -0x2d64
	ctx.r[8].s64 = ctx.r[10].s64 + -11620;
	// 82C5E1D0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C5E1D4: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 82C5E1D8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C5E1DC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C5E1E0: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82C5E1E4: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5E1E8: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5E1EC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C5E1F0: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5E1F4: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82C5E1F8: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5E1FC: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82C5E200: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C5E204: 916300B4  stw r11, 0xb4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82C5E208: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C5E20C: 916300EC  stw r11, 0xec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82C5E210: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82C5E214: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82C5E218: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82C5E21C: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 82C5E220: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82C5E224: 91630124  stw r11, 0x124(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 82C5E228: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82C5E22C: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82C5E230: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C5E234: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C5E238: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5E23C: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82C5E240: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C5E244: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C5E248: D003004C  stfs f0, 0x4c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82C5E24C: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82C5E250: D0030078  stfs f0, 0x78(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82C5E254: D0030070  stfs f0, 0x70(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82C5E258: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82C5E25C: D003006C  stfs f0, 0x6c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82C5E260: D0030068  stfs f0, 0x68(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82C5E264: D0030064  stfs f0, 0x64(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C5E268: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C5E26C: D003005C  stfs f0, 0x5c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82C5E270: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82C5E274: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82C5E278: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82C5E27C: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82C5E280: D0030080  stfs f0, 0x80(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82C5E284: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82C5E288: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82C5E28C: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82C5E290: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82C5E294: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82C5E298: D003009C  stfs f0, 0x9c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82C5E29C: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82C5E2A0: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82C5E2A4: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82C5E2A8: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82C5E2AC: D00300C0  stfs f0, 0xc0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82C5E2B0: D00300BC  stfs f0, 0xbc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82C5E2B4: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82C5E2B8: D00300E8  stfs f0, 0xe8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82C5E2BC: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82C5E2C0: D00300E4  stfs f0, 0xe4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82C5E2C4: D00300DC  stfs f0, 0xdc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82C5E2C8: D00300D8  stfs f0, 0xd8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82C5E2CC: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82C5E2D0: D00300D0  stfs f0, 0xd0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82C5E2D4: D00300CC  stfs f0, 0xcc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82C5E2D8: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82C5E2DC: D00300FC  stfs f0, 0xfc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82C5E2E0: D00300F8  stfs f0, 0xf8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82C5E2E4: D00300F4  stfs f0, 0xf4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82C5E2E8: D00300F0  stfs f0, 0xf0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82C5E2EC: D0030120  stfs f0, 0x120(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82C5E2F0: D0030118  stfs f0, 0x118(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82C5E2F4: D003011C  stfs f0, 0x11c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82C5E2F8: D0030114  stfs f0, 0x114(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82C5E2FC: D0030110  stfs f0, 0x110(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82C5E300: D003010C  stfs f0, 0x10c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82C5E304: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82C5E308: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C5E30C: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82C5E310: 3963007C  addi r11, r3, 0x7c
	ctx.r[11].s64 = ctx.r[3].s64 + 124;
	// 82C5E314: D0030138  stfs f0, 0x138(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82C5E318: 396300B4  addi r11, r3, 0xb4
	ctx.r[11].s64 = ctx.r[3].s64 + 180;
	// 82C5E31C: D0030134  stfs f0, 0x134(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82C5E320: 396300EC  addi r11, r3, 0xec
	ctx.r[11].s64 = ctx.r[3].s64 + 236;
	// 82C5E324: D0030130  stfs f0, 0x130(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82C5E328: 39630124  addi r11, r3, 0x124
	ctx.r[11].s64 = ctx.r[3].s64 + 292;
	// 82C5E32C: D003012C  stfs f0, 0x12c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82C5E330: D0030128  stfs f0, 0x128(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82C5E334: D0030158  stfs f0, 0x158(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 82C5E338: D0030150  stfs f0, 0x150(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82C5E33C: D0030154  stfs f0, 0x154(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82C5E340: D003014C  stfs f0, 0x14c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82C5E344: D0030148  stfs f0, 0x148(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82C5E348: D0030144  stfs f0, 0x144(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82C5E34C: D0030140  stfs f0, 0x140(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82C5E350: D003013C  stfs f0, 0x13c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82C5E354: 9883016C  stb r4, 0x16c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(364 as u32), ctx.r[4].u8 ) };
	// 82C5E358: C1A7D298  lfs f13, -0x2d68(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11624 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5E35C: D1A3015C  stfs f13, 0x15c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 82C5E360: C1A6177C  lfs f13, 0x177c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(6012 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5E364: D1A30164  stfs f13, 0x164(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82C5E368: D0030160  stfs f0, 0x160(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82C5E36C: C1A51544  lfs f13, 0x1544(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(5444 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5E370: D1A30168  stfs f13, 0x168(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82C5E374: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82C5E378: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82C5E37C: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82C5E380: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82C5E384: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82C5E388: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C5E38C: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C5E390: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5E394: D0030078  stfs f0, 0x78(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82C5E398: D0030070  stfs f0, 0x70(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82C5E39C: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82C5E3A0: D003006C  stfs f0, 0x6c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82C5E3A4: D0030068  stfs f0, 0x68(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82C5E3A8: D0030064  stfs f0, 0x64(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C5E3AC: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C5E3B0: D003005C  stfs f0, 0x5c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82C5E3B4: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82C5E3B8: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82C5E3BC: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82C5E3C0: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82C5E3C4: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82C5E3C8: D003009C  stfs f0, 0x9c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82C5E3CC: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82C5E3D0: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82C5E3D4: D00300E8  stfs f0, 0xe8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82C5E3D8: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82C5E3DC: D00300E4  stfs f0, 0xe4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82C5E3E0: D00300DC  stfs f0, 0xdc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82C5E3E4: D00300D8  stfs f0, 0xd8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82C5E3E8: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82C5E3EC: D00300D0  stfs f0, 0xd0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82C5E3F0: D00300CC  stfs f0, 0xcc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82C5E3F4: D0030120  stfs f0, 0x120(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82C5E3F8: D0030118  stfs f0, 0x118(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82C5E3FC: D003011C  stfs f0, 0x11c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82C5E400: D0030114  stfs f0, 0x114(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82C5E404: D0030110  stfs f0, 0x110(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82C5E408: D003010C  stfs f0, 0x10c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82C5E40C: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82C5E410: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82C5E414: D0030158  stfs f0, 0x158(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 82C5E418: D0030150  stfs f0, 0x150(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82C5E41C: D0030154  stfs f0, 0x154(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82C5E420: D003014C  stfs f0, 0x14c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82C5E424: D0030148  stfs f0, 0x148(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82C5E428: D0030144  stfs f0, 0x144(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82C5E42C: D0030140  stfs f0, 0x140(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82C5E430: D003013C  stfs f0, 0x13c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82C5E434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5E438 size=16
    let mut pc: u32 = 0x82C5E438;
    'dispatch: loop {
        match pc {
            0x82C5E438 => {
    //   block [0x82C5E438..0x82C5E448)
	// 82C5E438: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5E43C: 394BD268  addi r10, r11, -0x2d98
	ctx.r[10].s64 = ctx.r[11].s64 + -11672;
	// 82C5E440: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5E444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5E448 size=176
    let mut pc: u32 = 0x82C5E448;
    'dispatch: loop {
        match pc {
            0x82C5E448 => {
    //   block [0x82C5E448..0x82C5E468)
	// 82C5E448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E44C: 4804AFBD  bl 0x82ca9408
	ctx.lr = 0x82C5E450;
	sub_82CA93D0(ctx, base);
	// 82C5E450: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E454: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5E458: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5E45C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C5E460: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C5E464: 409A0014  bne cr6, 0x82c5e478
	if !ctx.cr[6].eq {
	pc = 0x82C5E478; continue 'dispatch;
	}
	pc = 0x82C5E468; continue 'dispatch;
            }
            0x82C5E468 => {
    //   block [0x82C5E468..0x82C5E478)
	// 82C5E468: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82C5E46C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82C5E470: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5E474: 4804AFE4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5E478 => {
    //   block [0x82C5E478..0x82C5E4BC)
	// 82C5E478: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C5E47C: 419AFFEC  beq cr6, 0x82c5e468
	if ctx.cr[6].eq {
	pc = 0x82C5E468; continue 'dispatch;
	}
	// 82C5E480: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C5E484: 419AFFE4  beq cr6, 0x82c5e468
	if ctx.cr[6].eq {
	pc = 0x82C5E468; continue 'dispatch;
	}
	// 82C5E488: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5E48C: 38800170  li r4, 0x170
	ctx.r[4].s64 = 368;
	// 82C5E490: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5E494: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5E498: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5E49C: 4E800421  bctrl
	ctx.lr = 0x82C5E4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5E4A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5E4A4: 419A0018  beq cr6, 0x82c5e4bc
	if ctx.cr[6].eq {
	pc = 0x82C5E4BC; continue 'dispatch;
	}
	// 82C5E4A8: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5E4AC: 4BFFFD15  bl 0x82c5e1c0
	ctx.lr = 0x82C5E4B0;
	sub_82C5E1C0(ctx, base);
	// 82C5E4B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E4B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5E4B8: 409A0014  bne cr6, 0x82c5e4cc
	if !ctx.cr[6].eq {
	pc = 0x82C5E4CC; continue 'dispatch;
	}
            }
            0x82C5E4BC => {
    //   block [0x82C5E4BC..0x82C5E4CC)
	// 82C5E4BC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C5E4C0: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C5E4C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5E4C8: 4804AF90  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C5E4CC => {
    //   block [0x82C5E4CC..0x82C5E4F8)
	// 82C5E4CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5E4D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C5E4D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C5E4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5E4DC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5E4E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5E4E4: 4E800421  bctrl
	ctx.lr = 0x82C5E4E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5E4E8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C5E4EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5E4F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5E4F4: 4804AF64  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5E4F8 size=56
    let mut pc: u32 = 0x82C5E4F8;
    'dispatch: loop {
        match pc {
            0x82C5E4F8 => {
    //   block [0x82C5E4F8..0x82C5E530)
	// 82C5E4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E4FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5E500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5E504: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E508: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C5E50C: 4BC9EF95  bl 0x828fd4a0
	ctx.lr = 0x82C5E510;
	sub_828FD4A0(ctx, base);
	// 82C5E510: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 82C5E514: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5E518: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5E51C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E528: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E52C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5E530 size=128
    let mut pc: u32 = 0x82C5E530;
    'dispatch: loop {
        match pc {
            0x82C5E530 => {
    //   block [0x82C5E530..0x82C5E58C)
	// 82C5E530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E534: 4804AED5  bl 0x82ca9408
	ctx.lr = 0x82C5E538;
	sub_82CA93D0(ctx, base);
	// 82C5E538: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E53C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5E540: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C5E544: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C5E548: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82C5E54C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5E550: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5E554: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5E558: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5E55C: 4E800421  bctrl
	ctx.lr = 0x82C5E560;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5E560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E564: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C5E568: 419A0024  beq cr6, 0x82c5e58c
	if ctx.cr[6].eq {
	pc = 0x82C5E58C; continue 'dispatch;
	}
	// 82C5E56C: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5E570: 480014B9  bl 0x82c5fa28
	ctx.lr = 0x82C5E574;
	sub_82C5FA28(ctx, base);
	// 82C5E574: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5E578: 394BD2C0  addi r10, r11, -0x2d40
	ctx.r[10].s64 = ctx.r[11].s64 + -11584;
	// 82C5E57C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5E580: 480014D1  bl 0x82c5fa50
	ctx.lr = 0x82C5E584;
	sub_82C5FA50(ctx, base);
	// 82C5E584: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C5E588: 48000008  b 0x82c5e590
	pc = 0x82C5E590; continue 'dispatch;
            }
            0x82C5E58C => {
    //   block [0x82C5E58C..0x82C5E590)
	// 82C5E58C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C5E590; continue 'dispatch;
            }
            0x82C5E590 => {
    //   block [0x82C5E590..0x82C5E5B0)
	// 82C5E590: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C5E594: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C5E598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5E59C: 48001365  bl 0x82c5f900
	ctx.lr = 0x82C5E5A0;
	sub_82C5F900(ctx, base);
	// 82C5E5A0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C5E5A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5E5A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5E5AC: 4804AEAC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5E5B0 size=80
    let mut pc: u32 = 0x82C5E5B0;
    'dispatch: loop {
        match pc {
            0x82C5E5B0 => {
    //   block [0x82C5E5B0..0x82C5E600)
	// 82C5E5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5E5B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5E5BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E5C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E5C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5E5C8: 394BD2C0  addi r10, r11, -0x2d40
	ctx.r[10].s64 = ctx.r[11].s64 + -11584;
	// 82C5E5CC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5E5D0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5E5D4: 480014ED  bl 0x82c5fac0
	ctx.lr = 0x82C5E5D8;
	sub_82C5FAC0(ctx, base);
	// 82C5E5D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C5E5DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5E5E0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C5E5E4: 48001395  bl 0x82c5f978
	ctx.lr = 0x82C5E5E8;
	sub_82C5F978(ctx, base);
	// 82C5E5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5E5EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E5F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E5F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E5F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C5E600 size=248
    let mut pc: u32 = 0x82C5E600;
    'dispatch: loop {
        match pc {
            0x82C5E600 => {
    //   block [0x82C5E600..0x82C5E630)
	// 82C5E600: DBE1FFF8  stfd f31, -8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[31].u64 ) };
	// 82C5E604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E608: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5E60C: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 82C5E610: C9AB0DF0  lfd f13, 0xdf0(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3568 as u32) ) };
	// 82C5E614: C80A0E50  lfd f0, 0xe50(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3664 as u32) ) };
	// 82C5E618: 419800A4  blt cr6, 0x82c5e6bc
	if ctx.cr[6].lt {
	pc = 0x82C5E6BC; continue 'dispatch;
	}
	// 82C5E61C: 3965FFFC  addi r11, r5, -4
	ctx.r[11].s64 = ctx.r[5].s64 + -4;
	// 82C5E620: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C5E624: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C5E628: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C5E62C: 7CAA2850  subf r5, r10, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	pc = 0x82C5E630; continue 'dispatch;
            }
            0x82C5E630 => {
    //   block [0x82C5E630..0x82C5E6BC)
	// 82C5E630: C1830000  lfs f12, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5E634: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C5E638: C1230008  lfs f9, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C5E63C: FD4C0332  fmul f10, f12, f12
	ctx.f[10].f64 = ctx.f[12].f64 * ctx.f[12].f64;
	// 82C5E640: C0E3000C  lfs f7, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C5E644: FCC90272  fmul f6, f9, f9
	ctx.f[6].f64 = ctx.f[9].f64 * ctx.f[9].f64;
	// 82C5E648: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5E64C: FCA701F2  fmul f5, f7, f7
	ctx.f[5].f64 = ctx.f[7].f64 * ctx.f[7].f64;
	// 82C5E650: FD0B02F2  fmul f8, f11, f11
	ctx.f[8].f64 = ctx.f[11].f64 * ctx.f[11].f64;
	// 82C5E654: FC8C0372  fmul f4, f12, f13
	ctx.f[4].f64 = ctx.f[12].f64 * ctx.f[13].f64;
	// 82C5E658: FC6B0372  fmul f3, f11, f13
	ctx.f[3].f64 = ctx.f[11].f64 * ctx.f[13].f64;
	// 82C5E65C: FC490372  fmul f2, f9, f13
	ctx.f[2].f64 = ctx.f[9].f64 * ctx.f[13].f64;
	// 82C5E660: FFE70372  fmul f31, f7, f13
	ctx.f[31].f64 = ctx.f[7].f64 * ctx.f[13].f64;
	// 82C5E664: FD8A0332  fmul f12, f10, f12
	ctx.f[12].f64 = ctx.f[10].f64 * ctx.f[12].f64;
	// 82C5E668: FD460272  fmul f10, f6, f9
	ctx.f[10].f64 = ctx.f[6].f64 * ctx.f[9].f64;
	// 82C5E66C: FD2501F2  fmul f9, f5, f7
	ctx.f[9].f64 = ctx.f[5].f64 * ctx.f[7].f64;
	// 82C5E670: FD6802F2  fmul f11, f8, f11
	ctx.f[11].f64 = ctx.f[8].f64 * ctx.f[11].f64;
	// 82C5E674: FD0C2038  fmsub f8, f12, f0, f4
	ctx.f[8].f64 = ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[4].f64;
	// 82C5E678: FCCA1038  fmsub f6, f10, f0, f2
	ctx.f[6].f64 = ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[2].f64;
	// 82C5E67C: FCA9F838  fmsub f5, f9, f0, f31
	ctx.f[5].f64 = ctx.f[9].f64 * ctx.f[0].f64 - ctx.f[31].f64;
	// 82C5E680: FCEB1838  fmsub f7, f11, f0, f3
	ctx.f[7].f64 = ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[3].f64;
	// 82C5E684: FC804018  frsp f4, f8
	ctx.f[4].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82C5E688: FC403018  frsp f2, f6
	ctx.f[2].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82C5E68C: FD802818  frsp f12, f5
	ctx.f[12].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82C5E690: FC603818  frsp f3, f7
	ctx.f[3].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82C5E694: ED640072  fmuls f11, f4, f1
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C5E698: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5E69C: ED220072  fmuls f9, f2, f1
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C5E6A0: D1230008  stfs f9, 8(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5E6A4: ED0C0072  fmuls f8, f12, f1
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C5E6A8: D103000C  stfs f8, 0xc(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5E6AC: ED430072  fmuls f10, f3, f1
	ctx.f[10].f64 = (((ctx.f[3].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C5E6B0: D1430004  stfs f10, 4(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5E6B4: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82C5E6B8: 4082FF78  bne 0x82c5e630
	if !ctx.cr[0].eq {
	pc = 0x82C5E630; continue 'dispatch;
	}
	pc = 0x82C5E6BC; continue 'dispatch;
            }
            0x82C5E6BC => {
    //   block [0x82C5E6BC..0x82C5E6C4)
	// 82C5E6BC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C5E6C0: 40990030  ble cr6, 0x82c5e6f0
	if !ctx.cr[6].gt {
	pc = 0x82C5E6F0; continue 'dispatch;
	}
	pc = 0x82C5E6C4; continue 'dispatch;
            }
            0x82C5E6C4 => {
    //   block [0x82C5E6C4..0x82C5E6F0)
	// 82C5E6C4: C1830000  lfs f12, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5E6C8: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C5E6CC: FD6C0332  fmul f11, f12, f12
	ctx.f[11].f64 = ctx.f[12].f64 * ctx.f[12].f64;
	// 82C5E6D0: FD4C0372  fmul f10, f12, f13
	ctx.f[10].f64 = ctx.f[12].f64 * ctx.f[13].f64;
	// 82C5E6D4: FD2B0332  fmul f9, f11, f12
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82C5E6D8: FD095038  fmsub f8, f9, f0, f10
	ctx.f[8].f64 = ctx.f[9].f64 * ctx.f[0].f64 - ctx.f[10].f64;
	// 82C5E6DC: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82C5E6E0: ECC70072  fmuls f6, f7, f1
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C5E6E4: D0C30000  stfs f6, 0(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5E6E8: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82C5E6EC: 4181FFD8  bgt 0x82c5e6c4
	if ctx.cr[0].gt {
	pc = 0x82C5E6C4; continue 'dispatch;
	}
	pc = 0x82C5E6F0; continue 'dispatch;
            }
            0x82C5E6F0 => {
    //   block [0x82C5E6F0..0x82C5E6F8)
	// 82C5E6F0: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82C5E6F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5E6F8 size=124
    let mut pc: u32 = 0x82C5E6F8;
    'dispatch: loop {
        match pc {
            0x82C5E6F8 => {
    //   block [0x82C5E6F8..0x82C5E738)
	// 82C5E6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E6FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5E700: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5E704: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E708: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E70C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E710: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5E714: D05F000C  stfs f2, 0xc(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5E718: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5E71C: 409A001C  bne cr6, 0x82c5e738
	if !ctx.cr[6].eq {
	pc = 0x82C5E738; continue 'dispatch;
	}
	// 82C5E720: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C5E724: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E72C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E734: 4E800020  blr
	return;
            }
            0x82C5E738 => {
    //   block [0x82C5E738..0x82C5E774)
	// 82C5E738: ED8100B2  fmuls f12, f1, f2
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[2].f64) as f32) as f64);
	// 82C5E73C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E740: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5E744: C80B0DA0  lfd f0, 0xda0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3488 as u32) ) };
	// 82C5E748: C9AA0CB0  lfd f13, 0xcb0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3248 as u32) ) };
	// 82C5E74C: FD6C0032  fmul f11, f12, f0
	ctx.f[11].f64 = ctx.f[12].f64 * ctx.f[0].f64;
	// 82C5E750: FC2D5824  fdiv f1, f13, f11
	ctx.f[1].f64 = ctx.f[13].f64 / ctx.f[11].f64;
	// 82C5E754: 4B59F80D  bl 0x821fdf60
	ctx.lr = 0x82C5E758;
	sub_821FDF60(ctx, base);
	// 82C5E758: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C5E75C: D15F002C  stfs f10, 0x2c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C5E760: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E76C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5E778 size=124
    let mut pc: u32 = 0x82C5E778;
    'dispatch: loop {
        match pc {
            0x82C5E778 => {
    //   block [0x82C5E778..0x82C5E7B8)
	// 82C5E778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E77C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5E780: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5E784: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E788: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E78C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E790: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5E794: D05F0010  stfs f2, 0x10(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C5E798: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5E79C: 409A001C  bne cr6, 0x82c5e7b8
	if !ctx.cr[6].eq {
	pc = 0x82C5E7B8; continue 'dispatch;
	}
	// 82C5E7A0: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82C5E7A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E7A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E7AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E7B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E7B4: 4E800020  blr
	return;
            }
            0x82C5E7B8 => {
    //   block [0x82C5E7B8..0x82C5E7F4)
	// 82C5E7B8: ED8100B2  fmuls f12, f1, f2
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[2].f64) as f32) as f64);
	// 82C5E7BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E7C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5E7C4: C80B0DA0  lfd f0, 0xda0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3488 as u32) ) };
	// 82C5E7C8: C9AA0CB0  lfd f13, 0xcb0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3248 as u32) ) };
	// 82C5E7CC: FD6C0032  fmul f11, f12, f0
	ctx.f[11].f64 = ctx.f[12].f64 * ctx.f[0].f64;
	// 82C5E7D0: FC2D5824  fdiv f1, f13, f11
	ctx.f[1].f64 = ctx.f[13].f64 / ctx.f[11].f64;
	// 82C5E7D4: 4B59F78D  bl 0x821fdf60
	ctx.lr = 0x82C5E7D8;
	sub_821FDF60(ctx, base);
	// 82C5E7D8: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C5E7DC: D15F0030  stfs f10, 0x30(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82C5E7E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E7E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E7E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E7EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E7F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5E7F8 size=124
    let mut pc: u32 = 0x82C5E7F8;
    'dispatch: loop {
        match pc {
            0x82C5E7F8 => {
    //   block [0x82C5E7F8..0x82C5E838)
	// 82C5E7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5E800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5E804: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E808: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E810: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5E814: D05F000C  stfs f2, 0xc(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5E818: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5E81C: 409A001C  bne cr6, 0x82c5e838
	if !ctx.cr[6].eq {
	pc = 0x82C5E838; continue 'dispatch;
	}
	// 82C5E820: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5E824: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E82C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E834: 4E800020  blr
	return;
            }
            0x82C5E838 => {
    //   block [0x82C5E838..0x82C5E874)
	// 82C5E838: ED8100B2  fmuls f12, f1, f2
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[2].f64) as f32) as f64);
	// 82C5E83C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E840: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5E844: C80B0DA0  lfd f0, 0xda0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3488 as u32) ) };
	// 82C5E848: C9AA0CB0  lfd f13, 0xcb0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3248 as u32) ) };
	// 82C5E84C: FD6C0032  fmul f11, f12, f0
	ctx.f[11].f64 = ctx.f[12].f64 * ctx.f[0].f64;
	// 82C5E850: FC2D5824  fdiv f1, f13, f11
	ctx.f[1].f64 = ctx.f[13].f64 / ctx.f[11].f64;
	// 82C5E854: 4B59F70D  bl 0x821fdf60
	ctx.lr = 0x82C5E858;
	sub_821FDF60(ctx, base);
	// 82C5E858: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C5E85C: D15F0024  stfs f10, 0x24(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5E860: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5E878 size=124
    let mut pc: u32 = 0x82C5E878;
    'dispatch: loop {
        match pc {
            0x82C5E878 => {
    //   block [0x82C5E878..0x82C5E8B8)
	// 82C5E878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5E880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5E884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E888: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E88C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E890: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5E894: D05F0010  stfs f2, 0x10(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C5E898: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5E89C: 409A001C  bne cr6, 0x82c5e8b8
	if !ctx.cr[6].eq {
	pc = 0x82C5E8B8; continue 'dispatch;
	}
	// 82C5E8A0: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C5E8A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E8A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E8AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E8B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E8B4: 4E800020  blr
	return;
            }
            0x82C5E8B8 => {
    //   block [0x82C5E8B8..0x82C5E8F4)
	// 82C5E8B8: ED8100B2  fmuls f12, f1, f2
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[2].f64) as f32) as f64);
	// 82C5E8BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E8C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5E8C4: C80B0DA0  lfd f0, 0xda0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3488 as u32) ) };
	// 82C5E8C8: C9AA0CB0  lfd f13, 0xcb0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3248 as u32) ) };
	// 82C5E8CC: FD6C0032  fmul f11, f12, f0
	ctx.f[11].f64 = ctx.f[12].f64 * ctx.f[0].f64;
	// 82C5E8D0: FC2D5824  fdiv f1, f13, f11
	ctx.f[1].f64 = ctx.f[13].f64 / ctx.f[11].f64;
	// 82C5E8D4: 4B59F68D  bl 0x821fdf60
	ctx.lr = 0x82C5E8D8;
	sub_821FDF60(ctx, base);
	// 82C5E8D8: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C5E8DC: D15F0028  stfs f10, 0x28(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C5E8E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E8E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E8E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E8EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E8F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5E8F8 size=76
    let mut pc: u32 = 0x82C5E8F8;
    'dispatch: loop {
        match pc {
            0x82C5E8F8 => {
    //   block [0x82C5E8F8..0x82C5E928)
	// 82C5E8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5E900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5E904: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E90C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5E910: 394BD4C8  addi r10, r11, -0x2b38
	ctx.r[10].s64 = ctx.r[11].s64 + -11064;
	// 82C5E914: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5E918: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5E91C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5E920: 419A0008  beq cr6, 0x82c5e928
	if ctx.cr[6].eq {
	pc = 0x82C5E928; continue 'dispatch;
	}
	// 82C5E924: 4BBE6E8D  bl 0x828457b0
	ctx.lr = 0x82C5E928;
	sub_828457B0(ctx, base);
	pc = 0x82C5E928; continue 'dispatch;
            }
            0x82C5E928 => {
    //   block [0x82C5E928..0x82C5E944)
	// 82C5E928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5E92C: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 82C5E930: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5E934: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5E938: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5E93C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5E940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5E948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5E948 size=276
    let mut pc: u32 = 0x82C5E948;
    'dispatch: loop {
        match pc {
            0x82C5E948 => {
    //   block [0x82C5E948..0x82C5E994)
	// 82C5E948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5E94C: 4804AABD  bl 0x82ca9408
	ctx.lr = 0x82C5E950;
	sub_82CA93D0(ctx, base);
	// 82C5E950: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82C5E954: 4804F381  bl 0x82cadcd4
	ctx.lr = 0x82C5E958;
	sub_82CADCA0(ctx, base);
	// 82C5E958: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5E95C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C5E960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5E964: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5E968: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C5E96C: 409900E0  ble cr6, 0x82c5ea4c
	if !ctx.cr[6].gt {
	pc = 0x82C5EA4C; continue 'dispatch;
	}
	// 82C5E970: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5E974: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5E978: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5E97C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C5E980: 7F842850  subf r28, r4, r5
	ctx.r[28].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82C5E984: C38B0C14  lfs f28, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82C5E988: CBCA0D40  lfd f30, 0xd40(r10)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3392 as u32) ) };
	// 82C5E98C: C3E90AB4  lfs f31, 0xab4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2740 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C5E990: C3A80AC8  lfs f29, 0xac8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2760 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x82C5E994; continue 'dispatch;
            }
            0x82C5E994 => {
    //   block [0x82C5E994..0x82C5E9F8)
	// 82C5E994: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5E998: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82C5E99C: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82C5E9A0: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5E9A4: C17F0020  lfs f11, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5E9A8: C15F001C  lfs f10, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5E9AC: ED2C6AFA  fmadds f9, f12, f11, f13
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82C5E9B0: EF695024  fdivs f27, f9, f10
	ctx.f[27].f64 = ((ctx.f[9].f64 / ctx.f[10].f64) as f32) as f64;
	// 82C5E9B4: D37F0038  stfs f27, 0x38(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82C5E9B8: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82C5E9BC: 4B5529AD  bl 0x821b1368
	ctx.lr = 0x82C5E9C0;
	sub_821B1368(ctx, base);
	// 82C5E9C0: FD000818  frsp f8, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C5E9C4: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5E9C8: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82C5E9CC: EDA80772  fmuls f13, f8, f29
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[29].f64) as f32) as f64);
	// 82C5E9D0: 40990028  ble cr6, 0x82c5e9f8
	if !ctx.cr[6].gt {
	pc = 0x82C5E9F8; continue 'dispatch;
	}
	// 82C5E9D4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C5E9D8: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5E9DC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C5E9E0: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C5E9E4: FD606050  fneg f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C5E9E8: EC4B07F2  fmuls f2, f11, f31
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82C5E9EC: 4B59FABD  bl 0x821fe4a8
	ctx.lr = 0x82C5E9F0;
	sub_821FE4A8(ctx, base);
	// 82C5E9F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C5E9F4: 48000008  b 0x82c5e9fc
	pc = 0x82C5E9FC; continue 'dispatch;
            }
            0x82C5E9F8 => {
    //   block [0x82C5E9F8..0x82C5E9FC)
	// 82C5E9F8: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	pc = 0x82C5E9FC; continue 'dispatch;
            }
            0x82C5E9FC => {
    //   block [0x82C5E9FC..0x82C5EA10)
	// 82C5E9FC: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5EA00: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5EA04: 4099000C  ble cr6, 0x82c5ea10
	if !ctx.cr[6].gt {
	pc = 0x82C5EA10; continue 'dispatch;
	}
	// 82C5EA08: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5EA0C: 48000008  b 0x82c5ea14
	pc = 0x82C5EA14; continue 'dispatch;
            }
            0x82C5EA10 => {
    //   block [0x82C5EA10..0x82C5EA14)
	// 82C5EA10: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82C5EA14; continue 'dispatch;
            }
            0x82C5EA14 => {
    //   block [0x82C5EA14..0x82C5EA40)
	// 82C5EA14: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5EA18: C17F0024  lfs f11, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5EA1C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82C5EA20: 40990020  ble cr6, 0x82c5ea40
	if !ctx.cr[6].gt {
	pc = 0x82C5EA40; continue 'dispatch;
	}
	// 82C5EA24: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5EA28: ED405828  fsubs f10, f0, f11
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C5EA2C: C13F0000  lfs f9, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C5EA30: ED0A5B3A  fmadds f8, f10, f12, f11
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82C5EA34: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C5EA38: ECC70272  fmuls f6, f7, f9
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[9].f64) as f32) as f64);
	// 82C5EA3C: 7CDCF52E  stfsx f6, r28, r30
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	pc = 0x82C5EA40; continue 'dispatch;
            }
            0x82C5EA40 => {
    //   block [0x82C5EA40..0x82C5EA4C)
	// 82C5EA40: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C5EA44: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C5EA48: 4199FF4C  bgt cr6, 0x82c5e994
	if ctx.cr[6].gt {
	pc = 0x82C5E994; continue 'dispatch;
	}
	pc = 0x82C5EA4C; continue 'dispatch;
            }
            0x82C5EA4C => {
    //   block [0x82C5EA4C..0x82C5EA5C)
	// 82C5EA4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C5EA50: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82C5EA54: 4804F2CD  bl 0x82cadd20
	ctx.lr = 0x82C5EA58;
	sub_82CADCEC(ctx, base);
	// 82C5EA58: 4804AA00  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5EA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5EA60 size=132
    let mut pc: u32 = 0x82C5EA60;
    'dispatch: loop {
        match pc {
            0x82C5EA60 => {
    //   block [0x82C5EA60..0x82C5EA98)
	// 82C5EA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5EA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5EA68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5EA6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5EA70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5EA74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5EA78: C00BD4CC  lfs f0, -0x2b34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EA7C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5EA80: 41980018  blt cr6, 0x82c5ea98
	if ctx.cr[6].lt {
	pc = 0x82C5EA98; continue 'dispatch;
	}
	// 82C5EA84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5EA88: C00B0B88  lfs f0, 0xb88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EA8C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5EA90: 41990008  bgt cr6, 0x82c5ea98
	if ctx.cr[6].gt {
	pc = 0x82C5EA98; continue 'dispatch;
	}
	// 82C5EA94: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	pc = 0x82C5EA98; continue 'dispatch;
            }
            0x82C5EA98 => {
    //   block [0x82C5EA98..0x82C5EAB8)
	// 82C5EA98: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C5EA9C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5EAA0: C00B11F4  lfs f0, 0x11f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4596 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EAA4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5EAA8: 40980010  bge cr6, 0x82c5eab8
	if !ctx.cr[6].lt {
	pc = 0x82C5EAB8; continue 'dispatch;
	}
	// 82C5EAAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5EAB0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EAB4: 48000018  b 0x82c5eacc
	pc = 0x82C5EACC; continue 'dispatch;
            }
            0x82C5EAB8 => {
    //   block [0x82C5EAB8..0x82C5EACC)
	// 82C5EAB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5EABC: C80BD4C0  lfd f0, -0x2b40(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-11072 as u32) ) };
	// 82C5EAC0: FC210032  fmul f1, f1, f0
	ctx.f[1].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 82C5EAC4: 4B59F49D  bl 0x821fdf60
	ctx.lr = 0x82C5EAC8;
	sub_821FDF60(ctx, base);
	// 82C5EAC8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82C5EACC; continue 'dispatch;
            }
            0x82C5EACC => {
    //   block [0x82C5EACC..0x82C5EAE4)
	// 82C5EACC: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C5EAD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EAD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EAD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5EAE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5EAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5EAE8 size=132
    let mut pc: u32 = 0x82C5EAE8;
    'dispatch: loop {
        match pc {
            0x82C5EAE8 => {
    //   block [0x82C5EAE8..0x82C5EB20)
	// 82C5EAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5EAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5EAF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5EAF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5EAF8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5EAFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5EB00: C00BD4CC  lfs f0, -0x2b34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EB04: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5EB08: 41980018  blt cr6, 0x82c5eb20
	if ctx.cr[6].lt {
	pc = 0x82C5EB20; continue 'dispatch;
	}
	// 82C5EB0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5EB10: C00B0B88  lfs f0, 0xb88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EB14: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5EB18: 41990008  bgt cr6, 0x82c5eb20
	if ctx.cr[6].gt {
	pc = 0x82C5EB20; continue 'dispatch;
	}
	// 82C5EB1C: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	pc = 0x82C5EB20; continue 'dispatch;
            }
            0x82C5EB20 => {
    //   block [0x82C5EB20..0x82C5EB40)
	// 82C5EB20: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C5EB24: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5EB28: C00B11F4  lfs f0, 0x11f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4596 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EB2C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5EB30: 40980010  bge cr6, 0x82c5eb40
	if !ctx.cr[6].lt {
	pc = 0x82C5EB40; continue 'dispatch;
	}
	// 82C5EB34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5EB38: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EB3C: 48000018  b 0x82c5eb54
	pc = 0x82C5EB54; continue 'dispatch;
            }
            0x82C5EB40 => {
    //   block [0x82C5EB40..0x82C5EB54)
	// 82C5EB40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5EB44: C80BD4C0  lfd f0, -0x2b40(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-11072 as u32) ) };
	// 82C5EB48: FC210032  fmul f1, f1, f0
	ctx.f[1].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 82C5EB4C: 4B59F415  bl 0x821fdf60
	ctx.lr = 0x82C5EB50;
	sub_821FDF60(ctx, base);
	// 82C5EB50: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82C5EB54; continue 'dispatch;
            }
            0x82C5EB54 => {
    //   block [0x82C5EB54..0x82C5EB6C)
	// 82C5EB54: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5EB58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EB5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EB60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EB64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5EB68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5EB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5EB70 size=112
    let mut pc: u32 = 0x82C5EB70;
    'dispatch: loop {
        match pc {
            0x82C5EB70 => {
    //   block [0x82C5EB70..0x82C5EBA8)
	// 82C5EB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5EB74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5EB78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5EB7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5EB80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5EB84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5EB88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5EB8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5EB90: 394BD4C8  addi r10, r11, -0x2b38
	ctx.r[10].s64 = ctx.r[11].s64 + -11064;
	// 82C5EB94: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5EB98: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5EB9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5EBA0: 419A0008  beq cr6, 0x82c5eba8
	if ctx.cr[6].eq {
	pc = 0x82C5EBA8; continue 'dispatch;
	}
	// 82C5EBA4: 4BBE6C0D  bl 0x828457b0
	ctx.lr = 0x82C5EBA8;
	sub_828457B0(ctx, base);
	pc = 0x82C5EBA8; continue 'dispatch;
            }
            0x82C5EBA8 => {
    //   block [0x82C5EBA8..0x82C5EBC8)
	// 82C5EBA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5EBAC: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C5EBB0: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 82C5EBB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5EBB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5EBBC: 419A000C  beq cr6, 0x82c5ebc8
	if ctx.cr[6].eq {
	pc = 0x82C5EBC8; continue 'dispatch;
	}
	// 82C5EBC0: 4BBE6BF1  bl 0x828457b0
	ctx.lr = 0x82C5EBC4;
	sub_828457B0(ctx, base);
	// 82C5EBC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C5EBC8; continue 'dispatch;
            }
            0x82C5EBC8 => {
    //   block [0x82C5EBC8..0x82C5EBE0)
	// 82C5EBC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5EBCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EBD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EBD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5EBD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5EBDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5EBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5EBE0 size=144
    let mut pc: u32 = 0x82C5EBE0;
    'dispatch: loop {
        match pc {
            0x82C5EBE0 => {
    //   block [0x82C5EBE0..0x82C5EC70)
	// 82C5EBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5EBE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5EBE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5EBEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5EBF0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C5EBF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5EBF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5EBFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C5EC00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5EC04: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 82C5EC08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5EC0C: C02B0C18  lfs f1, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5EC10: 4BFFFED9  bl 0x82c5eae8
	ctx.lr = 0x82C5EC14;
	sub_82C5EAE8(ctx, base);
	// 82C5EC14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5EC18: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C5EC1C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5EC20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5EC24: C00A0AA4  lfs f0, 0xaa4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EC28: C0490BE8  lfs f2, 0xbe8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3048 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5EC2C: D05F00C0  stfs f2, 0xc0(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82C5EC30: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82C5EC34: 4BFFFBC5  bl 0x82c5e7f8
	ctx.lr = 0x82C5EC38;
	sub_82C5E7F8(ctx, base);
	// 82C5EC38: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C5EC3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5EC40: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C5EC44: C0480B60  lfs f2, 0xb60(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5EC48: 4BFFFC31  bl 0x82c5e878
	ctx.lr = 0x82C5EC4C;
	sub_82C5E878(ctx, base);
	// 82C5EC4C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82C5EC50: 90FF00B4  stw r7, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[7].u32 ) };
	// 82C5EC54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5EC58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EC5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EC60: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C5EC64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5EC68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5EC6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5EC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5EC70 size=916
    let mut pc: u32 = 0x82C5EC70;
    'dispatch: loop {
        match pc {
            0x82C5EC70 => {
    //   block [0x82C5EC70..0x82C5ECD8)
	// 82C5EC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5EC74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5EC78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5EC7C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C5EC80: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82C5EC84: 2B04000C  cmplwi cr6, r4, 0xc
	ctx.cr[6].compare_u32(ctx.r[4].u32, 12 as u32, &mut ctx.xer);
	// 82C5EC88: 41990368  bgt cr6, 0x82c5eff0
	if ctx.cr[6].gt {
	pc = 0x82C5EFF0; continue 'dispatch;
	}
	// 82C5EC8C: 3D8082C6  lis r12, -0x7d3a
	ctx.r[12].s64 = -2100953088;
	// 82C5EC90: 398CECA4  addi r12, r12, -0x135c
	ctx.r[12].s64 = ctx.r[12].s64 + -4956;
	// 82C5EC94: 5480103A  slwi r0, r4, 2
	ctx.r[0].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82C5EC98: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82C5EC9C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82C5ECA0: 4E800420  bctr
	match ctx.r[4].u64 {
		0 => {
	pc = 0x82C5ECD8; continue 'dispatch;
		},
		1 => {
	pc = 0x82C5ED14; continue 'dispatch;
		},
		2 => {
	pc = 0x82C5ED50; continue 'dispatch;
		},
		3 => {
	pc = 0x82C5ED84; continue 'dispatch;
		},
		4 => {
	pc = 0x82C5EDB8; continue 'dispatch;
		},
		5 => {
	pc = 0x82C5EE14; continue 'dispatch;
		},
		6 => {
	pc = 0x82C5EE70; continue 'dispatch;
		},
		7 => {
	pc = 0x82C5EECC; continue 'dispatch;
		},
		8 => {
	pc = 0x82C5EEEC; continue 'dispatch;
		},
		9 => {
	pc = 0x82C5EF38; continue 'dispatch;
		},
		10 => {
	pc = 0x82C5EF58; continue 'dispatch;
		},
		11 => {
	pc = 0x82C5EF78; continue 'dispatch;
		},
		12 => {
	pc = 0x82C5EFCC; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82C5ECA4: 82C5ECD8  lwz r22, -0x1328(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4904 as u32) ) } as u64;
	// 82C5ECA8: 82C5ED14  lwz r22, -0x12ec(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4844 as u32) ) } as u64;
	// 82C5ECAC: 82C5ED50  lwz r22, -0x12b0(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4784 as u32) ) } as u64;
	// 82C5ECB0: 82C5ED84  lwz r22, -0x127c(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4732 as u32) ) } as u64;
	// 82C5ECB4: 82C5EDB8  lwz r22, -0x1248(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4680 as u32) ) } as u64;
	// 82C5ECB8: 82C5EE14  lwz r22, -0x11ec(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4588 as u32) ) } as u64;
	// 82C5ECBC: 82C5EE70  lwz r22, -0x1190(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4496 as u32) ) } as u64;
	// 82C5ECC0: 82C5EECC  lwz r22, -0x1134(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4404 as u32) ) } as u64;
	// 82C5ECC4: 82C5EEEC  lwz r22, -0x1114(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4372 as u32) ) } as u64;
	// 82C5ECC8: 82C5EF38  lwz r22, -0x10c8(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4296 as u32) ) } as u64;
	// 82C5ECCC: 82C5EF58  lwz r22, -0x10a8(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4264 as u32) ) } as u64;
	// 82C5ECD0: 82C5EF78  lwz r22, -0x1088(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4232 as u32) ) } as u64;
	// 82C5ECD4: 82C5EFCC  lwz r22, -0x1034(r5)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4148 as u32) ) } as u64;
            }
            0x82C5ECD8 => {
    //   block [0x82C5ECD8..0x82C5ECF8)
	// 82C5ECD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5ECDC: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5ECE0: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5ECE4: 41980014  blt cr6, 0x82c5ecf8
	if ctx.cr[6].lt {
	pc = 0x82C5ECF8; continue 'dispatch;
	}
	// 82C5ECE8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5ECEC: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5ECF0: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5ECF4: 40990008  ble cr6, 0x82c5ecfc
	if !ctx.cr[6].gt {
	pc = 0x82C5ECFC; continue 'dispatch;
	}
	pc = 0x82C5ECF8; continue 'dispatch;
            }
            0x82C5ECF8 => {
    //   block [0x82C5ECF8..0x82C5ECFC)
	// 82C5ECF8: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	pc = 0x82C5ECFC; continue 'dispatch;
            }
            0x82C5ECFC => {
    //   block [0x82C5ECFC..0x82C5ED14)
	// 82C5ECFC: D04B0008  stfs f2, 8(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5ED00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5ED04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5ED08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5ED0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5ED10: 4E800020  blr
	return;
            }
            0x82C5ED14 => {
    //   block [0x82C5ED14..0x82C5ED34)
	// 82C5ED14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5ED18: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5ED1C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5ED20: 41980014  blt cr6, 0x82c5ed34
	if ctx.cr[6].lt {
	pc = 0x82C5ED34; continue 'dispatch;
	}
	// 82C5ED24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5ED28: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5ED2C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5ED30: 40990008  ble cr6, 0x82c5ed38
	if !ctx.cr[6].gt {
	pc = 0x82C5ED38; continue 'dispatch;
	}
	pc = 0x82C5ED34; continue 'dispatch;
            }
            0x82C5ED34 => {
    //   block [0x82C5ED34..0x82C5ED38)
	// 82C5ED34: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	pc = 0x82C5ED38; continue 'dispatch;
            }
            0x82C5ED38 => {
    //   block [0x82C5ED38..0x82C5ED50)
	// 82C5ED38: D04B000C  stfs f2, 0xc(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5ED3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5ED40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5ED44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5ED48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5ED4C: 4E800020  blr
	return;
            }
            0x82C5ED50 => {
    //   block [0x82C5ED50..0x82C5ED6C)
	// 82C5ED50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5ED54: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5ED58: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5ED5C: 41980010  blt cr6, 0x82c5ed6c
	if ctx.cr[6].lt {
	pc = 0x82C5ED6C; continue 'dispatch;
	}
	// 82C5ED60: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5ED64: 41990008  bgt cr6, 0x82c5ed6c
	if ctx.cr[6].gt {
	pc = 0x82C5ED6C; continue 'dispatch;
	}
	// 82C5ED68: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	pc = 0x82C5ED6C; continue 'dispatch;
            }
            0x82C5ED6C => {
    //   block [0x82C5ED6C..0x82C5ED84)
	// 82C5ED6C: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5ED70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5ED74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5ED78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5ED7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5ED80: 4E800020  blr
	return;
            }
            0x82C5ED84 => {
    //   block [0x82C5ED84..0x82C5EDA0)
	// 82C5ED84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5ED88: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5ED8C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5ED90: 41980010  blt cr6, 0x82c5eda0
	if ctx.cr[6].lt {
	pc = 0x82C5EDA0; continue 'dispatch;
	}
	// 82C5ED94: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5ED98: 41990008  bgt cr6, 0x82c5eda0
	if ctx.cr[6].gt {
	pc = 0x82C5EDA0; continue 'dispatch;
	}
	// 82C5ED9C: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	pc = 0x82C5EDA0; continue 'dispatch;
            }
            0x82C5EDA0 => {
    //   block [0x82C5EDA0..0x82C5EDB8)
	// 82C5EDA0: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5EDA4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EDA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EDAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EDB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EDB4: 4E800020  blr
	return;
            }
            0x82C5EDB8 => {
    //   block [0x82C5EDB8..0x82C5EDE8)
	// 82C5EDB8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5EDBC: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EDC0: FC800210  fabs f4, f0
	ctx.f[4].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82C5EDC4: C1AB0054  lfs f13, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5EDC8: C00AD300  lfs f0, -0x2d00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EDCC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5EDD0: 41980018  blt cr6, 0x82c5ede8
	if ctx.cr[6].lt {
	pc = 0x82C5EDE8; continue 'dispatch;
	}
	// 82C5EDD4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5EDD8: C00AD304  lfs f0, -0x2cfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EDDC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5EDE0: 41990008  bgt cr6, 0x82c5ede8
	if ctx.cr[6].gt {
	pc = 0x82C5EDE8; continue 'dispatch;
	}
	// 82C5EDE4: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	pc = 0x82C5EDE8; continue 'dispatch;
            }
            0x82C5EDE8 => {
    //   block [0x82C5EDE8..0x82C5EE14)
	// 82C5EDE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5EDEC: C02B0020  lfs f1, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5EDF0: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82C5EDF4: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82C5EDF8: FC406A10  fabs f2, f13
	ctx.f[2].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82C5EDFC: 4BFFF0AD  bl 0x82c5dea8
	ctx.lr = 0x82C5EE00;
	sub_82C5DEA8(ctx, base);
	// 82C5EE00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EE04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EE08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EE0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EE10: 4E800020  blr
	return;
            }
            0x82C5EE14 => {
    //   block [0x82C5EE14..0x82C5EE40)
	// 82C5EE14: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5EE18: C1AB0058  lfs f13, 0x58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5EE1C: FC806A10  fabs f4, f13
	ctx.f[4].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82C5EE20: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EE24: C1AAD300  lfs f13, -0x2d00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5EE28: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5EE2C: 41980014  blt cr6, 0x82c5ee40
	if ctx.cr[6].lt {
	pc = 0x82C5EE40; continue 'dispatch;
	}
	// 82C5EE30: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5EE34: C1AAD304  lfs f13, -0x2cfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5EE38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5EE3C: 40990008  ble cr6, 0x82c5ee44
	if !ctx.cr[6].gt {
	pc = 0x82C5EE44; continue 'dispatch;
	}
	pc = 0x82C5EE40; continue 'dispatch;
            }
            0x82C5EE40 => {
    //   block [0x82C5EE40..0x82C5EE44)
	// 82C5EE40: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82C5EE44; continue 'dispatch;
            }
            0x82C5EE44 => {
    //   block [0x82C5EE44..0x82C5EE70)
	// 82C5EE44: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5EE48: C02B0020  lfs f1, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5EE4C: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82C5EE50: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82C5EE54: FC401210  fabs f2, f2
	ctx.f[2].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 82C5EE58: 4BFFF051  bl 0x82c5dea8
	ctx.lr = 0x82C5EE5C;
	sub_82C5DEA8(ctx, base);
	// 82C5EE5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EE60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EE64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EE68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EE6C: 4E800020  blr
	return;
            }
            0x82C5EE70 => {
    //   block [0x82C5EE70..0x82C5EE9C)
	// 82C5EE70: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5EE74: C00B0050  lfs f0, 0x50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EE78: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5EE7C: FC801210  fabs f4, f2
	ctx.f[4].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 82C5EE80: C1AAD300  lfs f13, -0x2d00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5EE84: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5EE88: 41980014  blt cr6, 0x82c5ee9c
	if ctx.cr[6].lt {
	pc = 0x82C5EE9C; continue 'dispatch;
	}
	// 82C5EE8C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5EE90: C1AAD304  lfs f13, -0x2cfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5EE94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5EE98: 40990008  ble cr6, 0x82c5eea0
	if !ctx.cr[6].gt {
	pc = 0x82C5EEA0; continue 'dispatch;
	}
	pc = 0x82C5EE9C; continue 'dispatch;
            }
            0x82C5EE9C => {
    //   block [0x82C5EE9C..0x82C5EEA0)
	// 82C5EE9C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82C5EEA0; continue 'dispatch;
            }
            0x82C5EEA0 => {
    //   block [0x82C5EEA0..0x82C5EECC)
	// 82C5EEA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5EEA4: C02B0020  lfs f1, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5EEA8: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82C5EEAC: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82C5EEB0: FC406210  fabs f2, f12
	ctx.f[2].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 82C5EEB4: 4BFFEFF5  bl 0x82c5dea8
	ctx.lr = 0x82C5EEB8;
	sub_82C5DEA8(ctx, base);
	// 82C5EEB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EEBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EEC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EEC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EEC8: 4E800020  blr
	return;
            }
            0x82C5EECC => {
    //   block [0x82C5EECC..0x82C5EEEC)
	// 82C5EECC: 386B005C  addi r3, r11, 0x5c
	ctx.r[3].s64 = ctx.r[11].s64 + 92;
	// 82C5EED0: FC201090  fmr f1, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82C5EED4: 4BFFFB8D  bl 0x82c5ea60
	ctx.lr = 0x82C5EED8;
	sub_82C5EA60(ctx, base);
	// 82C5EED8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EEDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EEE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EEE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EEE8: 4E800020  blr
	return;
            }
            0x82C5EEEC => {
    //   block [0x82C5EEEC..0x82C5EF0C)
	// 82C5EEEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5EEF0: C00A0BF8  lfs f0, 0xbf8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EEF4: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5EEF8: 41980014  blt cr6, 0x82c5ef0c
	if ctx.cr[6].lt {
	pc = 0x82C5EF0C; continue 'dispatch;
	}
	// 82C5EEFC: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82C5EF00: C00A9404  lfs f0, -0x6bfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EF04: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82C5EF08: 40990008  ble cr6, 0x82c5ef10
	if !ctx.cr[6].gt {
	pc = 0x82C5EF10; continue 'dispatch;
	}
	pc = 0x82C5EF0C; continue 'dispatch;
            }
            0x82C5EF0C => {
    //   block [0x82C5EF0C..0x82C5EF10)
	// 82C5EF0C: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	pc = 0x82C5EF10; continue 'dispatch;
            }
            0x82C5EF10 => {
    //   block [0x82C5EF10..0x82C5EF38)
	// 82C5EF10: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5EF14: D04B0064  stfs f2, 0x64(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C5EF18: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EF1C: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5EF20: EC001024  fdivs f0, f0, f2
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[2].f64) as f32) as f64;
	// 82C5EF24: D00B0084  stfs f0, 0x84(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82C5EF28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EF2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EF30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EF34: 4E800020  blr
	return;
            }
            0x82C5EF38 => {
    //   block [0x82C5EF38..0x82C5EF58)
	// 82C5EF38: 386B005C  addi r3, r11, 0x5c
	ctx.r[3].s64 = ctx.r[11].s64 + 92;
	// 82C5EF3C: C02B0020  lfs f1, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5EF40: 4BFFF7B9  bl 0x82c5e6f8
	ctx.lr = 0x82C5EF44;
	sub_82C5E6F8(ctx, base);
	// 82C5EF44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EF48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EF4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EF50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EF54: 4E800020  blr
	return;
            }
            0x82C5EF58 => {
    //   block [0x82C5EF58..0x82C5EF78)
	// 82C5EF58: 386B005C  addi r3, r11, 0x5c
	ctx.r[3].s64 = ctx.r[11].s64 + 92;
	// 82C5EF5C: C02B0020  lfs f1, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5EF60: 4BFFF819  bl 0x82c5e778
	ctx.lr = 0x82C5EF64;
	sub_82C5E778(ctx, base);
	// 82C5EF64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EF68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EF6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EF70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EF74: 4E800020  blr
	return;
            }
            0x82C5EF78 => {
    //   block [0x82C5EF78..0x82C5EFA8)
	// 82C5EF78: FC00101E  fctiwz f0, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[2].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[2].f64.trunc() as i32 as i64 };
	// 82C5EF7C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82C5EF80: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5EF84: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82C5EF88: 40980020  bge cr6, 0x82c5efa8
	if !ctx.cr[6].lt {
	pc = 0x82C5EFA8; continue 'dispatch;
	}
	// 82C5EF8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C5EF90: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EF94: 914B0070  stw r10, 0x70(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82C5EF98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EF9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EFA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EFA4: 4E800020  blr
	return;
            }
            0x82C5EFA8 => {
    //   block [0x82C5EFA8..0x82C5EFB4)
	// 82C5EFA8: 2F0A07D0  cmpwi cr6, r10, 0x7d0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2000, &mut ctx.xer);
	// 82C5EFAC: 40990008  ble cr6, 0x82c5efb4
	if !ctx.cr[6].gt {
	pc = 0x82C5EFB4; continue 'dispatch;
	}
	// 82C5EFB0: 394007D0  li r10, 0x7d0
	ctx.r[10].s64 = 2000;
	pc = 0x82C5EFB4; continue 'dispatch;
            }
            0x82C5EFB4 => {
    //   block [0x82C5EFB4..0x82C5EFCC)
	// 82C5EFB4: 914B0070  stw r10, 0x70(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82C5EFB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EFBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EFC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EFC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EFC8: 4E800020  blr
	return;
            }
            0x82C5EFCC => {
    //   block [0x82C5EFCC..0x82C5EFF0)
	// 82C5EFCC: FC001210  fabs f0, f2
	ctx.f[0].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 82C5EFD0: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82C5EFD4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5EFD8: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82C5EFDC: 7DAB57AE  stfiwx f13, r11, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C5EFE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EFE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EFE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5EFEC: 4E800020  blr
	return;
            }
            0x82C5EFF0 => {
    //   block [0x82C5EFF0..0x82C5F004)
	// 82C5EFF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5EFF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5EFF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5EFFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F008 size=980
    let mut pc: u32 = 0x82C5F008;
    'dispatch: loop {
        match pc {
            0x82C5F008 => {
    //   block [0x82C5F008..0x82C5F04C)
	// 82C5F008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F00C: 4804A3F9  bl 0x82ca9404
	ctx.lr = 0x82C5F010;
	sub_82CA93D0(ctx, base);
	// 82C5F010: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82C5F014: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5F01C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5F020: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C5F024: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C5F028: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F02C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5F030: 419A001C  beq cr6, 0x82c5f04c
	if ctx.cr[6].eq {
	pc = 0x82C5F04C; continue 'dispatch;
	}
	// 82C5F034: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82C5F038: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82C5F03C: 40980034  bge cr6, 0x82c5f070
	if !ctx.cr[6].lt {
	pc = 0x82C5F070; continue 'dispatch;
	}
	// 82C5F040: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5F044: 419A0008  beq cr6, 0x82c5f04c
	if ctx.cr[6].eq {
	pc = 0x82C5F04C; continue 'dispatch;
	}
	// 82C5F048: 4BBE6769  bl 0x828457b0
	ctx.lr = 0x82C5F04C;
	sub_828457B0(ctx, base);
	pc = 0x82C5F04C; continue 'dispatch;
            }
            0x82C5F04C => {
    //   block [0x82C5F04C..0x82C5F064)
	// 82C5F04C: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82C5F050: 57C3103A  slwi r3, r30, 2
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5F054: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 82C5F058: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5F05C: 40990008  ble cr6, 0x82c5f064
	if !ctx.cr[6].gt {
	pc = 0x82C5F064; continue 'dispatch;
	}
	// 82C5F060: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82C5F064; continue 'dispatch;
            }
            0x82C5F064 => {
    //   block [0x82C5F064..0x82C5F070)
	// 82C5F064: 4B5C01F5  bl 0x8221f258
	ctx.lr = 0x82C5F068;
	sub_8221F258(ctx, base);
	// 82C5F068: 907F01D0  stw r3, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[3].u32 ) };
	// 82C5F06C: 93DF01D4  stw r30, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[30].u32 ) };
	pc = 0x82C5F070; continue 'dispatch;
            }
            0x82C5F070 => {
    //   block [0x82C5F070..0x82C5F100)
	// 82C5F070: 57DB103A  slwi r27, r30, 2
	ctx.r[27].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82C5F074: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F078: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C5F07C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C5F080: 4804A401  bl 0x82ca9480
	ctx.lr = 0x82C5F084;
	sub_82CA9480(ctx, base);
	// 82C5F084: 809F01D0  lwz r4, 0x1d0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F088: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C5F08C: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 82C5F090: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82C5F094: 4BFFEC25  bl 0x82c5dcb8
	ctx.lr = 0x82C5F098;
	sub_82C5DCB8(ctx, base);
	// 82C5F098: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C5F09C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C5F0A0: 809F01D0  lwz r4, 0x1d0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F0A4: 4804A3DD  bl 0x82ca9480
	ctx.lr = 0x82C5F0A8;
	sub_82CA9480(ctx, base);
	// 82C5F0A8: 809F01D0  lwz r4, 0x1d0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F0AC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C5F0B0: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 82C5F0B4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82C5F0B8: 4BFFF891  bl 0x82c5e948
	ctx.lr = 0x82C5F0BC;
	sub_82C5E948(ctx, base);
	// 82C5F0BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F0C0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5F0C4: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82C5F0C8: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C5F0CC: 409A0208  bne cr6, 0x82c5f2d4
	if !ctx.cr[6].eq {
	pc = 0x82C5F2D4; continue 'dispatch;
	}
	// 82C5F0D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82C5F0D4: 813F01D0  lwz r9, 0x1d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F0D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C5F0DC: 616A2083  ori r10, r11, 0x2083
	ctx.r[10].u64 = ctx.r[11].u64 | 8323;
	// 82C5F0E0: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82C5F0E4: 4198011C  blt cr6, 0x82c5f200
	if ctx.cr[6].lt {
	pc = 0x82C5F200; continue 'dispatch;
	}
	// 82C5F0E8: 391EFFFC  addi r8, r30, -4
	ctx.r[8].s64 = ctx.r[30].s64 + -4;
	// 82C5F0EC: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 82C5F0F0: 5508F0BE  srwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C5F0F4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82C5F0F8: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C5F0FC: 7CA7F050  subf r5, r7, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[7].s64;
	pc = 0x82C5F100; continue 'dispatch;
            }
            0x82C5F100 => {
    //   block [0x82C5F100..0x82C5F200)
	// 82C5F100: 80EB00FC  lwz r7, 0xfc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F104: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F108: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F10C: 7C065D2E  stfsx f0, r6, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C5F110: 80EB00FC  lwz r7, 0xfc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F114: 38870001  addi r4, r7, 1
	ctx.r[4].s64 = ctx.r[7].s64 + 1;
	// 82C5F118: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82C5F11C: 7CC75096  mulhw r6, r7, r10
	ctx.r[6].s64 = ((ctx.r[7].s32 as i64 * ctx.r[10].s32 as i64) >> 32);
	// 82C5F120: 7C663A14  add r3, r6, r7
	ctx.r[3].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82C5F124: 7C672E70  srawi r7, r3, 5
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> 5) as i64;
	// 82C5F128: 54E60FFE  srwi r6, r7, 0x1f
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(31);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F12C: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 82C5F130: 54E63032  slwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F134: 7C673050  subf r3, r7, r6
	ctx.r[3].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 82C5F138: 7CE32050  subf r7, r3, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C5F13C: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F140: 90EB00FC  stw r7, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[7].u32 ) };
	// 82C5F144: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5F148: 7DA65D2E  stfsx f13, r6, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C5F14C: 80EB00FC  lwz r7, 0xfc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F150: 38870001  addi r4, r7, 1
	ctx.r[4].s64 = ctx.r[7].s64 + 1;
	// 82C5F154: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82C5F158: 7CC75096  mulhw r6, r7, r10
	ctx.r[6].s64 = ((ctx.r[7].s32 as i64 * ctx.r[10].s32 as i64) >> 32);
	// 82C5F15C: 7C663A14  add r3, r6, r7
	ctx.r[3].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82C5F160: 7C672E70  srawi r7, r3, 5
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> 5) as i64;
	// 82C5F164: 54E60FFE  srwi r6, r7, 0x1f
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(31);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F168: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 82C5F16C: 54E63032  slwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F170: 7C673050  subf r3, r7, r6
	ctx.r[3].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 82C5F174: 7CE32050  subf r7, r3, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C5F178: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F17C: 90EB00FC  stw r7, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[7].u32 ) };
	// 82C5F180: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5F184: 7D865D2E  stfsx f12, r6, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C5F188: 80EB00FC  lwz r7, 0xfc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F18C: 38870001  addi r4, r7, 1
	ctx.r[4].s64 = ctx.r[7].s64 + 1;
	// 82C5F190: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82C5F194: 7CC75096  mulhw r6, r7, r10
	ctx.r[6].s64 = ((ctx.r[7].s32 as i64 * ctx.r[10].s32 as i64) >> 32);
	// 82C5F198: 7C663A14  add r3, r6, r7
	ctx.r[3].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82C5F19C: 7C672E70  srawi r7, r3, 5
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> 5) as i64;
	// 82C5F1A0: 54E60FFE  srwi r6, r7, 0x1f
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(31);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F1A4: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 82C5F1A8: 54E63032  slwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F1AC: 7C673050  subf r3, r7, r6
	ctx.r[3].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 82C5F1B0: 7CE32050  subf r7, r3, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C5F1B4: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F1B8: 90EB00FC  stw r7, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[7].u32 ) };
	// 82C5F1BC: C169000C  lfs f11, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5F1C0: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 82C5F1C4: 7D665D2E  stfsx f11, r6, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C5F1C8: 80EB00FC  lwz r7, 0xfc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F1CC: 38870001  addi r4, r7, 1
	ctx.r[4].s64 = ctx.r[7].s64 + 1;
	// 82C5F1D0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82C5F1D4: 7CC75096  mulhw r6, r7, r10
	ctx.r[6].s64 = ((ctx.r[7].s32 as i64 * ctx.r[10].s32 as i64) >> 32);
	// 82C5F1D8: 7C663A14  add r3, r6, r7
	ctx.r[3].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82C5F1DC: 7C672E70  srawi r7, r3, 5
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> 5) as i64;
	// 82C5F1E0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C5F1E4: 54E60FFE  srwi r6, r7, 0x1f
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(31);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F1E8: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 82C5F1EC: 54E63032  slwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F1F0: 7C673050  subf r3, r7, r6
	ctx.r[3].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 82C5F1F4: 7CE32050  subf r7, r3, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C5F1F8: 90EB00FC  stw r7, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[7].u32 ) };
	// 82C5F1FC: 4082FF04  bne 0x82c5f100
	if !ctx.cr[0].eq {
	pc = 0x82C5F100; continue 'dispatch;
	}
	pc = 0x82C5F200; continue 'dispatch;
            }
            0x82C5F200 => {
    //   block [0x82C5F200..0x82C5F20C)
	// 82C5F200: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C5F204: 40990054  ble cr6, 0x82c5f258
	if !ctx.cr[6].gt {
	pc = 0x82C5F258; continue 'dispatch;
	}
	// 82C5F208: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	pc = 0x82C5F20C; continue 'dispatch;
            }
            0x82C5F20C => {
    //   block [0x82C5F20C..0x82C5F258)
	// 82C5F20C: 810B00FC  lwz r8, 0xfc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F210: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F214: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C5F218: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C5F21C: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C5F220: 810B00FC  lwz r8, 0xfc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F224: 38C80001  addi r6, r8, 1
	ctx.r[6].s64 = ctx.r[8].s64 + 1;
	// 82C5F228: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82C5F22C: 7CE85096  mulhw r7, r8, r10
	ctx.r[7].s64 = ((ctx.r[8].s32 as i64 * ctx.r[10].s32 as i64) >> 32);
	// 82C5F230: 7C874214  add r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82C5F234: 7C882E70  srawi r8, r4, 5
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[4].s32 >> 5) as i64;
	// 82C5F238: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C5F23C: 55070FFE  srwi r7, r8, 0x1f
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(31);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C5F240: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82C5F244: 55033032  slwi r3, r8, 6
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(6);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5F248: 7D081850  subf r8, r8, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82C5F24C: 7CE83050  subf r7, r8, r6
	ctx.r[7].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 82C5F250: 90EB00FC  stw r7, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[7].u32 ) };
	// 82C5F254: 4181FFB8  bgt 0x82c5f20c
	if ctx.cr[0].gt {
	pc = 0x82C5F20C; continue 'dispatch;
	}
	pc = 0x82C5F258; continue 'dispatch;
            }
            0x82C5F258 => {
    //   block [0x82C5F258..0x82C5F284)
	// 82C5F258: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C5F25C: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F260: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C5F264: 4BFFF39D  bl 0x82c5e600
	ctx.lr = 0x82C5F268;
	sub_82C5E600(ctx, base);
	// 82C5F268: 813F01D0  lwz r9, 0x1d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F26C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82C5F270: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82C5F274: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C5F278: 40990158  ble cr6, 0x82c5f3d0
	if !ctx.cr[6].gt {
	pc = 0x82C5F3D0; continue 'dispatch;
	}
	// 82C5F27C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C5F280: C1A80C18  lfs f13, 0xc18(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82C5F284; continue 'dispatch;
            }
            0x82C5F284 => {
    //   block [0x82C5F284..0x82C5F2BC)
	// 82C5F284: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F288: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82C5F28C: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5F290: FD600210  fabs f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82C5F294: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5F298: ED2C02B2  fmuls f9, f12, f10
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82C5F29C: C1090000  lfs f8, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C5F2A0: EC0B4A3A  fmadds f0, f11, f8, f9
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[8].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C5F2A4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5F2A8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F2AC: 55070050  rlwinm r7, r8, 0, 1, 8
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82C5F2B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C5F2B4: 409A0008  bne cr6, 0x82c5f2bc
	if !ctx.cr[6].eq {
	pc = 0x82C5F2BC; continue 'dispatch;
	}
	// 82C5F2B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82C5F2BC; continue 'dispatch;
            }
            0x82C5F2BC => {
    //   block [0x82C5F2BC..0x82C5F2D4)
	// 82C5F2BC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5F2C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C5F2C4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C5F2C8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C5F2CC: 4199FFB8  bgt cr6, 0x82c5f284
	if ctx.cr[6].gt {
	pc = 0x82C5F284; continue 'dispatch;
	}
	// 82C5F2D0: 480000B8  b 0x82c5f388
	pc = 0x82C5F388; continue 'dispatch;
            }
            0x82C5F2D4 => {
    //   block [0x82C5F2D4..0x82C5F2FC)
	// 82C5F2D4: 80BF01D0  lwz r5, 0x1d0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82C5F2D8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82C5F2DC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82C5F2E0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C5F2E4: 409900EC  ble cr6, 0x82c5f3d0
	if !ctx.cr[6].gt {
	pc = 0x82C5F3D0; continue 'dispatch;
	}
	// 82C5F2E8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C5F2EC: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 82C5F2F0: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 82C5F2F4: 60CA2083  ori r10, r6, 0x2083
	ctx.r[10].u64 = ctx.r[6].u64 | 8323;
	// 82C5F2F8: C1A80C18  lfs f13, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82C5F2FC; continue 'dispatch;
            }
            0x82C5F2FC => {
    //   block [0x82C5F2FC..0x82C5F374)
	// 82C5F2FC: 810B00FC  lwz r8, 0xfc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F300: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F304: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82C5F308: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C5F30C: 7D885C2E  lfsx f12, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5F310: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C5F314: 810B00FC  lwz r8, 0xfc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 82C5F318: 38880001  addi r4, r8, 1
	ctx.r[4].s64 = ctx.r[8].s64 + 1;
	// 82C5F31C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82C5F320: 7CC85096  mulhw r6, r8, r10
	ctx.r[6].s64 = ((ctx.r[8].s32 as i64 * ctx.r[10].s32 as i64) >> 32);
	// 82C5F324: 7C664214  add r3, r6, r8
	ctx.r[3].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82C5F328: 7C682E70  srawi r8, r3, 5
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[3].s32 >> 5) as i64;
	// 82C5F32C: 55060FFE  srwi r6, r8, 0x1f
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shr(31);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F330: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82C5F334: 55063032  slwi r6, r8, 6
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C5F338: 7C683050  subf r3, r8, r6
	ctx.r[3].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 82C5F33C: 7D032050  subf r8, r3, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C5F340: 910B00FC  stw r8, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[8].u32 ) };
	// 82C5F344: C1490000  lfs f10, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C5F348: C13F000C  lfs f9, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C5F34C: C17F0008  lfs f11, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5F350: FCE05A10  fabs f7, f11
	ctx.f[7].u64 = ctx.f[11].u64 & !0x8000_0000_0000_0000u64;
	// 82C5F354: ED0902B2  fmuls f8, f9, f10
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82C5F358: EC07433A  fmadds f0, f7, f12, f8
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64);
	// 82C5F35C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5F360: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F364: 54C40050  rlwinm r4, r6, 0, 1, 8
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82C5F368: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C5F36C: 409A0008  bne cr6, 0x82c5f374
	if !ctx.cr[6].eq {
	pc = 0x82C5F374; continue 'dispatch;
	}
	// 82C5F370: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82C5F374; continue 'dispatch;
            }
            0x82C5F374 => {
    //   block [0x82C5F374..0x82C5F388)
	// 82C5F374: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5F378: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C5F37C: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C5F380: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C5F384: 4199FF78  bgt cr6, 0x82c5f2fc
	if ctx.cr[6].gt {
	pc = 0x82C5F2FC; continue 'dispatch;
	}
	pc = 0x82C5F388; continue 'dispatch;
            }
            0x82C5F388 => {
    //   block [0x82C5F388..0x82C5F390)
	// 82C5F388: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F38C: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82C5F390; continue 'dispatch;
            }
            0x82C5F390 => {
    //   block [0x82C5F390..0x82C5F3B0)
	// 82C5F390: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F394: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 82C5F398: C19D0000  lfs f12, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5F39C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C5F3A0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C5F3A4: 4098000C  bge cr6, 0x82c5f3b0
	if !ctx.cr[6].lt {
	pc = 0x82C5F3B0; continue 'dispatch;
	}
	// 82C5F3A8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82C5F3AC: 48000010  b 0x82c5f3bc
	pc = 0x82C5F3BC; continue 'dispatch;
            }
            0x82C5F3B0 => {
    //   block [0x82C5F3B0..0x82C5F3BC)
	// 82C5F3B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82C5F3B4: 40990008  ble cr6, 0x82c5f3bc
	if !ctx.cr[6].gt {
	pc = 0x82C5F3BC; continue 'dispatch;
	}
	// 82C5F3B8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82C5F3BC; continue 'dispatch;
            }
            0x82C5F3BC => {
    //   block [0x82C5F3BC..0x82C5F3D0)
	// 82C5F3BC: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5F3C0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82C5F3C4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82C5F3C8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C5F3CC: 4199FFC4  bgt cr6, 0x82c5f390
	if ctx.cr[6].gt {
	pc = 0x82C5F390; continue 'dispatch;
	}
	pc = 0x82C5F3D0; continue 'dispatch;
            }
            0x82C5F3D0 => {
    //   block [0x82C5F3D0..0x82C5F3DC)
	// 82C5F3D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5F3D4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82C5F3D8: 4804A07C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F3E0 size=76
    let mut pc: u32 = 0x82C5F3E0;
    'dispatch: loop {
        match pc {
            0x82C5F3E0 => {
    //   block [0x82C5F3E0..0x82C5F404)
	// 82C5F3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F3E4: 4804A029  bl 0x82ca940c
	ctx.lr = 0x82C5F3E8;
	sub_82CA93D0(ctx, base);
	// 82C5F3E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F3EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5F3F0: 1D440034  mulli r10, r4, 0x34
	ctx.r[10].s32 = ((ctx.r[4].s32 as i64 * 52 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82C5F3F4: 396BD320  addi r11, r11, -0x2ce0
	ctx.r[11].s64 = ctx.r[11].s64 + -11488;
	// 82C5F3F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C5F3FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C5F400: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x82C5F404; continue 'dispatch;
            }
            0x82C5F404 => {
    //   block [0x82C5F404..0x82C5F42C)
	// 82C5F404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C5F408: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5F40C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5F410: 4BFFF861  bl 0x82c5ec70
	ctx.lr = 0x82C5F414;
	sub_82C5EC70(ctx, base);
	// 82C5F414: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82C5F418: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C5F41C: 2F1F000D  cmpwi cr6, r31, 0xd
	ctx.cr[6].compare_i32(ctx.r[31].s32, 13, &mut ctx.xer);
	// 82C5F420: 4198FFE4  blt cr6, 0x82c5f404
	if ctx.cr[6].lt {
	pc = 0x82C5F404; continue 'dispatch;
	}
	// 82C5F424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5F428: 4804A034  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F430 size=216
    let mut pc: u32 = 0x82C5F430;
    'dispatch: loop {
        match pc {
            0x82C5F430 => {
    //   block [0x82C5F430..0x82C5F508)
	// 82C5F430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F438: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5F43C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82C5F440: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C5F444: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F448: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F44C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5F450: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5F454: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C5F458: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C5F45C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5F460: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F464: 38C003E8  li r6, 0x3e8
	ctx.r[6].s64 = 1000;
	// 82C5F468: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5F46C: C3E90C18  lfs f31, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C5F470: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 82C5F474: C1880A98  lfs f12, 0xa98(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5F478: C167D4D8  lfs f11, -0x2b28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11048 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5F47C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5F480: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82C5F484: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5F488: D3FF0034  stfs f31, 0x34(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82C5F48C: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5F490: D17F0028  stfs f11, 0x28(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C5F494: C0250FE0  lfs f1, 0xfe0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5F498: 4BFFF5C9  bl 0x82c5ea60
	ctx.lr = 0x82C5F49C;
	sub_82C5EA60(ctx, base);
	// 82C5F49C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F4A0: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82C5F4A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F4A8: C3CB0C10  lfs f30, 0xc10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3088 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C5F4AC: C0440C4C  lfs f2, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5F4B0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C5F4B4: 4BFFF245  bl 0x82c5e6f8
	ctx.lr = 0x82C5F4B8;
	sub_82C5E6F8(ctx, base);
	// 82C5F4B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5F4BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F4C0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C5F4C4: C04A0A4C  lfs f2, 0xa4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2636 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5F4C8: 4BFFF2B1  bl 0x82c5e778
	ctx.lr = 0x82C5F4CC;
	sub_82C5E778(ctx, base);
	// 82C5F4CC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C5F4D0: D3FF003C  stfs f31, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82C5F4D4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C5F4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F4DC: C009D4D4  lfs f0, -0x2b2c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F4E0: C1A8D4D0  lfs f13, -0x2b30(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5F4E4: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C5F4E8: D1BF0020  stfs f13, 0x20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5F4EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5F4F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F4F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F4F8: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C5F4FC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5F500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F508 size=172
    let mut pc: u32 = 0x82C5F508;
    'dispatch: loop {
        match pc {
            0x82C5F508 => {
    //   block [0x82C5F508..0x82C5F5B4)
	// 82C5F508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F510: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5F514: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C5F518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F51C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F520: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C5F524: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5F528: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C5F52C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C5F530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5F534: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F538: 38C003E8  li r6, 0x3e8
	ctx.r[6].s64 = 1000;
	// 82C5F53C: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5F540: C0290C18  lfs f1, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5F544: C188D4E0  lfs f12, -0x2b20(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11040 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C5F548: C167D4DC  lfs f11, -0x2b24(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C5F54C: D03F002C  stfs f1, 0x2c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C5F550: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82C5F554: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5F558: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5F55C: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5F560: D17F0020  stfs f11, 0x20(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5F564: 4BFFF585  bl 0x82c5eae8
	ctx.lr = 0x82C5F568;
	sub_82C5EAE8(ctx, base);
	// 82C5F568: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82C5F56C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82C5F570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F574: C3E40C10  lfs f31, 0xc10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3088 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C5F578: C0450BF8  lfs f2, 0xbf8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3064 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5F57C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C5F580: 4BFFF279  bl 0x82c5e7f8
	ctx.lr = 0x82C5F584;
	sub_82C5E7F8(ctx, base);
	// 82C5F584: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F58C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C5F590: C04B0A4C  lfs f2, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C5F594: 4BFFF2E5  bl 0x82c5e878
	ctx.lr = 0x82C5F598;
	sub_82C5E878(ctx, base);
	// 82C5F598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F59C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5F5A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F5A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F5A8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5F5AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F5B8 size=212
    let mut pc: u32 = 0x82C5F5B8;
    'dispatch: loop {
        match pc {
            0x82C5F5B8 => {
    //   block [0x82C5F5B8..0x82C5F68C)
	// 82C5F5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F5BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F5C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5F5C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5F5C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F5CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F5D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5F5D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5F5D8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C5F5DC: 390AD4C8  addi r8, r10, -0x2b38
	ctx.r[8].s64 = ctx.r[10].s64 + -11064;
	// 82C5F5E0: C00B0C10  lfs f0, 0xc10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F5E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C5F5E8: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5F5EC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C5F5F0: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82C5F5F4: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 82C5F5F8: C0090C18  lfs f0, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F5FC: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82C5F600: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82C5F604: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82C5F608: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C5F60C: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C5F610: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82C5F614: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C5F618: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C5F61C: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82C5F620: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82C5F624: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82C5F628: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82C5F62C: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82C5F630: 4BFFFE01  bl 0x82c5f430
	ctx.lr = 0x82C5F634;
	sub_82C5F430(ctx, base);
	// 82C5F634: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 82C5F638: 4BFFFED1  bl 0x82c5f508
	ctx.lr = 0x82C5F63C;
	sub_82C5F508(ctx, base);
	// 82C5F63C: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 82C5F640: 38A000FC  li r5, 0xfc
	ctx.r[5].s64 = 252;
	// 82C5F644: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 82C5F648: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5F64C: 4804A365  bl 0x82ca99b0
	ctx.lr = 0x82C5F650;
	sub_82CA99B0(ctx, base);
	// 82C5F650: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82C5F654: 93DF01D0  stw r30, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[30].u32 ) };
	// 82C5F658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F65C: 93DF01D4  stw r30, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[30].u32 ) };
	// 82C5F660: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5F664: 90FF01D8  stw r7, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[7].u32 ) };
	// 82C5F668: 4BFFFD79  bl 0x82c5f3e0
	ctx.lr = 0x82C5F66C;
	sub_82C5F3E0(ctx, base);
	// 82C5F66C: 93DF01D8  stw r30, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[30].u32 ) };
	// 82C5F670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F674: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5F678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F67C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F680: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5F684: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F688: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F690 size=148
    let mut pc: u32 = 0x82C5F690;
    'dispatch: loop {
        match pc {
            0x82C5F690 => {
    //   block [0x82C5F690..0x82C5F6C8)
	// 82C5F690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F698: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5F69C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F6A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5F6A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5F6A8: C00BD2E0  lfs f0, -0x2d20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F6AC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5F6B0: 41980018  blt cr6, 0x82c5f6c8
	if ctx.cr[6].lt {
	pc = 0x82C5F6C8; continue 'dispatch;
	}
	// 82C5F6B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5F6B8: C00BD2E4  lfs f0, -0x2d1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F6BC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C5F6C0: 41990008  bgt cr6, 0x82c5f6c8
	if ctx.cr[6].gt {
	pc = 0x82C5F6C8; continue 'dispatch;
	}
	// 82C5F6C4: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	pc = 0x82C5F6C8; continue 'dispatch;
            }
            0x82C5F6C8 => {
    //   block [0x82C5F6C8..0x82C5F724)
	// 82C5F6C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F6CC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C5F6D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F6D4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F6D8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82C5F6DC: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C5F6E0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C5F6E4: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82C5F6E8: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82C5F6EC: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82C5F6F0: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82C5F6F4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82C5F6F8: C03F0020  lfs f1, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5F6FC: 4BFFF4E5  bl 0x82c5ebe0
	ctx.lr = 0x82C5F700;
	sub_82C5EBE0(ctx, base);
	// 82C5F700: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C5F704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5F708: 4BFFFCD9  bl 0x82c5f3e0
	ctx.lr = 0x82C5F70C;
	sub_82C5F3E0(ctx, base);
	// 82C5F70C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5F710: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5F714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F71C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5F728 size=20
    let mut pc: u32 = 0x82C5F728;
    'dispatch: loop {
        match pc {
            0x82C5F728 => {
    //   block [0x82C5F728..0x82C5F73C)
	// 82C5F728: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C5F72C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5F730: 99640000  stb r11, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C5F734: B1640002  sth r11, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 82C5F738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F740 size=132
    let mut pc: u32 = 0x82C5F740;
    'dispatch: loop {
        match pc {
            0x82C5F740 => {
    //   block [0x82C5F740..0x82C5F77C)
	// 82C5F740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F748: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5F74C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F750: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82C5F754: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C5F758: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5F75C: 419A0020  beq cr6, 0x82c5f77c
	if ctx.cr[6].eq {
	pc = 0x82C5F77C; continue 'dispatch;
	}
	// 82C5F760: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C5F764: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C5F768: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5F76C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F778: 4E800020  blr
	return;
            }
            0x82C5F77C => {
    //   block [0x82C5F77C..0x82C5F7C4)
	// 82C5F77C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5F780: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5F784: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C5F788: 5484063E  clrlwi r4, r4, 0x18
	ctx.r[4].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82C5F78C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F790: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C5F794: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F798: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C5F79C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C5F7A0: 4E800421  bctrl
	ctx.lr = 0x82C5F7A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5F7A4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F7A8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C5F7AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5F7B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5F7B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F7B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F7BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F7C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F7C8 size=100
    let mut pc: u32 = 0x82C5F7C8;
    'dispatch: loop {
        match pc {
            0x82C5F7C8 => {
    //   block [0x82C5F7C8..0x82C5F7F8)
	// 82C5F7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F7CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F7D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F7D4: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82C5F7D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5F7DC: 419A001C  beq cr6, 0x82c5f7f8
	if ctx.cr[6].eq {
	pc = 0x82C5F7F8; continue 'dispatch;
	}
	// 82C5F7E0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C5F7E4: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C5F7E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5F7EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F7F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F7F4: 4E800020  blr
	return;
            }
            0x82C5F7F8 => {
    //   block [0x82C5F7F8..0x82C5F82C)
	// 82C5F7F8: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5F7FC: C0260000  lfs f1, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5F800: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C5F804: 5484063E  clrlwi r4, r4, 0x18
	ctx.r[4].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82C5F808: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F80C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C5F810: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5F814: 4E800421  bctrl
	ctx.lr = 0x82C5F818;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5F818: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5F81C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5F820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5F830 size=204
    let mut pc: u32 = 0x82C5F830;
    'dispatch: loop {
        match pc {
            0x82C5F830 => {
    //   block [0x82C5F830..0x82C5F858)
	// 82C5F830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F838: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5F83C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5F844: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C5F848: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C5F84C: 4807ED65  bl 0x82cde5b0
	ctx.lr = 0x82C5F850;
	sub_82CDE5B0(ctx, base);
	// 82C5F850: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5F854: 40980020  bge cr6, 0x82c5f874
	if !ctx.cr[6].lt {
	pc = 0x82C5F874; continue 'dispatch;
	}
	pc = 0x82C5F858; continue 'dispatch;
            }
            0x82C5F858 => {
    //   block [0x82C5F858..0x82C5F874)
	// 82C5F858: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C5F85C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C5F860: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5F864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F870: 4E800020  blr
	return;
            }
            0x82C5F874 => {
    //   block [0x82C5F874..0x82C5F8B0)
	// 82C5F874: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C5F878: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 82C5F87C: 4199FFDC  bgt cr6, 0x82c5f858
	if ctx.cr[6].gt {
	pc = 0x82C5F858; continue 'dispatch;
	}
	// 82C5F880: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 82C5F884: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C5F888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5F88C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82C5F890: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5F894: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C5F898: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C5F89C: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C5F8A0: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82C5F8A4: 419A0020  beq cr6, 0x82c5f8c4
	if ctx.cr[6].eq {
	pc = 0x82C5F8C4; continue 'dispatch;
	}
	// 82C5F8A8: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5F8AC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	pc = 0x82C5F8B0; continue 'dispatch;
            }
            0x82C5F8B0 => {
    //   block [0x82C5F8B0..0x82C5F8C4)
	// 82C5F8B0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5F8B4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C5F8B8: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82C5F8BC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C5F8C0: 4082FFF0  bne 0x82c5f8b0
	if !ctx.cr[0].eq {
	pc = 0x82C5F8B0; continue 'dispatch;
	}
	pc = 0x82C5F8C4; continue 'dispatch;
            }
            0x82C5F8C4 => {
    //   block [0x82C5F8C4..0x82C5F8FC)
	// 82C5F8C4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5F8C8: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 82C5F8CC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C5F8D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C5F8D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F8D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5F8DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5F8E0: 4E800421  bctrl
	ctx.lr = 0x82C5F8E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5F8E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5F8E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5F8EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F8F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5F900 size=120
    let mut pc: u32 = 0x82C5F900;
    'dispatch: loop {
        match pc {
            0x82C5F900 => {
    //   block [0x82C5F900..0x82C5F964)
	// 82C5F900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F90C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5F910: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5F914: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82C5F918: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82C5F91C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C5F920: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C5F924: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C5F928: C00AD298  lfs f0, -0x2d68(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5F92C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82C5F930: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C5F934: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F938: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F93C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C5F940: 4E800421  bctrl
	ctx.lr = 0x82C5F944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5F944: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5F948: 419A001C  beq cr6, 0x82c5f964
	if ctx.cr[6].eq {
	pc = 0x82C5F964; continue 'dispatch;
	}
	// 82C5F94C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C5F950: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C5F954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5F958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F95C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F960: 4E800020  blr
	return;
            }
            0x82C5F964 => {
    //   block [0x82C5F964..0x82C5F978)
	// 82C5F964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5F968: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5F96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5F978 size=84
    let mut pc: u32 = 0x82C5F978;
    'dispatch: loop {
        match pc {
            0x82C5F978 => {
    //   block [0x82C5F978..0x82C5F9CC)
	// 82C5F978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5F984: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5F98C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5F990: 394BD548  addi r10, r11, -0x2ab8
	ctx.r[10].s64 = ctx.r[11].s64 + -10936;
	// 82C5F994: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5F998: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5F99C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F9A0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5F9A4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C5F9A8: 4E800421  bctrl
	ctx.lr = 0x82C5F9AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5F9AC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C5F9B0: 38C7D268  addi r6, r7, -0x2d98
	ctx.r[6].s64 = ctx.r[7].s64 + -11672;
	// 82C5F9B4: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82C5F9B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5F9BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5F9C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5F9C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5F9C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5F9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5F9D0 size=88
    let mut pc: u32 = 0x82C5F9D0;
    'dispatch: loop {
        match pc {
            0x82C5F9D0 => {
    //   block [0x82C5F9D0..0x82C5FA28)
	// 82C5F9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5F9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5F9D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5F9DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5F9E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5F9E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5F9E8: 394BD548  addi r10, r11, -0x2ab8
	ctx.r[10].s64 = ctx.r[11].s64 + -10936;
	// 82C5F9EC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5F9F0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5F9F4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5F9F8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5F9FC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C5FA00: 4E800421  bctrl
	ctx.lr = 0x82C5FA04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5FA04: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C5FA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5FA0C: 38C7D268  addi r6, r7, -0x2d98
	ctx.r[6].s64 = ctx.r[7].s64 + -11672;
	// 82C5FA10: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82C5FA14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5FA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FA20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5FA24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5FA28 size=32
    let mut pc: u32 = 0x82C5FA28;
    'dispatch: loop {
        match pc {
            0x82C5FA28 => {
    //   block [0x82C5FA28..0x82C5FA48)
	// 82C5FA28: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5FA2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C5FA30: 392AD548  addi r9, r10, -0x2ab8
	ctx.r[9].s64 = ctx.r[10].s64 + -10936;
	// 82C5FA34: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C5FA38: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5FA3C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C5FA40: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82C5FA44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5FA50 size=112
    let mut pc: u32 = 0x82C5FA50;
    'dispatch: loop {
        match pc {
            0x82C5FA50 => {
    //   block [0x82C5FA50..0x82C5FA80)
	// 82C5FA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FA58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5FA5C: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 82C5FA60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FA64: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82C5FA68: 4B68A751  bl 0x822ea1b8
	ctx.lr = 0x82C5FA6C;
	sub_822EA1B8(ctx, base);
	// 82C5FA6C: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C5FA70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5FA74: 419A000C  beq cr6, 0x82c5fa80
	if ctx.cr[6].eq {
	pc = 0x82C5FA80; continue 'dispatch;
	}
	// 82C5FA78: 48000159  bl 0x82c5fbd0
	ctx.lr = 0x82C5FA7C;
	sub_82C5FBD0(ctx, base);
	// 82C5FA7C: 48000008  b 0x82c5fa84
	pc = 0x82C5FA84; continue 'dispatch;
            }
            0x82C5FA80 => {
    //   block [0x82C5FA80..0x82C5FA84)
	// 82C5FA80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82C5FA84; continue 'dispatch;
            }
            0x82C5FA84 => {
    //   block [0x82C5FA84..0x82C5FAC0)
	// 82C5FA84: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 82C5FA88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FA8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FA90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5FA94: 4E800020  blr
	return;
	// 82C5FA98: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 82C5FA9C: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FAA0: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FAA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FAA8: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5FAAC: 4BBE5D05  bl 0x828457b0
	ctx.lr = 0x82C5FAB0;
	sub_828457B0(ctx, base);
	// 82C5FAB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5FAB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FAB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5FAC0 size=28
    let mut pc: u32 = 0x82C5FAC0;
    'dispatch: loop {
        match pc {
            0x82C5FAC0 => {
    //   block [0x82C5FAC0..0x82C5FADC)
	// 82C5FAC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5FAC4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C5FAC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5FACC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C5FAD0: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C5FAD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5FAD8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5FAE0 size=8
    let mut pc: u32 = 0x82C5FAE0;
    'dispatch: loop {
        match pc {
            0x82C5FAE0 => {
    //   block [0x82C5FAE0..0x82C5FAE8)
	// 82C5FAE0: 48000578  b 0x82c60058
	sub_82C60058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5FAE8 size=48
    let mut pc: u32 = 0x82C5FAE8;
    'dispatch: loop {
        match pc {
            0x82C5FAE8 => {
    //   block [0x82C5FAE8..0x82C5FB18)
	// 82C5FAE8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5FAEC: 4198002C  blt cr6, 0x82c5fb18
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82C5FB18);
		return;
	}
	// 82C5FAF0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82C5FAF4: 816BA878  lwz r11, -0x5788(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22408 as u32) ) } as u64;
	// 82C5FAF8: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C5FAFC: 4098001C  bge cr6, 0x82c5fb18
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82C5FB18);
		return;
	}
	// 82C5FB00: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82C5FB04: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C5FB08: 392BA848  addi r9, r11, -0x57b8
	ctx.r[9].s64 = ctx.r[11].s64 + -22456;
	// 82C5FB0C: 7D0A482E  lwzx r8, r10, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82C5FB10: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5FB14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5FB28 size=64
    let mut pc: u32 = 0x82C5FB28;
    'dispatch: loop {
        match pc {
            0x82C5FB28 => {
    //   block [0x82C5FB28..0x82C5FB68)
	// 82C5FB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FB2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FB30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FB34: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82C5FB38: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82C5FB3C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82C5FB40: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5FB44: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C5FB48: 4BFFFFA1  bl 0x82c5fae8
	ctx.lr = 0x82C5FB4C;
	sub_82C5FAE8(ctx, base);
	// 82C5FB4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C5FB50: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82C5FB54: 48001435  bl 0x82c60f88
	ctx.lr = 0x82C5FB58;
	sub_82C60F88(ctx, base);
	// 82C5FB58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5FB5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FB60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FB64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5FB68 size=104
    let mut pc: u32 = 0x82C5FB68;
    'dispatch: loop {
        match pc {
            0x82C5FB68 => {
    //   block [0x82C5FB68..0x82C5FBD0)
	// 82C5FB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FB6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FB70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5FB74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5FB78: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FB7C: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82C5FB80: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82C5FB84: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5FB88: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C5FB8C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C5FB90: 480019D1  bl 0x82c61560
	ctx.lr = 0x82C5FB94;
	sub_82C61560(ctx, base);
	// 82C5FB94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C5FB98: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C5FB9C: 388B0B34  addi r4, r11, 0xb34
	ctx.r[4].s64 = ctx.r[11].s64 + 2868;
	// 82C5FBA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C5FBA4: 4B5DFCFD  bl 0x8223f8a0
	ctx.lr = 0x82C5FBA8;
	sub_8223F8A0(ctx, base);
	// 82C5FBA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C5FBAC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C5FBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5FBB4: 480013D5  bl 0x82c60f88
	ctx.lr = 0x82C5FBB8;
	sub_82C60F88(ctx, base);
	// 82C5FBB8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C5FBBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FBC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FBC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5FBC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5FBCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5FBD0 size=64
    let mut pc: u32 = 0x82C5FBD0;
    'dispatch: loop {
        match pc {
            0x82C5FBD0 => {
    //   block [0x82C5FBD0..0x82C5FC10)
	// 82C5FBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FBD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FBD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5FBDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FBE0: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82C5FBE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5FBE8: 480013F1  bl 0x82c60fd8
	ctx.lr = 0x82C5FBEC;
	sub_82C60FD8(ctx, base);
	// 82C5FBEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5FBF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5FBF4: 394BD5A0  addi r10, r11, -0x2a60
	ctx.r[10].s64 = ctx.r[11].s64 + -10848;
	// 82C5FBF8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5FBFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5FC00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FC04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FC08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5FC0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C5FC10 size=632
    let mut pc: u32 = 0x82C5FC10;
    'dispatch: loop {
        match pc {
            0x82C5FC10 => {
    //   block [0x82C5FC10..0x82C5FC78)
	// 82C5FC10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5FC14: 394BD5A0  addi r10, r11, -0x2a60
	ctx.r[10].s64 = ctx.r[11].s64 + -10848;
	// 82C5FC18: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5FC1C: 480014AC  b 0x82c610c8
	sub_82C610C8(ctx, base);
	return;
	// 82C5FC20: 82CAE348  lwz r22, -0x1cb8(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7352 as u32) ) } as u64;
	// 82C5FC24: 8200D6A8  lwz r16, -0x2958(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -10584u32 ) } as u64;
	// 82C5FC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FC2C: 480497D1  bl 0x82ca93fc
	ctx.lr = 0x82C5FC30;
	sub_82CA93D0(ctx, base);
	// 82C5FC30: 3BE1FF60  addi r31, r1, -0xa0
	ctx.r[31].s64 = ctx.r[1].s64 + -160;
	// 82C5FC34: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FC38: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5FC3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5FC40: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C5FC44: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C5FC48: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5FC4C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C5FC50: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5FC54: 913E000C  stw r9, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82C5FC58: 8104000C  lwz r8, 0xc(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5FC5C: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C5FC60: 556707BC  rlwinm r7, r11, 0, 0x1e, 0x1e
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C5FC64: 911E0010  stw r8, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82C5FC68: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C5FC6C: 419A000C  beq cr6, 0x82c5fc78
	if ctx.cr[6].eq {
	pc = 0x82C5FC78; continue 'dispatch;
	}
	// 82C5FC70: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82C5FC74: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
            }
            0x82C5FC78 => {
    //   block [0x82C5FC78..0x82C5FCA0)
	// 82C5FC78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5FC7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5FC80: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C5FC84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5FC88: 4E800421  bctrl
	ctx.lr = 0x82C5FC8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5FC8C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C5FC90: 419A0010  beq cr6, 0x82c5fca0
	if ctx.cr[6].eq {
	pc = 0x82C5FCA0; continue 'dispatch;
	}
	// 82C5FC94: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C5FC98: 60630007  ori r3, r3, 7
	ctx.r[3].u64 = ctx.r[3].u64 | 7;
	// 82C5FC9C: 480001B8  b 0x82c5fe54
	pc = 0x82C5FE54; continue 'dispatch;
            }
            0x82C5FCA0 => {
    //   block [0x82C5FCA0..0x82C5FCC8)
	// 82C5FCA0: 38600268  li r3, 0x268
	ctx.r[3].s64 = 616;
	// 82C5FCA4: 480002C5  bl 0x82c5ff68
	ctx.lr = 0x82C5FCA8;
	sub_82C5FF68(ctx, base);
	// 82C5FCA8: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C5FCAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5FCB0: 419A0018  beq cr6, 0x82c5fcc8
	if ctx.cr[6].eq {
	pc = 0x82C5FCC8; continue 'dispatch;
	}
	// 82C5FCB4: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5FCB8: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C5FCBC: 48001E6D  bl 0x82c61b28
	ctx.lr = 0x82C5FCC0;
	sub_82C61B28(ctx, base);
	// 82C5FCC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C5FCC4: 48000008  b 0x82c5fccc
	pc = 0x82C5FCCC; continue 'dispatch;
            }
            0x82C5FCC8 => {
    //   block [0x82C5FCC8..0x82C5FCCC)
	// 82C5FCC8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C5FCCC; continue 'dispatch;
            }
            0x82C5FCCC => {
    //   block [0x82C5FCCC..0x82C5FE54)
	// 82C5FCCC: 93BE0014  stw r29, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82C5FCD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5FCD4: 48003945  bl 0x82c63618
	ctx.lr = 0x82C5FCD8;
	sub_82C63618(ctx, base);
	// 82C5FCD8: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5FCDC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5FCE0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FCE4: 553B1F38  rlwinm r27, r9, 3, 0x1c, 0x1c
	ctx.r[27].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 82C5FCE8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5FCEC: 3B8B57B0  addi r28, r11, 0x57b0
	ctx.r[28].s64 = ctx.r[11].s64 + 22448;
	// 82C5FCF0: 637A0040  ori r26, r27, 0x40
	ctx.r[26].u64 = ctx.r[27].u64 | 64;
	// 82C5FCF4: 388AD694  addi r4, r10, -0x296c
	ctx.r[4].s64 = ctx.r[10].s64 + -10604;
	// 82C5FCF8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C5FCFC: 38FD0128  addi r7, r29, 0x128
	ctx.r[7].s64 = ctx.r[29].s64 + 296;
	// 82C5FD00: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C5FD04: 48003065  bl 0x82c62d68
	ctx.lr = 0x82C5FD08;
	sub_82C62D68(ctx, base);
	// 82C5FD08: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FD0C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C5FD10: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C5FD14: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C5FD18: 3888D684  addi r4, r8, -0x297c
	ctx.r[4].s64 = ctx.r[8].s64 + -10620;
	// 82C5FD1C: 38FD0148  addi r7, r29, 0x148
	ctx.r[7].s64 = ctx.r[29].s64 + 328;
	// 82C5FD20: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82C5FD24: 48003045  bl 0x82c62d68
	ctx.lr = 0x82C5FD28;
	sub_82C62D68(ctx, base);
	// 82C5FD28: 3CE08333  lis r7, -0x7ccd
	ctx.r[7].s64 = -2093809664;
	// 82C5FD2C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FD30: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82C5FD34: 3B275858  addi r25, r7, 0x5858
	ctx.r[25].s64 = ctx.r[7].s64 + 22616;
	// 82C5FD38: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C5FD3C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82C5FD40: 3884D678  addi r4, r4, -0x2988
	ctx.r[4].s64 = ctx.r[4].s64 + -10632;
	// 82C5FD44: 38FD0168  addi r7, r29, 0x168
	ctx.r[7].s64 = ctx.r[29].s64 + 360;
	// 82C5FD48: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 82C5FD4C: 4800301D  bl 0x82c62d68
	ctx.lr = 0x82C5FD50;
	sub_82C62D68(ctx, base);
	// 82C5FD50: 3C608333  lis r3, -0x7ccd
	ctx.r[3].s64 = -2093809664;
	// 82C5FD54: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FD58: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5FD5C: 38A35778  addi r5, r3, 0x5778
	ctx.r[5].s64 = ctx.r[3].s64 + 22392;
	// 82C5FD60: 63660001  ori r6, r27, 1
	ctx.r[6].u64 = ctx.r[27].u64 | 1;
	// 82C5FD64: 388AD670  addi r4, r10, -0x2990
	ctx.r[4].s64 = ctx.r[10].s64 + -10640;
	// 82C5FD68: 38FD0188  addi r7, r29, 0x188
	ctx.r[7].s64 = ctx.r[29].s64 + 392;
	// 82C5FD6C: 386B0078  addi r3, r11, 0x78
	ctx.r[3].s64 = ctx.r[11].s64 + 120;
	// 82C5FD70: 48002FF9  bl 0x82c62d68
	ctx.lr = 0x82C5FD74;
	sub_82C62D68(ctx, base);
	// 82C5FD74: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FD78: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C5FD7C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C5FD80: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82C5FD84: 3889D660  addi r4, r9, -0x29a0
	ctx.r[4].s64 = ctx.r[9].s64 + -10656;
	// 82C5FD88: 38FD01A8  addi r7, r29, 0x1a8
	ctx.r[7].s64 = ctx.r[29].s64 + 424;
	// 82C5FD8C: 386B00A0  addi r3, r11, 0xa0
	ctx.r[3].s64 = ctx.r[11].s64 + 160;
	// 82C5FD90: 48002FD9  bl 0x82c62d68
	ctx.lr = 0x82C5FD94;
	sub_82C62D68(ctx, base);
	// 82C5FD94: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FD98: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C5FD9C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C5FDA0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C5FDA4: 3888D650  addi r4, r8, -0x29b0
	ctx.r[4].s64 = ctx.r[8].s64 + -10672;
	// 82C5FDA8: 38FD01C8  addi r7, r29, 0x1c8
	ctx.r[7].s64 = ctx.r[29].s64 + 456;
	// 82C5FDAC: 386B00C8  addi r3, r11, 0xc8
	ctx.r[3].s64 = ctx.r[11].s64 + 200;
	// 82C5FDB0: 48002FB9  bl 0x82c62d68
	ctx.lr = 0x82C5FDB4;
	sub_82C62D68(ctx, base);
	// 82C5FDB4: 3CE08333  lis r7, -0x7ccd
	ctx.r[7].s64 = -2093809664;
	// 82C5FDB8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FDBC: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82C5FDC0: 38A75820  addi r5, r7, 0x5820
	ctx.r[5].s64 = ctx.r[7].s64 + 22560;
	// 82C5FDC4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C5FDC8: 3884D648  addi r4, r4, -0x29b8
	ctx.r[4].s64 = ctx.r[4].s64 + -10680;
	// 82C5FDCC: 38FD01E8  addi r7, r29, 0x1e8
	ctx.r[7].s64 = ctx.r[29].s64 + 488;
	// 82C5FDD0: 386B00F0  addi r3, r11, 0xf0
	ctx.r[3].s64 = ctx.r[11].s64 + 240;
	// 82C5FDD4: 48002F95  bl 0x82c62d68
	ctx.lr = 0x82C5FDD8;
	sub_82C62D68(ctx, base);
	// 82C5FDD8: 3C608333  lis r3, -0x7ccd
	ctx.r[3].s64 = -2093809664;
	// 82C5FDDC: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FDE0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5FDE4: 38A351AC  addi r5, r3, 0x51ac
	ctx.r[5].s64 = ctx.r[3].s64 + 20908;
	// 82C5FDE8: 388AD63C  addi r4, r10, -0x29c4
	ctx.r[4].s64 = ctx.r[10].s64 + -10692;
	// 82C5FDEC: 38FD0208  addi r7, r29, 0x208
	ctx.r[7].s64 = ctx.r[29].s64 + 520;
	// 82C5FDF0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C5FDF4: 386B0118  addi r3, r11, 0x118
	ctx.r[3].s64 = ctx.r[11].s64 + 280;
	// 82C5FDF8: 48002F71  bl 0x82c62d68
	ctx.lr = 0x82C5FDFC;
	sub_82C62D68(ctx, base);
	// 82C5FDFC: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FE00: 38FD0228  addi r7, r29, 0x228
	ctx.r[7].s64 = ctx.r[29].s64 + 552;
	// 82C5FE04: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C5FE08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C5FE0C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C5FE10: 386B0140  addi r3, r11, 0x140
	ctx.r[3].s64 = ctx.r[11].s64 + 320;
	// 82C5FE14: 3889D630  addi r4, r9, -0x29d0
	ctx.r[4].s64 = ctx.r[9].s64 + -10704;
	// 82C5FE18: 48002F51  bl 0x82c62d68
	ctx.lr = 0x82C5FE1C;
	sub_82C62D68(ctx, base);
	// 82C5FE1C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C5FE20: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C5FE24: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C5FE28: 3888D620  addi r4, r8, -0x29e0
	ctx.r[4].s64 = ctx.r[8].s64 + -10720;
	// 82C5FE2C: 38FD0248  addi r7, r29, 0x248
	ctx.r[7].s64 = ctx.r[29].s64 + 584;
	// 82C5FE30: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C5FE34: 386B0168  addi r3, r11, 0x168
	ctx.r[3].s64 = ctx.r[11].s64 + 360;
	// 82C5FE38: 48002F31  bl 0x82c62d68
	ctx.lr = 0x82C5FE3C;
	sub_82C62D68(ctx, base);
	// 82C5FE3C: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5FE40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C5FE44: 80C70010  lwz r6, 0x10(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5FE48: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C5FE4C: 4E800421  bctrl
	ctx.lr = 0x82C5FE50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5FE50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            0x82C5FE54 => {
    //   block [0x82C5FE54..0x82C5FE88)
	// 82C5FE54: 383F00A0  addi r1, r31, 0xa0
	ctx.r[1].s64 = ctx.r[31].s64 + 160;
	// 82C5FE58: 480495F4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 82C5FE5C: 3BECFF60  addi r31, r12, -0xa0
	ctx.r[31].s64 = ctx.r[12].s64 + -160;
	// 82C5FE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FE64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FE68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FE6C: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5FE70: 4BFFFC71  bl 0x82c5fae0
	ctx.lr = 0x82C5FE74;
	sub_82C5FAE0(ctx, base);
	// 82C5FE74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5FE78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FE7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FE80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C5FE88 size=52
    let mut pc: u32 = 0x82C5FE88;
    'dispatch: loop {
        match pc {
            0x82C5FE88 => {
    //   block [0x82C5FE88..0x82C5FEBC)
	// 82C5FE88: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5FE8C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82C5FE90: 4199002C  bgt cr6, 0x82c5febc
	if ctx.cr[6].gt {
		sub_82C5FEBC(ctx, base);
		return;
	}
	// 82C5FE94: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5FE98: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82C5FE9C: 41990020  bgt cr6, 0x82c5febc
	if ctx.cr[6].gt {
		sub_82C5FEBC(ctx, base);
		return;
	}
	// 82C5FEA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5FEA4: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5FEA8: C00BD6E8  lfs f0, -0x2918(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C5FEAC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C5FEB0: 4199000C  bgt cr6, 0x82c5febc
	if ctx.cr[6].gt {
		sub_82C5FEBC(ctx, base);
		return;
	}
	// 82C5FEB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5FEB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FEBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5FEBC size=12
    let mut pc: u32 = 0x82C5FEBC;
    'dispatch: loop {
        match pc {
            0x82C5FEBC => {
    //   block [0x82C5FEBC..0x82C5FEC8)
	// 82C5FEBC: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C5FEC0: 60630007  ori r3, r3, 7
	ctx.r[3].u64 = ctx.r[3].u64 | 7;
	// 82C5FEC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C5FEC8 size=4
    let mut pc: u32 = 0x82C5FEC8;
    'dispatch: loop {
        match pc {
            0x82C5FEC8 => {
    //   block [0x82C5FEC8..0x82C5FECC)
	// 82C5FEC8: 48000F38  b 0x82c60e00
	sub_82C60E00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C5FED0 size=36
    let mut pc: u32 = 0x82C5FED0;
    'dispatch: loop {
        match pc {
            0x82C5FED0 => {
    //   block [0x82C5FED0..0x82C5FEF4)
	// 82C5FED0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5FED4: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C5FED8: C80BD6F0  lfd f0, -0x2910(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-10512 as u32) ) };
	// 82C5FEDC: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 82C5FEE0: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82C5FEE4: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 82C5FEE8: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82C5FEEC: 5543103A  slwi r3, r10, 2
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C5FEF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5FEF8 size=80
    let mut pc: u32 = 0x82C5FEF8;
    'dispatch: loop {
        match pc {
            0x82C5FEF8 => {
    //   block [0x82C5FEF8..0x82C5FF30)
	// 82C5FEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FF00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5FF04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5FF08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FF0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5FF10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5FF14: 4BFFFCFD  bl 0x82c5fc10
	ctx.lr = 0x82C5FF18;
	sub_82C5FC10(ctx, base);
	// 82C5FF18: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C5FF1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5FF20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5FF24: 419A000C  beq cr6, 0x82c5ff30
	if ctx.cr[6].eq {
	pc = 0x82C5FF30; continue 'dispatch;
	}
	// 82C5FF28: 4BBE5889  bl 0x828457b0
	ctx.lr = 0x82C5FF2C;
	sub_828457B0(ctx, base);
	// 82C5FF2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C5FF30; continue 'dispatch;
            }
            0x82C5FF30 => {
    //   block [0x82C5FF30..0x82C5FF48)
	// 82C5FF30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5FF34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FF38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FF3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5FF40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5FF44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5FF48 size=32
    let mut pc: u32 = 0x82C5FF48;
    'dispatch: loop {
        match pc {
            0x82C5FF48 => {
    //   block [0x82C5FF48..0x82C5FF68)
	// 82C5FF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FF50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FF54: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C5FF58: 3D608211  lis r11, -0x7def
	ctx.r[11].s64 = -2112815104;
	// 82C5FF5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C5FF60: 388BB500  addi r4, r11, -0x4b00
	ctx.r[4].s64 = ctx.r[11].s64 + -19200;
	// 82C5FF64: 4804D29D  bl 0x82cad200
	ctx.lr = 0x82C5FF68;
	sub_82CAD200(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5FF68 size=116
    let mut pc: u32 = 0x82C5FF68;
    'dispatch: loop {
        match pc {
            0x82C5FF68 => {
    //   block [0x82C5FF68..0x82C5FF9C)
	// 82C5FF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FF6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FF70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5FF74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FF78: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5FF7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5FF80: 814B51D4  lwz r10, 0x51d4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20948 as u32) ) } as u64;
	// 82C5FF84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5FF88: 419A0014  beq cr6, 0x82c5ff9c
	if ctx.cr[6].eq {
	pc = 0x82C5FF9C; continue 'dispatch;
	}
	// 82C5FF8C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C5FF90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C5FF94: 4E800421  bctrl
	ctx.lr = 0x82C5FF98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5FF98: 48000008  b 0x82c5ffa0
	pc = 0x82C5FFA0; continue 'dispatch;
            }
            0x82C5FF9C => {
    //   block [0x82C5FF9C..0x82C5FFA0)
	// 82C5FF9C: 4804A4ED  bl 0x82caa488
	ctx.lr = 0x82C5FFA0;
	sub_82CAA488(ctx, base);
	pc = 0x82C5FFA0; continue 'dispatch;
            }
            0x82C5FFA0 => {
    //   block [0x82C5FFA0..0x82C5FFC8)
	// 82C5FFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5FFA4: 409A0024  bne cr6, 0x82c5ffc8
	if !ctx.cr[6].eq {
	pc = 0x82C5FFC8; continue 'dispatch;
	}
	// 82C5FFA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82C5FFAC: 814B677C  lwz r10, 0x677c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26492 as u32) ) } as u64;
	// 82C5FFB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5FFB4: 419A0014  beq cr6, 0x82c5ffc8
	if ctx.cr[6].eq {
	pc = 0x82C5FFC8; continue 'dispatch;
	}
	// 82C5FFB8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C5FFBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5FFC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C5FFC4: 4E800421  bctrl
	ctx.lr = 0x82C5FFC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C5FFC8 => {
    //   block [0x82C5FFC8..0x82C5FFDC)
	// 82C5FFC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5FFCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5FFD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5FFD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5FFD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C5FFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C5FFE0 size=116
    let mut pc: u32 = 0x82C5FFE0;
    'dispatch: loop {
        match pc {
            0x82C5FFE0 => {
    //   block [0x82C5FFE0..0x82C60014)
	// 82C5FFE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5FFE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C5FFE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5FFEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5FFF0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5FFF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5FFF8: 814B51CC  lwz r10, 0x51cc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20940 as u32) ) } as u64;
	// 82C5FFFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C60000: 419A0014  beq cr6, 0x82c60014
	if ctx.cr[6].eq {
	pc = 0x82C60014; continue 'dispatch;
	}
	// 82C60004: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C6000C: 4E800421  bctrl
	ctx.lr = 0x82C60010;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C60010: 48000008  b 0x82c60018
	pc = 0x82C60018; continue 'dispatch;
            }
            0x82C60014 => {
    //   block [0x82C60014..0x82C60018)
	// 82C60014: 4804A475  bl 0x82caa488
	ctx.lr = 0x82C60018;
	sub_82CAA488(ctx, base);
	pc = 0x82C60018; continue 'dispatch;
            }
            0x82C60018 => {
    //   block [0x82C60018..0x82C60040)
	// 82C60018: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6001C: 409A0024  bne cr6, 0x82c60040
	if !ctx.cr[6].eq {
	pc = 0x82C60040; continue 'dispatch;
	}
	// 82C60020: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82C60024: 814B677C  lwz r10, 0x677c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26492 as u32) ) } as u64;
	// 82C60028: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6002C: 419A0014  beq cr6, 0x82c60040
	if ctx.cr[6].eq {
	pc = 0x82C60040; continue 'dispatch;
	}
	// 82C60030: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C6003C: 4E800421  bctrl
	ctx.lr = 0x82C60040;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C60040 => {
    //   block [0x82C60040..0x82C60054)
	// 82C60040: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6004C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C60058 size=28
    let mut pc: u32 = 0x82C60058;
    'dispatch: loop {
        match pc {
            0x82C60058 => {
    //   block [0x82C60058..0x82C60074)
	// 82C60058: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C6005C: 814B51D0  lwz r10, 0x51d0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20944 as u32) ) } as u64;
	// 82C60060: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C60064: 419A0010  beq cr6, 0x82c60074
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C60074);
		return;
	}
	// 82C60068: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6006C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C60070: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C60078 size=28
    let mut pc: u32 = 0x82C60078;
    'dispatch: loop {
        match pc {
            0x82C60078 => {
    //   block [0x82C60078..0x82C60094)
	// 82C60078: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C6007C: 814B51C8  lwz r10, 0x51c8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20936 as u32) ) } as u64;
	// 82C60080: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C60084: 419A0010  beq cr6, 0x82c60094
	if ctx.cr[6].eq {
		sub_82C60094(ctx, base);
		return;
	}
	// 82C60088: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6008C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C60090: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60094(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C60094 size=4
    let mut pc: u32 = 0x82C60094;
    'dispatch: loop {
        match pc {
            0x82C60094 => {
    //   block [0x82C60094..0x82C60098)
	// 82C60094: 4804C0AC  b 0x82cac140
	sub_82CAC140(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C60098 size=52
    let mut pc: u32 = 0x82C60098;
    'dispatch: loop {
        match pc {
            0x82C60098 => {
    //   block [0x82C60098..0x82C600CC)
	// 82C60098: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6009C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82C600A0: 4199002C  bgt cr6, 0x82c600cc
	if ctx.cr[6].gt {
		sub_82C600CC(ctx, base);
		return;
	}
	// 82C600A4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C600A8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82C600AC: 41990020  bgt cr6, 0x82c600cc
	if ctx.cr[6].gt {
		sub_82C600CC(ctx, base);
		return;
	}
	// 82C600B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C600B4: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C600B8: C00BD6E8  lfs f0, -0x2918(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C600BC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C600C0: 4199000C  bgt cr6, 0x82c600cc
	if ctx.cr[6].gt {
		sub_82C600CC(ctx, base);
		return;
	}
	// 82C600C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C600C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C600CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C600CC size=12
    let mut pc: u32 = 0x82C600CC;
    'dispatch: loop {
        match pc {
            0x82C600CC => {
    //   block [0x82C600CC..0x82C600D8)
	// 82C600CC: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C600D0: 60630007  ori r3, r3, 7
	ctx.r[3].u64 = ctx.r[3].u64 | 7;
	// 82C600D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C600D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C600D8 size=96
    let mut pc: u32 = 0x82C600D8;
    'dispatch: loop {
        match pc {
            0x82C600D8 => {
    //   block [0x82C600D8..0x82C60114)
	// 82C600D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C600DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C600E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C600E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C600E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C600EC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C600F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C600F4: 409A0020  bne cr6, 0x82c60114
	if !ctx.cr[6].eq {
	pc = 0x82C60114; continue 'dispatch;
	}
	// 82C600F8: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C600FC: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60100: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60104: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60108: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6010C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60110: 4E800020  blr
	return;
            }
            0x82C60114 => {
    //   block [0x82C60114..0x82C60138)
	// 82C60114: 48003445  bl 0x82c63558
	ctx.lr = 0x82C60118;
	sub_82C63558(ctx, base);
	// 82C60118: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C6011C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60120: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82C60124: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6012C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60130: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C60138 size=72
    let mut pc: u32 = 0x82C60138;
    'dispatch: loop {
        match pc {
            0x82C60138 => {
    //   block [0x82C60138..0x82C60180)
	// 82C60138: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6013C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C60140: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60144: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82C60148: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C6014C: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C60150: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C60154: 80E40008  lwz r7, 8(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C60158: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C6015C: 80C4000C  lwz r6, 0xc(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C60160: 54CA003E  slwi r10, r6, 0
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C60164: 554507BC  rlwinm r5, r10, 0, 0x1e, 0x1e
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82C60168: 90CB0010  stw r6, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82C6016C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C60170: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C60174: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 82C60178: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82C6017C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60180 size=112
    let mut pc: u32 = 0x82C60180;
    'dispatch: loop {
        match pc {
            0x82C60180 => {
    //   block [0x82C60180..0x82C601BC)
	// 82C60180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60188: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6018C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60190: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C60194: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60198: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6019C: 409A0020  bne cr6, 0x82c601bc
	if !ctx.cr[6].eq {
	pc = 0x82C601BC; continue 'dispatch;
	}
	// 82C601A0: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C601A4: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C601A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C601AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C601B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C601B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C601B8: 4E800020  blr
	return;
            }
            0x82C601BC => {
    //   block [0x82C601BC..0x82C601F0)
	// 82C601BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C601C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C601C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C601C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C601CC: 4E800421  bctrl
	ctx.lr = 0x82C601D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C601D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C601D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C601D8: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82C601DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C601E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C601E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C601E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C601EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C601F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C601F0 size=192
    let mut pc: u32 = 0x82C601F0;
    'dispatch: loop {
        match pc {
            0x82C601F0 => {
    //   block [0x82C601F0..0x82C60228)
	// 82C601F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C601F4: 4804920D  bl 0x82ca9400
	ctx.lr = 0x82C601F8;
	sub_82CA93D0(ctx, base);
	// 82C601F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C601FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C60200: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C60204: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C60208: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82C6020C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60214: 409A0014  bne cr6, 0x82c60228
	if !ctx.cr[6].eq {
	pc = 0x82C60228; continue 'dispatch;
	}
	// 82C60218: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C6021C: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60220: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C60224: 4804922C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C60228 => {
    //   block [0x82C60228..0x82C60250)
	// 82C60228: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6022C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C60230: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C60234: 419A001C  beq cr6, 0x82c60250
	if ctx.cr[6].eq {
	pc = 0x82C60250; continue 'dispatch;
	}
	// 82C60238: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6023C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60240: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C60244: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C60248: 4E800421  bctrl
	ctx.lr = 0x82C6024C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6024C: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
            }
            0x82C60250 => {
    //   block [0x82C60250..0x82C60270)
	// 82C60250: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C60254: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C60258: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C6025C: 419A0034  beq cr6, 0x82c60290
	if ctx.cr[6].eq {
	pc = 0x82C60290; continue 'dispatch;
	}
	// 82C60260: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60264: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C60268: 40990028  ble cr6, 0x82c60290
	if !ctx.cr[6].gt {
	pc = 0x82C60290; continue 'dispatch;
	}
	// 82C6026C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82C60270; continue 'dispatch;
            }
            0x82C60270 => {
    //   block [0x82C60270..0x82C60290)
	// 82C60270: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60274: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C60278: 48002DB9  bl 0x82c63030
	ctx.lr = 0x82C6027C;
	sub_82C63030(ctx, base);
	// 82C6027C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60280: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C60284: 3BDE0028  addi r30, r30, 0x28
	ctx.r[30].s64 = ctx.r[30].s64 + 40;
	// 82C60288: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C6028C: 4198FFE4  blt cr6, 0x82c60270
	if ctx.cr[6].lt {
	pc = 0x82C60270; continue 'dispatch;
	}
	pc = 0x82C60290; continue 'dispatch;
            }
            0x82C60290 => {
    //   block [0x82C60290..0x82C602B0)
	// 82C60290: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C60294: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60298: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C6029C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C602A0: 480035B1  bl 0x82c63850
	ctx.lr = 0x82C602A4;
	sub_82C63850(ctx, base);
	// 82C602A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C602A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C602AC: 480491A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C602B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C602B0 size=192
    let mut pc: u32 = 0x82C602B0;
    'dispatch: loop {
        match pc {
            0x82C602B0 => {
    //   block [0x82C602B0..0x82C602E8)
	// 82C602B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C602B4: 4804914D  bl 0x82ca9400
	ctx.lr = 0x82C602B8;
	sub_82CA93D0(ctx, base);
	// 82C602B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C602BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C602C0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C602C4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C602C8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82C602CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C602D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C602D4: 409A0014  bne cr6, 0x82c602e8
	if !ctx.cr[6].eq {
	pc = 0x82C602E8; continue 'dispatch;
	}
	// 82C602D8: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C602DC: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C602E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C602E4: 4804916C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C602E8 => {
    //   block [0x82C602E8..0x82C60310)
	// 82C602E8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C602EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C602F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C602F4: 419A001C  beq cr6, 0x82c60310
	if ctx.cr[6].eq {
	pc = 0x82C60310; continue 'dispatch;
	}
	// 82C602F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C602FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60300: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C60304: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C60308: 4E800421  bctrl
	ctx.lr = 0x82C6030C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6030C: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
            }
            0x82C60310 => {
    //   block [0x82C60310..0x82C60330)
	// 82C60310: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C60314: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C60318: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C6031C: 419A0034  beq cr6, 0x82c60350
	if ctx.cr[6].eq {
	pc = 0x82C60350; continue 'dispatch;
	}
	// 82C60320: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60324: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C60328: 40990028  ble cr6, 0x82c60350
	if !ctx.cr[6].gt {
	pc = 0x82C60350; continue 'dispatch;
	}
	// 82C6032C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82C60330; continue 'dispatch;
            }
            0x82C60330 => {
    //   block [0x82C60330..0x82C60350)
	// 82C60330: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60334: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C60338: 48002CF9  bl 0x82c63030
	ctx.lr = 0x82C6033C;
	sub_82C63030(ctx, base);
	// 82C6033C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60340: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C60344: 3BDE0028  addi r30, r30, 0x28
	ctx.r[30].s64 = ctx.r[30].s64 + 40;
	// 82C60348: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C6034C: 4198FFE4  blt cr6, 0x82c60330
	if ctx.cr[6].lt {
	pc = 0x82C60330; continue 'dispatch;
	}
	pc = 0x82C60350; continue 'dispatch;
            }
            0x82C60350 => {
    //   block [0x82C60350..0x82C60370)
	// 82C60350: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C60354: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60358: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C6035C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C60360: 480036D1  bl 0x82c63a30
	ctx.lr = 0x82C60364;
	sub_82C63A30(ctx, base);
	// 82C60364: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60368: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6036C: 480490E4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C60370 size=24
    let mut pc: u32 = 0x82C60370;
    'dispatch: loop {
        match pc {
            0x82C60370 => {
    //   block [0x82C60370..0x82C60388)
	// 82C60370: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60378: 409A0010  bne cr6, 0x82c60388
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C60388);
		return;
	}
	// 82C6037C: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60380: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C60398 size=160
    let mut pc: u32 = 0x82C60398;
    'dispatch: loop {
        match pc {
            0x82C60398 => {
    //   block [0x82C60398..0x82C603D4)
	// 82C60398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6039C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C603A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C603A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C603A8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C603AC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C603B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C603B4: 409A0020  bne cr6, 0x82c603d4
	if !ctx.cr[6].eq {
	pc = 0x82C603D4; continue 'dispatch;
	}
	// 82C603B8: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C603BC: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C603C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C603C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C603C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C603CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C603D0: 4E800020  blr
	return;
            }
            0x82C603D4 => {
    //   block [0x82C603D4..0x82C6041C)
	// 82C603D4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C603D8: 41980044  blt cr6, 0x82c6041c
	if ctx.cr[6].lt {
	pc = 0x82C6041C; continue 'dispatch;
	}
	// 82C603DC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C603E0: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C603E4: 40980038  bge cr6, 0x82c6041c
	if !ctx.cr[6].lt {
	pc = 0x82C6041C; continue 'dispatch;
	}
	// 82C603E8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C603EC: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C603F0: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C603F4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C603F8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C603FC: 4800297D  bl 0x82c62d78
	ctx.lr = 0x82C60400;
	sub_82C62D78(ctx, base);
	// 82C60400: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C60404: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60408: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6040C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60418: 4E800020  blr
	return;
            }
            0x82C6041C => {
    //   block [0x82C6041C..0x82C60438)
	// 82C6041C: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60420: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60424: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60428: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6042C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C60438 size=160
    let mut pc: u32 = 0x82C60438;
    'dispatch: loop {
        match pc {
            0x82C60438 => {
    //   block [0x82C60438..0x82C60474)
	// 82C60438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6043C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C60444: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60448: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6044C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C60450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60454: 409A0020  bne cr6, 0x82c60474
	if !ctx.cr[6].eq {
	pc = 0x82C60474; continue 'dispatch;
	}
	// 82C60458: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C6045C: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60460: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6046C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60470: 4E800020  blr
	return;
            }
            0x82C60474 => {
    //   block [0x82C60474..0x82C604BC)
	// 82C60474: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C60478: 41980044  blt cr6, 0x82c604bc
	if ctx.cr[6].lt {
	pc = 0x82C604BC; continue 'dispatch;
	}
	// 82C6047C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60480: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60484: 40980038  bge cr6, 0x82c604bc
	if !ctx.cr[6].lt {
	pc = 0x82C604BC; continue 'dispatch;
	}
	// 82C60488: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6048C: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60490: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C60494: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60498: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C6049C: 480029AD  bl 0x82c62e48
	ctx.lr = 0x82C604A0;
	sub_82C62E48(ctx, base);
	// 82C604A0: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C604A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C604A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C604AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C604B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C604B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C604B8: 4E800020  blr
	return;
            }
            0x82C604BC => {
    //   block [0x82C604BC..0x82C604D8)
	// 82C604BC: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C604C0: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C604C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C604C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C604CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C604D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C604D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C604D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C604D8 size=140
    let mut pc: u32 = 0x82C604D8;
    'dispatch: loop {
        match pc {
            0x82C604D8 => {
    //   block [0x82C604D8..0x82C60508)
	// 82C604D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C604DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C604E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C604E4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C604E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C604EC: 409A001C  bne cr6, 0x82c60508
	if !ctx.cr[6].eq {
	pc = 0x82C60508; continue 'dispatch;
	}
	// 82C604F0: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C604F4: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C604F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C604FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60504: 4E800020  blr
	return;
            }
            0x82C60508 => {
    //   block [0x82C60508..0x82C6054C)
	// 82C60508: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C6050C: 41980040  blt cr6, 0x82c6054c
	if ctx.cr[6].lt {
	pc = 0x82C6054C; continue 'dispatch;
	}
	// 82C60510: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60514: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60518: 40980034  bge cr6, 0x82c6054c
	if !ctx.cr[6].lt {
	pc = 0x82C6054C; continue 'dispatch;
	}
	// 82C6051C: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60520: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60524: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C60528: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C6052C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60530: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C60534: 48002C05  bl 0x82c63138
	ctx.lr = 0x82C60538;
	sub_82C63138(ctx, base);
	// 82C60538: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6053C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60548: 4E800020  blr
	return;
            }
            0x82C6054C => {
    //   block [0x82C6054C..0x82C60564)
	// 82C6054C: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60550: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60554: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6055C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C60568 size=160
    let mut pc: u32 = 0x82C60568;
    'dispatch: loop {
        match pc {
            0x82C60568 => {
    //   block [0x82C60568..0x82C605A4)
	// 82C60568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6056C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C60574: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60578: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6057C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C60580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60584: 409A0020  bne cr6, 0x82c605a4
	if !ctx.cr[6].eq {
	pc = 0x82C605A4; continue 'dispatch;
	}
	// 82C60588: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C6058C: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60590: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60594: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60598: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6059C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C605A0: 4E800020  blr
	return;
            }
            0x82C605A4 => {
    //   block [0x82C605A4..0x82C605EC)
	// 82C605A4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C605A8: 41980044  blt cr6, 0x82c605ec
	if ctx.cr[6].lt {
	pc = 0x82C605EC; continue 'dispatch;
	}
	// 82C605AC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C605B0: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C605B4: 40980038  bge cr6, 0x82c605ec
	if !ctx.cr[6].lt {
	pc = 0x82C605EC; continue 'dispatch;
	}
	// 82C605B8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C605BC: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C605C0: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C605C4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C605C8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C605CC: 48002975  bl 0x82c62f40
	ctx.lr = 0x82C605D0;
	sub_82C62F40(ctx, base);
	// 82C605D0: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C605D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C605D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C605DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C605E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C605E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C605E8: 4E800020  blr
	return;
            }
            0x82C605EC => {
    //   block [0x82C605EC..0x82C60608)
	// 82C605EC: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C605F0: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C605F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C605F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C605FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60600: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60608 size=140
    let mut pc: u32 = 0x82C60608;
    'dispatch: loop {
        match pc {
            0x82C60608 => {
    //   block [0x82C60608..0x82C60638)
	// 82C60608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6060C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60610: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60614: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6061C: 409A001C  bne cr6, 0x82c60638
	if !ctx.cr[6].eq {
	pc = 0x82C60638; continue 'dispatch;
	}
	// 82C60620: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60624: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60628: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6062C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60634: 4E800020  blr
	return;
            }
            0x82C60638 => {
    //   block [0x82C60638..0x82C6067C)
	// 82C60638: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C6063C: 41980040  blt cr6, 0x82c6067c
	if ctx.cr[6].lt {
	pc = 0x82C6067C; continue 'dispatch;
	}
	// 82C60640: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60644: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60648: 40980034  bge cr6, 0x82c6067c
	if !ctx.cr[6].lt {
	pc = 0x82C6067C; continue 'dispatch;
	}
	// 82C6064C: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60650: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60654: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C60658: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C6065C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60660: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C60664: 48002A25  bl 0x82c63088
	ctx.lr = 0x82C60668;
	sub_82C63088(ctx, base);
	// 82C60668: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6066C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60678: 4E800020  blr
	return;
            }
            0x82C6067C => {
    //   block [0x82C6067C..0x82C60694)
	// 82C6067C: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60680: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60684: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6068C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C60698 size=160
    let mut pc: u32 = 0x82C60698;
    'dispatch: loop {
        match pc {
            0x82C60698 => {
    //   block [0x82C60698..0x82C606D4)
	// 82C60698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6069C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C606A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C606A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C606A8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C606AC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C606B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C606B4: 409A0020  bne cr6, 0x82c606d4
	if !ctx.cr[6].eq {
	pc = 0x82C606D4; continue 'dispatch;
	}
	// 82C606B8: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C606BC: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C606C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C606C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C606C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C606CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C606D0: 4E800020  blr
	return;
            }
            0x82C606D4 => {
    //   block [0x82C606D4..0x82C6071C)
	// 82C606D4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C606D8: 41980044  blt cr6, 0x82c6071c
	if ctx.cr[6].lt {
	pc = 0x82C6071C; continue 'dispatch;
	}
	// 82C606DC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C606E0: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C606E4: 40980038  bge cr6, 0x82c6071c
	if !ctx.cr[6].lt {
	pc = 0x82C6071C; continue 'dispatch;
	}
	// 82C606E8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C606EC: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C606F0: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C606F4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C606F8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C606FC: 4830C65D  bl 0x82f6cd58
	ctx.lr = 0x82C60700;
	sub_82F6CD58(ctx, base);
	// 82C60700: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C60704: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60708: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6070C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60718: 4E800020  blr
	return;
            }
            0x82C6071C => {
    //   block [0x82C6071C..0x82C60738)
	// 82C6071C: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60720: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60724: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6072C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60738 size=148
    let mut pc: u32 = 0x82C60738;
    'dispatch: loop {
        match pc {
            0x82C60738 => {
    //   block [0x82C60738..0x82C60770)
	// 82C60738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6073C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60740: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60744: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60748: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C6074C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C60750: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C60754: 409A001C  bne cr6, 0x82c60770
	if !ctx.cr[6].eq {
	pc = 0x82C60770; continue 'dispatch;
	}
	// 82C60758: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C6075C: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60760: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6076C: 4E800020  blr
	return;
            }
            0x82C60770 => {
    //   block [0x82C60770..0x82C607B4)
	// 82C60770: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C60774: 41980040  blt cr6, 0x82c607b4
	if ctx.cr[6].lt {
	pc = 0x82C607B4; continue 'dispatch;
	}
	// 82C60778: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6077C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C60780: 40980034  bge cr6, 0x82c607b4
	if !ctx.cr[6].lt {
	pc = 0x82C607B4; continue 'dispatch;
	}
	// 82C60784: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C60788: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6078C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C60790: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82C60794: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60798: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C6079C: 48002B2D  bl 0x82c632c8
	ctx.lr = 0x82C607A0;
	sub_82C632C8(ctx, base);
	// 82C607A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C607A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C607A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C607AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C607B0: 4E800020  blr
	return;
            }
            0x82C607B4 => {
    //   block [0x82C607B4..0x82C607CC)
	// 82C607B4: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C607B8: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C607BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C607C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C607C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C607C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C607D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C607D0 size=160
    let mut pc: u32 = 0x82C607D0;
    'dispatch: loop {
        match pc {
            0x82C607D0 => {
    //   block [0x82C607D0..0x82C6080C)
	// 82C607D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C607D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C607D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C607DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C607E0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C607E4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C607E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C607EC: 409A0020  bne cr6, 0x82c6080c
	if !ctx.cr[6].eq {
	pc = 0x82C6080C; continue 'dispatch;
	}
	// 82C607F0: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C607F4: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C607F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C607FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60804: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60808: 4E800020  blr
	return;
            }
            0x82C6080C => {
    //   block [0x82C6080C..0x82C60854)
	// 82C6080C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C60810: 41980044  blt cr6, 0x82c60854
	if ctx.cr[6].lt {
	pc = 0x82C60854; continue 'dispatch;
	}
	// 82C60814: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60818: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C6081C: 40980038  bge cr6, 0x82c60854
	if !ctx.cr[6].lt {
	pc = 0x82C60854; continue 'dispatch;
	}
	// 82C60820: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60824: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60828: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C6082C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60830: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C60834: 4800243D  bl 0x82c62c70
	ctx.lr = 0x82C60838;
	sub_82C62C70(ctx, base);
	// 82C60838: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C6083C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60840: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6084C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60850: 4E800020  blr
	return;
            }
            0x82C60854 => {
    //   block [0x82C60854..0x82C60870)
	// 82C60854: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60858: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C6085C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60868: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6086C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60870 size=136
    let mut pc: u32 = 0x82C60870;
    'dispatch: loop {
        match pc {
            0x82C60870 => {
    //   block [0x82C60870..0x82C608A0)
	// 82C60870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60878: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6087C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60884: 409A001C  bne cr6, 0x82c608a0
	if !ctx.cr[6].eq {
	pc = 0x82C608A0; continue 'dispatch;
	}
	// 82C60888: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C6088C: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60890: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6089C: 4E800020  blr
	return;
            }
            0x82C608A0 => {
    //   block [0x82C608A0..0x82C608E0)
	// 82C608A0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C608A4: 4198003C  blt cr6, 0x82c608e0
	if ctx.cr[6].lt {
	pc = 0x82C608E0; continue 'dispatch;
	}
	// 82C608A8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C608AC: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C608B0: 40980030  bge cr6, 0x82c608e0
	if !ctx.cr[6].lt {
	pc = 0x82C608E0; continue 'dispatch;
	}
	// 82C608B4: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C608B8: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C608BC: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C608C0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C608C4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C608C8: 480023C9  bl 0x82c62c90
	ctx.lr = 0x82C608CC;
	sub_82C62C90(ctx, base);
	// 82C608CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C608D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C608D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C608D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C608DC: 4E800020  blr
	return;
            }
            0x82C608E0 => {
    //   block [0x82C608E0..0x82C608F8)
	// 82C608E0: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C608E4: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C608E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C608EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C608F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C608F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C608F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C608F8 size=160
    let mut pc: u32 = 0x82C608F8;
    'dispatch: loop {
        match pc {
            0x82C608F8 => {
    //   block [0x82C608F8..0x82C60934)
	// 82C608F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C608FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C60904: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60908: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6090C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C60910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60914: 409A0020  bne cr6, 0x82c60934
	if !ctx.cr[6].eq {
	pc = 0x82C60934; continue 'dispatch;
	}
	// 82C60918: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C6091C: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60920: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6092C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60930: 4E800020  blr
	return;
            }
            0x82C60934 => {
    //   block [0x82C60934..0x82C6097C)
	// 82C60934: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C60938: 41980044  blt cr6, 0x82c6097c
	if ctx.cr[6].lt {
	pc = 0x82C6097C; continue 'dispatch;
	}
	// 82C6093C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60940: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60944: 40980038  bge cr6, 0x82c6097c
	if !ctx.cr[6].lt {
	pc = 0x82C6097C; continue 'dispatch;
	}
	// 82C60948: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6094C: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60950: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C60954: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60958: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C6095C: 4800234D  bl 0x82c62ca8
	ctx.lr = 0x82C60960;
	sub_82C62CA8(ctx, base);
	// 82C60960: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C60964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60968: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6096C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60978: 4E800020  blr
	return;
            }
            0x82C6097C => {
    //   block [0x82C6097C..0x82C60998)
	// 82C6097C: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60980: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60984: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6098C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60998 size=136
    let mut pc: u32 = 0x82C60998;
    'dispatch: loop {
        match pc {
            0x82C60998 => {
    //   block [0x82C60998..0x82C609C8)
	// 82C60998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6099C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C609A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C609A4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C609A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C609AC: 409A001C  bne cr6, 0x82c609c8
	if !ctx.cr[6].eq {
	pc = 0x82C609C8; continue 'dispatch;
	}
	// 82C609B0: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C609B4: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C609B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C609BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C609C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C609C4: 4E800020  blr
	return;
            }
            0x82C609C8 => {
    //   block [0x82C609C8..0x82C60A08)
	// 82C609C8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C609CC: 4198003C  blt cr6, 0x82c60a08
	if ctx.cr[6].lt {
	pc = 0x82C60A08; continue 'dispatch;
	}
	// 82C609D0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C609D4: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C609D8: 40980030  bge cr6, 0x82c60a08
	if !ctx.cr[6].lt {
	pc = 0x82C60A08; continue 'dispatch;
	}
	// 82C609DC: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C609E0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C609E4: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C609E8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C609EC: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C609F0: 480022D9  bl 0x82c62cc8
	ctx.lr = 0x82C609F4;
	sub_82C62CC8(ctx, base);
	// 82C609F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C609F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C609FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60A00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60A04: 4E800020  blr
	return;
            }
            0x82C60A08 => {
    //   block [0x82C60A08..0x82C60A20)
	// 82C60A08: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60A0C: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60A10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60A1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C60A20 size=160
    let mut pc: u32 = 0x82C60A20;
    'dispatch: loop {
        match pc {
            0x82C60A20 => {
    //   block [0x82C60A20..0x82C60A5C)
	// 82C60A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60A28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C60A2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60A30: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60A34: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C60A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60A3C: 409A0020  bne cr6, 0x82c60a5c
	if !ctx.cr[6].eq {
	pc = 0x82C60A5C; continue 'dispatch;
	}
	// 82C60A40: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60A44: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60A48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60A4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60A50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60A54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60A58: 4E800020  blr
	return;
            }
            0x82C60A5C => {
    //   block [0x82C60A5C..0x82C60AA4)
	// 82C60A5C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C60A60: 41980044  blt cr6, 0x82c60aa4
	if ctx.cr[6].lt {
	pc = 0x82C60AA4; continue 'dispatch;
	}
	// 82C60A64: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60A68: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60A6C: 40980038  bge cr6, 0x82c60aa4
	if !ctx.cr[6].lt {
	pc = 0x82C60AA4; continue 'dispatch;
	}
	// 82C60A70: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60A74: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60A78: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C60A7C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60A80: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C60A84: 4800225D  bl 0x82c62ce0
	ctx.lr = 0x82C60A88;
	sub_82C62CE0(ctx, base);
	// 82C60A88: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C60A8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60A90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60A94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60A98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60A9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60AA0: 4E800020  blr
	return;
            }
            0x82C60AA4 => {
    //   block [0x82C60AA4..0x82C60AC0)
	// 82C60AA4: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60AA8: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60AAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60AB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60AB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60AB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60ABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60AC0 size=160
    let mut pc: u32 = 0x82C60AC0;
    'dispatch: loop {
        match pc {
            0x82C60AC0 => {
    //   block [0x82C60AC0..0x82C60AFC)
	// 82C60AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60AC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C60ACC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60AD0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60AD4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C60AD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60ADC: 409A0020  bne cr6, 0x82c60afc
	if !ctx.cr[6].eq {
	pc = 0x82C60AFC; continue 'dispatch;
	}
	// 82C60AE0: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60AE4: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60AE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60AEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60AF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60AF8: 4E800020  blr
	return;
            }
            0x82C60AFC => {
    //   block [0x82C60AFC..0x82C60B44)
	// 82C60AFC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C60B00: 41980044  blt cr6, 0x82c60b44
	if ctx.cr[6].lt {
	pc = 0x82C60B44; continue 'dispatch;
	}
	// 82C60B04: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60B08: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60B0C: 40980038  bge cr6, 0x82c60b44
	if !ctx.cr[6].lt {
	pc = 0x82C60B44; continue 'dispatch;
	}
	// 82C60B10: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60B14: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60B18: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C60B1C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60B20: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C60B24: 48002105  bl 0x82c62c28
	ctx.lr = 0x82C60B28;
	sub_82C62C28(ctx, base);
	// 82C60B28: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C60B2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60B30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60B34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60B38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60B3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60B40: 4E800020  blr
	return;
            }
            0x82C60B44 => {
    //   block [0x82C60B44..0x82C60B60)
	// 82C60B44: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60B48: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60B4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60B60 size=152
    let mut pc: u32 = 0x82C60B60;
    'dispatch: loop {
        match pc {
            0x82C60B60 => {
    //   block [0x82C60B60..0x82C60B94)
	// 82C60B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60B68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C60B6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C60B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60B74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C60B78: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C60B7C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60B80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C60B84: 409A0010  bne cr6, 0x82c60b94
	if !ctx.cr[6].eq {
	pc = 0x82C60B94; continue 'dispatch;
	}
	// 82C60B88: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60B8C: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60B90: 48000050  b 0x82c60be0
	pc = 0x82C60BE0; continue 'dispatch;
            }
            0x82C60B94 => {
    //   block [0x82C60B94..0x82C60BD8)
	// 82C60B94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C60B98: 41980040  blt cr6, 0x82c60bd8
	if ctx.cr[6].lt {
	pc = 0x82C60BD8; continue 'dispatch;
	}
	// 82C60B9C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60BA0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C60BA4: 40980034  bge cr6, 0x82c60bd8
	if !ctx.cr[6].lt {
	pc = 0x82C60BD8; continue 'dispatch;
	}
	// 82C60BA8: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C60BAC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60BB0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C60BB4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82C60BB8: 557E1838  slwi r30, r11, 3
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82C60BBC: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C60BC0: 48001FB1  bl 0x82c62b70
	ctx.lr = 0x82C60BC4;
	sub_82C62B70(ctx, base);
	// 82C60BC4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60BC8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C60BCC: 4800241D  bl 0x82c62fe8
	ctx.lr = 0x82C60BD0;
	sub_82C62FE8(ctx, base);
	// 82C60BD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60BD4: 4800000C  b 0x82c60be0
	pc = 0x82C60BE0; continue 'dispatch;
            }
            0x82C60BD8 => {
    //   block [0x82C60BD8..0x82C60BE0)
	// 82C60BD8: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60BDC: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	pc = 0x82C60BE0; continue 'dispatch;
            }
            0x82C60BE0 => {
    //   block [0x82C60BE0..0x82C60BF8)
	// 82C60BE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C60BE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60BE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60BEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C60BF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60BF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C60BF8 size=168
    let mut pc: u32 = 0x82C60BF8;
    'dispatch: loop {
        match pc {
            0x82C60BF8 => {
    //   block [0x82C60BF8..0x82C60C38)
	// 82C60BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60C00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C60C04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60C08: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60C0C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C60C10: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C60C14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C60C18: 409A0020  bne cr6, 0x82c60c38
	if !ctx.cr[6].eq {
	pc = 0x82C60C38; continue 'dispatch;
	}
	// 82C60C1C: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60C20: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60C24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60C28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60C2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60C30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60C34: 4E800020  blr
	return;
            }
            0x82C60C38 => {
    //   block [0x82C60C38..0x82C60C84)
	// 82C60C38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C60C3C: 41980048  blt cr6, 0x82c60c84
	if ctx.cr[6].lt {
	pc = 0x82C60C84; continue 'dispatch;
	}
	// 82C60C40: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60C44: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C60C48: 4098003C  bge cr6, 0x82c60c84
	if !ctx.cr[6].lt {
	pc = 0x82C60C84; continue 'dispatch;
	}
	// 82C60C4C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C60C50: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60C54: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C60C58: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82C60C5C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60C60: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C60C64: 480025D5  bl 0x82c63238
	ctx.lr = 0x82C60C68;
	sub_82C63238(ctx, base);
	// 82C60C68: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C60C6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60C70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60C7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60C80: 4E800020  blr
	return;
            }
            0x82C60C84 => {
    //   block [0x82C60C84..0x82C60CA0)
	// 82C60C84: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60C88: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60C8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60C90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60C94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60C98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60CA0 size=144
    let mut pc: u32 = 0x82C60CA0;
    'dispatch: loop {
        match pc {
            0x82C60CA0 => {
    //   block [0x82C60CA0..0x82C60CD4)
	// 82C60CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60CA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60CAC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C60CB0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C60CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C60CB8: 409A001C  bne cr6, 0x82c60cd4
	if !ctx.cr[6].eq {
	pc = 0x82C60CD4; continue 'dispatch;
	}
	// 82C60CBC: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60CC0: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C60CC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60CC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60CCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60CD0: 4E800020  blr
	return;
            }
            0x82C60CD4 => {
    //   block [0x82C60CD4..0x82C60D18)
	// 82C60CD4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C60CD8: 41980040  blt cr6, 0x82c60d18
	if ctx.cr[6].lt {
	pc = 0x82C60D18; continue 'dispatch;
	}
	// 82C60CDC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60CE0: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60CE4: 40980034  bge cr6, 0x82c60d18
	if !ctx.cr[6].lt {
	pc = 0x82C60D18; continue 'dispatch;
	}
	// 82C60CE8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60CEC: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60CF0: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82C60CF4: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C60CF8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C60CFC: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C60D00: 48001E69  bl 0x82c62b68
	ctx.lr = 0x82C60D04;
	sub_82C62B68(ctx, base);
	// 82C60D04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C60D08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60D14: 4E800020  blr
	return;
            }
            0x82C60D18 => {
    //   block [0x82C60D18..0x82C60D30)
	// 82C60D18: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60D1C: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C60D20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C60D24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60D28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60D2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60D30 size=80
    let mut pc: u32 = 0x82C60D30;
    'dispatch: loop {
        match pc {
            0x82C60D30 => {
    //   block [0x82C60D30..0x82C60D54)
	// 82C60D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60D34: 480486D9  bl 0x82ca940c
	ctx.lr = 0x82C60D38;
	sub_82CA93D0(ctx, base);
	// 82C60D38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60D3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C60D40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C60D44: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60D48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C60D4C: 4099002C  ble cr6, 0x82c60d78
	if !ctx.cr[6].gt {
	pc = 0x82C60D78; continue 'dispatch;
	}
	// 82C60D50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C60D54; continue 'dispatch;
            }
            0x82C60D54 => {
    //   block [0x82C60D54..0x82C60D78)
	// 82C60D54: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60D58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C60D5C: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C60D60: 48001E11  bl 0x82c62b70
	ctx.lr = 0x82C60D64;
	sub_82C62B70(ctx, base);
	// 82C60D64: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60D68: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C60D6C: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 82C60D70: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60D74: 4198FFE0  blt cr6, 0x82c60d54
	if ctx.cr[6].lt {
	pc = 0x82C60D54; continue 'dispatch;
	}
	pc = 0x82C60D78; continue 'dispatch;
            }
            0x82C60D78 => {
    //   block [0x82C60D78..0x82C60D80)
	// 82C60D78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C60D7C: 480486E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60D80 size=96
    let mut pc: u32 = 0x82C60D80;
    'dispatch: loop {
        match pc {
            0x82C60D80 => {
    //   block [0x82C60D80..0x82C60DA4)
	// 82C60D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60D84: 48048689  bl 0x82ca940c
	ctx.lr = 0x82C60D88;
	sub_82CA93D0(ctx, base);
	// 82C60D88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60D8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C60D90: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C60D94: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60D98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C60D9C: 4099003C  ble cr6, 0x82c60dd8
	if !ctx.cr[6].gt {
	pc = 0x82C60DD8; continue 'dispatch;
	}
	// 82C60DA0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C60DA4; continue 'dispatch;
            }
            0x82C60DA4 => {
    //   block [0x82C60DA4..0x82C60DD8)
	// 82C60DA4: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60DA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C60DAC: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C60DB0: 48001E31  bl 0x82c62be0
	ctx.lr = 0x82C60DB4;
	sub_82C62BE0(ctx, base);
	// 82C60DB4: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C60DB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C60DBC: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C60DC0: 48001DD1  bl 0x82c62b90
	ctx.lr = 0x82C60DC4;
	sub_82C62B90(ctx, base);
	// 82C60DC4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C60DC8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C60DCC: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 82C60DD0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C60DD4: 4198FFD0  blt cr6, 0x82c60da4
	if ctx.cr[6].lt {
	pc = 0x82C60DA4; continue 'dispatch;
	}
	pc = 0x82C60DD8; continue 'dispatch;
            }
            0x82C60DD8 => {
    //   block [0x82C60DD8..0x82C60DE0)
	// 82C60DD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C60DDC: 48048680  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C60E00 size=388
    let mut pc: u32 = 0x82C60E00;
    'dispatch: loop {
        match pc {
            0x82C60E00 => {
    //   block [0x82C60E00..0x82C60E5C)
	// 82C60E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60E04: 48048605  bl 0x82ca9408
	ctx.lr = 0x82C60E08;
	sub_82CA93D0(ctx, base);
	// 82C60E08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60E0C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C60E10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C60E14: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 82C60E18: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82C60E1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C60E20: 2B040006  cmplwi cr6, r4, 6
	ctx.cr[6].compare_u32(ctx.r[4].u32, 6 as u32, &mut ctx.xer);
	// 82C60E24: 41990150  bgt cr6, 0x82c60f74
	if ctx.cr[6].gt {
	pc = 0x82C60F74; continue 'dispatch;
	}
	// 82C60E28: 3D8082C6  lis r12, -0x7d3a
	ctx.r[12].s64 = -2100953088;
	// 82C60E2C: 398C0E40  addi r12, r12, 0xe40
	ctx.r[12].s64 = ctx.r[12].s64 + 3648;
	// 82C60E30: 5480103A  slwi r0, r4, 2
	ctx.r[0].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82C60E34: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82C60E38: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82C60E3C: 4E800420  bctr
	match ctx.r[4].u64 {
		0 => {
	pc = 0x82C60E5C; continue 'dispatch;
		},
		1 => {
	pc = 0x82C60E84; continue 'dispatch;
		},
		2 => {
	pc = 0x82C60ECC; continue 'dispatch;
		},
		3 => {
	pc = 0x82C60EE0; continue 'dispatch;
		},
		4 => {
	pc = 0x82C60F04; continue 'dispatch;
		},
		5 => {
	pc = 0x82C60F28; continue 'dispatch;
		},
		6 => {
	pc = 0x82C60F54; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82C60E40: 82C60E5C  lwz r22, 0xe5c(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3676 as u32) ) } as u64;
	// 82C60E44: 82C60E84  lwz r22, 0xe84(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3716 as u32) ) } as u64;
	// 82C60E48: 82C60ECC  lwz r22, 0xecc(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3788 as u32) ) } as u64;
	// 82C60E4C: 82C60EE0  lwz r22, 0xee0(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3808 as u32) ) } as u64;
	// 82C60E50: 82C60F04  lwz r22, 0xf04(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3844 as u32) ) } as u64;
	// 82C60E54: 82C60F28  lwz r22, 0xf28(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3880 as u32) ) } as u64;
	// 82C60E58: 82C60F54  lwz r22, 0xf54(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3924 as u32) ) } as u64;
            }
            0x82C60E5C => {
    //   block [0x82C60E5C..0x82C60E84)
	// 82C60E5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C60E60: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C60E64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C60E68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60E6C: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C60E70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C60E74: 4E800421  bctrl
	ctx.lr = 0x82C60E78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C60E78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C60E7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C60E80: 480485D8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C60E84 => {
    //   block [0x82C60E84..0x82C60ECC)
	// 82C60E84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C60E88: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82C60E8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C60E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60E94: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C60E98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C60E9C: 4E800421  bctrl
	ctx.lr = 0x82C60EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C60EA0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C60EA4: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C60EA8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C60EAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C60EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60EB4: 81090048  lwz r8, 0x48(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C60EB8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C60EBC: 4E800421  bctrl
	ctx.lr = 0x82C60EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C60EC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C60EC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C60EC8: 48048590  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C60ECC => {
    //   block [0x82C60ECC..0x82C60EE0)
	// 82C60ECC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C60ED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C60ED4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C60ED8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C60EDC: 4804857C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C60EE0 => {
    //   block [0x82C60EE0..0x82C60F04)
	// 82C60EE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C60EE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C60EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60EEC: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C60EF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C60EF4: 4E800421  bctrl
	ctx.lr = 0x82C60EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C60EF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C60EFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C60F00: 48048558  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C60F04 => {
    //   block [0x82C60F04..0x82C60F28)
	// 82C60F04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C60F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C60F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60F10: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C60F14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C60F18: 4E800421  bctrl
	ctx.lr = 0x82C60F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C60F1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C60F20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C60F24: 48048534  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C60F28 => {
    //   block [0x82C60F28..0x82C60F54)
	// 82C60F28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C60F2C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82C60F30: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82C60F34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C60F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60F3C: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C60F40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C60F44: 4E800421  bctrl
	ctx.lr = 0x82C60F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C60F48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C60F4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C60F50: 48048508  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C60F54 => {
    //   block [0x82C60F54..0x82C60F74)
	// 82C60F54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C60F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C60F5C: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C60F60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C60F64: 4E800421  bctrl
	ctx.lr = 0x82C60F68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C60F68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C60F6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C60F70: 480484E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C60F74 => {
    //   block [0x82C60F74..0x82C60F84)
	// 82C60F74: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C60F78: 60630004  ori r3, r3, 4
	ctx.r[3].u64 = ctx.r[3].u64 | 4;
	// 82C60F7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C60F80: 480484D8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60F88 size=72
    let mut pc: u32 = 0x82C60F88;
    'dispatch: loop {
        match pc {
            0x82C60F88 => {
    //   block [0x82C60F88..0x82C60FD0)
	// 82C60F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C60F90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C60F94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C60F98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60F9C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C60FA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C60FA4: 38BFFFFF  addi r5, r31, -1
	ctx.r[5].s64 = ctx.r[31].s64 + -1;
	// 82C60FA8: 4B66C101  bl 0x822cd0a8
	ctx.lr = 0x82C60FAC;
	sub_822CD0A8(ctx, base);
	// 82C60FAC: 7D7EFA14  add r11, r30, r31
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 82C60FB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C60FB4: 994BFFFF  stb r10, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[10].u8 ) };
	// 82C60FB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C60FBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C60FC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C60FC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C60FC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C60FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C60FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C60FD8 size=240
    let mut pc: u32 = 0x82C60FD8;
    'dispatch: loop {
        match pc {
            0x82C60FD8 => {
    //   block [0x82C60FD8..0x82C61038)
	// 82C60FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C60FDC: 48048429  bl 0x82ca9404
	ctx.lr = 0x82C60FE0;
	sub_82CA93D0(ctx, base);
	// 82C60FE0: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82C60FE4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C60FE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C60FEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C60FF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C60FF4: 394BD7F8  addi r10, r11, -0x2808
	ctx.r[10].s64 = ctx.r[11].s64 + -10248;
	// 82C60FF8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82C60FFC: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C61000: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82C61004: 48002F35  bl 0x82c63f38
	ctx.lr = 0x82C61008;
	sub_82C63F38(ctx, base);
	// 82C61008: 3D200666  lis r9, 0x666
	ctx.r[9].s64 = 107347968;
	// 82C6100C: 93DC0018  stw r30, 0x18(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82C61010: 61286666  ori r8, r9, 0x6666
	ctx.r[8].u64 = ctx.r[9].u64 | 26214;
	// 82C61014: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C61018: 41990020  bgt cr6, 0x82c61038
	if ctx.cr[6].gt {
	pc = 0x82C61038; continue 'dispatch;
	}
	// 82C6101C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C61020: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82C61024: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C61028: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6102C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C61030: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C61034: 40990008  ble cr6, 0x82c6103c
	if !ctx.cr[6].gt {
	pc = 0x82C6103C; continue 'dispatch;
	}
	pc = 0x82C61038; continue 'dispatch;
            }
            0x82C61038 => {
    //   block [0x82C61038..0x82C6103C)
	// 82C61038: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82C6103C; continue 'dispatch;
            }
            0x82C6103C => {
    //   block [0x82C6103C..0x82C6107C)
	// 82C6103C: 4B68917D  bl 0x822ea1b8
	ctx.lr = 0x82C61040;
	sub_822EA1B8(ctx, base);
	// 82C61040: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C61044: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C61048: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6104C: 419A0030  beq cr6, 0x82c6107c
	if ctx.cr[6].eq {
	pc = 0x82C6107C; continue 'dispatch;
	}
	// 82C61050: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C61054: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 82C61058: 3D6082C6  lis r11, -0x7d3a
	ctx.r[11].s64 = -2100953088;
	// 82C6105C: 3D4082C6  lis r10, -0x7d3a
	ctx.r[10].s64 = -2100953088;
	// 82C61060: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C61064: 38EB2B48  addi r7, r11, 0x2b48
	ctx.r[7].s64 = ctx.r[11].s64 + 11080;
	// 82C61068: 38CA3280  addi r6, r10, 0x3280
	ctx.r[6].s64 = ctx.r[10].s64 + 12928;
	// 82C6106C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C61070: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 82C61074: 4804D96D  bl 0x82cae9e0
	ctx.lr = 0x82C61078;
	sub_82CAE9E0(ctx, base);
	// 82C61078: 48000008  b 0x82c61080
	pc = 0x82C61080; continue 'dispatch;
            }
            0x82C6107C => {
    //   block [0x82C6107C..0x82C61080)
	// 82C6107C: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	pc = 0x82C61080; continue 'dispatch;
            }
            0x82C61080 => {
    //   block [0x82C61080..0x82C610C8)
	// 82C61080: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C61084: 93BC001C  stw r29, 0x1c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82C61088: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6108C: 937C0014  stw r27, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 82C61090: 917C0020  stw r11, 0x20(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82C61094: 937C0024  stw r27, 0x24(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[27].u32 ) };
	// 82C61098: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82C6109C: 480483B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C610A0: 3BECFF70  addi r31, r12, -0x90
	ctx.r[31].s64 = ctx.r[12].s64 + -144;
	// 82C610A4: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C610A8: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C610AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C610B0: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C610B4: 4BBE46FD  bl 0x828457b0
	ctx.lr = 0x82C610B8;
	sub_828457B0(ctx, base);
	// 82C610B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C610BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C610C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C610C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C610C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C610C8 size=112
    let mut pc: u32 = 0x82C610C8;
    'dispatch: loop {
        match pc {
            0x82C610C8 => {
    //   block [0x82C610C8..0x82C610F8)
	// 82C610C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C610CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C610D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C610D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C610D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C610DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C610E0: 392BD7F8  addi r9, r11, -0x2808
	ctx.r[9].s64 = ctx.r[11].s64 + -10248;
	// 82C610E4: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C610E8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C610EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C610F0: 419A0008  beq cr6, 0x82c610f8
	if ctx.cr[6].eq {
	pc = 0x82C610F8; continue 'dispatch;
	}
	// 82C610F4: 4BFFF08D  bl 0x82c60180
	ctx.lr = 0x82C610F8;
	sub_82C60180(ctx, base);
	pc = 0x82C610F8; continue 'dispatch;
            }
            0x82C610F8 => {
    //   block [0x82C610F8..0x82C61124)
	// 82C610F8: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C610FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C61100: 419A0024  beq cr6, 0x82c61124
	if ctx.cr[6].eq {
	pc = 0x82C61124; continue 'dispatch;
	}
	// 82C61104: 3D6082C6  lis r11, -0x7d3a
	ctx.r[11].s64 = -2100953088;
	// 82C61108: 80A3FFFC  lwz r5, -4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C6110C: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 82C61110: 38CB2B48  addi r6, r11, 0x2b48
	ctx.r[6].s64 = ctx.r[11].s64 + 11080;
	// 82C61114: 3BE3FFFC  addi r31, r3, -4
	ctx.r[31].s64 = ctx.r[3].s64 + -4;
	// 82C61118: 4804D7A1  bl 0x82cae8b8
	ctx.lr = 0x82C6111C;
	sub_82CAE8B8(ctx, base);
	// 82C6111C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C61120: 4BBE4691  bl 0x828457b0
	ctx.lr = 0x82C61124;
	sub_828457B0(ctx, base);
	pc = 0x82C61124; continue 'dispatch;
            }
            0x82C61124 => {
    //   block [0x82C61124..0x82C61138)
	// 82C61124: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C61128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6112C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C61130: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C61134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C61138 size=148
    let mut pc: u32 = 0x82C61138;
    'dispatch: loop {
        match pc {
            0x82C61138 => {
    //   block [0x82C61138..0x82C61170)
	// 82C61138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6113C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C61140: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61144: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C61148: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82C6114C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C61150: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C61154: 409A001C  bne cr6, 0x82c61170
	if !ctx.cr[6].eq {
	pc = 0x82C61170; continue 'dispatch;
	}
	// 82C61158: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C6115C: 60630008  ori r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u64 | 8;
	// 82C61160: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C61164: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C61168: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6116C: 4E800020  blr
	return;
            }
            0x82C61170 => {
    //   block [0x82C61170..0x82C611B4)
	// 82C61170: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C61174: 41980040  blt cr6, 0x82c611b4
	if ctx.cr[6].lt {
	pc = 0x82C611B4; continue 'dispatch;
	}
	// 82C61178: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6117C: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C61180: 40980034  bge cr6, 0x82c611b4
	if !ctx.cr[6].lt {
	pc = 0x82C611B4; continue 'dispatch;
	}
	// 82C61184: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C61188: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6118C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C61190: 7D445214  add r10, r4, r10
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 82C61194: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C61198: 7C89582E  lwzx r4, r9, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C6119C: 4BFFFDED  bl 0x82c60f88
	ctx.lr = 0x82C611A0;
	sub_82C60F88(ctx, base);
	// 82C611A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C611A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C611A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C611AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C611B0: 4E800020  blr
	return;
            }
            0x82C611B4 => {
    //   block [0x82C611B4..0x82C611CC)
	// 82C611B4: 3C602000  lis r3, 0x2000
	ctx.r[3].s64 = 536870912;
	// 82C611B8: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82C611BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C611C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C611C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C611C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C611D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C611D0 size=80
    let mut pc: u32 = 0x82C611D0;
    'dispatch: loop {
        match pc {
            0x82C611D0 => {
    //   block [0x82C611D0..0x82C61208)
	// 82C611D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C611D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C611D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C611DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C611E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C611E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C611E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C611EC: 4BFFFEDD  bl 0x82c610c8
	ctx.lr = 0x82C611F0;
	sub_82C610C8(ctx, base);
	// 82C611F0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C611F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C611F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C611FC: 419A000C  beq cr6, 0x82c61208
	if ctx.cr[6].eq {
	pc = 0x82C61208; continue 'dispatch;
	}
	// 82C61200: 4BBE45B1  bl 0x828457b0
	ctx.lr = 0x82C61204;
	sub_828457B0(ctx, base);
	// 82C61204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C61208; continue 'dispatch;
            }
            0x82C61208 => {
    //   block [0x82C61208..0x82C61220)
	// 82C61208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6120C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C61210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C61214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C61218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6121C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C61220 size=232
    let mut pc: u32 = 0x82C61220;
    'dispatch: loop {
        match pc {
            0x82C61220 => {
    //   block [0x82C61220..0x82C61270)
	// 82C61220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C61224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C61228: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6122C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C61230: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61234: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C61238: 48003511  bl 0x82c64748
	ctx.lr = 0x82C6123C;
	sub_82C64748(ctx, base);
	// 82C6123C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C61240: C01F0128  lfs f0, 0x128(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C61244: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82C61248: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C6124C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82C61250: 409A0020  bne cr6, 0x82c61270
	if !ctx.cr[6].eq {
	pc = 0x82C61270; continue 'dispatch;
	}
	// 82C61254: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C61258: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C6125C: 5565077A  rlwinm r5, r11, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C61260: 48003171  bl 0x82c643d0
	ctx.lr = 0x82C61264;
	sub_82C643D0(ctx, base);
	// 82C61264: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C61268: C02A0C14  lfs f1, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C6126C: 4800001C  b 0x82c61288
	pc = 0x82C61288; continue 'dispatch;
            }
            0x82C61270 => {
    //   block [0x82C61270..0x82C61288)
	// 82C61270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C61274: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C61278: 5545077A  rlwinm r5, r10, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82C6127C: C02B0C14  lfs f1, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C61280: 48003151  bl 0x82c643d0
	ctx.lr = 0x82C61284;
	sub_82C643D0(ctx, base);
	// 82C61284: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82C61288; continue 'dispatch;
            }
            0x82C61288 => {
    //   block [0x82C61288..0x82C61308)
	// 82C61288: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6128C: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C61290: 5525077A  rlwinm r5, r9, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82C61294: 4800313D  bl 0x82c643d0
	ctx.lr = 0x82C61298;
	sub_82C643D0(ctx, base);
	// 82C61298: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C6129C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C612A0: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82C612A4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C612A8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C612AC: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 82C612B0: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 82C612B4: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82C612B8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C612BC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C612C0: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C612C4: 4800310D  bl 0x82c643d0
	ctx.lr = 0x82C612C8;
	sub_82C643D0(ctx, base);
	// 82C612C8: 80DF00BC  lwz r6, 0xbc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C612CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C612D0: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82C612D4: 7CC40034  cntlzw r4, r6
	ctx.r[4].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 82C612D8: 548ADFFE  rlwinm r10, r4, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 82C612DC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82C612E0: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C612E4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82C612E8: FC205818  frsp f1, f11
	ctx.f[1].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82C612EC: 480030E5  bl 0x82c643d0
	ctx.lr = 0x82C612F0;
	sub_82C643D0(ctx, base);
	// 82C612F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C612F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C612F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C612FC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C61300: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C61304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C61308 size=72
    let mut pc: u32 = 0x82C61308;
    'dispatch: loop {
        match pc {
            0x82C61308 => {
    //   block [0x82C61308..0x82C61340)
	// 82C61308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6130C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C61310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61314: C0030128  lfs f0, 0x128(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C61318: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82C6131C: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82C61320: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C61324: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C61328: 916300B8  stw r11, 0xb8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82C6132C: 409A0014  bne cr6, 0x82c61340
	if !ctx.cr[6].eq {
	pc = 0x82C61340; continue 'dispatch;
	}
	// 82C61330: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C61334: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C61338: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6133C: 4E800421  bctrl
	ctx.lr = 0x82C61340;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C61340 => {
    //   block [0x82C61340..0x82C61350)
	// 82C61340: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C61344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C61348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6134C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C61350 size=72
    let mut pc: u32 = 0x82C61350;
    'dispatch: loop {
        match pc {
            0x82C61350 => {
    //   block [0x82C61350..0x82C61398)
	// 82C61350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C61354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C61358: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6135C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61360: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C61364: 3D6082C6  lis r11, -0x7d3a
	ctx.r[11].s64 = -2100953088;
	// 82C61368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6136C: 388B1220  addi r4, r11, 0x1220
	ctx.r[4].s64 = ctx.r[11].s64 + 4640;
	// 82C61370: 48003611  bl 0x82c64980
	ctx.lr = 0x82C61374;
	sub_82C64980(ctx, base);
	// 82C61374: 3D4082C6  lis r10, -0x7d3a
	ctx.r[10].s64 = -2100953088;
	// 82C61378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6137C: 388A1308  addi r4, r10, 0x1308
	ctx.r[4].s64 = ctx.r[10].s64 + 4872;
	// 82C61380: 48003601  bl 0x82c64980
	ctx.lr = 0x82C61384;
	sub_82C64980(ctx, base);
	// 82C61384: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C61388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6138C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C61390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C61394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C61398 size=240
    let mut pc: u32 = 0x82C61398;
    'dispatch: loop {
        match pc {
            0x82C61398 => {
    //   block [0x82C61398..0x82C613F0)
	// 82C61398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6139C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C613A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C613A4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C613A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C613AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C613B0: 48003399  bl 0x82c64748
	ctx.lr = 0x82C613B4;
	sub_82C64748(ctx, base);
	// 82C613B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C613B8: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C613BC: C01F0148  lfs f0, 0x148(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C613C0: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82C613C4: 5545077A  rlwinm r5, r10, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82C613C8: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C613CC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82C613D0: 409A0020  bne cr6, 0x82c613f0
	if !ctx.cr[6].eq {
	pc = 0x82C613F0; continue 'dispatch;
	}
	// 82C613D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C613D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C613DC: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82C613E0: 48002FF1  bl 0x82c643d0
	ctx.lr = 0x82C613E4;
	sub_82C643D0(ctx, base);
	// 82C613E4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C613E8: C0290C14  lfs f1, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C613EC: 4800001C  b 0x82c61408
	pc = 0x82C61408; continue 'dispatch;
            }
            0x82C613F0 => {
    //   block [0x82C613F0..0x82C61408)
	// 82C613F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C613F4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C613F8: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82C613FC: C0290C14  lfs f1, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C61400: 48002FD1  bl 0x82c643d0
	ctx.lr = 0x82C61404;
	sub_82C643D0(ctx, base);
	// 82C61404: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82C61408; continue 'dispatch;
            }
            0x82C61408 => {
    //   block [0x82C61408..0x82C61488)
	// 82C61408: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6140C: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82C61410: 5505077A  rlwinm r5, r8, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82C61414: 48002FBD  bl 0x82c643d0
	ctx.lr = 0x82C61418;
	sub_82C643D0(ctx, base);
	// 82C61418: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C6141C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61420: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82C61424: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C61428: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C6142C: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 82C61430: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 82C61434: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82C61438: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6143C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C61440: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C61444: 48002F8D  bl 0x82c643d0
	ctx.lr = 0x82C61448;
	sub_82C643D0(ctx, base);
	// 82C61448: 80DF00B8  lwz r6, 0xb8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C6144C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61450: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C61454: 7CC40034  cntlzw r4, r6
	ctx.r[4].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 82C61458: 548ADFFE  rlwinm r10, r4, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 82C6145C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82C61460: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C61464: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82C61468: FC205818  frsp f1, f11
	ctx.f[1].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82C6146C: 48002F65  bl 0x82c643d0
	ctx.lr = 0x82C61470;
	sub_82C643D0(ctx, base);
	// 82C61470: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C61474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C61478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6147C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C61480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C61484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C61488 size=64
    let mut pc: u32 = 0x82C61488;
    'dispatch: loop {
        match pc {
            0x82C61488 => {
    //   block [0x82C61488..0x82C614B8)
	// 82C61488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6148C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C61490: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61494: C0030148  lfs f0, 0x148(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C61498: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82C6149C: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82C614A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C614A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C614A8: 916300BC  stw r11, 0xbc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82C614AC: 409A000C  bne cr6, 0x82c614b8
	if !ctx.cr[6].eq {
	pc = 0x82C614B8; continue 'dispatch;
	}
	// 82C614B0: 806300C4  lwz r3, 0xc4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C614B4: 48004695  bl 0x82c65b48
	ctx.lr = 0x82C614B8;
	sub_82C65B48(ctx, base);
	pc = 0x82C614B8; continue 'dispatch;
            }
            0x82C614B8 => {
    //   block [0x82C614B8..0x82C614C8)
	// 82C614B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C614BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C614C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C614C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C614C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C614C8 size=72
    let mut pc: u32 = 0x82C614C8;
    'dispatch: loop {
        match pc {
            0x82C614C8 => {
    //   block [0x82C614C8..0x82C61510)
	// 82C614C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C614CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C614D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C614D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C614D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C614DC: 3D6082C6  lis r11, -0x7d3a
	ctx.r[11].s64 = -2100953088;
	// 82C614E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C614E4: 388B1398  addi r4, r11, 0x1398
	ctx.r[4].s64 = ctx.r[11].s64 + 5016;
	// 82C614E8: 48003499  bl 0x82c64980
	ctx.lr = 0x82C614EC;
	sub_82C64980(ctx, base);
	// 82C614EC: 3D4082C6  lis r10, -0x7d3a
	ctx.r[10].s64 = -2100953088;
	// 82C614F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C614F4: 388A1488  addi r4, r10, 0x1488
	ctx.r[4].s64 = ctx.r[10].s64 + 5256;
	// 82C614F8: 48003489  bl 0x82c64980
	ctx.lr = 0x82C614FC;
	sub_82C64980(ctx, base);
	// 82C614FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C61500: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C61504: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C61508: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6150C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C61510 size=16
    let mut pc: u32 = 0x82C61510;
    'dispatch: loop {
        match pc {
            0x82C61510 => {
    //   block [0x82C61510..0x82C61520)
	// 82C61510: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C61514: 806400C4  lwz r3, 0xc4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C61518: 5565077A  rlwinm r5, r11, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C6151C: 4800446C  b 0x82c65988
	sub_82C65988(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C61520 size=8
    let mut pc: u32 = 0x82C61520;
    'dispatch: loop {
        match pc {
            0x82C61520 => {
    //   block [0x82C61520..0x82C61528)
	// 82C61520: 806400C4  lwz r3, 0xc4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C61524: 4800432C  b 0x82c65850
	sub_82C65850(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C61528 size=16
    let mut pc: u32 = 0x82C61528;
    'dispatch: loop {
        match pc {
            0x82C61528 => {
    //   block [0x82C61528..0x82C61538)
	// 82C61528: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6152C: 806400C4  lwz r3, 0xc4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C61530: 5565077A  rlwinm r5, r11, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C61534: 480043EC  b 0x82c65920
	sub_82C65920(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C61538 size=36
    let mut pc: u32 = 0x82C61538;
    'dispatch: loop {
        match pc {
            0x82C61538 => {
    //   block [0x82C61538..0x82C61554)
	// 82C61538: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C6153C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C61540: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C61544: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C61548: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C6154C: 409A0008  bne cr6, 0x82c61554
	if !ctx.cr[6].eq {
	pc = 0x82C61554; continue 'dispatch;
	}
	// 82C61550: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82C61554; continue 'dispatch;
            }
            0x82C61554 => {
    //   block [0x82C61554..0x82C6155C)
	// 82C61554: 806B00C8  lwz r3, 0xc8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C61558: 48339D80  b 0x82f9b2d8
	sub_82F9B2D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C61560 size=32
    let mut pc: u32 = 0x82C61560;
    'dispatch: loop {
        match pc {
            0x82C61560 => {
    //   block [0x82C61560..0x82C61580)
	// 82C61560: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C61564: 4098001C  bge cr6, 0x82c61580
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82C61580);
		return;
	}
	// 82C61568: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6156C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82C61570: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C61574: 392BA880  addi r9, r11, -0x5780
	ctx.r[9].s64 = ctx.r[11].s64 + -22400;
	// 82C61578: 7C6A482E  lwzx r3, r10, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82C6157C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C615A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C615A0 size=52
    let mut pc: u32 = 0x82C615A0;
    'dispatch: loop {
        match pc {
            0x82C615A0 => {
    //   block [0x82C615A0..0x82C615D4)
	// 82C615A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C615A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C615A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C615AC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C615B0: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82C615B4: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82C615B8: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C615BC: 806B00C8  lwz r3, 0xc8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C615C0: 48004D39  bl 0x82c662f8
	ctx.lr = 0x82C615C4;
	sub_82C662F8(ctx, base);
	// 82C615C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C615C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C615CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C615D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C615D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C615D8 size=52
    let mut pc: u32 = 0x82C615D8;
    'dispatch: loop {
        match pc {
            0x82C615D8 => {
    //   block [0x82C615D8..0x82C6160C)
	// 82C615D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C615DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C615E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C615E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C615E8: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82C615EC: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82C615F0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C615F4: 806B00C8  lwz r3, 0xc8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C615F8: 48004EE9  bl 0x82c664e0
	ctx.lr = 0x82C615FC;
	sub_82C664E0(ctx, base);
	// 82C615FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C61600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C61604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C61608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C61610 size=36
    let mut pc: u32 = 0x82C61610;
    'dispatch: loop {
        match pc {
            0x82C61610 => {
    //   block [0x82C61610..0x82C6162C)
	// 82C61610: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C61614: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C61618: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C6161C: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C61620: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C61624: 409A0008  bne cr6, 0x82c6162c
	if !ctx.cr[6].eq {
	pc = 0x82C6162C; continue 'dispatch;
	}
	// 82C61628: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82C6162C; continue 'dispatch;
            }
            0x82C6162C => {
    //   block [0x82C6162C..0x82C61634)
	// 82C6162C: 806B00C8  lwz r3, 0xc8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C61630: 48004EE8  b 0x82c66518
	crate::recompiler::externs::call(ctx, base, 0x82C66518);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C61638 size=36
    let mut pc: u32 = 0x82C61638;
    'dispatch: loop {
        match pc {
            0x82C61638 => {
    //   block [0x82C61638..0x82C61654)
	// 82C61638: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C6163C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C61640: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C61644: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C61648: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C6164C: 409A0008  bne cr6, 0x82c61654
	if !ctx.cr[6].eq {
	pc = 0x82C61654; continue 'dispatch;
	}
	// 82C61650: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82C61654; continue 'dispatch;
            }
            0x82C61654 => {
    //   block [0x82C61654..0x82C6165C)
	// 82C61654: 806B00C4  lwz r3, 0xc4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C61658: 48004238  b 0x82c65890
	crate::recompiler::externs::call(ctx, base, 0x82C65890);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C61660 size=164
    let mut pc: u32 = 0x82C61660;
    'dispatch: loop {
        match pc {
            0x82C61660 => {
    //   block [0x82C61660..0x82C616D0)
	// 82C61660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C61664: 48047DA9  bl 0x82ca940c
	ctx.lr = 0x82C61668;
	sub_82CA93D0(ctx, base);
	// 82C61668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6166C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C61670: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C61674: 394BD8B0  addi r10, r11, -0x2750
	ctx.r[10].s64 = ctx.r[11].s64 + -10064;
	// 82C61678: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6167C: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C61680: 48003EE1  bl 0x82c65560
	ctx.lr = 0x82C61684;
	sub_82C65560(ctx, base);
	// 82C61684: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C61688: 48004BA9  bl 0x82c66230
	ctx.lr = 0x82C6168C;
	sub_82C66230(ctx, base);
	// 82C6168C: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C61690: 480051A9  bl 0x82c66838
	ctx.lr = 0x82C61694;
	sub_82C66838(ctx, base);
	// 82C61694: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82C61698: 480051A1  bl 0x82c66838
	ctx.lr = 0x82C6169C;
	sub_82C66838(ctx, base);
	// 82C6169C: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82C616A0: 48005199  bl 0x82c66838
	ctx.lr = 0x82C616A4;
	sub_82C66838(ctx, base);
	// 82C616A4: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82C616A8: 48005191  bl 0x82c66838
	ctx.lr = 0x82C616AC;
	sub_82C66838(ctx, base);
	// 82C616AC: 807F00DC  lwz r3, 0xdc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 82C616B0: 48005189  bl 0x82c66838
	ctx.lr = 0x82C616B4;
	sub_82C66838(ctx, base);
	// 82C616B4: 807F00E0  lwz r3, 0xe0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82C616B8: 48005181  bl 0x82c66838
	ctx.lr = 0x82C616BC;
	sub_82C66838(ctx, base);
	// 82C616BC: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C616C0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C616C4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C616C8: 4099002C  ble cr6, 0x82c616f4
	if !ctx.cr[6].gt {
	pc = 0x82C616F4; continue 'dispatch;
	}
	// 82C616CC: 3BDF0108  addi r30, r31, 0x108
	ctx.r[30].s64 = ctx.r[31].s64 + 264;
	pc = 0x82C616D0; continue 'dispatch;
            }
            0x82C616D0 => {
    //   block [0x82C616D0..0x82C616F4)
	// 82C616D0: 807EFFE0  lwz r3, -0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-32 as u32) ) } as u64;
	// 82C616D4: 480028A5  bl 0x82c63f78
	ctx.lr = 0x82C616D8;
	sub_82C63F78(ctx, base);
	// 82C616D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C616DC: 4800289D  bl 0x82c63f78
	ctx.lr = 0x82C616E0;
	sub_82C63F78(ctx, base);
	// 82C616E0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C616E4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C616E8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C616EC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C616F0: 4198FFE0  blt cr6, 0x82c616d0
	if ctx.cr[6].lt {
	pc = 0x82C616D0; continue 'dispatch;
	}
	pc = 0x82C616F4; continue 'dispatch;
            }
            0x82C616F4 => {
    //   block [0x82C616F4..0x82C61704)
	// 82C616F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C616F8: 48002F91  bl 0x82c64688
	ctx.lr = 0x82C616FC;
	sub_82C64688(ctx, base);
	// 82C616FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C61700: 48047D5C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C61708 size=432
    let mut pc: u32 = 0x82C61708;
    'dispatch: loop {
        match pc {
            0x82C61708 => {
    //   block [0x82C61708..0x82C61790)
	// 82C61708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6170C: 48047CF1  bl 0x82ca93fc
	ctx.lr = 0x82C61710;
	sub_82CA93D0(ctx, base);
	// 82C61710: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C61718: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C6171C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82C61720: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C61724: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82C61728: 807F00DC  lwz r3, 0xdc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 82C6172C: 48005115  bl 0x82c66840
	ctx.lr = 0x82C61730;
	sub_82C66840(ctx, base);
	// 82C61730: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82C61734: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C61738: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C6173C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C61740: 419A008C  beq cr6, 0x82c617cc
	if ctx.cr[6].eq {
	pc = 0x82C617CC; continue 'dispatch;
	}
	// 82C61744: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 82C61748: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82C6174C: 48002AFD  bl 0x82c64248
	ctx.lr = 0x82C61750;
	sub_82C64248(ctx, base);
	// 82C61750: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 82C61754: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C61758: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C6175C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C61760: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C61764: 4800448D  bl 0x82c65bf0
	ctx.lr = 0x82C61768;
	sub_82C65BF0(ctx, base);
	// 82C61768: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6176C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C61770: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82C61774: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C61778: 48002AD1  bl 0x82c64248
	ctx.lr = 0x82C6177C;
	sub_82C64248(ctx, base);
	// 82C6177C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C61780: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C61784: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C61788: 4099002C  ble cr6, 0x82c617b4
	if !ctx.cr[6].gt {
	pc = 0x82C617B4; continue 'dispatch;
	}
	// 82C6178C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	pc = 0x82C61790; continue 'dispatch;
            }
            0x82C61790 => {
    //   block [0x82C61790..0x82C617B4)
	// 82C61790: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C61794: 809C0020  lwz r4, 0x20(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C61798: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6179C: 48005285  bl 0x82c66a20
	ctx.lr = 0x82C617A0;
	sub_82C66A20(ctx, base);
	// 82C617A0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C617A4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C617A8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82C617AC: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C617B0: 4198FFE0  blt cr6, 0x82c61790
	if ctx.cr[6].lt {
	pc = 0x82C61790; continue 'dispatch;
	}
	pc = 0x82C617B4; continue 'dispatch;
            }
            0x82C617B4 => {
    //   block [0x82C617B4..0x82C617CC)
	// 82C617B4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C617B8: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82C617BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C617C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C617C4: 48002A85  bl 0x82c64248
	ctx.lr = 0x82C617C8;
	sub_82C64248(ctx, base);
	// 82C617C8: 48000088  b 0x82c61850
	pc = 0x82C61850; continue 'dispatch;
            }
            0x82C617CC => {
    //   block [0x82C617CC..0x82C6182C)
	// 82C617CC: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 82C617D0: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82C617D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C617D8: 48002A71  bl 0x82c64248
	ctx.lr = 0x82C617DC;
	sub_82C64248(ctx, base);
	// 82C617DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C617E0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C617E4: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82C617E8: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 82C617EC: 48002A5D  bl 0x82c64248
	ctx.lr = 0x82C617F0;
	sub_82C64248(ctx, base);
	// 82C617F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C617F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C617F8: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82C617FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C61800: 48002A49  bl 0x82c64248
	ctx.lr = 0x82C61804;
	sub_82C64248(ctx, base);
	// 82C61804: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C61808: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6180C: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C61810: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C61814: 480043DD  bl 0x82c65bf0
	ctx.lr = 0x82C61818;
	sub_82C65BF0(ctx, base);
	// 82C61818: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6181C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C61820: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C61824: 4099002C  ble cr6, 0x82c61850
	if !ctx.cr[6].gt {
	pc = 0x82C61850; continue 'dispatch;
	}
	// 82C61828: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	pc = 0x82C6182C; continue 'dispatch;
            }
            0x82C6182C => {
    //   block [0x82C6182C..0x82C61850)
	// 82C6182C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C61830: 809C0020  lwz r4, 0x20(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C61834: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C61838: 480051E9  bl 0x82c66a20
	ctx.lr = 0x82C6183C;
	sub_82C66A20(ctx, base);
	// 82C6183C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C61840: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C61844: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82C61848: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C6184C: 4198FFE0  blt cr6, 0x82c6182c
	if ctx.cr[6].lt {
	pc = 0x82C6182C; continue 'dispatch;
	}
	pc = 0x82C61850; continue 'dispatch;
            }
            0x82C61850 => {
    //   block [0x82C61850..0x82C61878)
	// 82C61850: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C61854: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C61858: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82C6185C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C61860: 480029E9  bl 0x82c64248
	ctx.lr = 0x82C61864;
	sub_82C64248(ctx, base);
	// 82C61864: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C61868: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C6186C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C61870: 40990030  ble cr6, 0x82c618a0
	if !ctx.cr[6].gt {
	pc = 0x82C618A0; continue 'dispatch;
	}
	// 82C61874: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	pc = 0x82C61878; continue 'dispatch;
            }
            0x82C61878 => {
    //   block [0x82C61878..0x82C618A0)
	// 82C61878: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6187C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C61880: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C61884: 4800519D  bl 0x82c66a20
	ctx.lr = 0x82C61888;
	sub_82C66A20(ctx, base);
	// 82C61888: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6188C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C61890: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82C61894: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82C61898: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C6189C: 4198FFDC  blt cr6, 0x82c61878
	if ctx.cr[6].lt {
	pc = 0x82C61878; continue 'dispatch;
	}
	pc = 0x82C618A0; continue 'dispatch;
            }
            0x82C618A0 => {
    //   block [0x82C618A0..0x82C618B8)
	// 82C618A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C618A4: 807F00E0  lwz r3, 0xe0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82C618A8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C618AC: 48004F95  bl 0x82c66840
	ctx.lr = 0x82C618B0;
	sub_82C66840(ctx, base);
	// 82C618B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C618B4: 48047B98  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C618B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C618B8 size=356
    let mut pc: u32 = 0x82C618B8;
    'dispatch: loop {
        match pc {
            0x82C618B8 => {
    //   block [0x82C618B8..0x82C618F0)
	// 82C618B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C618BC: 48047B45  bl 0x82ca9400
	ctx.lr = 0x82C618C0;
	sub_82CA93D0(ctx, base);
	// 82C618C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C618C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C618C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C618CC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C618D0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82C618D4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C618D8: 813C001C  lwz r9, 0x1c(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C618DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C618E0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C618E4: 40990034  ble cr6, 0x82c61918
	if !ctx.cr[6].gt {
	pc = 0x82C61918; continue 'dispatch;
	}
	// 82C618E8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C618EC: 7D1FD850  subf r8, r31, r27
	ctx.r[8].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	pc = 0x82C618F0; continue 'dispatch;
            }
            0x82C618F0 => {
    //   block [0x82C618F0..0x82C61914)
	// 82C618F0: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C618F4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C618F8: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C618FC: 409A0018  bne cr6, 0x82c61914
	if !ctx.cr[6].eq {
	pc = 0x82C61914; continue 'dispatch;
	}
	// 82C61900: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C61904: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C61908: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82C6190C: 4198FFE4  blt cr6, 0x82c618f0
	if ctx.cr[6].lt {
	pc = 0x82C618F0; continue 'dispatch;
	}
	// 82C61910: 48000008  b 0x82c61918
	pc = 0x82C61918; continue 'dispatch;
            }
            0x82C61914 => {
    //   block [0x82C61914..0x82C61918)
	// 82C61914: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82C61918; continue 'dispatch;
            }
            0x82C61918 => {
    //   block [0x82C61918..0x82C61958)
	// 82C61918: 817C00B8  lwz r11, 0xb8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C6191C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C61920: 419A00BC  beq cr6, 0x82c619dc
	if ctx.cr[6].eq {
	pc = 0x82C619DC; continue 'dispatch;
	}
	// 82C61924: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82C61928: 807C00DC  lwz r3, 0xdc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(220 as u32) ) } as u64;
	// 82C6192C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C61930: 48004F11  bl 0x82c66840
	ctx.lr = 0x82C61934;
	sub_82C66840(ctx, base);
	// 82C61934: 817C00BC  lwz r11, 0xbc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C61938: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6193C: 419A001C  beq cr6, 0x82c61958
	if ctx.cr[6].eq {
	pc = 0x82C61958; continue 'dispatch;
	}
	// 82C61940: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C61944: 807C00C4  lwz r3, 0xc4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C61948: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6194C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C61950: 480042A1  bl 0x82c65bf0
	ctx.lr = 0x82C61954;
	sub_82C65BF0(ctx, base);
	// 82C61954: 48000048  b 0x82c6199c
	pc = 0x82C6199C; continue 'dispatch;
            }
            0x82C61958 => {
    //   block [0x82C61958..0x82C61978)
	// 82C61958: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C6195C: 409A0040  bne cr6, 0x82c6199c
	if !ctx.cr[6].eq {
	pc = 0x82C6199C; continue 'dispatch;
	}
	// 82C61960: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C61964: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C61968: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6196C: 40990030  ble cr6, 0x82c6199c
	if !ctx.cr[6].gt {
	pc = 0x82C6199C; continue 'dispatch;
	}
	// 82C61970: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82C61974: 7F7FD850  subf r27, r31, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	pc = 0x82C61978; continue 'dispatch;
            }
            0x82C61978 => {
    //   block [0x82C61978..0x82C6199C)
	// 82C61978: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82C6197C: 7C9ED82E  lwzx r4, r30, r27
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82C61980: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C61984: 4800503D  bl 0x82c669c0
	ctx.lr = 0x82C61988;
	sub_82C669C0(ctx, base);
	// 82C61988: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6198C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C61990: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C61994: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C61998: 4198FFE0  blt cr6, 0x82c61978
	if ctx.cr[6].lt {
	pc = 0x82C61978; continue 'dispatch;
	}
	pc = 0x82C6199C; continue 'dispatch;
            }
            0x82C6199C => {
    //   block [0x82C6199C..0x82C619C4)
	// 82C6199C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C619A0: C1BC01C8  lfs f13, 0x1c8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(456 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C619A4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C619A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C619AC: 419A0018  beq cr6, 0x82c619c4
	if ctx.cr[6].eq {
	pc = 0x82C619C4; continue 'dispatch;
	}
	// 82C619B0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C619B4: 807C00C8  lwz r3, 0xc8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C619B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C619BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C619C0: 48004BA1  bl 0x82c66560
	ctx.lr = 0x82C619C4;
	sub_82C66560(ctx, base);
	pc = 0x82C619C4; continue 'dispatch;
            }
            0x82C619C4 => {
    //   block [0x82C619C4..0x82C619DC)
	// 82C619C4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82C619C8: 807C00E0  lwz r3, 0xe0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(224 as u32) ) } as u64;
	// 82C619CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C619D0: 48004E71  bl 0x82c66840
	ctx.lr = 0x82C619D4;
	sub_82C66840(ctx, base);
	// 82C619D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C619D8: 48047A78  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C619DC => {
    //   block [0x82C619DC..0x82C619F0)
	// 82C619DC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C619E0: 409A0034  bne cr6, 0x82c61a14
	if !ctx.cr[6].eq {
	pc = 0x82C61A14; continue 'dispatch;
	}
	// 82C619E4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C619E8: 4099002C  ble cr6, 0x82c61a14
	if !ctx.cr[6].gt {
	pc = 0x82C61A14; continue 'dispatch;
	}
	// 82C619EC: 7FBFD850  subf r29, r31, r27
	ctx.r[29].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	pc = 0x82C619F0; continue 'dispatch;
            }
            0x82C619F0 => {
    //   block [0x82C619F0..0x82C61A14)
	// 82C619F0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82C619F4: 7C9FE82E  lwzx r4, r31, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82C619F8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C619FC: 48004FC5  bl 0x82c669c0
	ctx.lr = 0x82C61A00;
	sub_82C669C0(ctx, base);
	// 82C61A00: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C61A04: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C61A08: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C61A0C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C61A10: 4198FFE0  blt cr6, 0x82c619f0
	if ctx.cr[6].lt {
	pc = 0x82C619F0; continue 'dispatch;
	}
	pc = 0x82C61A14; continue 'dispatch;
            }
            0x82C61A14 => {
    //   block [0x82C61A14..0x82C61A1C)
	// 82C61A14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C61A18: 48047A38  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C61A20 size=72
    let mut pc: u32 = 0x82C61A20;
    'dispatch: loop {
        match pc {
            0x82C61A20 => {
    //   block [0x82C61A20..0x82C61A68)
	// 82C61A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C61A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C61A28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C61A2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61A30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C61A34: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C61A38: 48004111  bl 0x82c65b48
	ctx.lr = 0x82C61A3C;
	sub_82C65B48(ctx, base);
	// 82C61A3C: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C61A40: 48004829  bl 0x82c66268
	ctx.lr = 0x82C61A44;
	sub_82C66268(ctx, base);
	// 82C61A44: 807F00DC  lwz r3, 0xdc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 82C61A48: 48004E99  bl 0x82c668e0
	ctx.lr = 0x82C61A4C;
	sub_82C668E0(ctx, base);
	// 82C61A4C: 807F00E0  lwz r3, 0xe0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82C61A50: 48004E91  bl 0x82c668e0
	ctx.lr = 0x82C61A54;
	sub_82C668E0(ctx, base);
	// 82C61A54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C61A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C61A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C61A60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C61A64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C61A68 size=184
    let mut pc: u32 = 0x82C61A68;
    'dispatch: loop {
        match pc {
            0x82C61A68 => {
    //   block [0x82C61A68..0x82C61AD4)
	// 82C61A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C61A6C: 480479A1  bl 0x82ca940c
	ctx.lr = 0x82C61A70;
	sub_82CA93D0(ctx, base);
	// 82C61A70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C61A78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C61A7C: 48002B75  bl 0x82c645f0
	ctx.lr = 0x82C61A80;
	sub_82C645F0(ctx, base);
	// 82C61A80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61A84: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C61A88: 480028E1  bl 0x82c64368
	ctx.lr = 0x82C61A8C;
	sub_82C64368(ctx, base);
	// 82C61A8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61A90: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82C61A94: 480028D5  bl 0x82c64368
	ctx.lr = 0x82C61A98;
	sub_82C64368(ctx, base);
	// 82C61A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61A9C: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82C61AA0: 480028C9  bl 0x82c64368
	ctx.lr = 0x82C61AA4;
	sub_82C64368(ctx, base);
	// 82C61AA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61AA8: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82C61AAC: 480028BD  bl 0x82c64368
	ctx.lr = 0x82C61AB0;
	sub_82C64368(ctx, base);
	// 82C61AB0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82C61AB4: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C61AB8: 40990060  ble cr6, 0x82c61b18
	if !ctx.cr[6].gt {
	pc = 0x82C61B18; continue 'dispatch;
	}
	// 82C61ABC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C61AC0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C61AC4: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82C61AC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C61ACC: 4099004C  ble cr6, 0x82c61b18
	if !ctx.cr[6].gt {
	pc = 0x82C61B18; continue 'dispatch;
	}
	// 82C61AD0: 3BDF0108  addi r30, r31, 0x108
	ctx.r[30].s64 = ctx.r[31].s64 + 264;
	pc = 0x82C61AD4; continue 'dispatch;
            }
            0x82C61AD4 => {
    //   block [0x82C61AD4..0x82C61B18)
	// 82C61AD4: 807EFFE0  lwz r3, -0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-32 as u32) ) } as u64;
	// 82C61AD8: 480024A1  bl 0x82c63f78
	ctx.lr = 0x82C61ADC;
	sub_82C63F78(ctx, base);
	// 82C61ADC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C61AE0: 48002499  bl 0x82c63f78
	ctx.lr = 0x82C61AE4;
	sub_82C63F78(ctx, base);
	// 82C61AE4: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82C61AE8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C61AEC: 4800247D  bl 0x82c63f68
	ctx.lr = 0x82C61AF0;
	sub_82C63F68(ctx, base);
	// 82C61AF0: 907EFFE0  stw r3, -0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-32 as u32), ctx.r[3].u32 ) };
	// 82C61AF4: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82C61AF8: 5543103A  slwi r3, r10, 2
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C61AFC: 4800246D  bl 0x82c63f68
	ctx.lr = 0x82C61B00;
	sub_82C63F68(ctx, base);
	// 82C61B00: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C61B04: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C61B08: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C61B0C: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C61B10: 7F1D4800  cmpw cr6, r29, r9
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82C61B14: 4198FFC0  blt cr6, 0x82c61ad4
	if ctx.cr[6].lt {
	pc = 0x82C61AD4; continue 'dispatch;
	}
	pc = 0x82C61B18; continue 'dispatch;
            }
            0x82C61B18 => {
    //   block [0x82C61B18..0x82C61B20)
	// 82C61B18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C61B1C: 48047940  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C61B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C61B28 size=1392
    let mut pc: u32 = 0x82C61B28;
    'dispatch: loop {
        match pc {
            0x82C61B28 => {
    //   block [0x82C61B28..0x82C61DDC)
	// 82C61B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C61B2C: 480478AD  bl 0x82ca93d8
	ctx.lr = 0x82C61B30;
	sub_82CA93D0(ctx, base);
	// 82C61B30: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 82C61B34: 4804C1A5  bl 0x82cadcd8
	ctx.lr = 0x82C61B38;
	sub_82CADCA0(ctx, base);
	// 82C61B38: 3BE1FEF0  addi r31, r1, -0x110
	ctx.r[31].s64 = ctx.r[1].s64 + -272;
	// 82C61B3C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C61B40: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C61B44: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82C61B48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C61B4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C61B50: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C61B54: 38EBD95C  addi r7, r11, -0x26a4
	ctx.r[7].s64 = ctx.r[11].s64 + -9892;
	// 82C61B58: 93DF0124  stw r30, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[30].u32 ) };
	// 82C61B5C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82C61B60: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 82C61B64: 48002A9D  bl 0x82c64600
	ctx.lr = 0x82C61B68;
	sub_82C64600(ctx, base);
	// 82C61B68: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C61B6C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C61B70: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C61B74: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C61B78: 3B7E0128  addi r27, r30, 0x128
	ctx.r[27].s64 = ctx.r[30].s64 + 296;
	// 82C61B7C: C3AA0BFC  lfs f29, 0xbfc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82C61B80: 3967D8B0  addi r11, r7, -0x2750
	ctx.r[11].s64 = ctx.r[7].s64 + -10064;
	// 82C61B84: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82C61B88: C3E90C14  lfs f31, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C61B8C: C3C80C18  lfs f30, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C61B90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61B94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61B98: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61B9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61BA0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61BA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61BA8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61BAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C61BB0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C61BB4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61BB8: 480053D1  bl 0x82c66f88
	ctx.lr = 0x82C61BBC;
	sub_82C66F88(ctx, base);
	// 82C61BBC: 3B5E0148  addi r26, r30, 0x148
	ctx.r[26].s64 = ctx.r[30].s64 + 328;
	// 82C61BC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61BC4: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61BC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61BCC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61BD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61BD4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61BD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61BDC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61BE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C61BE4: 480053A5  bl 0x82c66f88
	ctx.lr = 0x82C61BE8;
	sub_82C66F88(ctx, base);
	// 82C61BE8: 3B3E0168  addi r25, r30, 0x168
	ctx.r[25].s64 = ctx.r[30].s64 + 360;
	// 82C61BEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61BF0: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61BF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61BF8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61BFC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61C00: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61C04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61C08: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61C0C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C61C10: 48005379  bl 0x82c66f88
	ctx.lr = 0x82C61C14;
	sub_82C66F88(ctx, base);
	// 82C61C14: 3B1E0188  addi r24, r30, 0x188
	ctx.r[24].s64 = ctx.r[30].s64 + 392;
	// 82C61C18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61C1C: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61C20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61C24: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61C28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61C2C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61C30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61C34: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61C38: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C61C3C: 4800534D  bl 0x82c66f88
	ctx.lr = 0x82C61C40;
	sub_82C66F88(ctx, base);
	// 82C61C40: 3AFE01A8  addi r23, r30, 0x1a8
	ctx.r[23].s64 = ctx.r[30].s64 + 424;
	// 82C61C44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61C48: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61C4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61C50: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61C54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61C58: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61C5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61C60: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61C64: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C61C68: 48005321  bl 0x82c66f88
	ctx.lr = 0x82C61C6C;
	sub_82C66F88(ctx, base);
	// 82C61C6C: 3ADE01C8  addi r22, r30, 0x1c8
	ctx.r[22].s64 = ctx.r[30].s64 + 456;
	// 82C61C70: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61C74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61C78: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61C7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61C80: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61C84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61C88: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61C8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61C90: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C61C94: 480052F5  bl 0x82c66f88
	ctx.lr = 0x82C61C98;
	sub_82C66F88(ctx, base);
	// 82C61C98: 3ABE01E8  addi r21, r30, 0x1e8
	ctx.r[21].s64 = ctx.r[30].s64 + 488;
	// 82C61C9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61CA0: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61CA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61CA8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61CAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61CB0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61CB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61CB8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61CBC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82C61CC0: 480052C9  bl 0x82c66f88
	ctx.lr = 0x82C61CC4;
	sub_82C66F88(ctx, base);
	// 82C61CC4: 3A9E0208  addi r20, r30, 0x208
	ctx.r[20].s64 = ctx.r[30].s64 + 520;
	// 82C61CC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61CCC: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61CD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61CD4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61CD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61CDC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61CE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61CE4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61CE8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82C61CEC: 4800529D  bl 0x82c66f88
	ctx.lr = 0x82C61CF0;
	sub_82C66F88(ctx, base);
	// 82C61CF0: 3A7E0228  addi r19, r30, 0x228
	ctx.r[19].s64 = ctx.r[30].s64 + 552;
	// 82C61CF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61CF8: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61CFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61D00: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61D04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61D08: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61D0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61D10: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61D14: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82C61D18: 48005271  bl 0x82c66f88
	ctx.lr = 0x82C61D1C;
	sub_82C66F88(ctx, base);
	// 82C61D1C: 3A5E0248  addi r18, r30, 0x248
	ctx.r[18].s64 = ctx.r[30].s64 + 584;
	// 82C61D20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C61D24: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82C61D28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C61D2C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61D30: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C61D34: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61D38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C61D3C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61D40: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C61D44: 48005245  bl 0x82c66f88
	ctx.lr = 0x82C61D48;
	sub_82C66F88(ctx, base);
	// 82C61D48: 93BE00B8  stw r29, 0xb8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 82C61D4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C61D50: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82C61D54: 480043F5  bl 0x82c66148
	ctx.lr = 0x82C61D58;
	sub_82C66148(ctx, base);
	// 82C61D58: 907E00C4  stw r3, 0xc4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82C61D5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C61D60: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82C61D64: 48004A7D  bl 0x82c667e0
	ctx.lr = 0x82C61D68;
	sub_82C667E0(ctx, base);
	// 82C61D68: 907E00C8  stw r3, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[3].u32 ) };
	// 82C61D6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C61D70: 48002271  bl 0x82c63fe0
	ctx.lr = 0x82C61D74;
	sub_82C63FE0(ctx, base);
	// 82C61D74: 907E00CC  stw r3, 0xcc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(204 as u32), ctx.r[3].u32 ) };
	// 82C61D78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C61D7C: 48002265  bl 0x82c63fe0
	ctx.lr = 0x82C61D80;
	sub_82C63FE0(ctx, base);
	// 82C61D80: 907E00D0  stw r3, 0xd0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[3].u32 ) };
	// 82C61D84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C61D88: 48002259  bl 0x82c63fe0
	ctx.lr = 0x82C61D8C;
	sub_82C63FE0(ctx, base);
	// 82C61D8C: 907E00D4  stw r3, 0xd4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(212 as u32), ctx.r[3].u32 ) };
	// 82C61D90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C61D94: 4800224D  bl 0x82c63fe0
	ctx.lr = 0x82C61D98;
	sub_82C63FE0(ctx, base);
	// 82C61D98: 907E00D8  stw r3, 0xd8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 82C61D9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C61DA0: 48004BD9  bl 0x82c66978
	ctx.lr = 0x82C61DA4;
	sub_82C66978(ctx, base);
	// 82C61DA4: 907E00E0  stw r3, 0xe0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(224 as u32), ctx.r[3].u32 ) };
	// 82C61DA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C61DAC: 48004BCD  bl 0x82c66978
	ctx.lr = 0x82C61DB0;
	sub_82C66978(ctx, base);
	// 82C61DB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C61DB4: 907E00DC  stw r3, 0xdc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(220 as u32), ctx.r[3].u32 ) };
	// 82C61DB8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C61DBC: C80A0DA0  lfd f0, 0xda0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3488 as u32) ) };
	// 82C61DC0: FC1C0032  fmul f0, f28, f0
	ctx.f[0].f64 = ctx.f[28].f64 * ctx.f[0].f64;
	// 82C61DC4: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82C61DC8: D9BF0060  stfd f13, 0x60(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.f[13].u64 ) };
	// 82C61DCC: 823F0064  lwz r17, 0x64(r31)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C61DD0: 923E00E4  stw r17, 0xe4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), ctx.r[17].u32 ) };
	// 82C61DD4: 40990034  ble cr6, 0x82c61e08
	if !ctx.cr[6].gt {
	pc = 0x82C61E08; continue 'dispatch;
	}
	// 82C61DD8: 3A1E0108  addi r16, r30, 0x108
	ctx.r[16].s64 = ctx.r[30].s64 + 264;
	pc = 0x82C61DDC; continue 'dispatch;
            }
            0x82C61DDC => {
    //   block [0x82C61DDC..0x82C61E08)
	// 82C61DDC: 817E00E4  lwz r11, 0xe4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82C61DE0: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C61DE4: 48002185  bl 0x82c63f68
	ctx.lr = 0x82C61DE8;
	sub_82C63F68(ctx, base);
	// 82C61DE8: 9070FFE0  stw r3, -0x20(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(-32 as u32), ctx.r[3].u32 ) };
	// 82C61DEC: 815E00E4  lwz r10, 0xe4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82C61DF0: 5543103A  slwi r3, r10, 2
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C61DF4: 48002175  bl 0x82c63f68
	ctx.lr = 0x82C61DF8;
	sub_82C63F68(ctx, base);
	// 82C61DF8: 90700000  stw r3, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C61DFC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C61E00: 3A100004  addi r16, r16, 4
	ctx.r[16].s64 = ctx.r[16].s64 + 4;
	// 82C61E04: 4082FFD8  bne 0x82c61ddc
	if !ctx.cr[0].eq {
	pc = 0x82C61DDC; continue 'dispatch;
	}
	pc = 0x82C61E08; continue 'dispatch;
            }
            0x82C61E08 => {
    //   block [0x82C61E08..0x82C62098)
	// 82C61E08: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C61E0C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82C61E10: 3D6082C6  lis r11, -0x7d3a
	ctx.r[11].s64 = -2100953088;
	// 82C61E14: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61E18: 3B9E0004  addi r28, r30, 4
	ctx.r[28].s64 = ctx.r[30].s64 + 4;
	// 82C61E1C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61E20: 38CAD954  addi r6, r10, -0x26ac
	ctx.r[6].s64 = ctx.r[10].s64 + -9900;
	// 82C61E24: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61E28: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61E2C: 394B1350  addi r10, r11, 0x1350
	ctx.r[10].s64 = ctx.r[11].s64 + 4944;
	// 82C61E30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61E34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C61E38: 48005061  bl 0x82c66e98
	ctx.lr = 0x82C61E3C;
	sub_82C66E98(ctx, base);
	// 82C61E3C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61E40: 3D2082C6  lis r9, -0x7d3a
	ctx.r[9].s64 = -2100953088;
	// 82C61E44: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82C61E48: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C61E4C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61E50: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61E54: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61E58: 38C8D944  addi r6, r8, -0x26bc
	ctx.r[6].s64 = ctx.r[8].s64 + -9916;
	// 82C61E5C: 394914C8  addi r10, r9, 0x14c8
	ctx.r[10].s64 = ctx.r[9].s64 + 5320;
	// 82C61E60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61E64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C61E68: 48005031  bl 0x82c66e98
	ctx.lr = 0x82C61E6C;
	sub_82C66E98(ctx, base);
	// 82C61E6C: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82C61E70: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C61E74: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82C61E78: 3C6082C6  lis r3, -0x7d3a
	ctx.r[3].s64 = -2100953088;
	// 82C61E7C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61E80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C61E84: 39431510  addi r10, r3, 0x1510
	ctx.r[10].s64 = ctx.r[3].s64 + 5392;
	// 82C61E88: C3A4D940  lfs f29, -0x26c0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-9920 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82C61E8C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61E90: 38CBD934  addi r6, r11, -0x26cc
	ctx.r[6].s64 = ctx.r[11].s64 + -9932;
	// 82C61E94: C067D93C  lfs f3, -0x26c4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-9924 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C61E98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61E9C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82C61EA0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C61EA4: 48004FF5  bl 0x82c66e98
	ctx.lr = 0x82C61EA8;
	sub_82C66E98(ctx, base);
	// 82C61EA8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61EAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C61EB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C61EB4: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82C61EB8: 3D0082C6  lis r8, -0x7d3a
	ctx.r[8].s64 = -2100953088;
	// 82C61EBC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C61EC0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61EC4: C06A0AEC  lfs f3, 0xaec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2796 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C61EC8: 38C7D92C  addi r6, r7, -0x26d4
	ctx.r[6].s64 = ctx.r[7].s64 + -9940;
	// 82C61ECC: 39481520  addi r10, r8, 0x1520
	ctx.r[10].s64 = ctx.r[8].s64 + 5408;
	// 82C61ED0: C0499404  lfs f2, -0x6bfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C61ED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61ED8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C61EDC: 48004FBD  bl 0x82c66e98
	ctx.lr = 0x82C61EE0;
	sub_82C66E98(ctx, base);
	// 82C61EE0: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82C61EE4: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82C61EE8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82C61EEC: 3C6082C6  lis r3, -0x7d3a
	ctx.r[3].s64 = -2100953088;
	// 82C61EF0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61EF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C61EF8: 39431528  addi r10, r3, 0x1528
	ctx.r[10].s64 = ctx.r[3].s64 + 5416;
	// 82C61EFC: C06615E4  lfs f3, 0x15e4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(5604 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C61F00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61F04: C0440BB4  lfs f2, 0xbb4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(2996 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C61F08: 38CBD920  addi r6, r11, -0x26e0
	ctx.r[6].s64 = ctx.r[11].s64 + -9952;
	// 82C61F0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61F10: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C61F14: 48004F85  bl 0x82c66e98
	ctx.lr = 0x82C61F18;
	sub_82C66E98(ctx, base);
	// 82C61F18: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C61F1C: 3D2082C6  lis r9, -0x7d3a
	ctx.r[9].s64 = -2100953088;
	// 82C61F20: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82C61F24: 38CAD914  addi r6, r10, -0x26ec
	ctx.r[6].s64 = ctx.r[10].s64 + -9964;
	// 82C61F28: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61F2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61F30: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61F34: 39491538  addi r10, r9, 0x1538
	ctx.r[10].s64 = ctx.r[9].s64 + 5432;
	// 82C61F38: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61F3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61F40: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C61F44: 48004F55  bl 0x82c66e98
	ctx.lr = 0x82C61F48;
	sub_82C66E98(ctx, base);
	// 82C61F48: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61F4C: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82C61F50: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C61F54: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C61F58: 3C6082C6  lis r3, -0x7d3a
	ctx.r[3].s64 = -2100953088;
	// 82C61F5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C61F60: C0240A4C  lfs f1, 0xa4c(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(2636 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C61F64: 394315A0  addi r10, r3, 0x15a0
	ctx.r[10].s64 = ctx.r[3].s64 + 5536;
	// 82C61F68: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61F6C: C0680B60  lfs f3, 0xb60(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2912 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C61F70: 38CBD904  addi r6, r11, -0x26fc
	ctx.r[6].s64 = ctx.r[11].s64 + -9980;
	// 82C61F74: C0470AB0  lfs f2, 0xab0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2736 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C61F78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61F7C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82C61F80: 48004F19  bl 0x82c66e98
	ctx.lr = 0x82C61F84;
	sub_82C66E98(ctx, base);
	// 82C61F84: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82C61F88: 3D2082C6  lis r9, -0x7d3a
	ctx.r[9].s64 = -2100953088;
	// 82C61F8C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82C61F90: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C61F94: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61F98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61F9C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61FA0: 38C8D8F8  addi r6, r8, -0x2708
	ctx.r[6].s64 = ctx.r[8].s64 + -9992;
	// 82C61FA4: 816AA878  lwz r11, -0x5788(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-22408 as u32) ) } as u64;
	// 82C61FA8: 394915D8  addi r10, r9, 0x15d8
	ctx.r[10].s64 = ctx.r[9].s64 + 5592;
	// 82C61FAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61FB0: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 82C61FB4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82C61FB8: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 82C61FBC: F97F0060  std r11, 0x60(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82C61FC0: C81F0060  lfd f0, 0x60(r31)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	// 82C61FC4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C61FC8: FC406818  frsp f2, f13
	ctx.f[2].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C61FCC: 48004ECD  bl 0x82c66e98
	ctx.lr = 0x82C61FD0;
	sub_82C66E98(ctx, base);
	// 82C61FD0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C61FD4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C61FD8: 3D4082C6  lis r10, -0x7d3a
	ctx.r[10].s64 = -2100953088;
	// 82C61FDC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82C61FE0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C61FE4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C61FE8: 38C9D8EC  addi r6, r9, -0x2714
	ctx.r[6].s64 = ctx.r[9].s64 + -10004;
	// 82C61FEC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C61FF0: 394A1610  addi r10, r10, 0x1610
	ctx.r[10].s64 = ctx.r[10].s64 + 5648;
	// 82C61FF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C61FF8: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82C61FFC: 48004E9D  bl 0x82c66e98
	ctx.lr = 0x82C62000;
	sub_82C66E98(ctx, base);
	// 82C62000: 3D0082C6  lis r8, -0x7d3a
	ctx.r[8].s64 = -2100953088;
	// 82C62004: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C62008: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82C6200C: 39481638  addi r10, r8, 0x1638
	ctx.r[10].s64 = ctx.r[8].s64 + 5688;
	// 82C62010: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C62014: 38C7D8DC  addi r6, r7, -0x2724
	ctx.r[6].s64 = ctx.r[7].s64 + -10020;
	// 82C62018: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C6201C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C62020: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C62024: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C62028: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C6202C: 48004E6D  bl 0x82c66e98
	ctx.lr = 0x82C62030;
	sub_82C66E98(ctx, base);
	// 82C62030: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C62034: 4BFFF9ED  bl 0x82c61a20
	ctx.lr = 0x82C62038;
	sub_82C61A20(ctx, base);
	// 82C62038: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C6203C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C62040: 48001559  bl 0x82c63598
	ctx.lr = 0x82C62044;
	sub_82C63598(ctx, base);
	// 82C62044: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 82C62048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6204C: 4BFFFA1D  bl 0x82c61a68
	ctx.lr = 0x82C62050;
	sub_82C61A68(ctx, base);
	// 82C62050: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C62054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C62058: 48001521  bl 0x82c63578
	ctx.lr = 0x82C6205C;
	sub_82C63578(ctx, base);
	// 82C6205C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C62060: 383F0110  addi r1, r31, 0x110
	ctx.r[1].s64 = ctx.r[31].s64 + 272;
	// 82C62064: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 82C62068: 4804BCBD  bl 0x82cadd24
	ctx.lr = 0x82C6206C;
	sub_82CADCEC(ctx, base);
	// 82C6206C: 480473BC  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
	// 82C62070: 3BECFEF0  addi r31, r12, -0x110
	ctx.r[31].s64 = ctx.r[12].s64 + -272;
	// 82C62074: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62078: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6207C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62080: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82C62084: 48002605  bl 0x82c64688
	ctx.lr = 0x82C62088;
	sub_82C64688(ctx, base);
	// 82C62088: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6208C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C62098 size=80
    let mut pc: u32 = 0x82C62098;
    'dispatch: loop {
        match pc {
            0x82C62098 => {
    //   block [0x82C62098..0x82C620D0)
	// 82C62098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6209C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C620A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C620A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C620A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C620AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C620B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C620B4: 4BFFF5AD  bl 0x82c61660
	ctx.lr = 0x82C620B8;
	sub_82C61660(ctx, base);
	// 82C620B8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C620BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C620C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C620C4: 419A000C  beq cr6, 0x82c620d0
	if ctx.cr[6].eq {
	pc = 0x82C620D0; continue 'dispatch;
	}
	// 82C620C8: 4BFFDF91  bl 0x82c60058
	ctx.lr = 0x82C620CC;
	sub_82C60058(ctx, base);
	// 82C620CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C620D0; continue 'dispatch;
            }
            0x82C620D0 => {
    //   block [0x82C620D0..0x82C620E8)
	// 82C620D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C620D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C620D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C620DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C620E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C620E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C620E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C620E8 size=132
    let mut pc: u32 = 0x82C620E8;
    'dispatch: loop {
        match pc {
            0x82C620E8 => {
    //   block [0x82C620E8..0x82C6216C)
	// 82C620E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C620EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C620F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C620F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C620F8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C620FC: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62100: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C62104: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C62108: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82C6210C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C62110: 388A3590  addi r4, r10, 0x3590
	ctx.r[4].s64 = ctx.r[10].s64 + 13712;
	// 82C62114: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C62118: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C6211C: 80CB0018  lwz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C62120: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C62124: 4B5DD77D  bl 0x8223f8a0
	ctx.lr = 0x82C62128;
	sub_8223F8A0(ctx, base);
	// 82C62128: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C6212C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C62130: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C62134: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C62138: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82C6213C: 4B5DD765  bl 0x8223f8a0
	ctx.lr = 0x82C62140;
	sub_8223F8A0(ctx, base);
	// 82C62140: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C62144: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82C62148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6214C: 4B66AF5D  bl 0x822cd0a8
	ctx.lr = 0x82C62150;
	sub_822CD0A8(ctx, base);
	// 82C62150: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82C62154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6215C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C62160: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62170 size=100
    let mut pc: u32 = 0x82C62170;
    'dispatch: loop {
        match pc {
            0x82C62170 => {
    //   block [0x82C62170..0x82C621D4)
	// 82C62170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6217C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62180: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62184: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62188: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6218C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C62190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C62194: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C62198: C00B0AA4  lfs f0, 0xaa4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6219C: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C621A0: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C621A4: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C621A8: 4B5DD6F9  bl 0x8223f8a0
	ctx.lr = 0x82C621AC;
	sub_8223F8A0(ctx, base);
	// 82C621AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C621B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C621B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C621B8: 4B66AEF1  bl 0x822cd0a8
	ctx.lr = 0x82C621BC;
	sub_822CD0A8(ctx, base);
	// 82C621BC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C621C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C621C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C621C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C621CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C621D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C621D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C621D8 size=148
    let mut pc: u32 = 0x82C621D8;
    'dispatch: loop {
        match pc {
            0x82C621D8 => {
    //   block [0x82C621D8..0x82C62238)
	// 82C621D8: 82CAE348  lwz r22, -0x1cb8(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7352 as u32) ) } as u64;
	// 82C621DC: 8200D9A8  lwz r16, -0x2658(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -9816u32 ) } as u64;
	// 82C621E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C621E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C621E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C621EC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C621F0: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82C621F4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C621F8: 909F00AC  stw r4, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82C621FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C62200: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82C62204: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62208: 480052C1  bl 0x82c674c8
	ctx.lr = 0x82C6220C;
	sub_82C674C8(ctx, base);
	// 82C6220C: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82C62210: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C62214: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62218: 48005251  bl 0x82c67468
	ctx.lr = 0x82C6221C;
	sub_82C67468(ctx, base);
	// 82C6221C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C62220: 409A0018  bne cr6, 0x82c62238
	if !ctx.cr[6].eq {
	pc = 0x82C62238; continue 'dispatch;
	}
	// 82C62224: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62228: 48004D99  bl 0x82c66fc0
	ctx.lr = 0x82C6222C;
	sub_82C66FC0(ctx, base);
	// 82C6222C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62230: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C62234: 48000020  b 0x82c62254
	pc = 0x82C62254; continue 'dispatch;
            }
            0x82C62238 => {
    //   block [0x82C62238..0x82C62254)
	// 82C62238: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C6223C: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C62240: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62244: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C62248: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C6224C: 48004D75  bl 0x82c66fc0
	ctx.lr = 0x82C62250;
	sub_82C66FC0(ctx, base);
	// 82C62250: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82C62254; continue 'dispatch;
            }
            0x82C62254 => {
    //   block [0x82C62254..0x82C6226C)
	// 82C62254: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82C62258: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6225C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62260: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62298 size=100
    let mut pc: u32 = 0x82C62298;
    'dispatch: loop {
        match pc {
            0x82C62298 => {
    //   block [0x82C62298..0x82C622FC)
	// 82C62298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6229C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C622A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C622A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C622A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C622AC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C622B0: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C622B4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C622B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C622BC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C622C0: C00B9404  lfs f0, -0x6bfc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C622C4: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C622C8: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C622CC: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C622D0: 4B5DD5D1  bl 0x8223f8a0
	ctx.lr = 0x82C622D4;
	sub_8223F8A0(ctx, base);
	// 82C622D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C622D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C622DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C622E0: 4B66ADC9  bl 0x822cd0a8
	ctx.lr = 0x82C622E4;
	sub_822CD0A8(ctx, base);
	// 82C622E4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C622E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C622EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C622F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C622F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C622F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62300 size=148
    let mut pc: u32 = 0x82C62300;
    'dispatch: loop {
        match pc {
            0x82C62300 => {
    //   block [0x82C62300..0x82C62360)
	// 82C62300: 82CAE348  lwz r22, -0x1cb8(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7352 as u32) ) } as u64;
	// 82C62304: 8200D9E8  lwz r16, -0x2618(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -9752u32 ) } as u64;
	// 82C62308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6230C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62310: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62314: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C62318: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82C6231C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62320: 909F00AC  stw r4, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82C62324: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C62328: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82C6232C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62330: 48005199  bl 0x82c674c8
	ctx.lr = 0x82C62334;
	sub_82C674C8(ctx, base);
	// 82C62334: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82C62338: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C6233C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62340: 48005129  bl 0x82c67468
	ctx.lr = 0x82C62344;
	sub_82C67468(ctx, base);
	// 82C62344: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C62348: 409A0018  bne cr6, 0x82c62360
	if !ctx.cr[6].eq {
	pc = 0x82C62360; continue 'dispatch;
	}
	// 82C6234C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62350: 48004C71  bl 0x82c66fc0
	ctx.lr = 0x82C62354;
	sub_82C66FC0(ctx, base);
	// 82C62354: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62358: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C6235C: 48000020  b 0x82c6237c
	pc = 0x82C6237C; continue 'dispatch;
            }
            0x82C62360 => {
    //   block [0x82C62360..0x82C6237C)
	// 82C62360: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82C62364: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C62368: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6236C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C62370: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62374: 48004C4D  bl 0x82c66fc0
	ctx.lr = 0x82C62378;
	sub_82C66FC0(ctx, base);
	// 82C62378: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82C6237C; continue 'dispatch;
            }
            0x82C6237C => {
    //   block [0x82C6237C..0x82C62394)
	// 82C6237C: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82C62380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62388: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6238C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C623C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C623C0 size=200
    let mut pc: u32 = 0x82C623C0;
    'dispatch: loop {
        match pc {
            0x82C623C0 => {
    //   block [0x82C623C0..0x82C62420)
	// 82C623C0: 82CAE348  lwz r22, -0x1cb8(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7352 as u32) ) } as u64;
	// 82C623C4: 8200DA30  lwz r16, -0x25d0(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -9680u32 ) } as u64;
	// 82C623C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C623CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C623D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C623D4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C623D8: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82C623DC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C623E0: 909F00AC  stw r4, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82C623E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C623E8: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82C623EC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C623F0: 480050D9  bl 0x82c674c8
	ctx.lr = 0x82C623F4;
	sub_82C674C8(ctx, base);
	// 82C623F4: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82C623F8: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C623FC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62400: 48005069  bl 0x82c67468
	ctx.lr = 0x82C62404;
	sub_82C67468(ctx, base);
	// 82C62404: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C62408: 409A0018  bne cr6, 0x82c62420
	if !ctx.cr[6].eq {
	pc = 0x82C62420; continue 'dispatch;
	}
	// 82C6240C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62410: 48004BB1  bl 0x82c66fc0
	ctx.lr = 0x82C62414;
	sub_82C66FC0(ctx, base);
	// 82C62414: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62418: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C6241C: 48000054  b 0x82c62470
	pc = 0x82C62470; continue 'dispatch;
            }
            0x82C62420 => {
    //   block [0x82C62420..0x82C62460)
	// 82C62420: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C62424: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62428: 48004E89  bl 0x82c672b0
	ctx.lr = 0x82C6242C;
	sub_82C672B0(ctx, base);
	// 82C6242C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C62430: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C62434: 38ABDA20  addi r5, r11, -0x25e0
	ctx.r[5].s64 = ctx.r[11].s64 + -9696;
	// 82C62438: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C6243C: 48004C8D  bl 0x82c670c8
	ctx.lr = 0x82C62440;
	sub_82C670C8(ctx, base);
	// 82C62440: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C62444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C62448: 419A0018  beq cr6, 0x82c62460
	if ctx.cr[6].eq {
	pc = 0x82C62460; continue 'dispatch;
	}
	// 82C6244C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C62450: C1BF0050  lfs f13, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C62454: C00B9404  lfs f0, -0x6bfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62458: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C6245C: 48000008  b 0x82c62464
	pc = 0x82C62464; continue 'dispatch;
            }
            0x82C62460 => {
    //   block [0x82C62460..0x82C62464)
	// 82C62460: C3FF0050  lfs f31, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82C62464; continue 'dispatch;
            }
            0x82C62464 => {
    //   block [0x82C62464..0x82C62470)
	// 82C62464: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62468: 48004B59  bl 0x82c66fc0
	ctx.lr = 0x82C6246C;
	sub_82C66FC0(ctx, base);
	// 82C6246C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82C62470; continue 'dispatch;
            }
            0x82C62470 => {
    //   block [0x82C62470..0x82C62488)
	// 82C62470: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82C62474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6247C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C624B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C624B0 size=172
    let mut pc: u32 = 0x82C624B0;
    'dispatch: loop {
        match pc {
            0x82C624B0 => {
    //   block [0x82C624B0..0x82C624F8)
	// 82C624B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C624B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C624B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C624BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C624C0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C624C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C624C8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C624CC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C624D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C624D4: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C624D8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C624DC: 4098001C  bge cr6, 0x82c624f8
	if !ctx.cr[6].lt {
	pc = 0x82C624F8; continue 'dispatch;
	}
	// 82C624E0: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C624E4: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C624E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C624EC: 388BDA88  addi r4, r11, -0x2578
	ctx.r[4].s64 = ctx.r[11].s64 + -9592;
	// 82C624F0: 4B5DD3B1  bl 0x8223f8a0
	ctx.lr = 0x82C624F4;
	sub_8223F8A0(ctx, base);
	// 82C624F4: 48000040  b 0x82c62534
	pc = 0x82C62534; continue 'dispatch;
            }
            0x82C624F8 => {
    //   block [0x82C624F8..0x82C62520)
	// 82C624F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C624FC: C00B0A54  lfs f0, 0xa54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62500: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C62504: 4098001C  bge cr6, 0x82c62520
	if !ctx.cr[6].lt {
	pc = 0x82C62520; continue 'dispatch;
	}
	// 82C62508: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C6250C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C62510: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C62514: 388BDA80  addi r4, r11, -0x2580
	ctx.r[4].s64 = ctx.r[11].s64 + -9600;
	// 82C62518: 4B5DD389  bl 0x8223f8a0
	ctx.lr = 0x82C6251C;
	sub_8223F8A0(ctx, base);
	// 82C6251C: 48000018  b 0x82c62534
	pc = 0x82C62534; continue 'dispatch;
            }
            0x82C62520 => {
    //   block [0x82C62520..0x82C62534)
	// 82C62520: D8210020  stfd f1, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C62524: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C62528: 388BDA78  addi r4, r11, -0x2588
	ctx.r[4].s64 = ctx.r[11].s64 + -9608;
	// 82C6252C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C62530: 4B5DD371  bl 0x8223f8a0
	ctx.lr = 0x82C62534;
	sub_8223F8A0(ctx, base);
	pc = 0x82C62534; continue 'dispatch;
            }
            0x82C62534 => {
    //   block [0x82C62534..0x82C6255C)
	// 82C62534: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C62538: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6253C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C62540: 4B66AB69  bl 0x822cd0a8
	ctx.lr = 0x82C62544;
	sub_822CD0A8(ctx, base);
	// 82C62544: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C62548: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6254C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62550: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62554: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62590 size=184
    let mut pc: u32 = 0x82C62590;
    'dispatch: loop {
        match pc {
            0x82C62590 => {
    //   block [0x82C62590..0x82C625D8)
	// 82C62590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62598: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6259C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C625A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C625A4: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C625A8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C625AC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C625B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C625B4: C00B9404  lfs f0, -0x6bfc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C625B8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C625BC: 4098001C  bge cr6, 0x82c625d8
	if !ctx.cr[6].lt {
	pc = 0x82C625D8; continue 'dispatch;
	}
	// 82C625C0: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C625C4: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C625C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C625CC: 388BDAA8  addi r4, r11, -0x2558
	ctx.r[4].s64 = ctx.r[11].s64 + -9560;
	// 82C625D0: 4B5DD2D1  bl 0x8223f8a0
	ctx.lr = 0x82C625D4;
	sub_8223F8A0(ctx, base);
	// 82C625D4: 4800004C  b 0x82c62620
	pc = 0x82C62620; continue 'dispatch;
            }
            0x82C625D8 => {
    //   block [0x82C625D8..0x82C6260C)
	// 82C625D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C625DC: C00B0A40  lfs f0, 0xa40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C625E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82C625E4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C625E8: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C625EC: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C625F0: 4098001C  bge cr6, 0x82c6260c
	if !ctx.cr[6].lt {
	pc = 0x82C6260C; continue 'dispatch;
	}
	// 82C625F4: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C625F8: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C625FC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C62600: 388ADAA0  addi r4, r10, -0x2560
	ctx.r[4].s64 = ctx.r[10].s64 + -9568;
	// 82C62604: 4B5DD29D  bl 0x8223f8a0
	ctx.lr = 0x82C62608;
	sub_8223F8A0(ctx, base);
	// 82C62608: 48000018  b 0x82c62620
	pc = 0x82C62620; continue 'dispatch;
            }
            0x82C6260C => {
    //   block [0x82C6260C..0x82C62620)
	// 82C6260C: D8210020  stfd f1, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C62610: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C62614: 388ADA98  addi r4, r10, -0x2568
	ctx.r[4].s64 = ctx.r[10].s64 + -9576;
	// 82C62618: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C6261C: 4B5DD285  bl 0x8223f8a0
	ctx.lr = 0x82C62620;
	sub_8223F8A0(ctx, base);
	pc = 0x82C62620; continue 'dispatch;
            }
            0x82C62620 => {
    //   block [0x82C62620..0x82C62648)
	// 82C62620: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C62624: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C62628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6262C: 4B66AA7D  bl 0x822cd0a8
	ctx.lr = 0x82C62630;
	sub_822CD0A8(ctx, base);
	// 82C62630: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C62634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6263C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62640: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C62648 size=172
    let mut pc: u32 = 0x82C62648;
    'dispatch: loop {
        match pc {
            0x82C62648 => {
    //   block [0x82C62648..0x82C62690)
	// 82C62648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6264C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C62654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62658: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6265C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C62660: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C62664: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C62668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6266C: C80BDAB8  lfd f0, -0x2548(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-9544 as u32) ) };
	// 82C62670: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C62674: 4098001C  bge cr6, 0x82c62690
	if !ctx.cr[6].lt {
	pc = 0x82C62690; continue 'dispatch;
	}
	// 82C62678: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C6267C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C62680: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C62684: 388BDAA0  addi r4, r11, -0x2560
	ctx.r[4].s64 = ctx.r[11].s64 + -9568;
	// 82C62688: 4B5DD219  bl 0x8223f8a0
	ctx.lr = 0x82C6268C;
	sub_8223F8A0(ctx, base);
	// 82C6268C: 48000040  b 0x82c626cc
	pc = 0x82C626CC; continue 'dispatch;
            }
            0x82C62690 => {
    //   block [0x82C62690..0x82C626B8)
	// 82C62690: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C62694: C80BDAB0  lfd f0, -0x2550(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-9552 as u32) ) };
	// 82C62698: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C6269C: 4098001C  bge cr6, 0x82c626b8
	if !ctx.cr[6].lt {
	pc = 0x82C626B8; continue 'dispatch;
	}
	// 82C626A0: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C626A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C626A8: 388BDA98  addi r4, r11, -0x2568
	ctx.r[4].s64 = ctx.r[11].s64 + -9576;
	// 82C626AC: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C626B0: 4B5DD1F1  bl 0x8223f8a0
	ctx.lr = 0x82C626B4;
	sub_8223F8A0(ctx, base);
	// 82C626B4: 48000018  b 0x82c626cc
	pc = 0x82C626CC; continue 'dispatch;
            }
            0x82C626B8 => {
    //   block [0x82C626B8..0x82C626CC)
	// 82C626B8: D8210020  stfd f1, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C626BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C626C0: 388BDAA8  addi r4, r11, -0x2558
	ctx.r[4].s64 = ctx.r[11].s64 + -9560;
	// 82C626C4: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C626C8: 4B5DD1D9  bl 0x8223f8a0
	ctx.lr = 0x82C626CC;
	sub_8223F8A0(ctx, base);
	pc = 0x82C626CC; continue 'dispatch;
            }
            0x82C626CC => {
    //   block [0x82C626CC..0x82C626F4)
	// 82C626CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C626D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C626D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C626D8: 4B66A9D1  bl 0x822cd0a8
	ctx.lr = 0x82C626DC;
	sub_822CD0A8(ctx, base);
	// 82C626DC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C626E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C626E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C626E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C626EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C626F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C626F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C626F8 size=112
    let mut pc: u32 = 0x82C626F8;
    'dispatch: loop {
        match pc {
            0x82C626F8 => {
    //   block [0x82C626F8..0x82C62740)
	// 82C626F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C626FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62700: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62704: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62708: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82C6270C: C00B0BFC  lfs f0, 0xbfc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62710: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C62714: 4099002C  ble cr6, 0x82c62740
	if !ctx.cr[6].gt {
	pc = 0x82C62740; continue 'dispatch;
	}
	// 82C62718: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82C6271C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C62720: 392BED50  addi r9, r11, -0x12b0
	ctx.r[9].s64 = ctx.r[11].s64 + -4784;
	// 82C62724: 890BED50  lbz r8, -0x12b0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-4784 as u32) ) } as u64;
	// 82C62728: 88E90001  lbz r7, 1(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 82C6272C: 88A90002  lbz r5, 2(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 82C62730: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82C62734: 98EA0001  stb r7, 1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(1 as u32), ctx.r[7].u8 ) };
	// 82C62738: 98AA0002  stb r5, 2(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[5].u8 ) };
	// 82C6273C: 48000010  b 0x82c6274c
	pc = 0x82C6274C; continue 'dispatch;
            }
            0x82C62740 => {
    //   block [0x82C62740..0x82C6274C)
	// 82C62740: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82C62744: 816BED4C  lwz r11, -0x12b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4788 as u32) ) } as u64;
	// 82C62748: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82C6274C; continue 'dispatch;
            }
            0x82C6274C => {
    //   block [0x82C6274C..0x82C62768)
	// 82C6274C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C62750: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C62754: 4B66A955  bl 0x822cd0a8
	ctx.lr = 0x82C62758;
	sub_822CD0A8(ctx, base);
	// 82C62758: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C6275C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C62768 size=100
    let mut pc: u32 = 0x82C62768;
    'dispatch: loop {
        match pc {
            0x82C62768 => {
    //   block [0x82C62768..0x82C62790)
	// 82C62768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6276C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C62774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6277C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C62780: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82C62784: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C62788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6278C: 419A0024  beq cr6, 0x82c627b0
	if ctx.cr[6].eq {
	pc = 0x82C627B0; continue 'dispatch;
	}
	pc = 0x82C62790; continue 'dispatch;
            }
            0x82C62790 => {
    //   block [0x82C62790..0x82C627B0)
	// 82C62790: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C62794: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82C62798: 4B58C4B1  bl 0x821eec48
	ctx.lr = 0x82C6279C;
	sub_821EEC48(ctx, base);
	// 82C6279C: 987F0000  stb r3, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 82C627A0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82C627A4: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C627A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C627AC: 409AFFE4  bne cr6, 0x82c62790
	if !ctx.cr[6].eq {
	pc = 0x82C62790; continue 'dispatch;
	}
	pc = 0x82C627B0; continue 'dispatch;
            }
            0x82C627B0 => {
    //   block [0x82C627B0..0x82C627CC)
	// 82C627B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C627B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C627B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C627BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C627C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C627C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C627C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C627D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C627D0 size=140
    let mut pc: u32 = 0x82C627D0;
    'dispatch: loop {
        match pc {
            0x82C627D0 => {
    //   block [0x82C627D0..0x82C627F8)
	// 82C627D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C627D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C627D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C627DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C627E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C627E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C627E8: 4BFFFF81  bl 0x82c62768
	ctx.lr = 0x82C627EC;
	sub_82C62768(ctx, base);
	// 82C627EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C627F0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C627F4: 394ADAC0  addi r10, r10, -0x2540
	ctx.r[10].s64 = ctx.r[10].s64 + -9536;
	pc = 0x82C627F8; continue 'dispatch;
            }
            0x82C627F8 => {
    //   block [0x82C627F8..0x82C6281C)
	// 82C627F8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C627FC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C62800: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C62804: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82C62808: 419A0014  beq cr6, 0x82c6281c
	if ctx.cr[6].eq {
	pc = 0x82C6281C; continue 'dispatch;
	}
	// 82C6280C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C62810: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C62814: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C62818: 419AFFE0  beq cr6, 0x82c627f8
	if ctx.cr[6].eq {
	pc = 0x82C627F8; continue 'dispatch;
	}
	pc = 0x82C6281C; continue 'dispatch;
            }
            0x82C6281C => {
    //   block [0x82C6281C..0x82C62840)
	// 82C6281C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C62820: 409A0020  bne cr6, 0x82c62840
	if !ctx.cr[6].eq {
	pc = 0x82C62840; continue 'dispatch;
	}
	// 82C62824: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62828: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C6282C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C62830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6283C: 4E800020  blr
	return;
            }
            0x82C62840 => {
    //   block [0x82C62840..0x82C6285C)
	// 82C62840: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62844: C02B0C18  lfs f1, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C62848: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6284C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62854: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62860 size=240
    let mut pc: u32 = 0x82C62860;
    'dispatch: loop {
        match pc {
            0x82C62860 => {
    //   block [0x82C62860..0x82C628C8)
	// 82C62860: 82CAE348  lwz r22, -0x1cb8(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7352 as u32) ) } as u64;
	// 82C62864: 8200DAD0  lwz r16, -0x2530(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -9520u32 ) } as u64;
	// 82C62868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6286C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C62874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62878: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C6287C: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82C62880: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62884: 909F00AC  stw r4, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82C62888: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6288C: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82C62890: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62894: 48004C35  bl 0x82c674c8
	ctx.lr = 0x82C62898;
	sub_82C674C8(ctx, base);
	// 82C62898: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82C6289C: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C628A0: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C628A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C628A8: 48004BC1  bl 0x82c67468
	ctx.lr = 0x82C628AC;
	sub_82C67468(ctx, base);
	// 82C628AC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C628B0: 409A0018  bne cr6, 0x82c628c8
	if !ctx.cr[6].eq {
	pc = 0x82C628C8; continue 'dispatch;
	}
	// 82C628B4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C628B8: 48004709  bl 0x82c66fc0
	ctx.lr = 0x82C628BC;
	sub_82C66FC0(ctx, base);
	// 82C628BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C628C0: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C628C4: 48000070  b 0x82c62934
	pc = 0x82C62934; continue 'dispatch;
            }
            0x82C628C8 => {
    //   block [0x82C628C8..0x82C628F8)
	// 82C628C8: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C628CC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C628D0: 480049E1  bl 0x82c672b0
	ctx.lr = 0x82C628D4;
	sub_82C672B0(ctx, base);
	// 82C628D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C628D8: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C628DC: 38ABDAC4  addi r5, r11, -0x253c
	ctx.r[5].s64 = ctx.r[11].s64 + -9532;
	// 82C628E0: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C628E4: 480047E5  bl 0x82c670c8
	ctx.lr = 0x82C628E8;
	sub_82C670C8(ctx, base);
	// 82C628E8: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C628EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C628F0: 419A0008  beq cr6, 0x82c628f8
	if ctx.cr[6].eq {
	pc = 0x82C628F8; continue 'dispatch;
	}
	// 82C628F4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82C628F8; continue 'dispatch;
            }
            0x82C628F8 => {
    //   block [0x82C628F8..0x82C62914)
	// 82C628F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C628FC: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62900: C1AB0AC8  lfs f13, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C62904: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C62908: 4198000C  blt cr6, 0x82c62914
	if ctx.cr[6].lt {
	pc = 0x82C62914; continue 'dispatch;
	}
	// 82C6290C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C62910: 419A0014  beq cr6, 0x82c62924
	if ctx.cr[6].eq {
	pc = 0x82C62924; continue 'dispatch;
	}
	pc = 0x82C62914; continue 'dispatch;
            }
            0x82C62914 => {
    //   block [0x82C62914..0x82C62924)
	// 82C62914: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C62918: C1AB9404  lfs f13, -0x6bfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C6291C: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C62920: 48000008  b 0x82c62928
	pc = 0x82C62928; continue 'dispatch;
            }
            0x82C62924 => {
    //   block [0x82C62924..0x82C62928)
	// 82C62924: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x82C62928; continue 'dispatch;
            }
            0x82C62928 => {
    //   block [0x82C62928..0x82C62934)
	// 82C62928: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C6292C: 48004695  bl 0x82c66fc0
	ctx.lr = 0x82C62930;
	sub_82C66FC0(ctx, base);
	// 82C62930: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82C62934; continue 'dispatch;
            }
            0x82C62934 => {
    //   block [0x82C62934..0x82C62950)
	// 82C62934: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82C62938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6293C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62940: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C62944: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6294C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62978 size=232
    let mut pc: u32 = 0x82C62978;
    'dispatch: loop {
        match pc {
            0x82C62978 => {
    //   block [0x82C62978..0x82C629EC)
	// 82C62978: 82CAE348  lwz r22, -0x1cb8(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7352 as u32) ) } as u64;
	// 82C6297C: 8200DB20  lwz r16, -0x24e0(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -9440u32 ) } as u64;
	// 82C62980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6298C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C62990: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82C62994: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62998: 909F00AC  stw r4, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82C6299C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C629A0: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82C629A4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C629A8: 48004B21  bl 0x82c674c8
	ctx.lr = 0x82C629AC;
	sub_82C674C8(ctx, base);
	// 82C629AC: 3880003A  li r4, 0x3a
	ctx.r[4].s64 = 58;
	// 82C629B0: 807F00AC  lwz r3, 0xac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82C629B4: 4804785D  bl 0x82caa210
	ctx.lr = 0x82C629B8;
	sub_82CAA210(ctx, base);
	// 82C629B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C629BC: 419A0030  beq cr6, 0x82c629ec
	if ctx.cr[6].eq {
	pc = 0x82C629EC; continue 'dispatch;
	}
	// 82C629C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C629C4: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C629C8: 38AB0C08  addi r5, r11, 0xc08
	ctx.r[5].s64 = ctx.r[11].s64 + 3080;
	// 82C629CC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C629D0: 48004831  bl 0x82c67200
	ctx.lr = 0x82C629D4;
	sub_82C67200(ctx, base);
	// 82C629D4: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82C629D8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C629DC: 2B0A003A  cmplwi cr6, r10, 0x3a
	ctx.cr[6].compare_u32(ctx.r[10].u32, 58 as u32, &mut ctx.xer);
	// 82C629E0: 409A000C  bne cr6, 0x82c629ec
	if !ctx.cr[6].eq {
	pc = 0x82C629EC; continue 'dispatch;
	}
	// 82C629E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C629E8: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	pc = 0x82C629EC; continue 'dispatch;
            }
            0x82C629EC => {
    //   block [0x82C629EC..0x82C62A10)
	// 82C629EC: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82C629F0: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C629F4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C629F8: 48004A71  bl 0x82c67468
	ctx.lr = 0x82C629FC;
	sub_82C67468(ctx, base);
	// 82C629FC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C62A00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62A04: 409A000C  bne cr6, 0x82c62a10
	if !ctx.cr[6].eq {
	pc = 0x82C62A10; continue 'dispatch;
	}
	// 82C62A08: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62A0C: 48000028  b 0x82c62a34
	pc = 0x82C62A34; continue 'dispatch;
            }
            0x82C62A10 => {
    //   block [0x82C62A10..0x82C62A34)
	// 82C62A10: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62A14: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C62A18: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C62A1C: 4099001C  ble cr6, 0x82c62a38
	if !ctx.cr[6].gt {
	pc = 0x82C62A38; continue 'dispatch;
	}
	// 82C62A20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62A24: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C62A28: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C62A2C: 4098000C  bge cr6, 0x82c62a38
	if !ctx.cr[6].lt {
	pc = 0x82C62A38; continue 'dispatch;
	}
	// 82C62A30: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x82C62A34; continue 'dispatch;
            }
            0x82C62A34 => {
    //   block [0x82C62A34..0x82C62A38)
	// 82C62A34: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82C62A38; continue 'dispatch;
            }
            0x82C62A38 => {
    //   block [0x82C62A38..0x82C62A60)
	// 82C62A38: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82C62A3C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62A40: 48004581  bl 0x82c66fc0
	ctx.lr = 0x82C62A44;
	sub_82C66FC0(ctx, base);
	// 82C62A44: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C62A48: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82C62A4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62A50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62A54: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62A58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62A88 size=152
    let mut pc: u32 = 0x82C62A88;
    'dispatch: loop {
        match pc {
            0x82C62A88 => {
    //   block [0x82C62A88..0x82C62AE0)
	// 82C62A88: 82CAE348  lwz r22, -0x1cb8(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7352 as u32) ) } as u64;
	// 82C62A8C: 8200DB60  lwz r16, -0x24a0(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -9376u32 ) } as u64;
	// 82C62A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62A98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62A9C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C62AA0: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82C62AA4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62AA8: 909F00AC  stw r4, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82C62AAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C62AB0: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82C62AB4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62AB8: 48004A11  bl 0x82c674c8
	ctx.lr = 0x82C62ABC;
	sub_82C674C8(ctx, base);
	// 82C62ABC: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82C62AC0: 389F00AC  addi r4, r31, 0xac
	ctx.r[4].s64 = ctx.r[31].s64 + 172;
	// 82C62AC4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62AC8: 480049A1  bl 0x82c67468
	ctx.lr = 0x82C62ACC;
	sub_82C67468(ctx, base);
	// 82C62ACC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C62AD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62AD4: 409A000C  bne cr6, 0x82c62ae0
	if !ctx.cr[6].eq {
	pc = 0x82C62AE0; continue 'dispatch;
	}
	// 82C62AD8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62ADC: 48000018  b 0x82c62af4
	pc = 0x82C62AF4; continue 'dispatch;
            }
            0x82C62AE0 => {
    //   block [0x82C62AE0..0x82C62AF4)
	// 82C62AE0: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62AE4: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C62AE8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C62AEC: 4099000C  ble cr6, 0x82c62af8
	if !ctx.cr[6].gt {
	pc = 0x82C62AF8; continue 'dispatch;
	}
	// 82C62AF0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82C62AF4; continue 'dispatch;
            }
            0x82C62AF4 => {
    //   block [0x82C62AF4..0x82C62AF8)
	// 82C62AF4: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82C62AF8; continue 'dispatch;
            }
            0x82C62AF8 => {
    //   block [0x82C62AF8..0x82C62B20)
	// 82C62AF8: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82C62AFC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C62B00: 480044C1  bl 0x82c66fc0
	ctx.lr = 0x82C62B04;
	sub_82C66FC0(ctx, base);
	// 82C62B04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C62B08: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82C62B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62B14: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62B18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C62B68 size=8
    let mut pc: u32 = 0x82C62B68;
    'dispatch: loop {
        match pc {
            0x82C62B68 => {
    //   block [0x82C62B68..0x82C62B70)
	// 82C62B68: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C62B6C: 4800117C  b 0x82c63ce8
	sub_82C63CE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C62B70 size=28
    let mut pc: u32 = 0x82C62B70;
    'dispatch: loop {
        match pc {
            0x82C62B70 => {
    //   block [0x82C62B70..0x82C62B84)
	// 82C62B70: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C62B74: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C62B78: 616A0020  ori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 | 32;
	// 82C62B7C: 409A0008  bne cr6, 0x82c62b84
	if !ctx.cr[6].eq {
	pc = 0x82C62B84; continue 'dispatch;
	}
	// 82C62B80: 556A06F2  rlwinm r10, r11, 0, 0x1b, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82C62B84; continue 'dispatch;
            }
            0x82C62B84 => {
    //   block [0x82C62B84..0x82C62B8C)
	// 82C62B84: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C62B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C62B90 size=76
    let mut pc: u32 = 0x82C62B90;
    'dispatch: loop {
        match pc {
            0x82C62B90 => {
    //   block [0x82C62B90..0x82C62BAC)
	// 82C62B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62B98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C62B9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62BA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C62BA8: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	pc = 0x82C62BAC; continue 'dispatch;
            }
            0x82C62BAC => {
    //   block [0x82C62BAC..0x82C62BDC)
	// 82C62BAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C62BB0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C62BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C62BB8: 48004959  bl 0x82c67510
	ctx.lr = 0x82C62BBC;
	sub_82C67510(ctx, base);
	// 82C62BBC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C62BC0: 419AFFEC  beq cr6, 0x82c62bac
	if ctx.cr[6].eq {
	pc = 0x82C62BAC; continue 'dispatch;
	}
	// 82C62BC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C62BC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62BCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62BD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62BD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62BD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C62BE0 size=28
    let mut pc: u32 = 0x82C62BE0;
    'dispatch: loop {
        match pc {
            0x82C62BE0 => {
    //   block [0x82C62BE0..0x82C62BF4)
	// 82C62BE0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C62BE4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C62BE8: 616A0100  ori r10, r11, 0x100
	ctx.r[10].u64 = ctx.r[11].u64 | 256;
	// 82C62BEC: 409A0008  bne cr6, 0x82c62bf4
	if !ctx.cr[6].eq {
	pc = 0x82C62BF4; continue 'dispatch;
	}
	// 82C62BF0: 556A062C  rlwinm r10, r11, 0, 0x18, 0x16
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82C62BF4; continue 'dispatch;
            }
            0x82C62BF4 => {
    //   block [0x82C62BF4..0x82C62BFC)
	// 82C62BF4: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C62BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C62C00 size=32
    let mut pc: u32 = 0x82C62C00;
    'dispatch: loop {
        match pc {
            0x82C62C00 => {
    //   block [0x82C62C00..0x82C62C20)
	// 82C62C00: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C62C04: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82C62C08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C62C0C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C62C10: C0230018  lfs f1, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C62C14: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C62C18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C62C1C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C62C28 size=28
    let mut pc: u32 = 0x82C62C28;
    'dispatch: loop {
        match pc {
            0x82C62C28 => {
    //   block [0x82C62C28..0x82C62C44)
	// 82C62C28: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C62C2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C62C30: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C62C34: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C62C38: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C62C3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C62C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C62C48 size=24
    let mut pc: u32 = 0x82C62C48;
    'dispatch: loop {
        match pc {
            0x82C62C48 => {
    //   block [0x82C62C48..0x82C62C60)
	// 82C62C48: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82C62C4C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C62C50: 419A0010  beq cr6, 0x82c62c60
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C62C60);
		return;
	}
	// 82C62C54: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62C58: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C62C5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C62C70 size=20
    let mut pc: u32 = 0x82C62C70;
    'dispatch: loop {
        match pc {
            0x82C62C70 => {
    //   block [0x82C62C70..0x82C62C84)
	// 82C62C70: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C62C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C62C78: 419A000C  beq cr6, 0x82c62c84
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C62C84);
		return;
	}
	// 82C62C7C: C02B000C  lfs f1, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C62C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C62C90 size=24
    let mut pc: u32 = 0x82C62C90;
    'dispatch: loop {
        match pc {
            0x82C62C90 => {
    //   block [0x82C62C90..0x82C62CA8)
	// 82C62C90: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C62C94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C62C98: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C62C9C: 48003FBC  b 0x82c66c58
	crate::recompiler::externs::call(ctx, base, 0x82C66C58);
	return;
	// 82C62CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C62CA8 size=20
    let mut pc: u32 = 0x82C62CA8;
    'dispatch: loop {
        match pc {
            0x82C62CA8 => {
    //   block [0x82C62CA8..0x82C62CBC)
	// 82C62CA8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C62CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C62CB0: 419A000C  beq cr6, 0x82c62cbc
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C62CBC);
		return;
	}
	// 82C62CB4: C02B0010  lfs f1, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C62CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C62CC8 size=24
    let mut pc: u32 = 0x82C62CC8;
    'dispatch: loop {
        match pc {
            0x82C62CC8 => {
    //   block [0x82C62CC8..0x82C62CE0)
	// 82C62CC8: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C62CCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C62CD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C62CD4: 48003F8C  b 0x82c66c60
	crate::recompiler::externs::call(ctx, base, 0x82C66C60);
	return;
	// 82C62CD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C62CE0 size=20
    let mut pc: u32 = 0x82C62CE0;
    'dispatch: loop {
        match pc {
            0x82C62CE0 => {
    //   block [0x82C62CE0..0x82C62CF4)
	// 82C62CE0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C62CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C62CE8: 419A000C  beq cr6, 0x82c62cf4
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C62CF4);
		return;
	}
	// 82C62CEC: C02B0014  lfs f1, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C62CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62D00 size=100
    let mut pc: u32 = 0x82C62D00;
    'dispatch: loop {
        match pc {
            0x82C62D00 => {
    //   block [0x82C62D00..0x82C62D64)
	// 82C62D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62D04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62D08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62D0C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C62D10: 54C307BC  rlwinm r3, r6, 0, 0x1e, 0x1e
	ctx.r[3].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82C62D14: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82C62D18: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C62D1C: 910A001C  stw r8, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 82C62D20: 7D0B5910  subfe r8, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[8].u32 = res;
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82C62D24: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C62D28: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82C62D2C: 550B07FA  rlwinm r11, r8, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82C62D30: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82C62D34: 90CA000C  stw r6, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82C62D38: 38EB0003  addi r7, r11, 3
	ctx.r[7].s64 = ctx.r[11].s64 + 3;
	// 82C62D3C: 912A0020  stw r9, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82C62D40: 90EA0014  stw r7, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82C62D44: 4BFFFF05  bl 0x82c62c48
	ctx.lr = 0x82C62D48;
	sub_82C62C48(ctx, base);
	// 82C62D48: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82C62D4C: C0060C14  lfs f0, 0xc14(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62D50: D00A0024  stfs f0, 0x24(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C62D54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C62D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62D60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C62D68 size=12
    let mut pc: u32 = 0x82C62D68;
    'dispatch: loop {
        match pc {
            0x82C62D68 => {
    //   block [0x82C62D68..0x82C62D74)
	// 82C62D68: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C62D6C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C62D70: 4BFFFF90  b 0x82c62d00
	sub_82C62D00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62D78 size=204
    let mut pc: u32 = 0x82C62D78;
    'dispatch: loop {
        match pc {
            0x82C62D78 => {
    //   block [0x82C62D78..0x82C62DEC)
	// 82C62D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62D80: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 82C62D84: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 82C62D88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62D8C: FD800890  fmr f12, f1
	ctx.f[12].f64 = ctx.f[1].f64;
	// 82C62D90: 4BFFFEE1  bl 0x82c62c70
	ctx.lr = 0x82C62D94;
	sub_82C62C70(ctx, base);
	// 82C62D94: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C62D98: 4BFFFF11  bl 0x82c62ca8
	ctx.lr = 0x82C62D9C;
	sub_82C62CA8(ctx, base);
	// 82C62D9C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C62DA0: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82C62DA4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82C62DA8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C62DAC: 419A0040  beq cr6, 0x82c62dec
	if ctx.cr[6].eq {
	pc = 0x82C62DEC; continue 'dispatch;
	}
	// 82C62DB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62DB4: C02B0C18  lfs f1, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C62DB8: FF1E0800  fcmpu cr6, f30, f1
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 82C62DBC: 40990070  ble cr6, 0x82c62e2c
	if !ctx.cr[6].gt {
	pc = 0x82C62E2C; continue 'dispatch;
	}
	// 82C62DC0: FF1F0800  fcmpu cr6, f31, f1
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82C62DC4: 40990068  ble cr6, 0x82c62e2c
	if !ctx.cr[6].gt {
	pc = 0x82C62E2C; continue 'dispatch;
	}
	// 82C62DC8: C0430024  lfs f2, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C62DCC: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 82C62DD0: 4B59B6D9  bl 0x821fe4a8
	ctx.lr = 0x82C62DD4;
	sub_821FE4A8(ctx, base);
	// 82C62DD4: FC400818  frsp f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C62DD8: EC3EF824  fdivs f1, f30, f31
	ctx.f[1].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82C62DDC: 4B59B6CD  bl 0x821fe4a8
	ctx.lr = 0x82C62DE0;
	sub_821FE4A8(ctx, base);
	// 82C62DE0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C62DE4: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82C62DE8: 48000044  b 0x82c62e2c
	pc = 0x82C62E2C; continue 'dispatch;
            }
            0x82C62DEC => {
    //   block [0x82C62DEC..0x82C62E24)
	// 82C62DEC: 556B0672  rlwinm r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C62DF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C62DF4: 419A0030  beq cr6, 0x82c62e24
	if ctx.cr[6].eq {
	pc = 0x82C62E24; continue 'dispatch;
	}
	// 82C62DF8: ED7EF828  fsubs f11, f30, f31
	ctx.f[11].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82C62DFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62E00: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82C62E04: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C62E08: C9AA13F8  lfd f13, 0x13f8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(5112 as u32) ) };
	// 82C62E0C: ED4B002A  fadds f10, f11, f0
	ctx.f[10].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82C62E10: FD2A6828  fsub f9, f10, f13
	ctx.f[9].f64 = ctx.f[10].f64 - ctx.f[13].f64;
	// 82C62E14: FC29FB3A  fmadd f1, f9, f12, f31
	ctx.f[1].f64 = ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[31].f64;
	// 82C62E18: 4B5C9579  bl 0x8222c390
	ctx.lr = 0x82C62E1C;
	sub_8222C390(ctx, base);
	// 82C62E1C: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C62E20: 4800000C  b 0x82c62e2c
	pc = 0x82C62E2C; continue 'dispatch;
            }
            0x82C62E24 => {
    //   block [0x82C62E24..0x82C62E2C)
	// 82C62E24: EC1EF828  fsubs f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82C62E28: EC20FB3A  fmadds f1, f0, f12, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64);
	pc = 0x82C62E2C; continue 'dispatch;
            }
            0x82C62E2C => {
    //   block [0x82C62E2C..0x82C62E44)
	// 82C62E2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C62E30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62E34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62E38: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C62E3C: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62E40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62E48 size=244
    let mut pc: u32 = 0x82C62E48;
    'dispatch: loop {
        match pc {
            0x82C62E48 => {
    //   block [0x82C62E48..0x82C62EE4)
	// 82C62E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62E50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62E54: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82C62E58: 4804AE7D  bl 0x82cadcd4
	ctx.lr = 0x82C62E5C;
	sub_82CADCA0(ctx, base);
	// 82C62E5C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62E60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C62E64: FDA00890  fmr f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[1].f64;
	// 82C62E68: 4BFFFE09  bl 0x82c62c70
	ctx.lr = 0x82C62E6C;
	sub_82C62C70(ctx, base);
	// 82C62E6C: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82C62E70: 4BFFFE39  bl 0x82c62ca8
	ctx.lr = 0x82C62E74;
	sub_82C62CA8(ctx, base);
	// 82C62E74: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C62E78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C62E7C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C62E80: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C62E84: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82C62E88: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C62E8C: C3AA0C14  lfs f29, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82C62E90: C3C90C18  lfs f30, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C62E94: 419A0050  beq cr6, 0x82c62ee4
	if ctx.cr[6].eq {
	pc = 0x82C62EE4; continue 'dispatch;
	}
	// 82C62E98: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82C62E9C: 40990070  ble cr6, 0x82c62f0c
	if !ctx.cr[6].gt {
	pc = 0x82C62F0C; continue 'dispatch;
	}
	// 82C62EA0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82C62EA4: 40990068  ble cr6, 0x82c62f0c
	if !ctx.cr[6].gt {
	pc = 0x82C62F0C; continue 'dispatch;
	}
	// 82C62EA8: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 82C62EAC: 419A0060  beq cr6, 0x82c62f0c
	if ctx.cr[6].eq {
	pc = 0x82C62F0C; continue 'dispatch;
	}
	// 82C62EB0: EF9D0024  fdivs f28, f29, f0
	ctx.f[28].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 82C62EB4: EC3C0372  fmuls f1, f28, f13
	ctx.f[1].f64 = (((ctx.f[28].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C62EB8: 4B590EF9  bl 0x821f3db0
	ctx.lr = 0x82C62EBC;
	sub_821F3DB0(ctx, base);
	// 82C62EBC: FF600818  frsp f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C62EC0: EC3C07F2  fmuls f1, f28, f31
	ctx.f[1].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 82C62EC4: 4B590EED  bl 0x821f3db0
	ctx.lr = 0x82C62EC8;
	sub_821F3DB0(ctx, base);
	// 82C62EC8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C62ECC: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C62ED0: EC5D6824  fdivs f2, f29, f13
	ctx.f[2].f64 = ((ctx.f[29].f64 / ctx.f[13].f64) as f32) as f64;
	// 82C62ED4: EC3B0024  fdivs f1, f27, f0
	ctx.f[1].f64 = ((ctx.f[27].f64 / ctx.f[0].f64) as f32) as f64;
	// 82C62ED8: 4B59B5D1  bl 0x821fe4a8
	ctx.lr = 0x82C62EDC;
	sub_821FE4A8(ctx, base);
	// 82C62EDC: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C62EE0: 48000024  b 0x82c62f04
	pc = 0x82C62F04; continue 'dispatch;
            }
            0x82C62EE4 => {
    //   block [0x82C62EE4..0x82C62EF8)
	// 82C62EE4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82C62EE8: 409A0010  bne cr6, 0x82c62ef8
	if !ctx.cr[6].eq {
	pc = 0x82C62EF8; continue 'dispatch;
	}
	// 82C62EEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C62EF0: C02B0C18  lfs f1, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C62EF4: 4800002C  b 0x82c62f20
	pc = 0x82C62F20; continue 'dispatch;
            }
            0x82C62EF8 => {
    //   block [0x82C62EF8..0x82C62F04)
	// 82C62EF8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C62EFC: ED9F0028  fsubs f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C62F00: EC2D6024  fdivs f1, f13, f12
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	pc = 0x82C62F04; continue 'dispatch;
            }
            0x82C62F04 => {
    //   block [0x82C62F04..0x82C62F0C)
	// 82C62F04: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82C62F08: 4098000C  bge cr6, 0x82c62f14
	if !ctx.cr[6].lt {
	pc = 0x82C62F14; continue 'dispatch;
	}
	pc = 0x82C62F0C; continue 'dispatch;
            }
            0x82C62F0C => {
    //   block [0x82C62F0C..0x82C62F14)
	// 82C62F0C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C62F10: 48000010  b 0x82c62f20
	pc = 0x82C62F20; continue 'dispatch;
            }
            0x82C62F14 => {
    //   block [0x82C62F14..0x82C62F20)
	// 82C62F14: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82C62F18: 40990008  ble cr6, 0x82c62f20
	if !ctx.cr[6].gt {
	pc = 0x82C62F20; continue 'dispatch;
	}
	// 82C62F1C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	pc = 0x82C62F20; continue 'dispatch;
            }
            0x82C62F20 => {
    //   block [0x82C62F20..0x82C62F3C)
	// 82C62F20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C62F24: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82C62F28: 4804ADF9  bl 0x82cadd20
	ctx.lr = 0x82C62F2C;
	sub_82CADCEC(ctx, base);
	// 82C62F2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62F30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62F34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C62F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C62F40 size=40
    let mut pc: u32 = 0x82C62F40;
    'dispatch: loop {
        match pc {
            0x82C62F40 => {
    //   block [0x82C62F40..0x82C62F68)
	// 82C62F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62F48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62F4C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C62F50: 48309E09  bl 0x82f6cd58
	ctx.lr = 0x82C62F54;
	sub_82F6CD58(ctx, base);
	// 82C62F54: 4BFFFEF5  bl 0x82c62e48
	ctx.lr = 0x82C62F58;
	sub_82C62E48(ctx, base);
	// 82C62F58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C62F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C62F68 size=128
    let mut pc: u32 = 0x82C62F68;
    'dispatch: loop {
        match pc {
            0x82C62F68 => {
    //   block [0x82C62F68..0x82C62FA8)
	// 82C62F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62F70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62F74: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C62F78: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C62F7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82C62F80: 48309DD9  bl 0x82f6cd58
	ctx.lr = 0x82C62F84;
	sub_82F6CD58(ctx, base);
	// 82C62F84: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C62F88: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C62F8C: D0210054  stfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C62F90: 556806B4  rlwinm r8, r11, 0, 0x1a, 0x1a
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C62F94: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82C62F98: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C62F9C: 419A000C  beq cr6, 0x82c62fa8
	if ctx.cr[6].eq {
	pc = 0x82C62FA8; continue 'dispatch;
	}
	// 82C62FA0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82C62FA4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	pc = 0x82C62FA8; continue 'dispatch;
            }
            0x82C62FA8 => {
    //   block [0x82C62FA8..0x82C62FBC)
	// 82C62FA8: 556B05EE  rlwinm r11, r11, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C62FAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C62FB0: 419A000C  beq cr6, 0x82c62fbc
	if ctx.cr[6].eq {
	pc = 0x82C62FBC; continue 'dispatch;
	}
	// 82C62FB4: 612B0002  ori r11, r9, 2
	ctx.r[11].u64 = ctx.r[9].u64 | 2;
	// 82C62FB8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82C62FBC; continue 'dispatch;
            }
            0x82C62FBC => {
    //   block [0x82C62FBC..0x82C62FD8)
	// 82C62FBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C62FC0: 419A0018  beq cr6, 0x82c62fd8
	if ctx.cr[6].eq {
	pc = 0x82C62FD8; continue 'dispatch;
	}
	// 82C62FC4: 806A001C  lwz r3, 0x1c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C62FC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C62FCC: 419A000C  beq cr6, 0x82c62fd8
	if ctx.cr[6].eq {
	pc = 0x82C62FD8; continue 'dispatch;
	}
	// 82C62FD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C62FD4: 48000745  bl 0x82c63718
	ctx.lr = 0x82C62FD8;
	sub_82C63718(ctx, base);
	pc = 0x82C62FD8; continue 'dispatch;
            }
            0x82C62FD8 => {
    //   block [0x82C62FD8..0x82C62FE8)
	// 82C62FD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C62FDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C62FE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C62FE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C62FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C62FE8 size=68
    let mut pc: u32 = 0x82C62FE8;
    'dispatch: loop {
        match pc {
            0x82C62FE8 => {
    //   block [0x82C62FE8..0x82C6302C)
	// 82C62FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C62FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C62FF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C62FF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C62FF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C62FFC: 4BFFFF6D  bl 0x82c62f68
	ctx.lr = 0x82C63000;
	sub_82C62F68(ctx, base);
	// 82C63000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63004: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C63008: 4BFFFB89  bl 0x82c62b90
	ctx.lr = 0x82C6300C;
	sub_82C62B90(ctx, base);
	// 82C6300C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C63010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63014: 4BFFFBCD  bl 0x82c62be0
	ctx.lr = 0x82C63018;
	sub_82C62BE0(ctx, base);
	// 82C63018: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6301C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63020: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63024: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C63028: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63030 size=84
    let mut pc: u32 = 0x82C63030;
    'dispatch: loop {
        match pc {
            0x82C63030 => {
    //   block [0x82C63030..0x82C63070)
	// 82C63030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63038: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6303C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63044: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82C63048: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6304C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63050: 419A0020  beq cr6, 0x82c63070
	if ctx.cr[6].eq {
	pc = 0x82C63070; continue 'dispatch;
	}
	// 82C63054: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C63058: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C6305C: 480044B5  bl 0x82c67510
	ctx.lr = 0x82C63060;
	sub_82C67510(ctx, base);
	// 82C63060: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C63064: 419A000C  beq cr6, 0x82c63070
	if ctx.cr[6].eq {
	pc = 0x82C63070; continue 'dispatch;
	}
	// 82C63068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6306C: 4BFFFEFD  bl 0x82c62f68
	ctx.lr = 0x82C63070;
	sub_82C62F68(ctx, base);
	pc = 0x82C63070; continue 'dispatch;
            }
            0x82C63070 => {
    //   block [0x82C63070..0x82C63084)
	// 82C63070: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C63074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6307C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C63080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C63088 size=172
    let mut pc: u32 = 0x82C63088;
    'dispatch: loop {
        match pc {
            0x82C63088 => {
    //   block [0x82C63088..0x82C630BC)
	// 82C63088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6308C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C63094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C63098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6309C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C630A0: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82C630A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C630A8: 4BFFFC01  bl 0x82c62ca8
	ctx.lr = 0x82C630AC;
	sub_82C62CA8(ctx, base);
	// 82C630AC: FF000800  fcmpu cr6, f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82C630B0: 4099000C  ble cr6, 0x82c630bc
	if !ctx.cr[6].gt {
	pc = 0x82C630BC; continue 'dispatch;
	}
	// 82C630B4: 4BFFFBF5  bl 0x82c62ca8
	ctx.lr = 0x82C630B8;
	sub_82C62CA8(ctx, base);
	// 82C630B8: 48000018  b 0x82c630d0
	pc = 0x82C630D0; continue 'dispatch;
            }
            0x82C630BC => {
    //   block [0x82C630BC..0x82C630D0)
	// 82C630BC: 4BFFFBB5  bl 0x82c62c70
	ctx.lr = 0x82C630C0;
	sub_82C62C70(ctx, base);
	// 82C630C0: FF000800  fcmpu cr6, f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82C630C4: 40980010  bge cr6, 0x82c630d4
	if !ctx.cr[6].lt {
	pc = 0x82C630D4; continue 'dispatch;
	}
	// 82C630C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C630CC: 4BFFFBA5  bl 0x82c62c70
	ctx.lr = 0x82C630D0;
	sub_82C62C70(ctx, base);
	pc = 0x82C630D0; continue 'dispatch;
            }
            0x82C630D0 => {
    //   block [0x82C630D0..0x82C630D4)
	// 82C630D0: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	pc = 0x82C630D4; continue 'dispatch;
            }
            0x82C630D4 => {
    //   block [0x82C630D4..0x82C630F0)
	// 82C630D4: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C630D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C630DC: 419A0014  beq cr6, 0x82c630f0
	if ctx.cr[6].eq {
	pc = 0x82C630F0; continue 'dispatch;
	}
	// 82C630E0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C630E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C630E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C630EC: 4BFFFB15  bl 0x82c62c00
	ctx.lr = 0x82C630F0;
	sub_82C62C00(ctx, base);
	pc = 0x82C630F0; continue 'dispatch;
            }
            0x82C630F0 => {
    //   block [0x82C630F0..0x82C6311C)
	// 82C630F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C630F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C630F8: 4BFFFA79  bl 0x82c62b70
	ctx.lr = 0x82C630FC;
	sub_82C62B70(ctx, base);
	// 82C630FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C63100: 4BFFFA91  bl 0x82c62b90
	ctx.lr = 0x82C63104;
	sub_82C62B90(ctx, base);
	// 82C63104: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C63108: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C6310C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C63110: 409A000C  bne cr6, 0x82c6311c
	if !ctx.cr[6].eq {
	pc = 0x82C6311C; continue 'dispatch;
	}
	// 82C63114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63118: 4BFFFED1  bl 0x82c62fe8
	ctx.lr = 0x82C6311C;
	sub_82C62FE8(ctx, base);
	pc = 0x82C6311C; continue 'dispatch;
            }
            0x82C6311C => {
    //   block [0x82C6311C..0x82C63134)
	// 82C6311C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C63120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63128: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6312C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C63130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C63138 size=252
    let mut pc: u32 = 0x82C63138;
    'dispatch: loop {
        match pc {
            0x82C63138 => {
    //   block [0x82C63138..0x82C63168)
	// 82C63138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6313C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C63144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C63148: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C6314C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63150: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63154: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C63158: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6315C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C63160: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82C63164: 419900B4  bgt cr6, 0x82c63218
	if ctx.cr[6].gt {
	pc = 0x82C63218; continue 'dispatch;
	}
	pc = 0x82C63168; continue 'dispatch;
            }
            0x82C63168 => {
    //   block [0x82C63168..0x82C63190)
	// 82C63168: 3D8082C6  lis r12, -0x7d3a
	ctx.r[12].s64 = -2100953088;
	// 82C6316C: 398C3180  addi r12, r12, 0x3180
	ctx.r[12].s64 = ctx.r[12].s64 + 12672;
	// 82C63170: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82C63174: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82C63178: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82C6317C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82C63190; continue 'dispatch;
		},
		1 => {
	pc = 0x82C631BC; continue 'dispatch;
		},
		2 => {
	pc = 0x82C631DC; continue 'dispatch;
		},
		3 => {
	pc = 0x82C63200; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82C63180: 82C63190  lwz r22, 0x3190(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12688 as u32) ) } as u64;
	// 82C63184: 82C631BC  lwz r22, 0x31bc(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12732 as u32) ) } as u64;
	// 82C63188: 82C631DC  lwz r22, 0x31dc(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12764 as u32) ) } as u64;
	// 82C6318C: 82C63200  lwz r22, 0x3200(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12800 as u32) ) } as u64;
            }
            0x82C63190 => {
    //   block [0x82C63190..0x82C631A8)
	// 82C63190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63194: 4BFFFDAD  bl 0x82c62f40
	ctx.lr = 0x82C63198;
	sub_82C62F40(ctx, base);
	// 82C63198: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82C6319C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C631A0: 41980008  blt cr6, 0x82c631a8
	if ctx.cr[6].lt {
	pc = 0x82C631A8; continue 'dispatch;
	}
	// 82C631A4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82C631A8; continue 'dispatch;
            }
            0x82C631A8 => {
    //   block [0x82C631A8..0x82C631BC)
	// 82C631A8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C631AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C631B0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82C631B4: 4099FFB4  ble cr6, 0x82c63168
	if !ctx.cr[6].gt {
	pc = 0x82C63168; continue 'dispatch;
	}
	// 82C631B8: 48000060  b 0x82c63218
	pc = 0x82C63218; continue 'dispatch;
            }
            0x82C631BC => {
    //   block [0x82C631BC..0x82C631DC)
	// 82C631BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C631C0: 4BFFFD81  bl 0x82c62f40
	ctx.lr = 0x82C631C4;
	sub_82C62F40(ctx, base);
	// 82C631C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C631C8: C00B0A90  lfs f0, 0xa90(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C631CC: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C631D0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82C631D4: 41980044  blt cr6, 0x82c63218
	if ctx.cr[6].lt {
	pc = 0x82C63218; continue 'dispatch;
	}
	// 82C631D8: 48000020  b 0x82c631f8
	pc = 0x82C631F8; continue 'dispatch;
            }
            0x82C631DC => {
    //   block [0x82C631DC..0x82C631F8)
	// 82C631DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C631E0: 4BFFFD61  bl 0x82c62f40
	ctx.lr = 0x82C631E4;
	sub_82C62F40(ctx, base);
	// 82C631E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C631E8: C00B0A90  lfs f0, 0xa90(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C631EC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82C631F0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82C631F4: 41990024  bgt cr6, 0x82c63218
	if ctx.cr[6].gt {
	pc = 0x82C63218; continue 'dispatch;
	}
	pc = 0x82C631F8; continue 'dispatch;
            }
            0x82C631F8 => {
    //   block [0x82C631F8..0x82C63200)
	// 82C631F8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82C631FC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x82C63200; continue 'dispatch;
            }
            0x82C63200 => {
    //   block [0x82C63200..0x82C63218)
	// 82C63200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63204: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C63208: 4BFFFB71  bl 0x82c62d78
	ctx.lr = 0x82C6320C;
	sub_82C62D78(ctx, base);
	// 82C6320C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63210: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C63214: 4BFFFE75  bl 0x82c63088
	ctx.lr = 0x82C63218;
	sub_82C63088(ctx, base);
	pc = 0x82C63218; continue 'dispatch;
            }
            0x82C63218 => {
    //   block [0x82C63218..0x82C63234)
	// 82C63218: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6321C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63220: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63224: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C63228: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6322C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C63230: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63238 size=72
    let mut pc: u32 = 0x82C63238;
    'dispatch: loop {
        match pc {
            0x82C63238 => {
    //   block [0x82C63238..0x82C6326C)
	// 82C63238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6323C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63240: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C63244: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63248: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6324C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C63250: 48000BA9  bl 0x82c63df8
	ctx.lr = 0x82C63254;
	sub_82C63DF8(ctx, base);
	// 82C63254: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C63258: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C6325C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C63260: 419A000C  beq cr6, 0x82c6326c
	if ctx.cr[6].eq {
	pc = 0x82C6326C; continue 'dispatch;
	}
	// 82C63264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63268: 4BFFFB11  bl 0x82c62d78
	ctx.lr = 0x82C6326C;
	sub_82C62D78(ctx, base);
	pc = 0x82C6326C; continue 'dispatch;
            }
            0x82C6326C => {
    //   block [0x82C6326C..0x82C63280)
	// 82C6326C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C63270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6327C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63280 size=72
    let mut pc: u32 = 0x82C63280;
    'dispatch: loop {
        match pc {
            0x82C63280 => {
    //   block [0x82C63280..0x82C632C8)
	// 82C63280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6328C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63290: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C63294: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C63298: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82C6329C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C632A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C632A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C632A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C632AC: 4BFFFA55  bl 0x82c62d00
	ctx.lr = 0x82C632B0;
	sub_82C62D00(ctx, base);
	// 82C632B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C632B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C632B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C632BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C632C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C632C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C632C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C632C8 size=76
    let mut pc: u32 = 0x82C632C8;
    'dispatch: loop {
        match pc {
            0x82C632C8 => {
    //   block [0x82C632C8..0x82C632F8)
	// 82C632C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C632CC: 48046141  bl 0x82ca940c
	ctx.lr = 0x82C632D0;
	sub_82CA93D0(ctx, base);
	// 82C632D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C632D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C632D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C632DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C632E0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C632E4: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C632E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C632EC: 419A000C  beq cr6, 0x82c632f8
	if ctx.cr[6].eq {
	pc = 0x82C632F8; continue 'dispatch;
	}
	// 82C632F0: 4BFFFC51  bl 0x82c62f40
	ctx.lr = 0x82C632F4;
	sub_82C62F40(ctx, base);
	// 82C632F4: 48000008  b 0x82c632fc
	pc = 0x82C632FC; continue 'dispatch;
            }
            0x82C632F8 => {
    //   block [0x82C632F8..0x82C632FC)
	// 82C632F8: 48309A61  bl 0x82f6cd58
	ctx.lr = 0x82C632FC;
	sub_82F6CD58(ctx, base);
	pc = 0x82C632FC; continue 'dispatch;
            }
            0x82C632FC => {
    //   block [0x82C632FC..0x82C63314)
	// 82C632FC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82C63300: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C63304: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C63308: 480009E1  bl 0x82c63ce8
	ctx.lr = 0x82C6330C;
	sub_82C63CE8(ctx, base);
	// 82C6330C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C63310: 4804614C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C63320 size=244
    let mut pc: u32 = 0x82C63320;
    'dispatch: loop {
        match pc {
            0x82C63320 => {
    //   block [0x82C63320..0x82C633C4)
	// 82C63320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63324: 480460E1  bl 0x82ca9404
	ctx.lr = 0x82C63328;
	sub_82CA93D0(ctx, base);
	// 82C63328: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82C6332C: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 82C63330: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C63338: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C6333C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C63340: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82C63344: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 82C63348: 394BDBC4  addi r10, r11, -0x243c
	ctx.r[10].s64 = ctx.r[11].s64 + -9276;
	// 82C6334C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C63350: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C63354: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C63358: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82C6335C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82C63360: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82C63364: 48003905  bl 0x82c66c68
	ctx.lr = 0x82C63368;
	sub_82C66C68(ctx, base);
	// 82C63368: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6336C: 387E0054  addi r3, r30, 0x54
	ctx.r[3].s64 = ctx.r[30].s64 + 84;
	// 82C63370: 48003BA9  bl 0x82c66f18
	ctx.lr = 0x82C63374;
	sub_82C66F18(ctx, base);
	// 82C63374: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C63378: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82C6337C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C63380: 387E0068  addi r3, r30, 0x68
	ctx.r[3].s64 = ctx.r[30].s64 + 104;
	// 82C63384: 48004265  bl 0x82c675e8
	ctx.lr = 0x82C63388;
	sub_82C675E8(ctx, base);
	// 82C63388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6338C: 395E0034  addi r10, r30, 0x34
	ctx.r[10].s64 = ctx.r[30].s64 + 52;
	// 82C63390: D3FE0014  stfs f31, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C63394: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82C63398: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82C6339C: 917E002C  stw r11, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82C633A0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82C633A4: 917E0028  stw r11, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82C633A8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C633AC: 913E0018  stw r9, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82C633B0: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82C633B4: 939E001C  stw r28, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 82C633B8: 937E0020  stw r27, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 82C633BC: 913E0030  stw r9, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82C633C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82C633C4; continue 'dispatch;
            }
            0x82C633C4 => {
    //   block [0x82C633C4..0x82C63414)
	// 82C633C4: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C633C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C633CC: 4200FFF8  bdnz 0x82c633c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82C633C4; continue 'dispatch;
	}
	// 82C633D0: 48004191  bl 0x82c67560
	ctx.lr = 0x82C633D4;
	sub_82C67560(ctx, base);
	// 82C633D4: 907E0084  stw r3, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82C633D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C633DC: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 82C633E0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82C633E4: 48046070  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C633E8: 3BECFF70  addi r31, r12, -0x90
	ctx.r[31].s64 = ctx.r[12].s64 + -144;
	// 82C633EC: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C633F0: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C633F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C633F8: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82C633FC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C63400: 480038C1  bl 0x82c66cc0
	ctx.lr = 0x82C63404;
	sub_82C66CC0(ctx, base);
	// 82C63404: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C63408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6340C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63414(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63414 size=44
    let mut pc: u32 = 0x82C63414;
    'dispatch: loop {
        match pc {
            0x82C63414 => {
    //   block [0x82C63414..0x82C63440)
	// 82C63414: 3BECFF70  addi r31, r12, -0x90
	ctx.r[31].s64 = ctx.r[12].s64 + -144;
	// 82C63418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6341C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63420: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63424: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82C63428: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82C6342C: 48003905  bl 0x82c66d30
	ctx.lr = 0x82C63430;
	sub_82C66D30(ctx, base);
	// 82C63430: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C63434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6343C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63500 size=44
    let mut pc: u32 = 0x82C63500;
    'dispatch: loop {
        match pc {
            0x82C63500 => {
    //   block [0x82C63500..0x82C6352C)
	// 82C63500: 3BECFF80  addi r31, r12, -0x80
	ctx.r[31].s64 = ctx.r[12].s64 + -128;
	// 82C63504: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63508: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6350C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63510: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C63514: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82C63518: 48003819  bl 0x82c66d30
	ctx.lr = 0x82C6351C;
	sub_82C66D30(ctx, base);
	// 82C6351C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C63520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6352C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6352C size=44
    let mut pc: u32 = 0x82C6352C;
    'dispatch: loop {
        match pc {
            0x82C6352C => {
    //   block [0x82C6352C..0x82C63558)
	// 82C6352C: 3BECFF80  addi r31, r12, -0x80
	ctx.r[31].s64 = ctx.r[12].s64 + -128;
	// 82C63530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63538: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6353C: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C63540: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82C63544: 4800410D  bl 0x82c67650
	ctx.lr = 0x82C63548;
	sub_82C67650(ctx, base);
	// 82C63548: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6354C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63558 size=32
    let mut pc: u32 = 0x82C63558;
    'dispatch: loop {
        match pc {
            0x82C63558 => {
    //   block [0x82C63558..0x82C63578)
	// 82C63558: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6355C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C63560: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82C63564: 9143002C  stw r10, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82C63568: 91230030  stw r9, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82C6356C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C63570: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C63574: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63578 size=28
    let mut pc: u32 = 0x82C63578;
    'dispatch: loop {
        match pc {
            0x82C63578 => {
    //   block [0x82C63578..0x82C6358C)
	// 82C63578: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6357C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C63580: 616A0001  ori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 | 1;
	// 82C63584: 409A0008  bne cr6, 0x82c6358c
	if !ctx.cr[6].eq {
	pc = 0x82C6358C; continue 'dispatch;
	}
	// 82C63588: 556A003C  rlwinm r10, r11, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82C6358C; continue 'dispatch;
            }
            0x82C6358C => {
    //   block [0x82C6358C..0x82C63594)
	// 82C6358C: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C63590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63598 size=32
    let mut pc: u32 = 0x82C63598;
    'dispatch: loop {
        match pc {
            0x82C63598 => {
    //   block [0x82C63598..0x82C635B8)
	// 82C63598: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C6359C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C635A0: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C635A4: 5563F7FE  rlwinm r3, r11, 0x1e, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82C635A8: 419A0010  beq cr6, 0x82c635b8
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C635B8);
		return;
	}
	// 82C635AC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82C635B0: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C635B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C635C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C635C8 size=32
    let mut pc: u32 = 0x82C635C8;
    'dispatch: loop {
        match pc {
            0x82C635C8 => {
    //   block [0x82C635C8..0x82C635E8)
	// 82C635C8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C635CC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C635D0: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C635D4: 5563EFFE  rlwinm r3, r11, 0x1d, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 82C635D8: 419A0010  beq cr6, 0x82c635e8
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C635E8);
		return;
	}
	// 82C635DC: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 82C635E0: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C635E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C635F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C635F8 size=20
    let mut pc: u32 = 0x82C635F8;
    'dispatch: loop {
        match pc {
            0x82C635F8 => {
    //   block [0x82C635F8..0x82C6360C)
	// 82C635F8: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 82C635FC: 40980010  bge cr6, 0x82c6360c
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82C6360C);
		return;
	}
	// 82C63600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C63604: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82C63608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63618 size=100
    let mut pc: u32 = 0x82C63618;
    'dispatch: loop {
        match pc {
            0x82C63618 => {
    //   block [0x82C63618..0x82C6363C)
	// 82C63618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6361C: 48045DF1  bl 0x82ca940c
	ctx.lr = 0x82C63620;
	sub_82CA93D0(ctx, base);
	// 82C63620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C63628: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C6362C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63630: 409A000C  bne cr6, 0x82c6363c
	if !ctx.cr[6].eq {
	pc = 0x82C6363C; continue 'dispatch;
	}
	// 82C63634: 38800200  li r4, 0x200
	ctx.r[4].s64 = 512;
	// 82C63638: 4BFFFFC1  bl 0x82c635f8
	ctx.lr = 0x82C6363C;
	sub_82C635F8(ctx, base);
	pc = 0x82C6363C; continue 'dispatch;
            }
            0x82C6363C => {
    //   block [0x82C6363C..0x82C63650)
	// 82C6363C: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C63640: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C63644: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63648: 4099002C  ble cr6, 0x82c63674
	if !ctx.cr[6].gt {
	pc = 0x82C63674; continue 'dispatch;
	}
	// 82C6364C: 3BFE0034  addi r31, r30, 0x34
	ctx.r[31].s64 = ctx.r[30].s64 + 52;
	pc = 0x82C63650; continue 'dispatch;
            }
            0x82C63650 => {
    //   block [0x82C63650..0x82C63674)
	// 82C63650: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C63654: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C63658: 4BFFC989  bl 0x82c5ffe0
	ctx.lr = 0x82C6365C;
	sub_82C5FFE0(ctx, base);
	// 82C6365C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C63660: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C63664: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C63668: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6366C: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C63670: 4198FFE0  blt cr6, 0x82c63650
	if ctx.cr[6].lt {
	pc = 0x82C63650; continue 'dispatch;
	}
	pc = 0x82C63674; continue 'dispatch;
            }
            0x82C63674 => {
    //   block [0x82C63674..0x82C6367C)
	// 82C63674: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C63678: 48045DE4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C63680 size=152
    let mut pc: u32 = 0x82C63680;
    'dispatch: loop {
        match pc {
            0x82C63680 => {
    //   block [0x82C63680..0x82C6369C)
	// 82C63680: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 82C63684: 41980068  blt cr6, 0x82c636ec
	if ctx.cr[6].lt {
	pc = 0x82C636EC; continue 'dispatch;
	}
	// 82C63688: 3965FFFC  addi r11, r5, -4
	ctx.r[11].s64 = ctx.r[5].s64 + -4;
	// 82C6368C: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C63690: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C63694: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C63698: 7CAA2850  subf r5, r10, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	pc = 0x82C6369C; continue 'dispatch;
            }
            0x82C6369C => {
    //   block [0x82C6369C..0x82C636EC)
	// 82C6369C: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C636A0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C636A4: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C636A8: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82C636AC: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C636B0: D1830000  stfs f12, 0(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C636B4: C1440004  lfs f10, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C636B8: ED2A582A  fadds f9, f10, f11
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 82C636BC: C1030008  lfs f8, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C636C0: D1230004  stfs f9, 4(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C636C4: C0E40008  lfs f7, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C636C8: ECC7402A  fadds f6, f7, f8
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[8].f64) as f32) as f64;
	// 82C636CC: C0A3000C  lfs f5, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C636D0: D0C30008  stfs f6, 8(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C636D4: C084000C  lfs f4, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C636D8: EC64282A  fadds f3, f4, f5
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[5].f64) as f32) as f64;
	// 82C636DC: D063000C  stfs f3, 0xc(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C636E0: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82C636E4: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82C636E8: 4082FFB4  bne 0x82c6369c
	if !ctx.cr[0].eq {
	pc = 0x82C6369C; continue 'dispatch;
	}
	pc = 0x82C636EC; continue 'dispatch;
            }
            0x82C636EC => {
    //   block [0x82C636EC..0x82C636F4)
	// 82C636EC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C636F0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C636F4; continue 'dispatch;
            }
            0x82C636F4 => {
    //   block [0x82C636F4..0x82C63718)
	// 82C636F4: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C636F8: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C636FC: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C63700: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C63704: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C63708: D1830000  stfs f12, 0(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C6370C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82C63710: 4181FFE4  bgt 0x82c636f4
	if ctx.cr[0].gt {
	pc = 0x82C636F4; continue 'dispatch;
	}
	// 82C63714: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63718 size=80
    let mut pc: u32 = 0x82C63718;
    'dispatch: loop {
        match pc {
            0x82C63718 => {
    //   block [0x82C63718..0x82C63768)
	// 82C63718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6371C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63720: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C63724: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C63728: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6372C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63730: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C63734: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82C63738: 48003E51  bl 0x82c67588
	ctx.lr = 0x82C6373C;
	sub_82C67588(ctx, base);
	// 82C6373C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C63740: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82C63744: 480035F5  bl 0x82c66d38
	ctx.lr = 0x82C63748;
	sub_82C66D38(ctx, base);
	// 82C63748: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82C6374C: 48003E5D  bl 0x82c675a8
	ctx.lr = 0x82C63750;
	sub_82C675A8(ctx, base);
	// 82C63750: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C63754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6375C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C63760: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C63764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C63778 size=188
    let mut pc: u32 = 0x82C63778;
    'dispatch: loop {
        match pc {
            0x82C63778 => {
    //   block [0x82C63778..0x82C637B0)
	// 82C63778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6377C: 48045C8D  bl 0x82ca9408
	ctx.lr = 0x82C63780;
	sub_82CA93D0(ctx, base);
	// 82C63780: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63788: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82C6378C: 48003DFD  bl 0x82c67588
	ctx.lr = 0x82C63790;
	sub_82C67588(ctx, base);
	// 82C63790: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C63794: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63798: 40990018  ble cr6, 0x82c637b0
	if !ctx.cr[6].gt {
	pc = 0x82C637B0; continue 'dispatch;
	}
	// 82C6379C: 3D6082C6  lis r11, -0x7d3a
	ctx.r[11].s64 = -2100953088;
	// 82C637A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C637A4: 388B3768  addi r4, r11, 0x3768
	ctx.r[4].s64 = ctx.r[11].s64 + 14184;
	// 82C637A8: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82C637AC: 48003675  bl 0x82c66e20
	ctx.lr = 0x82C637B0;
	sub_82C66E20(ctx, base);
	pc = 0x82C637B0; continue 'dispatch;
            }
            0x82C637B0 => {
    //   block [0x82C637B0..0x82C637D0)
	// 82C637B0: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82C637B4: 48003DF5  bl 0x82c675a8
	ctx.lr = 0x82C637B8;
	sub_82C675A8(ctx, base);
	// 82C637B8: 3BDF0068  addi r30, r31, 0x68
	ctx.r[30].s64 = ctx.r[31].s64 + 104;
	// 82C637BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C637C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C637C4: 48003F65  bl 0x82c67728
	ctx.lr = 0x82C637C8;
	sub_82C67728(ctx, base);
	// 82C637C8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C637CC: 419A0060  beq cr6, 0x82c6382c
	if ctx.cr[6].eq {
	pc = 0x82C6382C; continue 'dispatch;
	}
	pc = 0x82C637D0; continue 'dispatch;
            }
            0x82C637D0 => {
    //   block [0x82C637D0..0x82C6382C)
	// 82C637D0: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C637D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C637D8: 552407FE  clrlwi r4, r9, 0x1f
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82C637DC: 4BFFFDBD  bl 0x82c63598
	ctx.lr = 0x82C637E0;
	sub_82C63598(ctx, base);
	// 82C637E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C637E4: 5524FFFE  rlwinm r4, r9, 0x1f, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82C637E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C637EC: 4BFFFDDD  bl 0x82c635c8
	ctx.lr = 0x82C637F0;
	sub_82C635C8(ctx, base);
	// 82C637F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C637F4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C637F8: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C637FC: 4800340D  bl 0x82c66c08
	ctx.lr = 0x82C63800;
	sub_82C66C08(ctx, base);
	// 82C63800: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C63804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63808: 4BFFFD91  bl 0x82c63598
	ctx.lr = 0x82C6380C;
	sub_82C63598(ctx, base);
	// 82C6380C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C63810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63814: 4BFFFDB5  bl 0x82c635c8
	ctx.lr = 0x82C63818;
	sub_82C635C8(ctx, base);
	// 82C63818: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6381C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C63820: 48003F09  bl 0x82c67728
	ctx.lr = 0x82C63824;
	sub_82C67728(ctx, base);
	// 82C63824: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C63828: 409AFFA8  bne cr6, 0x82c637d0
	if !ctx.cr[6].eq {
	pc = 0x82C637D0; continue 'dispatch;
	}
	pc = 0x82C6382C; continue 'dispatch;
            }
            0x82C6382C => {
    //   block [0x82C6382C..0x82C63834)
	// 82C6382C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C63830: 48045C28  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63850 size=476
    let mut pc: u32 = 0x82C63850;
    'dispatch: loop {
        match pc {
            0x82C63850 => {
    //   block [0x82C63850..0x82C638A4)
	// 82C63850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63854: 48045BB1  bl 0x82ca9404
	ctx.lr = 0x82C63858;
	sub_82CA93D0(ctx, base);
	// 82C63858: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6385C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63860: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C63864: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C63868: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82C6386C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C63870: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C63874: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C63878: 419A0174  beq cr6, 0x82c639ec
	if ctx.cr[6].eq {
	pc = 0x82C639EC; continue 'dispatch;
	}
	// 82C6387C: 83BF0024  lwz r29, 0x24(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C63880: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C63884: 7D6BEA15  add. r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63888: 4081001C  ble 0x82c638a4
	if !ctx.cr[0].gt {
	pc = 0x82C638A4; continue 'dispatch;
	}
	// 82C6388C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C63890: 57AA003E  slwi r10, r29, 0
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C63894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C63898: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C6389C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C638A0: 48046069  bl 0x82ca9908
	ctx.lr = 0x82C638A4;
	sub_82CA9908(ctx, base);
	pc = 0x82C638A4; continue 'dispatch;
            }
            0x82C638A4 => {
    //   block [0x82C638A4..0x82C638CC)
	// 82C638A4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C638A8: 7D6BEA15  add. r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C638AC: 40810020  ble 0x82c638cc
	if !ctx.cr[0].gt {
	pc = 0x82C638CC; continue 'dispatch;
	}
	// 82C638B0: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C638B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C638B8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C638BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C638C0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C638C4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C638C8: 48046041  bl 0x82ca9908
	ctx.lr = 0x82C638CC;
	sub_82CA9908(ctx, base);
	pc = 0x82C638CC; continue 'dispatch;
            }
            0x82C638CC => {
    //   block [0x82C638CC..0x82C638D8)
	// 82C638CC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82C638D0: 40990154  ble cr6, 0x82c63a24
	if !ctx.cr[6].gt {
	pc = 0x82C63A24; continue 'dispatch;
	}
	// 82C638D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C638D8; continue 'dispatch;
            }
            0x82C638D8 => {
    //   block [0x82C638D8..0x82C638F8)
	// 82C638D8: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C638DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C638E0: 409A0018  bne cr6, 0x82c638f8
	if !ctx.cr[6].eq {
	pc = 0x82C638F8; continue 'dispatch;
	}
	// 82C638E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C638E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C638EC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C638F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C638F4: 4E800421  bctrl
	ctx.lr = 0x82C638F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C638F8 => {
    //   block [0x82C638F8..0x82C63910)
	// 82C638F8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C638FC: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C63900: 7FCA5850  subf r30, r10, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C63904: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82C63908: 41980008  blt cr6, 0x82c63910
	if ctx.cr[6].lt {
	pc = 0x82C63910; continue 'dispatch;
	}
	// 82C6390C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x82C63910; continue 'dispatch;
            }
            0x82C63910 => {
    //   block [0x82C63910..0x82C63924)
	// 82C63910: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C63914: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63918: 419A000C  beq cr6, 0x82c63924
	if ctx.cr[6].eq {
	pc = 0x82C63924; continue 'dispatch;
	}
	// 82C6391C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63920: 4BFFFE59  bl 0x82c63778
	ctx.lr = 0x82C63924;
	sub_82C63778(ctx, base);
	pc = 0x82C63924; continue 'dispatch;
            }
            0x82C63924 => {
    //   block [0x82C63924..0x82C6396C)
	// 82C63924: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63928: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6392C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82C63930: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C63934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63938: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6393C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C63940: 4E800421  bctrl
	ctx.lr = 0x82C63944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C63944: 80FF0024  lwz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C63948: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6394C: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82C63950: 7D2B3A15  add. r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C63954: 40810030  ble 0x82c63984
	if !ctx.cr[0].gt {
	pc = 0x82C63984; continue 'dispatch;
	}
	// 82C63958: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6395C: 54E9003E  slwi r9, r7, 0
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C63960: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C63964: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C63968: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
            }
            0x82C6396C => {
    //   block [0x82C6396C..0x82C63984)
	// 82C6396C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63970: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C63974: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C63978: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6397C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C63980: 4082FFEC  bne 0x82c6396c
	if !ctx.cr[0].eq {
	pc = 0x82C6396C; continue 'dispatch;
	}
	pc = 0x82C63984; continue 'dispatch;
            }
            0x82C63984 => {
    //   block [0x82C63984..0x82C639A4)
	// 82C63984: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C63988: 7D6B3A15  add. r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6398C: 40810030  ble 0x82c639bc
	if !ctx.cr[0].gt {
	pc = 0x82C639BC; continue 'dispatch;
	}
	// 82C63990: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C63994: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C63998: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C6399C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82C639A0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x82C639A4; continue 'dispatch;
            }
            0x82C639A4 => {
    //   block [0x82C639A4..0x82C639BC)
	// 82C639A4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C639A8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C639AC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82C639B0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C639B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C639B8: 4082FFEC  bne 0x82c639a4
	if !ctx.cr[0].eq {
	pc = 0x82C639A4; continue 'dispatch;
	}
	pc = 0x82C639BC; continue 'dispatch;
            }
            0x82C639BC => {
    //   block [0x82C639BC..0x82C639DC)
	// 82C639BC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C639C0: 7F7ED850  subf r27, r30, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[30].s64;
	// 82C639C4: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C639C8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C639CC: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82C639D0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C639D4: 41980008  blt cr6, 0x82c639dc
	if ctx.cr[6].lt {
	pc = 0x82C639DC; continue 'dispatch;
	}
	// 82C639D8: 93BF002C  stw r29, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	pc = 0x82C639DC; continue 'dispatch;
            }
            0x82C639DC => {
    //   block [0x82C639DC..0x82C639EC)
	// 82C639DC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82C639E0: 4199FEF8  bgt cr6, 0x82c638d8
	if ctx.cr[6].gt {
	pc = 0x82C638D8; continue 'dispatch;
	}
	// 82C639E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C639E8: 48045A6C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C639EC => {
    //   block [0x82C639EC..0x82C63A00)
	// 82C639EC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C639F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C639F4: 419A000C  beq cr6, 0x82c63a00
	if ctx.cr[6].eq {
	pc = 0x82C63A00; continue 'dispatch;
	}
	// 82C639F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C639FC: 4BFFFD7D  bl 0x82c63778
	ctx.lr = 0x82C63A00;
	sub_82C63778(ctx, base);
	pc = 0x82C63A00; continue 'dispatch;
            }
            0x82C63A00 => {
    //   block [0x82C63A00..0x82C63A24)
	// 82C63A00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63A04: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C63A08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C63A0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C63A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63A14: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C63A18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C63A1C: 4E800421  bctrl
	ctx.lr = 0x82C63A20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C63A20: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
            }
            0x82C63A24 => {
    //   block [0x82C63A24..0x82C63A2C)
	// 82C63A24: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C63A28: 48045A2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63A30 size=460
    let mut pc: u32 = 0x82C63A30;
    'dispatch: loop {
        match pc {
            0x82C63A30 => {
    //   block [0x82C63A30..0x82C63A70)
	// 82C63A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63A34: 480459D1  bl 0x82ca9404
	ctx.lr = 0x82C63A38;
	sub_82CA93D0(ctx, base);
	// 82C63A38: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63A40: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C63A44: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C63A48: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C63A4C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C63A50: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63A54: 4081001C  ble 0x82c63a70
	if !ctx.cr[0].gt {
	pc = 0x82C63A70; continue 'dispatch;
	}
	// 82C63A58: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C63A5C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C63A60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C63A64: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C63A68: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C63A6C: 48045E9D  bl 0x82ca9908
	ctx.lr = 0x82C63A70;
	sub_82CA9908(ctx, base);
	pc = 0x82C63A70; continue 'dispatch;
            }
            0x82C63A70 => {
    //   block [0x82C63A70..0x82C63A90)
	// 82C63A70: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C63A74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63A78: 40990018  ble cr6, 0x82c63a90
	if !ctx.cr[6].gt {
	pc = 0x82C63A90; continue 'dispatch;
	}
	// 82C63A7C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C63A80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C63A84: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C63A88: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C63A8C: 48045E7D  bl 0x82ca9908
	ctx.lr = 0x82C63A90;
	sub_82CA9908(ctx, base);
	pc = 0x82C63A90; continue 'dispatch;
            }
            0x82C63A90 => {
    //   block [0x82C63A90..0x82C63AA0)
	// 82C63A90: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C63A94: 40990160  ble cr6, 0x82c63bf4
	if !ctx.cr[6].gt {
	pc = 0x82C63BF4; continue 'dispatch;
	}
	// 82C63A98: 3B9F0034  addi r28, r31, 0x34
	ctx.r[28].s64 = ctx.r[31].s64 + 52;
	// 82C63A9C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82C63AA0; continue 'dispatch;
            }
            0x82C63AA0 => {
    //   block [0x82C63AA0..0x82C63AD0)
	// 82C63AA0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C63AA4: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C63AA8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C63AAC: 419A0024  beq cr6, 0x82c63ad0
	if ctx.cr[6].eq {
	pc = 0x82C63AD0; continue 'dispatch;
	}
	// 82C63AB0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C63AB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63AB8: 409A0018  bne cr6, 0x82c63ad0
	if !ctx.cr[6].eq {
	pc = 0x82C63AD0; continue 'dispatch;
	}
	// 82C63ABC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63AC4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C63AC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C63ACC: 4E800421  bctrl
	ctx.lr = 0x82C63AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C63AD0 => {
    //   block [0x82C63AD0..0x82C63AE8)
	// 82C63AD0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C63AD4: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C63AD8: 7FCA5850  subf r30, r10, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C63ADC: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82C63AE0: 41980008  blt cr6, 0x82c63ae8
	if ctx.cr[6].lt {
	pc = 0x82C63AE8; continue 'dispatch;
	}
	// 82C63AE4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82C63AE8; continue 'dispatch;
            }
            0x82C63AE8 => {
    //   block [0x82C63AE8..0x82C63AFC)
	// 82C63AE8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C63AEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63AF0: 419A000C  beq cr6, 0x82c63afc
	if ctx.cr[6].eq {
	pc = 0x82C63AFC; continue 'dispatch;
	}
	// 82C63AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63AF8: 4BFFFC81  bl 0x82c63778
	ctx.lr = 0x82C63AFC;
	sub_82C63778(ctx, base);
	pc = 0x82C63AFC; continue 'dispatch;
            }
            0x82C63AFC => {
    //   block [0x82C63AFC..0x82C63B38)
	// 82C63AFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63B00: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C63B04: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C63B08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C63B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63B10: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C63B14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C63B18: 4E800421  bctrl
	ctx.lr = 0x82C63B1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C63B1C: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C63B20: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82C63B24: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C63B28: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C63B2C: 40990034  ble cr6, 0x82c63b60
	if !ctx.cr[6].gt {
	pc = 0x82C63B60; continue 'dispatch;
	}
	// 82C63B30: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82C63B34: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
            }
            0x82C63B38 => {
    //   block [0x82C63B38..0x82C63B60)
	// 82C63B38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C63B3C: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63B40: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63B44: 4BFFFB3D  bl 0x82c63680
	ctx.lr = 0x82C63B48;
	sub_82C63680(ctx, base);
	// 82C63B48: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C63B4C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82C63B50: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C63B54: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82C63B58: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C63B5C: 4198FFDC  blt cr6, 0x82c63b38
	if ctx.cr[6].lt {
	pc = 0x82C63B38; continue 'dispatch;
	}
	pc = 0x82C63B60; continue 'dispatch;
            }
            0x82C63B60 => {
    //   block [0x82C63B60..0x82C63B84)
	// 82C63B60: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C63B64: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C63B68: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63B6C: 40810030  ble 0x82c63b9c
	if !ctx.cr[0].gt {
	pc = 0x82C63B9C; continue 'dispatch;
	}
	// 82C63B70: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C63B74: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C63B78: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C63B7C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C63B80: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x82C63B84; continue 'dispatch;
            }
            0x82C63B84 => {
    //   block [0x82C63B84..0x82C63B9C)
	// 82C63B84: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63B88: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C63B8C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C63B90: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C63B94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C63B98: 4082FFEC  bne 0x82c63b84
	if !ctx.cr[0].eq {
	pc = 0x82C63B84; continue 'dispatch;
	}
	pc = 0x82C63B9C; continue 'dispatch;
            }
            0x82C63B9C => {
    //   block [0x82C63B9C..0x82C63BB4)
	// 82C63B9C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C63BA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C63BA4: 40990028  ble cr6, 0x82c63bcc
	if !ctx.cr[6].gt {
	pc = 0x82C63BCC; continue 'dispatch;
	}
	// 82C63BA8: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C63BAC: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C63BB0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	pc = 0x82C63BB4; continue 'dispatch;
            }
            0x82C63BB4 => {
    //   block [0x82C63BB4..0x82C63BCC)
	// 82C63BB4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63BB8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C63BBC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C63BC0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C63BC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C63BC8: 4082FFEC  bne 0x82c63bb4
	if !ctx.cr[0].eq {
	pc = 0x82C63BB4; continue 'dispatch;
	}
	pc = 0x82C63BCC; continue 'dispatch;
            }
            0x82C63BCC => {
    //   block [0x82C63BCC..0x82C63BEC)
	// 82C63BCC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C63BD0: 7FBEE850  subf r29, r30, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82C63BD4: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C63BD8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C63BDC: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82C63BE0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C63BE4: 41980008  blt cr6, 0x82c63bec
	if ctx.cr[6].lt {
	pc = 0x82C63BEC; continue 'dispatch;
	}
	// 82C63BE8: 937F002C  stw r27, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[27].u32 ) };
	pc = 0x82C63BEC; continue 'dispatch;
            }
            0x82C63BEC => {
    //   block [0x82C63BEC..0x82C63BF4)
	// 82C63BEC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C63BF0: 4199FEB0  bgt cr6, 0x82c63aa0
	if ctx.cr[6].gt {
	pc = 0x82C63AA0; continue 'dispatch;
	}
	pc = 0x82C63BF4; continue 'dispatch;
            }
            0x82C63BF4 => {
    //   block [0x82C63BF4..0x82C63BFC)
	// 82C63BF4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C63BF8: 4804585C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63C00 size=68
    let mut pc: u32 = 0x82C63C00;
    'dispatch: loop {
        match pc {
            0x82C63C00 => {
    //   block [0x82C63C00..0x82C63C14)
	// 82C63C00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C63C04: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C63C08: 396B0CA0  addi r11, r11, 0xca0
	ctx.r[11].s64 = ctx.r[11].s64 + 3232;
	// 82C63C0C: 409A0008  bne cr6, 0x82c63c14
	if !ctx.cr[6].eq {
	pc = 0x82C63C14; continue 'dispatch;
	}
	// 82C63C10: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x82C63C14; continue 'dispatch;
            }
            0x82C63C14 => {
    //   block [0x82C63C14..0x82C63C28)
	// 82C63C14: 90830014  stw r4, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 82C63C18: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C63C1C: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82C63C20: 409A0008  bne cr6, 0x82c63c28
	if !ctx.cr[6].eq {
	pc = 0x82C63C28; continue 'dispatch;
	}
	// 82C63C24: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82C63C28; continue 'dispatch;
            }
            0x82C63C28 => {
    //   block [0x82C63C28..0x82C63C44)
	// 82C63C28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C63C2C: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 82C63C30: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C63C34: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C63C38: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82C63C3C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C63C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63C48 size=24
    let mut pc: u32 = 0x82C63C48;
    'dispatch: loop {
        match pc {
            0x82C63C48 => {
    //   block [0x82C63C48..0x82C63C60)
	// 82C63C48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63C4C: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82C63C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C63C54: 419A000C  beq cr6, 0x82c63c60
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C63C60);
		return;
	}
	// 82C63C58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C63C5C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63C70 size=116
    let mut pc: u32 = 0x82C63C70;
    'dispatch: loop {
        match pc {
            0x82C63C70 => {
    //   block [0x82C63C70..0x82C63CA8)
	// 82C63C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63C78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C63C7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C63C80: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63C84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C63C88: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C63C8C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C63C90: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C63C94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C63C98: 419A0010  beq cr6, 0x82c63ca8
	if ctx.cr[6].eq {
	pc = 0x82C63CA8; continue 'dispatch;
	}
	// 82C63C9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C63CA0: 4E800421  bctrl
	ctx.lr = 0x82C63CA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C63CA4: 48000028  b 0x82c63ccc
	pc = 0x82C63CCC; continue 'dispatch;
            }
            0x82C63CA8 => {
    //   block [0x82C63CA8..0x82C63CCC)
	// 82C63CA8: D8210020  stfd f1, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 82C63CAC: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82C63CB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C63CB4: 808B0018  lwz r4, 0x18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C63CB8: 4B5DBBE9  bl 0x8223f8a0
	ctx.lr = 0x82C63CBC;
	sub_8223F8A0(ctx, base);
	// 82C63CBC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C63CC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C63CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63CC8: 4BFFD2C1  bl 0x82c60f88
	ctx.lr = 0x82C63CCC;
	sub_82C60F88(ctx, base);
	pc = 0x82C63CCC; continue 'dispatch;
            }
            0x82C63CCC => {
    //   block [0x82C63CCC..0x82C63CE4)
	// 82C63CCC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C63CD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63CD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63CD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C63CDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C63CE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63CE8 size=264
    let mut pc: u32 = 0x82C63CE8;
    'dispatch: loop {
        match pc {
            0x82C63CE8 => {
    //   block [0x82C63CE8..0x82C63D28)
	// 82C63CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63CEC: 48045721  bl 0x82ca940c
	ctx.lr = 0x82C63CF0;
	sub_82CA93D0(ctx, base);
	// 82C63CF0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C63CF4: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63CF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63CFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C63D00: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C63D04: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C63D08: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C63D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C63D10: 419A0018  beq cr6, 0x82c63d28
	if ctx.cr[6].eq {
	pc = 0x82C63D28; continue 'dispatch;
	}
	// 82C63D14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C63D18: 4E800421  bctrl
	ctx.lr = 0x82C63D1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C63D1C: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82C63D20: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C63D24: 48045738  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C63D28 => {
    //   block [0x82C63D28..0x82C63D5C)
	// 82C63D28: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 82C63D2C: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 82C63D30: 4BFFFF41  bl 0x82c63c70
	ctx.lr = 0x82C63D34;
	sub_82C63C70(ctx, base);
	// 82C63D34: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 82C63D38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C63D3C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C63D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C63D44: 4BFFFF05  bl 0x82c63c48
	ctx.lr = 0x82C63D48;
	sub_82C63C48(ctx, base);
	// 82C63D48: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C63D4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C63D50: 419A0084  beq cr6, 0x82c63dd4
	if ctx.cr[6].eq {
	pc = 0x82C63DD4; continue 'dispatch;
	}
	// 82C63D54: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 82C63D58: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82C63D5C; continue 'dispatch;
            }
            0x82C63D5C => {
    //   block [0x82C63D5C..0x82C63D90)
	// 82C63D5C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63D60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C63D64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C63D68: 409AFFF4  bne cr6, 0x82c63d5c
	if !ctx.cr[6].eq {
	pc = 0x82C63D5C; continue 'dispatch;
	}
	// 82C63D6C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C63D70: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C63D74: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82C63D78: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82C63D7C: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C63D80: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 82C63D84: A14A4A00  lhz r10, 0x4a00(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18944 as u32) ) } as u64;
	// 82C63D88: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82C63D8C: 7D484B2E  sthx r10, r8, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u16) };
	pc = 0x82C63D90; continue 'dispatch;
            }
            0x82C63D90 => {
    //   block [0x82C63D90..0x82C63DC0)
	// 82C63D90: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63D94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C63D98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C63D9C: 409AFFF4  bne cr6, 0x82c63d90
	if !ctx.cr[6].eq {
	pc = 0x82C63D90; continue 'dispatch;
	}
	// 82C63DA0: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82C63DA4: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82C63DA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82C63DAC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82C63DB0: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C63DB4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C63DB8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82C63DBC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	pc = 0x82C63DC0; continue 'dispatch;
            }
            0x82C63DC0 => {
    //   block [0x82C63DC0..0x82C63DD4)
	// 82C63DC0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C63DC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C63DC8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82C63DCC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C63DD0: 409AFFF0  bne cr6, 0x82c63dc0
	if !ctx.cr[6].eq {
	pc = 0x82C63DC0; continue 'dispatch;
	}
	pc = 0x82C63DD4; continue 'dispatch;
            }
            0x82C63DD4 => {
    //   block [0x82C63DD4..0x82C63DF0)
	// 82C63DD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C63DD8: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82C63DDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C63DE0: 4BFFD1A9  bl 0x82c60f88
	ctx.lr = 0x82C63DE4;
	sub_82C60F88(ctx, base);
	// 82C63DE4: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82C63DE8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C63DEC: 48045670  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C63DF8 size=192
    let mut pc: u32 = 0x82C63DF8;
    'dispatch: loop {
        match pc {
            0x82C63DF8 => {
    //   block [0x82C63DF8..0x82C63E28)
	// 82C63DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63E00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C63E04: 3BE1FF80  addi r31, r1, -0x80
	ctx.r[31].s64 = ctx.r[1].s64 + -128;
	// 82C63E08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63E0C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C63E10: 909F009C  stw r4, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82C63E14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C63E18: 419A0010  beq cr6, 0x82c63e28
	if ctx.cr[6].eq {
	pc = 0x82C63E28; continue 'dispatch;
	}
	// 82C63E1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C63E20: 4E800421  bctrl
	ctx.lr = 0x82C63E24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C63E24: 48000058  b 0x82c63e7c
	pc = 0x82C63E7C; continue 'dispatch;
            }
            0x82C63E28 => {
    //   block [0x82C63E28..0x82C63E70)
	// 82C63E28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C63E2C: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82C63E30: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C63E34: 48003695  bl 0x82c674c8
	ctx.lr = 0x82C63E38;
	sub_82C674C8(ctx, base);
	// 82C63E38: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C63E3C: 389F009C  addi r4, r31, 0x9c
	ctx.r[4].s64 = ctx.r[31].s64 + 156;
	// 82C63E40: 38ABDC98  addi r5, r11, -0x2368
	ctx.r[5].s64 = ctx.r[11].s64 + -9064;
	// 82C63E44: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C63E48: 480033B9  bl 0x82c67200
	ctx.lr = 0x82C63E4C;
	sub_82C67200(ctx, base);
	// 82C63E4C: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82C63E50: 389F009C  addi r4, r31, 0x9c
	ctx.r[4].s64 = ctx.r[31].s64 + 156;
	// 82C63E54: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C63E58: 48003611  bl 0x82c67468
	ctx.lr = 0x82C63E5C;
	sub_82C67468(ctx, base);
	// 82C63E5C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C63E60: 409A0010  bne cr6, 0x82c63e70
	if !ctx.cr[6].eq {
	pc = 0x82C63E70; continue 'dispatch;
	}
	// 82C63E64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C63E68: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C63E6C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82C63E70; continue 'dispatch;
            }
            0x82C63E70 => {
    //   block [0x82C63E70..0x82C63E7C)
	// 82C63E70: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C63E74: 4800314D  bl 0x82c66fc0
	ctx.lr = 0x82C63E78;
	sub_82C66FC0(ctx, base);
	// 82C63E78: C03F0050  lfs f1, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x82C63E7C; continue 'dispatch;
            }
            0x82C63E7C => {
    //   block [0x82C63E7C..0x82C63EB8)
	// 82C63E7C: 383F0080  addi r1, r31, 0x80
	ctx.r[1].s64 = ctx.r[31].s64 + 128;
	// 82C63E80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63E84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63E88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C63E8C: 4E800020  blr
	return;
	// 82C63E90: 3BECFF80  addi r31, r12, -0x80
	ctx.r[31].s64 = ctx.r[12].s64 + -128;
	// 82C63E94: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63E98: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63E9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63EA0: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82C63EA4: 4800311D  bl 0x82c66fc0
	ctx.lr = 0x82C63EA8;
	sub_82C66FC0(ctx, base);
	// 82C63EA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C63EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63EB8 size=36
    let mut pc: u32 = 0x82C63EB8;
    'dispatch: loop {
        match pc {
            0x82C63EB8 => {
    //   block [0x82C63EB8..0x82C63EDC)
	// 82C63EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63EC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63EC4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C63EC8: 4BFFFD39  bl 0x82c63c00
	ctx.lr = 0x82C63ECC;
	sub_82C63C00(ctx, base);
	// 82C63ECC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C63ED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63ED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63EE0 size=44
    let mut pc: u32 = 0x82C63EE0;
    'dispatch: loop {
        match pc {
            0x82C63EE0 => {
    //   block [0x82C63EE0..0x82C63EF4)
	// 82C63EE0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C63EE4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C63EE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C63EEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C63EF0: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	pc = 0x82C63EF4; continue 'dispatch;
            }
            0x82C63EF4 => {
    //   block [0x82C63EF4..0x82C63F0C)
	// 82C63EF4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C63EF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C63EFC: 4200FFF8  bdnz 0x82c63ef4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82C63EF4; continue 'dispatch;
	}
	// 82C63F00: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C63F04: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C63F08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63F10 size=36
    let mut pc: u32 = 0x82C63F10;
    'dispatch: loop {
        match pc {
            0x82C63F10 => {
    //   block [0x82C63F10..0x82C63F24)
	// 82C63F10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C63F14: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C63F18: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C63F1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C63F20: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	pc = 0x82C63F24; continue 'dispatch;
            }
            0x82C63F24 => {
    //   block [0x82C63F24..0x82C63F34)
	// 82C63F24: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82C63F28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C63F2C: 4200FFF8  bdnz 0x82c63f24
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82C63F24; continue 'dispatch;
	}
	// 82C63F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63F38 size=48
    let mut pc: u32 = 0x82C63F38;
    'dispatch: loop {
        match pc {
            0x82C63F38 => {
    //   block [0x82C63F38..0x82C63F68)
	// 82C63F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63F40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63F44: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82C63F48: 5524F0BE  srwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82C63F4C: 4BFFFF95  bl 0x82c63ee0
	ctx.lr = 0x82C63F50;
	sub_82C63EE0(ctx, base);
	// 82C63F50: 552407BE  clrlwi r4, r9, 0x1e
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82C63F54: 4BFFFFBD  bl 0x82c63f10
	ctx.lr = 0x82C63F58;
	sub_82C63F10(ctx, base);
	// 82C63F58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C63F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63F68 size=12
    let mut pc: u32 = 0x82C63F68;
    'dispatch: loop {
        match pc {
            0x82C63F68 => {
    //   block [0x82C63F68..0x82C63F74)
	// 82C63F68: 3C80E582  lis r4, -0x1a7e
	ctx.r[4].s64 = -444465152;
	// 82C63F6C: 60844000  ori r4, r4, 0x4000
	ctx.r[4].u64 = ctx.r[4].u64 | 16384;
	// 82C63F70: 4B590F48  b 0x821f4eb8
	sub_821F4EB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C63F78 size=20
    let mut pc: u32 = 0x82C63F78;
    'dispatch: loop {
        match pc {
            0x82C63F78 => {
    //   block [0x82C63F78..0x82C63F8C)
	// 82C63F78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C63F7C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C63F80: 3C80E582  lis r4, -0x1a7e
	ctx.r[4].s64 = -444465152;
	// 82C63F84: 60844000  ori r4, r4, 0x4000
	ctx.r[4].u64 = ctx.r[4].u64 | 16384;
	// 82C63F88: 4B5920C0  b 0x821f6048
	sub_821F6048(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C63F90 size=76
    let mut pc: u32 = 0x82C63F90;
    'dispatch: loop {
        match pc {
            0x82C63F90 => {
    //   block [0x82C63F90..0x82C63FDC)
	// 82C63F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63F98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C63F9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C63FA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63FA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C63FA8: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 82C63FAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63FB0: 4BFFFF89  bl 0x82c63f38
	ctx.lr = 0x82C63FB4;
	sub_82C63F38(ctx, base);
	// 82C63FB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C63FB8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C63FBC: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C63FC0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C63FC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C63FC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C63FCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C63FD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C63FD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C63FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C63FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C63FE0 size=72
    let mut pc: u32 = 0x82C63FE0;
    'dispatch: loop {
        match pc {
            0x82C63FE0 => {
    //   block [0x82C63FE0..0x82C64028)
	// 82C63FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C63FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C63FE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C63FEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C63FF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C63FF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C63FF8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82C63FFC: 4BFFFF6D  bl 0x82c63f68
	ctx.lr = 0x82C64000;
	sub_82C63F68(ctx, base);
	// 82C64000: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C64004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C64008: 4BFFFF89  bl 0x82c63f90
	ctx.lr = 0x82C6400C;
	sub_82C63F90(ctx, base);
	// 82C6400C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C64010: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C64014: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C64018: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6401C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C64020: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64024: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C64028 size=132
    let mut pc: u32 = 0x82C64028;
    'dispatch: loop {
        match pc {
            0x82C64028 => {
    //   block [0x82C64028..0x82C64044)
	// 82C64028: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 82C6402C: 41980058  blt cr6, 0x82c64084
	if ctx.cr[6].lt {
	pc = 0x82C64084; continue 'dispatch;
	}
	// 82C64030: 3966FFFC  addi r11, r6, -4
	ctx.r[11].s64 = ctx.r[6].s64 + -4;
	// 82C64034: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C64038: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C6403C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64040: 7CCA3050  subf r6, r10, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	pc = 0x82C64044; continue 'dispatch;
            }
            0x82C64044 => {
    //   block [0x82C64044..0x82C64084)
	// 82C64044: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64048: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6404C: EDA00072  fmuls f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C64050: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C64054: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C64058: ED6C0072  fmuls f11, f12, f1
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C6405C: D1640004  stfs f11, 4(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C64060: C1430008  lfs f10, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C64064: ED2A0072  fmuls f9, f10, f1
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C64068: D1240008  stfs f9, 8(r4)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C6406C: C103000C  lfs f8, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C64070: ECE80072  fmuls f7, f8, f1
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C64074: D0E4000C  stfs f7, 0xc(r4)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C64078: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82C6407C: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82C64080: 4082FFC4  bne 0x82c64044
	if !ctx.cr[0].eq {
	pc = 0x82C64044; continue 'dispatch;
	}
	pc = 0x82C64084; continue 'dispatch;
            }
            0x82C64084 => {
    //   block [0x82C64084..0x82C6408C)
	// 82C64084: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C64088: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C6408C; continue 'dispatch;
            }
            0x82C6408C => {
    //   block [0x82C6408C..0x82C640AC)
	// 82C6408C: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64090: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C64094: EDA00072  fmuls f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C64098: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C6409C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82C640A0: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C640A4: 4181FFE8  bgt 0x82c6408c
	if ctx.cr[0].gt {
	pc = 0x82C6408C; continue 'dispatch;
	}
	// 82C640A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C640B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C640B0 size=152
    let mut pc: u32 = 0x82C640B0;
    'dispatch: loop {
        match pc {
            0x82C640B0 => {
    //   block [0x82C640B0..0x82C640CC)
	// 82C640B0: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 82C640B4: 41980068  blt cr6, 0x82c6411c
	if ctx.cr[6].lt {
	pc = 0x82C6411C; continue 'dispatch;
	}
	// 82C640B8: 3967FFFC  addi r11, r7, -4
	ctx.r[11].s64 = ctx.r[7].s64 + -4;
	// 82C640BC: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C640C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C640C4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C640C8: 7CEA3850  subf r7, r10, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	pc = 0x82C640CC; continue 'dispatch;
            }
            0x82C640CC => {
    //   block [0x82C640CC..0x82C6411C)
	// 82C640CC: EC01102A  fadds f0, f1, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64;
	// 82C640D0: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C640D4: ED8D0072  fmuls f12, f13, f1
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C640D8: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C640DC: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C640E0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C640E4: ED40102A  fadds f10, f0, f2
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[2].f64) as f32) as f64;
	// 82C640E8: ED2B0032  fmuls f9, f11, f0
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C640EC: D1240004  stfs f9, 4(r4)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C640F0: ED0A102A  fadds f8, f10, f2
	ctx.f[8].f64 = ((ctx.f[10].f64 + ctx.f[2].f64) as f32) as f64;
	// 82C640F4: C0E30008  lfs f7, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C640F8: ECC702B2  fmuls f6, f7, f10
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[10].f64) as f32) as f64);
	// 82C640FC: D0C40008  stfs f6, 8(r4)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C64100: C0A3000C  lfs f5, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C64104: EC850232  fmuls f4, f5, f8
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[8].f64) as f32) as f64);
	// 82C64108: D084000C  stfs f4, 0xc(r4)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C6410C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82C64110: EC28102A  fadds f1, f8, f2
	ctx.f[1].f64 = ((ctx.f[8].f64 + ctx.f[2].f64) as f32) as f64;
	// 82C64114: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82C64118: 4082FFB4  bne 0x82c640cc
	if !ctx.cr[0].eq {
	pc = 0x82C640CC; continue 'dispatch;
	}
	pc = 0x82C6411C; continue 'dispatch;
            }
            0x82C6411C => {
    //   block [0x82C6411C..0x82C64124)
	// 82C6411C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C64120: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C64124; continue 'dispatch;
            }
            0x82C64124 => {
    //   block [0x82C64124..0x82C64148)
	// 82C64124: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64128: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C6412C: EDA00072  fmuls f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C64130: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C64134: EC21102A  fadds f1, f1, f2
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64;
	// 82C64138: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82C6413C: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C64140: 4181FFE4  bgt 0x82c64124
	if ctx.cr[0].gt {
	pc = 0x82C64124; continue 'dispatch;
	}
	// 82C64144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C64148 size=108
    let mut pc: u32 = 0x82C64148;
    'dispatch: loop {
        match pc {
            0x82C64148 => {
    //   block [0x82C64148..0x82C64178)
	// 82C64148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6414C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C64150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C64154: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64158: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82C6415C: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82C64160: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C64164: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C64168: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6416C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C64170: 40990030  ble cr6, 0x82c641a0
	if !ctx.cr[6].gt {
	pc = 0x82C641A0; continue 'dispatch;
	}
	// 82C64174: 7CA92850  subf r5, r9, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	pc = 0x82C64178; continue 'dispatch;
            }
            0x82C64178 => {
    //   block [0x82C64178..0x82C641A0)
	// 82C64178: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6417C: C0270004  lfs f1, 4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C64180: 7C85482E  lwzx r4, r5, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82C64184: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64188: 4BFFFEA1  bl 0x82c64028
	ctx.lr = 0x82C6418C;
	sub_82C64028(ctx, base);
	// 82C6418C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64190: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82C64194: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C64198: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C6419C: 4198FFDC  blt cr6, 0x82c64178
	if ctx.cr[6].lt {
	pc = 0x82C64178; continue 'dispatch;
	}
	pc = 0x82C641A0; continue 'dispatch;
            }
            0x82C641A0 => {
    //   block [0x82C641A0..0x82C641B4)
	// 82C641A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C641A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C641A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C641AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C641B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C641B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C641B8 size=140
    let mut pc: u32 = 0x82C641B8;
    'dispatch: loop {
        match pc {
            0x82C641B8 => {
    //   block [0x82C641B8..0x82C641E4)
	// 82C641B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C641BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C641C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C641C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C641C8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82C641CC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82C641D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C641D4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C641D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C641DC: 4099004C  ble cr6, 0x82c64228
	if !ctx.cr[6].gt {
	pc = 0x82C64228; continue 'dispatch;
	}
	// 82C641E0: 7CA92850  subf r5, r9, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	pc = 0x82C641E4; continue 'dispatch;
            }
            0x82C641E4 => {
    //   block [0x82C641E4..0x82C64228)
	// 82C641E4: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82C641E8: C0480008  lfs f2, 8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C641EC: C0280004  lfs f1, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C641F0: 7C85482E  lwzx r4, r5, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82C641F4: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C641F8: 4BFFFEB9  bl 0x82c640b0
	ctx.lr = 0x82C641FC;
	sub_82C640B0(ctx, base);
	// 82C641FC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64200: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82C64204: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C64208: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C6420C: 4198FFD8  blt cr6, 0x82c641e4
	if ctx.cr[6].lt {
	pc = 0x82C641E4; continue 'dispatch;
	}
	// 82C64210: D0280004  stfs f1, 4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C64214: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C64218: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6421C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C64220: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64224: 4E800020  blr
	return;
            }
            0x82C64228 => {
    //   block [0x82C64228..0x82C64244)
	// 82C64228: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6422C: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C64230: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C64234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C64238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6423C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C64248 size=288
    let mut pc: u32 = 0x82C64248;
    'dispatch: loop {
        match pc {
            0x82C64248 => {
    //   block [0x82C64248..0x82C642A0)
	// 82C64248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6424C: 480451B9  bl 0x82ca9404
	ctx.lr = 0x82C64250;
	sub_82CA93D0(ctx, base);
	// 82C64250: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C64258: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6425C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C64260: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C64264: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C64268: 409900E8  ble cr6, 0x82c64350
	if !ctx.cr[6].gt {
	pc = 0x82C64350; continue 'dispatch;
	}
	// 82C6426C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64270: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C64274: 4099002C  ble cr6, 0x82c642a0
	if !ctx.cr[6].gt {
	pc = 0x82C642A0; continue 'dispatch;
	}
	// 82C64278: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6427C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C64280: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82C64284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C64288: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C6428C: 4804567D  bl 0x82ca9908
	ctx.lr = 0x82C64290;
	sub_82CA9908(ctx, base);
	// 82C64290: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C64294: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C64298: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C6429C: 4804566D  bl 0x82ca9908
	ctx.lr = 0x82C642A0;
	sub_82CA9908(ctx, base);
	pc = 0x82C642A0; continue 'dispatch;
            }
            0x82C642A0 => {
    //   block [0x82C642A0..0x82C642B0)
	// 82C642A0: 7F1CF000  cmpw cr6, r28, r30
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82C642A4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C642A8: 41980008  blt cr6, 0x82c642b0
	if ctx.cr[6].lt {
	pc = 0x82C642B0; continue 'dispatch;
	}
	// 82C642AC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	pc = 0x82C642B0; continue 'dispatch;
            }
            0x82C642B0 => {
    //   block [0x82C642B0..0x82C642E8)
	// 82C642B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C642B4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C642B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C642BC: 4BFFFEFD  bl 0x82c641b8
	ctx.lr = 0x82C642C0;
	sub_82C641B8(ctx, base);
	// 82C642C0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C642C4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C642C8: 7FC6F050  subf r30, r6, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[6].s64;
	// 82C642CC: 7C665850  subf r3, r6, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82C642D0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C642D4: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82C642D8: 40990044  ble cr6, 0x82c6431c
	if !ctx.cr[6].gt {
	pc = 0x82C6431C; continue 'dispatch;
	}
	// 82C642DC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C642E0: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C642E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C642E8; continue 'dispatch;
            }
            0x82C642E8 => {
    //   block [0x82C642E8..0x82C6431C)
	// 82C642E8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82C642EC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82C642F0: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82C642F4: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82C642F8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C642FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C64300: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64304: 80A80000  lwz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64308: 7CC43A14  add r6, r4, r7
	ctx.r[6].u64 = ctx.r[4].u64 + ctx.r[7].u64;
	// 82C6430C: 7CA53A14  add r5, r5, r7
	ctx.r[5].u64 = ctx.r[5].u64 + ctx.r[7].u64;
	// 82C64310: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82C64314: 90A80000  stw r5, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82C64318: 4082FFD0  bne 0x82c642e8
	if !ctx.cr[0].eq {
	pc = 0x82C642E8; continue 'dispatch;
	}
	pc = 0x82C6431C; continue 'dispatch;
            }
            0x82C6431C => {
    //   block [0x82C6431C..0x82C6432C)
	// 82C6431C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C64320: 409A000C  bne cr6, 0x82c6432c
	if !ctx.cr[6].eq {
	pc = 0x82C6432C; continue 'dispatch;
	}
	// 82C64324: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64328: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82C6432C; continue 'dispatch;
            }
            0x82C6432C => {
    //   block [0x82C6432C..0x82C64350)
	// 82C6432C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C64330: 40990030  ble cr6, 0x82c64360
	if !ctx.cr[6].gt {
	pc = 0x82C64360; continue 'dispatch;
	}
	// 82C64334: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C64338: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C6433C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C64340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C64344: 4BFFFE05  bl 0x82c64148
	ctx.lr = 0x82C64348;
	sub_82C64148(ctx, base);
	// 82C64348: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C6434C: 48045108  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C64350 => {
    //   block [0x82C64350..0x82C64360)
	// 82C64350: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C64354: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C64358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6435C: 4BFFFDED  bl 0x82c64148
	ctx.lr = 0x82C64360;
	sub_82C64148(ctx, base);
	pc = 0x82C64360; continue 'dispatch;
            }
            0x82C64360 => {
    //   block [0x82C64360..0x82C64368)
	// 82C64360: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C64364: 480450F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C64368 size=8
    let mut pc: u32 = 0x82C64368;
    'dispatch: loop {
        match pc {
            0x82C64368 => {
    //   block [0x82C64368..0x82C64370)
	// 82C64368: 90830010  stw r4, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 82C6436C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C64370 size=68
    let mut pc: u32 = 0x82C64370;
    'dispatch: loop {
        match pc {
            0x82C64370 => {
    //   block [0x82C64370..0x82C643B4)
	// 82C64370: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C64374: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C64378: 4099003C  ble cr6, 0x82c643b4
	if !ctx.cr[6].gt {
		sub_82C643B4(ctx, base);
		return;
	}
	// 82C6437C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64380: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C64384: 419A0030  beq cr6, 0x82c643b4
	if ctx.cr[6].eq {
		sub_82C643B4(ctx, base);
		return;
	}
	// 82C64388: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 82C6438C: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C64390: D023000C  stfs f1, 0xc(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C64394: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C64398: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82C6439C: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C643A0: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82C643A4: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C643A8: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82C643AC: D1430008  stfs f10, 8(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C643B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C643B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C643B4 size=8
    let mut pc: u32 = 0x82C643B4;
    'dispatch: loop {
        match pc {
            0x82C643B4 => {
    //   block [0x82C643B4..0x82C643BC)
	// 82C643B4: D0230004  stfs f1, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C643B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C643C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C643C0 size=16
    let mut pc: u32 = 0x82C643C0;
    'dispatch: loop {
        match pc {
            0x82C643C0 => {
    //   block [0x82C643C0..0x82C643D0)
	// 82C643C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C643C4: D0230004  stfs f1, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C643C8: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C643CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


