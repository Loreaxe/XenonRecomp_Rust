pub fn sub_82CE9BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9BD0 size=8
    let mut pc: u32 = 0x82CE9BD0;
    'dispatch: loop {
        match pc {
            0x82CE9BD0 => {
    //   block [0x82CE9BD0..0x82CE9BD8)
	// 82CE9BD0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82CE9BD4: 4BFF619C  b 0x82cdfd70
	sub_82CDFD70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9BD8 size=88
    let mut pc: u32 = 0x82CE9BD8;
    'dispatch: loop {
        match pc {
            0x82CE9BD8 => {
    //   block [0x82CE9BD8..0x82CE9C30)
	// 82CE9BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9BE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE9BE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE9BEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CE9BF0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CE9BF4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CE9BF8: 390B5000  addi r8, r11, 0x5000
	ctx.r[8].s64 = ctx.r[11].s64 + 20480;
	// 82CE9BFC: 38EA4FD8  addi r7, r10, 0x4fd8
	ctx.r[7].s64 = ctx.r[10].s64 + 20440;
	// 82CE9C00: 38C94F78  addi r6, r9, 0x4f78
	ctx.r[6].s64 = ctx.r[9].s64 + 20344;
	// 82CE9C04: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82CE9C08: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CE9C0C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82CE9C10: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82CE9C14: 4BFF6595  bl 0x82ce01a8
	ctx.lr = 0x82CE9C18;
	sub_82CE01A8(ctx, base);
	// 82CE9C18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9C1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CE9C20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9C24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9C28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9C2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9C30 size=96
    let mut pc: u32 = 0x82CE9C30;
    'dispatch: loop {
        match pc {
            0x82CE9C30 => {
    //   block [0x82CE9C30..0x82CE9C7C)
	// 82CE9C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9C38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE9C3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9C40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE9C44: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82CE9C48: 4BFFCB11  bl 0x82ce6758
	ctx.lr = 0x82CE9C4C;
	sub_82CE6758(ctx, base);
	// 82CE9C4C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE9C50: 4198002C  blt cr6, 0x82ce9c7c
	if ctx.cr[6].lt {
	pc = 0x82CE9C7C; continue 'dispatch;
	}
	// 82CE9C54: 897F00C4  lbz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82CE9C58: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CE9C5C: 893F00C5  lbz r9, 0xc5(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(197 as u32) ) } as u64;
	// 82CE9C60: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CE9C64: 38EA5078  addi r7, r10, 0x5078
	ctx.r[7].s64 = ctx.r[10].s64 + 20600;
	// 82CE9C68: 5566103E  rotlwi r6, r11, 2
	ctx.r[6].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82CE9C6C: 7CA6382E  lwzx r5, r6, r7
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82CE9C70: B11F006E  sth r8, 0x6e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(110 as u32), ctx.r[8].u16 ) };
	// 82CE9C74: 7C8549D6  mullw r4, r5, r9
	ctx.r[4].s32 = ((ctx.r[5].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CE9C78: B09F006C  sth r4, 0x6c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[4].u16 ) };
	pc = 0x82CE9C7C; continue 'dispatch;
            }
            0x82CE9C7C => {
    //   block [0x82CE9C7C..0x82CE9C90)
	// 82CE9C7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CE9C80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9C84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9C88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE9C90 size=196
    let mut pc: u32 = 0x82CE9C90;
    'dispatch: loop {
        match pc {
            0x82CE9C90 => {
    //   block [0x82CE9C90..0x82CE9CD4)
	// 82CE9C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9C94: 4BFBF775  bl 0x82ca9408
	ctx.lr = 0x82CE9C98;
	sub_82CA93D0(ctx, base);
	// 82CE9C98: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE9C9C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9CA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE9CA4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE9CA8: 485D065D  bl 0x832ba304
	ctx.lr = 0x82CE9CAC;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE9CAC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE9CB0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE9CB4: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE9CB8: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE9CBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9CC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9CC4: 419A0010  beq cr6, 0x82ce9cd4
	if ctx.cr[6].eq {
	pc = 0x82CE9CD4; continue 'dispatch;
	}
	// 82CE9CC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9CCC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9CD0: 419A0018  beq cr6, 0x82ce9ce8
	if ctx.cr[6].eq {
	pc = 0x82CE9CE8; continue 'dispatch;
	}
	pc = 0x82CE9CD4; continue 'dispatch;
            }
            0x82CE9CD4 => {
    //   block [0x82CE9CD4..0x82CE9CE8)
	// 82CE9CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9CD8: 485D061D  bl 0x832ba2f4
	ctx.lr = 0x82CE9CDC;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE9CDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9CE0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE9CE4: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	pc = 0x82CE9CE8; continue 'dispatch;
            }
            0x82CE9CE8 => {
    //   block [0x82CE9CE8..0x82CE9D44)
	// 82CE9CE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE9CEC: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9CF0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9CF4: D3FD0070  stfs f31, 0x70(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82CE9CF8: D3FD00E0  stfs f31, 0xe0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82CE9CFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9D00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9D04: 419A0040  beq cr6, 0x82ce9d44
	if ctx.cr[6].eq {
	pc = 0x82CE9D44; continue 'dispatch;
	}
	// 82CE9D08: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9D0C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9D10: 409A0034  bne cr6, 0x82ce9d44
	if !ctx.cr[6].eq {
	pc = 0x82CE9D44; continue 'dispatch;
	}
	// 82CE9D14: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9D18: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9D1C: 40820028  bne 0x82ce9d44
	if !ctx.cr[0].eq {
	pc = 0x82CE9D44; continue 'dispatch;
	}
	// 82CE9D20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE9D24: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9D28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE9D2C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9D34: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE9D38: 485D05FD  bl 0x832ba334
	ctx.lr = 0x82CE9D3C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE9D40: 485D05D5  bl 0x832ba314
	ctx.lr = 0x82CE9D44;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CE9D44; continue 'dispatch;
            }
            0x82CE9D44 => {
    //   block [0x82CE9D44..0x82CE9D54)
	// 82CE9D44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9D48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CE9D4C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE9D50: 4BFBF708  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE9D58 size=280
    let mut pc: u32 = 0x82CE9D58;
    'dispatch: loop {
        match pc {
            0x82CE9D58 => {
    //   block [0x82CE9D58..0x82CE9D9C)
	// 82CE9D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9D5C: 4BFBF6AD  bl 0x82ca9408
	ctx.lr = 0x82CE9D60;
	sub_82CA93D0(ctx, base);
	// 82CE9D60: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE9D64: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9D68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE9D6C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE9D70: 485D0595  bl 0x832ba304
	ctx.lr = 0x82CE9D74;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE9D74: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE9D78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE9D7C: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE9D80: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE9D84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9D88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9D8C: 419A0010  beq cr6, 0x82ce9d9c
	if ctx.cr[6].eq {
	pc = 0x82CE9D9C; continue 'dispatch;
	}
	// 82CE9D90: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9D94: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9D98: 419A0018  beq cr6, 0x82ce9db0
	if ctx.cr[6].eq {
	pc = 0x82CE9DB0; continue 'dispatch;
	}
	pc = 0x82CE9D9C; continue 'dispatch;
            }
            0x82CE9D9C => {
    //   block [0x82CE9D9C..0x82CE9DB0)
	// 82CE9D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9DA0: 485D0555  bl 0x832ba2f4
	ctx.lr = 0x82CE9DA4;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE9DA4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9DA8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE9DAC: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	pc = 0x82CE9DB0; continue 'dispatch;
            }
            0x82CE9DB0 => {
    //   block [0x82CE9DB0..0x82CE9E60)
	// 82CE9DB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE9DB4: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82CE9DB8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CE9DBC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9DC0: C82A0DE8  lfd f1, 0xde8(r10)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3560 as u32) ) };
	// 82CE9DC4: 4B5146E5  bl 0x821fe4a8
	ctx.lr = 0x82CE9DC8;
	sub_821FE4A8(ctx, base);
	// 82CE9DC8: 80FE003C  lwz r7, 0x3c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CE9DCC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CE9DD0: 891E0038  lbz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9DD4: 88DE0034  lbz r6, 0x34(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CE9DD8: D01E0074  stfs f0, 0x74(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82CE9DDC: 991E00C5  stb r8, 0xc5(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(197 as u32), ctx.r[8].u8 ) };
	// 82CE9DE0: 397E00B8  addi r11, r30, 0xb8
	ctx.r[11].s64 = ctx.r[30].s64 + 184;
	// 82CE9DE4: 98DE00C4  stb r6, 0xc4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[6].u8 ) };
	// 82CE9DE8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82CE9DEC: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82CE9DF0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CE9DF4: 809E0108  lwz r4, 0x108(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CE9DF8: 60830001  ori r3, r4, 1
	ctx.r[3].u64 = ctx.r[4].u64 | 1;
	// 82CE9DFC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CE9E00: 907E0108  stw r3, 0x108(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 82CE9E04: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9E08: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CE9E0C: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CE9E10: FD20565E  fctidz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 82CE9E14: 7D2B2FAE  stfiwx f9, r11, r5
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82CE9E18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9E1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9E20: 419A0040  beq cr6, 0x82ce9e60
	if ctx.cr[6].eq {
	pc = 0x82CE9E60; continue 'dispatch;
	}
	// 82CE9E24: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9E28: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9E2C: 409A0034  bne cr6, 0x82ce9e60
	if !ctx.cr[6].eq {
	pc = 0x82CE9E60; continue 'dispatch;
	}
	// 82CE9E30: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9E34: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9E38: 40820028  bne 0x82ce9e60
	if !ctx.cr[0].eq {
	pc = 0x82CE9E60; continue 'dispatch;
	}
	// 82CE9E3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE9E40: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9E44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE9E48: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9E50: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE9E54: 485D04E1  bl 0x832ba334
	ctx.lr = 0x82CE9E58;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9E58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE9E5C: 485D04B9  bl 0x832ba314
	ctx.lr = 0x82CE9E60;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CE9E60; continue 'dispatch;
            }
            0x82CE9E60 => {
    //   block [0x82CE9E60..0x82CE9E70)
	// 82CE9E60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9E64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CE9E68: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE9E6C: 4BFBF5EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE9E70 size=260
    let mut pc: u32 = 0x82CE9E70;
    'dispatch: loop {
        match pc {
            0x82CE9E70 => {
    //   block [0x82CE9E70..0x82CE9EB4)
	// 82CE9E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9E74: 4BFBF595  bl 0x82ca9408
	ctx.lr = 0x82CE9E78;
	sub_82CA93D0(ctx, base);
	// 82CE9E78: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE9E7C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9E80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE9E84: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE9E88: 485D047D  bl 0x832ba304
	ctx.lr = 0x82CE9E8C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE9E8C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE9E90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE9E94: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE9E98: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE9E9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9EA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9EA4: 419A0010  beq cr6, 0x82ce9eb4
	if ctx.cr[6].eq {
	pc = 0x82CE9EB4; continue 'dispatch;
	}
	// 82CE9EA8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9EAC: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9EB0: 419A0018  beq cr6, 0x82ce9ec8
	if ctx.cr[6].eq {
	pc = 0x82CE9EC8; continue 'dispatch;
	}
	pc = 0x82CE9EB4; continue 'dispatch;
            }
            0x82CE9EB4 => {
    //   block [0x82CE9EB4..0x82CE9EC8)
	// 82CE9EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9EB8: 485D043D  bl 0x832ba2f4
	ctx.lr = 0x82CE9EBC;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE9EBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9EC0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE9EC4: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	pc = 0x82CE9EC8; continue 'dispatch;
            }
            0x82CE9EC8 => {
    //   block [0x82CE9EC8..0x82CE9F64)
	// 82CE9EC8: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82CE9ECC: 397E00B8  addi r11, r30, 0xb8
	ctx.r[11].s64 = ctx.r[30].s64 + 184;
	// 82CE9ED0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CE9ED4: D3FE0074  stfs f31, 0x74(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82CE9ED8: 813E003C  lwz r9, 0x3c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CE9EDC: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82CE9EE0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CE9EE4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CE9EE8: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82CE9EEC: 891E0038  lbz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9EF0: 88FE0034  lbz r7, 0x34(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CE9EF4: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9EF8: 98FE00C4  stb r7, 0xc4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[7].u8 ) };
	// 82CE9EFC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82CE9F00: 991E00C5  stb r8, 0xc5(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(197 as u32), ctx.r[8].u8 ) };
	// 82CE9F04: 80BE0108  lwz r5, 0x108(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CE9F08: 60A40001  ori r4, r5, 1
	ctx.r[4].u64 = ctx.r[5].u64 | 1;
	// 82CE9F0C: ED6C07F2  fmuls f11, f12, f31
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82CE9F10: 909E0108  stw r4, 0x108(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), ctx.r[4].u32 ) };
	// 82CE9F14: FD405E5E  fctidz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82CE9F18: 7D4B37AE  stfiwx f10, r11, r6
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82CE9F1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9F20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9F24: 419A0040  beq cr6, 0x82ce9f64
	if ctx.cr[6].eq {
	pc = 0x82CE9F64; continue 'dispatch;
	}
	// 82CE9F28: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9F2C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9F30: 409A0034  bne cr6, 0x82ce9f64
	if !ctx.cr[6].eq {
	pc = 0x82CE9F64; continue 'dispatch;
	}
	// 82CE9F34: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9F38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9F3C: 40820028  bne 0x82ce9f64
	if !ctx.cr[0].eq {
	pc = 0x82CE9F64; continue 'dispatch;
	}
	// 82CE9F40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE9F44: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE9F4C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9F54: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE9F58: 485D03DD  bl 0x832ba334
	ctx.lr = 0x82CE9F5C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9F5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE9F60: 485D03B5  bl 0x832ba314
	ctx.lr = 0x82CE9F64;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CE9F64; continue 'dispatch;
            }
            0x82CE9F64 => {
    //   block [0x82CE9F64..0x82CE9F74)
	// 82CE9F64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9F68: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CE9F6C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE9F70: 4BFBF4E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F78 size=8
    let mut pc: u32 = 0x82CE9F78;
    'dispatch: loop {
        match pc {
            0x82CE9F78 => {
    //   block [0x82CE9F78..0x82CE9F80)
	// 82CE9F78: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9F7C: 4BFFFA34  b 0x82ce99b0
	sub_82CE99B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F80 size=8
    let mut pc: u32 = 0x82CE9F80;
    'dispatch: loop {
        match pc {
            0x82CE9F80 => {
    //   block [0x82CE9F80..0x82CE9F88)
	// 82CE9F80: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9F84: 4BFFFCAC  b 0x82ce9c30
	sub_82CE9C30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F88 size=8
    let mut pc: u32 = 0x82CE9F88;
    'dispatch: loop {
        match pc {
            0x82CE9F88 => {
    //   block [0x82CE9F88..0x82CE9F90)
	// 82CE9F88: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CE9F8C: 4BFFF9F4  b 0x82ce9980
	sub_82CE9980(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F90 size=8
    let mut pc: u32 = 0x82CE9F90;
    'dispatch: loop {
        match pc {
            0x82CE9F90 => {
    //   block [0x82CE9F90..0x82CE9F98)
	// 82CE9F90: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9F94: 4BFFFA0C  b 0x82ce99a0
	sub_82CE99A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F98 size=8
    let mut pc: u32 = 0x82CE9F98;
    'dispatch: loop {
        match pc {
            0x82CE9F98 => {
    //   block [0x82CE9F98..0x82CE9FA0)
	// 82CE9F98: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9F9C: 4BFFFA84  b 0x82ce9a20
	sub_82CE9A20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FA0 size=8
    let mut pc: u32 = 0x82CE9FA0;
    'dispatch: loop {
        match pc {
            0x82CE9FA0 => {
    //   block [0x82CE9FA0..0x82CE9FA8)
	// 82CE9FA0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FA4: 4BFFFA14  b 0x82ce99b8
	sub_82CE99B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FA8 size=8
    let mut pc: u32 = 0x82CE9FA8;
    'dispatch: loop {
        match pc {
            0x82CE9FA8 => {
    //   block [0x82CE9FA8..0x82CE9FB0)
	// 82CE9FA8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FAC: 4BFFFCE4  b 0x82ce9c90
	sub_82CE9C90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FB0 size=8
    let mut pc: u32 = 0x82CE9FB0;
    'dispatch: loop {
        match pc {
            0x82CE9FB0 => {
    //   block [0x82CE9FB0..0x82CE9FB8)
	// 82CE9FB0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FB4: 4BFFFBAC  b 0x82ce9b60
	sub_82CE9B60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FB8 size=8
    let mut pc: u32 = 0x82CE9FB8;
    'dispatch: loop {
        match pc {
            0x82CE9FB8 => {
    //   block [0x82CE9FB8..0x82CE9FC0)
	// 82CE9FB8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FBC: 4BFFFAFC  b 0x82ce9ab8
	sub_82CE9AB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FC0 size=8
    let mut pc: u32 = 0x82CE9FC0;
    'dispatch: loop {
        match pc {
            0x82CE9FC0 => {
    //   block [0x82CE9FC0..0x82CE9FC8)
	// 82CE9FC0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FC4: 4BFFFD94  b 0x82ce9d58
	sub_82CE9D58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FC8 size=8
    let mut pc: u32 = 0x82CE9FC8;
    'dispatch: loop {
        match pc {
            0x82CE9FC8 => {
    //   block [0x82CE9FC8..0x82CE9FD0)
	// 82CE9FC8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FCC: 4BFFF9FC  b 0x82ce99c8
	sub_82CE99C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FD0 size=8
    let mut pc: u32 = 0x82CE9FD0;
    'dispatch: loop {
        match pc {
            0x82CE9FD0 => {
    //   block [0x82CE9FD0..0x82CE9FD8)
	// 82CE9FD0: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CE9FD4: 4BFFFBF4  b 0x82ce9bc8
	sub_82CE9BC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FD8 size=8
    let mut pc: u32 = 0x82CE9FD8;
    'dispatch: loop {
        match pc {
            0x82CE9FD8 => {
    //   block [0x82CE9FD8..0x82CE9FE0)
	// 82CE9FD8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FDC: 4BFFF9CC  b 0x82ce99a8
	sub_82CE99A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FE0 size=8
    let mut pc: u32 = 0x82CE9FE0;
    'dispatch: loop {
        match pc {
            0x82CE9FE0 => {
    //   block [0x82CE9FE0..0x82CE9FE8)
	// 82CE9FE0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FE4: 4BFFFE8C  b 0x82ce9e70
	sub_82CE9E70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FE8 size=8
    let mut pc: u32 = 0x82CE9FE8;
    'dispatch: loop {
        match pc {
            0x82CE9FE8 => {
    //   block [0x82CE9FE8..0x82CE9FF0)
	// 82CE9FE8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FEC: 4BFFF9EC  b 0x82ce99d8
	sub_82CE99D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9FF0 size=208
    let mut pc: u32 = 0x82CE9FF0;
    'dispatch: loop {
        match pc {
            0x82CE9FF0 => {
    //   block [0x82CE9FF0..0x82CEA030)
	// 82CE9FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9FF4: 4BFBF411  bl 0x82ca9404
	ctx.lr = 0x82CE9FF8;
	sub_82CA93D0(ctx, base);
	// 82CE9FF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9FFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEA000: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CEA004: 485D0301  bl 0x832ba304
	ctx.lr = 0x82CEA008;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA008: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA00C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA010: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA014: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CEA018: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA01C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA020: 419A0010  beq cr6, 0x82cea030
	if ctx.cr[6].eq {
	pc = 0x82CEA030; continue 'dispatch;
	}
	// 82CEA024: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA028: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA02C: 419A0018  beq cr6, 0x82cea044
	if ctx.cr[6].eq {
	pc = 0x82CEA044; continue 'dispatch;
	}
	pc = 0x82CEA030; continue 'dispatch;
            }
            0x82CEA030 => {
    //   block [0x82CEA030..0x82CEA044)
	// 82CEA030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA034: 485D02C1  bl 0x832ba2f4
	ctx.lr = 0x82CEA038;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA038: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA03C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CEA040: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	pc = 0x82CEA044; continue 'dispatch;
            }
            0x82CEA044 => {
    //   block [0x82CEA044..0x82CEA0B4)
	// 82CEA044: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA048: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CEA04C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA050: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA054: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA058: A0FE006C  lhz r7, 0x6c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82CEA05C: 7CC83B96  divwu r6, r8, r7
	ctx.r[6].u32 = ctx.r[8].u32 / ctx.r[7].u32;
	// 82CEA060: 913E0110  stw r9, 0x110(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(272 as u32), ctx.r[9].u32 ) };
	// 82CEA064: 0CC70000  twi 6, r7, 0
	// 82CEA068: 90DE0078  stw r6, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 82CEA06C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA070: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA074: 419A0040  beq cr6, 0x82cea0b4
	if ctx.cr[6].eq {
	pc = 0x82CEA0B4; continue 'dispatch;
	}
	// 82CEA078: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA07C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEA080: 409A0034  bne cr6, 0x82cea0b4
	if !ctx.cr[6].eq {
	pc = 0x82CEA0B4; continue 'dispatch;
	}
	// 82CEA084: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA088: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA08C: 40820028  bne 0x82cea0b4
	if !ctx.cr[0].eq {
	pc = 0x82CEA0B4; continue 'dispatch;
	}
	// 82CEA090: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEA094: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA09C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA0A4: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA0A8: 485D028D  bl 0x832ba334
	ctx.lr = 0x82CEA0AC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA0AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA0B0: 485D0265  bl 0x832ba314
	ctx.lr = 0x82CEA0B4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEA0B4; continue 'dispatch;
            }
            0x82CEA0B4 => {
    //   block [0x82CEA0B4..0x82CEA0C0)
	// 82CEA0B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA0B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEA0BC: 4BFBF398  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEA0C0 size=244
    let mut pc: u32 = 0x82CEA0C0;
    'dispatch: loop {
        match pc {
            0x82CEA0C0 => {
    //   block [0x82CEA0C0..0x82CEA0FC)
	// 82CEA0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA0C4: 4BFBF345  bl 0x82ca9408
	ctx.lr = 0x82CEA0C8;
	sub_82CA93D0(ctx, base);
	// 82CEA0C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA0CC: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82CEA0D0: 485D0235  bl 0x832ba304
	ctx.lr = 0x82CEA0D4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA0D4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA0D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA0DC: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA0E0: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CEA0E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA0E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA0EC: 419A0010  beq cr6, 0x82cea0fc
	if ctx.cr[6].eq {
	pc = 0x82CEA0FC; continue 'dispatch;
	}
	// 82CEA0F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA0F4: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA0F8: 419A0018  beq cr6, 0x82cea110
	if ctx.cr[6].eq {
	pc = 0x82CEA110; continue 'dispatch;
	}
	pc = 0x82CEA0FC; continue 'dispatch;
            }
            0x82CEA0FC => {
    //   block [0x82CEA0FC..0x82CEA110)
	// 82CEA0FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA100: 485D01F5  bl 0x832ba2f4
	ctx.lr = 0x82CEA104;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA104: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA108: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CEA10C: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	pc = 0x82CEA110; continue 'dispatch;
            }
            0x82CEA110 => {
    //   block [0x82CEA110..0x82CEA134)
	// 82CEA110: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA114: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA118: 895E009C  lbz r10, 0x9c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 82CEA11C: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82CEA120: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA124: 409A0010  bne cr6, 0x82cea134
	if !ctx.cr[6].eq {
	pc = 0x82CEA134; continue 'dispatch;
	}
	// 82CEA128: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82CEA12C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82CEA130: 48000018  b 0x82cea148
	pc = 0x82CEA148; continue 'dispatch;
            }
            0x82CEA134 => {
    //   block [0x82CEA134..0x82CEA148)
	// 82CEA134: 554A077A  rlwinm r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA138: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA13C: 419A0024  beq cr6, 0x82cea160
	if ctx.cr[6].eq {
	pc = 0x82CEA160; continue 'dispatch;
	}
	// 82CEA140: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82CEA144: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	pc = 0x82CEA148; continue 'dispatch;
            }
            0x82CEA148 => {
    //   block [0x82CEA148..0x82CEA160)
	// 82CEA148: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA14C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA150: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA154: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA158: 4E800421  bctrl
	ctx.lr = 0x82CEA15C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA15C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
            }
            0x82CEA160 => {
    //   block [0x82CEA160..0x82CEA1A8)
	// 82CEA160: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA164: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA168: 419A0040  beq cr6, 0x82cea1a8
	if ctx.cr[6].eq {
	pc = 0x82CEA1A8; continue 'dispatch;
	}
	// 82CEA16C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA170: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEA174: 409A0034  bne cr6, 0x82cea1a8
	if !ctx.cr[6].eq {
	pc = 0x82CEA1A8; continue 'dispatch;
	}
	// 82CEA178: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA17C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA180: 40820028  bne 0x82cea1a8
	if !ctx.cr[0].eq {
	pc = 0x82CEA1A8; continue 'dispatch;
	}
	// 82CEA184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA188: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA18C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEA190: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA198: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA19C: 485D0199  bl 0x832ba334
	ctx.lr = 0x82CEA1A0;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA1A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA1A4: 485D0171  bl 0x832ba314
	ctx.lr = 0x82CEA1A8;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEA1A8; continue 'dispatch;
            }
            0x82CEA1A8 => {
    //   block [0x82CEA1A8..0x82CEA1B4)
	// 82CEA1A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA1AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEA1B0: 4BFBF2A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEA1B8 size=308
    let mut pc: u32 = 0x82CEA1B8;
    'dispatch: loop {
        match pc {
            0x82CEA1B8 => {
    //   block [0x82CEA1B8..0x82CEA1F8)
	// 82CEA1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA1BC: 4BFBF249  bl 0x82ca9404
	ctx.lr = 0x82CEA1C0;
	sub_82CA93D0(ctx, base);
	// 82CEA1C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA1C4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CEA1C8: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82CEA1CC: 485D0139  bl 0x832ba304
	ctx.lr = 0x82CEA1D0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA1D0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA1D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA1D8: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA1DC: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CEA1E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA1E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA1E8: 419A0010  beq cr6, 0x82cea1f8
	if ctx.cr[6].eq {
	pc = 0x82CEA1F8; continue 'dispatch;
	}
	// 82CEA1EC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA1F0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA1F4: 419A0018  beq cr6, 0x82cea20c
	if ctx.cr[6].eq {
	pc = 0x82CEA20C; continue 'dispatch;
	}
	pc = 0x82CEA1F8; continue 'dispatch;
            }
            0x82CEA1F8 => {
    //   block [0x82CEA1F8..0x82CEA20C)
	// 82CEA1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA1FC: 485D00F9  bl 0x832ba2f4
	ctx.lr = 0x82CEA200;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA200: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA204: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CEA208: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	pc = 0x82CEA20C; continue 'dispatch;
            }
            0x82CEA20C => {
    //   block [0x82CEA20C..0x82CEA278)
	// 82CEA20C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA210: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA214: 895E009C  lbz r10, 0x9c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 82CEA218: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82CEA21C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA220: 419A0078  beq cr6, 0x82cea298
	if ctx.cr[6].eq {
	pc = 0x82CEA298; continue 'dispatch;
	}
	// 82CEA224: 576907FE  clrlwi r9, r27, 0x1f
	ctx.r[9].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 82CEA228: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA22C: 409A004C  bne cr6, 0x82cea278
	if !ctx.cr[6].eq {
	pc = 0x82CEA278; continue 'dispatch;
	}
	// 82CEA230: 554906FC  rlwinm r9, r10, 0, 0x1b, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA234: 552907B6  rlwinm r9, r9, 0, 0x1e, 0x1b
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA238: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA23C: 409A003C  bne cr6, 0x82cea278
	if !ctx.cr[6].eq {
	pc = 0x82CEA278; continue 'dispatch;
	}
	// 82CEA240: 554A077A  rlwinm r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA248: 409A0050  bne cr6, 0x82cea298
	if !ctx.cr[6].eq {
	pc = 0x82CEA298; continue 'dispatch;
	}
	// 82CEA24C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA250: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82CEA254: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82CEA258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA25C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA260: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA264: 4E800421  bctrl
	ctx.lr = 0x82CEA268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA268: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEA26C: A1694E08  lhz r11, 0x4e08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(19976 as u32) ) } as u64;
	// 82CEA270: B17E009E  sth r11, 0x9e(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(158 as u32), ctx.r[11].u16 ) };
	// 82CEA274: 48000020  b 0x82cea294
	pc = 0x82CEA294; continue 'dispatch;
            }
            0x82CEA278 => {
    //   block [0x82CEA278..0x82CEA294)
	// 82CEA278: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA27C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CEA280: 38800057  li r4, 0x57
	ctx.r[4].s64 = 87;
	// 82CEA284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA288: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA28C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA290: 4E800421  bctrl
	ctx.lr = 0x82CEA294;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEA294 => {
    //   block [0x82CEA294..0x82CEA298)
	// 82CEA294: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82CEA298; continue 'dispatch;
            }
            0x82CEA298 => {
    //   block [0x82CEA298..0x82CEA2E0)
	// 82CEA298: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA29C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA2A0: 419A0040  beq cr6, 0x82cea2e0
	if ctx.cr[6].eq {
	pc = 0x82CEA2E0; continue 'dispatch;
	}
	// 82CEA2A4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA2A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEA2AC: 409A0034  bne cr6, 0x82cea2e0
	if !ctx.cr[6].eq {
	pc = 0x82CEA2E0; continue 'dispatch;
	}
	// 82CEA2B0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA2B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA2B8: 40820028  bne 0x82cea2e0
	if !ctx.cr[0].eq {
	pc = 0x82CEA2E0; continue 'dispatch;
	}
	// 82CEA2BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA2C0: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA2C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEA2C8: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA2D0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA2D4: 485D0061  bl 0x832ba334
	ctx.lr = 0x82CEA2D8;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA2D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA2DC: 485D0039  bl 0x832ba314
	ctx.lr = 0x82CEA2E0;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEA2E0; continue 'dispatch;
            }
            0x82CEA2E0 => {
    //   block [0x82CEA2E0..0x82CEA2EC)
	// 82CEA2E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA2E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEA2E8: 4BFBF16C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEA2F0 size=240
    let mut pc: u32 = 0x82CEA2F0;
    'dispatch: loop {
        match pc {
            0x82CEA2F0 => {
    //   block [0x82CEA2F0..0x82CEA32C)
	// 82CEA2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA2F4: 4BFBF115  bl 0x82ca9408
	ctx.lr = 0x82CEA2F8;
	sub_82CA93D0(ctx, base);
	// 82CEA2F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA2FC: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 82CEA300: 485D0005  bl 0x832ba304
	ctx.lr = 0x82CEA304;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA304: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA308: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA30C: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA310: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEA314: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA318: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA31C: 419A0010  beq cr6, 0x82cea32c
	if ctx.cr[6].eq {
	pc = 0x82CEA32C; continue 'dispatch;
	}
	// 82CEA320: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA324: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEA328: 419A001C  beq cr6, 0x82cea344
	if ctx.cr[6].eq {
	pc = 0x82CEA344; continue 'dispatch;
	}
	pc = 0x82CEA32C; continue 'dispatch;
            }
            0x82CEA32C => {
    //   block [0x82CEA32C..0x82CEA344)
	// 82CEA32C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA330: 485CFFC5  bl 0x832ba2f4
	ctx.lr = 0x82CEA334;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA334: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CEA338: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA33C: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CEA340: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82CEA344; continue 'dispatch;
            }
            0x82CEA344 => {
    //   block [0x82CEA344..0x82CEA390)
	// 82CEA344: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA348: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 82CEA34C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA350: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA354: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEA358: 419A0038  beq cr6, 0x82cea390
	if ctx.cr[6].eq {
	pc = 0x82CEA390; continue 'dispatch;
	}
	// 82CEA35C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA360: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82CEA364: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA368: 419A0028  beq cr6, 0x82cea390
	if ctx.cr[6].eq {
	pc = 0x82CEA390; continue 'dispatch;
	}
	// 82CEA36C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA370: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82CEA374: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82CEA378: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA37C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA380: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA384: 4E800421  bctrl
	ctx.lr = 0x82CEA388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA388: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA38C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
            }
            0x82CEA390 => {
    //   block [0x82CEA390..0x82CEA3D4)
	// 82CEA390: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA394: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA398: 419A003C  beq cr6, 0x82cea3d4
	if ctx.cr[6].eq {
	pc = 0x82CEA3D4; continue 'dispatch;
	}
	// 82CEA39C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEA3A0: 409A0034  bne cr6, 0x82cea3d4
	if !ctx.cr[6].eq {
	pc = 0x82CEA3D4; continue 'dispatch;
	}
	// 82CEA3A4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA3A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA3AC: 40820028  bne 0x82cea3d4
	if !ctx.cr[0].eq {
	pc = 0x82CEA3D4; continue 'dispatch;
	}
	// 82CEA3B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA3B4: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA3B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEA3BC: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA3C4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA3C8: 485CFF6D  bl 0x832ba334
	ctx.lr = 0x82CEA3CC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA3CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA3D0: 485CFF45  bl 0x832ba314
	ctx.lr = 0x82CEA3D4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEA3D4; continue 'dispatch;
            }
            0x82CEA3D4 => {
    //   block [0x82CEA3D4..0x82CEA3E0)
	// 82CEA3D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA3D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEA3DC: 4BFBF07C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEA3F8 size=8
    let mut pc: u32 = 0x82CEA3F8;
    'dispatch: loop {
        match pc {
            0x82CEA3F8 => {
    //   block [0x82CEA3F8..0x82CEA400)
	// 82CEA3F8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CEA3FC: 4BFFFEF4  b 0x82cea2f0
	sub_82CEA2F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEA400 size=8
    let mut pc: u32 = 0x82CEA400;
    'dispatch: loop {
        match pc {
            0x82CEA400 => {
    //   block [0x82CEA400..0x82CEA408)
	// 82CEA400: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CEA404: 4BFFFDB4  b 0x82cea1b8
	sub_82CEA1B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEA408 size=8
    let mut pc: u32 = 0x82CEA408;
    'dispatch: loop {
        match pc {
            0x82CEA408 => {
    //   block [0x82CEA408..0x82CEA410)
	// 82CEA408: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CEA40C: 4BFFFCB4  b 0x82cea0c0
	sub_82CEA0C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEA410 size=272
    let mut pc: u32 = 0x82CEA410;
    'dispatch: loop {
        match pc {
            0x82CEA410 => {
    //   block [0x82CEA410..0x82CEA520)
	// 82CEA410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA414: 4BFBEFF1  bl 0x82ca9404
	ctx.lr = 0x82CEA418;
	sub_82CA93D0(ctx, base);
	// 82CEA418: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEA420: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CEA424: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82CEA428: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82CEA42C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA430: 4BFF5A89  bl 0x82cdfeb8
	ctx.lr = 0x82CEA434;
	sub_82CDFEB8(ctx, base);
	// 82CEA434: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEA438: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEA43C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEA440: 3BDF00B8  addi r30, r31, 0xb8
	ctx.r[30].s64 = ctx.r[31].s64 + 184;
	// 82CEA444: 390B5000  addi r8, r11, 0x5000
	ctx.r[8].s64 = ctx.r[11].s64 + 20480;
	// 82CEA448: 38EA4FD8  addi r7, r10, 0x4fd8
	ctx.r[7].s64 = ctx.r[10].s64 + 20440;
	// 82CEA44C: 38C94F78  addi r6, r9, 0x4f78
	ctx.r[6].s64 = ctx.r[9].s64 + 20344;
	// 82CEA450: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82CEA454: 38A0004C  li r5, 0x4c
	ctx.r[5].s64 = 76;
	// 82CEA458: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CEA45C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEA460: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82CEA464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA468: 4BFBF549  bl 0x82ca99b0
	ctx.lr = 0x82CEA46C;
	sub_82CA99B0(ctx, base);
	// 82CEA46C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA470: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CEA474: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82CEA478: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CEA47C: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82CEA480: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA484: 4BFF57C5  bl 0x82cdfc48
	ctx.lr = 0x82CEA488;
	sub_82CDFC48(ctx, base);
	// 82CEA488: 3C800000  lis r4, 0
	ctx.r[4].s64 = 0;
	// 82CEA48C: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEA490: 891C0045  lbz r8, 0x45(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEA494: 608BBB80  ori r11, r4, 0xbb80
	ctx.r[11].u64 = ctx.r[4].u64 | 48000;
	// 82CEA498: 88DF0038  lbz r6, 0x38(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEA49C: 3C608201  lis r3, -0x7dff
	ctx.r[3].s64 = -2113863680;
	// 82CEA4A0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82CEA4A4: 39435078  addi r10, r3, 0x5078
	ctx.r[10].s64 = ctx.r[3].s64 + 20600;
	// 82CEA4A8: 911F010C  stw r8, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[8].u32 ) };
	// 82CEA4AC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CEA4B0: 809F003C  lwz r4, 0x3c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEA4B4: 811F0108  lwz r8, 0x108(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CEA4B8: 61070001  ori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 | 1;
	// 82CEA4BC: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82CEA4C0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CEA4C4: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CEA4C8: 887F0034  lbz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEA4CC: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CEA4D0: 98DF00C5  stb r6, 0xc5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(197 as u32), ctx.r[6].u8 ) };
	// 82CEA4D4: 54E6003E  slwi r6, r7, 0
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CEA4D8: 987F00C4  stb r3, 0xc4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[3].u8 ) };
	// 82CEA4DC: 90FF0108  stw r7, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[7].u32 ) };
	// 82CEA4E0: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CEA4E4: FD20565E  fctidz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 82CEA4E8: 7D3E2FAE  stfiwx f9, r30, r5
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82CEA4EC: 60C50002  ori r5, r6, 2
	ctx.r[5].u64 = ctx.r[6].u64 | 2;
	// 82CEA4F0: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82CEA4F4: 90BF0108  stw r5, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[5].u32 ) };
	// 82CEA4F8: 889F00C5  lbz r4, 0xc5(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(197 as u32) ) } as u64;
	// 82CEA4FC: 887F00C4  lbz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82CEA500: 546B103E  rotlwi r11, r3, 2
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(2)) as u64;
	// 82CEA504: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEA508: 7D0A21D6  mullw r8, r10, r4
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CEA50C: B13F006E  sth r9, 0x6e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(110 as u32), ctx.r[9].u16 ) };
	// 82CEA510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA514: B11F006C  sth r8, 0x6c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u16 ) };
	// 82CEA518: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEA51C: 4BFBEF38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEA520 size=1808
    let mut pc: u32 = 0x82CEA520;
    'dispatch: loop {
        match pc {
            0x82CEA520 => {
    //   block [0x82CEA520..0x82CEA54C)
	// 82CEA520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA524: 4BFBEED1  bl 0x82ca93f4
	ctx.lr = 0x82CEA528;
	sub_82CA93D0(ctx, base);
	// 82CEA528: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82CEA52C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA530: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82CEA534: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82CEA538: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82CEA53C: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82CEA540: 3B85FFF8  addi r28, r5, -8
	ctx.r[28].s64 = ctx.r[5].s64 + -8;
	// 82CEA544: 409A0008  bne cr6, 0x82cea54c
	if !ctx.cr[6].eq {
	pc = 0x82CEA54C; continue 'dispatch;
	}
	// 82CEA548: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	pc = 0x82CEA54C; continue 'dispatch;
            }
            0x82CEA54C => {
    //   block [0x82CEA54C..0x82CEA578)
	// 82CEA54C: 485CFDB9  bl 0x832ba304
	ctx.lr = 0x82CEA550;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA550: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA554: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEA558: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA55C: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEA560: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA564: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA568: 419A0010  beq cr6, 0x82cea578
	if ctx.cr[6].eq {
	pc = 0x82CEA578; continue 'dispatch;
	}
	// 82CEA56C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA570: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA574: 419A0018  beq cr6, 0x82cea58c
	if ctx.cr[6].eq {
	pc = 0x82CEA58C; continue 'dispatch;
	}
	pc = 0x82CEA578; continue 'dispatch;
            }
            0x82CEA578 => {
    //   block [0x82CEA578..0x82CEA58C)
	// 82CEA578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA57C: 485CFD79  bl 0x832ba2f4
	ctx.lr = 0x82CEA580;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA580: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA584: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEA588: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CEA58C; continue 'dispatch;
            }
            0x82CEA58C => {
    //   block [0x82CEA58C..0x82CEA5D0)
	// 82CEA58C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA590: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEA594: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA598: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEA59C: 4BFF3FED  bl 0x82cde588
	ctx.lr = 0x82CEA5A0;
	sub_82CDE588(ctx, base);
	// 82CEA5A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEA5A4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEA5A8: 41980028  blt cr6, 0x82cea5d0
	if ctx.cr[6].lt {
	pc = 0x82CEA5D0; continue 'dispatch;
	}
	// 82CEA5AC: 897A0038  lbz r11, 0x38(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEA5B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CEA5B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEA5B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEA5BC: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82CEA5C0: 4BFF4129  bl 0x82cde6e8
	ctx.lr = 0x82CEA5C4;
	sub_82CDE6E8(ctx, base);
	// 82CEA5C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEA5C8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEA5CC: 409800DC  bge cr6, 0x82cea6a8
	if !ctx.cr[6].lt {
	pc = 0x82CEA6A8; continue 'dispatch;
	}
	pc = 0x82CEA5D0; continue 'dispatch;
            }
            0x82CEA5D0 => {
    //   block [0x82CEA5D0..0x82CEA61C)
	// 82CEA5D0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA5D4: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA5D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA5DC: 419A0040  beq cr6, 0x82cea61c
	if ctx.cr[6].eq {
	pc = 0x82CEA61C; continue 'dispatch;
	}
	// 82CEA5E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA5E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEA5E8: 409A0034  bne cr6, 0x82cea61c
	if !ctx.cr[6].eq {
	pc = 0x82CEA61C; continue 'dispatch;
	}
	// 82CEA5EC: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA5F0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA5F4: 40820028  bne 0x82cea61c
	if !ctx.cr[0].eq {
	pc = 0x82CEA61C; continue 'dispatch;
	}
	// 82CEA5F8: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEA5FC: 8BBF000C  lbz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA600: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA604: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA60C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA610: 485CFD25  bl 0x832ba334
	ctx.lr = 0x82CEA614;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA618: 485CFCFD  bl 0x832ba314
	ctx.lr = 0x82CEA61C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEA61C; continue 'dispatch;
            }
            0x82CEA61C => {
    //   block [0x82CEA61C..0x82CEA628)
	// 82CEA61C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA620: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEA624: 409A0600  bne cr6, 0x82ceac24
	if !ctx.cr[6].eq {
	pc = 0x82CEAC24; continue 'dispatch;
	}
	pc = 0x82CEA628; continue 'dispatch;
            }
            0x82CEA628 => {
    //   block [0x82CEA628..0x82CEA638)
	// 82CEA628: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEA62C: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 82CEA630: 4BFF97F9  bl 0x82ce3e28
	ctx.lr = 0x82CEA634;
	sub_82CE3E28(ctx, base);
	// 82CEA634: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x82CEA638; continue 'dispatch;
            }
            0x82CEA638 => {
    //   block [0x82CEA638..0x82CEA670)
	// 82CEA638: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82CEA63C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82CEA640: 419A0258  beq cr6, 0x82cea898
	if ctx.cr[6].eq {
	pc = 0x82CEA898; continue 'dispatch;
	}
	// 82CEA644: 817A00BC  lwz r11, 0xbc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(188 as u32) ) } as u64;
	// 82CEA648: 815A00C0  lwz r10, 0xc0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(192 as u32) ) } as u64;
	// 82CEA64C: 7D2A5851  subf. r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA650: 40820248  bne 0x82cea898
	if !ctx.cr[0].eq {
	pc = 0x82CEA898; continue 'dispatch;
	}
	// 82CEA654: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEA658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEA65C: 419A021C  beq cr6, 0x82cea878
	if ctx.cr[6].eq {
	pc = 0x82CEA878; continue 'dispatch;
	}
	// 82CEA660: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82CEA664: 419A000C  beq cr6, 0x82cea670
	if ctx.cr[6].eq {
	pc = 0x82CEA670; continue 'dispatch;
	}
	// 82CEA668: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82CEA66C: 91790010  stw r11, 0x10(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82CEA670; continue 'dispatch;
            }
            0x82CEA670 => {
    //   block [0x82CEA670..0x82CEA6A8)
	// 82CEA670: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEA674: 917A0078  stw r11, 0x78(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82CEA678: 817A00B4  lwz r11, 0xb4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(180 as u32) ) } as u64;
	// 82CEA67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEA680: 419A0218  beq cr6, 0x82cea898
	if ctx.cr[6].eq {
	pc = 0x82CEA898; continue 'dispatch;
	}
	// 82CEA684: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CEA68C: 81390024  lwz r9, 0x24(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEA690: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82CEA694: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CEA698: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CEA69C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CEA6A0: 4E800421  bctrl
	ctx.lr = 0x82CEA6A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA6A4: 480001F4  b 0x82cea898
	pc = 0x82CEA898; continue 'dispatch;
            }
            0x82CEA6A8 => {
    //   block [0x82CEA6A8..0x82CEA710)
	// 82CEA6A8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82CEA6AC: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 82CEA6B0: 92FA00D4  stw r23, 0xd4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(212 as u32), ctx.r[23].u32 ) };
	// 82CEA6B4: 3BDA00B8  addi r30, r26, 0xb8
	ctx.r[30].s64 = ctx.r[26].s64 + 184;
	// 82CEA6B8: 915A00D0  stw r10, 0xd0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82CEA6BC: 917A00CC  stw r11, 0xcc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82CEA6C0: 897A00AC  lbz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CEA6C4: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEA6C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA6CC: 419A010C  beq cr6, 0x82cea7d8
	if ctx.cr[6].eq {
	pc = 0x82CEA7D8; continue 'dispatch;
	}
	// 82CEA6D0: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA6D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA6D8: 409A0100  bne cr6, 0x82cea7d8
	if !ctx.cr[6].eq {
	pc = 0x82CEA7D8; continue 'dispatch;
	}
	// 82CEA6DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CEA6E0: 556907BC  rlwinm r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA6E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA6E8: C3EA0C18  lfs f31, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82CEA6EC: 419A0050  beq cr6, 0x82cea73c
	if ctx.cr[6].eq {
	pc = 0x82CEA73C; continue 'dispatch;
	}
	// 82CEA6F0: C01A0070  lfs f0, 0x70(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEA6F4: 397E0034  addi r11, r30, 0x34
	ctx.r[11].s64 = ctx.r[30].s64 + 52;
	// 82CEA6F8: D01A00E0  stfs f0, 0xe0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82CEA6FC: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82CEA700: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEA704: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82CEA708: D1BE0024  stfs f13, 0x24(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEA70C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82CEA710; continue 'dispatch;
            }
            0x82CEA710 => {
    //   block [0x82CEA710..0x82CEA73C)
	// 82CEA710: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEA714: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CEA718: 4200FFF8  bdnz 0x82cea710
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82CEA710; continue 'dispatch;
	}
	// 82CEA71C: D3FE0030  stfs f31, 0x30(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82CEA720: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEA724: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 82CEA728: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CEA72C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82CEA730: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA734: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA738: 4E800421  bctrl
	ctx.lr = 0x82CEA73C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEA73C => {
    //   block [0x82CEA73C..0x82CEA780)
	// 82CEA73C: 897A00AC  lbz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CEA740: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA744: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA748: 419A0040  beq cr6, 0x82cea788
	if ctx.cr[6].eq {
	pc = 0x82CEA788; continue 'dispatch;
	}
	// 82CEA74C: A15A00AE  lhz r10, 0xae(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(174 as u32) ) } as u64;
	// 82CEA750: C1BA00E0  lfs f13, 0xe0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEA754: 397A0010  addi r11, r26, 0x10
	ctx.r[11].s64 = ctx.r[26].s64 + 16;
	// 82CEA758: 3D2A0001  addis r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 65536;
	// 82CEA75C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82CEA760: 5528043E  clrlwi r8, r9, 0x10
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82CEA764: B11A00AE  sth r8, 0xae(r26)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[26].u32.wrapping_add(174 as u32), ctx.r[8].u16 ) };
	// 82CEA768: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CEA76C: 419A0014  beq cr6, 0x82cea780
	if ctx.cr[6].eq {
	pc = 0x82CEA780; continue 'dispatch;
	}
	// 82CEA770: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEA774: C00B4E0C  lfs f0, 0x4e0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEA778: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CEA77C: 48000008  b 0x82cea784
	pc = 0x82CEA784; continue 'dispatch;
            }
            0x82CEA780 => {
    //   block [0x82CEA780..0x82CEA784)
	// 82CEA780: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82CEA784; continue 'dispatch;
            }
            0x82CEA784 => {
    //   block [0x82CEA784..0x82CEA788)
	// 82CEA784: D01A00E0  stfs f0, 0xe0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(224 as u32), tmp.u32 ) };
	pc = 0x82CEA788; continue 'dispatch;
            }
            0x82CEA788 => {
    //   block [0x82CEA788..0x82CEA7D8)
	// 82CEA788: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA78C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA790: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA794: 419AFE94  beq cr6, 0x82cea628
	if ctx.cr[6].eq {
	pc = 0x82CEA628; continue 'dispatch;
	}
	// 82CEA798: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA79C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEA7A0: 409AFE88  bne cr6, 0x82cea628
	if !ctx.cr[6].eq {
	pc = 0x82CEA628; continue 'dispatch;
	}
	// 82CEA7A4: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA7A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA7AC: 4082FE7C  bne 0x82cea628
	if !ctx.cr[0].eq {
	pc = 0x82CEA628; continue 'dispatch;
	}
	// 82CEA7B0: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEA7B4: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA7B8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA7BC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA7C4: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA7C8: 485CFB6D  bl 0x832ba334
	ctx.lr = 0x82CEA7CC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA7CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA7D0: 485CFB45  bl 0x832ba314
	ctx.lr = 0x82CEA7D4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA7D4: 4BFFFE54  b 0x82cea628
	pc = 0x82CEA628; continue 'dispatch;
            }
            0x82CEA7D8 => {
    //   block [0x82CEA7D8..0x82CEA7FC)
	// 82CEA7D8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CEA7DC: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEA7E0: 8BBE000D  lbz r29, 0xd(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CEA7E4: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEA7E8: 41820034  beq 0x82cea81c
	if ctx.cr[0].eq {
	pc = 0x82CEA81C; continue 'dispatch;
	}
	// 82CEA7EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82CEA7F0: 419A002C  beq cr6, 0x82cea81c
	if ctx.cr[6].eq {
	pc = 0x82CEA81C; continue 'dispatch;
	}
	// 82CEA7F4: 555B103A  slwi r27, r10, 2
	ctx.r[27].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82CEA7F8: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	pc = 0x82CEA7FC; continue 'dispatch;
            }
            0x82CEA7FC => {
    //   block [0x82CEA7FC..0x82CEA81C)
	// 82CEA7FC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEA800: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CEA804: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEA808: 7C7C5A14  add r3, r28, r11
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82CEA80C: 4BFBF1A5  bl 0x82ca99b0
	ctx.lr = 0x82CEA810;
	sub_82CA99B0(ctx, base);
	// 82CEA810: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82CEA814: 3B9C0400  addi r28, r28, 0x400
	ctx.r[28].s64 = ctx.r[28].s64 + 1024;
	// 82CEA818: 4082FFE4  bne 0x82cea7fc
	if !ctx.cr[0].eq {
	pc = 0x82CEA7FC; continue 'dispatch;
	}
	pc = 0x82CEA81C; continue 'dispatch;
            }
            0x82CEA81C => {
    //   block [0x82CEA81C..0x82CEA868)
	// 82CEA81C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA820: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA824: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA828: 419A0040  beq cr6, 0x82cea868
	if ctx.cr[6].eq {
	pc = 0x82CEA868; continue 'dispatch;
	}
	// 82CEA82C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA830: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEA834: 409A0034  bne cr6, 0x82cea868
	if !ctx.cr[6].eq {
	pc = 0x82CEA868; continue 'dispatch;
	}
	// 82CEA838: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA83C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA840: 40820028  bne 0x82cea868
	if !ctx.cr[0].eq {
	pc = 0x82CEA868; continue 'dispatch;
	}
	// 82CEA844: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEA848: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA84C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA850: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA858: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA85C: 485CFAD9  bl 0x832ba334
	ctx.lr = 0x82CEA860;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA864: 485CFAB1  bl 0x832ba314
	ctx.lr = 0x82CEA868;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEA868; continue 'dispatch;
            }
            0x82CEA868 => {
    //   block [0x82CEA868..0x82CEA878)
	// 82CEA868: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CEA86C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82CEA870: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82CEA874: 4BFBEBD0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CEA878 => {
    //   block [0x82CEA878..0x82CEA898)
	// 82CEA878: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEA87C: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 82CEA880: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CEA884: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82CEA888: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82CEA88C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA890: 4E800421  bctrl
	ctx.lr = 0x82CEA894;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA894: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
            }
            0x82CEA898 => {
    //   block [0x82CEA898..0x82CEA8D8)
	// 82CEA898: 817A00D0  lwz r11, 0xd0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(208 as u32) ) } as u64;
	// 82CEA89C: 3B9A00B8  addi r28, r26, 0xb8
	ctx.r[28].s64 = ctx.r[26].s64 + 184;
	// 82CEA8A0: 815A00D4  lwz r10, 0xd4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 82CEA8A4: 7D2A5851  subf. r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA8A8: 418201F4  beq 0x82ceaa9c
	if ctx.cr[0].eq {
	pc = 0x82CEAA9C; continue 'dispatch;
	}
	// 82CEA8AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CEA8B0: 409A00EC  bne cr6, 0x82cea99c
	if !ctx.cr[6].eq {
	pc = 0x82CEA99C; continue 'dispatch;
	}
	// 82CEA8B4: 485CFA51  bl 0x832ba304
	ctx.lr = 0x82CEA8B8;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA8B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA8BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEA8C0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEA8C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA8C8: 419A0010  beq cr6, 0x82cea8d8
	if ctx.cr[6].eq {
	pc = 0x82CEA8D8; continue 'dispatch;
	}
	// 82CEA8CC: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA8D0: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEA8D4: 419A001C  beq cr6, 0x82cea8f0
	if ctx.cr[6].eq {
	pc = 0x82CEA8F0; continue 'dispatch;
	}
	pc = 0x82CEA8D8; continue 'dispatch;
            }
            0x82CEA8D8 => {
    //   block [0x82CEA8D8..0x82CEA8F0)
	// 82CEA8D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA8DC: 485CFA19  bl 0x832ba2f4
	ctx.lr = 0x82CEA8E0;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA8E0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CEA8E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA8E8: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEA8EC: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82CEA8F0; continue 'dispatch;
            }
            0x82CEA8F0 => {
    //   block [0x82CEA8F0..0x82CEA914)
	// 82CEA8F0: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82CEA8F4: 397A0014  addi r11, r26, 0x14
	ctx.r[11].s64 = ctx.r[26].s64 + 20;
	// 82CEA8F8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82CEA8FC: 815A0014  lwz r10, 0x14(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEA900: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA904: 419A0010  beq cr6, 0x82cea914
	if ctx.cr[6].eq {
	pc = 0x82CEA914; continue 'dispatch;
	}
	// 82CEA908: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA90C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CEA910: 48000008  b 0x82cea918
	pc = 0x82CEA918; continue 'dispatch;
            }
            0x82CEA914 => {
    //   block [0x82CEA914..0x82CEA918)
	// 82CEA914: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x82CEA918; continue 'dispatch;
            }
            0x82CEA918 => {
    //   block [0x82CEA918..0x82CEA944)
	// 82CEA918: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82CEA91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEA920: 419A0038  beq cr6, 0x82cea958
	if ctx.cr[6].eq {
	pc = 0x82CEA958; continue 'dispatch;
	}
	// 82CEA924: 894B0075  lbz r10, 0x75(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(117 as u32) ) } as u64;
	// 82CEA928: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA92C: 409A002C  bne cr6, 0x82cea958
	if !ctx.cr[6].eq {
	pc = 0x82CEA958; continue 'dispatch;
	}
	// 82CEA930: 815A0110  lwz r10, 0x110(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(272 as u32) ) } as u64;
	// 82CEA934: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEA938: 419A000C  beq cr6, 0x82cea944
	if ctx.cr[6].eq {
	pc = 0x82CEA944; continue 'dispatch;
	}
	// 82CEA93C: 92FA0110  stw r23, 0x110(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(272 as u32), ctx.r[23].u32 ) };
	// 82CEA940: 4800000C  b 0x82cea94c
	pc = 0x82CEA94C; continue 'dispatch;
            }
            0x82CEA944 => {
    //   block [0x82CEA944..0x82CEA94C)
	// 82CEA944: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CEA948: 915A0078  stw r10, 0x78(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	pc = 0x82CEA94C; continue 'dispatch;
            }
            0x82CEA94C => {
    //   block [0x82CEA94C..0x82CEA958)
	// 82CEA94C: 9B0B0075  stb r24, 0x75(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(117 as u32), ctx.r[24].u8 ) };
	// 82CEA950: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA954: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82CEA958; continue 'dispatch;
            }
            0x82CEA958 => {
    //   block [0x82CEA958..0x82CEA99C)
	// 82CEA958: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CEA95C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA960: 419A003C  beq cr6, 0x82cea99c
	if ctx.cr[6].eq {
	pc = 0x82CEA99C; continue 'dispatch;
	}
	// 82CEA964: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEA968: 409A0034  bne cr6, 0x82cea99c
	if !ctx.cr[6].eq {
	pc = 0x82CEA99C; continue 'dispatch;
	}
	// 82CEA96C: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA970: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA974: 40820028  bne 0x82cea99c
	if !ctx.cr[0].eq {
	pc = 0x82CEA99C; continue 'dispatch;
	}
	// 82CEA978: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA97C: 8BBF000C  lbz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA980: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEA984: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA98C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA990: 485CF9A5  bl 0x832ba334
	ctx.lr = 0x82CEA994;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA998: 485CF97D  bl 0x832ba314
	ctx.lr = 0x82CEA99C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEA99C; continue 'dispatch;
            }
            0x82CEA99C => {
    //   block [0x82CEA99C..0x82CEA9BC)
	// 82CEA99C: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 82CEA9A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CEA9A4: 419A00F8  beq cr6, 0x82ceaa9c
	if ctx.cr[6].eq {
	pc = 0x82CEAA9C; continue 'dispatch;
	}
	// 82CEA9A8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEA9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEA9B0: 419A000C  beq cr6, 0x82cea9bc
	if ctx.cr[6].eq {
	pc = 0x82CEA9BC; continue 'dispatch;
	}
	// 82CEA9B4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEA9B8: 48000008  b 0x82cea9c0
	pc = 0x82CEA9C0; continue 'dispatch;
            }
            0x82CEA9BC => {
    //   block [0x82CEA9BC..0x82CEA9C0)
	// 82CEA9BC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82CEA9C0; continue 'dispatch;
            }
            0x82CEA9C0 => {
    //   block [0x82CEA9C0..0x82CEA9DC)
	// 82CEA9C0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA9C4: 837A0078  lwz r27, 0x78(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) } as u64;
	// 82CEA9C8: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA9CC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEA9D0: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEA9D4: 40980008  bge cr6, 0x82cea9dc
	if !ctx.cr[6].lt {
	pc = 0x82CEA9DC; continue 'dispatch;
	}
	// 82CEA9D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82CEA9DC; continue 'dispatch;
            }
            0x82CEA9DC => {
    //   block [0x82CEA9DC..0x82CEAA10)
	// 82CEA9DC: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82CEA9E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEA9E4: 4800357D  bl 0x82cedf60
	ctx.lr = 0x82CEA9E8;
	sub_82CEDF60(ctx, base);
	// 82CEA9E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA9EC: 485CF919  bl 0x832ba304
	ctx.lr = 0x82CEA9F0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA9F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA9F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEA9F8: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEA9FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEAA00: 419A0010  beq cr6, 0x82ceaa10
	if ctx.cr[6].eq {
	pc = 0x82CEAA10; continue 'dispatch;
	}
	// 82CEAA04: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAA08: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEAA0C: 419A0018  beq cr6, 0x82ceaa24
	if ctx.cr[6].eq {
	pc = 0x82CEAA24; continue 'dispatch;
	}
	pc = 0x82CEAA10; continue 'dispatch;
            }
            0x82CEAA10 => {
    //   block [0x82CEAA10..0x82CEAA24)
	// 82CEAA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAA14: 485CF8E1  bl 0x832ba2f4
	ctx.lr = 0x82CEAA18;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEAA18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAA1C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEAA20: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CEAA24; continue 'dispatch;
            }
            0x82CEAA24 => {
    //   block [0x82CEAA24..0x82CEAA40)
	// 82CEAA24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEAA28: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEAA2C: 817A0078  lwz r11, 0x78(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) } as u64;
	// 82CEAA30: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEAA34: 409A000C  bne cr6, 0x82ceaa40
	if !ctx.cr[6].eq {
	pc = 0x82CEAA40; continue 'dispatch;
	}
	// 82CEAA38: 7D7CDA14  add r11, r28, r27
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82CEAA3C: 917A0078  stw r11, 0x78(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	pc = 0x82CEAA40; continue 'dispatch;
            }
            0x82CEAA40 => {
    //   block [0x82CEAA40..0x82CEAA9C)
	// 82CEAA40: 817A00A8  lwz r11, 0xa8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 82CEAA44: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEAA48: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82CEAA4C: 917A00A8  stw r11, 0xa8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82CEAA50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAA54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEAA58: 419AFBE0  beq cr6, 0x82cea638
	if ctx.cr[6].eq {
	pc = 0x82CEA638; continue 'dispatch;
	}
	// 82CEAA5C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAA60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEAA64: 409AFBD4  bne cr6, 0x82cea638
	if !ctx.cr[6].eq {
	pc = 0x82CEA638; continue 'dispatch;
	}
	// 82CEAA68: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEAA6C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEAA70: 4082FBC8  bne 0x82cea638
	if !ctx.cr[0].eq {
	pc = 0x82CEA638; continue 'dispatch;
	}
	// 82CEAA74: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEAA78: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEAA7C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEAA80: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEAA84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAA88: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEAA8C: 485CF8A9  bl 0x832ba334
	ctx.lr = 0x82CEAA90;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEAA90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEAA94: 485CF881  bl 0x832ba314
	ctx.lr = 0x82CEAA98;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEAA98: 4BFFFBA0  b 0x82cea638
	pc = 0x82CEA638; continue 'dispatch;
            }
            0x82CEAA9C => {
    //   block [0x82CEAA9C..0x82CEAAC0)
	// 82CEAA9C: 485CF869  bl 0x832ba304
	ctx.lr = 0x82CEAAA0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEAAA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAAA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEAAA8: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEAAAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEAAB0: 419A0010  beq cr6, 0x82ceaac0
	if ctx.cr[6].eq {
	pc = 0x82CEAAC0; continue 'dispatch;
	}
	// 82CEAAB4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAAB8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEAABC: 419A0018  beq cr6, 0x82ceaad4
	if ctx.cr[6].eq {
	pc = 0x82CEAAD4; continue 'dispatch;
	}
	pc = 0x82CEAAC0; continue 'dispatch;
            }
            0x82CEAAC0 => {
    //   block [0x82CEAAC0..0x82CEAAD4)
	// 82CEAAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAAC4: 485CF831  bl 0x832ba2f4
	ctx.lr = 0x82CEAAC8;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEAAC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAACC: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEAAD0: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CEAAD4; continue 'dispatch;
            }
            0x82CEAAD4 => {
    //   block [0x82CEAAD4..0x82CEAB0C)
	// 82CEAAD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEAAD8: 3BDA00B8  addi r30, r26, 0xb8
	ctx.r[30].s64 = ctx.r[26].s64 + 184;
	// 82CEAADC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEAAE0: C01A00E0  lfs f0, 0xe0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEAAE4: D01A00DC  stfs f0, 0xdc(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82CEAAE8: 8BBA00C5  lbz r29, 0xc5(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(197 as u32) ) } as u64;
	// 82CEAAEC: 817A00D4  lwz r11, 0xd4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 82CEAAF0: 815A00D0  lwz r10, 0xd0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(208 as u32) ) } as u64;
	// 82CEAAF4: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEAAF8: 4182009C  beq 0x82ceab94
	if ctx.cr[0].eq {
	pc = 0x82CEAB94; continue 'dispatch;
	}
	// 82CEAAFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82CEAB00: 419A002C  beq cr6, 0x82ceab2c
	if ctx.cr[6].eq {
	pc = 0x82CEAB2C; continue 'dispatch;
	}
	// 82CEAB04: 555B103A  slwi r27, r10, 2
	ctx.r[27].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82CEAB08: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	pc = 0x82CEAB0C; continue 'dispatch;
            }
            0x82CEAB0C => {
    //   block [0x82CEAB0C..0x82CEAB2C)
	// 82CEAB0C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEAB10: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CEAB14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEAB18: 7C7C5A14  add r3, r28, r11
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82CEAB1C: 4BFBEE95  bl 0x82ca99b0
	ctx.lr = 0x82CEAB20;
	sub_82CA99B0(ctx, base);
	// 82CEAB20: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82CEAB24: 3B9C0400  addi r28, r28, 0x400
	ctx.r[28].s64 = ctx.r[28].s64 + 1024;
	// 82CEAB28: 4082FFE4  bne 0x82ceab0c
	if !ctx.cr[0].eq {
	pc = 0x82CEAB0C; continue 'dispatch;
	}
	pc = 0x82CEAB2C; continue 'dispatch;
            }
            0x82CEAB2C => {
    //   block [0x82CEAB2C..0x82CEAB5C)
	// 82CEAB2C: 897A00AC  lbz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CEAB30: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEAB34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEAB38: 409A0044  bne cr6, 0x82ceab7c
	if !ctx.cr[6].eq {
	pc = 0x82CEAB7C; continue 'dispatch;
	}
	// 82CEAB3C: 815A0014  lwz r10, 0x14(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEAB40: 397A0014  addi r11, r26, 0x14
	ctx.r[11].s64 = ctx.r[26].s64 + 20;
	// 82CEAB44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEAB48: 419A0014  beq cr6, 0x82ceab5c
	if ctx.cr[6].eq {
	pc = 0x82CEAB5C; continue 'dispatch;
	}
	// 82CEAB4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAB50: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CEAB54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEAB58: 409A003C  bne cr6, 0x82ceab94
	if !ctx.cr[6].eq {
	pc = 0x82CEAB94; continue 'dispatch;
	}
	pc = 0x82CEAB5C; continue 'dispatch;
            }
            0x82CEAB5C => {
    //   block [0x82CEAB5C..0x82CEAB7C)
	// 82CEAB5C: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEAB60: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 82CEAB64: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82CEAB68: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82CEAB6C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEAB70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAB74: 4E800421  bctrl
	ctx.lr = 0x82CEAB78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAB78: 4800001C  b 0x82ceab94
	pc = 0x82CEAB94; continue 'dispatch;
            }
            0x82CEAB7C => {
    //   block [0x82CEAB7C..0x82CEAB94)
	// 82CEAB7C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAB80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEAB84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82CEAB88: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEAB8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAB90: 4E800421  bctrl
	ctx.lr = 0x82CEAB94;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEAB94 => {
    //   block [0x82CEAB94..0x82CEABBC)
	// 82CEAB94: 897A00AC  lbz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CEAB98: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEAB9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEABA0: 419A0034  beq cr6, 0x82ceabd4
	if ctx.cr[6].eq {
	pc = 0x82CEABD4; continue 'dispatch;
	}
	// 82CEABA4: A15A00AE  lhz r10, 0xae(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(174 as u32) ) } as u64;
	// 82CEABA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEABAC: 419A0010  beq cr6, 0x82ceabbc
	if ctx.cr[6].eq {
	pc = 0x82CEABBC; continue 'dispatch;
	}
	// 82CEABB0: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEABB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEABB8: 419A001C  beq cr6, 0x82ceabd4
	if ctx.cr[6].eq {
	pc = 0x82CEABD4; continue 'dispatch;
	}
	pc = 0x82CEABBC; continue 'dispatch;
            }
            0x82CEABBC => {
    //   block [0x82CEABBC..0x82CEABD4)
	// 82CEABBC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEABC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEABC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82CEABC8: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEABCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEABD0: 4E800421  bctrl
	ctx.lr = 0x82CEABD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEABD4 => {
    //   block [0x82CEABD4..0x82CEAC20)
	// 82CEABD4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEABD8: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEABDC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEABE0: 419A0040  beq cr6, 0x82ceac20
	if ctx.cr[6].eq {
	pc = 0x82CEAC20; continue 'dispatch;
	}
	// 82CEABE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEABE8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEABEC: 409A0034  bne cr6, 0x82ceac20
	if !ctx.cr[6].eq {
	pc = 0x82CEAC20; continue 'dispatch;
	}
	// 82CEABF0: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEABF4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEABF8: 40820028  bne 0x82ceac20
	if !ctx.cr[0].eq {
	pc = 0x82CEAC20; continue 'dispatch;
	}
	// 82CEABFC: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEAC00: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEAC04: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEAC08: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEAC0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAC10: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEAC14: 485CF721  bl 0x832ba334
	ctx.lr = 0x82CEAC18;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEAC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEAC1C: 485CF6F9  bl 0x832ba314
	ctx.lr = 0x82CEAC20;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEAC20; continue 'dispatch;
            }
            0x82CEAC20 => {
    //   block [0x82CEAC20..0x82CEAC24)
	// 82CEAC20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82CEAC24; continue 'dispatch;
            }
            0x82CEAC24 => {
    //   block [0x82CEAC24..0x82CEAC30)
	// 82CEAC24: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82CEAC28: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82CEAC2C: 4BFBE818  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAC30 size=112
    let mut pc: u32 = 0x82CEAC30;
    'dispatch: loop {
        match pc {
            0x82CEAC30 => {
    //   block [0x82CEAC30..0x82CEAC90)
	// 82CEAC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAC34: 4BFBE7D9  bl 0x82ca940c
	ctx.lr = 0x82CEAC38;
	sub_82CA93D0(ctx, base);
	// 82CEAC38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAC3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEAC40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEAC44: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CEAC48: 38800114  li r4, 0x114
	ctx.r[4].s64 = 276;
	// 82CEAC4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAC50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAC54: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEAC58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAC5C: 4E800421  bctrl
	ctx.lr = 0x82CEAC60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAC60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEAC64: 419A002C  beq cr6, 0x82ceac90
	if ctx.cr[6].eq {
	pc = 0x82CEAC90; continue 'dispatch;
	}
	// 82CEAC68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CEAC6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CEAC70: 4BFFF7A1  bl 0x82cea410
	ctx.lr = 0x82CEAC74;
	sub_82CEA410(ctx, base);
	// 82CEAC74: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CEAC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEAC7C: 419A0014  beq cr6, 0x82ceac90
	if ctx.cr[6].eq {
	pc = 0x82CEAC90; continue 'dispatch;
	}
	// 82CEAC80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEAC84: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEAC88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEAC8C: 4BFBE7D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CEAC90 => {
    //   block [0x82CEAC90..0x82CEACA0)
	// 82CEAC90: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEAC94: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEAC98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEAC9C: 4BFBE7C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEACA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEACA0 size=112
    let mut pc: u32 = 0x82CEACA0;
    'dispatch: loop {
        match pc {
            0x82CEACA0 => {
    //   block [0x82CEACA0..0x82CEACF4)
	// 82CEACA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEACA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEACA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEACAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEACB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEACB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEACB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEACBC: 394B5088  addi r10, r11, 0x5088
	ctx.r[10].s64 = ctx.r[11].s64 + 20616;
	// 82CEACC0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEACC4: 48001E2D  bl 0x82cecaf0
	ctx.lr = 0x82CEACC8;
	sub_82CECAF0(ctx, base);
	// 82CEACC8: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEACCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEACD0: 419A0024  beq cr6, 0x82ceacf4
	if ctx.cr[6].eq {
	pc = 0x82CEACF4; continue 'dispatch;
	}
	// 82CEACD4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEACD8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82CEACDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEACE0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEACE4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEACE8: 4E800421  bctrl
	ctx.lr = 0x82CEACEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEACEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CEACF0: 911F0044  stw r8, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[8].u32 ) };
            }
            0x82CEACF4 => {
    //   block [0x82CEACF4..0x82CEAD10)
	// 82CEACF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEACF8: 480016D9  bl 0x82cec3d0
	ctx.lr = 0x82CEACFC;
	sub_82CEC3D0(ctx, base);
	// 82CEACFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEAD00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAD04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAD08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAD0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAD10 size=92
    let mut pc: u32 = 0x82CEAD10;
    'dispatch: loop {
        match pc {
            0x82CEAD10 => {
    //   block [0x82CEAD10..0x82CEAD54)
	// 82CEAD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAD14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAD18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEAD1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAD20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAD24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAD28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEAD2C: 480022BD  bl 0x82cecfe8
	ctx.lr = 0x82CEAD30;
	sub_82CECFE8(ctx, base);
	// 82CEAD30: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEAD34: 41980020  blt cr6, 0x82cead54
	if ctx.cr[6].lt {
	pc = 0x82CEAD54; continue 'dispatch;
	}
	// 82CEAD38: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEAD3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CEAD40: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAD44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAD48: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEAD4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAD50: 4E800421  bctrl
	ctx.lr = 0x82CEAD54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEAD54 => {
    //   block [0x82CEAD54..0x82CEAD6C)
	// 82CEAD54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEAD58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAD5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAD60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEAD64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAD68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAD80 size=128
    let mut pc: u32 = 0x82CEAD80;
    'dispatch: loop {
        match pc {
            0x82CEAD80 => {
    //   block [0x82CEAD80..0x82CEADD0)
	// 82CEAD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAD88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEAD8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAD90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAD94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEAD98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEAD9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEADA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEADA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEADA8: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEADAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEADB0: 4E800421  bctrl
	ctx.lr = 0x82CEADB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEADB4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEADB8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CEADBC: 41980028  blt cr6, 0x82ceade4
	if ctx.cr[6].lt {
	pc = 0x82CEADE4; continue 'dispatch;
	}
	// 82CEADC0: 419A0010  beq cr6, 0x82ceadd0
	if ctx.cr[6].eq {
	pc = 0x82CEADD0; continue 'dispatch;
	}
	// 82CEADC4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82CEADC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEADCC: 4800001C  b 0x82ceade8
	pc = 0x82CEADE8; continue 'dispatch;
            }
            0x82CEADD0 => {
    //   block [0x82CEADD0..0x82CEADE4)
	// 82CEADD0: 897F004C  lbz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CEADD4: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82CEADD8: 1D6B002C  mulli r11, r11, 0x2c
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CEADDC: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEADE0: 48000008  b 0x82ceade8
	pc = 0x82CEADE8; continue 'dispatch;
            }
            0x82CEADE4 => {
    //   block [0x82CEADE4..0x82CEADE8)
	// 82CEADE4: 387E0050  addi r3, r30, 0x50
	ctx.r[3].s64 = ctx.r[30].s64 + 80;
	pc = 0x82CEADE8; continue 'dispatch;
            }
            0x82CEADE8 => {
    //   block [0x82CEADE8..0x82CEAE00)
	// 82CEADE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEADEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEADF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEADF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEADF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEADFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAE00 size=48
    let mut pc: u32 = 0x82CEAE00;
    'dispatch: loop {
        match pc {
            0x82CEAE00 => {
    //   block [0x82CEAE00..0x82CEAE30)
	// 82CEAE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAE04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAE08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAE0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAE10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAE14: 4BFFFE8D  bl 0x82ceaca0
	ctx.lr = 0x82CEAE18;
	sub_82CEACA0(ctx, base);
	// 82CEAE18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAE1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEAE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAE28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAE2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAE30 size=296
    let mut pc: u32 = 0x82CEAE30;
    'dispatch: loop {
        match pc {
            0x82CEAE30 => {
    //   block [0x82CEAE30..0x82CEAE94)
	// 82CEAE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAE38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEAE3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAE40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAE44: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82CEAE48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEAE4C: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82CEAE50: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CEAE54: 6148BB80  ori r8, r10, 0xbb80
	ctx.r[8].u64 = ctx.r[10].u64 | 48000;
	// 82CEAE58: FBCB0000  std r30, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 82CEAE5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAE60: FBCB0008  std r30, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u64 ) };
	// 82CEAE64: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CEAE68: FBCB0010  std r30, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u64 ) };
	// 82CEAE6C: 9BC10060  stb r30, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 82CEAE70: 99210061  stb r9, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[9].u8 ) };
	// 82CEAE74: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82CEAE78: 419A001C  beq cr6, 0x82ceae94
	if ctx.cr[6].eq {
	pc = 0x82CEAE94; continue 'dispatch;
	}
	// 82CEAE7C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAE80: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAE84: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAE88: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82CEAE8C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82CEAE90: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	pc = 0x82CEAE94; continue 'dispatch;
            }
            0x82CEAE94 => {
    //   block [0x82CEAE94..0x82CEAEF0)
	// 82CEAE94: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82CEAE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAE9C: 48002015  bl 0x82ceceb0
	ctx.lr = 0x82CEAEA0;
	sub_82CECEB0(ctx, base);
	// 82CEAEA0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEAEA4: 4198009C  blt cr6, 0x82ceaf40
	if ctx.cr[6].lt {
	pc = 0x82CEAF40; continue 'dispatch;
	}
	// 82CEAEA8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82CEAEAC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAEB0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82CEAEB4: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82CEAEB8: FBCB0000  std r30, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 82CEAEBC: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEAEC0: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82CEAEC4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82CEAEC8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAECC: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEAED0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEAED4: 4E800421  bctrl
	ctx.lr = 0x82CEAED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEAEDC: 419A0014  beq cr6, 0x82ceaef0
	if ctx.cr[6].eq {
	pc = 0x82CEAEF0; continue 'dispatch;
	}
	// 82CEAEE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEAEE4: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAEE8: 4BFF3CD9  bl 0x82cdebc0
	ctx.lr = 0x82CEAEEC;
	sub_82CDEBC0(ctx, base);
	// 82CEAEEC: 48000008  b 0x82ceaef4
	pc = 0x82CEAEF4; continue 'dispatch;
            }
            0x82CEAEF0 => {
    //   block [0x82CEAEF0..0x82CEAEF4)
	// 82CEAEF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82CEAEF4; continue 'dispatch;
            }
            0x82CEAEF4 => {
    //   block [0x82CEAEF4..0x82CEAF0C)
	// 82CEAEF4: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82CEAEF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEAEFC: 409A0010  bne cr6, 0x82ceaf0c
	if !ctx.cr[6].eq {
	pc = 0x82CEAF0C; continue 'dispatch;
	}
	// 82CEAF00: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEAF04: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEAF08: 48000038  b 0x82ceaf40
	pc = 0x82CEAF40; continue 'dispatch;
            }
            0x82CEAF0C => {
    //   block [0x82CEAF0C..0x82CEAF40)
	// 82CEAF0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAF10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEAF14: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAF18: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEAF1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAF20: 4E800421  bctrl
	ctx.lr = 0x82CEAF24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAF24: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEAF28: 41980018  blt cr6, 0x82ceaf40
	if ctx.cr[6].lt {
	pc = 0x82CEAF40; continue 'dispatch;
	}
	// 82CEAF2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAF30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAF34: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEAF38: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAF3C: 4E800421  bctrl
	ctx.lr = 0x82CEAF40;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEAF40 => {
    //   block [0x82CEAF40..0x82CEAF58)
	// 82CEAF40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEAF44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAF48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAF4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEAF50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAF54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAF58 size=84
    let mut pc: u32 = 0x82CEAF58;
    'dispatch: loop {
        match pc {
            0x82CEAF58 => {
    //   block [0x82CEAF58..0x82CEAF90)
	// 82CEAF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAF60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEAF64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAF68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAF6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEAF70: 48001291  bl 0x82cec200
	ctx.lr = 0x82CEAF74;
	sub_82CEC200(ctx, base);
	// 82CEAF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAF78: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CEAF7C: 41980014  blt cr6, 0x82ceaf90
	if ctx.cr[6].lt {
	pc = 0x82CEAF90; continue 'dispatch;
	}
	// 82CEAF80: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82CEAF84: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEAF88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEAF8C: 4BFF3885  bl 0x82cde810
	ctx.lr = 0x82CEAF90;
	sub_82CDE810(ctx, base);
	pc = 0x82CEAF90; continue 'dispatch;
            }
            0x82CEAF90 => {
    //   block [0x82CEAF90..0x82CEAFAC)
	// 82CEAF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAF94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEAF98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAF9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAFA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEAFA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAFA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAFB0 size=104
    let mut pc: u32 = 0x82CEAFB0;
    'dispatch: loop {
        match pc {
            0x82CEAFB0 => {
    //   block [0x82CEAFB0..0x82CEAFEC)
	// 82CEAFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAFB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAFBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAFC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAFC4: 897F003D  lbz r11, 0x3d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEAFC8: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEAFCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEAFD0: 419A001C  beq cr6, 0x82ceafec
	if ctx.cr[6].eq {
	pc = 0x82CEAFEC; continue 'dispatch;
	}
	// 82CEAFD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEAFD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEAFDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAFE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAFE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAFE8: 4E800020  blr
	return;
            }
            0x82CEAFEC => {
    //   block [0x82CEAFEC..0x82CEB018)
	// 82CEAFEC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82CEAFF0: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEAFF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEAFF8: 4BFF3819  bl 0x82cde810
	ctx.lr = 0x82CEAFFC;
	sub_82CDE810(ctx, base);
	// 82CEAFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB000: 480018C9  bl 0x82cec8c8
	ctx.lr = 0x82CEB004;
	sub_82CEC8C8(ctx, base);
	// 82CEB004: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB00C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB018 size=224
    let mut pc: u32 = 0x82CEB018;
    'dispatch: loop {
        match pc {
            0x82CEB018 => {
    //   block [0x82CEB018..0x82CEB054)
	// 82CEB018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB01C: 4BFBE3ED  bl 0x82ca9408
	ctx.lr = 0x82CEB020;
	sub_82CA93D0(ctx, base);
	// 82CEB020: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB024: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEB028: 485CF2DD  bl 0x832ba304
	ctx.lr = 0x82CEB02C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEB02C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB030: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEB034: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEB038: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEB03C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB040: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEB044: 419A0010  beq cr6, 0x82ceb054
	if ctx.cr[6].eq {
	pc = 0x82CEB054; continue 'dispatch;
	}
	// 82CEB048: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB04C: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEB050: 419A001C  beq cr6, 0x82ceb06c
	if ctx.cr[6].eq {
	pc = 0x82CEB06C; continue 'dispatch;
	}
	pc = 0x82CEB054; continue 'dispatch;
            }
            0x82CEB054 => {
    //   block [0x82CEB054..0x82CEB06C)
	// 82CEB054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB058: 485CF29D  bl 0x832ba2f4
	ctx.lr = 0x82CEB05C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEB05C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CEB060: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB064: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEB068: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82CEB06C; continue 'dispatch;
            }
            0x82CEB06C => {
    //   block [0x82CEB06C..0x82CEB0A8)
	// 82CEB06C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CEB070: 397C0018  addi r11, r28, 0x18
	ctx.r[11].s64 = ctx.r[28].s64 + 24;
	// 82CEB074: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEB078: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEB07C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEB080: 419A0028  beq cr6, 0x82ceb0a8
	if ctx.cr[6].eq {
	pc = 0x82CEB0A8; continue 'dispatch;
	}
	// 82CEB084: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB088: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEB08C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB090: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB094: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB098: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB09C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB0A0: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB0A4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82CEB0A8; continue 'dispatch;
            }
            0x82CEB0A8 => {
    //   block [0x82CEB0A8..0x82CEB0EC)
	// 82CEB0A8: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CEB0AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEB0B0: 419A003C  beq cr6, 0x82ceb0ec
	if ctx.cr[6].eq {
	pc = 0x82CEB0EC; continue 'dispatch;
	}
	// 82CEB0B4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEB0B8: 409A0034  bne cr6, 0x82ceb0ec
	if !ctx.cr[6].eq {
	pc = 0x82CEB0EC; continue 'dispatch;
	}
	// 82CEB0BC: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEB0C0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB0C4: 40820028  bne 0x82ceb0ec
	if !ctx.cr[0].eq {
	pc = 0x82CEB0EC; continue 'dispatch;
	}
	// 82CEB0C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB0CC: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB0D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEB0D4: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEB0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB0DC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEB0E0: 485CF255  bl 0x832ba334
	ctx.lr = 0x82CEB0E4;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEB0E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEB0E8: 485CF22D  bl 0x832ba314
	ctx.lr = 0x82CEB0EC;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEB0EC; continue 'dispatch;
            }
            0x82CEB0EC => {
    //   block [0x82CEB0EC..0x82CEB0F8)
	// 82CEB0EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB0F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB0F4: 4BFBE364  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB0F8 size=148
    let mut pc: u32 = 0x82CEB0F8;
    'dispatch: loop {
        match pc {
            0x82CEB0F8 => {
    //   block [0x82CEB0F8..0x82CEB158)
	// 82CEB0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB104: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB108: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82CEB10C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB110: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82CEB114: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82CEB118: 6127BB80  ori r7, r9, 0xbb80
	ctx.r[7].u64 = ctx.r[9].u64 | 48000;
	// 82CEB11C: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82CEB120: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEB124: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82CEB128: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEB12C: F96A0010  std r11, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82CEB130: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82CEB134: 99010061  stb r8, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[8].u8 ) };
	// 82CEB138: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82CEB13C: 419A001C  beq cr6, 0x82ceb158
	if ctx.cr[6].eq {
	pc = 0x82CEB158; continue 'dispatch;
	}
	// 82CEB140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB144: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB148: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB14C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82CEB150: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82CEB154: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	pc = 0x82CEB158; continue 'dispatch;
            }
            0x82CEB158 => {
    //   block [0x82CEB158..0x82CEB178)
	// 82CEB158: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEB15C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82CEB160: 48001189  bl 0x82cec2e8
	ctx.lr = 0x82CEB164;
	sub_82CEC2E8(ctx, base);
	// 82CEB164: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB168: 41980010  blt cr6, 0x82ceb178
	if ctx.cr[6].lt {
	pc = 0x82CEB178; continue 'dispatch;
	}
	// 82CEB16C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB170: 394B001C  addi r10, r11, 0x1c
	ctx.r[10].s64 = ctx.r[11].s64 + 28;
	// 82CEB174: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82CEB178; continue 'dispatch;
            }
            0x82CEB178 => {
    //   block [0x82CEB178..0x82CEB18C)
	// 82CEB178: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEB17C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB184: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB190 size=240
    let mut pc: u32 = 0x82CEB190;
    'dispatch: loop {
        match pc {
            0x82CEB190 => {
    //   block [0x82CEB190..0x82CEB1E8)
	// 82CEB190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB194: 4BFBE271  bl 0x82ca9404
	ctx.lr = 0x82CEB198;
	sub_82CA93D0(ctx, base);
	// 82CEB198: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB19C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB1A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEB1A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CEB1A8: 806B72AC  lwz r3, 0x72ac(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEB1AC: 4BFFFBD5  bl 0x82cead80
	ctx.lr = 0x82CEB1B0;
	sub_82CEAD80(ctx, base);
	// 82CEB1B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82CEB1B4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CEB1B8: 419A00BC  beq cr6, 0x82ceb274
	if ctx.cr[6].eq {
	pc = 0x82CEB274; continue 'dispatch;
	}
	// 82CEB1BC: 485CF149  bl 0x832ba304
	ctx.lr = 0x82CEB1C0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEB1C0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB1C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEB1C8: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEB1CC: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEB1D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB1D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEB1D8: 419A0010  beq cr6, 0x82ceb1e8
	if ctx.cr[6].eq {
	pc = 0x82CEB1E8; continue 'dispatch;
	}
	// 82CEB1DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB1E0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEB1E4: 419A0018  beq cr6, 0x82ceb1fc
	if ctx.cr[6].eq {
	pc = 0x82CEB1FC; continue 'dispatch;
	}
	pc = 0x82CEB1E8; continue 'dispatch;
            }
            0x82CEB1E8 => {
    //   block [0x82CEB1E8..0x82CEB1FC)
	// 82CEB1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB1EC: 485CF109  bl 0x832ba2f4
	ctx.lr = 0x82CEB1F0;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEB1F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB1F4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEB1F8: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CEB1FC; continue 'dispatch;
            }
            0x82CEB1FC => {
    //   block [0x82CEB1FC..0x82CEB274)
	// 82CEB1FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEB200: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEB204: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB208: 813B0028  lwz r9, 0x28(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEB20C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB210: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82CEB214: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB218: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB21C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEB220: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB224: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB228: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB22C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB230: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEB234: 419A0040  beq cr6, 0x82ceb274
	if ctx.cr[6].eq {
	pc = 0x82CEB274; continue 'dispatch;
	}
	// 82CEB238: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB23C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEB240: 409A0034  bne cr6, 0x82ceb274
	if !ctx.cr[6].eq {
	pc = 0x82CEB274; continue 'dispatch;
	}
	// 82CEB244: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEB248: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB24C: 40820028  bne 0x82ceb274
	if !ctx.cr[0].eq {
	pc = 0x82CEB274; continue 'dispatch;
	}
	// 82CEB250: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEB254: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB25C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEB260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB264: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEB268: 485CF0CD  bl 0x832ba334
	ctx.lr = 0x82CEB26C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEB26C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEB270: 485CF0A5  bl 0x832ba314
	ctx.lr = 0x82CEB274;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEB274; continue 'dispatch;
            }
            0x82CEB274 => {
    //   block [0x82CEB274..0x82CEB280)
	// 82CEB274: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB278: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB27C: 4BFBE1D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB280 size=264
    let mut pc: u32 = 0x82CEB280;
    'dispatch: loop {
        match pc {
            0x82CEB280 => {
    //   block [0x82CEB280..0x82CEB2B8)
	// 82CEB280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB284: 4BFBE185  bl 0x82ca9408
	ctx.lr = 0x82CEB288;
	sub_82CA93D0(ctx, base);
	// 82CEB288: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB28C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB290: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CEB294: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CEB298: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82CEB29C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEB2A0: 4BFFFE59  bl 0x82ceb0f8
	ctx.lr = 0x82CEB2A4;
	sub_82CEB0F8(ctx, base);
	// 82CEB2A4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB2A8: 41980010  blt cr6, 0x82ceb2b8
	if ctx.cr[6].lt {
	pc = 0x82CEB2B8; continue 'dispatch;
	}
	// 82CEB2AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEB2B0: 388B0048  addi r4, r11, 0x48
	ctx.r[4].s64 = ctx.r[11].s64 + 72;
	// 82CEB2B4: 48000008  b 0x82ceb2bc
	pc = 0x82CEB2BC; continue 'dispatch;
            }
            0x82CEB2B8 => {
    //   block [0x82CEB2B8..0x82CEB2BC)
	// 82CEB2B8: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82CEB2BC; continue 'dispatch;
            }
            0x82CEB2BC => {
    //   block [0x82CEB2BC..0x82CEB340)
	// 82CEB2BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEB2C0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB2C4: 4198009C  blt cr6, 0x82ceb360
	if ctx.cr[6].lt {
	pc = 0x82CEB360; continue 'dispatch;
	}
	// 82CEB2C8: 3C606182  lis r3, 0x6182
	ctx.r[3].s64 = 1635909632;
	// 82CEB2CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEB2D0: 60630006  ori r3, r3, 6
	ctx.r[3].u64 = ctx.r[3].u64 | 6;
	// 82CEB2D4: 4800053D  bl 0x82ceb810
	ctx.lr = 0x82CEB2D8;
	sub_82CEB810(ctx, base);
	// 82CEB2D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEB2DC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEB2E0: 41980080  blt cr6, 0x82ceb360
	if ctx.cr[6].lt {
	pc = 0x82CEB360; continue 'dispatch;
	}
	// 82CEB2E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB2E8: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 82CEB2EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB2F0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEB2F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB2F8: 4E800421  bctrl
	ctx.lr = 0x82CEB2FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB300: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CEB304: 419A003C  beq cr6, 0x82ceb340
	if ctx.cr[6].eq {
	pc = 0x82CEB340; continue 'dispatch;
	}
	// 82CEB308: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82CEB30C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB310: 48001329  bl 0x82cec638
	ctx.lr = 0x82CEB314;
	sub_82CEC638(ctx, base);
	// 82CEB314: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB318: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82CEB31C: 394B5088  addi r10, r11, 0x5088
	ctx.r[10].s64 = ctx.r[11].s64 + 20616;
	// 82CEB320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB324: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEB328: 4BFFFB09  bl 0x82ceae30
	ctx.lr = 0x82CEB32C;
	sub_82CEAE30(ctx, base);
	// 82CEB32C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEB330: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEB334: 41980018  blt cr6, 0x82ceb34c
	if ctx.cr[6].lt {
	pc = 0x82CEB34C; continue 'dispatch;
	}
	// 82CEB338: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82CEB33C: 48000024  b 0x82ceb360
	pc = 0x82CEB360; continue 'dispatch;
            }
            0x82CEB340 => {
    //   block [0x82CEB340..0x82CEB34C)
	// 82CEB340: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 82CEB344: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 82CEB348: 48000018  b 0x82ceb360
	pc = 0x82CEB360; continue 'dispatch;
            }
            0x82CEB34C => {
    //   block [0x82CEB34C..0x82CEB360)
	// 82CEB34C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB354: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB358: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB35C: 4E800421  bctrl
	ctx.lr = 0x82CEB360;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEB360 => {
    //   block [0x82CEB360..0x82CEB37C)
	// 82CEB360: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEB368: 419A0014  beq cr6, 0x82ceb37c
	if ctx.cr[6].eq {
	pc = 0x82CEB37C; continue 'dispatch;
	}
	// 82CEB36C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB370: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB374: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB378: 4E800421  bctrl
	ctx.lr = 0x82CEB37C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEB37C => {
    //   block [0x82CEB37C..0x82CEB388)
	// 82CEB37C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEB380: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB384: 4BFBE0D4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEB388 size=24
    let mut pc: u32 = 0x82CEB388;
    'dispatch: loop {
        match pc {
            0x82CEB388 => {
    //   block [0x82CEB388..0x82CEB3A0)
	// 82CEB388: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 82CEB38C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEB390: 556B003A  rlwinm r11, r11, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEB394: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEB398: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82CEB39C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB3A0 size=116
    let mut pc: u32 = 0x82CEB3A0;
    'dispatch: loop {
        match pc {
            0x82CEB3A0 => {
    //   block [0x82CEB3A0..0x82CEB3C4)
	// 82CEB3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB3A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB3AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB3B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB3B4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82CEB3B8: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEB3BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CEB3C0: 409A001C  bne cr6, 0x82ceb3dc
	if !ctx.cr[6].eq {
	pc = 0x82CEB3DC; continue 'dispatch;
	}
	pc = 0x82CEB3C4; continue 'dispatch;
            }
            0x82CEB3C4 => {
    //   block [0x82CEB3C4..0x82CEB3DC)
	// 82CEB3C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB3C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB3CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB3D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB3D8: 4E800020  blr
	return;
            }
            0x82CEB3DC => {
    //   block [0x82CEB3DC..0x82CEB414)
	// 82CEB3DC: 90BF000C  stw r5, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82CEB3E0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB3E4: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB3E8: 4BFF5431  bl 0x82ce0818
	ctx.lr = 0x82CEB3EC;
	sub_82CE0818(ctx, base);
	// 82CEB3EC: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82CEB3F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEB3F4: 409AFFD0  bne cr6, 0x82ceb3c4
	if !ctx.cr[6].eq {
	pc = 0x82CEB3C4; continue 'dispatch;
	}
	// 82CEB3F8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEB3FC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEB400: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB40C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB418 size=108
    let mut pc: u32 = 0x82CEB418;
    'dispatch: loop {
        match pc {
            0x82CEB418 => {
    //   block [0x82CEB418..0x82CEB458)
	// 82CEB418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB430: 39440003  addi r10, r4, 3
	ctx.r[10].s64 = ctx.r[4].s64 + 3;
	// 82CEB434: 555E003A  rlwinm r30, r10, 0, 0, 0x1d
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEB438: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB43C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEB440: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEB444: 4E800421  bctrl
	ctx.lr = 0x82CEB448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB448: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82CEB44C: 4099000C  ble cr6, 0x82ceb458
	if !ctx.cr[6].gt {
	pc = 0x82CEB458; continue 'dispatch;
	}
	// 82CEB450: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB454: 48000018  b 0x82ceb46c
	pc = 0x82CEB46C; continue 'dispatch;
            }
            0x82CEB458 => {
    //   block [0x82CEB458..0x82CEB46C)
	// 82CEB458: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEB45C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEB460: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEB464: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CEB468: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	pc = 0x82CEB46C; continue 'dispatch;
            }
            0x82CEB46C => {
    //   block [0x82CEB46C..0x82CEB484)
	// 82CEB46C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB478: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB47C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB488 size=124
    let mut pc: u32 = 0x82CEB488;
    'dispatch: loop {
        match pc {
            0x82CEB488 => {
    //   block [0x82CEB488..0x82CEB4E0)
	// 82CEB488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB49C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB4A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB4A4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB4A8: 392B50F4  addi r9, r11, 0x50f4
	ctx.r[9].s64 = ctx.r[11].s64 + 20724;
	// 82CEB4AC: 390A50E0  addi r8, r10, 0x50e0
	ctx.r[8].s64 = ctx.r[10].s64 + 20704;
	// 82CEB4B0: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEB4B4: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82CEB4B8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB4BC: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEB4C0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CEB4C4: 419A001C  beq cr6, 0x82ceb4e0
	if ctx.cr[6].eq {
	pc = 0x82CEB4E0; continue 'dispatch;
	}
	// 82CEB4C8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB4CC: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB4D0: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB4D4: 4BFF5355  bl 0x82ce0828
	ctx.lr = 0x82CEB4D8;
	sub_82CE0828(ctx, base);
	// 82CEB4D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEB4DC: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	pc = 0x82CEB4E0; continue 'dispatch;
            }
            0x82CEB4E0 => {
    //   block [0x82CEB4E0..0x82CEB504)
	// 82CEB4E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB4E4: 394B3DD0  addi r10, r11, 0x3dd0
	ctx.r[10].s64 = ctx.r[11].s64 + 15824;
	// 82CEB4E8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEB4EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB4F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB4F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB4F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB4FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEB510 size=16
    let mut pc: u32 = 0x82CEB510;
    'dispatch: loop {
        match pc {
            0x82CEB510 => {
    //   block [0x82CEB510..0x82CEB520)
	// 82CEB510: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEB514: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEB518: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CEB51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB530 size=100
    let mut pc: u32 = 0x82CEB530;
    'dispatch: loop {
        match pc {
            0x82CEB530 => {
    //   block [0x82CEB530..0x82CEB57C)
	// 82CEB530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB53C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB544: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB548: 3BE3FFFC  addi r31, r3, -4
	ctx.r[31].s64 = ctx.r[3].s64 + -4;
	// 82CEB54C: 83C30008  lwz r30, 8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB550: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEB554: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB558: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB55C: 4E800421  bctrl
	ctx.lr = 0x82CEB560;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB560: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CEB564: 419A0018  beq cr6, 0x82ceb57c
	if ctx.cr[6].eq {
	pc = 0x82CEB57C; continue 'dispatch;
	}
	// 82CEB568: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB56C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CEB570: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEB578: 4BFF52B1  bl 0x82ce0828
	ctx.lr = 0x82CEB57C;
	sub_82CE0828(ctx, base);
            }
            0x82CEB57C => {
    //   block [0x82CEB57C..0x82CEB594)
	// 82CEB57C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB588: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB58C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB598 size=92
    let mut pc: u32 = 0x82CEB598;
    'dispatch: loop {
        match pc {
            0x82CEB598 => {
    //   block [0x82CEB598..0x82CEB5D8)
	// 82CEB598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB5A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB5A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB5A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB5AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB5B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB5B4: 4BFFFED5  bl 0x82ceb488
	ctx.lr = 0x82CEB5B8;
	sub_82CEB488(ctx, base);
	// 82CEB5B8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CEB5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEB5C0: 419A0018  beq cr6, 0x82ceb5d8
	if ctx.cr[6].eq {
	pc = 0x82CEB5D8; continue 'dispatch;
	}
	// 82CEB5C4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB5C8: 3CA06182  lis r5, 0x6182
	ctx.r[5].s64 = 1635909632;
	// 82CEB5CC: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB5D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEB5D4: 4BFF5255  bl 0x82ce0828
	ctx.lr = 0x82CEB5D8;
	sub_82CE0828(ctx, base);
	pc = 0x82CEB5D8; continue 'dispatch;
            }
            0x82CEB5D8 => {
    //   block [0x82CEB5D8..0x82CEB5F4)
	// 82CEB5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB5DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB5E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB5E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB5E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB5EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB5F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB5F8 size=116
    let mut pc: u32 = 0x82CEB5F8;
    'dispatch: loop {
        match pc {
            0x82CEB5F8 => {
    //   block [0x82CEB5F8..0x82CEB650)
	// 82CEB5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB60C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB610: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB614: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB618: 392B50F4  addi r9, r11, 0x50f4
	ctx.r[9].s64 = ctx.r[11].s64 + 20724;
	// 82CEB61C: 390A510C  addi r8, r10, 0x510c
	ctx.r[8].s64 = ctx.r[10].s64 + 20748;
	// 82CEB620: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB624: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB628: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEB62C: 4BFFFE5D  bl 0x82ceb488
	ctx.lr = 0x82CEB630;
	sub_82CEB488(ctx, base);
	// 82CEB630: 57C707FE  clrlwi r7, r30, 0x1f
	ctx.r[7].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CEB634: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CEB638: 419A0018  beq cr6, 0x82ceb650
	if ctx.cr[6].eq {
	pc = 0x82CEB650; continue 'dispatch;
	}
	// 82CEB63C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB640: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CEB644: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEB64C: 4BFF51DD  bl 0x82ce0828
	ctx.lr = 0x82CEB650;
	sub_82CE0828(ctx, base);
	pc = 0x82CEB650; continue 'dispatch;
            }
            0x82CEB650 => {
    //   block [0x82CEB650..0x82CEB66C)
	// 82CEB650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB660: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB670 size=80
    let mut pc: u32 = 0x82CEB670;
    'dispatch: loop {
        match pc {
            0x82CEB670 => {
    //   block [0x82CEB670..0x82CEB6C0)
	// 82CEB670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB67C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB684: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB688: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB68C: 392B50F4  addi r9, r11, 0x50f4
	ctx.r[9].s64 = ctx.r[11].s64 + 20724;
	// 82CEB690: 390A5120  addi r8, r10, 0x5120
	ctx.r[8].s64 = ctx.r[10].s64 + 20768;
	// 82CEB694: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CEB698: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB69C: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEB6A0: 90FF0018  stw r7, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82CEB6A4: 4BFFFDE5  bl 0x82ceb488
	ctx.lr = 0x82CEB6A8;
	sub_82CEB488(ctx, base);
	// 82CEB6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB6AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB6B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB6B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB6B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB6BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB6C0 size=176
    let mut pc: u32 = 0x82CEB6C0;
    'dispatch: loop {
        match pc {
            0x82CEB6C0 => {
    //   block [0x82CEB6C0..0x82CEB754)
	// 82CEB6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB6C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB6CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB6D0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB6D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB6D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CEB6DC: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB6E0: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82CEB6E4: 4BFF5135  bl 0x82ce0818
	ctx.lr = 0x82CEB6E8;
	sub_82CE0818(ctx, base);
	// 82CEB6E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CEB6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEB6F0: 419A0064  beq cr6, 0x82ceb754
	if ctx.cr[6].eq {
	pc = 0x82CEB754; continue 'dispatch;
	}
	// 82CEB6F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB6F8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEB6FC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEB700: 38EA3DD0  addi r7, r10, 0x3dd0
	ctx.r[7].s64 = ctx.r[10].s64 + 15824;
	// 82CEB704: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CEB708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEB70C: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CEB710: 38A950F4  addi r5, r9, 0x50f4
	ctx.r[5].s64 = ctx.r[9].s64 + 20724;
	// 82CEB714: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82CEB718: 3888510C  addi r4, r8, 0x510c
	ctx.r[4].s64 = ctx.r[8].s64 + 20748;
	// 82CEB71C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82CEB720: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82CEB724: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82CEB728: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82CEB72C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82CEB730: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82CEB734: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82CEB738: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82CEB73C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB740: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB74C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB750: 4E800020  blr
	return;
            }
            0x82CEB754 => {
    //   block [0x82CEB754..0x82CEB770)
	// 82CEB754: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEB758: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEB75C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB768: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB76C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB770 size=156
    let mut pc: u32 = 0x82CEB770;
    'dispatch: loop {
        match pc {
            0x82CEB770 => {
    //   block [0x82CEB770..0x82CEB7B8)
	// 82CEB770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB774: 4BFBDC99  bl 0x82ca940c
	ctx.lr = 0x82CEB778;
	sub_82CA93D0(ctx, base);
	// 82CEB778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB780: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB784: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB788: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CEB78C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CEB790: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB794: 389E001C  addi r4, r30, 0x1c
	ctx.r[4].s64 = ctx.r[30].s64 + 28;
	// 82CEB798: 4BFF5081  bl 0x82ce0818
	ctx.lr = 0x82CEB79C;
	sub_82CE0818(ctx, base);
	// 82CEB79C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CEB7A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEB7A4: 409A0014  bne cr6, 0x82ceb7b8
	if !ctx.cr[6].eq {
	pc = 0x82CEB7B8; continue 'dispatch;
	}
	// 82CEB7A8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEB7AC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEB7B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB7B4: 4BFBDCA8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CEB7B8 => {
    //   block [0x82CEB7B8..0x82CEB80C)
	// 82CEB7B8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB7BC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEB7C0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEB7C4: 38EA3DD0  addi r7, r10, 0x3dd0
	ctx.r[7].s64 = ctx.r[10].s64 + 15824;
	// 82CEB7C8: 38A950F4  addi r5, r9, 0x50f4
	ctx.r[5].s64 = ctx.r[9].s64 + 20724;
	// 82CEB7CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CEB7D0: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CEB7D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB7D8: 38885120  addi r4, r8, 0x5120
	ctx.r[4].s64 = ctx.r[8].s64 + 20768;
	// 82CEB7DC: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82CEB7E0: 392B001C  addi r9, r11, 0x1c
	ctx.r[9].s64 = ctx.r[11].s64 + 28;
	// 82CEB7E4: 906B0014  stw r3, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82CEB7E8: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82CEB7EC: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82CEB7F0: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82CEB7F4: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82CEB7F8: 93CB0010  stw r30, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82CEB7FC: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82CEB800: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB804: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB808: 4BFBDC54  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB810 size=172
    let mut pc: u32 = 0x82CEB810;
    'dispatch: loop {
        match pc {
            0x82CEB810 => {
    //   block [0x82CEB810..0x82CEB850)
	// 82CEB810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB814: 4BFBDBF5  bl 0x82ca9408
	ctx.lr = 0x82CEB818;
	sub_82CA93D0(ctx, base);
	// 82CEB818: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB81C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82CEB820: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEB824: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB828: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB82C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CEB830: 409A0040  bne cr6, 0x82ceb870
	if !ctx.cr[6].eq {
	pc = 0x82CEB870; continue 'dispatch;
	}
	// 82CEB834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB838: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CEB83C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CEB840: 419A0010  beq cr6, 0x82ceb850
	if ctx.cr[6].eq {
	pc = 0x82CEB850; continue 'dispatch;
	}
	// 82CEB844: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEB848: 4BFFFF29  bl 0x82ceb770
	ctx.lr = 0x82CEB84C;
	sub_82CEB770(ctx, base);
	// 82CEB84C: 4800000C  b 0x82ceb858
	pc = 0x82CEB858; continue 'dispatch;
            }
            0x82CEB850 => {
    //   block [0x82CEB850..0x82CEB858)
	// 82CEB850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CEB854: 4BFFFE6D  bl 0x82ceb6c0
	ctx.lr = 0x82CEB858;
	sub_82CEB6C0(ctx, base);
	pc = 0x82CEB858; continue 'dispatch;
            }
            0x82CEB858 => {
    //   block [0x82CEB858..0x82CEB870)
	// 82CEB858: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB85C: 41980058  blt cr6, 0x82ceb8b4
	if ctx.cr[6].lt {
	pc = 0x82CEB8B4; continue 'dispatch;
	}
	// 82CEB860: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB864: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB868: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB86C: 4BFBDBEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CEB870 => {
    //   block [0x82CEB870..0x82CEB8B4)
	// 82CEB870: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB878: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB87C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB880: 4E800421  bctrl
	ctx.lr = 0x82CEB884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB884: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB888: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CEB88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB890: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB894: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEB898: 4E800421  bctrl
	ctx.lr = 0x82CEB89C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB89C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB8A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82CEB8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB8A8: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB8AC: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82CEB8B0: 4E800421  bctrl
	ctx.lr = 0x82CEB8B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEB8B4 => {
    //   block [0x82CEB8B4..0x82CEB8BC)
	// 82CEB8B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB8B8: 4BFBDBA0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB8C0 size=60
    let mut pc: u32 = 0x82CEB8C0;
    'dispatch: loop {
        match pc {
            0x82CEB8C0 => {
    //   block [0x82CEB8C0..0x82CEB8FC)
	// 82CEB8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB8C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB8CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB8D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB8D4: 48000D65  bl 0x82cec638
	ctx.lr = 0x82CEB8D8;
	sub_82CEC638(ctx, base);
	// 82CEB8D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB8DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB8E0: 394B5138  addi r10, r11, 0x5138
	ctx.r[10].s64 = ctx.r[11].s64 + 20792;
	// 82CEB8E4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEB8E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB8EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB8F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB900 size=80
    let mut pc: u32 = 0x82CEB900;
    'dispatch: loop {
        match pc {
            0x82CEB900 => {
    //   block [0x82CEB900..0x82CEB950)
	// 82CEB900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB90C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB918: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CEB91C: 480009B5  bl 0x82cec2d0
	ctx.lr = 0x82CEB920;
	sub_82CEC2D0(ctx, base);
	// 82CEB920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB924: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CEB928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB92C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEB930: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB934: 4E800421  bctrl
	ctx.lr = 0x82CEB938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB93C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB944: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB950 size=180
    let mut pc: u32 = 0x82CEB950;
    'dispatch: loop {
        match pc {
            0x82CEB950 => {
    //   block [0x82CEB950..0x82CEB9EC)
	// 82CEB950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB960: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB964: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB968: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82CEB96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB970: 48000979  bl 0x82cec2e8
	ctx.lr = 0x82CEB974;
	sub_82CEC2E8(ctx, base);
	// 82CEB974: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB978: 41980074  blt cr6, 0x82ceb9ec
	if ctx.cr[6].lt {
	pc = 0x82CEB9EC; continue 'dispatch;
	}
	// 82CEB97C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82CEB980: 893F0019  lbz r9, 0x19(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82CEB984: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB988: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CEB98C: 3CE08333  lis r7, -0x7ccd
	ctx.r[7].s64 = -2093809664;
	// 82CEB990: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEB994: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82CEB998: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82CEB99C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82CEB9A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82CEB9A4: 99610069  stb r11, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82CEB9A8: 99210068  stb r9, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u8 ) };
	// 82CEB9AC: 99010060  stb r8, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u8 ) };
	// 82CEB9B0: 816772AC  lwz r11, 0x72ac(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEB9B4: 806B003C  lwz r3, 0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEB9B8: 4BFF6919  bl 0x82ce22d0
	ctx.lr = 0x82CEB9BC;
	sub_82CE22D0(ctx, base);
	// 82CEB9BC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB9C0: 4198002C  blt cr6, 0x82ceb9ec
	if ctx.cr[6].lt {
	pc = 0x82CEB9EC; continue 'dispatch;
	}
	// 82CEB9C4: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEB9C8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB9CC: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 82CEB9D0: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEB9D4: 7D4B51D6  mullw r10, r11, r10
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CEB9D8: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CEB9DC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82CEB9E0: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEB9E4: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEB9E8: 90DE0000  stw r6, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	pc = 0x82CEB9EC; continue 'dispatch;
            }
            0x82CEB9EC => {
    //   block [0x82CEB9EC..0x82CEBA04)
	// 82CEB9EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEB9F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB9F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB9F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB9FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEBA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBA08 size=276
    let mut pc: u32 = 0x82CEBA08;
    'dispatch: loop {
        match pc {
            0x82CEBA08 => {
    //   block [0x82CEBA08..0x82CEBA70)
	// 82CEBA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBA0C: 4BFBD9FD  bl 0x82ca9408
	ctx.lr = 0x82CEBA10;
	sub_82CA93D0(ctx, base);
	// 82CEBA10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBA14: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CEBA18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEBA1C: 897C0018  lbz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEBA20: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82CEBA24: 4800148D  bl 0x82ceceb0
	ctx.lr = 0x82CEBA28;
	sub_82CECEB0(ctx, base);
	// 82CEBA28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBA2C: 419800D8  blt cr6, 0x82cebb04
	if ctx.cr[6].lt {
	pc = 0x82CEBB04; continue 'dispatch;
	}
	// 82CEBA30: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBA34: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEBA38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBA3C: 419A0034  beq cr6, 0x82ceba70
	if ctx.cr[6].eq {
	pc = 0x82CEBA70; continue 'dispatch;
	}
	// 82CEBA40: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEBA44: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CEBA48: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEBA4C: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CEBA50: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBA54: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEBA58: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEBA5C: 4E800421  bctrl
	ctx.lr = 0x82CEBA60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBA60: 907F0048  stw r3, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82CEBA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEBA68: 419A00A4  beq cr6, 0x82cebb0c
	if ctx.cr[6].eq {
	pc = 0x82CEBB0C; continue 'dispatch;
	}
	// 82CEBA6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            0x82CEBA70 => {
    //   block [0x82CEBA70..0x82CEBAAC)
	// 82CEBA70: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBA74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBA78: 419A006C  beq cr6, 0x82cebae4
	if ctx.cr[6].eq {
	pc = 0x82CEBAE4; continue 'dispatch;
	}
	// 82CEBA7C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82CEBA80: 893C0019  lbz r9, 0x19(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 82CEBA84: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CEBA88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBA8C: FBCA0000  std r30, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 82CEBA90: FBCA0008  std r30, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[30].u64 ) };
	// 82CEBA94: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82CEBA98: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 82CEBA9C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82CEBAA0: 9BC10059  stb r30, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[30].u8 ) };
	// 82CEBAA4: 419A0040  beq cr6, 0x82cebae4
	if ctx.cr[6].eq {
	pc = 0x82CEBAE4; continue 'dispatch;
	}
	// 82CEBAA8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82CEBAAC; continue 'dispatch;
            }
            0x82CEBAAC => {
    //   block [0x82CEBAAC..0x82CEBAE4)
	// 82CEBAAC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBAB0: 41980054  blt cr6, 0x82cebb04
	if ctx.cr[6].lt {
	pc = 0x82CEBB04; continue 'dispatch;
	}
	// 82CEBAB4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBAB8: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82CEBABC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEBAC0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82CEBAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBAC8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82CEBACC: 480009D5  bl 0x82cec4a0
	ctx.lr = 0x82CEBAD0;
	sub_82CEC4A0(ctx, base);
	// 82CEBAD0: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBAD4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82CEBAD8: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82CEBADC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEBAE0: 4198FFCC  blt cr6, 0x82cebaac
	if ctx.cr[6].lt {
	pc = 0x82CEBAAC; continue 'dispatch;
	}
	pc = 0x82CEBAE4; continue 'dispatch;
            }
            0x82CEBAE4 => {
    //   block [0x82CEBAE4..0x82CEBB04)
	// 82CEBAE4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBAE8: 4198001C  blt cr6, 0x82cebb04
	if ctx.cr[6].lt {
	pc = 0x82CEBB04; continue 'dispatch;
	}
	// 82CEBAEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBAF4: 809C001C  lwz r4, 0x1c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CEBAF8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEBAFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBB00: 4E800421  bctrl
	ctx.lr = 0x82CEBB04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEBB04 => {
    //   block [0x82CEBB04..0x82CEBB0C)
	// 82CEBB04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEBB08: 4BFBD950  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CEBB0C => {
    //   block [0x82CEBB0C..0x82CEBB1C)
	// 82CEBB0C: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEBB10: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEBB14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEBB18: 4BFBD940  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBB20 size=192
    let mut pc: u32 = 0x82CEBB20;
    'dispatch: loop {
        match pc {
            0x82CEBB20 => {
    //   block [0x82CEBB20..0x82CEBB48)
	// 82CEBB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBB24: 4BFBD8E9  bl 0x82ca940c
	ctx.lr = 0x82CEBB28;
	sub_82CA93D0(ctx, base);
	// 82CEBB28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBB2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEBB30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEBB34: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CEBB38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CEBB3C: 409A000C  bne cr6, 0x82cebb48
	if !ctx.cr[6].eq {
	pc = 0x82CEBB48; continue 'dispatch;
	}
	// 82CEBB40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEBB44: 3BEB5194  addi r31, r11, 0x5194
	ctx.r[31].s64 = ctx.r[11].s64 + 20884;
	pc = 0x82CEBB48; continue 'dispatch;
            }
            0x82CEBB48 => {
    //   block [0x82CEBB48..0x82CEBB5C)
	// 82CEBB48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBB50: 419A000C  beq cr6, 0x82cebb5c
	if ctx.cr[6].eq {
	pc = 0x82CEBB5C; continue 'dispatch;
	}
	// 82CEBB54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEBB58: 48000014  b 0x82cebb6c
	pc = 0x82CEBB6C; continue 'dispatch;
            }
            0x82CEBB5C => {
    //   block [0x82CEBB5C..0x82CEBB6C)
	// 82CEBB5C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEBB60: 816B72AC  lwz r11, 0x72ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEBB64: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82CEBB68: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82CEBB6C; continue 'dispatch;
            }
            0x82CEBB6C => {
    //   block [0x82CEBB6C..0x82CEBBC0)
	// 82CEBB6C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB74: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBB78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBB7C: 4E800421  bctrl
	ctx.lr = 0x82CEBB80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBB80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBB88: 409A0038  bne cr6, 0x82cebbc0
	if !ctx.cr[6].eq {
	pc = 0x82CEBBC0; continue 'dispatch;
	}
	// 82CEBB8C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEBB94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB98: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82CEBB9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBBA0: 4E800421  bctrl
	ctx.lr = 0x82CEBBA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBBA4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBBA8: 41980030  blt cr6, 0x82cebbd8
	if ctx.cr[6].lt {
	pc = 0x82CEBBD8; continue 'dispatch;
	}
	// 82CEBBAC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82CEBBB0: 88810051  lbz r4, 0x51(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82CEBBB4: 887D0035  lbz r3, 0x35(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(53 as u32) ) } as u64;
	// 82CEBBB8: 4BFED301  bl 0x82cd8eb8
	ctx.lr = 0x82CEBBBC;
	sub_82CD8EB8(ctx, base);
	// 82CEBBBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            0x82CEBBC0 => {
    //   block [0x82CEBBC0..0x82CEBBD8)
	// 82CEBBC0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBBC4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82CEBBC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBBCC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEBBD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBBD4: 4E800421  bctrl
	ctx.lr = 0x82CEBBD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEBBD8 => {
    //   block [0x82CEBBD8..0x82CEBBE0)
	// 82CEBBD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBBDC: 4BFBD880  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBBE0 size=96
    let mut pc: u32 = 0x82CEBBE0;
    'dispatch: loop {
        match pc {
            0x82CEBBE0 => {
    //   block [0x82CEBBE0..0x82CEBC08)
	// 82CEBBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBBE4: 4BFBD825  bl 0x82ca9408
	ctx.lr = 0x82CEBBE8;
	sub_82CA93D0(ctx, base);
	// 82CEBBE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBBEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEBBF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82CEBBF4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82CEBBF8: 897E0045  lbz r11, 0x45(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBBFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBC00: 419A0034  beq cr6, 0x82cebc34
	if ctx.cr[6].eq {
	pc = 0x82CEBC34; continue 'dispatch;
	}
	// 82CEBC04: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x82CEBC08; continue 'dispatch;
            }
            0x82CEBC08 => {
    //   block [0x82CEBC08..0x82CEBC34)
	// 82CEBC08: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBC0C: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CEBC10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBC14: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEBC18: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEBC1C: 4E800421  bctrl
	ctx.lr = 0x82CEBC20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBC20: 891E0045  lbz r8, 0x45(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBC24: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82CEBC28: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82CEBC2C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEBC30: 4198FFD8  blt cr6, 0x82cebc08
	if ctx.cr[6].lt {
	pc = 0x82CEBC08; continue 'dispatch;
	}
            }
            0x82CEBC34 => {
    //   block [0x82CEBC34..0x82CEBC40)
	// 82CEBC34: 9B9E0045  stb r28, 0x45(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(69 as u32), ctx.r[28].u8 ) };
	// 82CEBC38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBC3C: 4BFBD81C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBC40 size=152
    let mut pc: u32 = 0x82CEBC40;
    'dispatch: loop {
        match pc {
            0x82CEBC40 => {
    //   block [0x82CEBC40..0x82CEBC78)
	// 82CEBC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBC44: 4BFBD7C1  bl 0x82ca9404
	ctx.lr = 0x82CEBC48;
	sub_82CA93D0(ctx, base);
	// 82CEBC48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBC4C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEBC50: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82CEBC54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEBC58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEBC5C: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEBC60: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBC64: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 82CEBC68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEBC6C: 553B07FE  clrlwi r27, r9, 0x1f
	ctx.r[27].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82CEBC70: 419A0060  beq cr6, 0x82cebcd0
	if ctx.cr[6].eq {
	pc = 0x82CEBCD0; continue 'dispatch;
	}
	// 82CEBC74: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82CEBC78; continue 'dispatch;
            }
            0x82CEBC78 => {
    //   block [0x82CEBC78..0x82CEBCD0)
	// 82CEBC78: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBC7C: 41980054  blt cr6, 0x82cebcd0
	if ctx.cr[6].lt {
	pc = 0x82CEBCD0; continue 'dispatch;
	}
	// 82CEBC80: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBC84: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CEBC88: 813C0048  lwz r9, 0x48(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBC8C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEBC90: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBC94: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBC98: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CEBC9C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CEBCA0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEBCA4: 7D4B4A14  add r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CEBCA8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBCAC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBCB0: 81090038  lwz r8, 0x38(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEBCB4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEBCB8: 4E800421  bctrl
	ctx.lr = 0x82CEBCBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBCBC: 88FD0000  lbz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBCC0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82CEBCC4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82CEBCC8: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CEBCCC: 4198FFAC  blt cr6, 0x82cebc78
	if ctx.cr[6].lt {
	pc = 0x82CEBC78; continue 'dispatch;
	}
            }
            0x82CEBCD0 => {
    //   block [0x82CEBCD0..0x82CEBCD8)
	// 82CEBCD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBCD4: 4BFBD780  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBCD8 size=156
    let mut pc: u32 = 0x82CEBCD8;
    'dispatch: loop {
        match pc {
            0x82CEBCD8 => {
    //   block [0x82CEBCD8..0x82CEBD1C)
	// 82CEBCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBCDC: 4BFBD72D  bl 0x82ca9408
	ctx.lr = 0x82CEBCE0;
	sub_82CA93D0(ctx, base);
	// 82CEBCE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBCE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEBCE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEBCEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEBCF0: 394B5138  addi r10, r11, 0x5138
	ctx.r[10].s64 = ctx.r[11].s64 + 20792;
	// 82CEBCF4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEBCF8: 48000DF9  bl 0x82cecaf0
	ctx.lr = 0x82CEBCFC;
	sub_82CECAF0(ctx, base);
	// 82CEBCFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBD00: 4BFFFEE1  bl 0x82cebbe0
	ctx.lr = 0x82CEBD04;
	sub_82CEBBE0(ctx, base);
	// 82CEBD04: 893F0044  lbz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBD08: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82CEBD0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEBD10: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82CEBD14: 419A0050  beq cr6, 0x82cebd64
	if ctx.cr[6].eq {
	pc = 0x82CEBD64; continue 'dispatch;
	}
	// 82CEBD18: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82CEBD1C; continue 'dispatch;
            }
            0x82CEBD1C => {
    //   block [0x82CEBD1C..0x82CEBD50)
	// 82CEBD1C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBD20: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEBD24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBD28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEBD2C: 419A0024  beq cr6, 0x82cebd50
	if ctx.cr[6].eq {
	pc = 0x82CEBD50; continue 'dispatch;
	}
	// 82CEBD30: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82CEBD34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBD38: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBD3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBD40: 4E800421  bctrl
	ctx.lr = 0x82CEBD44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBD44: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBD48: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEBD4C: 93890004  stw r28, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
            }
            0x82CEBD50 => {
    //   block [0x82CEBD50..0x82CEBD64)
	// 82CEBD50: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBD54: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82CEBD58: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82CEBD5C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEBD60: 4198FFBC  blt cr6, 0x82cebd1c
	if ctx.cr[6].lt {
	pc = 0x82CEBD1C; continue 'dispatch;
	}
	pc = 0x82CEBD64; continue 'dispatch;
            }
            0x82CEBD64 => {
    //   block [0x82CEBD64..0x82CEBD74)
	// 82CEBD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBD68: 48000669  bl 0x82cec3d0
	ctx.lr = 0x82CEBD6C;
	sub_82CEC3D0(ctx, base);
	// 82CEBD6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBD70: 4BFBD6E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBD78 size=200
    let mut pc: u32 = 0x82CEBD78;
    'dispatch: loop {
        match pc {
            0x82CEBD78 => {
    //   block [0x82CEBD78..0x82CEBDB4)
	// 82CEBD78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBD7C: 4BFBD685  bl 0x82ca9400
	ctx.lr = 0x82CEBD80;
	sub_82CA93D0(ctx, base);
	// 82CEBD80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBD84: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEBD88: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CEBD8C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82CEBD90: 4BFFFE51  bl 0x82cebbe0
	ctx.lr = 0x82CEBD94;
	sub_82CEBBE0(ctx, base);
	// 82CEBD94: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CEBD98: 419A0074  beq cr6, 0x82cebe0c
	if ctx.cr[6].eq {
	pc = 0x82CEBE0C; continue 'dispatch;
	}
	// 82CEBD9C: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBDA0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82CEBDA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBDA8: 419A0050  beq cr6, 0x82cebdf8
	if ctx.cr[6].eq {
	pc = 0x82CEBDF8; continue 'dispatch;
	}
	// 82CEBDAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEBDB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82CEBDB4; continue 'dispatch;
            }
            0x82CEBDB4 => {
    //   block [0x82CEBDB4..0x82CEBDF8)
	// 82CEBDB4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82CEBDB8: 41980048  blt cr6, 0x82cebe00
	if ctx.cr[6].lt {
	pc = 0x82CEBE00; continue 'dispatch;
	}
	// 82CEBDBC: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBDC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEBDC4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBDC8: 7CAAFA14  add r5, r10, r31
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82CEBDCC: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEBDD0: 4BFFFD51  bl 0x82cebb20
	ctx.lr = 0x82CEBDD4;
	sub_82CEBB20(ctx, base);
	// 82CEBDD4: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBDD8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82CEBDDC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82CEBDE0: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82CEBDE4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82CEBDE8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEBDEC: 4198FFC8  blt cr6, 0x82cebdb4
	if ctx.cr[6].lt {
	pc = 0x82CEBDB4; continue 'dispatch;
	}
	// 82CEBDF0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82CEBDF4: 4198000C  blt cr6, 0x82cebe00
	if ctx.cr[6].lt {
	pc = 0x82CEBE00; continue 'dispatch;
	}
	pc = 0x82CEBDF8; continue 'dispatch;
            }
            0x82CEBDF8 => {
    //   block [0x82CEBDF8..0x82CEBE00)
	// 82CEBDF8: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBDFC: 997C0045  stb r11, 0x45(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(69 as u32), ctx.r[11].u8 ) };
	pc = 0x82CEBE00; continue 'dispatch;
            }
            0x82CEBE00 => {
    //   block [0x82CEBE00..0x82CEBE04)
	// 82CEBE00: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82CEBE04; continue 'dispatch;
            }
            0x82CEBE04 => {
    //   block [0x82CEBE04..0x82CEBE0C)
	// 82CEBE04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEBE08: 4BFBD648  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CEBE0C => {
    //   block [0x82CEBE0C..0x82CEBE40)
	// 82CEBE0C: 897C0044  lbz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBE14: 419AFFEC  beq cr6, 0x82cebe00
	if ctx.cr[6].eq {
	pc = 0x82CEBE00; continue 'dispatch;
	}
	// 82CEBE18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEBE1C: 80BC0048  lwz r5, 0x48(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBE20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEBE24: 4BFFFCFD  bl 0x82cebb20
	ctx.lr = 0x82CEBE28;
	sub_82CEBB20(ctx, base);
	// 82CEBE28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBE2C: 4198FFD8  blt cr6, 0x82cebe04
	if ctx.cr[6].lt {
	pc = 0x82CEBE04; continue 'dispatch;
	}
	// 82CEBE30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CEBE34: 997C0045  stb r11, 0x45(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(69 as u32), ctx.r[11].u8 ) };
	// 82CEBE38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEBE3C: 4BFBD614  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBE40 size=144
    let mut pc: u32 = 0x82CEBE40;
    'dispatch: loop {
        match pc {
            0x82CEBE40 => {
    //   block [0x82CEBE40..0x82CEBE6C)
	// 82CEBE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBE44: 4BFBD5C5  bl 0x82ca9408
	ctx.lr = 0x82CEBE48;
	sub_82CA93D0(ctx, base);
	// 82CEBE48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBE4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEBE50: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CEBE54: 48001195  bl 0x82cecfe8
	ctx.lr = 0x82CEBE58;
	sub_82CECFE8(ctx, base);
	// 82CEBE58: 897E0045  lbz r11, 0x45(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBE5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82CEBE60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBE64: 419A0064  beq cr6, 0x82cebec8
	if ctx.cr[6].eq {
	pc = 0x82CEBEC8; continue 'dispatch;
	}
	// 82CEBE68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82CEBE6C; continue 'dispatch;
            }
            0x82CEBE6C => {
    //   block [0x82CEBE6C..0x82CEBEC8)
	// 82CEBE6C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBE70: 41980058  blt cr6, 0x82cebec8
	if ctx.cr[6].lt {
	pc = 0x82CEBEC8; continue 'dispatch;
	}
	// 82CEBE74: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBE78: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CEBE7C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82CEBE80: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBE84: 81090048  lwz r8, 0x48(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBE88: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEBE8C: 4E800421  bctrl
	ctx.lr = 0x82CEBE90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBE90: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBE94: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82CEBE98: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBE9C: 7CEBFA14  add r7, r11, r31
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82CEBEA0: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBEA4: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBEA8: 81660018  lwz r11, 0x18(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEBEAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CEBEB0: 4E800421  bctrl
	ctx.lr = 0x82CEBEB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBEB4: 895E0045  lbz r10, 0x45(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBEB8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82CEBEBC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82CEBEC0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEBEC4: 4198FFA8  blt cr6, 0x82cebe6c
	if ctx.cr[6].lt {
	pc = 0x82CEBE6C; continue 'dispatch;
	}
            }
            0x82CEBEC8 => {
    //   block [0x82CEBEC8..0x82CEBED0)
	// 82CEBEC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBECC: 4BFBD58C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBED0 size=324
    let mut pc: u32 = 0x82CEBED0;
    'dispatch: loop {
        match pc {
            0x82CEBED0 => {
    //   block [0x82CEBED0..0x82CEBF0C)
	// 82CEBED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBED4: 4BFBD535  bl 0x82ca9408
	ctx.lr = 0x82CEBED8;
	sub_82CA93D0(ctx, base);
	// 82CEBED8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBEDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEBEE0: 485CE425  bl 0x832ba304
	ctx.lr = 0x82CEBEE4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEBEE4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEBEE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEBEEC: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEBEF0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEBEF4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBEF8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEBEFC: 419A0010  beq cr6, 0x82cebf0c
	if ctx.cr[6].eq {
	pc = 0x82CEBF0C; continue 'dispatch;
	}
	// 82CEBF00: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEBF04: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEBF08: 419A001C  beq cr6, 0x82cebf24
	if ctx.cr[6].eq {
	pc = 0x82CEBF24; continue 'dispatch;
	}
	pc = 0x82CEBF0C; continue 'dispatch;
            }
            0x82CEBF0C => {
    //   block [0x82CEBF0C..0x82CEBF24)
	// 82CEBF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBF10: 485CE3E5  bl 0x832ba2f4
	ctx.lr = 0x82CEBF14;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEBF14: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CEBF18: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBF1C: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEBF20: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82CEBF24; continue 'dispatch;
            }
            0x82CEBF24 => {
    //   block [0x82CEBF24..0x82CEBF60)
	// 82CEBF24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CEBF28: 397C0018  addi r11, r28, 0x18
	ctx.r[11].s64 = ctx.r[28].s64 + 24;
	// 82CEBF2C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEBF30: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEBF34: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEBF38: 419A0028  beq cr6, 0x82cebf60
	if ctx.cr[6].eq {
	pc = 0x82CEBF60; continue 'dispatch;
	}
	// 82CEBF3C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBF40: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEBF44: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBF48: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBF4C: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEBF50: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEBF54: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEBF58: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEBF5C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82CEBF60; continue 'dispatch;
            }
            0x82CEBF60 => {
    //   block [0x82CEBF60..0x82CEBFA4)
	// 82CEBF60: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CEBF64: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEBF68: 419A003C  beq cr6, 0x82cebfa4
	if ctx.cr[6].eq {
	pc = 0x82CEBFA4; continue 'dispatch;
	}
	// 82CEBF6C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEBF70: 409A0034  bne cr6, 0x82cebfa4
	if !ctx.cr[6].eq {
	pc = 0x82CEBFA4; continue 'dispatch;
	}
	// 82CEBF74: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEBF78: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEBF7C: 40820028  bne 0x82cebfa4
	if !ctx.cr[0].eq {
	pc = 0x82CEBFA4; continue 'dispatch;
	}
	// 82CEBF80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEBF84: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEBF88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEBF8C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEBF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBF94: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEBF98: 485CE39D  bl 0x832ba334
	ctx.lr = 0x82CEBF9C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEBF9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEBFA0: 485CE375  bl 0x832ba314
	ctx.lr = 0x82CEBFA4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEBFA4; continue 'dispatch;
            }
            0x82CEBFA4 => {
    //   block [0x82CEBFA4..0x82CEBFBC)
	// 82CEBFA4: 897C0045  lbz r11, 0x45(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBFA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEBFAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEBFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBFB4: 419A0058  beq cr6, 0x82cec00c
	if ctx.cr[6].eq {
	pc = 0x82CEC00C; continue 'dispatch;
	}
	// 82CEBFB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82CEBFBC; continue 'dispatch;
            }
            0x82CEBFBC => {
    //   block [0x82CEBFBC..0x82CEBFE4)
	// 82CEBFBC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBFC0: 4198004C  blt cr6, 0x82cec00c
	if ctx.cr[6].lt {
	pc = 0x82CEC00C; continue 'dispatch;
	}
	// 82CEBFC4: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBFC8: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CEBFCC: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEBFD0: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEBFD4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82CEBFD8: 4182000C  beq 0x82cebfe4
	if ctx.cr[0].eq {
	pc = 0x82CEBFE4; continue 'dispatch;
	}
	// 82CEBFDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEBFE0: 48000018  b 0x82cebff8
	pc = 0x82CEBFF8; continue 'dispatch;
            }
            0x82CEBFE4 => {
    //   block [0x82CEBFE4..0x82CEBFF8)
	// 82CEBFE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBFE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEBFEC: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEBFF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBFF4: 4E800421  bctrl
	ctx.lr = 0x82CEBFF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEBFF8 => {
    //   block [0x82CEBFF8..0x82CEC00C)
	// 82CEBFF8: 897C0045  lbz r11, 0x45(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBFFC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82CEC000: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82CEC004: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEC008: 4198FFB4  blt cr6, 0x82cebfbc
	if ctx.cr[6].lt {
	pc = 0x82CEBFBC; continue 'dispatch;
	}
	pc = 0x82CEC00C; continue 'dispatch;
            }
            0x82CEC00C => {
    //   block [0x82CEC00C..0x82CEC014)
	// 82CEC00C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEC010: 4BFBD448  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC018 size=92
    let mut pc: u32 = 0x82CEC018;
    'dispatch: loop {
        match pc {
            0x82CEC018 => {
    //   block [0x82CEC018..0x82CEC058)
	// 82CEC018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC01C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEC024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEC028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC02C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC030: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEC034: 4BFFFCA5  bl 0x82cebcd8
	ctx.lr = 0x82CEC038;
	sub_82CEBCD8(ctx, base);
	// 82CEC038: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CEC03C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC040: 419A0018  beq cr6, 0x82cec058
	if ctx.cr[6].eq {
	pc = 0x82CEC058; continue 'dispatch;
	}
	// 82CEC044: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC048: 3CA06182  lis r5, 0x6182
	ctx.r[5].s64 = 1635909632;
	// 82CEC04C: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEC050: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEC054: 4BFF47D5  bl 0x82ce0828
	ctx.lr = 0x82CEC058;
	sub_82CE0828(ctx, base);
	pc = 0x82CEC058; continue 'dispatch;
            }
            0x82CEC058 => {
    //   block [0x82CEC058..0x82CEC074)
	// 82CEC058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC05C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC068: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEC06C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEC070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC078 size=388
    let mut pc: u32 = 0x82CEC078;
    'dispatch: loop {
        match pc {
            0x82CEC078 => {
    //   block [0x82CEC078..0x82CEC0A0)
	// 82CEC078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC07C: 4BFBD389  bl 0x82ca9404
	ctx.lr = 0x82CEC080;
	sub_82CA93D0(ctx, base);
	// 82CEC080: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC084: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEC088: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC08C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEC090: 897D0045  lbz r11, 0x45(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEC094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC098: 419A0050  beq cr6, 0x82cec0e8
	if ctx.cr[6].eq {
	pc = 0x82CEC0E8; continue 'dispatch;
	}
	// 82CEC09C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82CEC0A0; continue 'dispatch;
            }
            0x82CEC0A0 => {
    //   block [0x82CEC0A0..0x82CEC0E8)
	// 82CEC0A0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC0A4: 41980150  blt cr6, 0x82cec1f4
	if ctx.cr[6].lt {
	pc = 0x82CEC1F4; continue 'dispatch;
	}
	// 82CEC0A8: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEC0AC: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82CEC0B0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEC0B4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82CEC0B8: 91430028  stw r10, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82CEC0BC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC0C0: 81090038  lwz r8, 0x38(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEC0C4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEC0C8: 4E800421  bctrl
	ctx.lr = 0x82CEC0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC0CC: 88FD0045  lbz r7, 0x45(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEC0D0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82CEC0D4: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82CEC0D8: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CEC0DC: 4198FFC4  blt cr6, 0x82cec0a0
	if ctx.cr[6].lt {
	pc = 0x82CEC0A0; continue 'dispatch;
	}
	// 82CEC0E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC0E4: 41980110  blt cr6, 0x82cec1f4
	if ctx.cr[6].lt {
	pc = 0x82CEC1F4; continue 'dispatch;
	}
            }
            0x82CEC0E8 => {
    //   block [0x82CEC0E8..0x82CEC12C)
	// 82CEC0E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC0EC: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82CEC0F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEC0F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEC0F8: 83EA72AC  lwz r31, 0x72ac(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEC0FC: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEC100: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEC104: 4E800421  bctrl
	ctx.lr = 0x82CEC108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC108: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC10C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CEC110: 4198001C  blt cr6, 0x82cec12c
	if ctx.cr[6].lt {
	pc = 0x82CEC12C; continue 'dispatch;
	}
	// 82CEC114: 409A00DC  bne cr6, 0x82cec1f0
	if !ctx.cr[6].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC118: 895D004C  lbz r10, 0x4c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CEC11C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82CEC120: 1D4A002C  mulli r10, r10, 0x2c
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 44 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CEC124: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CEC128: 48000008  b 0x82cec130
	pc = 0x82CEC130; continue 'dispatch;
            }
            0x82CEC12C => {
    //   block [0x82CEC12C..0x82CEC130)
	// 82CEC12C: 3B7F0050  addi r27, r31, 0x50
	ctx.r[27].s64 = ctx.r[31].s64 + 80;
	pc = 0x82CEC130; continue 'dispatch;
            }
            0x82CEC130 => {
    //   block [0x82CEC130..0x82CEC164)
	// 82CEC130: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CEC134: 419A00BC  beq cr6, 0x82cec1f0
	if ctx.cr[6].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC138: 485CE1CD  bl 0x832ba304
	ctx.lr = 0x82CEC13C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEC13C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC140: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEC144: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEC148: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEC14C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC150: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC154: 419A0010  beq cr6, 0x82cec164
	if ctx.cr[6].eq {
	pc = 0x82CEC164; continue 'dispatch;
	}
	// 82CEC158: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC15C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC160: 419A0018  beq cr6, 0x82cec178
	if ctx.cr[6].eq {
	pc = 0x82CEC178; continue 'dispatch;
	}
	pc = 0x82CEC164; continue 'dispatch;
            }
            0x82CEC164 => {
    //   block [0x82CEC164..0x82CEC178)
	// 82CEC164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC168: 485CE18D  bl 0x832ba2f4
	ctx.lr = 0x82CEC16C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEC16C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC170: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEC174: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	pc = 0x82CEC178; continue 'dispatch;
            }
            0x82CEC178 => {
    //   block [0x82CEC178..0x82CEC1F0)
	// 82CEC178: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEC17C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEC180: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC184: 813B0028  lwz r9, 0x28(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEC188: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC18C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82CEC190: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEC194: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC198: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEC19C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC1A0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC1A4: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEC1A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC1AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC1B0: 419A0040  beq cr6, 0x82cec1f0
	if ctx.cr[6].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC1B4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC1B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEC1BC: 409A0034  bne cr6, 0x82cec1f0
	if !ctx.cr[6].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC1C0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC1C4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC1C8: 40820028  bne 0x82cec1f0
	if !ctx.cr[0].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC1CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEC1D0: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC1D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEC1D8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEC1DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC1E0: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEC1E4: 485CE151  bl 0x832ba334
	ctx.lr = 0x82CEC1E8;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEC1E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEC1EC: 485CE129  bl 0x832ba314
	ctx.lr = 0x82CEC1F0;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CEC1F0; continue 'dispatch;
            }
            0x82CEC1F0 => {
    //   block [0x82CEC1F0..0x82CEC1F4)
	// 82CEC1F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82CEC1F4; continue 'dispatch;
            }
            0x82CEC1F4 => {
    //   block [0x82CEC1F4..0x82CEC1FC)
	// 82CEC1F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEC1F8: 4BFBD25C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC200 size=208
    let mut pc: u32 = 0x82CEC200;
    'dispatch: loop {
        match pc {
            0x82CEC200 => {
    //   block [0x82CEC200..0x82CEC250)
	// 82CEC200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEC20C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC214: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC218: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEC21C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC220: 4E800421  bctrl
	ctx.lr = 0x82CEC224;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC224: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82CEC228: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82CEC22C: 4BC11275  bl 0x828fd4a0
	ctx.lr = 0x82CEC230;
	sub_828FD4A0(ctx, base);
	// 82CEC230: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82CEC234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC238: 419A0018  beq cr6, 0x82cec250
	if ctx.cr[6].eq {
	pc = 0x82CEC250; continue 'dispatch;
	}
	// 82CEC23C: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CEC240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CEC244: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CEC248: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CEC24C: 4E800421  bctrl
	ctx.lr = 0x82CEC250;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEC250 => {
    //   block [0x82CEC250..0x82CEC278)
	// 82CEC250: 897F003D  lbz r11, 0x3d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEC254: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEC258: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC25C: 419A001C  beq cr6, 0x82cec278
	if ctx.cr[6].eq {
	pc = 0x82CEC278; continue 'dispatch;
	}
	// 82CEC260: A17F0040  lhz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82CEC264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC268: 419A004C  beq cr6, 0x82cec2b4
	if ctx.cr[6].eq {
	pc = 0x82CEC2B4; continue 'dispatch;
	}
	// 82CEC26C: 3D6B0001  addis r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 65536;
	// 82CEC270: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82CEC274: B17F0040  sth r11, 0x40(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u16 ) };
	pc = 0x82CEC278; continue 'dispatch;
            }
            0x82CEC278 => {
    //   block [0x82CEC278..0x82CEC290)
	// 82CEC278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC27C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82CEC280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC284: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEC288: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC28C: 4E800421  bctrl
	ctx.lr = 0x82CEC290;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEC290 => {
    //   block [0x82CEC290..0x82CEC2B4)
	// 82CEC290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC294: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82CEC298: 4BC11209  bl 0x828fd4a0
	ctx.lr = 0x82CEC29C;
	sub_828FD4A0(ctx, base);
	// 82CEC29C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC2A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC2A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC2A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC2AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEC2B0: 4E800020  blr
	return;
            }
            0x82CEC2B4 => {
    //   block [0x82CEC2B4..0x82CEC2D0)
	// 82CEC2B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC2B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEC2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC2C0: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC2C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC2C8: 4E800421  bctrl
	ctx.lr = 0x82CEC2CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC2CC: 4BFFFFC4  b 0x82cec290
	pc = 0x82CEC290; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC2D0 size=20
    let mut pc: u32 = 0x82CEC2D0;
    'dispatch: loop {
        match pc {
            0x82CEC2D0 => {
    //   block [0x82CEC2D0..0x82CEC2E4)
	// 82CEC2D0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC2D4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82CEC2D8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC2DC: 91430038  stw r10, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82CEC2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC2E8 size=228
    let mut pc: u32 = 0x82CEC2E8;
    'dispatch: loop {
        match pc {
            0x82CEC2E8 => {
    //   block [0x82CEC2E8..0x82CEC35C)
	// 82CEC2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC2EC: 4BFBD115  bl 0x82ca9400
	ctx.lr = 0x82CEC2F0;
	sub_82CA93D0(ctx, base);
	// 82CEC2F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC2F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEC2F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEC2FC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82CEC300: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82CEC304: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82CEC308: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC30C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC314: 409A0048  bne cr6, 0x82cec35c
	if !ctx.cr[6].eq {
	pc = 0x82CEC35C; continue 'dispatch;
	}
	// 82CEC318: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82CEC31C: 895C0001  lbz r10, 1(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CEC320: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82CEC324: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEC328: 6128BB80  ori r8, r9, 0xbb80
	ctx.r[8].u64 = ctx.r[9].u64 | 48000;
	// 82CEC32C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82CEC330: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82CEC334: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82CEC338: 93EB0010  stw r31, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82CEC33C: 9BE10064  stb r31, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u8 ) };
	// 82CEC340: 99410065  stb r10, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[10].u8 ) };
	// 82CEC344: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82CEC348: 9BE10060  stb r31, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	// 82CEC34C: 4BFF24DD  bl 0x82cde828
	ctx.lr = 0x82CEC350;
	sub_82CDE828(ctx, base);
	// 82CEC350: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC354: 41980070  blt cr6, 0x82cec3c4
	if ctx.cr[6].lt {
	pc = 0x82CEC3C4; continue 'dispatch;
	}
	// 82CEC358: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82CEC35C; continue 'dispatch;
            }
            0x82CEC35C => {
    //   block [0x82CEC35C..0x82CEC378)
	// 82CEC35C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC364: 419A0054  beq cr6, 0x82cec3b8
	if ctx.cr[6].eq {
	pc = 0x82CEC3B8; continue 'dispatch;
	}
	// 82CEC368: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC36C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC370: 419A0048  beq cr6, 0x82cec3b8
	if ctx.cr[6].eq {
	pc = 0x82CEC3B8; continue 'dispatch;
	}
	// 82CEC374: 3F608333  lis r27, -0x7ccd
	ctx.r[27].s64 = -2093809664;
	pc = 0x82CEC378; continue 'dispatch;
            }
            0x82CEC378 => {
    //   block [0x82CEC378..0x82CEC3B8)
	// 82CEC378: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC37C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEC380: 817B72AC  lwz r11, 0x72ac(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEC384: 7C8AF82E  lwzx r4, r10, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CEC388: 806B003C  lwz r3, 0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC38C: 4BFF5F45  bl 0x82ce22d0
	ctx.lr = 0x82CEC390;
	sub_82CE22D0(ctx, base);
	// 82CEC390: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC394: 41980030  blt cr6, 0x82cec3c4
	if ctx.cr[6].lt {
	pc = 0x82CEC3C4; continue 'dispatch;
	}
	// 82CEC398: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC39C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82CEC3A0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC3A4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82CEC3A8: 7FAAEA14  add r29, r10, r29
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82CEC3AC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC3B0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC3B4: 4198FFC4  blt cr6, 0x82cec378
	if ctx.cr[6].lt {
	pc = 0x82CEC378; continue 'dispatch;
	}
	pc = 0x82CEC3B8; continue 'dispatch;
            }
            0x82CEC3B8 => {
    //   block [0x82CEC3B8..0x82CEC3C4)
	// 82CEC3B8: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC3BC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82CEC3C0: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82CEC3C4; continue 'dispatch;
            }
            0x82CEC3C4 => {
    //   block [0x82CEC3C4..0x82CEC3CC)
	// 82CEC3C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CEC3C8: 4BFBD088  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC3D0 size=204
    let mut pc: u32 = 0x82CEC3D0;
    'dispatch: loop {
        match pc {
            0x82CEC3D0 => {
    //   block [0x82CEC3D0..0x82CEC400)
	// 82CEC3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC3D4: 4BFBD035  bl 0x82ca9408
	ctx.lr = 0x82CEC3D8;
	sub_82CA93D0(ctx, base);
	// 82CEC3D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC3DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC3E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEC3E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82CEC3E8: 392B51A0  addi r9, r11, 0x51a0
	ctx.r[9].s64 = ctx.r[11].s64 + 20896;
	// 82CEC3EC: 895F003C  lbz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC3F0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEC3F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC3F8: 419A0050  beq cr6, 0x82cec448
	if ctx.cr[6].eq {
	pc = 0x82CEC448; continue 'dispatch;
	}
	// 82CEC3FC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x82CEC400; continue 'dispatch;
            }
            0x82CEC400 => {
    //   block [0x82CEC400..0x82CEC430)
	// 82CEC400: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC404: 57BE1838  slwi r30, r29, 3
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82CEC408: 7D7E502E  lwzx r11, r30, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEC40C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC410: 419A0020  beq cr6, 0x82cec430
	if ctx.cr[6].eq {
	pc = 0x82CEC430; continue 'dispatch;
	}
	// 82CEC414: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC418: 7C7E502E  lwzx r3, r30, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEC41C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC420: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC424: 4E800421  bctrl
	ctx.lr = 0x82CEC428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC428: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC42C: 7F9E492E  stwx r28, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[28].u32) };
            }
            0x82CEC430 => {
    //   block [0x82CEC430..0x82CEC448)
	// 82CEC430: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82CEC434: 895F003C  lbz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC438: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CEC43C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82CEC440: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC444: 4198FFBC  blt cr6, 0x82cec400
	if ctx.cr[6].lt {
	pc = 0x82CEC400; continue 'dispatch;
	}
	pc = 0x82CEC448; continue 'dispatch;
            }
            0x82CEC448 => {
    //   block [0x82CEC448..0x82CEC45C)
	// 82CEC448: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEC44C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEC450: 419A000C  beq cr6, 0x82cec45c
	if ctx.cr[6].eq {
	pc = 0x82CEC45C; continue 'dispatch;
	}
	// 82CEC454: 4BFF2115  bl 0x82cde568
	ctx.lr = 0x82CEC458;
	sub_82CDE568(ctx, base);
	// 82CEC458: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	pc = 0x82CEC45C; continue 'dispatch;
            }
            0x82CEC45C => {
    //   block [0x82CEC45C..0x82CEC488)
	// 82CEC45C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEC460: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC464: 394B3FAC  addi r10, r11, 0x3fac
	ctx.r[10].s64 = ctx.r[11].s64 + 16300;
	// 82CEC468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEC46C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEC470: 419A0018  beq cr6, 0x82cec488
	if ctx.cr[6].eq {
	pc = 0x82CEC488; continue 'dispatch;
	}
	// 82CEC474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC478: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC47C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC480: 4E800421  bctrl
	ctx.lr = 0x82CEC484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC484: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
            }
            0x82CEC488 => {
    //   block [0x82CEC488..0x82CEC49C)
	// 82CEC488: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEC48C: 394B3DD0  addi r10, r11, 0x3dd0
	ctx.r[10].s64 = ctx.r[11].s64 + 15824;
	// 82CEC490: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEC494: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEC498: 4BFBCFC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC4A0 size=152
    let mut pc: u32 = 0x82CEC4A0;
    'dispatch: loop {
        match pc {
            0x82CEC4A0 => {
    //   block [0x82CEC4A0..0x82CEC530)
	// 82CEC4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC4A4: 4BFBCF69  bl 0x82ca940c
	ctx.lr = 0x82CEC4A8;
	sub_82CA93D0(ctx, base);
	// 82CEC4A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC4AC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC4B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEC4B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEC4B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEC4BC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82CEC4C0: 816B72AC  lwz r11, 0x72ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEC4C4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82CEC4C8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82CEC4CC: 806B003C  lwz r3, 0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC4D0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEC4D4: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC4D8: 4BFF5E19  bl 0x82ce22f0
	ctx.lr = 0x82CEC4DC;
	sub_82CE22F0(ctx, base);
	// 82CEC4DC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC4E0: 41980050  blt cr6, 0x82cec530
	if ctx.cr[6].lt {
	pc = 0x82CEC530; continue 'dispatch;
	}
	// 82CEC4E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC4E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEC4EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC4F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC4F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC4F8: 4E800421  bctrl
	ctx.lr = 0x82CEC4FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC4FC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC500: 41980030  blt cr6, 0x82cec530
	if ctx.cr[6].lt {
	pc = 0x82CEC530; continue 'dispatch;
	}
	// 82CEC504: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC508: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CEC50C: A1610052  lhz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82CEC510: 9BBF0004  stb r29, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u8 ) };
	// 82CEC514: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82CEC518: 993F0005  stb r9, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[9].u8 ) };
	// 82CEC51C: 995F0006  stb r10, 6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u8 ) };
	// 82CEC520: A0FE003E  lhz r7, 0x3e(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(62 as u32) ) } as u64;
	// 82CEC524: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CEC528: 40990008  ble cr6, 0x82cec530
	if !ctx.cr[6].gt {
	pc = 0x82CEC530; continue 'dispatch;
	}
	// 82CEC52C: B17E003E  sth r11, 0x3e(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(62 as u32), ctx.r[11].u16 ) };
            }
            0x82CEC530 => {
    //   block [0x82CEC530..0x82CEC538)
	// 82CEC530: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEC534: 4BFBCF28  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC538 size=36
    let mut pc: u32 = 0x82CEC538;
    'dispatch: loop {
        match pc {
            0x82CEC538 => {
    //   block [0x82CEC538..0x82CEC55C)
	// 82CEC538: 8943003C  lbz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC53C: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CEC540: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82CEC544: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82CEC548: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC54C: 41980010  blt cr6, 0x82cec55c
	if ctx.cr[6].lt {
		sub_82CEC55C(ctx, base);
		return;
	}
	// 82CEC550: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEC554: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82CEC558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC55C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC55C size=36
    let mut pc: u32 = 0x82CEC55C;
    'dispatch: loop {
        match pc {
            0x82CEC55C => {
    //   block [0x82CEC55C..0x82CEC580)
	// 82CEC55C: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC560: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC564: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82CEC568: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82CEC56C: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEC570: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC574: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC578: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC57C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC580 size=36
    let mut pc: u32 = 0x82CEC580;
    'dispatch: loop {
        match pc {
            0x82CEC580 => {
    //   block [0x82CEC580..0x82CEC5A4)
	// 82CEC580: 8943003C  lbz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC584: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CEC588: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82CEC58C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82CEC590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC594: 41980010  blt cr6, 0x82cec5a4
	if ctx.cr[6].lt {
		sub_82CEC5A4(ctx, base);
		return;
	}
	// 82CEC598: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEC59C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82CEC5A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC5A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC5A4 size=36
    let mut pc: u32 = 0x82CEC5A4;
    'dispatch: loop {
        match pc {
            0x82CEC5A4 => {
    //   block [0x82CEC5A4..0x82CEC5C8)
	// 82CEC5A4: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC5A8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC5AC: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82CEC5B0: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82CEC5B4: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEC5B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC5BC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEC5C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC5C4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC5C8 size=28
    let mut pc: u32 = 0x82CEC5C8;
    'dispatch: loop {
        match pc {
            0x82CEC5C8 => {
    //   block [0x82CEC5C8..0x82CEC5E4)
	// 82CEC5C8: 8943003C  lbz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC5CC: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CEC5D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC5D4: 41980010  blt cr6, 0x82cec5e4
	if ctx.cr[6].lt {
		sub_82CEC5E4(ctx, base);
		return;
	}
	// 82CEC5D8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEC5DC: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82CEC5E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC5E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC5E4 size=28
    let mut pc: u32 = 0x82CEC5E4;
    'dispatch: loop {
        match pc {
            0x82CEC5E4 => {
    //   block [0x82CEC5E4..0x82CEC600)
	// 82CEC5E4: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC5E8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC5EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC5F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEC5F4: 896B0005  lbz r11, 5(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 82CEC5F8: 99650000  stb r11, 0(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82CEC5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC600 size=28
    let mut pc: u32 = 0x82CEC600;
    'dispatch: loop {
        match pc {
            0x82CEC600 => {
    //   block [0x82CEC600..0x82CEC61C)
	// 82CEC600: 8943003C  lbz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC604: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CEC608: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC60C: 41980010  blt cr6, 0x82cec61c
	if ctx.cr[6].lt {
		sub_82CEC61C(ctx, base);
		return;
	}
	// 82CEC610: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEC614: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82CEC618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC61C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC61C size=24
    let mut pc: u32 = 0x82CEC61C;
    'dispatch: loop {
        match pc {
            0x82CEC61C => {
    //   block [0x82CEC61C..0x82CEC634)
	// 82CEC61C: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC620: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC624: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC628: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEC62C: 98AB0005  stb r5, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[5].u8 ) };
	// 82CEC630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC638 size=156
    let mut pc: u32 = 0x82CEC638;
    'dispatch: loop {
        match pc {
            0x82CEC638 => {
    //   block [0x82CEC638..0x82CEC688)
	// 82CEC638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEC644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEC648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC64C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC650: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEC654: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82CEC658: 392B3FAC  addi r9, r11, 0x3fac
	ctx.r[9].s64 = ctx.r[11].s64 + 16300;
	// 82CEC65C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CEC660: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82CEC664: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CEC668: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEC66C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEC670: 419A0018  beq cr6, 0x82cec688
	if ctx.cr[6].eq {
	pc = 0x82CEC688; continue 'dispatch;
	}
	// 82CEC674: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC678: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82CEC67C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC680: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC684: 4E800421  bctrl
	ctx.lr = 0x82CEC688;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CEC688 => {
    //   block [0x82CEC688..0x82CEC6D4)
	// 82CEC688: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEC68C: 9BDF000C  stb r30, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 82CEC690: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82CEC694: 392A51A0  addi r9, r10, 0x51a0
	ctx.r[9].s64 = ctx.r[10].s64 + 20896;
	// 82CEC698: 395F0018  addi r10, r31, 0x18
	ctx.r[10].s64 = ctx.r[31].s64 + 24;
	// 82CEC69C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEC6A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CEC6A4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82CEC6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC6AC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82CEC6B0: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82CEC6B4: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CEC6B8: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82CEC6BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC6C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC6C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC6C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEC6CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEC6D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC6D8 size=92
    let mut pc: u32 = 0x82CEC6D8;
    'dispatch: loop {
        match pc {
            0x82CEC6D8 => {
    //   block [0x82CEC6D8..0x82CEC718)
	// 82CEC6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC6E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEC6E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEC6E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC6EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC6F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEC6F4: 4BFFFCDD  bl 0x82cec3d0
	ctx.lr = 0x82CEC6F8;
	sub_82CEC3D0(ctx, base);
	// 82CEC6F8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CEC6FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC700: 419A0018  beq cr6, 0x82cec718
	if ctx.cr[6].eq {
	pc = 0x82CEC718; continue 'dispatch;
	}
	// 82CEC704: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC708: 3CA06182  lis r5, 0x6182
	ctx.r[5].s64 = 1635909632;
	// 82CEC70C: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEC710: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEC714: 4BFF4115  bl 0x82ce0828
	ctx.lr = 0x82CEC718;
	sub_82CE0828(ctx, base);
	pc = 0x82CEC718; continue 'dispatch;
            }
            0x82CEC718 => {
    //   block [0x82CEC718..0x82CEC734)
	// 82CEC718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC71C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC728: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEC72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEC730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC738 size=112
    let mut pc: u32 = 0x82CEC738;
    'dispatch: loop {
        match pc {
            0x82CEC738 => {
    //   block [0x82CEC738..0x82CEC760)
	// 82CEC738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC73C: 4BFBCCD1  bl 0x82ca940c
	ctx.lr = 0x82CEC740;
	sub_82CA93D0(ctx, base);
	// 82CEC740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC744: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEC748: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEC74C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC750: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CEC754: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC75C: 419A0044  beq cr6, 0x82cec7a0
	if ctx.cr[6].eq {
	pc = 0x82CEC7A0; continue 'dispatch;
	}
	pc = 0x82CEC760; continue 'dispatch;
            }
            0x82CEC760 => {
    //   block [0x82CEC760..0x82CEC7A0)
	// 82CEC760: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC764: 4198003C  blt cr6, 0x82cec7a0
	if ctx.cr[6].lt {
	pc = 0x82CEC7A0; continue 'dispatch;
	}
	// 82CEC768: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC76C: 54C815BA  rlwinm r8, r6, 2, 0x16, 0x1d
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x3FFFFFFFu64;
	// 82CEC770: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC774: 54CB1D78  rlwinm r11, r6, 3, 0x15, 0x1c
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x1FFFFFFFu64;
	// 82CEC778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEC77C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEC780: 54DD063E  clrlwi r29, r6, 0x18
	ctx.r[29].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CEC784: 7CA8482E  lwzx r5, r8, r9
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82CEC788: 4BFFFD19  bl 0x82cec4a0
	ctx.lr = 0x82CEC78C;
	sub_82CEC4A0(ctx, base);
	// 82CEC78C: 38FD0001  addi r7, r29, 1
	ctx.r[7].s64 = ctx.r[29].s64 + 1;
	// 82CEC790: 88BF0000  lbz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC794: 54E6063E  clrlwi r6, r7, 0x18
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82CEC798: 7F062840  cmplw cr6, r6, r5
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82CEC79C: 4198FFC4  blt cr6, 0x82cec760
	if ctx.cr[6].lt {
	pc = 0x82CEC760; continue 'dispatch;
	}
	pc = 0x82CEC7A0; continue 'dispatch;
            }
            0x82CEC7A0 => {
    //   block [0x82CEC7A0..0x82CEC7A8)
	// 82CEC7A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC7A4: 4BFBCCB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC7A8 size=288
    let mut pc: u32 = 0x82CEC7A8;
    'dispatch: loop {
        match pc {
            0x82CEC7A8 => {
    //   block [0x82CEC7A8..0x82CEC7D8)
	// 82CEC7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC7AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC7B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC7B4: 89640005  lbz r11, 5(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 82CEC7B8: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEC7BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC7C0: 409A0018  bne cr6, 0x82cec7d8
	if !ctx.cr[6].eq {
	pc = 0x82CEC7D8; continue 'dispatch;
	}
	// 82CEC7C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC7C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEC7CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC7D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC7D4: 4E800020  blr
	return;
            }
            0x82CEC7D8 => {
    //   block [0x82CEC7D8..0x82CEC810)
	// 82CEC7D8: 89640006  lbz r11, 6(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CEC7DC: 556A077C  rlwinm r10, r11, 0, 0x1d, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEC7E0: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82CEC7E4: 409A0080  bne cr6, 0x82cec864
	if !ctx.cr[6].eq {
	pc = 0x82CEC864; continue 'dispatch;
	}
	// 82CEC7E8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC7EC: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC7F0: 892D010C  lbz r9, 0x10c(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[13].u32.wrapping_add(268 as u32) ) } as u64;
	// 82CEC7F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CEC7F8: 810B72AC  lwz r8, 0x72ac(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEC7FC: 419A0030  beq cr6, 0x82cec82c
	if ctx.cr[6].eq {
	pc = 0x82CEC82C; continue 'dispatch;
	}
	// 82CEC800: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CEC804: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEC808: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82CEC80C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82CEC810; continue 'dispatch;
            }
            0x82CEC810 => {
    //   block [0x82CEC810..0x82CEC82C)
	// 82CEC810: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC814: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CEC818: 419A0028  beq cr6, 0x82cec840
	if ctx.cr[6].eq {
	pc = 0x82CEC840; continue 'dispatch;
	}
	// 82CEC81C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEC820: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CEC824: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CEC828: 4198FFE8  blt cr6, 0x82cec810
	if ctx.cr[6].lt {
	pc = 0x82CEC810; continue 'dispatch;
	}
	pc = 0x82CEC82C; continue 'dispatch;
            }
            0x82CEC82C => {
    //   block [0x82CEC82C..0x82CEC840)
	// 82CEC82C: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC830: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82CEC834: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC838: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEC83C: 48000060  b 0x82cec89c
	pc = 0x82CEC89C; continue 'dispatch;
            }
            0x82CEC840 => {
    //   block [0x82CEC840..0x82CEC864)
	// 82CEC840: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82CEC844: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CEC848: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEC84C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEC850: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 82CEC854: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CEC858: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82CEC85C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEC860: 4800003C  b 0x82cec89c
	pc = 0x82CEC89C; continue 'dispatch;
            }
            0x82CEC864 => {
    //   block [0x82CEC864..0x82CEC87C)
	// 82CEC864: 556A07BE  clrlwi r10, r11, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82CEC868: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC86C: 419A0010  beq cr6, 0x82cec87c
	if ctx.cr[6].eq {
	pc = 0x82CEC87C; continue 'dispatch;
	}
	// 82CEC870: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC874: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEC878: 48000024  b 0x82cec89c
	pc = 0x82CEC89C; continue 'dispatch;
            }
            0x82CEC87C => {
    //   block [0x82CEC87C..0x82CEC894)
	// 82CEC87C: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEC880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC884: 419A0010  beq cr6, 0x82cec894
	if ctx.cr[6].eq {
	pc = 0x82CEC894; continue 'dispatch;
	}
	// 82CEC888: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC88C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CEC890: 4800000C  b 0x82cec89c
	pc = 0x82CEC89C; continue 'dispatch;
            }
            0x82CEC894 => {
    //   block [0x82CEC894..0x82CEC89C)
	// 82CEC894: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC898: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82CEC89C; continue 'dispatch;
            }
            0x82CEC89C => {
    //   block [0x82CEC89C..0x82CEC8C8)
	// 82CEC89C: 80640000  lwz r3, 0(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC8A0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82CEC8A4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82CEC8A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC8AC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEC8B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC8B4: 4E800421  bctrl
	ctx.lr = 0x82CEC8B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC8B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEC8BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC8C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC8C8 size=548
    let mut pc: u32 = 0x82CEC8C8;
    'dispatch: loop {
        match pc {
            0x82CEC8C8 => {
    //   block [0x82CEC8C8..0x82CEC90C)
	// 82CEC8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC8CC: 4BFBCB3D  bl 0x82ca9408
	ctx.lr = 0x82CEC8D0;
	sub_82CA93D0(ctx, base);
	// 82CEC8D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC8D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEC8D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CEC8DC: 4BC10BC5  bl 0x828fd4a0
	ctx.lr = 0x82CEC8E0;
	sub_828FD4A0(ctx, base);
	// 82CEC8E0: 485CDA25  bl 0x832ba304
	ctx.lr = 0x82CEC8E4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEC8E4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC8E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEC8EC: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEC8F0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEC8F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC8F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC8FC: 419A0010  beq cr6, 0x82cec90c
	if ctx.cr[6].eq {
	pc = 0x82CEC90C; continue 'dispatch;
	}
	// 82CEC900: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC904: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC908: 419A0018  beq cr6, 0x82cec920
	if ctx.cr[6].eq {
	pc = 0x82CEC920; continue 'dispatch;
	}
	pc = 0x82CEC90C; continue 'dispatch;
            }
            0x82CEC90C => {
    //   block [0x82CEC90C..0x82CEC920)
	// 82CEC90C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC910: 485CD9E5  bl 0x832ba2f4
	ctx.lr = 0x82CEC914;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEC914: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC918: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEC91C: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CEC920; continue 'dispatch;
            }
            0x82CEC920 => {
    //   block [0x82CEC920..0x82CEC95C)
	// 82CEC920: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEC924: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC928: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEC92C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEC930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC934: 419A00A4  beq cr6, 0x82cec9d8
	if ctx.cr[6].eq {
	pc = 0x82CEC9D8; continue 'dispatch;
	}
	// 82CEC938: 485CD9CD  bl 0x832ba304
	ctx.lr = 0x82CEC93C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEC93C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC940: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEC944: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEC948: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC94C: 419A0010  beq cr6, 0x82cec95c
	if ctx.cr[6].eq {
	pc = 0x82CEC95C; continue 'dispatch;
	}
	// 82CEC950: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC954: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC958: 419A0018  beq cr6, 0x82cec970
	if ctx.cr[6].eq {
	pc = 0x82CEC970; continue 'dispatch;
	}
	pc = 0x82CEC95C; continue 'dispatch;
            }
            0x82CEC95C => {
    //   block [0x82CEC95C..0x82CEC970)
	// 82CEC95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC960: 485CD995  bl 0x832ba2f4
	ctx.lr = 0x82CEC964;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEC964: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC968: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEC96C: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CEC970; continue 'dispatch;
            }
            0x82CEC970 => {
    //   block [0x82CEC970..0x82CEC9D8)
	// 82CEC970: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEC974: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEC978: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC97C: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEC980: 5569063E  clrlwi r9, r11, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CEC984: 552907B8  rlwinm r9, r9, 0, 0x1e, 0x1c
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEC988: 993C003D  stb r9, 0x3d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(61 as u32), ctx.r[9].u8 ) };
	// 82CEC98C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC990: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC994: 419A00FC  beq cr6, 0x82ceca90
	if ctx.cr[6].eq {
	pc = 0x82CECA90; continue 'dispatch;
	}
	// 82CEC998: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC99C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEC9A0: 409A00F0  bne cr6, 0x82ceca90
	if !ctx.cr[6].eq {
	pc = 0x82CECA90; continue 'dispatch;
	}
	// 82CEC9A4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC9A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC9AC: 408200E4  bne 0x82ceca90
	if !ctx.cr[0].eq {
	pc = 0x82CECA90; continue 'dispatch;
	}
	// 82CEC9B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEC9B4: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC9B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEC9BC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEC9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC9C4: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEC9C8: 485CD96D  bl 0x832ba334
	ctx.lr = 0x82CEC9CC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEC9CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEC9D0: 485CD945  bl 0x832ba314
	ctx.lr = 0x82CEC9D4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEC9D4: 480000B8  b 0x82ceca8c
	pc = 0x82CECA8C; continue 'dispatch;
            }
            0x82CEC9D8 => {
    //   block [0x82CEC9D8..0x82CEC9FC)
	// 82CEC9D8: 485CD92D  bl 0x832ba304
	ctx.lr = 0x82CEC9DC;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEC9DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC9E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEC9E4: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEC9E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC9EC: 419A0010  beq cr6, 0x82cec9fc
	if ctx.cr[6].eq {
	pc = 0x82CEC9FC; continue 'dispatch;
	}
	// 82CEC9F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC9F4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC9F8: 419A0018  beq cr6, 0x82ceca10
	if ctx.cr[6].eq {
	pc = 0x82CECA10; continue 'dispatch;
	}
	pc = 0x82CEC9FC; continue 'dispatch;
            }
            0x82CEC9FC => {
    //   block [0x82CEC9FC..0x82CECA10)
	// 82CEC9FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECA00: 485CD8F5  bl 0x832ba2f4
	ctx.lr = 0x82CECA04;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECA04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECA08: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CECA0C: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CECA10; continue 'dispatch;
            }
            0x82CECA10 => {
    //   block [0x82CECA10..0x82CECA78)
	// 82CECA10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECA14: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECA18: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECA1C: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECA20: 5569063C  rlwinm r9, r11, 0, 0x18, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CECA24: 552906B0  rlwinm r9, r9, 0, 0x1a, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CECA28: 61280001  ori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 | 1;
	// 82CECA2C: 991C003D  stb r8, 0x3d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(61 as u32), ctx.r[8].u8 ) };
	// 82CECA30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECA34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECA38: 419A0040  beq cr6, 0x82ceca78
	if ctx.cr[6].eq {
	pc = 0x82CECA78; continue 'dispatch;
	}
	// 82CECA3C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECA40: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECA44: 409A0034  bne cr6, 0x82ceca78
	if !ctx.cr[6].eq {
	pc = 0x82CECA78; continue 'dispatch;
	}
	// 82CECA48: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECA4C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECA50: 40820028  bne 0x82ceca78
	if !ctx.cr[0].eq {
	pc = 0x82CECA78; continue 'dispatch;
	}
	// 82CECA54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECA58: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECA5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECA60: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECA68: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECA6C: 485CD8C9  bl 0x832ba334
	ctx.lr = 0x82CECA70;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECA70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECA74: 485CD8A1  bl 0x832ba314
	ctx.lr = 0x82CECA78;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CECA78; continue 'dispatch;
            }
            0x82CECA78 => {
    //   block [0x82CECA78..0x82CECA8C)
	// 82CECA78: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECA7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CECA80: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CECA84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CECA88: 4E800421  bctrl
	ctx.lr = 0x82CECA8C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82CECA8C => {
    //   block [0x82CECA8C..0x82CECA90)
	// 82CECA8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82CECA90; continue 'dispatch;
            }
            0x82CECA90 => {
    //   block [0x82CECA90..0x82CECAD8)
	// 82CECA90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECA94: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECA98: 419A0040  beq cr6, 0x82cecad8
	if ctx.cr[6].eq {
	pc = 0x82CECAD8; continue 'dispatch;
	}
	// 82CECA9C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECAA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECAA4: 409A0034  bne cr6, 0x82cecad8
	if !ctx.cr[6].eq {
	pc = 0x82CECAD8; continue 'dispatch;
	}
	// 82CECAA8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECAAC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECAB0: 40820028  bne 0x82cecad8
	if !ctx.cr[0].eq {
	pc = 0x82CECAD8; continue 'dispatch;
	}
	// 82CECAB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECAB8: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECABC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECAC0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECAC8: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECACC: 485CD869  bl 0x832ba334
	ctx.lr = 0x82CECAD0;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECAD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECAD4: 485CD841  bl 0x832ba314
	ctx.lr = 0x82CECAD8;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CECAD8; continue 'dispatch;
            }
            0x82CECAD8 => {
    //   block [0x82CECAD8..0x82CECAEC)
	// 82CECAD8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CECADC: 4BC109C5  bl 0x828fd4a0
	ctx.lr = 0x82CECAE0;
	sub_828FD4A0(ctx, base);
	// 82CECAE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECAE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECAE8: 4BFBC970  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CECAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CECAF0 size=960
    let mut pc: u32 = 0x82CECAF0;
    'dispatch: loop {
        match pc {
            0x82CECAF0 => {
    //   block [0x82CECAF0..0x82CECB44)
	// 82CECAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CECAF4: 4BFBC915  bl 0x82ca9408
	ctx.lr = 0x82CECAF8;
	sub_82CA93D0(ctx, base);
	// 82CECAF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CECAFC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CECB00: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECB04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CECB08: 4BC10999  bl 0x828fd4a0
	ctx.lr = 0x82CECB0C;
	sub_828FD4A0(ctx, base);
	// 82CECB0C: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 82CECB10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECB14: 419A01DC  beq cr6, 0x82ceccf0
	if ctx.cr[6].eq {
	pc = 0x82CECCF0; continue 'dispatch;
	}
	// 82CECB18: 485CD7ED  bl 0x832ba304
	ctx.lr = 0x82CECB1C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CECB1C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CECB20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CECB24: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CECB28: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CECB2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECB30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECB34: 419A0010  beq cr6, 0x82cecb44
	if ctx.cr[6].eq {
	pc = 0x82CECB44; continue 'dispatch;
	}
	// 82CECB38: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECB3C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECB40: 419A0018  beq cr6, 0x82cecb58
	if ctx.cr[6].eq {
	pc = 0x82CECB58; continue 'dispatch;
	}
	pc = 0x82CECB44; continue 'dispatch;
            }
            0x82CECB44 => {
    //   block [0x82CECB44..0x82CECB58)
	// 82CECB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECB48: 485CD7AD  bl 0x832ba2f4
	ctx.lr = 0x82CECB4C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECB4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECB50: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CECB54: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CECB58; continue 'dispatch;
            }
            0x82CECB58 => {
    //   block [0x82CECB58..0x82CECBE0)
	// 82CECB58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECB5C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82CECB60: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECB64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CECB68: 806A72AC  lwz r3, 0x72ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CECB6C: 4BFF415D  bl 0x82ce0cc8
	ctx.lr = 0x82CECB70;
	sub_82CE0CC8(ctx, base);
	// 82CECB70: 893C003D  lbz r9, 0x3d(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECB74: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82CECB78: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CECB7C: 409A0064  bne cr6, 0x82cecbe0
	if !ctx.cr[6].eq {
	pc = 0x82CECBE0; continue 'dispatch;
	}
	// 82CECB80: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECB84: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECB88: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CECB8C: 419A0310  beq cr6, 0x82cece9c
	if ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECB90: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECB94: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CECB98: 409A0304  bne cr6, 0x82cece9c
	if !ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECB9C: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECBA0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECBA4: 408202F8  bne 0x82cece9c
	if !ctx.cr[0].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECBA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECBAC: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECBB4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECBBC: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECBC0: 485CD775  bl 0x832ba334
	ctx.lr = 0x82CECBC4;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECBC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECBC8: 485CD74D  bl 0x832ba314
	ctx.lr = 0x82CECBCC;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECBCC: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECBD0: 4BC108D1  bl 0x828fd4a0
	ctx.lr = 0x82CECBD4;
	sub_828FD4A0(ctx, base);
	// 82CECBD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECBD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECBDC: 4BFBC87C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CECBE0 => {
    //   block [0x82CECBE0..0x82CECC04)
	// 82CECBE0: 485CD725  bl 0x832ba304
	ctx.lr = 0x82CECBE4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CECBE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECBE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CECBEC: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CECBF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECBF4: 419A0010  beq cr6, 0x82cecc04
	if ctx.cr[6].eq {
	pc = 0x82CECC04; continue 'dispatch;
	}
	// 82CECBF8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECBFC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECC00: 419A0018  beq cr6, 0x82cecc18
	if ctx.cr[6].eq {
	pc = 0x82CECC18; continue 'dispatch;
	}
	pc = 0x82CECC04; continue 'dispatch;
            }
            0x82CECC04 => {
    //   block [0x82CECC04..0x82CECC18)
	// 82CECC04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECC08: 485CD6ED  bl 0x832ba2f4
	ctx.lr = 0x82CECC0C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECC0C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECC10: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CECC14: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CECC18; continue 'dispatch;
            }
            0x82CECC18 => {
    //   block [0x82CECC18..0x82CECC7C)
	// 82CECC18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECC1C: 398000BA  li r12, 0xba
	ctx.r[12].s64 = 186;
	// 82CECC20: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECC24: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECC28: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECC2C: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82CECC30: 993C003D  stb r9, 0x3d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(61 as u32), ctx.r[9].u8 ) };
	// 82CECC34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECC38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECC3C: 419A0040  beq cr6, 0x82cecc7c
	if ctx.cr[6].eq {
	pc = 0x82CECC7C; continue 'dispatch;
	}
	// 82CECC40: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECC44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECC48: 409A0034  bne cr6, 0x82cecc7c
	if !ctx.cr[6].eq {
	pc = 0x82CECC7C; continue 'dispatch;
	}
	// 82CECC4C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECC50: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECC54: 40820028  bne 0x82cecc7c
	if !ctx.cr[0].eq {
	pc = 0x82CECC7C; continue 'dispatch;
	}
	// 82CECC58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECC5C: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECC60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECC64: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECC6C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECC70: 485CD6C5  bl 0x832ba334
	ctx.lr = 0x82CECC74;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECC74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECC78: 485CD69D  bl 0x832ba314
	ctx.lr = 0x82CECC7C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CECC7C; continue 'dispatch;
            }
            0x82CECC7C => {
    //   block [0x82CECC7C..0x82CECCF0)
	// 82CECC7C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECC80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CECC84: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CECC88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CECC8C: 4E800421  bctrl
	ctx.lr = 0x82CECC90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CECC90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECC94: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECC98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECC9C: 419A0200  beq cr6, 0x82cece9c
	if ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECCA0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECCA4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECCA8: 409A01F4  bne cr6, 0x82cece9c
	if !ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECCAC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECCB0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECCB4: 408201E8  bne 0x82cece9c
	if !ctx.cr[0].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECCB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECCBC: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECCC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECCC4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECCC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECCCC: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECCD0: 485CD665  bl 0x832ba334
	ctx.lr = 0x82CECCD4;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECCD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECCD8: 485CD63D  bl 0x832ba314
	ctx.lr = 0x82CECCDC;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECCDC: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECCE0: 4BC107C1  bl 0x828fd4a0
	ctx.lr = 0x82CECCE4;
	sub_828FD4A0(ctx, base);
	// 82CECCE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECCE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECCEC: 4BFBC76C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CECCF0 => {
    //   block [0x82CECCF0..0x82CECD1C)
	// 82CECCF0: 485CD615  bl 0x832ba304
	ctx.lr = 0x82CECCF4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CECCF4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CECCF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CECCFC: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CECD00: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CECD04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECD08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECD0C: 419A0010  beq cr6, 0x82cecd1c
	if ctx.cr[6].eq {
	pc = 0x82CECD1C; continue 'dispatch;
	}
	// 82CECD10: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECD14: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECD18: 419A0024  beq cr6, 0x82cecd3c
	if ctx.cr[6].eq {
	pc = 0x82CECD3C; continue 'dispatch;
	}
	pc = 0x82CECD1C; continue 'dispatch;
            }
            0x82CECD1C => {
    //   block [0x82CECD1C..0x82CECD3C)
	// 82CECD1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECD20: 485CD5D5  bl 0x832ba2f4
	ctx.lr = 0x82CECD24;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECD24: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82CECD28: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82CECD2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECD30: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECD34: 993F000C  stb r9, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 82CECD38: 48000008  b 0x82cecd40
	pc = 0x82CECD40; continue 'dispatch;
            }
            0x82CECD3C => {
    //   block [0x82CECD3C..0x82CECD40)
	// 82CECD3C: 893F000C  lbz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82CECD40; continue 'dispatch;
            }
            0x82CECD40 => {
    //   block [0x82CECD40..0x82CECDB0)
	// 82CECD40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECD44: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECD48: 891C003D  lbz r8, 0x3d(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECD4C: 550707FE  clrlwi r7, r8, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 82CECD50: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CECD54: 409A005C  bne cr6, 0x82cecdb0
	if !ctx.cr[6].eq {
	pc = 0x82CECDB0; continue 'dispatch;
	}
	// 82CECD58: 7DA86B78  mr r8, r13
	ctx.r[8].u64 = ctx.r[13].u64;
	// 82CECD5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECD60: 419A013C  beq cr6, 0x82cece9c
	if ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECD64: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECD68: 409A0134  bne cr6, 0x82cece9c
	if !ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECD6C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECD70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECD74: 40820128  bne 0x82cece9c
	if !ctx.cr[0].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECD78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECD7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECD80: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECD84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECD88: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECD8C: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82CECD90: 485CD5A5  bl 0x832ba334
	ctx.lr = 0x82CECD94;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECD94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECD98: 485CD57D  bl 0x832ba314
	ctx.lr = 0x82CECD9C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECD9C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECDA0: 4BC10701  bl 0x828fd4a0
	ctx.lr = 0x82CECDA4;
	sub_828FD4A0(ctx, base);
	// 82CECDA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECDA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECDAC: 4BFBC6AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CECDB0 => {
    //   block [0x82CECDB0..0x82CECDD4)
	// 82CECDB0: 485CD555  bl 0x832ba304
	ctx.lr = 0x82CECDB4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CECDB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECDB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CECDBC: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CECDC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECDC4: 419A0010  beq cr6, 0x82cecdd4
	if ctx.cr[6].eq {
	pc = 0x82CECDD4; continue 'dispatch;
	}
	// 82CECDC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECDCC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECDD0: 419A0018  beq cr6, 0x82cecde8
	if ctx.cr[6].eq {
	pc = 0x82CECDE8; continue 'dispatch;
	}
	pc = 0x82CECDD4; continue 'dispatch;
            }
            0x82CECDD4 => {
    //   block [0x82CECDD4..0x82CECDE8)
	// 82CECDD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECDD8: 485CD51D  bl 0x832ba2f4
	ctx.lr = 0x82CECDDC;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECDDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECDE0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CECDE4: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x82CECDE8; continue 'dispatch;
            }
            0x82CECDE8 => {
    //   block [0x82CECDE8..0x82CECE4C)
	// 82CECDE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECDEC: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECDF0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECDF4: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECDF8: 61690004  ori r9, r11, 4
	ctx.r[9].u64 = ctx.r[11].u64 | 4;
	// 82CECDFC: 993C003D  stb r9, 0x3d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(61 as u32), ctx.r[9].u8 ) };
	// 82CECE00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECE04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECE08: 419A0044  beq cr6, 0x82cece4c
	if ctx.cr[6].eq {
	pc = 0x82CECE4C; continue 'dispatch;
	}
	// 82CECE0C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECE10: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECE14: 409A0038  bne cr6, 0x82cece4c
	if !ctx.cr[6].eq {
	pc = 0x82CECE4C; continue 'dispatch;
	}
	// 82CECE18: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECE1C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECE20: 4082002C  bne 0x82cece4c
	if !ctx.cr[0].eq {
	pc = 0x82CECE4C; continue 'dispatch;
	}
	// 82CECE24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECE28: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECE2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECE30: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECE38: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECE3C: 485CD4F9  bl 0x832ba334
	ctx.lr = 0x82CECE40;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECE40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECE44: 485CD4D1  bl 0x832ba314
	ctx.lr = 0x82CECE48;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECE48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82CECE4C; continue 'dispatch;
            }
            0x82CECE4C => {
    //   block [0x82CECE4C..0x82CECE94)
	// 82CECE4C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECE50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECE54: 419A0040  beq cr6, 0x82cece94
	if ctx.cr[6].eq {
	pc = 0x82CECE94; continue 'dispatch;
	}
	// 82CECE58: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECE5C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECE60: 409A0034  bne cr6, 0x82cece94
	if !ctx.cr[6].eq {
	pc = 0x82CECE94; continue 'dispatch;
	}
	// 82CECE64: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECE68: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECE6C: 40820028  bne 0x82cece94
	if !ctx.cr[0].eq {
	pc = 0x82CECE94; continue 'dispatch;
	}
	// 82CECE70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECE74: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECE78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECE7C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECE84: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECE88: 485CD4AD  bl 0x832ba334
	ctx.lr = 0x82CECE8C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECE8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECE90: 485CD485  bl 0x832ba314
	ctx.lr = 0x82CECE94;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	pc = 0x82CECE94; continue 'dispatch;
            }
            0x82CECE94 => {
    //   block [0x82CECE94..0x82CECE9C)
	// 82CECE94: A17C003E  lhz r11, 0x3e(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(62 as u32) ) } as u64;
	// 82CECE98: B17C0040  sth r11, 0x40(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), ctx.r[11].u16 ) };
	pc = 0x82CECE9C; continue 'dispatch;
            }
            0x82CECE9C => {
    //   block [0x82CECE9C..0x82CECEB0)
	// 82CECE9C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECEA0: 4BC10601  bl 0x828fd4a0
	ctx.lr = 0x82CECEA4;
	sub_828FD4A0(ctx, base);
	// 82CECEA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECEA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECEAC: 4BFBC5AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CECEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CECEB0 size=308
    let mut pc: u32 = 0x82CECEB0;
    'dispatch: loop {
        match pc {
            0x82CECEB0 => {
    //   block [0x82CECEB0..0x82CECF00)
	// 82CECEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CECEB4: 4BFBC555  bl 0x82ca9408
	ctx.lr = 0x82CECEB8;
	sub_82CA93D0(ctx, base);
	// 82CECEB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CECEBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CECEC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CECEC4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82CECEC8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82CECECC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CECED0: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82CECED4: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CECED8: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82CECEDC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECEE0: 913F0034  stw r9, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 82CECEE4: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECEE8: 911F0038  stw r8, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[8].u32 ) };
	// 82CECEEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECEF4: 419A000C  beq cr6, 0x82cecf00
	if ctx.cr[6].eq {
	pc = 0x82CECF00; continue 'dispatch;
	}
	// 82CECEF8: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECEFC: 48000008  b 0x82cecf04
	pc = 0x82CECF04; continue 'dispatch;
            }
            0x82CECF00 => {
    //   block [0x82CECF00..0x82CECF04)
	// 82CECF00: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82CECF04; continue 'dispatch;
            }
            0x82CECF04 => {
    //   block [0x82CECF04..0x82CECF2C)
	// 82CECF04: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82CECF08: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECF0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECF10: 419A001C  beq cr6, 0x82cecf2c
	if ctx.cr[6].eq {
	pc = 0x82CECF2C; continue 'dispatch;
	}
	// 82CECF14: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82CECF18: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECF1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CECF20: 419A0054  beq cr6, 0x82cecf74
	if ctx.cr[6].eq {
	pc = 0x82CECF74; continue 'dispatch;
	}
	// 82CECF24: 4BFF1625  bl 0x82cde548
	ctx.lr = 0x82CECF28;
	sub_82CDE548(ctx, base);
	// 82CECF28: 4800004C  b 0x82cecf74
	pc = 0x82CECF74; continue 'dispatch;
            }
            0x82CECF2C => {
    //   block [0x82CECF2C..0x82CECF74)
	// 82CECF2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82CECF30: 895E0001  lbz r10, 1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CECF34: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82CECF38: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECF3C: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 82CECF40: 6128BB80  ori r8, r9, 0xbb80
	ctx.r[8].u64 = ctx.r[9].u64 | 48000;
	// 82CECF44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CECF48: FBAB0000  std r29, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 82CECF4C: FBAB0008  std r29, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 82CECF50: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82CECF54: 9BA10054  stb r29, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u8 ) };
	// 82CECF58: 99410055  stb r10, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[10].u8 ) };
	// 82CECF5C: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82CECF60: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82CECF64: 4BFF191D  bl 0x82cde880
	ctx.lr = 0x82CECF68;
	sub_82CDE880(ctx, base);
	// 82CECF68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CECF6C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82CECF70: 41980068  blt cr6, 0x82cecfd8
	if ctx.cr[6].lt {
	pc = 0x82CECFD8; continue 'dispatch;
	}
	pc = 0x82CECF74; continue 'dispatch;
            }
            0x82CECF74 => {
    //   block [0x82CECF74..0x82CECFA8)
	// 82CECF74: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CECF78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECF7C: 419A002C  beq cr6, 0x82cecfa8
	if ctx.cr[6].eq {
	pc = 0x82CECFA8; continue 'dispatch;
	}
	// 82CECF80: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECF84: 55641838  slwi r4, r11, 3
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CECF88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECF8C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CECF90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CECF94: 4E800421  bctrl
	ctx.lr = 0x82CECF98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CECF98: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 82CECF9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CECFA0: 419A0028  beq cr6, 0x82cecfc8
	if ctx.cr[6].eq {
	pc = 0x82CECFC8; continue 'dispatch;
	}
	// 82CECFA4: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
            }
            0x82CECFA8 => {
    //   block [0x82CECFA8..0x82CECFC8)
	// 82CECFA8: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CECFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECFB0: 419A0028  beq cr6, 0x82cecfd8
	if ctx.cr[6].eq {
	pc = 0x82CECFD8; continue 'dispatch;
	}
	// 82CECFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECFB8: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECFBC: 4BFFF77D  bl 0x82cec738
	ctx.lr = 0x82CECFC0;
	sub_82CEC738(ctx, base);
	// 82CECFC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CECFC4: 4BFBC494  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CECFC8 => {
    //   block [0x82CECFC8..0x82CECFD8)
	// 82CECFC8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CECFCC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CECFD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CECFD4: 4BFBC484  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CECFD8 => {
    //   block [0x82CECFD8..0x82CECFE4)
	// 82CECFD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CECFDC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CECFE0: 4BFBC478  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CECFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CECFE8 size=104
    let mut pc: u32 = 0x82CECFE8;
    'dispatch: loop {
        match pc {
            0x82CECFE8 => {
    //   block [0x82CECFE8..0x82CED010)
	// 82CECFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CECFEC: 4BFBC421  bl 0x82ca940c
	ctx.lr = 0x82CECFF0;
	sub_82CA93D0(ctx, base);
	// 82CECFF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CECFF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CECFF8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82CECFFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CED000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CED004: 895F003C  lbz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CED008: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CED00C: 419A003C  beq cr6, 0x82ced048
	if ctx.cr[6].eq {
	pc = 0x82CED048; continue 'dispatch;
	}
	pc = 0x82CED010; continue 'dispatch;
            }
            0x82CED010 => {
    //   block [0x82CED010..0x82CED048)
	// 82CED010: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CED014: 41980034  blt cr6, 0x82ced048
	if ctx.cr[6].lt {
	pc = 0x82CED048; continue 'dispatch;
	}
	// 82CED018: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CED01C: 556A1D78  rlwinm r10, r11, 3, 0x15, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82CED020: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82CED024: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82CED028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CED02C: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CED030: 4BFFF779  bl 0x82cec7a8
	ctx.lr = 0x82CED034;
	sub_82CEC7A8(ctx, base);
	// 82CED034: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82CED038: 895F003C  lbz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CED03C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CED040: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CED044: 4198FFCC  blt cr6, 0x82ced010
	if ctx.cr[6].lt {
	pc = 0x82CED010; continue 'dispatch;
	}
	pc = 0x82CED048; continue 'dispatch;
            }
            0x82CED048 => {
    //   block [0x82CED048..0x82CED050)
	// 82CED048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CED04C: 4BFBC410  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED050 size=16
    let mut pc: u32 = 0x82CED050;
    'dispatch: loop {
        match pc {
            0x82CED050 => {
    //   block [0x82CED050..0x82CED060)
	// 82CED050: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82CED054: 4199000C  bgt cr6, 0x82ced060
	if ctx.cr[6].gt {
		sub_82CED060(ctx, base);
		return;
	}
	// 82CED058: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CED05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED060 size=16
    let mut pc: u32 = 0x82CED060;
    'dispatch: loop {
        match pc {
            0x82CED060 => {
    //   block [0x82CED060..0x82CED070)
	// 82CED060: 2B0326F5  cmplwi cr6, r3, 0x26f5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 9973 as u32, &mut ctx.xer);
	// 82CED064: 4198000C  blt cr6, 0x82ced070
	if ctx.cr[6].lt {
		sub_82CED070(ctx, base);
		return;
	}
	// 82CED068: 386026F5  li r3, 0x26f5
	ctx.r[3].s64 = 9973;
	// 82CED06C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED070 size=84
    let mut pc: u32 = 0x82CED070;
    'dispatch: loop {
        match pc {
            0x82CED070 => {
    //   block [0x82CED070..0x82CED084)
	// 82CED070: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CED074: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CED078: 390004CD  li r8, 0x4cd
	ctx.r[8].s64 = 1229;
	// 82CED07C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CED080: 38CA51F8  addi r6, r10, 0x51f8
	ctx.r[6].s64 = ctx.r[10].s64 + 20984;
	pc = 0x82CED084; continue 'dispatch;
            }
            0x82CED084 => {
    //   block [0x82CED084..0x82CED0AC)
	// 82CED084: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CED088: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82CED08C: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CED090: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CED094: 7D45302E  lwzx r10, r5, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82CED098: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82CED09C: 419A001C  beq cr6, 0x82ced0b8
	if ctx.cr[6].eq {
	pc = 0x82CED0B8; continue 'dispatch;
	}
	// 82CED0A0: 4099000C  ble cr6, 0x82ced0ac
	if !ctx.cr[6].gt {
	pc = 0x82CED0AC; continue 'dispatch;
	}
	// 82CED0A4: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82CED0A8: 48000008  b 0x82ced0b0
	pc = 0x82CED0B0; continue 'dispatch;
            }
            0x82CED0AC => {
    //   block [0x82CED0AC..0x82CED0B0)
	// 82CED0AC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	pc = 0x82CED0B0; continue 'dispatch;
            }
            0x82CED0B0 => {
    //   block [0x82CED0B0..0x82CED0B8)
	// 82CED0B0: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CED0B4: 409AFFD0  bne cr6, 0x82ced084
	if !ctx.cr[6].eq {
	pc = 0x82CED084; continue 'dispatch;
	}
	pc = 0x82CED0B8; continue 'dispatch;
            }
            0x82CED0B8 => {
    //   block [0x82CED0B8..0x82CED0C4)
	// 82CED0B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CED0BC: 7C6B302E  lwzx r3, r11, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82CED0C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CED0C8 size=56
    let mut pc: u32 = 0x82CED0C8;
    'dispatch: loop {
        match pc {
            0x82CED0C8 => {
    //   block [0x82CED0C8..0x82CED100)
	// 82CED0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CED0D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CED0D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CED0DC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82CED0E0: 4BFF4479  bl 0x82ce1558
	ctx.lr = 0x82CED0E4;
	sub_82CE1558(ctx, base);
	// 82CED0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CED0E8: 4BFF4471  bl 0x82ce1558
	ctx.lr = 0x82CED0EC;
	sub_82CE1558(ctx, base);
	// 82CED0EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CED0F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CED0F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CED0F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CED0FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CED100 size=188
    let mut pc: u32 = 0x82CED100;
    'dispatch: loop {
        match pc {
            0x82CED100 => {
    //   block [0x82CED100..0x82CED154)
	// 82CED100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CED108: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CED10C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CED110: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED114: 549E063E  clrlwi r30, r4, 0x18
	ctx.r[30].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CED118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CED11C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CED120: 419A0084  beq cr6, 0x82ced1a4
	if ctx.cr[6].eq {
	pc = 0x82CED1A4; continue 'dispatch;
	}
	// 82CED124: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CED128: 1C9E0078  mulli r4, r30, 0x78
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 120 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CED12C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CED130: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82CED134: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CED138: 4E800421  bctrl
	ctx.lr = 0x82CED13C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CED13C: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82CED140: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CED144: 419A0060  beq cr6, 0x82ced1a4
	if ctx.cr[6].eq {
	pc = 0x82CED1A4; continue 'dispatch;
	}
	// 82CED148: 393F000C  addi r9, r31, 0xc
	ctx.r[9].s64 = ctx.r[31].s64 + 12;
	// 82CED14C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CED150: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
            }
            0x82CED154 => {
    //   block [0x82CED154..0x82CED1A4)
	// 82CED154: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CED158: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CED15C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CED160: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CED164: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CED168: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CED16C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CED170: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CED174: 80FF0018  lwz r7, 0x18(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CED178: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CED17C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CED180: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82CED184: 394A0078  addi r10, r10, 0x78
	ctx.r[10].s64 = ctx.r[10].s64 + 120;
	// 82CED188: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CED18C: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CED190: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82CED194: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CED198: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CED19C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CED1A0: 4082FFB4  bne 0x82ced154
	if !ctx.cr[0].eq {
	pc = 0x82CED154; continue 'dispatch;
	}
	pc = 0x82CED1A4; continue 'dispatch;
            }
            0x82CED1A4 => {
    //   block [0x82CED1A4..0x82CED1BC)
	// 82CED1A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CED1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CED1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CED1B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CED1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CED1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED1C0 size=36
    let mut pc: u32 = 0x82CED1C0;
    'dispatch: loop {
        match pc {
            0x82CED1C0 => {
    //   block [0x82CED1C0..0x82CED1E4)
	// 82CED1C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CED1C4: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82CED1C8: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 82CED1CC: 90630004  stw r3, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82CED1D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CED1D4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82CED1D8: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82CED1DC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82CED1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CED1E8 size=616
    let mut pc: u32 = 0x82CED1E8;
    'dispatch: loop {
        match pc {
            0x82CED1E8 => {
    //   block [0x82CED1E8..0x82CED450)
	// 82CED1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED1EC: 4BFBC21D  bl 0x82ca9408
	ctx.lr = 0x82CED1F0;
	sub_82CA93D0(ctx, base);
	// 82CED1F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED1F4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CED1F8: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CED1FC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CED200: 7C001A2C  dcbt 0, r3
	// 82CED204: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CED208: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CED20C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CED210: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CED214: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CED218: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CED21C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CED220: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CED224: 38886880  addi r4, r8, 0x6880
	ctx.r[4].s64 = ctx.r[8].s64 + 26752;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CED450 size=716
    let mut pc: u32 = 0x82CED450;
    'dispatch: loop {
        match pc {
            0x82CED450 => {
    //   block [0x82CED450..0x82CED71C)
	// 82CED450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED454: 4BFBBFAD  bl 0x82ca9400
	ctx.lr = 0x82CED458;
	sub_82CA93D0(ctx, base);
	// 82CED458: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED45C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82CED460: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CED464: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CED468: 7C001A2C  dcbt 0, r3
	// 82CED46C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CED470: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CED474: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CED478: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CED47C: C17E002C  lfs f11, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CED480: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CED484: 38E96890  addi r7, r9, 0x6890
	ctx.r[7].s64 = ctx.r[9].s64 + 26768;
	// 82CED488: D1BE0024  stfs f13, 0x24(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CED48C: 38886880  addi r4, r8, 0x6880
	ctx.r[4].s64 = ctx.r[8].s64 + 26752;
	// 82CED490: C15E0030  lfs f10, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CED494: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CED498: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CED49C: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CED4A0: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82CED4A4: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CED4A8: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CED720 size=928
    let mut pc: u32 = 0x82CED720;
    'dispatch: loop {
        match pc {
            0x82CED720 => {
    //   block [0x82CED720..0x82CEDAC0)
	// 82CED720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED724: 4BFBBCBD  bl 0x82ca93e0
	ctx.lr = 0x82CED728;
	sub_82CA93D0(ctx, base);
	// 82CED728: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED72C: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82CED730: C0180024  lfs f0, 0x24(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CED734: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CED738: 7C001A2C  dcbt 0, r3
	// 82CED73C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CED740: C1B80028  lfs f13, 0x28(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CED744: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CED748: C178002C  lfs f11, 0x2c(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CED74C: 7CC807B4  extsw r8, r6
	ctx.r[8].s64 = ctx.r[6].s32 as i64;
	// 82CED750: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 82CED754: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CED758: C1580030  lfs f10, 0x30(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CED75C: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82CED760: D1B80024  stfs f13, 0x24(r24)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CED764: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CED768: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CED76C: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CED770: 3FA08204  lis r29, -0x7dfc
	ctx.r[29].s64 = -2113667072;
	// 82CED774: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CED778: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82CED77C: 390B6890  addi r8, r11, 0x6890
	ctx.r[8].s64 = ctx.r[11].s64 + 26768;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEDAC0 size=1184
    let mut pc: u32 = 0x82CEDAC0;
    'dispatch: loop {
        match pc {
            0x82CEDAC0 => {
    //   block [0x82CEDAC0..0x82CEDF60)
	// 82CEDAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEDAC4: 4BFBB90D  bl 0x82ca93d0
	ctx.lr = 0x82CEDAC8;
	sub_82CA93D0(ctx, base);
	// 82CEDAC8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEDACC: C0070024  lfs f0, 0x24(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEDAD0: 90C1013C  stw r6, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[6].u32 ) };
	// 82CEDAD4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEDAD8: 90E10144  stw r7, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[7].u32 ) };
	// 82CEDADC: 7C001A2C  dcbt 0, r3
	// 82CEDAE0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEDAE4: C1A70028  lfs f13, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEDAE8: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 82CEDAEC: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEDAF0: C167002C  lfs f11, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEDAF4: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82CEDAF8: C1470030  lfs f10, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEDAFC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEDF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEDF60 size=444
    let mut pc: u32 = 0x82CEDF60;
    'dispatch: loop {
        match pc {
            0x82CEDF60 => {
    //   block [0x82CEDF60..0x82CEDF88)
	// 82CEDF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEDF64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEDF68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEDF6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEDF70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEDF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEDF78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEDF7C: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEDF80: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEDF84: 4198000C  blt cr6, 0x82cedf90
	if ctx.cr[6].lt {
	pc = 0x82CEDF90; continue 'dispatch;
	}
	pc = 0x82CEDF88; continue 'dispatch;
            }
            0x82CEDF88 => {
    //   block [0x82CEDF88..0x82CEDF90)
	// 82CEDF88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEDF8C: 48000178  b 0x82cee104
	pc = 0x82CEE104; continue 'dispatch;
            }
            0x82CEDF90 => {
    //   block [0x82CEDF90..0x82CEE020)
	// 82CEDF90: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CEDF94: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEDF98: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEDF9C: 4098FFEC  bge cr6, 0x82cedf88
	if !ctx.cr[6].lt {
	pc = 0x82CEDF88; continue 'dispatch;
	}
	// 82CEDFA0: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEDFA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEDFA8: 419A0144  beq cr6, 0x82cee0ec
	if ctx.cr[6].eq {
	pc = 0x82CEE0EC; continue 'dispatch;
	}
	// 82CEDFAC: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82CEDFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEDFB4: 419A0130  beq cr6, 0x82cee0e4
	if ctx.cr[6].eq {
	pc = 0x82CEE0E4; continue 'dispatch;
	}
	// 82CEDFB8: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEDFBC: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEDFC0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CEDFC4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEDFC8: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82CEDFCC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CEDFD0: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82CEDFD4: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEDFD8: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82CEDFDC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CEDFE0: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CEDFE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEDFE8: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CEDFEC: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CEDFF0: ED0A4824  fdivs f8, f10, f9
	ctx.f[8].f64 = ((ctx.f[10].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CEDFF4: D11F002C  stfs f8, 0x2c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82CEDFF8: 419A0058  beq cr6, 0x82cee050
	if ctx.cr[6].eq {
	pc = 0x82CEE050; continue 'dispatch;
	}
	// 82CEDFFC: 54E8003E  slwi r8, r7, 0
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CEE000: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEE004: 409A001C  bne cr6, 0x82cee020
	if !ctx.cr[6].eq {
	pc = 0x82CEE020; continue 'dispatch;
	}
	// 82CEE008: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE00C: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82CEE010: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82CEE014: 552B07FA  rlwinm r11, r9, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE018: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82CEE01C: 48000048  b 0x82cee064
	pc = 0x82CEE064; continue 'dispatch;
            }
            0x82CEE020 => {
    //   block [0x82CEE020..0x82CEE050)
	// 82CEE020: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEE024: 419A002C  beq cr6, 0x82cee050
	if ctx.cr[6].eq {
	pc = 0x82CEE050; continue 'dispatch;
	}
	// 82CEE028: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEE02C: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CEE030: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEE034: 409A001C  bne cr6, 0x82cee050
	if !ctx.cr[6].eq {
	pc = 0x82CEE050; continue 'dispatch;
	}
	// 82CEE038: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE03C: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82CEE040: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82CEE044: 552B07FA  rlwinm r11, r9, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE048: 394B0005  addi r10, r11, 5
	ctx.r[10].s64 = ctx.r[11].s64 + 5;
	// 82CEE04C: 48000018  b 0x82cee064
	pc = 0x82CEE064; continue 'dispatch;
            }
            0x82CEE050 => {
    //   block [0x82CEE050..0x82CEE064)
	// 82CEE050: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE054: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82CEE058: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82CEE05C: 552B07FA  rlwinm r11, r9, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE060: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	pc = 0x82CEE064; continue 'dispatch;
            }
            0x82CEE064 => {
    //   block [0x82CEE064..0x82CEE0A8)
	// 82CEE064: 897F000D  lbz r11, 0xd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CEE068: 891F000C  lbz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEE06C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82CEE070: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 82CEE074: 41990040  bgt cr6, 0x82cee0b4
	if ctx.cr[6].gt {
	pc = 0x82CEE0B4; continue 'dispatch;
	}
	// 82CEE078: 3D8082CF  lis r12, -0x7d31
	ctx.r[12].s64 = -2100363264;
	// 82CEE07C: 398CE090  addi r12, r12, -0x1f70
	ctx.r[12].s64 = ctx.r[12].s64 + -8048;
	// 82CEE080: 5520103A  slwi r0, r9, 2
	ctx.r[0].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82CEE084: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82CEE088: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82CEE08C: 4E800420  bctr
	match ctx.r[9].u64 {
		0 => {
	pc = 0x82CEE0A8; continue 'dispatch;
		},
		1 => {
	pc = 0x82CEE0A8; continue 'dispatch;
		},
		2 => {
	pc = 0x82CEE0B4; continue 'dispatch;
		},
		3 => {
	pc = 0x82CEE0A8; continue 'dispatch;
		},
		4 => {
	pc = 0x82CEE0B4; continue 'dispatch;
		},
		5 => {
	pc = 0x82CEE0A8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82CEE090: 82CEE0A8  lwz r22, -0x1f58(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8024 as u32) ) } as u64;
	// 82CEE094: 82CEE0A8  lwz r22, -0x1f58(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8024 as u32) ) } as u64;
	// 82CEE098: 82CEE0B4  lwz r22, -0x1f4c(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8012 as u32) ) } as u64;
	// 82CEE09C: 82CEE0A8  lwz r22, -0x1f58(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8024 as u32) ) } as u64;
	// 82CEE0A0: 82CEE0B4  lwz r22, -0x1f4c(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8012 as u32) ) } as u64;
	// 82CEE0A4: 82CEE0A8  lwz r22, -0x1f58(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8024 as u32) ) } as u64;
            }
            0x82CEE0A8 => {
    //   block [0x82CEE0A8..0x82CEE0B4)
	// 82CEE0A8: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEE0AC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82CEE0B0: 48000008  b 0x82cee0b8
	pc = 0x82CEE0B8; continue 'dispatch;
            }
            0x82CEE0B4 => {
    //   block [0x82CEE0B4..0x82CEE0B8)
	// 82CEE0B4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82CEE0B8; continue 'dispatch;
            }
            0x82CEE0B8 => {
    //   block [0x82CEE0B8..0x82CEE0E4)
	// 82CEE0B8: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEE0BC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CEE0C0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CEE0C4: 38C76530  addi r6, r7, 0x6530
	ctx.r[6].s64 = ctx.r[7].s64 + 25904;
	// 82CEE0C8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82CEE0CC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CEE0D0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEE0D4: 7CAB4A14  add r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CEE0D8: 54A4103A  slwi r4, r5, 2
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CEE0DC: 7C64302E  lwzx r3, r4, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82CEE0E0: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	pc = 0x82CEE0E4; continue 'dispatch;
            }
            0x82CEE0E4 => {
    //   block [0x82CEE0E4..0x82CEE0EC)
	// 82CEE0E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEE0E8: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82CEE0EC; continue 'dispatch;
            }
            0x82CEE0EC => {
    //   block [0x82CEE0EC..0x82CEE104)
	// 82CEE0EC: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CEE0F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEE0F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CEE0F8: 4E800421  bctrl
	ctx.lr = 0x82CEE0FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEE0FC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEE100: 7C7E5050  subf r3, r30, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[30].s64;
            }
            0x82CEE104 => {
    //   block [0x82CEE104..0x82CEE11C)
	// 82CEE104: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEE108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEE10C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEE110: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEE114: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEE118: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEE120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEE120 size=508
    let mut pc: u32 = 0x82CEE120;
    'dispatch: loop {
        match pc {
            0x82CEE120 => {
    //   block [0x82CEE120..0x82CEE31C)
	// 82CEE120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEE124: 4BFBB2E9  bl 0x82ca940c
	ctx.lr = 0x82CEE128;
	sub_82CA93D0(ctx, base);
	// 82CEE128: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEE12C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CEE130: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEE134: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEE138: 7C001A2C  dcbt 0, r3
	// 82CEE13C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEE140: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEE144: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEE148: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEE14C: C15F002C  lfs f10, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEE150: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CEE154: 38EA6880  addi r7, r10, 0x6880
	ctx.r[7].s64 = ctx.r[10].s64 + 26752;
	// 82CEE158: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEE15C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82CEE160: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CEE164: C8096878  lfd f0, 0x6878(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(26744 as u32) ) };
	// 82CEE168: FC805E9C  fcfid f4, f11
	ctx.f[4].f64 = (ctx.f[11].s64 as f64);
	// 82CEE16C: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEE320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEE320 size=560
    let mut pc: u32 = 0x82CEE320;
    'dispatch: loop {
        match pc {
            0x82CEE320 => {
    //   block [0x82CEE320..0x82CEE550)
	// 82CEE320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEE324: 4BFBB0E5  bl 0x82ca9408
	ctx.lr = 0x82CEE328;
	sub_82CA93D0(ctx, base);
	// 82CEE328: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEE32C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82CEE330: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEE334: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEE338: 7C001A2C  dcbt 0, r3
	// 82CEE33C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEE340: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEE344: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEE348: C15E002C  lfs f10, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEE34C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEE350: D1BE0024  stfs f13, 0x24(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEE354: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CEE358: C13E0030  lfs f9, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CEE35C: 38EA6880  addi r7, r10, 0x6880
	ctx.r[7].s64 = ctx.r[10].s64 + 26752;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEE550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEE550 size=664
    let mut pc: u32 = 0x82CEE550;
    'dispatch: loop {
        match pc {
            0x82CEE550 => {
    //   block [0x82CEE550..0x82CEE7E8)
	// 82CEE550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEE554: 4BFBAE9D  bl 0x82ca93f0
	ctx.lr = 0x82CEE558;
	sub_82CA93D0(ctx, base);
	// 82CEE558: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEE55C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82CEE560: C01A0024  lfs f0, 0x24(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEE564: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEE568: 7C001A2C  dcbt 0, r3
	// 82CEE56C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEE570: C1BA0028  lfs f13, 0x28(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEE574: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEE578: C17A002C  lfs f11, 0x2c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEE57C: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CEE580: C15A0030  lfs f10, 0x30(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEE584: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CEE588: D1BA0024  stfs f13, 0x24(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEE58C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEE590: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEE594: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEE598: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEE59C: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEE5A0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82CEE5A4: 38E96880  addi r7, r9, 0x6880
	ctx.r[7].s64 = ctx.r[9].s64 + 26752;
	// 82CEE5A8: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEE7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEE7E8 size=784
    let mut pc: u32 = 0x82CEE7E8;
    'dispatch: loop {
        match pc {
            0x82CEE7E8 => {
    //   block [0x82CEE7E8..0x82CEEAF8)
	// 82CEE7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEE7EC: 4BFBABE9  bl 0x82ca93d4
	ctx.lr = 0x82CEE7F0;
	sub_82CA93D0(ctx, base);
	// 82CEE7F0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEE7F4: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 82CEE7F8: C0140024  lfs f0, 0x24(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEE7FC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEE800: 7C001A2C  dcbt 0, r3
	// 82CEE804: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEE808: C1B40028  lfs f13, 0x28(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEE80C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEE810: C174002C  lfs f11, 0x2c(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEE814: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CEE818: C1540030  lfs f10, 0x30(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEE81C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CEE820: D1B40024  stfs f13, 0x24(r20)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEE824: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEEAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEEAF8 size=788
    let mut pc: u32 = 0x82CEEAF8;
    'dispatch: loop {
        match pc {
            0x82CEEAF8 => {
    //   block [0x82CEEAF8..0x82CEEE0C)
	// 82CEEAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEEAFC: 4BFBA90D  bl 0x82ca9408
	ctx.lr = 0x82CEEB00;
	sub_82CA93D0(ctx, base);
	// 82CEEB00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEEB04: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CEEB08: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEEB0C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEEB10: 7C001A2C  dcbt 0, r3
	// 82CEEB14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEEB18: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEEB1C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEEB20: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEEB24: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEEB28: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEEB2C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEEB30: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEEB34: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEEB38: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEEB3C: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEEB40: 396968B0  addi r11, r9, 0x68b0
	ctx.r[11].s64 = ctx.r[9].s64 + 26800;
	// 82CEEB44: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CEEB48: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CEEB4C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CEEB50: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEEB54: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 82CEEB58: 1007030C  vspltisb v0, 7
	for i in 0..16 {
		ctx.v[0].u8[i] = 7 as u8;
	}
	// 82CEEB5C: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEEE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEEE10 size=1008
    let mut pc: u32 = 0x82CEEE10;
    'dispatch: loop {
        match pc {
            0x82CEEE10 => {
    //   block [0x82CEEE10..0x82CEF200)
	// 82CEEE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEEE14: 4BFBA5DD  bl 0x82ca93f0
	ctx.lr = 0x82CEEE18;
	sub_82CA93D0(ctx, base);
	// 82CEEE18: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEEE1C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82CEEE20: C01C0024  lfs f0, 0x24(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEEE24: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEEE28: 7C001A2C  dcbt 0, r3
	// 82CEEE2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEEE30: C1BC0028  lfs f13, 0x28(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEEE34: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEEE38: C15C0030  lfs f10, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEEE3C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEEE40: D1BC0024  stfs f13, 0x24(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEEE44: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEEE48: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEEE4C: 394968B0  addi r10, r9, 0x68b0
	ctx.r[10].s64 = ctx.r[9].s64 + 26800;
	// 82CEEE50: C17C002C  lfs f11, 0x2c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEEE54: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEEE58: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEEE5C: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CEEE60: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CEEE64: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CEEE68: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEEE6C: 392868A0  addi r9, r8, 0x68a0
	ctx.r[9].s64 = ctx.r[8].s64 + 26784;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEF200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEF200 size=1520
    let mut pc: u32 = 0x82CEF200;
    'dispatch: loop {
        match pc {
            0x82CEF200 => {
    //   block [0x82CEF200..0x82CEF7F0)
	// 82CEF200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEF204: 4BFBA1CD  bl 0x82ca93d0
	ctx.lr = 0x82CEF208;
	sub_82CA93D0(ctx, base);
	// 82CEF208: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEF20C: C0070024  lfs f0, 0x24(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEF210: 90C1016C  stw r6, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[6].u32 ) };
	// 82CEF214: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEF218: 90E10174  stw r7, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[7].u32 ) };
	// 82CEF21C: 7C001A2C  dcbt 0, r3
	// 82CEF220: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEF224: C1A70028  lfs f13, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEF228: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEF22C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEF230: C1470030  lfs f10, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEF234: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEF238: D1A70024  stfs f13, 0x24(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEF23C: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CEF240: C167002C  lfs f11, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEF244: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEF248: 388968B0  addi r4, r9, 0x68b0
	ctx.r[4].s64 = ctx.r[9].s64 + 26800;
	// 82CEF24C: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CEF250: 39266880  addi r9, r6, 0x6880
	ctx.r[9].s64 = ctx.r[6].s64 + 26752;
	// 82CEF254: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEF258: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CEF25C: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEF260: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 82CEF264: 39476890  addi r10, r7, 0x6890
	ctx.r[10].s64 = ctx.r[7].s64 + 26768;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEF7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEF7F0 size=2124
    let mut pc: u32 = 0x82CEF7F0;
    'dispatch: loop {
        match pc {
            0x82CEF7F0 => {
    //   block [0x82CEF7F0..0x82CF003C)
	// 82CEF7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEF7F4: 4BFB9BDD  bl 0x82ca93d0
	ctx.lr = 0x82CEF7F8;
	sub_82CA93D0(ctx, base);
	// 82CEF7F8: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEF7FC: C0070024  lfs f0, 0x24(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEF800: 90C101CC  stw r6, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[6].u32 ) };
	// 82CEF804: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82CEF808: 90E101D4  stw r7, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[7].u32 ) };
	// 82CEF80C: 7C001A2C  dcbt 0, r3
	// 82CEF810: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEF814: C1A70028  lfs f13, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEF818: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEF81C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEF820: C1470030  lfs f10, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEF824: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEF828: C167002C  lfs f11, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEF82C: 38C968B0  addi r6, r9, 0x68b0
	ctx.r[6].s64 = ctx.r[9].s64 + 26800;
	// 82CEF830: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEF834: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEF838: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEF83C: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CEF840: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 82CEF844: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEF848: 388868A0  addi r4, r8, 0x68a0
	ctx.r[4].s64 = ctx.r[8].s64 + 26784;
	// 82CEF84C: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82CEF850: D1A70024  stfs f13, 0x24(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEF854: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF0040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CF0040 size=644
    let mut pc: u32 = 0x82CF0040;
    'dispatch: loop {
        match pc {
            0x82CF0040 => {
    //   block [0x82CF0040..0x82CF02C4)
	// 82CF0040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF0044: 4BFB93C5  bl 0x82ca9408
	ctx.lr = 0x82CF0048;
	sub_82CA93D0(ctx, base);
	// 82CF0048: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CF004C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CF0050: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF0054: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CF0058: 7C001A2C  dcbt 0, r3
	// 82CF005C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF0060: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF0064: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF0068: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF006C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CF0070: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF0074: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CF0078: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF007C: 38886880  addi r4, r8, 0x6880
	ctx.r[4].s64 = ctx.r[8].s64 + 26752;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF02C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CF02C8 size=744
    let mut pc: u32 = 0x82CF02C8;
    'dispatch: loop {
        match pc {
            0x82CF02C8 => {
    //   block [0x82CF02C8..0x82CF05B0)
	// 82CF02C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF02CC: 4BFB9135  bl 0x82ca9400
	ctx.lr = 0x82CF02D0;
	sub_82CA93D0(ctx, base);
	// 82CF02D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CF02D4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82CF02D8: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF02DC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CF02E0: 7C001A2C  dcbt 0, r3
	// 82CF02E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF02E8: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF02EC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CF02F0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF02F4: C17E002C  lfs f11, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF02F8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CF02FC: 38E96890  addi r7, r9, 0x6890
	ctx.r[7].s64 = ctx.r[9].s64 + 26768;
	// 82CF0300: D1BE0024  stfs f13, 0x24(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF0304: 38886880  addi r4, r8, 0x6880
	ctx.r[4].s64 = ctx.r[8].s64 + 26752;
	// 82CF0308: C15E0030  lfs f10, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF030C: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CF0310: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CF0314: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CF0318: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82CF031C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF0320: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF05B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CF05B0 size=956
    let mut pc: u32 = 0x82CF05B0;
    'dispatch: loop {
        match pc {
            0x82CF05B0 => {
    //   block [0x82CF05B0..0x82CF096C)
	// 82CF05B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF05B4: 4BFB8E2D  bl 0x82ca93e0
	ctx.lr = 0x82CF05B8;
	sub_82CA93D0(ctx, base);
	// 82CF05B8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CF05BC: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82CF05C0: C0180024  lfs f0, 0x24(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF05C4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CF05C8: 7C001A2C  dcbt 0, r3
	// 82CF05CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF05D0: C1B80028  lfs f13, 0x28(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF05D4: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF05D8: C178002C  lfs f11, 0x2c(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF05DC: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 82CF05E0: F8810068  std r4, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u64 ) };
	// 82CF05E4: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CF05E8: C1580030  lfs f10, 0x30(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF05EC: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82CF05F0: D1B80024  stfs f13, 0x24(r24)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF05F4: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CF05F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF05FC: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CF0600: 3FA08204  lis r29, -0x7dfc
	ctx.r[29].s64 = -2113667072;
	// 82CF0604: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CF0608: 388B6890  addi r4, r11, 0x6890
	ctx.r[4].s64 = ctx.r[11].s64 + 26768;
	// 82CF060C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF0970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CF0970 size=1212
    let mut pc: u32 = 0x82CF0970;
    'dispatch: loop {
        match pc {
            0x82CF0970 => {
    //   block [0x82CF0970..0x82CF0E2C)
	// 82CF0970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF0974: 4BFB8A5D  bl 0x82ca93d0
	ctx.lr = 0x82CF0978;
	sub_82CA93D0(ctx, base);
	// 82CF0978: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CF097C: C0070024  lfs f0, 0x24(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF0980: 90C1013C  stw r6, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[6].u32 ) };
	// 82CF0984: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CF0988: 90E10144  stw r7, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[7].u32 ) };
	// 82CF098C: 7C001A2C  dcbt 0, r3
	// 82CF0990: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF0994: C1A70028  lfs f13, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF0998: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 82CF099C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF09A0: C167002C  lfs f11, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF09A4: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82CF09A8: C1470030  lfs f10, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF09AC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF0E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF0E30 size=876
    let mut pc: u32 = 0x82CF0E30;
    'dispatch: loop {
        match pc {
            0x82CF0E30 => {
    //   block [0x82CF0E30..0x82CF119C)
	// 82CF0E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF0E34: 4BFB85A9  bl 0x82ca93dc
	ctx.lr = 0x82CF0E38;
	sub_82CA93D0(ctx, base);
	// 82CF0E38: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF0E3C: 3B03000D  addi r24, r3, 0xd
	ctx.r[24].s64 = ctx.r[3].s64 + 13;
	// 82CF0E40: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF0E44: 3A830008  addi r20, r3, 8
	ctx.r[20].s64 = ctx.r[3].s64 + 8;
	// 82CF0E48: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF0E4C: 3A23001C  addi r17, r3, 0x1c
	ctx.r[17].s64 = ctx.r[3].s64 + 28;
	// 82CF0E50: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF0E54: 7D2551D6  mullw r9, r5, r10
	ctx.r[9].s32 = ((ctx.r[5].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF0E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF0E5C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF0E60: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF0E64: 7FE43050  subf r31, r4, r6
	ctx.r[31].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF0E68: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF0E6C: 5487103A  slwi r7, r4, 2
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF0E70: 93E1FF70  stw r31, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[31].u32 ) };
	// 82CF0E74: 3A430018  addi r18, r3, 0x18
	ctx.r[18].s64 = ctx.r[3].s64 + 24;
	// 82CF0E78: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82CF0E7C: 3A630014  addi r19, r3, 0x14
	ctx.r[19].s64 = ctx.r[3].s64 + 20;
	// 82CF0E80: 3B630034  addi r27, r3, 0x34
	ctx.r[27].s64 = ctx.r[3].s64 + 52;
	// 82CF0E84: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF0E88: 7F25F050  subf r25, r5, r30
	ctx.r[25].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF0E8C: 7C874214  add r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF0E90: 7C00322C  dcbt 0, r6
	// 82CF0E94: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CF0E98: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF0E9C: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 82CF0EA0: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF0EA4: 790507E6  rldicr r5, r8, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[8].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF0EA8: 38E1FF70  addi r7, r1, -0x90
	ctx.r[7].s64 = ctx.r[1].s64 + -144;
	// 82CF0EAC: F8A1FF78  std r5, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[5].u64 ) };
	// 82CF0EB0: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF0EB4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF0EB8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82CF0EBC: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF0EC0: 13834C07  vcmpneb. (lvlx128) v28, v3, v9
	tmp.u32 = ctx.r[3].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF0EC4: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 82CF0EC8: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF11A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF11A0 size=736
    let mut pc: u32 = 0x82CF11A0;
    'dispatch: loop {
        match pc {
            0x82CF11A0 => {
    //   block [0x82CF11A0..0x82CF1480)
	// 82CF11A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF11A4: 4BFB823D  bl 0x82ca93e0
	ctx.lr = 0x82CF11A8;
	sub_82CA93D0(ctx, base);
	// 82CF11A8: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF11AC: 3AE30008  addi r23, r3, 8
	ctx.r[23].s64 = ctx.r[3].s64 + 8;
	// 82CF11B0: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF11B4: 3BA3000D  addi r29, r3, 0xd
	ctx.r[29].s64 = ctx.r[3].s64 + 13;
	// 82CF11B8: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF11BC: 3A83001C  addi r20, r3, 0x1c
	ctx.r[20].s64 = ctx.r[3].s64 + 28;
	// 82CF11C0: 7CC429D6  mullw r6, r4, r5
	ctx.r[6].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82CF11C4: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF11C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF11CC: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF11D0: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF11D4: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF11D8: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF11DC: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82CF11E0: 3AA30018  addi r21, r3, 0x18
	ctx.r[21].s64 = ctx.r[3].s64 + 24;
	// 82CF11E4: 3B830004  addi r28, r3, 4
	ctx.r[28].s64 = ctx.r[3].s64 + 4;
	// 82CF11E8: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF11EC: 3AC30014  addi r22, r3, 0x14
	ctx.r[22].s64 = ctx.r[3].s64 + 20;
	// 82CF11F0: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82CF11F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF11F8: 7F252050  subf r25, r5, r4
	ctx.r[25].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82CF11FC: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82CF1200: 7C004A2C  dcbt 0, r9
	// 82CF1204: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF1208: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF120C: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF1210: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF1214: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF1218: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF121C: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF1220: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF1224: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF1228: 3BC1FF70  addi r30, r1, -0x90
	ctx.r[30].s64 = ctx.r[1].s64 + -144;
	// 82CF122C: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF1230: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF1234: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF1238: C80B0CB8  lfd f0, 0xcb8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF1480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF1480 size=808
    let mut pc: u32 = 0x82CF1480;
    'dispatch: loop {
        match pc {
            0x82CF1480 => {
    //   block [0x82CF1480..0x82CF17A8)
	// 82CF1480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF1484: 4BFB7F5D  bl 0x82ca93e0
	ctx.lr = 0x82CF1488;
	sub_82CA93D0(ctx, base);
	// 82CF1488: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF148C: 3AA30008  addi r21, r3, 8
	ctx.r[21].s64 = ctx.r[3].s64 + 8;
	// 82CF1490: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF1494: 3B63000D  addi r27, r3, 0xd
	ctx.r[27].s64 = ctx.r[3].s64 + 13;
	// 82CF1498: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF149C: 3A43001C  addi r18, r3, 0x1c
	ctx.r[18].s64 = ctx.r[3].s64 + 28;
	// 82CF14A0: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF14A4: 7C8429D6  mullw r4, r4, r5
	ctx.r[4].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF14A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF14AC: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF14B0: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF14B4: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF14B8: 7CC83050  subf r6, r8, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 82CF14BC: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF14C0: 3A630018  addi r19, r3, 0x18
	ctx.r[19].s64 = ctx.r[3].s64 + 24;
	// 82CF14C4: 90C1FF70  stw r6, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[6].u32 ) };
	// 82CF14C8: 3B430004  addi r26, r3, 4
	ctx.r[26].s64 = ctx.r[3].s64 + 4;
	// 82CF14CC: 3A830014  addi r20, r3, 0x14
	ctx.r[20].s64 = ctx.r[3].s64 + 20;
	// 82CF14D0: 3BA30034  addi r29, r3, 0x34
	ctx.r[29].s64 = ctx.r[3].s64 + 52;
	// 82CF14D4: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF14D8: 7EC5F850  subf r22, r5, r31
	ctx.r[22].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF14DC: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF14E0: 7C00422C  dcbt 0, r8
	// 82CF14E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF14E8: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF14EC: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 82CF14F0: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF14F4: 796707E6  rldicr r7, r11, 0x20, 0x3f
	ctx.r[7].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF14F8: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF14FC: F8E1FF78  std r7, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[7].u64 ) };
	// 82CF1500: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF1504: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF1508: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CF150C: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF1510: 13832C07  vcmpneb. (lvlx128) v28, v3, v5
	tmp.u32 = ctx.r[3].u32 + ctx.r[5].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF1514: 38A1FF70  addi r5, r1, -0x90
	ctx.r[5].s64 = ctx.r[1].s64 + -144;
	// 82CF1518: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF17A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF17A8 size=1012
    let mut pc: u32 = 0x82CF17A8;
    'dispatch: loop {
        match pc {
            0x82CF17A8 => {
    //   block [0x82CF17A8..0x82CF1B9C)
	// 82CF17A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF17AC: 4BFB7C2D  bl 0x82ca93d8
	ctx.lr = 0x82CF17B0;
	sub_82CA93D0(ctx, base);
	// 82CF17B0: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 82CF17B4: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF17B8: 3923001C  addi r9, r3, 0x1c
	ctx.r[9].s64 = ctx.r[3].s64 + 28;
	// 82CF17BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17C0: 9141FF64  stw r10, -0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), ctx.r[10].u32 ) };
	// 82CF17C4: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 82CF17C8: 9121FF50  stw r9, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[9].u32 ) };
	// 82CF17CC: 3AE3000D  addi r23, r3, 0xd
	ctx.r[23].s64 = ctx.r[3].s64 + 13;
	// 82CF17D0: 9101FF68  stw r8, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u32 ) };
	// 82CF17D4: 3AC30004  addi r22, r3, 4
	ctx.r[22].s64 = ctx.r[3].s64 + 4;
	// 82CF17D8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17DC: 39430014  addi r10, r3, 0x14
	ctx.r[10].s64 = ctx.r[3].s64 + 20;
	// 82CF17E0: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17E4: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82CF17E8: 7CA639D6  mullw r5, r6, r7
	ctx.r[5].s32 = ((ctx.r[6].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF17EC: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17F0: 9141FF60  stw r10, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[10].u32 ) };
	// 82CF17F4: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF17F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17FC: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF1800: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF1804: 7CA43050  subf r5, r4, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF1808: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF180C: 90A1FF58  stw r5, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[5].u32 ) };
	// 82CF1810: 7E67F050  subf r19, r7, r30
	ctx.r[19].s64 = ctx.r[30].s64 - ctx.r[7].s64;
	// 82CF1814: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF1818: 7C005A2C  dcbt 0, r11
	// 82CF181C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CF1820: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF1824: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82CF1828: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF182C: 788807E6  rldicr r8, r4, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[4].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF1830: 3921FF58  addi r9, r1, -0xa8
	ctx.r[9].s64 = ctx.r[1].s64 + -168;
	// 82CF1834: F901FF70  std r8, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[8].u64 ) };
	// 82CF1838: C981FF70  lfd f12, -0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82CF183C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF1840: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF1844: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF1848: 13833C07  vcmpneb. (lvlx128) v28, v3, v7
	tmp.u32 = ctx.r[3].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF184C: 38E1FF58  addi r7, r1, -0xa8
	ctx.r[7].s64 = ctx.r[1].s64 + -168;
	// 82CF1850: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF1BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF1BA0 size=1280
    let mut pc: u32 = 0x82CF1BA0;
    'dispatch: loop {
        match pc {
            0x82CF1BA0 => {
    //   block [0x82CF1BA0..0x82CF20A0)
	// 82CF1BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF1BA4: 4BFB783D  bl 0x82ca93e0
	ctx.lr = 0x82CF1BA8;
	sub_82CA93D0(ctx, base);
	// 82CF1BA8: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82CF1BAC: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF1BB0: 3903001C  addi r8, r3, 0x1c
	ctx.r[8].s64 = ctx.r[3].s64 + 28;
	// 82CF1BB4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BB8: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82CF1BBC: 9121FF6C  stw r9, -0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-148 as u32), ctx.r[9].u32 ) };
	// 82CF1BC0: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 82CF1BC4: 9101FF5C  stw r8, -0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-164 as u32), ctx.r[8].u32 ) };
	// 82CF1BC8: 90E1FF60  stw r7, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[7].u32 ) };
	// 82CF1BCC: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BD0: 39230014  addi r9, r3, 0x14
	ctx.r[9].s64 = ctx.r[3].s64 + 20;
	// 82CF1BD4: 90C1FF70  stw r6, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[6].u32 ) };
	// 82CF1BD8: 7CAB21D6  mullw r5, r11, r4
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF1BDC: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BE0: 80C60000  lwz r6, 0(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BE4: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BE8: 9121FF68  stw r9, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[9].u32 ) };
	// 82CF1BEC: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BF0: 3963000D  addi r11, r3, 0xd
	ctx.r[11].s64 = ctx.r[3].s64 + 13;
	// 82CF1BF4: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF1BF8: 7CE4F050  subf r7, r4, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[4].s64;
	// 82CF1BFC: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF1C00: 7CBF3050  subf r5, r31, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[31].s64;
	// 82CF1C04: 90E1FF58  stw r7, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[7].u32 ) };
	// 82CF1C08: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF1C0C: 90A1FF50  stw r5, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[5].u32 ) };
	// 82CF1C10: 38830034  addi r4, r3, 0x34
	ctx.r[4].s64 = ctx.r[3].s64 + 52;
	// 82CF1C14: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF1C18: 7C005A2C  dcbt 0, r11
	// 82CF1C1C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF1C20: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF1C24: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 82CF1C28: 78C807E6  rldicr r8, r6, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF1C2C: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 82CF1C30: 9121FF64  stw r9, -0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), ctx.r[9].u32 ) };
	// 82CF1C34: F901FF78  std r8, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[8].u64 ) };
	// 82CF1C38: C9A1FF78  lfd f13, -0x88(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF1C3C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CF1C40: 38E1FF50  addi r7, r1, -0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + -176;
	// 82CF1C44: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF1C48: FD400332  fmul f10, f0, f12
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[12].f64;
	// 82CF1C4C: FD2B0332  fmul f9, f11, f12
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82CF1C50: 13A33407  vcmpneb. (lvlx128) v29, v3, v6
	tmp.u32 = ctx.r[3].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF1C54: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF1C58: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF1C5C: 3BE1FF78  addi r31, r1, -0x88
	ctx.r[31].s64 = ctx.r[1].s64 + -136;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF20A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF20A0 size=936
    let mut pc: u32 = 0x82CF20A0;
    'dispatch: loop {
        match pc {
            0x82CF20A0 => {
    //   block [0x82CF20A0..0x82CF2448)
	// 82CF20A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF20A4: 4BFB7339  bl 0x82ca93dc
	ctx.lr = 0x82CF20A8;
	sub_82CA93D0(ctx, base);
	// 82CF20A8: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF20AC: 3B03000D  addi r24, r3, 0xd
	ctx.r[24].s64 = ctx.r[3].s64 + 13;
	// 82CF20B0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF20B4: 3A830008  addi r20, r3, 8
	ctx.r[20].s64 = ctx.r[3].s64 + 8;
	// 82CF20B8: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF20BC: 3A23001C  addi r17, r3, 0x1c
	ctx.r[17].s64 = ctx.r[3].s64 + 28;
	// 82CF20C0: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF20C4: 7D2A29D6  mullw r9, r10, r5
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF20C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF20CC: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF20D0: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF20D4: 7FE43050  subf r31, r4, r6
	ctx.r[31].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF20D8: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF20DC: 5487103A  slwi r7, r4, 2
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF20E0: 93E1FF70  stw r31, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[31].u32 ) };
	// 82CF20E4: 3A430018  addi r18, r3, 0x18
	ctx.r[18].s64 = ctx.r[3].s64 + 24;
	// 82CF20E8: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82CF20EC: 3A630014  addi r19, r3, 0x14
	ctx.r[19].s64 = ctx.r[3].s64 + 20;
	// 82CF20F0: 3B430034  addi r26, r3, 0x34
	ctx.r[26].s64 = ctx.r[3].s64 + 52;
	// 82CF20F4: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF20F8: 7F25F050  subf r25, r5, r30
	ctx.r[25].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF20FC: 7C874214  add r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF2100: 7C00322C  dcbt 0, r6
	// 82CF2104: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CF2108: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF210C: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 82CF2110: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF2114: 790507E6  rldicr r5, r8, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[8].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF2118: 38E1FF70  addi r7, r1, -0x90
	ctx.r[7].s64 = ctx.r[1].s64 + -144;
	// 82CF211C: F8A1FF78  std r5, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[5].u64 ) };
	// 82CF2120: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF2124: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF2128: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82CF212C: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF2130: 13834C07  vcmpneb. (lvlx128) v28, v3, v9
	tmp.u32 = ctx.r[3].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF2134: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 82CF2138: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF2448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF2448 size=792
    let mut pc: u32 = 0x82CF2448;
    'dispatch: loop {
        match pc {
            0x82CF2448 => {
    //   block [0x82CF2448..0x82CF2760)
	// 82CF2448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF244C: 4BFB6F95  bl 0x82ca93e0
	ctx.lr = 0x82CF2450;
	sub_82CA93D0(ctx, base);
	// 82CF2450: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF2454: 3AE30008  addi r23, r3, 8
	ctx.r[23].s64 = ctx.r[3].s64 + 8;
	// 82CF2458: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF245C: 3BA3000D  addi r29, r3, 0xd
	ctx.r[29].s64 = ctx.r[3].s64 + 13;
	// 82CF2460: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF2464: 3A83001C  addi r20, r3, 0x1c
	ctx.r[20].s64 = ctx.r[3].s64 + 28;
	// 82CF2468: 7CC429D6  mullw r6, r4, r5
	ctx.r[6].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82CF246C: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF2470: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2474: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF2478: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF247C: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF2480: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF2484: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82CF2488: 3AA30018  addi r21, r3, 0x18
	ctx.r[21].s64 = ctx.r[3].s64 + 24;
	// 82CF248C: 3B830004  addi r28, r3, 4
	ctx.r[28].s64 = ctx.r[3].s64 + 4;
	// 82CF2490: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF2494: 3AC30014  addi r22, r3, 0x14
	ctx.r[22].s64 = ctx.r[3].s64 + 20;
	// 82CF2498: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82CF249C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF24A0: 7F252050  subf r25, r5, r4
	ctx.r[25].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82CF24A4: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82CF24A8: 7C004A2C  dcbt 0, r9
	// 82CF24AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF24B0: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF24B4: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF24B8: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF24BC: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF24C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF24C4: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF24C8: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF24CC: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF24D0: 3BC1FF70  addi r30, r1, -0x90
	ctx.r[30].s64 = ctx.r[1].s64 + -144;
	// 82CF24D4: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF24D8: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF24DC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF24E0: C80B0CB8  lfd f0, 0xcb8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF2760 size=916
    let mut pc: u32 = 0x82CF2760;
    'dispatch: loop {
        match pc {
            0x82CF2760 => {
    //   block [0x82CF2760..0x82CF2AF4)
	// 82CF2760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF2764: 4BFB6C7D  bl 0x82ca93e0
	ctx.lr = 0x82CF2768;
	sub_82CA93D0(ctx, base);
	// 82CF2768: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF276C: 3AA30008  addi r21, r3, 8
	ctx.r[21].s64 = ctx.r[3].s64 + 8;
	// 82CF2770: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF2774: 3B63000D  addi r27, r3, 0xd
	ctx.r[27].s64 = ctx.r[3].s64 + 13;
	// 82CF2778: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF277C: 3A43001C  addi r18, r3, 0x1c
	ctx.r[18].s64 = ctx.r[3].s64 + 28;
	// 82CF2780: 7CC429D6  mullw r6, r4, r5
	ctx.r[6].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82CF2784: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF2788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF278C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF2790: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF2794: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF2798: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF279C: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82CF27A0: 3A630018  addi r19, r3, 0x18
	ctx.r[19].s64 = ctx.r[3].s64 + 24;
	// 82CF27A4: 3B430004  addi r26, r3, 4
	ctx.r[26].s64 = ctx.r[3].s64 + 4;
	// 82CF27A8: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF27AC: 3A830014  addi r20, r3, 0x14
	ctx.r[20].s64 = ctx.r[3].s64 + 20;
	// 82CF27B0: 3BA30034  addi r29, r3, 0x34
	ctx.r[29].s64 = ctx.r[3].s64 + 52;
	// 82CF27B4: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF27B8: 7EC52050  subf r22, r5, r4
	ctx.r[22].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82CF27BC: 7D264A14  add r9, r6, r9
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 82CF27C0: 7C00422C  dcbt 0, r8
	// 82CF27C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF27C8: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF27CC: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF27D0: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF27D4: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF27D8: 3B81FF70  addi r28, r1, -0x90
	ctx.r[28].s64 = ctx.r[1].s64 + -144;
	// 82CF27DC: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF27E0: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF27E4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF27E8: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 82CF27EC: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF27F0: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF27F4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF2AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF2AF8 size=1220
    let mut pc: u32 = 0x82CF2AF8;
    'dispatch: loop {
        match pc {
            0x82CF2AF8 => {
    //   block [0x82CF2AF8..0x82CF2FBC)
	// 82CF2AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF2AFC: 4BFB68E1  bl 0x82ca93dc
	ctx.lr = 0x82CF2B00;
	sub_82CA93D0(ctx, base);
	// 82CF2B00: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 82CF2B04: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF2B08: 3923001C  addi r9, r3, 0x1c
	ctx.r[9].s64 = ctx.r[3].s64 + 28;
	// 82CF2B0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B10: 9141FF64  stw r10, -0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), ctx.r[10].u32 ) };
	// 82CF2B14: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 82CF2B18: 9121FF50  stw r9, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[9].u32 ) };
	// 82CF2B1C: 3B03000D  addi r24, r3, 0xd
	ctx.r[24].s64 = ctx.r[3].s64 + 13;
	// 82CF2B20: 9101FF68  stw r8, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u32 ) };
	// 82CF2B24: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82CF2B28: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B2C: 39430014  addi r10, r3, 0x14
	ctx.r[10].s64 = ctx.r[3].s64 + 20;
	// 82CF2B30: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B34: 7CA639D6  mullw r5, r6, r7
	ctx.r[5].s32 = ((ctx.r[6].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF2B38: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B3C: 9141FF60  stw r10, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[10].u32 ) };
	// 82CF2B40: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF2B44: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B48: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF2B4C: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF2B50: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF2B54: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF2B58: 90C1FF58  stw r6, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[6].u32 ) };
	// 82CF2B5C: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF2B60: 7E87F850  subf r20, r7, r31
	ctx.r[20].s64 = ctx.r[31].s64 - ctx.r[7].s64;
	// 82CF2B64: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF2B68: 7C005A2C  dcbt 0, r11
	// 82CF2B6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CF2B70: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF2B74: 3921FF58  addi r9, r1, -0xa8
	ctx.r[9].s64 = ctx.r[1].s64 + -168;
	// 82CF2B78: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF2B7C: 788807E6  rldicr r8, r4, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[4].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF2B80: 3B61FF58  addi r27, r1, -0xa8
	ctx.r[27].s64 = ctx.r[1].s64 + -168;
	// 82CF2B84: F901FF70  std r8, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[8].u64 ) };
	// 82CF2B88: C981FF70  lfd f12, -0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82CF2B8C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF2B90: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CF2B94: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF2B98: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF2FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF2FC0 size=1572
    let mut pc: u32 = 0x82CF2FC0;
    'dispatch: loop {
        match pc {
            0x82CF2FC0 => {
    //   block [0x82CF2FC0..0x82CF35E4)
	// 82CF2FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF2FC4: 4BFB6415  bl 0x82ca93d8
	ctx.lr = 0x82CF2FC8;
	sub_82CA93D0(ctx, base);
	// 82CF2FC8: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82CF2FCC: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF2FD0: 3903001C  addi r8, r3, 0x1c
	ctx.r[8].s64 = ctx.r[3].s64 + 28;
	// 82CF2FD4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2FD8: 38A30018  addi r5, r3, 0x18
	ctx.r[5].s64 = ctx.r[3].s64 + 24;
	// 82CF2FDC: 9121FF5C  stw r9, -0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-164 as u32), ctx.r[9].u32 ) };
	// 82CF2FE0: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82CF2FE4: 9101FF4C  stw r8, -0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-180 as u32), ctx.r[8].u32 ) };
	// 82CF2FE8: 90A1FF60  stw r5, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[5].u32 ) };
	// 82CF2FEC: 3963000D  addi r11, r3, 0xd
	ctx.r[11].s64 = ctx.r[3].s64 + 13;
	// 82CF2FF0: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2FF4: 39230014  addi r9, r3, 0x14
	ctx.r[9].s64 = ctx.r[3].s64 + 20;
	// 82CF2FF8: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2FFC: 7C8431D6  mullw r4, r4, r6
	ctx.r[4].s32 = ((ctx.r[4].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF3000: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF3004: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF3008: 9121FF58  stw r9, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[9].u32 ) };
	// 82CF300C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF3010: 90E1FF50  stw r7, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[7].u32 ) };
	// 82CF3014: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF3018: 7C86F050  subf r4, r6, r30
	ctx.r[4].s64 = ctx.r[30].s64 - ctx.r[6].s64;
	// 82CF301C: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF3020: 7CBF2850  subf r5, r31, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 82CF3024: 9081FF48  stw r4, -0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-184 as u32), ctx.r[4].u32 ) };
	// 82CF3028: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF302C: 90A1FF40  stw r5, -0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-192 as u32), ctx.r[5].u32 ) };
	// 82CF3030: 38C30034  addi r6, r3, 0x34
	ctx.r[6].s64 = ctx.r[3].s64 + 52;
	// 82CF3034: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF3038: 7C005A2C  dcbt 0, r11
	// 82CF303C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CF3040: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF3044: 39030030  addi r8, r3, 0x30
	ctx.r[8].s64 = ctx.r[3].s64 + 48;
	// 82CF3048: 792707E6  rldicr r7, r9, 0x20, 0x3f
	ctx.r[7].u64 = (ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF304C: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 82CF3050: 9101FF54  stw r8, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[8].u32 ) };
	// 82CF3054: F8E1FF68  std r7, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[7].u64 ) };
	// 82CF3058: C9A1FF68  lfd f13, -0x98(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82CF305C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CF3060: 3881FF40  addi r4, r1, -0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + -192;
	// 82CF3064: C1680000  lfs f11, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF3068: 39030024  addi r8, r3, 0x24
	ctx.r[8].s64 = ctx.r[3].s64 + 36;
	// 82CF306C: FD4B0332  fmul f10, f11, f12
	ctx.f[10].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82CF3070: 13A34C07  vcmpneb. (lvlx128) v29, v3, v9
	tmp.u32 = ctx.r[3].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3074: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82CF3078: 13E02407  vcmpneb. (lvlx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF307C: 3BE1FF40  addi r31, r1, -0xc0
	ctx.r[31].s64 = ctx.r[1].s64 + -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF35E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF35E8 size=936
    let mut pc: u32 = 0x82CF35E8;
    'dispatch: loop {
        match pc {
            0x82CF35E8 => {
    //   block [0x82CF35E8..0x82CF3990)
	// 82CF35E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF35EC: 4BFB5DF5  bl 0x82ca93e0
	ctx.lr = 0x82CF35F0;
	sub_82CA93D0(ctx, base);
	// 82CF35F0: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF35F4: 3B43000D  addi r26, r3, 0xd
	ctx.r[26].s64 = ctx.r[3].s64 + 13;
	// 82CF35F8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF35FC: 3AA30008  addi r21, r3, 8
	ctx.r[21].s64 = ctx.r[3].s64 + 8;
	// 82CF3600: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF3604: 3A43001C  addi r18, r3, 0x1c
	ctx.r[18].s64 = ctx.r[3].s64 + 28;
	// 82CF3608: 80A30018  lwz r5, 0x18(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF360C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF3610: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF3614: 7D4459D6  mullw r10, r4, r11
	ctx.r[10].s32 = ((ctx.r[4].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF3618: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF361C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF3620: 7CA62850  subf r5, r6, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[6].s64;
	// 82CF3624: 7F64F850  subf r27, r4, r31
	ctx.r[27].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 82CF3628: 3A630018  addi r19, r3, 0x18
	ctx.r[19].s64 = ctx.r[3].s64 + 24;
	// 82CF362C: 90A1FF70  stw r5, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[5].u32 ) };
	// 82CF3630: 3B230004  addi r25, r3, 4
	ctx.r[25].s64 = ctx.r[3].s64 + 4;
	// 82CF3634: 3A830014  addi r20, r3, 0x14
	ctx.r[20].s64 = ctx.r[3].s64 + 20;
	// 82CF3638: 3AC30034  addi r22, r3, 0x34
	ctx.r[22].s64 = ctx.r[3].s64 + 52;
	// 82CF363C: 7CC95214  add r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CF3640: 7C874214  add r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF3644: 7C00322C  dcbt 0, r6
	// 82CF3648: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82CF364C: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF3650: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82CF3654: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF3658: 794807E6  rldicr r8, r10, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF365C: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 82CF3660: F901FF78  std r8, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[8].u64 ) };
	// 82CF3664: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF3668: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF366C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF3670: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF3674: 3BA1FF70  addi r29, r1, -0x90
	ctx.r[29].s64 = ctx.r[1].s64 + -144;
	// 82CF3678: 13833C07  vcmpneb. (lvlx128) v28, v3, v7
	tmp.u32 = ctx.r[3].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF367C: FD2D02F2  fmul f9, f13, f11
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[11].f64;
	// 82CF3680: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3684: 3AE30024  addi r23, r3, 0x24
	ctx.r[23].s64 = ctx.r[3].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF3990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF3990 size=824
    let mut pc: u32 = 0x82CF3990;
    'dispatch: loop {
        match pc {
            0x82CF3990 => {
    //   block [0x82CF3990..0x82CF3CC8)
	// 82CF3990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF3994: 4BFB5A51  bl 0x82ca93e4
	ctx.lr = 0x82CF3998;
	sub_82CA93D0(ctx, base);
	// 82CF3998: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF399C: 3AC30008  addi r22, r3, 8
	ctx.r[22].s64 = ctx.r[3].s64 + 8;
	// 82CF39A0: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF39A4: 3B83000D  addi r28, r3, 0xd
	ctx.r[28].s64 = ctx.r[3].s64 + 13;
	// 82CF39A8: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF39AC: 3A63001C  addi r19, r3, 0x1c
	ctx.r[19].s64 = ctx.r[3].s64 + 28;
	// 82CF39B0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF39B4: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF39B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF39BC: 7CE44850  subf r7, r4, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CF39C0: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF39C4: 7D4A29D6  mullw r10, r10, r5
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF39C8: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF39CC: 90E1FF80  stw r7, -0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.r[7].u32 ) };
	// 82CF39D0: 3A830018  addi r20, r3, 0x18
	ctx.r[20].s64 = ctx.r[3].s64 + 24;
	// 82CF39D4: 3B630004  addi r27, r3, 4
	ctx.r[27].s64 = ctx.r[3].s64 + 4;
	// 82CF39D8: 3AA30014  addi r21, r3, 0x14
	ctx.r[21].s64 = ctx.r[3].s64 + 20;
	// 82CF39DC: 3BC30034  addi r30, r3, 0x34
	ctx.r[30].s64 = ctx.r[3].s64 + 52;
	// 82CF39E0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF39E4: 7F05F850  subf r24, r5, r31
	ctx.r[24].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF39E8: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82CF39EC: 7C004A2C  dcbt 0, r9
	// 82CF39F0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF39F4: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF39F8: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 82CF39FC: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF3A00: 78C407E6  rldicr r4, r6, 0x20, 0x3f
	ctx.r[4].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF3A04: 38A1FF80  addi r5, r1, -0x80
	ctx.r[5].s64 = ctx.r[1].s64 + -128;
	// 82CF3A08: F881FF88  std r4, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.r[4].u64 ) };
	// 82CF3A0C: C981FF88  lfd f12, -0x78(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82CF3A10: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF3A14: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF3A18: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF3A1C: 3BA1FF80  addi r29, r1, -0x80
	ctx.r[29].s64 = ctx.r[1].s64 + -128;
	// 82CF3A20: 13835C07  vcmpneb. (lvlx128) v28, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3A24: FD2D02F2  fmul f9, f13, f11
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[11].f64;
	// 82CF3A28: 13E02C07  vcmpneb. (lvlx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3A2C: 3B230024  addi r25, r3, 0x24
	ctx.r[25].s64 = ctx.r[3].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF3CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF3CC8 size=980
    let mut pc: u32 = 0x82CF3CC8;
    'dispatch: loop {
        match pc {
            0x82CF3CC8 => {
    //   block [0x82CF3CC8..0x82CF409C)
	// 82CF3CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF3CCC: 4BFB5715  bl 0x82ca93e0
	ctx.lr = 0x82CF3CD0;
	sub_82CA93D0(ctx, base);
	// 82CF3CD0: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF3CD4: 3AA30008  addi r21, r3, 8
	ctx.r[21].s64 = ctx.r[3].s64 + 8;
	// 82CF3CD8: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF3CDC: 3B63000D  addi r27, r3, 0xd
	ctx.r[27].s64 = ctx.r[3].s64 + 13;
	// 82CF3CE0: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF3CE4: 3A43001C  addi r18, r3, 0x1c
	ctx.r[18].s64 = ctx.r[3].s64 + 28;
	// 82CF3CE8: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF3CEC: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF3CF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF3CF4: 7CE44050  subf r7, r4, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CF3CF8: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF3CFC: 7D4A29D6  mullw r10, r10, r5
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF3D00: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF3D04: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF3D08: 3A630018  addi r19, r3, 0x18
	ctx.r[19].s64 = ctx.r[3].s64 + 24;
	// 82CF3D0C: 3B430004  addi r26, r3, 4
	ctx.r[26].s64 = ctx.r[3].s64 + 4;
	// 82CF3D10: 3A830014  addi r20, r3, 0x14
	ctx.r[20].s64 = ctx.r[3].s64 + 20;
	// 82CF3D14: 3BA30034  addi r29, r3, 0x34
	ctx.r[29].s64 = ctx.r[3].s64 + 52;
	// 82CF3D18: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF3D1C: 7EC5F850  subf r22, r5, r31
	ctx.r[22].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF3D20: 7D264A14  add r9, r6, r9
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 82CF3D24: 7C00422C  dcbt 0, r8
	// 82CF3D28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF3D2C: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF3D30: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 82CF3D34: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF3D38: 78C407E6  rldicr r4, r6, 0x20, 0x3f
	ctx.r[4].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF3D3C: 38A1FF70  addi r5, r1, -0x90
	ctx.r[5].s64 = ctx.r[1].s64 + -144;
	// 82CF3D40: F881FF78  std r4, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[4].u64 ) };
	// 82CF3D44: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF3D48: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF3D4C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF3D50: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF3D54: 3AE1FF70  addi r23, r1, -0x90
	ctx.r[23].s64 = ctx.r[1].s64 + -144;
	// 82CF3D58: 13835C07  vcmpneb. (lvlx128) v28, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3D5C: FD2D02F2  fmul f9, f13, f11
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[11].f64;
	// 82CF3D60: 13E02C07  vcmpneb. (lvlx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3D64: 3B030024  addi r24, r3, 0x24
	ctx.r[24].s64 = ctx.r[3].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF40A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF40A0 size=1312
    let mut pc: u32 = 0x82CF40A0;
    'dispatch: loop {
        match pc {
            0x82CF40A0 => {
    //   block [0x82CF40A0..0x82CF45C0)
	// 82CF40A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF40A4: 4BFB5341  bl 0x82ca93e4
	ctx.lr = 0x82CF40A8;
	sub_82CA93D0(ctx, base);
	// 82CF40A8: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 82CF40AC: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF40B0: 3923001C  addi r9, r3, 0x1c
	ctx.r[9].s64 = ctx.r[3].s64 + 28;
	// 82CF40B4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF40B8: 38E30018  addi r7, r3, 0x18
	ctx.r[7].s64 = ctx.r[3].s64 + 24;
	// 82CF40BC: 9141FF7C  stw r10, -0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-132 as u32), ctx.r[10].u32 ) };
	// 82CF40C0: 39030014  addi r8, r3, 0x14
	ctx.r[8].s64 = ctx.r[3].s64 + 20;
	// 82CF40C4: 9121FF60  stw r9, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[9].u32 ) };
	// 82CF40C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40CC: 3AC3000D  addi r22, r3, 0xd
	ctx.r[22].s64 = ctx.r[3].s64 + 13;
	// 82CF40D0: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40D4: 3AA30004  addi r21, r3, 4
	ctx.r[21].s64 = ctx.r[3].s64 + 4;
	// 82CF40D8: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40DC: 7D4429D6  mullw r10, r4, r5
	ctx.r[10].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF40E0: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40E4: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40E8: 9101FF74  stw r8, -0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-140 as u32), ctx.r[8].u32 ) };
	// 82CF40EC: 90E1FF78  stw r7, -0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[7].u32 ) };
	// 82CF40F0: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF40F4: 7E65F850  subf r19, r5, r31
	ctx.r[19].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF40F8: 7CC62050  subf r6, r6, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 82CF40FC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF4100: 9261FF70  stw r19, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[19].u32 ) };
	// 82CF4104: 90C1FF68  stw r6, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[6].u32 ) };
	// 82CF4108: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF410C: 7D684A14  add r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF4110: 7C00522C  dcbt 0, r10
	// 82CF4114: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CF4118: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF411C: 39230024  addi r9, r3, 0x24
	ctx.r[9].s64 = ctx.r[3].s64 + 36;
	// 82CF4120: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF4124: 790707E6  rldicr r7, r8, 0x20, 0x3f
	ctx.r[7].u64 = (ctx.r[8].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF4128: 39000028  li r8, 0x28
	ctx.r[8].s64 = 40;
	// 82CF412C: F8E1FF80  std r7, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.r[7].u64 ) };
	// 82CF4130: C981FF80  lfd f12, -0x80(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82CF4134: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF4138: 3881FF68  addi r4, r1, -0x98
	ctx.r[4].s64 = ctx.r[1].s64 + -152;
	// 82CF413C: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF4140: 13834407  vcmpneb. (lvlx128) v28, v3, v8
	tmp.u32 = ctx.r[3].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4144: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CF4148: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF414C: 3B81FF68  addi r28, r1, -0x98
	ctx.r[28].s64 = ctx.r[1].s64 + -152;
	// 82CF4150: 13C02407  vcmpneb. (lvlx128) v30, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF45C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF45C0 size=1680
    let mut pc: u32 = 0x82CF45C0;
    'dispatch: loop {
        match pc {
            0x82CF45C0 => {
    //   block [0x82CF45C0..0x82CF4C50)
	// 82CF45C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF45C4: 4BFB4E25  bl 0x82ca93e8
	ctx.lr = 0x82CF45C8;
	sub_82CA93D0(ctx, base);
	// 82CF45C8: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82CF45CC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF45D0: 3903001C  addi r8, r3, 0x1c
	ctx.r[8].s64 = ctx.r[3].s64 + 28;
	// 82CF45D4: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82CF45D8: 9121FF80  stw r9, -0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.r[9].u32 ) };
	// 82CF45DC: 38830018  addi r4, r3, 0x18
	ctx.r[4].s64 = ctx.r[3].s64 + 24;
	// 82CF45E0: 9101FF6C  stw r8, -0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-148 as u32), ctx.r[8].u32 ) };
	// 82CF45E4: 38C30014  addi r6, r3, 0x14
	ctx.r[6].s64 = ctx.r[3].s64 + 20;
	// 82CF45E8: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF45EC: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF45F0: 3963000D  addi r11, r3, 0xd
	ctx.r[11].s64 = ctx.r[3].s64 + 13;
	// 82CF45F4: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF45F8: 9081FF7C  stw r4, -0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-132 as u32), ctx.r[4].u32 ) };
	// 82CF45FC: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF4600: 7D6929D6  mullw r11, r9, r5
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF4604: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF4608: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF460C: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF4610: 90C1FF78  stw r6, -0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u32 ) };
	// 82CF4614: 7CE5F050  subf r7, r5, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF4618: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF461C: 7C9F2050  subf r4, r31, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 82CF4620: 90E1FF68  stw r7, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[7].u32 ) };
	// 82CF4624: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF4628: 9081FF60  stw r4, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[4].u32 ) };
	// 82CF462C: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF4630: 7D684A14  add r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF4634: 7C00522C  dcbt 0, r10
	// 82CF4638: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF463C: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF4640: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 82CF4644: 78C807E6  rldicr r8, r6, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF4648: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 82CF464C: 9121FF74  stw r9, -0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-140 as u32), ctx.r[9].u32 ) };
	// 82CF4650: F901FF88  std r8, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.r[8].u64 ) };
	// 82CF4654: C9A1FF88  lfd f13, -0x78(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82CF4658: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CF465C: 38E1FF60  addi r7, r1, -0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + -160;
	// 82CF4660: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF4664: FD400332  fmul f10, f0, f12
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[12].f64;
	// 82CF4668: FD2B0332  fmul f9, f11, f12
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82CF466C: 13A33407  vcmpneb. (lvlx128) v29, v3, v6
	tmp.u32 = ctx.r[3].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4670: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF4674: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4678: 3BE1FF88  addi r31, r1, -0x78
	ctx.r[31].s64 = ctx.r[1].s64 + -120;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF4C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF4C50 size=964
    let mut pc: u32 = 0x82CF4C50;
    'dispatch: loop {
        match pc {
            0x82CF4C50 => {
    //   block [0x82CF4C50..0x82CF5014)
	// 82CF4C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF4C54: 4BFB4785  bl 0x82ca93d8
	ctx.lr = 0x82CF4C58;
	sub_82CA93D0(ctx, base);
	// 82CF4C58: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF4C5C: 3B03000D  addi r24, r3, 0xd
	ctx.r[24].s64 = ctx.r[3].s64 + 13;
	// 82CF4C60: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF4C64: 3A630008  addi r19, r3, 8
	ctx.r[19].s64 = ctx.r[3].s64 + 8;
	// 82CF4C68: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82CF4C6C: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF4C70: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF4C74: 7D6B29D6  mullw r11, r11, r5
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF4C78: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF4C7C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF4C80: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF4C84: 7FE43050  subf r31, r4, r6
	ctx.r[31].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF4C88: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF4C8C: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF4C90: 93E1FF60  stw r31, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[31].u32 ) };
	// 82CF4C94: 3A03001C  addi r16, r3, 0x1c
	ctx.r[16].s64 = ctx.r[3].s64 + 28;
	// 82CF4C98: 3A230018  addi r17, r3, 0x18
	ctx.r[17].s64 = ctx.r[3].s64 + 24;
	// 82CF4C9C: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82CF4CA0: 3A430014  addi r18, r3, 0x14
	ctx.r[18].s64 = ctx.r[3].s64 + 20;
	// 82CF4CA4: 3B230034  addi r25, r3, 0x34
	ctx.r[25].s64 = ctx.r[3].s64 + 52;
	// 82CF4CA8: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF4CAC: 7EC5F050  subf r22, r5, r30
	ctx.r[22].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF4CB0: 7C884A14  add r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF4CB4: 7C00322C  dcbt 0, r6
	// 82CF4CB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82CF4CBC: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF4CC0: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 82CF4CC4: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF4CC8: 794807E6  rldicr r8, r10, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF4CCC: 3921FF60  addi r9, r1, -0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + -160;
	// 82CF4CD0: F901FF68  std r8, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u64 ) };
	// 82CF4CD4: C981FF68  lfd f12, -0x98(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82CF4CD8: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF4CDC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF4CE0: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF4CE4: 3B61FF60  addi r27, r1, -0xa0
	ctx.r[27].s64 = ctx.r[1].s64 + -160;
	// 82CF4CE8: 13832C07  vcmpneb. (lvlx128) v28, v3, v5
	tmp.u32 = ctx.r[3].u32 + ctx.r[5].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4CEC: FD2D02F2  fmul f9, f13, f11
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[11].f64;
	// 82CF4CF0: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4CF4: 3A830024  addi r20, r3, 0x24
	ctx.r[20].s64 = ctx.r[3].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF5018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF5018 size=816
    let mut pc: u32 = 0x82CF5018;
    'dispatch: loop {
        match pc {
            0x82CF5018 => {
    //   block [0x82CF5018..0x82CF5348)
	// 82CF5018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF501C: 4BFB43C1  bl 0x82ca93dc
	ctx.lr = 0x82CF5020;
	sub_82CA93D0(ctx, base);
	// 82CF5020: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF5024: 3AC30008  addi r22, r3, 8
	ctx.r[22].s64 = ctx.r[3].s64 + 8;
	// 82CF5028: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF502C: 3B83000D  addi r28, r3, 0xd
	ctx.r[28].s64 = ctx.r[3].s64 + 13;
	// 82CF5030: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF5034: 3A63001C  addi r19, r3, 0x1c
	ctx.r[19].s64 = ctx.r[3].s64 + 28;
	// 82CF5038: 7CC429D6  mullw r6, r4, r5
	ctx.r[6].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82CF503C: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF5040: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5044: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF5048: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF504C: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF5050: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF5054: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82CF5058: 3A830018  addi r20, r3, 0x18
	ctx.r[20].s64 = ctx.r[3].s64 + 24;
	// 82CF505C: 3B630004  addi r27, r3, 4
	ctx.r[27].s64 = ctx.r[3].s64 + 4;
	// 82CF5060: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF5064: 3AA30014  addi r21, r3, 0x14
	ctx.r[21].s64 = ctx.r[3].s64 + 20;
	// 82CF5068: 3BC30034  addi r30, r3, 0x34
	ctx.r[30].s64 = ctx.r[3].s64 + 52;
	// 82CF506C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF5070: 7F052050  subf r24, r5, r4
	ctx.r[24].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82CF5074: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82CF5078: 7C004A2C  dcbt 0, r9
	// 82CF507C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF5080: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF5084: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF5088: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF508C: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF5090: 3AE1FF70  addi r23, r1, -0x90
	ctx.r[23].s64 = ctx.r[1].s64 + -144;
	// 82CF5094: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF5098: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF509C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF50A0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF50A4: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF50A8: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF5348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF5348 size=956
    let mut pc: u32 = 0x82CF5348;
    'dispatch: loop {
        match pc {
            0x82CF5348 => {
    //   block [0x82CF5348..0x82CF5704)
	// 82CF5348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF534C: 4BFB4091  bl 0x82ca93dc
	ctx.lr = 0x82CF5350;
	sub_82CA93D0(ctx, base);
	// 82CF5350: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF5354: 3A830008  addi r20, r3, 8
	ctx.r[20].s64 = ctx.r[3].s64 + 8;
	// 82CF5358: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF535C: 3B43000D  addi r26, r3, 0xd
	ctx.r[26].s64 = ctx.r[3].s64 + 13;
	// 82CF5360: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF5364: 3A23001C  addi r17, r3, 0x1c
	ctx.r[17].s64 = ctx.r[3].s64 + 28;
	// 82CF5368: 7CE429D6  mullw r7, r4, r5
	ctx.r[7].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82CF536C: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF5370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5374: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF5378: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF537C: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF5380: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF5384: 7CE82050  subf r7, r8, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF5388: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF538C: 3A430018  addi r18, r3, 0x18
	ctx.r[18].s64 = ctx.r[3].s64 + 24;
	// 82CF5390: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF5394: 3B230004  addi r25, r3, 4
	ctx.r[25].s64 = ctx.r[3].s64 + 4;
	// 82CF5398: 3A630014  addi r19, r3, 0x14
	ctx.r[19].s64 = ctx.r[3].s64 + 20;
	// 82CF539C: 3B830034  addi r28, r3, 0x34
	ctx.r[28].s64 = ctx.r[3].s64 + 52;
	// 82CF53A0: 7EA5F850  subf r21, r5, r31
	ctx.r[21].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF53A4: 7D464A14  add r10, r6, r9
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 82CF53A8: 7C00422C  dcbt 0, r8
	// 82CF53AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF53B0: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF53B4: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 82CF53B8: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF53BC: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF53C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF53C4: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF53C8: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF53CC: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF53D0: 3BC1FF70  addi r30, r1, -0x90
	ctx.r[30].s64 = ctx.r[1].s64 + -144;
	// 82CF53D4: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF53D8: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF53DC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82CF53E0: C80B0CB8  lfd f0, 0xcb8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF5708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF5708 size=1304
    let mut pc: u32 = 0x82CF5708;
    'dispatch: loop {
        match pc {
            0x82CF5708 => {
    //   block [0x82CF5708..0x82CF5C20)
	// 82CF5708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF570C: 4BFB3CD1  bl 0x82ca93dc
	ctx.lr = 0x82CF5710;
	sub_82CA93D0(ctx, base);
	// 82CF5710: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 82CF5714: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF5718: 3923001C  addi r9, r3, 0x1c
	ctx.r[9].s64 = ctx.r[3].s64 + 28;
	// 82CF571C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF5720: 9141FF64  stw r10, -0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), ctx.r[10].u32 ) };
	// 82CF5724: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 82CF5728: 9121FF54  stw r9, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[9].u32 ) };
	// 82CF572C: 3AE3000D  addi r23, r3, 0xd
	ctx.r[23].s64 = ctx.r[3].s64 + 13;
	// 82CF5730: 9101FF68  stw r8, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u32 ) };
	// 82CF5734: 3AC30004  addi r22, r3, 4
	ctx.r[22].s64 = ctx.r[3].s64 + 4;
	// 82CF5738: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF573C: 39430014  addi r10, r3, 0x14
	ctx.r[10].s64 = ctx.r[3].s64 + 20;
	// 82CF5740: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5744: 7CC639D6  mullw r6, r6, r7
	ctx.r[6].s32 = ((ctx.r[6].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82CF5748: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF574C: 9141FF60  stw r10, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[10].u32 ) };
	// 82CF5750: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5754: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5758: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF575C: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF5760: 7C872050  subf r4, r7, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 82CF5764: 7CA5F850  subf r5, r5, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF5768: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF576C: 9081FF50  stw r4, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[4].u32 ) };
	// 82CF5770: 90A1FF58  stw r5, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[5].u32 ) };
	// 82CF5774: 38830034  addi r4, r3, 0x34
	ctx.r[4].s64 = ctx.r[3].s64 + 52;
	// 82CF5778: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF577C: 7C005A2C  dcbt 0, r11
	// 82CF5780: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CF5784: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF5788: 3901FF58  addi r8, r1, -0xa8
	ctx.r[8].s64 = ctx.r[1].s64 + -168;
	// 82CF578C: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF5790: 792707E6  rldicr r7, r9, 0x20, 0x3f
	ctx.r[7].u64 = (ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF5794: 3BA1FF58  addi r29, r1, -0xa8
	ctx.r[29].s64 = ctx.r[1].s64 + -168;
	// 82CF5798: F8E1FF70  std r7, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u64 ) };
	// 82CF579C: C981FF70  lfd f12, -0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82CF57A0: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF57A4: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CF57A8: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF57AC: 13E04407  vcmpneb. (lvlx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF57B0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF5C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF5C20 size=1680
    let mut pc: u32 = 0x82CF5C20;
    'dispatch: loop {
        match pc {
            0x82CF5C20 => {
    //   block [0x82CF5C20..0x82CF62B0)
	// 82CF5C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF5C24: 4BFB37B1  bl 0x82ca93d4
	ctx.lr = 0x82CF5C28;
	sub_82CA93D0(ctx, base);
	// 82CF5C28: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82CF5C2C: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF5C30: 3903001C  addi r8, r3, 0x1c
	ctx.r[8].s64 = ctx.r[3].s64 + 28;
	// 82CF5C34: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C38: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82CF5C3C: 9121FF5C  stw r9, -0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-164 as u32), ctx.r[9].u32 ) };
	// 82CF5C40: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 82CF5C44: 9101FF4C  stw r8, -0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-180 as u32), ctx.r[8].u32 ) };
	// 82CF5C48: 3963000D  addi r11, r3, 0xd
	ctx.r[11].s64 = ctx.r[3].s64 + 13;
	// 82CF5C4C: 90E1FF50  stw r7, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[7].u32 ) };
	// 82CF5C50: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C54: 39230014  addi r9, r3, 0x14
	ctx.r[9].s64 = ctx.r[3].s64 + 20;
	// 82CF5C58: 90C1FF60  stw r6, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[6].u32 ) };
	// 82CF5C5C: 7C8429D6  mullw r4, r4, r5
	ctx.r[4].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF5C60: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C64: 80C60000  lwz r6, 0(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C68: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C6C: 9121FF58  stw r9, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[9].u32 ) };
	// 82CF5C70: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C74: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF5C78: 7CE5F050  subf r7, r5, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF5C7C: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF5C80: 7C9F3050  subf r4, r31, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[31].s64;
	// 82CF5C84: 90E1FF48  stw r7, -0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-184 as u32), ctx.r[7].u32 ) };
	// 82CF5C88: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF5C8C: 9081FF40  stw r4, -0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-192 as u32), ctx.r[4].u32 ) };
	// 82CF5C90: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF5C94: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF5C98: 7C005A2C  dcbt 0, r11
	// 82CF5C9C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF5CA0: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF5CA4: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 82CF5CA8: 78C807E6  rldicr r8, r6, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF5CAC: 38E1FF40  addi r7, r1, -0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + -192;
	// 82CF5CB0: 9121FF54  stw r9, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[9].u32 ) };
	// 82CF5CB4: F901FF68  std r8, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u64 ) };
	// 82CF5CB8: C9A1FF68  lfd f13, -0x98(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82CF5CBC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CF5CC0: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 82CF5CC4: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF5CC8: FD400332  fmul f10, f0, f12
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[12].f64;
	// 82CF5CCC: FD2B0332  fmul f9, f11, f12
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82CF5CD0: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF5CD4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CF5CD8: 13A33407  vcmpneb. (lvlx128) v29, v3, v6
	tmp.u32 = ctx.r[3].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF5CDC: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF62B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF62B0 size=280
    let mut pc: u32 = 0x82CF62B0;
    'dispatch: loop {
        match pc {
            0x82CF62B0 => {
    //   block [0x82CF62B0..0x82CF6300)
	// 82CF62B0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF62B4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF62B8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF62BC: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF62C0: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF62C4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF62C8: 7D0559D6  mullw r8, r5, r11
	ctx.r[8].s32 = ((ctx.r[5].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CF62CC: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF62D0: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF62D4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF62D8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF62DC: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF62E0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF62E4: 7D64F850  subf r11, r4, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 82CF62E8: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF62EC: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF62F0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF62F4: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF62F8: 41980008  blt cr6, 0x82cf6300
	if ctx.cr[6].lt {
	pc = 0x82CF6300; continue 'dispatch;
	}
	// 82CF62FC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82CF6300; continue 'dispatch;
            }
            0x82CF6300 => {
    //   block [0x82CF6300..0x82CF6324)
	// 82CF6300: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF6304: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6308: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF630C: 54A4103A  slwi r4, r5, 2
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF6310: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF6314: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6318: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF631C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6320: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF6324; continue 'dispatch;
            }
            0x82CF6324 => {
    //   block [0x82CF6324..0x82CF6338)
	// 82CF6324: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82CF6328: 419A002C  beq cr6, 0x82cf6354
	if ctx.cr[6].eq {
	pc = 0x82CF6354; continue 'dispatch;
	}
	// 82CF632C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82CF6330: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82CF6334: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x82CF6338; continue 'dispatch;
            }
            0x82CF6338 => {
    //   block [0x82CF6338..0x82CF6354)
	// 82CF6338: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF633C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF6340: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6344: D1690000  stfs f11, 0(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6348: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF634C: 39290400  addi r9, r9, 0x400
	ctx.r[9].s64 = ctx.r[9].s64 + 1024;
	// 82CF6350: 4082FFE8  bne 0x82cf6338
	if !ctx.cr[0].eq {
	pc = 0x82CF6338; continue 'dispatch;
	}
	pc = 0x82CF6354; continue 'dispatch;
            }
            0x82CF6354 => {
    //   block [0x82CF6354..0x82CF6390)
	// 82CF6354: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF6358: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF635C: 7D044214  add r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 82CF6360: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF6364: 4082FFC0  bne 0x82cf6324
	if !ctx.cr[0].eq {
	pc = 0x82CF6324; continue 'dispatch;
	}
	// 82CF6368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF636C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6370: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF6374: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6378: 5548103E  rotlwi r8, r10, 2
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF637C: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF6380: 0CC80000  twi 6, r8, 0
	// 82CF6384: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6388: 41980008  blt cr6, 0x82cf6390
	if ctx.cr[6].lt {
	pc = 0x82CF6390; continue 'dispatch;
	}
	// 82CF638C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF6390; continue 'dispatch;
            }
            0x82CF6390 => {
    //   block [0x82CF6390..0x82CF63BC)
	// 82CF6390: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6394: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6398: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF639C: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF63A0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF63A4: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF63A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF63AC: 40980010  bge cr6, 0x82cf63bc
	if !ctx.cr[6].lt {
	pc = 0x82CF63BC; continue 'dispatch;
	}
	// 82CF63B0: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF63B4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF63B8: 4E800020  blr
	return;
            }
            0x82CF63BC => {
    //   block [0x82CF63BC..0x82CF63C8)
	// 82CF63BC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF63C0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF63C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF63C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF63C8 size=284
    let mut pc: u32 = 0x82CF63C8;
    'dispatch: loop {
        match pc {
            0x82CF63C8 => {
    //   block [0x82CF63C8..0x82CF6418)
	// 82CF63C8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF63CC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF63D0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF63D4: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF63D8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF63DC: 7C8A59D6  mullw r4, r10, r11
	ctx.r[4].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF63E0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF63E4: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF63E8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF63EC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF63F0: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF63F4: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF63F8: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF63FC: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6400: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CF6404: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6408: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF640C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF6410: 41980008  blt cr6, 0x82cf6418
	if ctx.cr[6].lt {
	pc = 0x82CF6418; continue 'dispatch;
	}
	// 82CF6414: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82CF6418; continue 'dispatch;
            }
            0x82CF6418 => {
    //   block [0x82CF6418..0x82CF6430)
	// 82CF6418: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF641C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF6420: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF6424: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF6428: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF642C: 419A0018  beq cr6, 0x82cf6444
	if ctx.cr[6].eq {
	pc = 0x82CF6444; continue 'dispatch;
	}
	pc = 0x82CF6430; continue 'dispatch;
            }
            0x82CF6430 => {
    //   block [0x82CF6430..0x82CF6444)
	// 82CF6430: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6434: 7C05522C  dcbt r5, r10
	// 82CF6438: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF643C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF6440: 4198FFF0  blt cr6, 0x82cf6430
	if ctx.cr[6].lt {
	pc = 0x82CF6430; continue 'dispatch;
	}
	pc = 0x82CF6444; continue 'dispatch;
            }
            0x82CF6444 => {
    //   block [0x82CF6444..0x82CF6464)
	// 82CF6444: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CF6448: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF644C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6450: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF6454: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6458: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF645C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6460: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF6464; continue 'dispatch;
            }
            0x82CF6464 => {
    //   block [0x82CF6464..0x82CF64AC)
	// 82CF6464: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF6468: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF646C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6470: D1670000  stfs f11, 0(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6474: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF6478: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF647C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF6480: 4082FFE4  bne 0x82cf6464
	if !ctx.cr[0].eq {
	pc = 0x82CF6464; continue 'dispatch;
	}
	// 82CF6484: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6488: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF648C: 5568103E  rotlwi r8, r11, 2
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82CF6490: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6494: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82CF6498: 0CC80000  twi 6, r8, 0
	// 82CF649C: 7D464396  divwu r10, r6, r8
	ctx.r[10].u32 = ctx.r[6].u32 / ctx.r[8].u32;
	// 82CF64A0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF64A4: 41980008  blt cr6, 0x82cf64ac
	if ctx.cr[6].lt {
	pc = 0x82CF64AC; continue 'dispatch;
	}
	// 82CF64A8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF64AC; continue 'dispatch;
            }
            0x82CF64AC => {
    //   block [0x82CF64AC..0x82CF64D8)
	// 82CF64AC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF64B0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF64B4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF64B8: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF64BC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF64C0: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF64C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF64C8: 40980010  bge cr6, 0x82cf64d8
	if !ctx.cr[6].lt {
	pc = 0x82CF64D8; continue 'dispatch;
	}
	// 82CF64CC: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF64D0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF64D4: 4E800020  blr
	return;
            }
            0x82CF64D8 => {
    //   block [0x82CF64D8..0x82CF64E4)
	// 82CF64D8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF64DC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF64E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF64E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF64E8 size=296
    let mut pc: u32 = 0x82CF64E8;
    'dispatch: loop {
        match pc {
            0x82CF64E8 => {
    //   block [0x82CF64E8..0x82CF6538)
	// 82CF64E8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF64EC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF64F0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF64F4: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF64F8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF64FC: 7C8951D6  mullw r4, r9, r10
	ctx.r[4].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF6500: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6504: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF650C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6510: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF6514: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6518: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82CF651C: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6520: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF6524: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6528: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF652C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF6530: 41980008  blt cr6, 0x82cf6538
	if ctx.cr[6].lt {
	pc = 0x82CF6538; continue 'dispatch;
	}
	// 82CF6534: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82CF6538; continue 'dispatch;
            }
            0x82CF6538 => {
    //   block [0x82CF6538..0x82CF6550)
	// 82CF6538: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF653C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF6540: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF6544: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6548: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF654C: 419A0018  beq cr6, 0x82cf6564
	if ctx.cr[6].eq {
	pc = 0x82CF6564; continue 'dispatch;
	}
	pc = 0x82CF6550; continue 'dispatch;
            }
            0x82CF6550 => {
    //   block [0x82CF6550..0x82CF6564)
	// 82CF6550: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6554: 7C055A2C  dcbt r5, r11
	// 82CF6558: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF655C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6560: 4198FFF0  blt cr6, 0x82cf6550
	if ctx.cr[6].lt {
	pc = 0x82CF6550; continue 'dispatch;
	}
	pc = 0x82CF6564; continue 'dispatch;
            }
            0x82CF6564 => {
    //   block [0x82CF6564..0x82CF6584)
	// 82CF6564: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF6568: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF656C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6570: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF6574: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6578: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF657C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6580: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF6584; continue 'dispatch;
            }
            0x82CF6584 => {
    //   block [0x82CF6584..0x82CF65D8)
	// 82CF6584: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF6588: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF658C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6590: D1680400  stfs f11, 0x400(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6594: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF6598: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF659C: D1280000  stfs f9, 0(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF65A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF65A4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF65A8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF65AC: 4082FFD8  bne 0x82cf6584
	if !ctx.cr[0].eq {
	pc = 0x82CF6584; continue 'dispatch;
	}
	// 82CF65B0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF65B4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF65B8: 5547103E  rotlwi r7, r10, 2
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF65BC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF65C0: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF65C4: 0CC70000  twi 6, r7, 0
	// 82CF65C8: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF65CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF65D0: 40980008  bge cr6, 0x82cf65d8
	if !ctx.cr[6].lt {
	pc = 0x82CF65D8; continue 'dispatch;
	}
	// 82CF65D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF65D8; continue 'dispatch;
            }
            0x82CF65D8 => {
    //   block [0x82CF65D8..0x82CF6604)
	// 82CF65D8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF65DC: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF65E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF65E4: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF65E8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF65EC: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF65F0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF65F4: 40980010  bge cr6, 0x82cf6604
	if !ctx.cr[6].lt {
	pc = 0x82CF6604; continue 'dispatch;
	}
	// 82CF65F8: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF65FC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6600: 4E800020  blr
	return;
            }
            0x82CF6604 => {
    //   block [0x82CF6604..0x82CF6610)
	// 82CF6604: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6608: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF660C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6610 size=320
    let mut pc: u32 = 0x82CF6610;
    'dispatch: loop {
        match pc {
            0x82CF6610 => {
    //   block [0x82CF6610..0x82CF6660)
	// 82CF6610: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6614: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6618: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF661C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6620: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6624: 7CA951D6  mullw r5, r9, r10
	ctx.r[5].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF6628: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF662C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6630: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6634: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6638: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF663C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6640: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF6644: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6648: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF664C: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6650: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6654: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF6658: 41980008  blt cr6, 0x82cf6660
	if ctx.cr[6].lt {
	pc = 0x82CF6660; continue 'dispatch;
	}
	// 82CF665C: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	pc = 0x82CF6660; continue 'dispatch;
            }
            0x82CF6660 => {
    //   block [0x82CF6660..0x82CF6678)
	// 82CF6660: 55072036  slwi r7, r8, 4
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6664: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF6668: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF666C: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6670: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF6674: 419A0018  beq cr6, 0x82cf668c
	if ctx.cr[6].eq {
	pc = 0x82CF668C; continue 'dispatch;
	}
	pc = 0x82CF6678; continue 'dispatch;
            }
            0x82CF6678 => {
    //   block [0x82CF6678..0x82CF668C)
	// 82CF6678: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF667C: 7C055A2C  dcbt r5, r11
	// 82CF6680: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF6684: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6688: 4198FFF0  blt cr6, 0x82cf6678
	if ctx.cr[6].lt {
	pc = 0x82CF6678; continue 'dispatch;
	}
	pc = 0x82CF668C; continue 'dispatch;
            }
            0x82CF668C => {
    //   block [0x82CF668C..0x82CF66AC)
	// 82CF668C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF6690: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6694: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6698: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF669C: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF66A0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF66A4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF66A8: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF66AC; continue 'dispatch;
            }
            0x82CF66AC => {
    //   block [0x82CF66AC..0x82CF6718)
	// 82CF66AC: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF66B0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF66B4: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF66B8: D1690C00  stfs f11, 0xc00(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF66BC: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF66C0: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF66C4: D1290800  stfs f9, 0x800(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF66C8: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF66CC: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF66D0: D0E90400  stfs f7, 0x400(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF66D4: C0CB0000  lfs f6, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF66D8: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF66DC: D0A90000  stfs f5, 0(r9)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF66E0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82CF66E4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF66E8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF66EC: 4082FFC0  bne 0x82cf66ac
	if !ctx.cr[0].eq {
	pc = 0x82CF66AC; continue 'dispatch;
	}
	// 82CF66F0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF66F4: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF66F8: 5547103E  rotlwi r7, r10, 2
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF66FC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6700: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF6704: 0CC70000  twi 6, r7, 0
	// 82CF6708: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF670C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF6710: 40980008  bge cr6, 0x82cf6718
	if !ctx.cr[6].lt {
	pc = 0x82CF6718; continue 'dispatch;
	}
	// 82CF6714: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF6718; continue 'dispatch;
            }
            0x82CF6718 => {
    //   block [0x82CF6718..0x82CF6744)
	// 82CF6718: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF671C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6720: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF6724: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF6728: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF672C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6730: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6734: 40980010  bge cr6, 0x82cf6744
	if !ctx.cr[6].lt {
	pc = 0x82CF6744; continue 'dispatch;
	}
	// 82CF6738: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF673C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6740: 4E800020  blr
	return;
            }
            0x82CF6744 => {
    //   block [0x82CF6744..0x82CF6750)
	// 82CF6744: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6748: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF674C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6750 size=348
    let mut pc: u32 = 0x82CF6750;
    'dispatch: loop {
        match pc {
            0x82CF6750 => {
    //   block [0x82CF6750..0x82CF679C)
	// 82CF6750: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6754: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6758: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF675C: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6760: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6764: 7CA741D6  mullw r5, r7, r8
	ctx.r[5].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF6768: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF676C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6770: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6774: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6778: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF677C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6780: 7D082050  subf r8, r8, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF6784: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6788: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF678C: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF6790: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6794: 41980008  blt cr6, 0x82cf679c
	if ctx.cr[6].lt {
	pc = 0x82CF679C; continue 'dispatch;
	}
	// 82CF6798: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	pc = 0x82CF679C; continue 'dispatch;
            }
            0x82CF679C => {
    //   block [0x82CF679C..0x82CF67BC)
	// 82CF679C: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF67A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF67A4: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82CF67A8: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF67AC: 38A7007F  addi r5, r7, 0x7f
	ctx.r[5].s64 = ctx.r[7].s64 + 127;
	// 82CF67B0: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF67B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF67B8: 419A0018  beq cr6, 0x82cf67d0
	if ctx.cr[6].eq {
	pc = 0x82CF67D0; continue 'dispatch;
	}
	pc = 0x82CF67BC; continue 'dispatch;
            }
            0x82CF67BC => {
    //   block [0x82CF67BC..0x82CF67D0)
	// 82CF67BC: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF67C0: 7C055A2C  dcbt r5, r11
	// 82CF67C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF67C8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF67CC: 4198FFF0  blt cr6, 0x82cf67bc
	if ctx.cr[6].lt {
	pc = 0x82CF67BC; continue 'dispatch;
	}
	pc = 0x82CF67D0; continue 'dispatch;
            }
            0x82CF67D0 => {
    //   block [0x82CF67D0..0x82CF67F0)
	// 82CF67D0: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CF67D4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF67D8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF67DC: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82CF67E0: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF67E4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF67E8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF67EC: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF67F0; continue 'dispatch;
            }
            0x82CF67F0 => {
    //   block [0x82CF67F0..0x82CF6874)
	// 82CF67F0: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF67F4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF67F8: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF67FC: D16A1400  stfs f11, 0x1400(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF6800: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF6804: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6808: D12A1000  stfs f9, 0x1000(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF680C: C10B000C  lfs f8, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF6810: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6814: D0EA0C00  stfs f7, 0xc00(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF6818: C0CB0008  lfs f6, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF681C: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6820: D0AA0800  stfs f5, 0x800(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF6824: C08B0004  lfs f4, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF6828: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF682C: D06A0400  stfs f3, 0x400(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6830: C04B0000  lfs f2, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CF6834: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6838: D02A0000  stfs f1, 0(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF683C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82CF6840: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF6844: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6848: 4082FFA8  bne 0x82cf67f0
	if !ctx.cr[0].eq {
	pc = 0x82CF67F0; continue 'dispatch;
	}
	// 82CF684C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6850: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6854: 5527103E  rotlwi r7, r9, 2
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 82CF6858: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF685C: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF6860: 0CC70000  twi 6, r7, 0
	// 82CF6864: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF6868: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF686C: 40980008  bge cr6, 0x82cf6874
	if !ctx.cr[6].lt {
	pc = 0x82CF6874; continue 'dispatch;
	}
	// 82CF6870: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82CF6874; continue 'dispatch;
            }
            0x82CF6874 => {
    //   block [0x82CF6874..0x82CF68A0)
	// 82CF6874: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6878: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF687C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6880: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF6884: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF6888: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF688C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6890: 40980010  bge cr6, 0x82cf68a0
	if !ctx.cr[6].lt {
	pc = 0x82CF68A0; continue 'dispatch;
	}
	// 82CF6894: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF6898: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF689C: 4E800020  blr
	return;
            }
            0x82CF68A0 => {
    //   block [0x82CF68A0..0x82CF68AC)
	// 82CF68A0: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF68A4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF68A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF68B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF68B0 size=312
    let mut pc: u32 = 0x82CF68B0;
    'dispatch: loop {
        match pc {
            0x82CF68B0 => {
    //   block [0x82CF68B0..0x82CF6900)
	// 82CF68B0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF68B4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF68B8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF68BC: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF68C0: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF68C4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF68C8: 7D0559D6  mullw r8, r5, r11
	ctx.r[8].s32 = ((ctx.r[5].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CF68CC: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF68D0: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF68D4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF68D8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF68DC: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF68E0: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF68E4: 7D64F850  subf r11, r4, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 82CF68E8: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF68EC: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF68F0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF68F4: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF68F8: 41980008  blt cr6, 0x82cf6900
	if ctx.cr[6].lt {
	pc = 0x82CF6900; continue 'dispatch;
	}
	// 82CF68FC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82CF6900; continue 'dispatch;
            }
            0x82CF6900 => {
    //   block [0x82CF6900..0x82CF692C)
	// 82CF6900: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF6904: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6908: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF690C: 54A4083C  slwi r4, r5, 1
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF6910: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF6914: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6918: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF691C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF6920: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6924: C1AB0C58  lfs f13, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6928: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF692C; continue 'dispatch;
            }
            0x82CF692C => {
    //   block [0x82CF692C..0x82CF6940)
	// 82CF692C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82CF6930: 419A0044  beq cr6, 0x82cf6974
	if ctx.cr[6].eq {
	pc = 0x82CF6974; continue 'dispatch;
	}
	// 82CF6934: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82CF6938: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82CF693C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x82CF6940; continue 'dispatch;
            }
            0x82CF6940 => {
    //   block [0x82CF6940..0x82CF6974)
	// 82CF6940: A3EA0000  lhz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6944: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF6948: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82CF694C: 7FFF0734  extsh r31, r31
	ctx.r[31].s64 = ctx.r[31].s16 as i64;
	// 82CF6950: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CF6954: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6958: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF695C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6960: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6964: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6968: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF696C: 39290400  addi r9, r9, 0x400
	ctx.r[9].s64 = ctx.r[9].s64 + 1024;
	// 82CF6970: 4082FFD0  bne 0x82cf6940
	if !ctx.cr[0].eq {
	pc = 0x82CF6940; continue 'dispatch;
	}
	pc = 0x82CF6974; continue 'dispatch;
            }
            0x82CF6974 => {
    //   block [0x82CF6974..0x82CF69B0)
	// 82CF6974: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF6978: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF697C: 7D044214  add r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 82CF6980: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF6984: 4082FFA8  bne 0x82cf692c
	if !ctx.cr[0].eq {
	pc = 0x82CF692C; continue 'dispatch;
	}
	// 82CF6988: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF698C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6990: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF6994: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6998: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF699C: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF69A0: 0CC80000  twi 6, r8, 0
	// 82CF69A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF69A8: 41980008  blt cr6, 0x82cf69b0
	if ctx.cr[6].lt {
	pc = 0x82CF69B0; continue 'dispatch;
	}
	// 82CF69AC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF69B0; continue 'dispatch;
            }
            0x82CF69B0 => {
    //   block [0x82CF69B0..0x82CF69DC)
	// 82CF69B0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF69B4: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF69B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF69BC: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF69C0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF69C4: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF69C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF69CC: 40980010  bge cr6, 0x82cf69dc
	if !ctx.cr[6].lt {
	pc = 0x82CF69DC; continue 'dispatch;
	}
	// 82CF69D0: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF69D4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF69D8: 4E800020  blr
	return;
            }
            0x82CF69DC => {
    //   block [0x82CF69DC..0x82CF69E8)
	// 82CF69DC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF69E0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF69E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF69E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF69E8 size=316
    let mut pc: u32 = 0x82CF69E8;
    'dispatch: loop {
        match pc {
            0x82CF69E8 => {
    //   block [0x82CF69E8..0x82CF6A38)
	// 82CF69E8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF69EC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF69F0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF69F4: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF69F8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF69FC: 7C8A59D6  mullw r4, r10, r11
	ctx.r[4].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF6A00: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6A04: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6A08: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6A0C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6A10: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF6A14: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6A18: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF6A1C: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6A20: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CF6A24: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6A28: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6A2C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF6A30: 41980008  blt cr6, 0x82cf6a38
	if ctx.cr[6].lt {
	pc = 0x82CF6A38; continue 'dispatch;
	}
	// 82CF6A34: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82CF6A38; continue 'dispatch;
            }
            0x82CF6A38 => {
    //   block [0x82CF6A38..0x82CF6A50)
	// 82CF6A38: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF6A3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF6A40: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF6A44: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF6A48: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF6A4C: 419A0018  beq cr6, 0x82cf6a64
	if ctx.cr[6].eq {
	pc = 0x82CF6A64; continue 'dispatch;
	}
	pc = 0x82CF6A50; continue 'dispatch;
            }
            0x82CF6A50 => {
    //   block [0x82CF6A50..0x82CF6A64)
	// 82CF6A50: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6A54: 7C05522C  dcbt r5, r10
	// 82CF6A58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF6A5C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF6A60: 4198FFF0  blt cr6, 0x82cf6a50
	if ctx.cr[6].lt {
	pc = 0x82CF6A50; continue 'dispatch;
	}
	pc = 0x82CF6A64; continue 'dispatch;
            }
            0x82CF6A64 => {
    //   block [0x82CF6A64..0x82CF6A8C)
	// 82CF6A64: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CF6A68: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6A6C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6A70: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF6A74: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6A78: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6A7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF6A80: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6A84: C1AB0C58  lfs f13, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6A88: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF6A8C; continue 'dispatch;
            }
            0x82CF6A8C => {
    //   block [0x82CF6A8C..0x82CF6AEC)
	// 82CF6A8C: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6A90: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF6A94: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82CF6A98: 7D660734  extsh r6, r11
	ctx.r[6].s64 = ctx.r[11].s16 as i64;
	// 82CF6A9C: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82CF6AA0: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6AA4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6AA8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6AAC: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6AB0: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6AB4: D0E70000  stfs f7, 0(r7)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6AB8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF6ABC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6AC0: 4082FFCC  bne 0x82cf6a8c
	if !ctx.cr[0].eq {
	pc = 0x82CF6A8C; continue 'dispatch;
	}
	// 82CF6AC4: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6AC8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6ACC: 5568083E  rotlwi r8, r11, 1
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 82CF6AD0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6AD4: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82CF6AD8: 0CC80000  twi 6, r8, 0
	// 82CF6ADC: 7D464396  divwu r10, r6, r8
	ctx.r[10].u32 = ctx.r[6].u32 / ctx.r[8].u32;
	// 82CF6AE0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6AE4: 41980008  blt cr6, 0x82cf6aec
	if ctx.cr[6].lt {
	pc = 0x82CF6AEC; continue 'dispatch;
	}
	// 82CF6AE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF6AEC; continue 'dispatch;
            }
            0x82CF6AEC => {
    //   block [0x82CF6AEC..0x82CF6B18)
	// 82CF6AEC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6AF0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6AF4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF6AF8: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF6AFC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6B00: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6B04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6B08: 40980010  bge cr6, 0x82cf6b18
	if !ctx.cr[6].lt {
	pc = 0x82CF6B18; continue 'dispatch;
	}
	// 82CF6B0C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF6B10: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6B14: 4E800020  blr
	return;
            }
            0x82CF6B18 => {
    //   block [0x82CF6B18..0x82CF6B24)
	// 82CF6B18: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6B1C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6B20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6B28 size=352
    let mut pc: u32 = 0x82CF6B28;
    'dispatch: loop {
        match pc {
            0x82CF6B28 => {
    //   block [0x82CF6B28..0x82CF6B78)
	// 82CF6B28: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6B2C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6B30: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF6B34: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6B38: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6B3C: 7C8951D6  mullw r4, r9, r10
	ctx.r[4].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF6B40: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6B44: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6B48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6B4C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6B50: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF6B54: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6B58: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82CF6B5C: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6B60: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF6B64: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6B68: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6B6C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF6B70: 41980008  blt cr6, 0x82cf6b78
	if ctx.cr[6].lt {
	pc = 0x82CF6B78; continue 'dispatch;
	}
	// 82CF6B74: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82CF6B78; continue 'dispatch;
            }
            0x82CF6B78 => {
    //   block [0x82CF6B78..0x82CF6B90)
	// 82CF6B78: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6B7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF6B80: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF6B84: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6B88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF6B8C: 419A0018  beq cr6, 0x82cf6ba4
	if ctx.cr[6].eq {
	pc = 0x82CF6BA4; continue 'dispatch;
	}
	pc = 0x82CF6B90; continue 'dispatch;
            }
            0x82CF6B90 => {
    //   block [0x82CF6B90..0x82CF6BA4)
	// 82CF6B90: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6B94: 7C055A2C  dcbt r5, r11
	// 82CF6B98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF6B9C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6BA0: 4198FFF0  blt cr6, 0x82cf6b90
	if ctx.cr[6].lt {
	pc = 0x82CF6B90; continue 'dispatch;
	}
	pc = 0x82CF6BA4; continue 'dispatch;
            }
            0x82CF6BA4 => {
    //   block [0x82CF6BA4..0x82CF6BCC)
	// 82CF6BA4: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF6BA8: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6BAC: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6BB0: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82CF6BB4: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF6BB8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6BBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF6BC0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6BC4: C1AA0C58  lfs f13, 0xc58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6BC8: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF6BCC; continue 'dispatch;
            }
            0x82CF6BCC => {
    //   block [0x82CF6BCC..0x82CF6C50)
	// 82CF6BCC: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF6BD0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF6BD4: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF6BD8: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82CF6BDC: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF6BE0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6BE4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6BE8: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6BEC: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6BF0: D0E80400  stfs f7, 0x400(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6BF4: A0AB0000  lhz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6BF8: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 82CF6BFC: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 82CF6C00: C8C1FFE8  lfd f6, -0x18(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF6C04: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF6C08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF6C0C: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF6C10: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6C14: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6C18: D0480000  stfs f2, 0(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6C1C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF6C20: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6C24: 4082FFA8  bne 0x82cf6bcc
	if !ctx.cr[0].eq {
	pc = 0x82CF6BCC; continue 'dispatch;
	}
	// 82CF6C28: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6C2C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6C30: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF6C34: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6C38: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF6C3C: 0CC70000  twi 6, r7, 0
	// 82CF6C40: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF6C44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF6C48: 40980008  bge cr6, 0x82cf6c50
	if !ctx.cr[6].lt {
	pc = 0x82CF6C50; continue 'dispatch;
	}
	// 82CF6C4C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF6C50; continue 'dispatch;
            }
            0x82CF6C50 => {
    //   block [0x82CF6C50..0x82CF6C7C)
	// 82CF6C50: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6C54: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6C58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF6C5C: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF6C60: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6C64: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6C68: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6C6C: 40980010  bge cr6, 0x82cf6c7c
	if !ctx.cr[6].lt {
	pc = 0x82CF6C7C; continue 'dispatch;
	}
	// 82CF6C70: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF6C74: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6C78: 4E800020  blr
	return;
            }
            0x82CF6C7C => {
    //   block [0x82CF6C7C..0x82CF6C88)
	// 82CF6C7C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6C80: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6C88 size=424
    let mut pc: u32 = 0x82CF6C88;
    'dispatch: loop {
        match pc {
            0x82CF6C88 => {
    //   block [0x82CF6C88..0x82CF6CD8)
	// 82CF6C88: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6C8C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6C90: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF6C94: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6C98: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6C9C: 7CA951D6  mullw r5, r9, r10
	ctx.r[5].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF6CA0: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6CA4: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6CA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6CAC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6CB0: 54A9083C  slwi r9, r5, 1
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF6CB4: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6CB8: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF6CBC: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6CC0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF6CC4: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6CC8: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6CCC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF6CD0: 41980008  blt cr6, 0x82cf6cd8
	if ctx.cr[6].lt {
	pc = 0x82CF6CD8; continue 'dispatch;
	}
	// 82CF6CD4: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	pc = 0x82CF6CD8; continue 'dispatch;
            }
            0x82CF6CD8 => {
    //   block [0x82CF6CD8..0x82CF6CF0)
	// 82CF6CD8: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6CDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF6CE0: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF6CE4: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6CE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF6CEC: 419A0018  beq cr6, 0x82cf6d04
	if ctx.cr[6].eq {
	pc = 0x82CF6D04; continue 'dispatch;
	}
	pc = 0x82CF6CF0; continue 'dispatch;
            }
            0x82CF6CF0 => {
    //   block [0x82CF6CF0..0x82CF6D04)
	// 82CF6CF0: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6CF4: 7C055A2C  dcbt r5, r11
	// 82CF6CF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF6CFC: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6D00: 4198FFF0  blt cr6, 0x82cf6cf0
	if ctx.cr[6].lt {
	pc = 0x82CF6CF0; continue 'dispatch;
	}
	pc = 0x82CF6D04; continue 'dispatch;
            }
            0x82CF6D04 => {
    //   block [0x82CF6D04..0x82CF6D2C)
	// 82CF6D04: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF6D08: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6D0C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6D10: F941FFD0  std r10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[10].u64 ) };
	// 82CF6D14: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF6D18: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6D1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF6D20: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6D24: C1AA0C58  lfs f13, 0xc58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6D28: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF6D2C; continue 'dispatch;
            }
            0x82CF6D2C => {
    //   block [0x82CF6D2C..0x82CF6DF8)
	// 82CF6D2C: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF6D30: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF6D34: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF6D38: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CF6D3C: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF6D40: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6D44: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6D48: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6D4C: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6D50: D0E90C00  stfs f7, 0xc00(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF6D54: A0AB0004  lhz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6D58: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 82CF6D5C: F941FFD8  std r10, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[10].u64 ) };
	// 82CF6D60: C8C1FFD8  lfd f6, -0x28(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF6D64: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF6D68: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF6D6C: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6D70: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6D74: D0490800  stfs f2, 0x800(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF6D78: A0EB0002  lhz r7, 2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF6D7C: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF6D80: F8A1FFE0  std r5, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[5].u64 ) };
	// 82CF6D84: C821FFE0  lfd f1, -0x20(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF6D88: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 82CF6D8C: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF6D90: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6D94: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6D98: D1090400  stfs f8, 0x400(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6D9C: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6DA0: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF6DA4: F8E1FFE8  std r7, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[7].u64 ) };
	// 82CF6DA8: C8E1FFE8  lfd f7, -0x18(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF6DAC: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF6DB0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF6DB4: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF6DB8: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6DBC: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6DC0: D0690000  stfs f3, 0(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6DC4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF6DC8: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6DCC: 4082FF60  bne 0x82cf6d2c
	if !ctx.cr[0].eq {
	pc = 0x82CF6D2C; continue 'dispatch;
	}
	// 82CF6DD0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6DD4: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6DD8: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF6DDC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6DE0: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF6DE4: 0CC70000  twi 6, r7, 0
	// 82CF6DE8: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF6DEC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF6DF0: 40980008  bge cr6, 0x82cf6df8
	if !ctx.cr[6].lt {
	pc = 0x82CF6DF8; continue 'dispatch;
	}
	// 82CF6DF4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF6DF8; continue 'dispatch;
            }
            0x82CF6DF8 => {
    //   block [0x82CF6DF8..0x82CF6E24)
	// 82CF6DF8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6DFC: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6E00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF6E04: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF6E08: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6E0C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6E10: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6E14: 40980010  bge cr6, 0x82cf6e24
	if !ctx.cr[6].lt {
	pc = 0x82CF6E24; continue 'dispatch;
	}
	// 82CF6E18: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF6E1C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6E20: 4E800020  blr
	return;
            }
            0x82CF6E24 => {
    //   block [0x82CF6E24..0x82CF6E30)
	// 82CF6E24: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6E28: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6E2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6E30 size=500
    let mut pc: u32 = 0x82CF6E30;
    'dispatch: loop {
        match pc {
            0x82CF6E30 => {
    //   block [0x82CF6E30..0x82CF6E7C)
	// 82CF6E30: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6E34: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6E38: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF6E3C: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6E40: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6E44: 7CA741D6  mullw r5, r7, r8
	ctx.r[5].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF6E48: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6E4C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6E50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6E54: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6E58: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6E5C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6E60: 7D082050  subf r8, r8, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF6E64: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6E68: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF6E6C: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF6E70: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6E74: 41980008  blt cr6, 0x82cf6e7c
	if ctx.cr[6].lt {
	pc = 0x82CF6E7C; continue 'dispatch;
	}
	// 82CF6E78: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	pc = 0x82CF6E7C; continue 'dispatch;
            }
            0x82CF6E7C => {
    //   block [0x82CF6E7C..0x82CF6E9C)
	// 82CF6E7C: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6E80: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF6E84: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82CF6E88: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6E8C: 38A7007F  addi r5, r7, 0x7f
	ctx.r[5].s64 = ctx.r[7].s64 + 127;
	// 82CF6E90: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6E94: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF6E98: 419A0018  beq cr6, 0x82cf6eb0
	if ctx.cr[6].eq {
	pc = 0x82CF6EB0; continue 'dispatch;
	}
	pc = 0x82CF6E9C; continue 'dispatch;
            }
            0x82CF6E9C => {
    //   block [0x82CF6E9C..0x82CF6EB0)
	// 82CF6E9C: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6EA0: 7C055A2C  dcbt r5, r11
	// 82CF6EA4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF6EA8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6EAC: 4198FFF0  blt cr6, 0x82cf6e9c
	if ctx.cr[6].lt {
	pc = 0x82CF6E9C; continue 'dispatch;
	}
	pc = 0x82CF6EB0; continue 'dispatch;
            }
            0x82CF6EB0 => {
    //   block [0x82CF6EB0..0x82CF6ED8)
	// 82CF6EB0: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CF6EB4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6EB8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6EBC: F921FFC0  std r9, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[9].u64 ) };
	// 82CF6EC0: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF6EC4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6EC8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF6ECC: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6ED0: C1A90C58  lfs f13, 0xc58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6ED4: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF6ED8; continue 'dispatch;
            }
            0x82CF6ED8 => {
    //   block [0x82CF6ED8..0x82CF6FEC)
	// 82CF6ED8: A12B000A  lhz r9, 0xa(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 82CF6EDC: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF6EE0: 7D260734  extsh r6, r9
	ctx.r[6].s64 = ctx.r[9].s16 as i64;
	// 82CF6EE4: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CF6EE8: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF6EEC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6EF0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6EF4: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6EF8: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6EFC: D0EA1400  stfs f7, 0x1400(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF6F00: A0AB0008  lhz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6F04: 7CA90734  extsh r9, r5
	ctx.r[9].s64 = ctx.r[5].s16 as i64;
	// 82CF6F08: F921FFC8  std r9, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[9].u64 ) };
	// 82CF6F0C: C8C1FFC8  lfd f6, -0x38(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CF6F10: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF6F14: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF6F18: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6F1C: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6F20: D04A1000  stfs f2, 0x1000(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF6F24: A0EB0006  lhz r7, 6(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF6F28: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF6F2C: F8A1FFD0  std r5, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u64 ) };
	// 82CF6F30: C821FFD0  lfd f1, -0x30(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF6F34: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 82CF6F38: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF6F3C: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6F40: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6F44: D10A0C00  stfs f8, 0xc00(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF6F48: A08B0004  lhz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6F4C: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF6F50: F8E1FFD8  std r7, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[7].u64 ) };
	// 82CF6F54: C8E1FFD8  lfd f7, -0x28(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF6F58: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF6F5C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF6F60: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6F64: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6F68: D06A0800  stfs f3, 0x800(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF6F6C: A0CB0002  lhz r6, 2(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF6F70: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CF6F74: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CF6F78: C841FFE0  lfd f2, -0x20(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF6F7C: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF6F80: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF6F84: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6F88: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6F8C: D12A0400  stfs f9, 0x400(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6F90: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6F94: 7D260734  extsh r6, r9
	ctx.r[6].s64 = ctx.r[9].s16 as i64;
	// 82CF6F98: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF6F9C: C901FFE8  lfd f8, -0x18(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF6FA0: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82CF6FA4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82CF6FA8: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82CF6FAC: ECA60372  fmuls f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6FB0: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6FB4: D08A0000  stfs f4, 0(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6FB8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF6FBC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6FC0: 4082FF18  bne 0x82cf6ed8
	if !ctx.cr[0].eq {
	pc = 0x82CF6ED8; continue 'dispatch;
	}
	// 82CF6FC4: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6FC8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6FCC: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82CF6FD0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6FD4: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF6FD8: 0CC70000  twi 6, r7, 0
	// 82CF6FDC: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF6FE0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF6FE4: 40980008  bge cr6, 0x82cf6fec
	if !ctx.cr[6].lt {
	pc = 0x82CF6FEC; continue 'dispatch;
	}
	// 82CF6FE8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82CF6FEC; continue 'dispatch;
            }
            0x82CF6FEC => {
    //   block [0x82CF6FEC..0x82CF7018)
	// 82CF6FEC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6FF0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6FF4: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6FF8: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF6FFC: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF7000: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7004: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7008: 40980010  bge cr6, 0x82cf7018
	if !ctx.cr[6].lt {
	pc = 0x82CF7018; continue 'dispatch;
	}
	// 82CF700C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7010: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7014: 4E800020  blr
	return;
            }
            0x82CF7018 => {
    //   block [0x82CF7018..0x82CF7024)
	// 82CF7018: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF701C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7028 size=304
    let mut pc: u32 = 0x82CF7028;
    'dispatch: loop {
        match pc {
            0x82CF7028 => {
    //   block [0x82CF7028..0x82CF7074)
	// 82CF7028: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF702C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7030: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7034: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7038: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF703C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7040: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7044: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7048: 7CE959D6  mullw r7, r9, r11
	ctx.r[7].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82CF704C: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7050: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7054: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82CF7058: 7D4AF850  subf r10, r10, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82CF705C: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7060: 7CC53214  add r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF7064: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF7068: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82CF706C: 41980008  blt cr6, 0x82cf7074
	if ctx.cr[6].lt {
	pc = 0x82CF7074; continue 'dispatch;
	}
	// 82CF7070: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	pc = 0x82CF7074; continue 'dispatch;
            }
            0x82CF7074 => {
    //   block [0x82CF7074..0x82CF70A4)
	// 82CF7074: 7D4B07B4  extsw r11, r10
	ctx.r[11].s64 = ctx.r[10].s32 as i64;
	// 82CF7078: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF707C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7080: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF7084: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF7088: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF708C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7090: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF7094: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7098: C1AA67A4  lfs f13, 0x67a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF709C: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF70A0: C18B67A0  lfs f12, 0x67a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF70A4; continue 'dispatch;
            }
            0x82CF70A4 => {
    //   block [0x82CF70A4..0x82CF70B4)
	// 82CF70A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF70A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CF70AC: 419A003C  beq cr6, 0x82cf70e8
	if ctx.cr[6].eq {
	pc = 0x82CF70E8; continue 'dispatch;
	}
	// 82CF70B0: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	pc = 0x82CF70B4; continue 'dispatch;
            }
            0x82CF70B4 => {
    //   block [0x82CF70B4..0x82CF70E8)
	// 82CF70B4: 7C8B40AE  lbzx r4, r11, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82CF70B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF70BC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF70C0: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82CF70C4: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF70C8: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF70CC: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF70D0: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF70D4: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF70D8: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF70DC: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF70E0: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CF70E4: 4198FFD0  blt cr6, 0x82cf70b4
	if ctx.cr[6].lt {
	pc = 0x82CF70B4; continue 'dispatch;
	}
	pc = 0x82CF70E8; continue 'dispatch;
            }
            0x82CF70E8 => {
    //   block [0x82CF70E8..0x82CF7120)
	// 82CF70E8: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF70EC: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF70F0: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF70F4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82CF70F8: 4082FFAC  bne 0x82cf70a4
	if !ctx.cr[0].eq {
	pc = 0x82CF70A4; continue 'dispatch;
	}
	// 82CF70FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7100: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7104: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF7108: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF710C: 0CCA0000  twi 6, r10, 0
	// 82CF7110: 7D495396  divwu r10, r9, r10
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 82CF7114: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7118: 41980008  blt cr6, 0x82cf7120
	if ctx.cr[6].lt {
	pc = 0x82CF7120; continue 'dispatch;
	}
	// 82CF711C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF7120; continue 'dispatch;
            }
            0x82CF7120 => {
    //   block [0x82CF7120..0x82CF714C)
	// 82CF7120: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7124: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7128: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF712C: 7D4B3050  subf r10, r11, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 82CF7130: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7134: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7138: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF713C: 40980010  bge cr6, 0x82cf714c
	if !ctx.cr[6].lt {
	pc = 0x82CF714C; continue 'dispatch;
	}
	// 82CF7140: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7144: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7148: 4E800020  blr
	return;
            }
            0x82CF714C => {
    //   block [0x82CF714C..0x82CF7158)
	// 82CF714C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7150: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7158 size=312
    let mut pc: u32 = 0x82CF7158;
    'dispatch: loop {
        match pc {
            0x82CF7158 => {
    //   block [0x82CF7158..0x82CF71A4)
	// 82CF7158: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF715C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7160: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7164: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7168: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF716C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7170: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7174: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7178: 7D2551D6  mullw r9, r5, r10
	ctx.r[9].s32 = ((ctx.r[5].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF717C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7180: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7184: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF7188: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF718C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF7190: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7194: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF7198: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF719C: 41980008  blt cr6, 0x82cf71a4
	if ctx.cr[6].lt {
	pc = 0x82CF71A4; continue 'dispatch;
	}
	// 82CF71A0: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82CF71A4; continue 'dispatch;
            }
            0x82CF71A4 => {
    //   block [0x82CF71A4..0x82CF71B8)
	// 82CF71A4: 3909007F  addi r8, r9, 0x7f
	ctx.r[8].s64 = ctx.r[9].s64 + 127;
	// 82CF71A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF71AC: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF71B0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF71B4: 419A0018  beq cr6, 0x82cf71cc
	if ctx.cr[6].eq {
	pc = 0x82CF71CC; continue 'dispatch;
	}
	pc = 0x82CF71B8; continue 'dispatch;
            }
            0x82CF71B8 => {
    //   block [0x82CF71B8..0x82CF71CC)
	// 82CF71B8: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF71BC: 7C055A2C  dcbt r5, r11
	// 82CF71C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF71C4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF71C8: 4198FFF0  blt cr6, 0x82cf71b8
	if ctx.cr[6].lt {
	pc = 0x82CF71B8; continue 'dispatch;
	}
	pc = 0x82CF71CC; continue 'dispatch;
            }
            0x82CF71CC => {
    //   block [0x82CF71CC..0x82CF71FC)
	// 82CF71CC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF71D0: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF71D4: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF71D8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CF71DC: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF71E0: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF71E4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF71E8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF71EC: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF71F0: C1A867A4  lfs f13, 0x67a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF71F4: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF71F8: C18A67A0  lfs f12, 0x67a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF71FC; continue 'dispatch;
            }
            0x82CF71FC => {
    //   block [0x82CF71FC..0x82CF7258)
	// 82CF71FC: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7200: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF7204: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF7208: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82CF720C: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF7210: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF7214: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF7218: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF721C: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7220: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7224: D0A70000  stfs f5, 0(r7)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7228: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF722C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7230: 4082FFCC  bne 0x82cf71fc
	if !ctx.cr[0].eq {
	pc = 0x82CF71FC; continue 'dispatch;
	}
	// 82CF7234: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7238: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF723C: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF7240: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7244: 0CC90000  twi 6, r9, 0
	// 82CF7248: 7D484B96  divwu r10, r8, r9
	ctx.r[10].u32 = ctx.r[8].u32 / ctx.r[9].u32;
	// 82CF724C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7250: 41980008  blt cr6, 0x82cf7258
	if ctx.cr[6].lt {
	pc = 0x82CF7258; continue 'dispatch;
	}
	// 82CF7254: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF7258; continue 'dispatch;
            }
            0x82CF7258 => {
    //   block [0x82CF7258..0x82CF7284)
	// 82CF7258: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF725C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7260: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7264: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF7268: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF726C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7270: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7274: 40980010  bge cr6, 0x82cf7284
	if !ctx.cr[6].lt {
	pc = 0x82CF7284; continue 'dispatch;
	}
	// 82CF7278: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF727C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7280: 4E800020  blr
	return;
            }
            0x82CF7284 => {
    //   block [0x82CF7284..0x82CF7290)
	// 82CF7284: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7288: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF728C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7290 size=352
    let mut pc: u32 = 0x82CF7290;
    'dispatch: loop {
        match pc {
            0x82CF7290 => {
    //   block [0x82CF7290..0x82CF72DC)
	// 82CF7290: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7294: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7298: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF729C: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF72A0: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF72A4: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF72A8: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF72AC: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF72B0: 7D2551D6  mullw r9, r5, r10
	ctx.r[9].s32 = ((ctx.r[5].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF72B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF72B8: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF72BC: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF72C0: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF72C4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF72C8: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF72CC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF72D0: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF72D4: 41980008  blt cr6, 0x82cf72dc
	if ctx.cr[6].lt {
	pc = 0x82CF72DC; continue 'dispatch;
	}
	// 82CF72D8: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82CF72DC; continue 'dispatch;
            }
            0x82CF72DC => {
    //   block [0x82CF72DC..0x82CF72F4)
	// 82CF72DC: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF72E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF72E4: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF72E8: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF72EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF72F0: 419A0018  beq cr6, 0x82cf7308
	if ctx.cr[6].eq {
	pc = 0x82CF7308; continue 'dispatch;
	}
	pc = 0x82CF72F4; continue 'dispatch;
            }
            0x82CF72F4 => {
    //   block [0x82CF72F4..0x82CF7308)
	// 82CF72F4: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF72F8: 7C055A2C  dcbt r5, r11
	// 82CF72FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF7300: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7304: 4198FFF0  blt cr6, 0x82cf72f4
	if ctx.cr[6].lt {
	pc = 0x82CF72F4; continue 'dispatch;
	}
	pc = 0x82CF7308; continue 'dispatch;
            }
            0x82CF7308 => {
    //   block [0x82CF7308..0x82CF7338)
	// 82CF7308: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF730C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7310: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7314: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CF7318: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82CF731C: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7320: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7324: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF7328: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF732C: C1A767A4  lfs f13, 0x67a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7330: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7334: C18A67A0  lfs f12, 0x67a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF7338; continue 'dispatch;
            }
            0x82CF7338 => {
    //   block [0x82CF7338..0x82CF73B8)
	// 82CF7338: 88EB0001  lbz r7, 1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF733C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF7340: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF7344: C941FFE0  lfd f10, -0x20(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7348: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF734C: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF7350: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF7354: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7358: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF735C: D0A80400  stfs f5, 0x400(r8)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7360: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7364: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CF7368: F8A1FFE8  std r5, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[5].u64 ) };
	// 82CF736C: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF7370: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF7374: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF7378: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF737C: ED410332  fmuls f10, f1, f12
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7380: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7384: D1280000  stfs f9, 0(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7388: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF738C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7390: 4082FFA8  bne 0x82cf7338
	if !ctx.cr[0].eq {
	pc = 0x82CF7338; continue 'dispatch;
	}
	// 82CF7394: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7398: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF739C: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF73A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF73A4: 0CC90000  twi 6, r9, 0
	// 82CF73A8: 7D474B96  divwu r10, r7, r9
	ctx.r[10].u32 = ctx.r[7].u32 / ctx.r[9].u32;
	// 82CF73AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF73B0: 41980008  blt cr6, 0x82cf73b8
	if ctx.cr[6].lt {
	pc = 0x82CF73B8; continue 'dispatch;
	}
	// 82CF73B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF73B8; continue 'dispatch;
            }
            0x82CF73B8 => {
    //   block [0x82CF73B8..0x82CF73E4)
	// 82CF73B8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF73BC: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF73C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF73C4: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF73C8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF73CC: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF73D0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF73D4: 40980010  bge cr6, 0x82cf73e4
	if !ctx.cr[6].lt {
	pc = 0x82CF73E4; continue 'dispatch;
	}
	// 82CF73D8: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF73DC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF73E0: 4E800020  blr
	return;
            }
            0x82CF73E4 => {
    //   block [0x82CF73E4..0x82CF73F0)
	// 82CF73E4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF73E8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF73EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF73F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF73F0 size=404
    let mut pc: u32 = 0x82CF73F0;
    'dispatch: loop {
        match pc {
            0x82CF73F0 => {
    //   block [0x82CF73F0..0x82CF7438)
	// 82CF73F0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF73F4: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF73F8: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF73FC: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7400: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7404: 7D2951D6  mullw r9, r9, r10
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF7408: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF740C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7410: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7414: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7418: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82CF741C: 7CC62050  subf r6, r6, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 82CF7420: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF7424: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7428: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF742C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF7430: 41980008  blt cr6, 0x82cf7438
	if ctx.cr[6].lt {
	pc = 0x82CF7438; continue 'dispatch;
	}
	// 82CF7434: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	pc = 0x82CF7438; continue 'dispatch;
            }
            0x82CF7438 => {
    //   block [0x82CF7438..0x82CF7450)
	// 82CF7438: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF743C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF7440: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF7444: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7448: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF744C: 419A0018  beq cr6, 0x82cf7464
	if ctx.cr[6].eq {
	pc = 0x82CF7464; continue 'dispatch;
	}
	pc = 0x82CF7450; continue 'dispatch;
            }
            0x82CF7450 => {
    //   block [0x82CF7450..0x82CF7464)
	// 82CF7450: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7454: 7C055A2C  dcbt r5, r11
	// 82CF7458: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF745C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7460: 4198FFF0  blt cr6, 0x82cf7450
	if ctx.cr[6].lt {
	pc = 0x82CF7450; continue 'dispatch;
	}
	pc = 0x82CF7464; continue 'dispatch;
            }
            0x82CF7464 => {
    //   block [0x82CF7464..0x82CF7494)
	// 82CF7464: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF7468: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF746C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7470: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CF7474: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82CF7478: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF747C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7480: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF7484: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7488: C1A767A4  lfs f13, 0x67a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF748C: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7490: C18A67A0  lfs f12, 0x67a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF7494; continue 'dispatch;
            }
            0x82CF7494 => {
    //   block [0x82CF7494..0x82CF755C)
	// 82CF7494: 88EB0003  lbz r7, 3(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82CF7498: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF749C: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF74A0: C941FFE0  lfd f10, -0x20(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF74A4: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF74A8: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF74AC: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF74B0: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF74B4: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF74B8: D0A90C00  stfs f5, 0xc00(r9)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF74BC: 88AB0002  lbz r5, 2(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF74C0: F8A1FFE8  std r5, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[5].u64 ) };
	// 82CF74C4: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF74C8: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF74CC: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF74D0: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF74D4: ED410332  fmuls f10, f1, f12
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF74D8: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF74DC: D1290800  stfs f9, 0x800(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF74E0: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF74E4: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF74E8: C901FFF0  lfd f8, -0x10(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF74EC: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82CF74F0: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82CF74F4: ECA66828  fsubs f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF74F8: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF74FC: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7500: D0690400  stfs f3, 0x400(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7504: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7508: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF750C: F8C1FFF8  std r6, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[6].u64 ) };
	// 82CF7510: C841FFF8  lfd f2, -8(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7514: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF7518: FD400818  frsp f10, f1
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF751C: ED2A6828  fsubs f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF7520: ED090332  fmuls f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7524: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7528: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF752C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF7530: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7534: 4082FF60  bne 0x82cf7494
	if !ctx.cr[0].eq {
	pc = 0x82CF7494; continue 'dispatch;
	}
	// 82CF7538: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF753C: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7540: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF7544: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7548: 0CC80000  twi 6, r8, 0
	// 82CF754C: 7D474396  divwu r10, r7, r8
	ctx.r[10].u32 = ctx.r[7].u32 / ctx.r[8].u32;
	// 82CF7550: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7554: 41980008  blt cr6, 0x82cf755c
	if ctx.cr[6].lt {
	pc = 0x82CF755C; continue 'dispatch;
	}
	// 82CF7558: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF755C; continue 'dispatch;
            }
            0x82CF755C => {
    //   block [0x82CF755C..0x82CF7584)
	// 82CF755C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7560: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7564: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7568: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF756C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7570: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7574: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7578: 4098000C  bge cr6, 0x82cf7584
	if !ctx.cr[6].lt {
		sub_82CF7584(ctx, base);
		return;
	}
	// 82CF757C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7584(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CF7584 size=8
    let mut pc: u32 = 0x82CF7584;
    'dispatch: loop {
        match pc {
            0x82CF7584 => {
    //   block [0x82CF7584..0x82CF758C)
	// 82CF7584: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7590 size=480
    let mut pc: u32 = 0x82CF7590;
    'dispatch: loop {
        match pc {
            0x82CF7590 => {
    //   block [0x82CF7590..0x82CF75D4)
	// 82CF7590: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7594: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7598: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF759C: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF75A0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF75A4: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF75A8: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF75AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF75B0: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF75B4: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF75B8: 7D082850  subf r8, r8, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82CF75BC: 7CC62050  subf r6, r6, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 82CF75C0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF75C4: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF75C8: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF75CC: 41980008  blt cr6, 0x82cf75d4
	if ctx.cr[6].lt {
	pc = 0x82CF75D4; continue 'dispatch;
	}
	// 82CF75D0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	pc = 0x82CF75D4; continue 'dispatch;
            }
            0x82CF75D4 => {
    //   block [0x82CF75D4..0x82CF75F4)
	// 82CF75D4: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF75D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF75DC: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82CF75E0: 54E7083C  slwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF75E4: 38A7007F  addi r5, r7, 0x7f
	ctx.r[5].s64 = ctx.r[7].s64 + 127;
	// 82CF75E8: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF75EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF75F0: 419A0018  beq cr6, 0x82cf7608
	if ctx.cr[6].eq {
	pc = 0x82CF7608; continue 'dispatch;
	}
	pc = 0x82CF75F4; continue 'dispatch;
            }
            0x82CF75F4 => {
    //   block [0x82CF75F4..0x82CF7608)
	// 82CF75F4: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF75F8: 7C055A2C  dcbt r5, r11
	// 82CF75FC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF7600: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7604: 4198FFF0  blt cr6, 0x82cf75f4
	if ctx.cr[6].lt {
	pc = 0x82CF75F4; continue 'dispatch;
	}
	pc = 0x82CF7608; continue 'dispatch;
            }
            0x82CF7608 => {
    //   block [0x82CF7608..0x82CF7638)
	// 82CF7608: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CF760C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7610: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7614: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CF7618: F921FFD0  std r9, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[9].u64 ) };
	// 82CF761C: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7620: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7624: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CF7628: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF762C: C1A767A4  lfs f13, 0x67a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7630: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7634: C18967A0  lfs f12, 0x67a0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF7638; continue 'dispatch;
            }
            0x82CF7638 => {
    //   block [0x82CF7638..0x82CF7748)
	// 82CF7638: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 82CF763C: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF7640: F8E1FFD0  std r7, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[7].u64 ) };
	// 82CF7644: C941FFD0  lfd f10, -0x30(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7648: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF764C: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF7650: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF7654: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7658: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF765C: D0AA1400  stfs f5, 0x1400(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF7660: 88AB0004  lbz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7664: F8A1FFD8  std r5, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[5].u64 ) };
	// 82CF7668: C881FFD8  lfd f4, -0x28(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF766C: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF7670: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF7674: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF7678: ED410332  fmuls f10, f1, f12
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF767C: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7680: D12A1000  stfs f9, 0x1000(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF7684: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82CF7688: F921FFE0  std r9, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[9].u64 ) };
	// 82CF768C: C901FFE0  lfd f8, -0x20(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7690: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82CF7694: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82CF7698: ECA66828  fsubs f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF769C: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF76A0: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF76A4: D06A0C00  stfs f3, 0xc00(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF76A8: 88CB0002  lbz r6, 2(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF76AC: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF76B0: C841FFE8  lfd f2, -0x18(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF76B4: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF76B8: FD400818  frsp f10, f1
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF76BC: ED2A6828  fsubs f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF76C0: ED090332  fmuls f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF76C4: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF76C8: D0EA0800  stfs f7, 0x800(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF76CC: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF76D0: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82CF76D4: C8C1FFF0  lfd f6, -0x10(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF76D8: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF76DC: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF76E0: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF76E4: EC430332  fmuls f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF76E8: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF76EC: D02A0400  stfs f1, 0x400(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF76F0: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF76F4: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 82CF76F8: F8E1FFF8  std r7, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[7].u64 ) };
	// 82CF76FC: C941FFF8  lfd f10, -8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7700: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF7704: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF7708: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF770C: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7710: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7714: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7718: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF771C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7720: 4082FF18  bne 0x82cf7638
	if !ctx.cr[0].eq {
	pc = 0x82CF7638; continue 'dispatch;
	}
	// 82CF7724: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7728: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF772C: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF7730: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7734: 0CC80000  twi 6, r8, 0
	// 82CF7738: 7D274396  divwu r9, r7, r8
	ctx.r[9].u32 = ctx.r[7].u32 / ctx.r[8].u32;
	// 82CF773C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7740: 41980008  blt cr6, 0x82cf7748
	if ctx.cr[6].lt {
	pc = 0x82CF7748; continue 'dispatch;
	}
	// 82CF7744: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82CF7748; continue 'dispatch;
            }
            0x82CF7748 => {
    //   block [0x82CF7748..0x82CF7770)
	// 82CF7748: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF774C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7750: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7754: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF7758: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF775C: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7760: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7764: 4098000C  bge cr6, 0x82cf7770
	if !ctx.cr[6].lt {
		sub_82CF7770(ctx, base);
		return;
	}
	// 82CF7768: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF776C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CF7770 size=8
    let mut pc: u32 = 0x82CF7770;
    'dispatch: loop {
        match pc {
            0x82CF7770 => {
    //   block [0x82CF7770..0x82CF7778)
	// 82CF7770: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7778 size=332
    let mut pc: u32 = 0x82CF7778;
    'dispatch: loop {
        match pc {
            0x82CF7778 => {
    //   block [0x82CF7778..0x82CF77CC)
	// 82CF7778: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82CF777C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7780: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7784: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7788: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF778C: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7790: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7794: 7D0559D6  mullw r8, r5, r11
	ctx.r[8].s32 = ((ctx.r[5].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CF7798: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF779C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF77A0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF77A4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF77A8: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF77AC: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF77B0: 7D64F850  subf r11, r4, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 82CF77B4: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF77B8: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF77BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF77C0: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF77C4: 41980008  blt cr6, 0x82cf77cc
	if ctx.cr[6].lt {
	pc = 0x82CF77CC; continue 'dispatch;
	}
	// 82CF77C8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82CF77CC; continue 'dispatch;
            }
            0x82CF77CC => {
    //   block [0x82CF77CC..0x82CF77F8)
	// 82CF77CC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF77D0: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF77D4: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF77D8: 54A4083C  slwi r4, r5, 1
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF77DC: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82CF77E0: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF77E4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF77E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF77EC: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF77F0: C1AB0C58  lfs f13, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF77F4: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF77F8; continue 'dispatch;
            }
            0x82CF77F8 => {
    //   block [0x82CF77F8..0x82CF780C)
	// 82CF77F8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82CF77FC: 419A004C  beq cr6, 0x82cf7848
	if ctx.cr[6].eq {
	pc = 0x82CF7848; continue 'dispatch;
	}
	// 82CF7800: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82CF7804: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82CF7808: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x82CF780C; continue 'dispatch;
            }
            0x82CF780C => {
    //   block [0x82CF780C..0x82CF7848)
	// 82CF780C: A3EA0000  lhz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7810: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF7814: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82CF7818: 57FEC63E  rlwinm r30, r31, 0x18, 0x18, 0x1f
	ctx.r[30].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82CF781C: 53FE442E  rlwimi r30, r31, 8, 0x10, 0x17
	ctx.r[30].u64 = (((ctx.r[31].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[30].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7820: 7FDF0734  extsh r31, r30
	ctx.r[31].s64 = ctx.r[30].s16 as i64;
	// 82CF7824: FBE1FFE0  std r31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[31].u64 ) };
	// 82CF7828: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF782C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7830: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7834: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7838: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF783C: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7840: 39290400  addi r9, r9, 0x400
	ctx.r[9].s64 = ctx.r[9].s64 + 1024;
	// 82CF7844: 4082FFC8  bne 0x82cf780c
	if !ctx.cr[0].eq {
	pc = 0x82CF780C; continue 'dispatch;
	}
	pc = 0x82CF7848; continue 'dispatch;
            }
            0x82CF7848 => {
    //   block [0x82CF7848..0x82CF7884)
	// 82CF7848: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF784C: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7850: 7D044214  add r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 82CF7854: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF7858: 4082FFA0  bne 0x82cf77f8
	if !ctx.cr[0].eq {
	pc = 0x82CF77F8; continue 'dispatch;
	}
	// 82CF785C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7860: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7864: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF7868: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF786C: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF7870: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF7874: 0CC80000  twi 6, r8, 0
	// 82CF7878: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF787C: 41980008  blt cr6, 0x82cf7884
	if ctx.cr[6].lt {
	pc = 0x82CF7884; continue 'dispatch;
	}
	// 82CF7880: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF7884; continue 'dispatch;
            }
            0x82CF7884 => {
    //   block [0x82CF7884..0x82CF78B4)
	// 82CF7884: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7888: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF788C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7890: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF7894: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7898: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF789C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF78A0: 40980014  bge cr6, 0x82cf78b4
	if !ctx.cr[6].lt {
	pc = 0x82CF78B4; continue 'dispatch;
	}
	// 82CF78A4: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF78A8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF78AC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF78B0: 4E800020  blr
	return;
            }
            0x82CF78B4 => {
    //   block [0x82CF78B4..0x82CF78C4)
	// 82CF78B4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF78B8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF78BC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF78C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF78C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF78C8 size=324
    let mut pc: u32 = 0x82CF78C8;
    'dispatch: loop {
        match pc {
            0x82CF78C8 => {
    //   block [0x82CF78C8..0x82CF7918)
	// 82CF78C8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF78CC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF78D0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF78D4: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF78D8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF78DC: 7C8A59D6  mullw r4, r10, r11
	ctx.r[4].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF78E0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF78E4: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF78E8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF78EC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF78F0: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF78F4: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF78F8: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF78FC: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF7900: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CF7904: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7908: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF790C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF7910: 41980008  blt cr6, 0x82cf7918
	if ctx.cr[6].lt {
	pc = 0x82CF7918; continue 'dispatch;
	}
	// 82CF7914: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82CF7918; continue 'dispatch;
            }
            0x82CF7918 => {
    //   block [0x82CF7918..0x82CF7930)
	// 82CF7918: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF791C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF7920: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF7924: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF7928: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF792C: 419A0018  beq cr6, 0x82cf7944
	if ctx.cr[6].eq {
	pc = 0x82CF7944; continue 'dispatch;
	}
	pc = 0x82CF7930; continue 'dispatch;
            }
            0x82CF7930 => {
    //   block [0x82CF7930..0x82CF7944)
	// 82CF7930: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7934: 7C05522C  dcbt r5, r10
	// 82CF7938: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF793C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF7940: 4198FFF0  blt cr6, 0x82cf7930
	if ctx.cr[6].lt {
	pc = 0x82CF7930; continue 'dispatch;
	}
	pc = 0x82CF7944; continue 'dispatch;
            }
            0x82CF7944 => {
    //   block [0x82CF7944..0x82CF796C)
	// 82CF7944: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CF7948: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF794C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7950: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF7954: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF7958: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF795C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF7960: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7964: C1AB0C58  lfs f13, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7968: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF796C; continue 'dispatch;
            }
            0x82CF796C => {
    //   block [0x82CF796C..0x82CF79D4)
	// 82CF796C: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7970: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF7974: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82CF7978: 5568C63E  rlwinm r8, r11, 0x18, 0x18, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CF797C: 5168442E  rlwimi r8, r11, 8, 0x10, 0x17
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7980: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 82CF7984: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82CF7988: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF798C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7990: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7994: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7998: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF799C: D0E70000  stfs f7, 0(r7)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF79A0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF79A4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF79A8: 4082FFC4  bne 0x82cf796c
	if !ctx.cr[0].eq {
	pc = 0x82CF796C; continue 'dispatch;
	}
	// 82CF79AC: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF79B0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF79B4: 5568083E  rotlwi r8, r11, 1
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 82CF79B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF79BC: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82CF79C0: 0CC80000  twi 6, r8, 0
	// 82CF79C4: 7D464396  divwu r10, r6, r8
	ctx.r[10].u32 = ctx.r[6].u32 / ctx.r[8].u32;
	// 82CF79C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF79CC: 41980008  blt cr6, 0x82cf79d4
	if ctx.cr[6].lt {
	pc = 0x82CF79D4; continue 'dispatch;
	}
	// 82CF79D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF79D4; continue 'dispatch;
            }
            0x82CF79D4 => {
    //   block [0x82CF79D4..0x82CF7A00)
	// 82CF79D4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF79D8: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF79DC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF79E0: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF79E4: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF79E8: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF79EC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF79F0: 40980010  bge cr6, 0x82cf7a00
	if !ctx.cr[6].lt {
	pc = 0x82CF7A00; continue 'dispatch;
	}
	// 82CF79F4: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF79F8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF79FC: 4E800020  blr
	return;
            }
            0x82CF7A00 => {
    //   block [0x82CF7A00..0x82CF7A0C)
	// 82CF7A00: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7A04: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7A10 size=368
    let mut pc: u32 = 0x82CF7A10;
    'dispatch: loop {
        match pc {
            0x82CF7A10 => {
    //   block [0x82CF7A10..0x82CF7A60)
	// 82CF7A10: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7A14: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7A18: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7A1C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7A20: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7A24: 7C8951D6  mullw r4, r9, r10
	ctx.r[4].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82CF7A28: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7A2C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7A30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7A34: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7A38: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF7A3C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7A40: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82CF7A44: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF7A48: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF7A4C: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7A50: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF7A54: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF7A58: 41980008  blt cr6, 0x82cf7a60
	if ctx.cr[6].lt {
	pc = 0x82CF7A60; continue 'dispatch;
	}
	// 82CF7A5C: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82CF7A60; continue 'dispatch;
            }
            0x82CF7A60 => {
    //   block [0x82CF7A60..0x82CF7A78)
	// 82CF7A60: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7A64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF7A68: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF7A6C: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7A70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF7A74: 419A0018  beq cr6, 0x82cf7a8c
	if ctx.cr[6].eq {
	pc = 0x82CF7A8C; continue 'dispatch;
	}
	pc = 0x82CF7A78; continue 'dispatch;
            }
            0x82CF7A78 => {
    //   block [0x82CF7A78..0x82CF7A8C)
	// 82CF7A78: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7A7C: 7C055A2C  dcbt r5, r11
	// 82CF7A80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF7A84: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7A88: 4198FFF0  blt cr6, 0x82cf7a78
	if ctx.cr[6].lt {
	pc = 0x82CF7A78; continue 'dispatch;
	}
	pc = 0x82CF7A8C; continue 'dispatch;
            }
            0x82CF7A8C => {
    //   block [0x82CF7A8C..0x82CF7AB4)
	// 82CF7A8C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF7A90: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7A94: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7A98: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82CF7A9C: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7AA0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7AA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF7AA8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7AAC: C1AA0C58  lfs f13, 0xc58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7AB0: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF7AB4; continue 'dispatch;
            }
            0x82CF7AB4 => {
    //   block [0x82CF7AB4..0x82CF7B48)
	// 82CF7AB4: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF7AB8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF7ABC: 5547C63E  rlwinm r7, r10, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CF7AC0: 5147442E  rlwimi r7, r10, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7AC4: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF7AC8: F8A1FFE0  std r5, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[5].u64 ) };
	// 82CF7ACC: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7AD0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7AD4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7AD8: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7ADC: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7AE0: D0E80400  stfs f7, 0x400(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7AE4: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7AE8: 548AC63E  rlwinm r10, r4, 0x18, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CF7AEC: 508A442E  rlwimi r10, r4, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7AF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF7AF4: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF7AF8: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF7AFC: C8C1FFE8  lfd f6, -0x18(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF7B00: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF7B04: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF7B08: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7B0C: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7B10: D0480000  stfs f2, 0(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7B14: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF7B18: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7B1C: 4082FF98  bne 0x82cf7ab4
	if !ctx.cr[0].eq {
	pc = 0x82CF7AB4; continue 'dispatch;
	}
	// 82CF7B20: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7B24: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7B28: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF7B2C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7B30: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF7B34: 0CC70000  twi 6, r7, 0
	// 82CF7B38: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF7B3C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF7B40: 40980008  bge cr6, 0x82cf7b48
	if !ctx.cr[6].lt {
	pc = 0x82CF7B48; continue 'dispatch;
	}
	// 82CF7B44: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF7B48; continue 'dispatch;
            }
            0x82CF7B48 => {
    //   block [0x82CF7B48..0x82CF7B74)
	// 82CF7B48: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7B4C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7B50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7B54: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF7B58: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7B5C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7B60: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7B64: 40980010  bge cr6, 0x82cf7b74
	if !ctx.cr[6].lt {
	pc = 0x82CF7B74; continue 'dispatch;
	}
	// 82CF7B68: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7B6C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7B70: 4E800020  blr
	return;
            }
            0x82CF7B74 => {
    //   block [0x82CF7B74..0x82CF7B80)
	// 82CF7B74: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7B78: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7B7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7B80 size=456
    let mut pc: u32 = 0x82CF7B80;
    'dispatch: loop {
        match pc {
            0x82CF7B80 => {
    //   block [0x82CF7B80..0x82CF7BD0)
	// 82CF7B80: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7B84: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7B88: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7B8C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7B90: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7B94: 7CA951D6  mullw r5, r9, r10
	ctx.r[5].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF7B98: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7B9C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7BA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7BA4: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7BA8: 54A9083C  slwi r9, r5, 1
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF7BAC: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7BB0: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF7BB4: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF7BB8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF7BBC: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7BC0: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF7BC4: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF7BC8: 41980008  blt cr6, 0x82cf7bd0
	if ctx.cr[6].lt {
	pc = 0x82CF7BD0; continue 'dispatch;
	}
	// 82CF7BCC: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	pc = 0x82CF7BD0; continue 'dispatch;
            }
            0x82CF7BD0 => {
    //   block [0x82CF7BD0..0x82CF7BE8)
	// 82CF7BD0: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7BD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF7BD8: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF7BDC: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7BE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF7BE4: 419A0018  beq cr6, 0x82cf7bfc
	if ctx.cr[6].eq {
	pc = 0x82CF7BFC; continue 'dispatch;
	}
	pc = 0x82CF7BE8; continue 'dispatch;
            }
            0x82CF7BE8 => {
    //   block [0x82CF7BE8..0x82CF7BFC)
	// 82CF7BE8: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7BEC: 7C055A2C  dcbt r5, r11
	// 82CF7BF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF7BF4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7BF8: 4198FFF0  blt cr6, 0x82cf7be8
	if ctx.cr[6].lt {
	pc = 0x82CF7BE8; continue 'dispatch;
	}
	pc = 0x82CF7BFC; continue 'dispatch;
            }
            0x82CF7BFC => {
    //   block [0x82CF7BFC..0x82CF7C24)
	// 82CF7BFC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF7C00: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7C04: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7C08: F941FFD0  std r10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[10].u64 ) };
	// 82CF7C0C: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7C10: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7C14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF7C18: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7C1C: C1AA0C58  lfs f13, 0xc58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7C20: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF7C24; continue 'dispatch;
            }
            0x82CF7C24 => {
    //   block [0x82CF7C24..0x82CF7D10)
	// 82CF7C24: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF7C28: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF7C2C: 5547C63E  rlwinm r7, r10, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CF7C30: 5147442E  rlwimi r7, r10, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7C34: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF7C38: F8A1FFD0  std r5, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u64 ) };
	// 82CF7C3C: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7C40: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7C44: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7C48: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7C4C: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7C50: D0E90C00  stfs f7, 0xc00(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF7C54: A08B0004  lhz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7C58: 548AC63E  rlwinm r10, r4, 0x18, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CF7C5C: 508A442E  rlwimi r10, r4, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7C60: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF7C64: F8C1FFD8  std r6, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[6].u64 ) };
	// 82CF7C68: C8C1FFD8  lfd f6, -0x28(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF7C6C: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF7C70: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF7C74: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7C78: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7C7C: D0490800  stfs f2, 0x800(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF7C80: A0AB0002  lhz r5, 2(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF7C84: 54A4C63E  rlwinm r4, r5, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82CF7C88: 50A4442E  rlwimi r4, r5, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7C8C: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF7C90: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF7C94: C821FFE0  lfd f1, -0x20(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7C98: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 82CF7C9C: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF7CA0: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7CA4: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7CA8: D1090400  stfs f8, 0x400(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7CAC: A0CB0000  lhz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7CB0: 54C5C63E  rlwinm r5, r6, 0x18, 0x18, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CF7CB4: 50C5442E  rlwimi r5, r6, 8, 0x10, 0x17
	ctx.r[5].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7CB8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF7CBC: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 82CF7CC0: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 82CF7CC4: C8E1FFE8  lfd f7, -0x18(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF7CC8: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF7CCC: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF7CD0: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7CD4: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7CD8: D0690000  stfs f3, 0(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7CDC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF7CE0: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7CE4: 4082FF40  bne 0x82cf7c24
	if !ctx.cr[0].eq {
	pc = 0x82CF7C24; continue 'dispatch;
	}
	// 82CF7CE8: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7CEC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7CF0: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF7CF4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7CF8: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF7CFC: 0CC70000  twi 6, r7, 0
	// 82CF7D00: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF7D04: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF7D08: 40980008  bge cr6, 0x82cf7d10
	if !ctx.cr[6].lt {
	pc = 0x82CF7D10; continue 'dispatch;
	}
	// 82CF7D0C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF7D10; continue 'dispatch;
            }
            0x82CF7D10 => {
    //   block [0x82CF7D10..0x82CF7D3C)
	// 82CF7D10: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7D14: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7D18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7D1C: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF7D20: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7D24: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7D28: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7D2C: 40980010  bge cr6, 0x82cf7d3c
	if !ctx.cr[6].lt {
	pc = 0x82CF7D3C; continue 'dispatch;
	}
	// 82CF7D30: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7D34: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7D38: 4E800020  blr
	return;
            }
            0x82CF7D3C => {
    //   block [0x82CF7D3C..0x82CF7D48)
	// 82CF7D3C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7D40: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7D44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7D48 size=548
    let mut pc: u32 = 0x82CF7D48;
    'dispatch: loop {
        match pc {
            0x82CF7D48 => {
    //   block [0x82CF7D48..0x82CF7D94)
	// 82CF7D48: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7D4C: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7D50: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7D54: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7D58: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7D5C: 7CA741D6  mullw r5, r7, r8
	ctx.r[5].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82CF7D60: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7D64: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7D68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7D6C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7D70: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7D74: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7D78: 7D082050  subf r8, r8, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF7D7C: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF7D80: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF7D84: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF7D88: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF7D8C: 41980008  blt cr6, 0x82cf7d94
	if ctx.cr[6].lt {
	pc = 0x82CF7D94; continue 'dispatch;
	}
	// 82CF7D90: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	pc = 0x82CF7D94; continue 'dispatch;
            }
            0x82CF7D94 => {
    //   block [0x82CF7D94..0x82CF7DB4)
	// 82CF7D94: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7D98: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF7D9C: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82CF7DA0: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7DA4: 38A7007F  addi r5, r7, 0x7f
	ctx.r[5].s64 = ctx.r[7].s64 + 127;
	// 82CF7DA8: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7DAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF7DB0: 419A0018  beq cr6, 0x82cf7dc8
	if ctx.cr[6].eq {
	pc = 0x82CF7DC8; continue 'dispatch;
	}
	pc = 0x82CF7DB4; continue 'dispatch;
            }
            0x82CF7DB4 => {
    //   block [0x82CF7DB4..0x82CF7DC8)
	// 82CF7DB4: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7DB8: 7C055A2C  dcbt r5, r11
	// 82CF7DBC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF7DC0: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7DC4: 4198FFF0  blt cr6, 0x82cf7db4
	if ctx.cr[6].lt {
	pc = 0x82CF7DB4; continue 'dispatch;
	}
	pc = 0x82CF7DC8; continue 'dispatch;
            }
            0x82CF7DC8 => {
    //   block [0x82CF7DC8..0x82CF7DF0)
	// 82CF7DC8: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CF7DCC: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7DD0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7DD4: F921FFC0  std r9, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[9].u64 ) };
	// 82CF7DD8: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF7DDC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7DE0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF7DE4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7DE8: C1A90C58  lfs f13, 0xc58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7DEC: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	pc = 0x82CF7DF0; continue 'dispatch;
            }
            0x82CF7DF0 => {
    //   block [0x82CF7DF0..0x82CF7F34)
	// 82CF7DF0: A12B000A  lhz r9, 0xa(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 82CF7DF4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF7DF8: 5527C63E  rlwinm r7, r9, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CF7DFC: 5127442E  rlwimi r7, r9, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7E00: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF7E04: F8A1FFC0  std r5, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[5].u64 ) };
	// 82CF7E08: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF7E0C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7E10: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7E14: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7E18: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7E1C: D0EA1400  stfs f7, 0x1400(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF7E20: A08B0008  lhz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7E24: 5489C63E  rlwinm r9, r4, 0x18, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CF7E28: 5089442E  rlwimi r9, r4, 8, 0x10, 0x17
	ctx.r[9].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7E2C: 7D260734  extsh r6, r9
	ctx.r[6].s64 = ctx.r[9].s16 as i64;
	// 82CF7E30: F8C1FFC8  std r6, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[6].u64 ) };
	// 82CF7E34: C8C1FFC8  lfd f6, -0x38(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CF7E38: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF7E3C: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF7E40: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7E44: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7E48: D04A1000  stfs f2, 0x1000(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF7E4C: A0AB0006  lhz r5, 6(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF7E50: 54A4C63E  rlwinm r4, r5, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82CF7E54: 50A4442E  rlwimi r4, r5, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7E58: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF7E5C: F8E1FFD0  std r7, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[7].u64 ) };
	// 82CF7E60: C821FFD0  lfd f1, -0x30(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7E64: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 82CF7E68: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF7E6C: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7E70: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7E74: D10A0C00  stfs f8, 0xc00(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF7E78: A0CB0004  lhz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7E7C: 54C5C63E  rlwinm r5, r6, 0x18, 0x18, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CF7E80: 50C5442E  rlwimi r5, r6, 8, 0x10, 0x17
	ctx.r[5].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7E84: 7CA90734  extsh r9, r5
	ctx.r[9].s64 = ctx.r[5].s16 as i64;
	// 82CF7E88: F921FFD8  std r9, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[9].u64 ) };
	// 82CF7E8C: C8E1FFD8  lfd f7, -0x28(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF7E90: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF7E94: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF7E98: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7E9C: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7EA0: D06A0800  stfs f3, 0x800(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF7EA4: A0EB0002  lhz r7, 2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF7EA8: 54E6C63E  rlwinm r6, r7, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82CF7EAC: 50E6442E  rlwimi r6, r7, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[7].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7EB0: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CF7EB4: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CF7EB8: C841FFE0  lfd f2, -0x20(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7EBC: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF7EC0: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF7EC4: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7EC8: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7ECC: D12A0400  stfs f9, 0x400(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7ED0: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7ED4: 5527C63E  rlwinm r7, r9, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CF7ED8: 5127442E  rlwimi r7, r9, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7EDC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82CF7EE0: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF7EE4: F8A1FFE8  std r5, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[5].u64 ) };
	// 82CF7EE8: C901FFE8  lfd f8, -0x18(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF7EEC: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82CF7EF0: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82CF7EF4: ECA60372  fmuls f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7EF8: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7EFC: D08A0000  stfs f4, 0(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7F00: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF7F04: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7F08: 4082FEE8  bne 0x82cf7df0
	if !ctx.cr[0].eq {
	pc = 0x82CF7DF0; continue 'dispatch;
	}
	// 82CF7F0C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7F10: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7F14: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82CF7F18: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7F1C: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF7F20: 0CC70000  twi 6, r7, 0
	// 82CF7F24: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF7F28: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF7F2C: 40980008  bge cr6, 0x82cf7f34
	if !ctx.cr[6].lt {
	pc = 0x82CF7F34; continue 'dispatch;
	}
	// 82CF7F30: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82CF7F34; continue 'dispatch;
            }
            0x82CF7F34 => {
    //   block [0x82CF7F34..0x82CF7F60)
	// 82CF7F34: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7F38: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7F3C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7F40: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF7F44: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF7F48: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7F4C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7F50: 40980010  bge cr6, 0x82cf7f60
	if !ctx.cr[6].lt {
	pc = 0x82CF7F60; continue 'dispatch;
	}
	// 82CF7F54: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7F58: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7F5C: 4E800020  blr
	return;
            }
            0x82CF7F60 => {
    //   block [0x82CF7F60..0x82CF7F6C)
	// 82CF7F60: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7F64: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7F70 size=400
    let mut pc: u32 = 0x82CF7F70;
    'dispatch: loop {
        match pc {
            0x82CF7F70 => {
    //   block [0x82CF7F70..0x82CF7FD0)
	// 82CF7F70: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82CF7F74: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7F78: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7F7C: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7F80: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7F84: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82CF7F88: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF7F8C: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7F90: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7F94: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF7F98: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7F9C: 7D0429D6  mullw r8, r4, r5
	ctx.r[8].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CF7FA0: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7FA4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7FA8: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82CF7FAC: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82CF7FB0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF7FB4: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82CF7FB8: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF7FBC: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF7FC0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF7FC4: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF7FC8: 41980008  blt cr6, 0x82cf7fd0
	if ctx.cr[6].lt {
	pc = 0x82CF7FD0; continue 'dispatch;
	}
	// 82CF7FCC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82CF7FD0; continue 'dispatch;
            }
            0x82CF7FD0 => {
    //   block [0x82CF7FD0..0x82CF800C)
	// 82CF7FD0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF7FD4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7FD8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7FDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF7FE0: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82CF7FE4: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7FE8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7FEC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF7FF0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7FF4: C1AA0C4C  lfs f13, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7FF8: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7FFC: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8000: 419A0018  beq cr6, 0x82cf8018
	if ctx.cr[6].eq {
	pc = 0x82CF8018; continue 'dispatch;
	}
	// 82CF8004: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82CF8008: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82CF800C; continue 'dispatch;
            }
            0x82CF800C => {
    //   block [0x82CF800C..0x82CF8018)
	// 82CF800C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF8010: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF8014: 4082FFF8  bne 0x82cf800c
	if !ctx.cr[0].eq {
	pc = 0x82CF800C; continue 'dispatch;
	}
	pc = 0x82CF8018; continue 'dispatch;
            }
            0x82CF8018 => {
    //   block [0x82CF8018..0x82CF8024)
	// 82CF8018: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF801C: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82CF8020: C18B0BFC  lfs f12, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF8024; continue 'dispatch;
            }
            0x82CF8024 => {
    //   block [0x82CF8024..0x82CF8040)
	// 82CF8024: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF8028: 419A004C  beq cr6, 0x82cf8074
	if ctx.cr[6].eq {
	pc = 0x82CF8074; continue 'dispatch;
	}
	// 82CF802C: EDAB002A  fadds f13, f11, f0
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8030: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82CF8034: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82CF8038: 7D1F2850  subf r8, r31, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 82CF803C: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	pc = 0x82CF8040; continue 'dispatch;
            }
            0x82CF8040 => {
    //   block [0x82CF8040..0x82CF8074)
	// 82CF8040: 7D285C2E  lfsx f9, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF8044: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF8048: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF804C: ECED0272  fmuls f7, f13, f9
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[9].f64) as f32) as f64);
	// 82CF8050: ECC9402A  fadds f6, f9, f8
	ctx.f[6].f64 = ((ctx.f[9].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF8054: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8058: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF805C: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8060: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8064: D08A0000  stfs f4, 0(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8068: D0EA0004  stfs f7, 4(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF806C: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CF8070: 4082FFD0  bne 0x82cf8040
	if !ctx.cr[0].eq {
	pc = 0x82CF8040; continue 'dispatch;
	}
	pc = 0x82CF8074; continue 'dispatch;
            }
            0x82CF8074 => {
    //   block [0x82CF8074..0x82CF80B0)
	// 82CF8074: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF8078: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF807C: 7CBE2A14  add r5, r30, r5
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[5].u64;
	// 82CF8080: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82CF8084: 4082FFA0  bne 0x82cf8024
	if !ctx.cr[0].eq {
	pc = 0x82CF8024; continue 'dispatch;
	}
	// 82CF8088: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF808C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8090: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF8094: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8098: 5548103E  rotlwi r8, r10, 2
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF809C: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF80A0: 0CC80000  twi 6, r8, 0
	// 82CF80A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF80A8: 41980008  blt cr6, 0x82cf80b0
	if ctx.cr[6].lt {
	pc = 0x82CF80B0; continue 'dispatch;
	}
	// 82CF80AC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF80B0; continue 'dispatch;
            }
            0x82CF80B0 => {
    //   block [0x82CF80B0..0x82CF80D0)
	// 82CF80B0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF80B4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF80B8: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF80BC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF80C0: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF80C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF80C8: 40980008  bge cr6, 0x82cf80d0
	if !ctx.cr[6].lt {
	pc = 0x82CF80D0; continue 'dispatch;
	}
	// 82CF80CC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF80D0; continue 'dispatch;
            }
            0x82CF80D0 => {
    //   block [0x82CF80D0..0x82CF80E8)
	// 82CF80D0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF80D4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF80D8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF80DC: 419A0018  beq cr6, 0x82cf80f4
	if ctx.cr[6].eq {
	pc = 0x82CF80F4; continue 'dispatch;
	}
	// 82CF80E0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82CF80E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82CF80E8; continue 'dispatch;
            }
            0x82CF80E8 => {
    //   block [0x82CF80E8..0x82CF80F4)
	// 82CF80E8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF80EC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF80F0: 4082FFF8  bne 0x82cf80e8
	if !ctx.cr[0].eq {
	pc = 0x82CF80E8; continue 'dispatch;
	}
	pc = 0x82CF80F4; continue 'dispatch;
            }
            0x82CF80F4 => {
    //   block [0x82CF80F4..0x82CF8100)
	// 82CF80F4: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF80F8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF80FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8100 size=316
    let mut pc: u32 = 0x82CF8100;
    'dispatch: loop {
        match pc {
            0x82CF8100 => {
    //   block [0x82CF8100..0x82CF8150)
	// 82CF8100: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8104: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8108: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF810C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8110: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8114: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8118: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF811C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8120: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF8124: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8128: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF812C: 7CA50E70  srawi r5, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CF8130: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8134: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CF8138: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CF813C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CF8140: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF8144: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF8148: 41980008  blt cr6, 0x82cf8150
	if ctx.cr[6].lt {
	pc = 0x82CF8150; continue 'dispatch;
	}
	// 82CF814C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x82CF8150; continue 'dispatch;
            }
            0x82CF8150 => {
    //   block [0x82CF8150..0x82CF8194)
	// 82CF8150: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82CF8154: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8158: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF815C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8160: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CF8164: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8168: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF816C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF8170: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8174: 38AA007F  addi r5, r10, 0x7f
	ctx.r[5].s64 = ctx.r[10].s64 + 127;
	// 82CF8178: C1860C4C  lfs f12, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF817C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF8180: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF8184: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF8188: EDAB4024  fdivs f13, f11, f8
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CF818C: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8190: 419A0018  beq cr6, 0x82cf81a8
	if ctx.cr[6].eq {
	pc = 0x82CF81A8; continue 'dispatch;
	}
	pc = 0x82CF8194; continue 'dispatch;
            }
            0x82CF8194 => {
    //   block [0x82CF8194..0x82CF81A8)
	// 82CF8194: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8198: 7C065A2C  dcbt r6, r11
	// 82CF819C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF81A0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF81A4: 4198FFF0  blt cr6, 0x82cf8194
	if ctx.cr[6].lt {
	pc = 0x82CF8194; continue 'dispatch;
	}
	pc = 0x82CF81A8; continue 'dispatch;
            }
            0x82CF81A8 => {
    //   block [0x82CF81A8..0x82CF81B0)
	// 82CF81A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF81AC: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82CF81B0; continue 'dispatch;
            }
            0x82CF81B0 => {
    //   block [0x82CF81B0..0x82CF8214)
	// 82CF81B0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF81B4: ED2D002A  fadds f9, f13, f0
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF81B8: C1030034  lfs f8, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF81BC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF81C0: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF81C4: D1430034  stfs f10, 0x34(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CF81C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF81CC: ECC902B2  fmuls f6, f9, f10
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF81D0: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF81D4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF81D8: EC8502F2  fmuls f4, f5, f11
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF81DC: D0880000  stfs f4, 0(r8)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF81E0: D0C80004  stfs f6, 4(r8)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF81E4: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82CF81E8: 4082FFC8  bne 0x82cf81b0
	if !ctx.cr[0].eq {
	pc = 0x82CF81B0; continue 'dispatch;
	}
	// 82CF81EC: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF81F0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF81F4: 5547103E  rotlwi r7, r10, 2
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF81F8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF81FC: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF8200: 0CC70000  twi 6, r7, 0
	// 82CF8204: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF8208: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF820C: 40980008  bge cr6, 0x82cf8214
	if !ctx.cr[6].lt {
	pc = 0x82CF8214; continue 'dispatch;
	}
	// 82CF8210: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF8214; continue 'dispatch;
            }
            0x82CF8214 => {
    //   block [0x82CF8214..0x82CF823C)
	// 82CF8214: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8218: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF821C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF8220: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF8224: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8228: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF822C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF8230: 4098000C  bge cr6, 0x82cf823c
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82CF823C);
		return;
	}
	// 82CF8234: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF8238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8248 size=404
    let mut pc: u32 = 0x82CF8248;
    'dispatch: loop {
        match pc {
            0x82CF8248 => {
    //   block [0x82CF8248..0x82CF82A0)
	// 82CF8248: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF824C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8250: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8254: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8258: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF825C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8260: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8264: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8268: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF826C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8270: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF8274: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8278: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF827C: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF8280: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8284: 7D09F850  subf r8, r9, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 82CF8288: 7D240194  addze r9, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[9].s64 = tmp.s64;
	// 82CF828C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF8290: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF8294: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82CF8298: 41980008  blt cr6, 0x82cf82a0
	if ctx.cr[6].lt {
	pc = 0x82CF82A0; continue 'dispatch;
	}
	// 82CF829C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CF82A0; continue 'dispatch;
            }
            0x82CF82A0 => {
    //   block [0x82CF82A0..0x82CF82E4)
	// 82CF82A0: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82CF82A4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF82A8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF82AC: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF82B0: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CF82B4: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF82B8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF82BC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF82C0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF82C4: 3889007F  addi r4, r9, 0x7f
	ctx.r[4].s64 = ctx.r[9].s64 + 127;
	// 82CF82C8: C1A60C4C  lfs f13, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF82CC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF82D0: 5487C9FE  srwi r7, r4, 7
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF82D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF82D8: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF82DC: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF82E0: 419A0018  beq cr6, 0x82cf82f8
	if ctx.cr[6].eq {
	pc = 0x82CF82F8; continue 'dispatch;
	}
	pc = 0x82CF82E4; continue 'dispatch;
            }
            0x82CF82E4 => {
    //   block [0x82CF82E4..0x82CF82F8)
	// 82CF82E4: 55263830  slwi r6, r9, 7
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF82E8: 7C065A2C  dcbt r6, r11
	// 82CF82EC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF82F0: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF82F4: 4198FFF0  blt cr6, 0x82cf82e4
	if ctx.cr[6].lt {
	pc = 0x82CF82E4; continue 'dispatch;
	}
	pc = 0x82CF82F8; continue 'dispatch;
            }
            0x82CF82F8 => {
    //   block [0x82CF82F8..0x82CF8300)
	// 82CF82F8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82CF82FC: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82CF8300; continue 'dispatch;
            }
            0x82CF8300 => {
    //   block [0x82CF8300..0x82CF8314)
	// 82CF8300: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF8304: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF8308: 4082FFF8  bne 0x82cf8300
	if !ctx.cr[0].eq {
	pc = 0x82CF8300; continue 'dispatch;
	}
	// 82CF830C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF8310: C1A90BFC  lfs f13, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF8314; continue 'dispatch;
            }
            0x82CF8314 => {
    //   block [0x82CF8314..0x82CF839C)
	// 82CF8314: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF8318: ED2C002A  fadds f9, f12, f0
	ctx.f[9].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF831C: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF8320: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF8324: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF8328: D1450004  stfs f10, 4(r5)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF832C: ECC902B2  fmuls f6, f9, f10
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8330: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8334: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8338: D08A0400  stfs f4, 0x400(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF833C: D0CA0404  stfs f6, 0x404(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8340: C0250000  lfs f1, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CF8344: C06B0000  lfs f3, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF8348: EC4900F2  fmuls f2, f9, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF834C: ED43082A  fadds f10, f3, f1
	ctx.f[10].f64 = ((ctx.f[3].f64 + ctx.f[1].f64) as f32) as f64;
	// 82CF8350: D0650000  stfs f3, 0(r5)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8354: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF8358: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF835C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8360: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8364: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8368: D04A0004  stfs f2, 4(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF836C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CF8370: 4082FFA4  bne 0x82cf8314
	if !ctx.cr[0].eq {
	pc = 0x82CF8314; continue 'dispatch;
	}
	// 82CF8374: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8378: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF837C: 5527103E  rotlwi r7, r9, 2
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 82CF8380: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8384: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF8388: 0CC70000  twi 6, r7, 0
	// 82CF838C: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF8390: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF8394: 40980008  bge cr6, 0x82cf839c
	if !ctx.cr[6].lt {
	pc = 0x82CF839C; continue 'dispatch;
	}
	// 82CF8398: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82CF839C; continue 'dispatch;
            }
            0x82CF839C => {
    //   block [0x82CF839C..0x82CF83BC)
	// 82CF839C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF83A0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF83A4: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF83A8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF83AC: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF83B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF83B4: 40980008  bge cr6, 0x82cf83bc
	if !ctx.cr[6].lt {
	pc = 0x82CF83BC; continue 'dispatch;
	}
	// 82CF83B8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF83BC; continue 'dispatch;
            }
            0x82CF83BC => {
    //   block [0x82CF83BC..0x82CF83C8)
	// 82CF83BC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF83C0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF83C4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82CF83C8; continue 'dispatch;
            }
            0x82CF83C8 => {
    //   block [0x82CF83C8..0x82CF83DC)
	// 82CF83C8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF83CC: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82CF83D0: 4082FFF8  bne 0x82cf83c8
	if !ctx.cr[0].eq {
	pc = 0x82CF83C8; continue 'dispatch;
	}
	// 82CF83D4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF83D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF83E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF83E0 size=476
    let mut pc: u32 = 0x82CF83E0;
    'dispatch: loop {
        match pc {
            0x82CF83E0 => {
    //   block [0x82CF83E0..0x82CF8438)
	// 82CF83E0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF83E4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF83E8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF83EC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF83F0: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 82CF83F4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF83F8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF83FC: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8400: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8404: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8408: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF840C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8410: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8414: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF8418: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CF841C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8420: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF8424: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF8428: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF842C: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF8430: 41980008  blt cr6, 0x82cf8438
	if ctx.cr[6].lt {
	pc = 0x82CF8438; continue 'dispatch;
	}
	// 82CF8434: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82CF8438; continue 'dispatch;
            }
            0x82CF8438 => {
    //   block [0x82CF8438..0x82CF847C)
	// 82CF8438: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF843C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8440: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8444: 54E82036  slwi r8, r7, 4
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8448: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82CF844C: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8450: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF8454: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CF8458: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF845C: 3888007F  addi r4, r8, 0x7f
	ctx.r[4].s64 = ctx.r[8].s64 + 127;
	// 82CF8460: C1A50C4C  lfs f13, 0xc4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8464: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CF8468: 5486C9FE  srwi r6, r4, 7
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF846C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF8470: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF8474: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8478: 419A0018  beq cr6, 0x82cf8490
	if ctx.cr[6].eq {
	pc = 0x82CF8490; continue 'dispatch;
	}
	pc = 0x82CF847C; continue 'dispatch;
            }
            0x82CF847C => {
    //   block [0x82CF847C..0x82CF8490)
	// 82CF847C: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF8480: 7C05522C  dcbt r5, r10
	// 82CF8484: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF8488: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF848C: 4198FFF0  blt cr6, 0x82cf847c
	if ctx.cr[6].lt {
	pc = 0x82CF847C; continue 'dispatch;
	}
	pc = 0x82CF8490; continue 'dispatch;
            }
            0x82CF8490 => {
    //   block [0x82CF8490..0x82CF8498)
	// 82CF8490: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 82CF8494: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	pc = 0x82CF8498; continue 'dispatch;
            }
            0x82CF8498 => {
    //   block [0x82CF8498..0x82CF84AC)
	// 82CF8498: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF849C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82CF84A0: 4082FFF8  bne 0x82cf8498
	if !ctx.cr[0].eq {
	pc = 0x82CF8498; continue 'dispatch;
	}
	// 82CF84A4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF84A8: C1A80BFC  lfs f13, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF84AC; continue 'dispatch;
            }
            0x82CF84AC => {
    //   block [0x82CF84AC..0x82CF857C)
	// 82CF84AC: C14A000C  lfs f10, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF84B0: ED2C002A  fadds f9, f12, f0
	ctx.f[9].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF84B4: C109000C  lfs f8, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF84B8: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF84BC: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF84C0: D149000C  stfs f10, 0xc(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF84C4: ECC902B2  fmuls f6, f9, f10
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF84C8: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF84CC: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF84D0: D08B0C00  stfs f4, 0xc00(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF84D4: D0CB0C04  stfs f6, 0xc04(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF84D8: C06A0008  lfs f3, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF84DC: EC4900F2  fmuls f2, f9, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF84E0: C0290008  lfs f1, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CF84E4: ED43082A  fadds f10, f3, f1
	ctx.f[10].f64 = ((ctx.f[3].f64 + ctx.f[1].f64) as f32) as f64;
	// 82CF84E8: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF84EC: D0690008  stfs f3, 8(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF84F0: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF84F4: D0EB0800  stfs f7, 0x800(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF84F8: D04B0804  stfs f2, 0x804(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF84FC: C0CA0004  lfs f6, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF8500: ECA901B2  fmuls f5, f9, f6
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF8504: C0890004  lfs f4, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF8508: EC66202A  fadds f3, f6, f4
	ctx.f[3].f64 = ((ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CF850C: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8510: D0C90004  stfs f6, 4(r9)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8514: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8518: D02B0400  stfs f1, 0x400(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF851C: D0AB0404  stfs f5, 0x404(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8520: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF8524: ED2902B2  fmuls f9, f9, f10
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8528: C1090000  lfs f8, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF852C: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF8530: ECC70032  fmuls f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8534: D1490000  stfs f10, 0(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8538: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82CF853C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8540: ECA60372  fmuls f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8544: D0AB0000  stfs f5, 0(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8548: D12B0004  stfs f9, 4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF854C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF8550: 4082FF5C  bne 0x82cf84ac
	if !ctx.cr[0].eq {
	pc = 0x82CF84AC; continue 'dispatch;
	}
	// 82CF8554: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8558: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF855C: 5506103E  rotlwi r6, r8, 2
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 82CF8560: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8564: 7CA75050  subf r5, r7, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 82CF8568: 0CC60000  twi 6, r6, 0
	// 82CF856C: 7D453396  divwu r10, r5, r6
	ctx.r[10].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CF8570: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF8574: 40980008  bge cr6, 0x82cf857c
	if !ctx.cr[6].lt {
	pc = 0x82CF857C; continue 'dispatch;
	}
	// 82CF8578: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82CF857C; continue 'dispatch;
            }
            0x82CF857C => {
    //   block [0x82CF857C..0x82CF859C)
	// 82CF857C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8580: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8584: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF8588: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF858C: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF8590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF8594: 41980008  blt cr6, 0x82cf859c
	if ctx.cr[6].lt {
	pc = 0x82CF859C; continue 'dispatch;
	}
	// 82CF8598: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF859C; continue 'dispatch;
            }
            0x82CF859C => {
    //   block [0x82CF859C..0x82CF85A8)
	// 82CF859C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF85A0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF85A4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	pc = 0x82CF85A8; continue 'dispatch;
            }
            0x82CF85A8 => {
    //   block [0x82CF85A8..0x82CF85BC)
	// 82CF85A8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF85AC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF85B0: 4082FFF8  bne 0x82cf85a8
	if !ctx.cr[0].eq {
	pc = 0x82CF85A8; continue 'dispatch;
	}
	// 82CF85B4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF85B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF85C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF85C0 size=556
    let mut pc: u32 = 0x82CF85C0;
    'dispatch: loop {
        match pc {
            0x82CF85C0 => {
    //   block [0x82CF85C0..0x82CF8618)
	// 82CF85C0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF85C4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF85C8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF85CC: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF85D0: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82CF85D4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF85D8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF85DC: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF85E0: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF85E4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF85E8: 7D2741D6  mullw r9, r7, r8
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF85EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF85F0: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF85F4: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF85F8: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CF85FC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF8600: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF8604: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF8608: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF860C: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF8610: 41980008  blt cr6, 0x82cf8618
	if ctx.cr[6].lt {
	pc = 0x82CF8618; continue 'dispatch;
	}
	// 82CF8614: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82CF8618; continue 'dispatch;
            }
            0x82CF8618 => {
    //   block [0x82CF8618..0x82CF8664)
	// 82CF8618: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF861C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8620: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8624: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8628: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82CF862C: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8630: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF8634: 7CA74214  add r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF8638: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF863C: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8640: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF8644: 38C8007F  addi r6, r8, 0x7f
	ctx.r[6].s64 = ctx.r[8].s64 + 127;
	// 82CF8648: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CF864C: 54C6C9FE  srwi r6, r6, 7
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8650: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8654: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF8658: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF865C: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8660: 419A0018  beq cr6, 0x82cf8678
	if ctx.cr[6].eq {
	pc = 0x82CF8678; continue 'dispatch;
	}
	pc = 0x82CF8664; continue 'dispatch;
            }
            0x82CF8664 => {
    //   block [0x82CF8664..0x82CF8678)
	// 82CF8664: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF8668: 7C054A2C  dcbt r5, r9
	// 82CF866C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF8670: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF8674: 4198FFF0  blt cr6, 0x82cf8664
	if ctx.cr[6].lt {
	pc = 0x82CF8664; continue 'dispatch;
	}
	pc = 0x82CF8678; continue 'dispatch;
            }
            0x82CF8678 => {
    //   block [0x82CF8678..0x82CF8680)
	// 82CF8678: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF867C: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	pc = 0x82CF8680; continue 'dispatch;
            }
            0x82CF8680 => {
    //   block [0x82CF8680..0x82CF8694)
	// 82CF8680: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF8684: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82CF8688: 4082FFF8  bne 0x82cf8680
	if !ctx.cr[0].eq {
	pc = 0x82CF8680; continue 'dispatch;
	}
	// 82CF868C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF8690: C1A80BFC  lfs f13, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF8694; continue 'dispatch;
            }
            0x82CF8694 => {
    //   block [0x82CF8694..0x82CF87AC)
	// 82CF8694: C1490014  lfs f10, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF8698: ED2C002A  fadds f9, f12, f0
	ctx.f[9].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF869C: C10A0014  lfs f8, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF86A0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF86A4: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF86A8: D14A0014  stfs f10, 0x14(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82CF86AC: ECC902B2  fmuls f6, f9, f10
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF86B0: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF86B4: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF86B8: D08B1400  stfs f4, 0x1400(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF86BC: D0CB1404  stfs f6, 0x1404(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5124 as u32), tmp.u32 ) };
	// 82CF86C0: C0690010  lfs f3, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF86C4: EC4900F2  fmuls f2, f9, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF86C8: C02A0010  lfs f1, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CF86CC: ED43082A  fadds f10, f3, f1
	ctx.f[10].f64 = ((ctx.f[3].f64 + ctx.f[1].f64) as f32) as f64;
	// 82CF86D0: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF86D4: D06A0010  stfs f3, 0x10(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82CF86D8: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF86DC: D0EB1000  stfs f7, 0x1000(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF86E0: D04B1004  stfs f2, 0x1004(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), tmp.u32 ) };
	// 82CF86E4: C0C9000C  lfs f6, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF86E8: ECA901B2  fmuls f5, f9, f6
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF86EC: C08A000C  lfs f4, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF86F0: EC66202A  fadds f3, f6, f4
	ctx.f[3].f64 = ((ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CF86F4: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF86F8: D0CA000C  stfs f6, 0xc(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF86FC: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8700: D02B0C00  stfs f1, 0xc00(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF8704: D0AB0C04  stfs f5, 0xc04(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF8708: C1490008  lfs f10, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF870C: ED0902B2  fmuls f8, f9, f10
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8710: C0EA0008  lfs f7, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF8714: ECCA382A  fadds f6, f10, f7
	ctx.f[6].f64 = ((ctx.f[10].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF8718: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF871C: D14A0008  stfs f10, 8(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF8720: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8724: D08B0800  stfs f4, 0x800(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF8728: D10B0804  stfs f8, 0x804(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF872C: C0690004  lfs f3, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF8730: EC4900F2  fmuls f2, f9, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF8734: C02A0004  lfs f1, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CF8738: ED43082A  fadds f10, f3, f1
	ctx.f[10].f64 = ((ctx.f[3].f64 + ctx.f[1].f64) as f32) as f64;
	// 82CF873C: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8740: D06A0004  stfs f3, 4(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8744: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8748: D0EB0400  stfs f7, 0x400(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF874C: D04B0404  stfs f2, 0x404(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8750: C0C90000  lfs f6, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF8754: ECA901B2  fmuls f5, f9, f6
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF8758: C08A0000  lfs f4, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF875C: EC66202A  fadds f3, f6, f4
	ctx.f[3].f64 = ((ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CF8760: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8764: D0CA0000  stfs f6, 0(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8768: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82CF876C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8770: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8774: D02B0000  stfs f1, 0(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8778: D0AB0004  stfs f5, 4(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF877C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF8780: 4082FF14  bne 0x82cf8694
	if !ctx.cr[0].eq {
	pc = 0x82CF8694; continue 'dispatch;
	}
	// 82CF8784: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8788: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF878C: 5506103E  rotlwi r6, r8, 2
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 82CF8790: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8794: 7CA74850  subf r5, r7, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82CF8798: 0CC60000  twi 6, r6, 0
	// 82CF879C: 7D253396  divwu r9, r5, r6
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CF87A0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF87A4: 40980008  bge cr6, 0x82cf87ac
	if !ctx.cr[6].lt {
	pc = 0x82CF87AC; continue 'dispatch;
	}
	// 82CF87A8: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CF87AC; continue 'dispatch;
            }
            0x82CF87AC => {
    //   block [0x82CF87AC..0x82CF87CC)
	// 82CF87AC: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF87B0: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF87B4: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF87B8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF87BC: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF87C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF87C4: 41980008  blt cr6, 0x82cf87cc
	if ctx.cr[6].lt {
	pc = 0x82CF87CC; continue 'dispatch;
	}
	// 82CF87C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82CF87CC; continue 'dispatch;
            }
            0x82CF87CC => {
    //   block [0x82CF87CC..0x82CF87D8)
	// 82CF87CC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF87D0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF87D4: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	pc = 0x82CF87D8; continue 'dispatch;
            }
            0x82CF87D8 => {
    //   block [0x82CF87D8..0x82CF87EC)
	// 82CF87D8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF87DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF87E0: 4082FFF8  bne 0x82cf87d8
	if !ctx.cr[0].eq {
	pc = 0x82CF87D8; continue 'dispatch;
	}
	// 82CF87E4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF87E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF87F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF87F0 size=528
    let mut pc: u32 = 0x82CF87F0;
    'dispatch: loop {
        match pc {
            0x82CF87F0 => {
    //   block [0x82CF87F0..0x82CF8850)
	// 82CF87F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF87F4: 4BFB0C19  bl 0x82ca940c
	ctx.lr = 0x82CF87F8;
	sub_82CA93D0(ctx, base);
	// 82CF87F8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF87FC: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8800: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8804: 3BC30034  addi r30, r3, 0x34
	ctx.r[30].s64 = ctx.r[3].s64 + 52;
	// 82CF8808: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF880C: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8810: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8814: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8818: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF881C: 7D0429D6  mullw r8, r4, r5
	ctx.r[8].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CF8820: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8824: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8828: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82CF882C: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82CF8830: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8834: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82CF8838: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF883C: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF8840: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF8844: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF8848: 41980008  blt cr6, 0x82cf8850
	if ctx.cr[6].lt {
	pc = 0x82CF8850; continue 'dispatch;
	}
	// 82CF884C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82CF8850; continue 'dispatch;
            }
            0x82CF8850 => {
    //   block [0x82CF8850..0x82CF8894)
	// 82CF8850: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF8854: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8858: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF885C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF8860: F961FFD0  std r11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u64 ) };
	// 82CF8864: C941FFD0  lfd f10, -0x30(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8868: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF886C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF8870: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8874: C1AA0C4C  lfs f13, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8878: C1890C58  lfs f12, 0xc58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF887C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF8880: ED4B4024  fdivs f10, f11, f8
	ctx.f[10].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CF8884: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8888: 419A0038  beq cr6, 0x82cf88c0
	if ctx.cr[6].eq {
	pc = 0x82CF88C0; continue 'dispatch;
	}
	// 82CF888C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CF8890: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	pc = 0x82CF8894; continue 'dispatch;
            }
            0x82CF8894 => {
    //   block [0x82CF8894..0x82CF88C0)
	// 82CF8894: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8898: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF889C: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 82CF88A0: F921FFD0  std r9, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[9].u64 ) };
	// 82CF88A4: C9A1FFD0  lfd f13, -0x30(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF88A8: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 82CF88AC: FD005818  frsp f8, f11
	ctx.f[8].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF88B0: ECE80332  fmuls f7, f8, f12
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF88B4: D0EB0000  stfs f7, 0(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF88B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF88BC: 4082FFD8  bne 0x82cf8894
	if !ctx.cr[0].eq {
	pc = 0x82CF8894; continue 'dispatch;
	}
	pc = 0x82CF88C0; continue 'dispatch;
            }
            0x82CF88C0 => {
    //   block [0x82CF88C0..0x82CF88CC)
	// 82CF88C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF88C4: 549F083C  slwi r31, r4, 1
	ctx.r[31].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82CF88C8: C16B0BFC  lfs f11, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82CF88CC; continue 'dispatch;
            }
            0x82CF88CC => {
    //   block [0x82CF88CC..0x82CF88E8)
	// 82CF88CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF88D0: 419A0068  beq cr6, 0x82cf8938
	if ctx.cr[6].eq {
	pc = 0x82CF8938; continue 'dispatch;
	}
	// 82CF88D4: EDAA002A  fadds f13, f10, f0
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF88D8: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82CF88DC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CF88E0: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CF88E4: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	pc = 0x82CF88E8; continue 'dispatch;
            }
            0x82CF88E8 => {
    //   block [0x82CF88E8..0x82CF8938)
	// 82CF88E8: A3A80000  lhz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF88EC: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF88F0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF88F4: 7FBD0734  extsh r29, r29
	ctx.r[29].s64 = ctx.r[29].s16 as i64;
	// 82CF88F8: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 82CF88FC: FBA1FFD0  std r29, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[29].u64 ) };
	// 82CF8900: C8E1FFD0  lfd f7, -0x30(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8904: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF8908: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF890C: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8910: D08B0000  stfs f4, 0(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8914: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF8918: EC64402A  fadds f3, f4, f8
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF891C: EC4D0132  fmuls f2, f13, f4
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF8920: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8924: ED0102F2  fmuls f8, f1, f11
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF8928: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF892C: D04A0004  stfs f2, 4(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8930: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CF8934: 4082FFB4  bne 0x82cf88e8
	if !ctx.cr[0].eq {
	pc = 0x82CF88E8; continue 'dispatch;
	}
	pc = 0x82CF8938; continue 'dispatch;
            }
            0x82CF8938 => {
    //   block [0x82CF8938..0x82CF8974)
	// 82CF8938: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF893C: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8940: 7CBF2A14  add r5, r31, r5
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[5].u64;
	// 82CF8944: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82CF8948: 4082FF84  bne 0x82cf88cc
	if !ctx.cr[0].eq {
	pc = 0x82CF88CC; continue 'dispatch;
	}
	// 82CF894C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8950: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8954: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF8958: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF895C: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF8960: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF8964: 0CC80000  twi 6, r8, 0
	// 82CF8968: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF896C: 41980008  blt cr6, 0x82cf8974
	if ctx.cr[6].lt {
	pc = 0x82CF8974; continue 'dispatch;
	}
	// 82CF8970: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF8974; continue 'dispatch;
            }
            0x82CF8974 => {
    //   block [0x82CF8974..0x82CF8994)
	// 82CF8974: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8978: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF897C: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF8980: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8984: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8988: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF898C: 40980008  bge cr6, 0x82cf8994
	if !ctx.cr[6].lt {
	pc = 0x82CF8994; continue 'dispatch;
	}
	// 82CF8990: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF8994; continue 'dispatch;
            }
            0x82CF8994 => {
    //   block [0x82CF8994..0x82CF89B8)
	// 82CF8994: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF8998: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF899C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF89A0: 419A005C  beq cr6, 0x82cf89fc
	if ctx.cr[6].eq {
	pc = 0x82CF89FC; continue 'dispatch;
	}
	// 82CF89A4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CF89A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CF89AC: 39007FFF  li r8, 0x7fff
	ctx.r[8].s64 = 32767;
	// 82CF89B0: 3920801E  li r9, -0x7fe2
	ctx.r[9].s64 = -32738;
	// 82CF89B4: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CF89B8; continue 'dispatch;
            }
            0x82CF89B8 => {
    //   block [0x82CF89B8..0x82CF89DC)
	// 82CF89B8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF89BC: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF89C0: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF89C4: D961FFD0  stfd f11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[11].u64 ) };
	// 82CF89C8: 8141FFD4  lwz r10, -0x2c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82CF89CC: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 82CF89D0: 4198000C  blt cr6, 0x82cf89dc
	if ctx.cr[6].lt {
	pc = 0x82CF89DC; continue 'dispatch;
	}
	// 82CF89D4: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CF89D8: 48000018  b 0x82cf89f0
	pc = 0x82CF89F0; continue 'dispatch;
            }
            0x82CF89DC => {
    //   block [0x82CF89DC..0x82CF89EC)
	// 82CF89DC: 2F0A8000  cmpwi cr6, r10, -0x8000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -32768, &mut ctx.xer);
	// 82CF89E0: 4199000C  bgt cr6, 0x82cf89ec
	if ctx.cr[6].gt {
	pc = 0x82CF89EC; continue 'dispatch;
	}
	// 82CF89E4: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82CF89E8: 48000008  b 0x82cf89f0
	pc = 0x82CF89F0; continue 'dispatch;
            }
            0x82CF89EC => {
    //   block [0x82CF89EC..0x82CF89F0)
	// 82CF89EC: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	pc = 0x82CF89F0; continue 'dispatch;
            }
            0x82CF89F0 => {
    //   block [0x82CF89F0..0x82CF89FC)
	// 82CF89F0: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CF89F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF89F8: 4082FFC0  bne 0x82cf89b8
	if !ctx.cr[0].eq {
	pc = 0x82CF89B8; continue 'dispatch;
	}
	pc = 0x82CF89FC; continue 'dispatch;
            }
            0x82CF89FC => {
    //   block [0x82CF89FC..0x82CF8A00)
	// 82CF89FC: 4BFB0A60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8A00 size=428
    let mut pc: u32 = 0x82CF8A00;
    'dispatch: loop {
        match pc {
            0x82CF8A00 => {
    //   block [0x82CF8A00..0x82CF8A50)
	// 82CF8A00: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8A04: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8A08: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8A0C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8A10: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8A14: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8A18: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8A1C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8A20: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF8A24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8A28: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8A2C: 7CA50E70  srawi r5, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CF8A30: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8A34: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CF8A38: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CF8A3C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CF8A40: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF8A44: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF8A48: 41980008  blt cr6, 0x82cf8a50
	if ctx.cr[6].lt {
	pc = 0x82CF8A50; continue 'dispatch;
	}
	// 82CF8A4C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x82CF8A50; continue 'dispatch;
            }
            0x82CF8A50 => {
    //   block [0x82CF8A50..0x82CF8A94)
	// 82CF8A50: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82CF8A54: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8A58: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8A5C: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8A60: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CF8A64: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8A68: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF8A6C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF8A70: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8A74: 38AA007F  addi r5, r10, 0x7f
	ctx.r[5].s64 = ctx.r[10].s64 + 127;
	// 82CF8A78: C1860C4C  lfs f12, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF8A7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF8A80: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF8A84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF8A88: EDAB4024  fdivs f13, f11, f8
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CF8A8C: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8A90: 419A0018  beq cr6, 0x82cf8aa8
	if ctx.cr[6].eq {
	pc = 0x82CF8AA8; continue 'dispatch;
	}
	pc = 0x82CF8A94; continue 'dispatch;
            }
            0x82CF8A94 => {
    //   block [0x82CF8A94..0x82CF8AA8)
	// 82CF8A94: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8A98: 7C065A2C  dcbt r6, r11
	// 82CF8A9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF8AA0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF8AA4: 4198FFF0  blt cr6, 0x82cf8a94
	if ctx.cr[6].lt {
	pc = 0x82CF8A94; continue 'dispatch;
	}
	pc = 0x82CF8AA8; continue 'dispatch;
            }
            0x82CF8AA8 => {
    //   block [0x82CF8AA8..0x82CF8AD8)
	// 82CF8AA8: A1430034  lhz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CF8AAC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CF8AB0: 7D450734  extsh r5, r10
	ctx.r[5].s64 = ctx.r[10].s16 as i64;
	// 82CF8AB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF8AB8: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82CF8ABC: C1470C58  lfs f10, 0xc58(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3160 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF8AC0: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8AC4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CF8AC8: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF8ACC: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8AD0: ECE802B2  fmuls f7, f8, f10
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8AD4: D0E30034  stfs f7, 0x34(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x82CF8AD8; continue 'dispatch;
            }
            0x82CF8AD8 => {
    //   block [0x82CF8AD8..0x82CF8B54)
	// 82CF8AD8: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8ADC: C1230034  lfs f9, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF8AE0: ED0D002A  fadds f8, f13, f0
	ctx.f[8].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8AE4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF8AE8: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF8AEC: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CF8AF0: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82CF8AF4: C8E1FFF0  lfd f7, -0x10(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8AF8: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF8AFC: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF8B00: EC8502B2  fmuls f4, f5, f10
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8B04: D0830034  stfs f4, 0x34(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CF8B08: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CF8B0C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF8B10: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8B14: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8B18: ED2102F2  fmuls f9, f1, f11
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF8B1C: D1280000  stfs f9, 0(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8B20: D0480004  stfs f2, 4(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8B24: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82CF8B28: 4082FFB0  bne 0x82cf8ad8
	if !ctx.cr[0].eq {
	pc = 0x82CF8AD8; continue 'dispatch;
	}
	// 82CF8B2C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8B30: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8B34: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF8B38: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8B3C: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF8B40: 0CC70000  twi 6, r7, 0
	// 82CF8B44: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF8B48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF8B4C: 40980008  bge cr6, 0x82cf8b54
	if !ctx.cr[6].lt {
	pc = 0x82CF8B54; continue 'dispatch;
	}
	// 82CF8B50: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF8B54; continue 'dispatch;
            }
            0x82CF8B54 => {
    //   block [0x82CF8B54..0x82CF8B74)
	// 82CF8B54: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8B58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF8B5C: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF8B60: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8B64: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8B68: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF8B6C: 40980008  bge cr6, 0x82cf8b74
	if !ctx.cr[6].lt {
	pc = 0x82CF8B74; continue 'dispatch;
	}
	// 82CF8B70: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF8B74; continue 'dispatch;
            }
            0x82CF8B74 => {
    //   block [0x82CF8B74..0x82CF8BAC)
	// 82CF8B74: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CF8B78: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF8B7C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF8B80: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8B84: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8B88: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8B8C: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF8B90: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 82CF8B94: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82CF8B98: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CF8B9C: 41980010  blt cr6, 0x82cf8bac
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82CF8BAC);
		return;
	}
	// 82CF8BA0: 39607FFF  li r11, 0x7fff
	ctx.r[11].s64 = 32767;
	// 82CF8BA4: B1630034  sth r11, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u16 ) };
	// 82CF8BA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8BC0 size=568
    let mut pc: u32 = 0x82CF8BC0;
    'dispatch: loop {
        match pc {
            0x82CF8BC0 => {
    //   block [0x82CF8BC0..0x82CF8C18)
	// 82CF8BC0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF8BC4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8BC8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8BCC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8BD0: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF8BD4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8BD8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8BDC: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8BE0: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8BE4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8BE8: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF8BEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8BF0: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8BF4: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF8BF8: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8BFC: 7D09F850  subf r8, r9, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 82CF8C00: 7D240194  addze r9, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[9].s64 = tmp.s64;
	// 82CF8C04: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF8C08: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF8C0C: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82CF8C10: 41980008  blt cr6, 0x82cf8c18
	if ctx.cr[6].lt {
	pc = 0x82CF8C18; continue 'dispatch;
	}
	// 82CF8C14: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CF8C18; continue 'dispatch;
            }
            0x82CF8C18 => {
    //   block [0x82CF8C18..0x82CF8C5C)
	// 82CF8C18: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82CF8C1C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8C20: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8C24: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF8C28: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF8C2C: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF8C30: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF8C34: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF8C38: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF8C3C: 3889007F  addi r4, r9, 0x7f
	ctx.r[4].s64 = ctx.r[9].s64 + 127;
	// 82CF8C40: C1A60C4C  lfs f13, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8C44: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF8C48: 5487C9FE  srwi r7, r4, 7
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF8C4C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF8C50: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF8C54: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8C58: 419A0018  beq cr6, 0x82cf8c70
	if ctx.cr[6].eq {
	pc = 0x82CF8C70; continue 'dispatch;
	}
	pc = 0x82CF8C5C; continue 'dispatch;
            }
            0x82CF8C5C => {
    //   block [0x82CF8C5C..0x82CF8C70)
	// 82CF8C5C: 55263830  slwi r6, r9, 7
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8C60: 7C065A2C  dcbt r6, r11
	// 82CF8C64: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF8C68: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF8C6C: 4198FFF0  blt cr6, 0x82cf8c5c
	if ctx.cr[6].lt {
	pc = 0x82CF8C5C; continue 'dispatch;
	}
	pc = 0x82CF8C70; continue 'dispatch;
            }
            0x82CF8C70 => {
    //   block [0x82CF8C70..0x82CF8C80)
	// 82CF8C70: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF8C74: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82CF8C78: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82CF8C7C: C1A60C58  lfs f13, 0xc58(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF8C80; continue 'dispatch;
            }
            0x82CF8C80 => {
    //   block [0x82CF8C80..0x82CF8CB4)
	// 82CF8C80: A0C90000  lhz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8C84: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF8C88: 7CC60734  extsh r6, r6
	ctx.r[6].s64 = ctx.r[6].s16 as i64;
	// 82CF8C8C: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82CF8C90: C981FFE0  lfd f12, -0x20(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF8C94: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CF8C98: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8C9C: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8CA0: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8CA4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF8CA8: 4082FFD8  bne 0x82cf8c80
	if !ctx.cr[0].eq {
	pc = 0x82CF8C80; continue 'dispatch;
	}
	// 82CF8CAC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF8CB0: C1890BFC  lfs f12, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF8CB4; continue 'dispatch;
            }
            0x82CF8CB4 => {
    //   block [0x82CF8CB4..0x82CF8D6C)
	// 82CF8CB4: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF8CB8: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF8CBC: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8CC0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF8CC4: 7D260734  extsh r6, r9
	ctx.r[6].s64 = ctx.r[9].s16 as i64;
	// 82CF8CC8: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82CF8CCC: C8E1FFE0  lfd f7, -0x20(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF8CD0: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF8CD4: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF8CD8: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8CDC: D0850004  stfs f4, 4(r5)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8CE0: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CF8CE4: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF8CE8: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8CEC: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8CF0: D12A0400  stfs f9, 0x400(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF8CF4: D04A0404  stfs f2, 0x404(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8CF8: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8CFC: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF8D00: F8E1FFE8  std r7, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[7].u64 ) };
	// 82CF8D04: C8C1FFE8  lfd f6, -0x18(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF8D08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF8D0C: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF8D10: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF8D14: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF8D18: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8D1C: D0650000  stfs f3, 0(r5)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8D20: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF8D24: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8D28: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF8D2C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8D30: ED090332  fmuls f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8D34: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8D38: D02A0004  stfs f1, 4(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8D3C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CF8D40: 4082FF74  bne 0x82cf8cb4
	if !ctx.cr[0].eq {
	pc = 0x82CF8CB4; continue 'dispatch;
	}
	// 82CF8D44: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8D48: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8D4C: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82CF8D50: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8D54: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF8D58: 0CC70000  twi 6, r7, 0
	// 82CF8D5C: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF8D60: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF8D64: 40980008  bge cr6, 0x82cf8d6c
	if !ctx.cr[6].lt {
	pc = 0x82CF8D6C; continue 'dispatch;
	}
	// 82CF8D68: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82CF8D6C; continue 'dispatch;
            }
            0x82CF8D6C => {
    //   block [0x82CF8D6C..0x82CF8D8C)
	// 82CF8D6C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8D70: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8D74: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF8D78: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF8D7C: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8D80: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF8D84: 40980008  bge cr6, 0x82cf8d8c
	if !ctx.cr[6].lt {
	pc = 0x82CF8D8C; continue 'dispatch;
	}
	// 82CF8D88: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF8D8C; continue 'dispatch;
            }
            0x82CF8D8C => {
    //   block [0x82CF8D8C..0x82CF8DAC)
	// 82CF8D8C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CF8D90: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF8D94: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF8D98: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CF8D9C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82CF8DA0: 38E07FFF  li r7, 0x7fff
	ctx.r[7].s64 = 32767;
	// 82CF8DA4: 3900801E  li r8, -0x7fe2
	ctx.r[8].s64 = -32738;
	// 82CF8DA8: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CF8DAC; continue 'dispatch;
            }
            0x82CF8DAC => {
    //   block [0x82CF8DAC..0x82CF8DD0)
	// 82CF8DAC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8DB0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8DB4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF8DB8: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF8DBC: 8141FFEC  lwz r10, -0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF8DC0: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 82CF8DC4: 4198000C  blt cr6, 0x82cf8dd0
	if ctx.cr[6].lt {
	pc = 0x82CF8DD0; continue 'dispatch;
	}
	// 82CF8DC8: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CF8DCC: 48000018  b 0x82cf8de4
	pc = 0x82CF8DE4; continue 'dispatch;
            }
            0x82CF8DD0 => {
    //   block [0x82CF8DD0..0x82CF8DE0)
	// 82CF8DD0: 2F0A8000  cmpwi cr6, r10, -0x8000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -32768, &mut ctx.xer);
	// 82CF8DD4: 4199000C  bgt cr6, 0x82cf8de0
	if ctx.cr[6].gt {
	pc = 0x82CF8DE0; continue 'dispatch;
	}
	// 82CF8DD8: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CF8DDC: 48000008  b 0x82cf8de4
	pc = 0x82CF8DE4; continue 'dispatch;
            }
            0x82CF8DE0 => {
    //   block [0x82CF8DE0..0x82CF8DE4)
	// 82CF8DE0: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	pc = 0x82CF8DE4; continue 'dispatch;
            }
            0x82CF8DE4 => {
    //   block [0x82CF8DE4..0x82CF8DF8)
	// 82CF8DE4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF8DE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF8DEC: 4082FFC0  bne 0x82cf8dac
	if !ctx.cr[0].eq {
	pc = 0x82CF8DAC; continue 'dispatch;
	}
	// 82CF8DF0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF8DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8DF8 size=684
    let mut pc: u32 = 0x82CF8DF8;
    'dispatch: loop {
        match pc {
            0x82CF8DF8 => {
    //   block [0x82CF8DF8..0x82CF8E50)
	// 82CF8DF8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF8DFC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8E00: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8E04: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8E08: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 82CF8E0C: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8E10: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF8E14: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8E18: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8E1C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8E20: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF8E24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8E28: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8E2C: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF8E30: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CF8E34: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8E38: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF8E3C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF8E40: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF8E44: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF8E48: 41980008  blt cr6, 0x82cf8e50
	if ctx.cr[6].lt {
	pc = 0x82CF8E50; continue 'dispatch;
	}
	// 82CF8E4C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82CF8E50; continue 'dispatch;
            }
            0x82CF8E50 => {
    //   block [0x82CF8E50..0x82CF8E94)
	// 82CF8E50: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF8E54: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8E58: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8E5C: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8E60: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CF8E64: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8E68: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF8E6C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CF8E70: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF8E74: 3888007F  addi r4, r8, 0x7f
	ctx.r[4].s64 = ctx.r[8].s64 + 127;
	// 82CF8E78: C1A50C4C  lfs f13, 0xc4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8E7C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CF8E80: 5486C9FE  srwi r6, r4, 7
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8E84: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF8E88: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF8E8C: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8E90: 419A0018  beq cr6, 0x82cf8ea8
	if ctx.cr[6].eq {
	pc = 0x82CF8EA8; continue 'dispatch;
	}
	pc = 0x82CF8E94; continue 'dispatch;
            }
            0x82CF8E94 => {
    //   block [0x82CF8E94..0x82CF8EA8)
	// 82CF8E94: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF8E98: 7C05522C  dcbt r5, r10
	// 82CF8E9C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF8EA0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF8EA4: 4198FFF0  blt cr6, 0x82cf8e94
	if ctx.cr[6].lt {
	pc = 0x82CF8E94; continue 'dispatch;
	}
	pc = 0x82CF8EA8; continue 'dispatch;
            }
            0x82CF8EA8 => {
    //   block [0x82CF8EA8..0x82CF8EB8)
	// 82CF8EA8: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CF8EAC: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF8EB0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF8EB4: C1A50C58  lfs f13, 0xc58(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF8EB8; continue 'dispatch;
            }
            0x82CF8EB8 => {
    //   block [0x82CF8EB8..0x82CF8EEC)
	// 82CF8EB8: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8EBC: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF8EC0: 7CA50734  extsh r5, r5
	ctx.r[5].s64 = ctx.r[5].s16 as i64;
	// 82CF8EC4: F8A1FFD0  std r5, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u64 ) };
	// 82CF8EC8: C981FFD0  lfd f12, -0x30(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8ECC: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CF8ED0: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8ED4: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8ED8: D0E80000  stfs f7, 0(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8EDC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF8EE0: 4082FFD8  bne 0x82cf8eb8
	if !ctx.cr[0].eq {
	pc = 0x82CF8EB8; continue 'dispatch;
	}
	// 82CF8EE4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF8EE8: C1880BFC  lfs f12, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF8EEC; continue 'dispatch;
            }
            0x82CF8EEC => {
    //   block [0x82CF8EEC..0x82CF901C)
	// 82CF8EEC: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF8EF0: C129000C  lfs f9, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF8EF4: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8EF8: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF8EFC: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 82CF8F00: F8A1FFD0  std r5, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u64 ) };
	// 82CF8F04: C8E1FFD0  lfd f7, -0x30(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8F08: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF8F0C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF8F10: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8F14: D089000C  stfs f4, 0xc(r9)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF8F18: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CF8F1C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF8F20: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8F24: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8F28: D12B0C00  stfs f9, 0xc00(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF8F2C: D04B0C04  stfs f2, 0xc04(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF8F30: A08A0004  lhz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8F34: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 82CF8F38: F8C1FFD8  std r6, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[6].u64 ) };
	// 82CF8F3C: C8C1FFD8  lfd f6, -0x28(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF8F40: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF8F44: C0E90008  lfs f7, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF8F48: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF8F4C: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8F50: D0690008  stfs f3, 8(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF8F54: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF8F58: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8F5C: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF8F60: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8F64: D0EB0800  stfs f7, 0x800(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF8F68: D02B0804  stfs f1, 0x804(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF8F6C: A0AA0002  lhz r5, 2(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF8F70: 7CA80734  extsh r8, r5
	ctx.r[8].s64 = ctx.r[5].s16 as i64;
	// 82CF8F74: F901FFE0  std r8, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u64 ) };
	// 82CF8F78: C8A1FFE0  lfd f5, -0x20(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF8F7C: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF8F80: C0C90004  lfs f6, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF8F84: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF8F88: EC430372  fmuls f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8F8C: D0490004  stfs f2, 4(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8F90: EC22302A  fadds f1, f2, f6
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF8F94: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8F98: ED2800B2  fmuls f9, f8, f2
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF8F9C: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8FA0: D0CB0400  stfs f6, 0x400(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF8FA4: D12B0404  stfs f9, 0x404(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8FA8: A0CA0000  lhz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8FAC: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CF8FB0: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CF8FB4: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF8FB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CF8FBC: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF8FC0: C0A90000  lfs f5, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CF8FC4: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF8FC8: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8FCC: D0290000  stfs f1, 0(r9)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8FD0: ED21282A  fadds f9, f1, f5
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 82CF8FD4: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8FD8: ED080072  fmuls f8, f8, f1
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CF8FDC: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8FE0: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8FE4: D0CB0000  stfs f6, 0(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8FE8: D10B0004  stfs f8, 4(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8FEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF8FF0: 4082FEFC  bne 0x82cf8eec
	if !ctx.cr[0].eq {
	pc = 0x82CF8EEC; continue 'dispatch;
	}
	// 82CF8FF4: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8FF8: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8FFC: 5506083E  rotlwi r6, r8, 1
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82CF9000: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9004: 7CA75050  subf r5, r7, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 82CF9008: 0CC60000  twi 6, r6, 0
	// 82CF900C: 7D453396  divwu r10, r5, r6
	ctx.r[10].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CF9010: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF9014: 40980008  bge cr6, 0x82cf901c
	if !ctx.cr[6].lt {
	pc = 0x82CF901C; continue 'dispatch;
	}
	// 82CF9018: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82CF901C; continue 'dispatch;
            }
            0x82CF901C => {
    //   block [0x82CF901C..0x82CF903C)
	// 82CF901C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9020: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9024: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF9028: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF902C: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF9030: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF9034: 41980008  blt cr6, 0x82cf903c
	if ctx.cr[6].lt {
	pc = 0x82CF903C; continue 'dispatch;
	}
	// 82CF9038: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF903C; continue 'dispatch;
            }
            0x82CF903C => {
    //   block [0x82CF903C..0x82CF9058)
	// 82CF903C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9040: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CF9044: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9048: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF904C: 38E07FFF  li r7, 0x7fff
	ctx.r[7].s64 = 32767;
	// 82CF9050: 3900801E  li r8, -0x7fe2
	ctx.r[8].s64 = -32738;
	// 82CF9054: C00B0F28  lfs f0, 0xf28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CF9058; continue 'dispatch;
            }
            0x82CF9058 => {
    //   block [0x82CF9058..0x82CF907C)
	// 82CF9058: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF905C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9060: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF9064: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF9068: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF906C: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CF9070: 4198000C  blt cr6, 0x82cf907c
	if ctx.cr[6].lt {
	pc = 0x82CF907C; continue 'dispatch;
	}
	// 82CF9074: B0E90000  sth r7, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CF9078: 48000018  b 0x82cf9090
	pc = 0x82CF9090; continue 'dispatch;
            }
            0x82CF907C => {
    //   block [0x82CF907C..0x82CF908C)
	// 82CF907C: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CF9080: 4199000C  bgt cr6, 0x82cf908c
	if ctx.cr[6].gt {
	pc = 0x82CF908C; continue 'dispatch;
	}
	// 82CF9084: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CF9088: 48000008  b 0x82cf9090
	pc = 0x82CF9090; continue 'dispatch;
            }
            0x82CF908C => {
    //   block [0x82CF908C..0x82CF9090)
	// 82CF908C: B1690000  sth r11, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x82CF9090; continue 'dispatch;
            }
            0x82CF9090 => {
    //   block [0x82CF9090..0x82CF90A4)
	// 82CF9090: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF9094: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF9098: 4082FFC0  bne 0x82cf9058
	if !ctx.cr[0].eq {
	pc = 0x82CF9058; continue 'dispatch;
	}
	// 82CF909C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF90A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF90A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF90A8 size=812
    let mut pc: u32 = 0x82CF90A8;
    'dispatch: loop {
        match pc {
            0x82CF90A8 => {
    //   block [0x82CF90A8..0x82CF9100)
	// 82CF90A8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF90AC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF90B0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF90B4: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF90B8: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82CF90BC: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF90C0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF90C4: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF90C8: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF90CC: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF90D0: 7D2741D6  mullw r9, r7, r8
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF90D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF90D8: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF90DC: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF90E0: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CF90E4: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF90E8: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF90EC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF90F0: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF90F4: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF90F8: 41980008  blt cr6, 0x82cf9100
	if ctx.cr[6].lt {
	pc = 0x82CF9100; continue 'dispatch;
	}
	// 82CF90FC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82CF9100; continue 'dispatch;
            }
            0x82CF9100 => {
    //   block [0x82CF9100..0x82CF914C)
	// 82CF9100: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF9104: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9108: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF910C: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9110: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CF9114: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9118: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF911C: 7CA74214  add r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF9120: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9124: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9128: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF912C: 38C8007F  addi r6, r8, 0x7f
	ctx.r[6].s64 = ctx.r[8].s64 + 127;
	// 82CF9130: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CF9134: 54C6C9FE  srwi r6, r6, 7
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9138: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF913C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF9140: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF9144: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9148: 419A0018  beq cr6, 0x82cf9160
	if ctx.cr[6].eq {
	pc = 0x82CF9160; continue 'dispatch;
	}
	pc = 0x82CF914C; continue 'dispatch;
            }
            0x82CF914C => {
    //   block [0x82CF914C..0x82CF9160)
	// 82CF914C: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF9150: 7C054A2C  dcbt r5, r9
	// 82CF9154: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF9158: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF915C: 4198FFF0  blt cr6, 0x82cf914c
	if ctx.cr[6].lt {
	pc = 0x82CF914C; continue 'dispatch;
	}
	pc = 0x82CF9160; continue 'dispatch;
            }
            0x82CF9160 => {
    //   block [0x82CF9160..0x82CF9170)
	// 82CF9160: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CF9164: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF9168: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82CF916C: C1A50C58  lfs f13, 0xc58(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF9170; continue 'dispatch;
            }
            0x82CF9170 => {
    //   block [0x82CF9170..0x82CF91A4)
	// 82CF9170: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9174: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF9178: 7CA50734  extsh r5, r5
	ctx.r[5].s64 = ctx.r[5].s16 as i64;
	// 82CF917C: F8A1FFC0  std r5, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[5].u64 ) };
	// 82CF9180: C981FFC0  lfd f12, -0x40(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9184: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CF9188: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF918C: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9190: D0E80000  stfs f7, 0(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9194: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF9198: 4082FFD8  bne 0x82cf9170
	if !ctx.cr[0].eq {
	pc = 0x82CF9170; continue 'dispatch;
	}
	// 82CF919C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF91A0: C1880BFC  lfs f12, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CF91A4; continue 'dispatch;
            }
            0x82CF91A4 => {
    //   block [0x82CF91A4..0x82CF934C)
	// 82CF91A4: A109000A  lhz r8, 0xa(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(10 as u32) ) } as u64;
	// 82CF91A8: C12A0014  lfs f9, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF91AC: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF91B0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF91B4: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 82CF91B8: F8A1FFC0  std r5, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[5].u64 ) };
	// 82CF91BC: C8E1FFC0  lfd f7, -0x40(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF91C0: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF91C4: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF91C8: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF91CC: D08A0014  stfs f4, 0x14(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82CF91D0: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CF91D4: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF91D8: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF91DC: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF91E0: D12B1400  stfs f9, 0x1400(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF91E4: D04B1404  stfs f2, 0x1404(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5124 as u32), tmp.u32 ) };
	// 82CF91E8: A0890008  lhz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF91EC: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 82CF91F0: F8C1FFC8  std r6, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[6].u64 ) };
	// 82CF91F4: C8C1FFC8  lfd f6, -0x38(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CF91F8: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF91FC: C0EA0010  lfs f7, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF9200: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF9204: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9208: D06A0010  stfs f3, 0x10(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82CF920C: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF9210: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9214: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF9218: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF921C: D0EB1000  stfs f7, 0x1000(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF9220: D02B1004  stfs f1, 0x1004(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), tmp.u32 ) };
	// 82CF9224: A0A90006  lhz r5, 6(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF9228: 7CA80734  extsh r8, r5
	ctx.r[8].s64 = ctx.r[5].s16 as i64;
	// 82CF922C: F901FFD0  std r8, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u64 ) };
	// 82CF9230: C8A1FFD0  lfd f5, -0x30(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9234: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF9238: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF923C: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF9240: EC430372  fmuls f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9244: D04A000C  stfs f2, 0xc(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF9248: EC22302A  fadds f1, f2, f6
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF924C: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9250: ED2800B2  fmuls f9, f8, f2
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9254: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9258: D0CB0C00  stfs f6, 0xc00(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF925C: D12B0C04  stfs f9, 0xc04(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF9260: A0C90004  lhz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9264: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CF9268: F881FFD8  std r4, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[4].u64 ) };
	// 82CF926C: C881FFD8  lfd f4, -0x28(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF9270: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF9274: C0AA0008  lfs f5, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CF9278: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF927C: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9280: D02A0008  stfs f1, 8(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF9284: ED21282A  fadds f9, f1, f5
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 82CF9288: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF928C: ECE80072  fmuls f7, f8, f1
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CF9290: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9294: D0AB0800  stfs f5, 0x800(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF9298: D0EB0804  stfs f7, 0x804(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF929C: A1090002  lhz r8, 2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF92A0: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 82CF92A4: F8A1FFE0  std r5, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[5].u64 ) };
	// 82CF92A8: C861FFE0  lfd f3, -0x20(r1)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF92AC: FC401E9C  fcfid f2, f3
	ctx.f[2].f64 = (ctx.f[3].s64 as f64);
	// 82CF92B0: C08A0004  lfs f4, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF92B4: FC201018  frsp f1, f2
	ctx.f[1].f64 = (ctx.f[2].f64 as f32) as f64;
	// 82CF92B8: ED210372  fmuls f9, f1, f13
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF92BC: D12A0004  stfs f9, 4(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF92C0: ECE9202A  fadds f7, f9, f4
	ctx.f[7].f64 = ((ctx.f[9].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CF92C4: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF92C8: ECC80272  fmuls f6, f8, f9
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 82CF92CC: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF92D0: D08B0400  stfs f4, 0x400(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF92D4: D0CB0404  stfs f6, 0x404(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF92D8: A0890000  lhz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF92DC: C06A0000  lfs f3, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF92E0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82CF92E4: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 82CF92E8: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF92EC: C841FFE8  lfd f2, -0x18(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF92F0: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF92F4: FD200818  frsp f9, f1
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF92F8: ECE90372  fmuls f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF92FC: D0EA0000  stfs f7, 0(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9300: ECC7182A  fadds f6, f7, f3
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[3].f64) as f32) as f64;
	// 82CF9304: ECA801F2  fmuls f5, f8, f7
	ctx.f[5].f64 = (((ctx.f[8].f64 * ctx.f[7].f64) as f32) as f64);
	// 82CF9308: EC860032  fmuls f4, f6, f0
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF930C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9310: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9314: D06B0000  stfs f3, 0(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9318: D0AB0004  stfs f5, 4(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF931C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF9320: 4082FE84  bne 0x82cf91a4
	if !ctx.cr[0].eq {
	pc = 0x82CF91A4; continue 'dispatch;
	}
	// 82CF9324: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9328: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF932C: 5506083E  rotlwi r6, r8, 1
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82CF9330: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9334: 7CA74850  subf r5, r7, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82CF9338: 0CC60000  twi 6, r6, 0
	// 82CF933C: 7D253396  divwu r9, r5, r6
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CF9340: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF9344: 40980008  bge cr6, 0x82cf934c
	if !ctx.cr[6].lt {
	pc = 0x82CF934C; continue 'dispatch;
	}
	// 82CF9348: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CF934C; continue 'dispatch;
            }
            0x82CF934C => {
    //   block [0x82CF934C..0x82CF936C)
	// 82CF934C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9350: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9354: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF9358: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF935C: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF9360: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF9364: 41980008  blt cr6, 0x82cf936c
	if ctx.cr[6].lt {
	pc = 0x82CF936C; continue 'dispatch;
	}
	// 82CF9368: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82CF936C; continue 'dispatch;
            }
            0x82CF936C => {
    //   block [0x82CF936C..0x82CF9388)
	// 82CF936C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9370: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CF9374: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9378: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CF937C: 38E07FFF  li r7, 0x7fff
	ctx.r[7].s64 = 32767;
	// 82CF9380: 3900801E  li r8, -0x7fe2
	ctx.r[8].s64 = -32738;
	// 82CF9384: C00B0F28  lfs f0, 0xf28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CF9388; continue 'dispatch;
            }
            0x82CF9388 => {
    //   block [0x82CF9388..0x82CF93AC)
	// 82CF9388: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF938C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9390: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF9394: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF9398: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF939C: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CF93A0: 4198000C  blt cr6, 0x82cf93ac
	if ctx.cr[6].lt {
	pc = 0x82CF93AC; continue 'dispatch;
	}
	// 82CF93A4: B0EA0000  sth r7, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CF93A8: 48000018  b 0x82cf93c0
	pc = 0x82CF93C0; continue 'dispatch;
            }
            0x82CF93AC => {
    //   block [0x82CF93AC..0x82CF93BC)
	// 82CF93AC: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CF93B0: 4199000C  bgt cr6, 0x82cf93bc
	if ctx.cr[6].gt {
	pc = 0x82CF93BC; continue 'dispatch;
	}
	// 82CF93B4: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CF93B8: 48000008  b 0x82cf93c0
	pc = 0x82CF93C0; continue 'dispatch;
            }
            0x82CF93BC => {
    //   block [0x82CF93BC..0x82CF93C0)
	// 82CF93BC: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x82CF93C0; continue 'dispatch;
            }
            0x82CF93C0 => {
    //   block [0x82CF93C0..0x82CF93D4)
	// 82CF93C0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF93C4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF93C8: 4082FFC0  bne 0x82cf9388
	if !ctx.cr[0].eq {
	pc = 0x82CF9388; continue 'dispatch;
	}
	// 82CF93CC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF93D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF93D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF93D8 size=532
    let mut pc: u32 = 0x82CF93D8;
    'dispatch: loop {
        match pc {
            0x82CF93D8 => {
    //   block [0x82CF93D8..0x82CF9434)
	// 82CF93D8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82CF93DC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF93E0: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF93E4: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF93E8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF93EC: 38830034  addi r4, r3, 0x34
	ctx.r[4].s64 = ctx.r[3].s64 + 52;
	// 82CF93F0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF93F4: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF93F8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF93FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9400: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9404: 7D3E0E70  srawi r30, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82CF9408: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF940C: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82CF9410: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9414: 7CE8F9D6  mullw r7, r8, r31
	ctx.r[7].s32 = ((ctx.r[8].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82CF9418: 7D7E0194  addze r11, r30
	tmp.s64 = ctx.r[30].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[30].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82CF941C: 7CC53214  add r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF9420: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF9424: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF9428: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82CF942C: 41980008  blt cr6, 0x82cf9434
	if ctx.cr[6].lt {
	pc = 0x82CF9434; continue 'dispatch;
	}
	// 82CF9430: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x82CF9434; continue 'dispatch;
            }
            0x82CF9434 => {
    //   block [0x82CF9434..0x82CF9480)
	// 82CF9434: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF9438: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF943C: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9440: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF9444: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82CF9448: C921FFE0  lfd f9, -0x20(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF944C: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82CF9450: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CF9454: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9458: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF945C: C1AA0C4C  lfs f13, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9460: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF9464: C16967A0  lfs f11, 0x67a0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26528 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF9468: C18B67A4  lfs f12, 0x67a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26532 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF946C: ED2A3824  fdivs f9, f10, f7
	ctx.f[9].f64 = ((ctx.f[10].f64 / ctx.f[7].f64) as f32) as f64;
	// 82CF9470: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9474: 419A0038  beq cr6, 0x82cf94ac
	if ctx.cr[6].eq {
	pc = 0x82CF94AC; continue 'dispatch;
	}
	// 82CF9478: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CF947C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x82CF9480; continue 'dispatch;
            }
            0x82CF9480 => {
    //   block [0x82CF9480..0x82CF94AC)
	// 82CF9480: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9484: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF9488: F921FFE0  std r9, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[9].u64 ) };
	// 82CF948C: C9A1FFE0  lfd f13, -0x20(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF9490: FD406E9C  fcfid f10, f13
	ctx.f[10].f64 = (ctx.f[13].s64 as f64);
	// 82CF9494: FCE05018  frsp f7, f10
	ctx.f[7].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9498: ECC76028  fsubs f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CF949C: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF94A0: D0AB0000  stfs f5, 0(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF94A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF94A8: 4082FFD8  bne 0x82cf9480
	if !ctx.cr[0].eq {
	pc = 0x82CF9480; continue 'dispatch;
	}
	pc = 0x82CF94AC; continue 'dispatch;
            }
            0x82CF94AC => {
    //   block [0x82CF94AC..0x82CF94B8)
	// 82CF94AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF94B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CF94B4: C14B0BFC  lfs f10, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	pc = 0x82CF94B8; continue 'dispatch;
            }
            0x82CF94B8 => {
    //   block [0x82CF94B8..0x82CF94D0)
	// 82CF94B8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82CF94BC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF94C0: 419A0060  beq cr6, 0x82cf9520
	if ctx.cr[6].eq {
	pc = 0x82CF9520; continue 'dispatch;
	}
	// 82CF94C4: EDA9002A  fadds f13, f9, f0
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF94C8: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 82CF94CC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82CF94D0; continue 'dispatch;
            }
            0x82CF94D0 => {
    //   block [0x82CF94D0..0x82CF9520)
	// 82CF94D0: 7FC938AE  lbzx r30, r9, r7
	ctx.r[30].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82CF94D4: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF94D8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF94DC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF94E0: FBC1FFE0  std r30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[30].u64 ) };
	// 82CF94E4: C8C1FFE0  lfd f6, -0x20(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF94E8: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF94EC: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF94F0: EC646028  fsubs f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CF94F4: EC4302F2  fmuls f2, f3, f11
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF94F8: D04B0000  stfs f2, 0(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF94FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF9500: EC22382A  fadds f1, f2, f7
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF9504: ECED00B2  fmuls f7, f13, f2
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9508: ECC10032  fmuls f6, f1, f0
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF950C: ECA602B2  fmuls f5, f6, f10
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF9510: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9514: D0EA0004  stfs f7, 4(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9518: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CF951C: 4198FFB4  blt cr6, 0x82cf94d0
	if ctx.cr[6].lt {
	pc = 0x82CF94D0; continue 'dispatch;
	}
	pc = 0x82CF9520; continue 'dispatch;
            }
            0x82CF9520 => {
    //   block [0x82CF9520..0x82CF9558)
	// 82CF9520: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82CF9524: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9528: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF952C: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 82CF9530: 4082FF88  bne 0x82cf94b8
	if !ctx.cr[0].eq {
	pc = 0x82CF94B8; continue 'dispatch;
	}
	// 82CF9534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9538: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF953C: 7D2B3850  subf r9, r11, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF9540: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9544: 0CCA0000  twi 6, r10, 0
	// 82CF9548: 7D495396  divwu r10, r9, r10
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 82CF954C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9550: 41980008  blt cr6, 0x82cf9558
	if ctx.cr[6].lt {
	pc = 0x82CF9558; continue 'dispatch;
	}
	// 82CF9554: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF9558; continue 'dispatch;
            }
            0x82CF9558 => {
    //   block [0x82CF9558..0x82CF9578)
	// 82CF9558: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF955C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF9560: 7D4B3050  subf r10, r11, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 82CF9564: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9568: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF956C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9570: 40980008  bge cr6, 0x82cf9578
	if !ctx.cr[6].lt {
	pc = 0x82CF9578; continue 'dispatch;
	}
	// 82CF9574: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF9578; continue 'dispatch;
            }
            0x82CF9578 => {
    //   block [0x82CF9578..0x82CF9598)
	// 82CF9578: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF957C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9580: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF9584: 419A005C  beq cr6, 0x82cf95e0
	if ctx.cr[6].eq {
	pc = 0x82CF95E0; continue 'dispatch;
	}
	// 82CF9588: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF958C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CF9590: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 82CF9594: C00A67A8  lfs f0, 0x67a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CF9598; continue 'dispatch;
            }
            0x82CF9598 => {
    //   block [0x82CF9598..0x82CF95C0)
	// 82CF9598: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF959C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF95A0: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF95A4: D961FFE0  stfd f11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[11].u64 ) };
	// 82CF95A8: 8141FFE4  lwz r10, -0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) } as u64;
	// 82CF95AC: 214A0080  subfic r10, r10, 0x80
	ctx.xer.ca = ctx.r[10].u32 <= 128 as u32;
	ctx.r[10].s64 = (128 as i64) - ctx.r[10].s64;
	// 82CF95B0: 2F0A00FF  cmpwi cr6, r10, 0xff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 255, &mut ctx.xer);
	// 82CF95B4: 4198000C  blt cr6, 0x82cf95c0
	if ctx.cr[6].lt {
	pc = 0x82CF95C0; continue 'dispatch;
	}
	// 82CF95B8: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82CF95BC: 48000018  b 0x82cf95d4
	pc = 0x82CF95D4; continue 'dispatch;
            }
            0x82CF95C0 => {
    //   block [0x82CF95C0..0x82CF95D0)
	// 82CF95C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF95C4: 4199000C  bgt cr6, 0x82cf95d0
	if ctx.cr[6].gt {
	pc = 0x82CF95D0; continue 'dispatch;
	}
	// 82CF95C8: 9BEB0000  stb r31, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82CF95CC: 48000008  b 0x82cf95d4
	pc = 0x82CF95D4; continue 'dispatch;
            }
            0x82CF95D0 => {
    //   block [0x82CF95D0..0x82CF95D4)
	// 82CF95D0: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x82CF95D4; continue 'dispatch;
            }
            0x82CF95D4 => {
    //   block [0x82CF95D4..0x82CF95E0)
	// 82CF95D4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF95D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF95DC: 4082FFBC  bne 0x82cf9598
	if !ctx.cr[0].eq {
	pc = 0x82CF9598; continue 'dispatch;
	}
	pc = 0x82CF95E0; continue 'dispatch;
            }
            0x82CF95E0 => {
    //   block [0x82CF95E0..0x82CF95EC)
	// 82CF95E0: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF95E4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF95E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF95F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF95F0 size=428
    let mut pc: u32 = 0x82CF95F0;
    'dispatch: loop {
        match pc {
            0x82CF95F0 => {
    //   block [0x82CF95F0..0x82CF963C)
	// 82CF95F0: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF95F4: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF95F8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF95FC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF9600: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9604: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF9608: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF960C: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9610: 7D040E70  srawi r4, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 82CF9614: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9618: 7D0749D6  mullw r8, r7, r9
	ctx.r[8].s32 = ((ctx.r[7].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CF961C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9620: 7D292850  subf r9, r9, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 82CF9624: 7D440194  addze r10, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CF9628: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CF962C: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF9630: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF9634: 41980008  blt cr6, 0x82cf963c
	if ctx.cr[6].lt {
	pc = 0x82CF963C; continue 'dispatch;
	}
	// 82CF9638: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x82CF963C; continue 'dispatch;
            }
            0x82CF963C => {
    //   block [0x82CF963C..0x82CF967C)
	// 82CF963C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF9640: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9644: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9648: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF964C: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF9650: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF9654: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF9658: 38A9007F  addi r5, r9, 0x7f
	ctx.r[5].s64 = ctx.r[9].s64 + 127;
	// 82CF965C: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF9660: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF9664: C1860C4C  lfs f12, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF9668: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF966C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF9670: EDAB4024  fdivs f13, f11, f8
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CF9674: ED2D0332  fmuls f9, f13, f12
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9678: 419A0018  beq cr6, 0x82cf9690
	if ctx.cr[6].eq {
	pc = 0x82CF9690; continue 'dispatch;
	}
	pc = 0x82CF967C; continue 'dispatch;
            }
            0x82CF967C => {
    //   block [0x82CF967C..0x82CF9690)
	// 82CF967C: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9680: 7C065A2C  dcbt r6, r11
	// 82CF9684: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF9688: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF968C: 4198FFF0  blt cr6, 0x82cf967c
	if ctx.cr[6].lt {
	pc = 0x82CF967C; continue 'dispatch;
	}
	pc = 0x82CF9690; continue 'dispatch;
            }
            0x82CF9690 => {
    //   block [0x82CF9690..0x82CF96C8)
	// 82CF9690: 88A30034  lbz r5, 0x34(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CF9694: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CF9698: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CF969C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF96A0: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82CF96A4: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF96A8: FD00569C  fcfid f8, f10
	ctx.f[8].f64 = (ctx.f[10].s64 as f64);
	// 82CF96AC: C18767A4  lfs f12, 0x67a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26532 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF96B0: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF96B4: C16667A0  lfs f11, 0x67a0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(26528 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF96B8: C14A0BFC  lfs f10, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF96BC: ECC76028  fsubs f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CF96C0: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF96C4: D0A30034  stfs f5, 0x34(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x82CF96C8; continue 'dispatch;
            }
            0x82CF96C8 => {
    //   block [0x82CF96C8..0x82CF9740)
	// 82CF96C8: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF96CC: C1030034  lfs f8, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF96D0: ECED002A  fadds f7, f13, f0
	ctx.f[7].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF96D4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF96D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF96DC: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CF96E0: C8C1FFF0  lfd f6, -0x10(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF96E4: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF96E8: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF96EC: EC646028  fsubs f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CF96F0: EC4302F2  fmuls f2, f3, f11
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF96F4: D0430034  stfs f2, 0x34(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CF96F8: EC22402A  fadds f1, f2, f8
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF96FC: ED0700B2  fmuls f8, f7, f2
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9700: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9704: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9708: ECC702B2  fmuls f6, f7, f10
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF970C: D0C80000  stfs f6, 0(r8)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9710: D1080004  stfs f8, 4(r8)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9714: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82CF9718: 4082FFB0  bne 0x82cf96c8
	if !ctx.cr[0].eq {
	pc = 0x82CF96C8; continue 'dispatch;
	}
	// 82CF971C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9720: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9724: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF9728: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF972C: 0CC90000  twi 6, r9, 0
	// 82CF9730: 7D474B96  divwu r10, r7, r9
	ctx.r[10].u32 = ctx.r[7].u32 / ctx.r[9].u32;
	// 82CF9734: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9738: 41980008  blt cr6, 0x82cf9740
	if ctx.cr[6].lt {
	pc = 0x82CF9740; continue 'dispatch;
	}
	// 82CF973C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF9740; continue 'dispatch;
            }
            0x82CF9740 => {
    //   block [0x82CF9740..0x82CF9760)
	// 82CF9740: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9744: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF9748: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF974C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9750: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF9754: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9758: 40980008  bge cr6, 0x82cf9760
	if !ctx.cr[6].lt {
	pc = 0x82CF9760; continue 'dispatch;
	}
	// 82CF975C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF9760; continue 'dispatch;
            }
            0x82CF9760 => {
    //   block [0x82CF9760..0x82CF979C)
	// 82CF9760: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9764: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF9768: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF976C: C00A67A8  lfs f0, 0x67a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9770: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9774: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9778: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF977C: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 82CF9780: 8121FFF4  lwz r9, -0xc(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82CF9784: 21690080  subfic r11, r9, 0x80
	ctx.xer.ca = ctx.r[9].u32 <= 128 as u32;
	ctx.r[11].s64 = (128 as i64) - ctx.r[9].s64;
	// 82CF9788: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82CF978C: 41980010  blt cr6, 0x82cf979c
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82CF979C);
		return;
	}
	// 82CF9790: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82CF9794: 99630034  stb r11, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82CF9798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF97B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF97B0 size=572
    let mut pc: u32 = 0x82CF97B0;
    'dispatch: loop {
        match pc {
            0x82CF97B0 => {
    //   block [0x82CF97B0..0x82CF9804)
	// 82CF97B0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF97B4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF97B8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF97BC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF97C0: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF97C4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF97C8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF97CC: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF97D0: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF97D4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF97D8: 7CFF0E70  srawi r31, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 82CF97DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF97E0: 7D2441D6  mullw r9, r4, r8
	ctx.r[9].s32 = ((ctx.r[4].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF97E4: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF97E8: 7D085050  subf r8, r8, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF97EC: 7D5F0194  addze r10, r31
	tmp.s64 = ctx.r[31].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[31].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CF97F0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF97F4: 7D263A14  add r9, r6, r7
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF97F8: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF97FC: 41980008  blt cr6, 0x82cf9804
	if ctx.cr[6].lt {
	pc = 0x82CF9804; continue 'dispatch;
	}
	// 82CF9800: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82CF9804; continue 'dispatch;
            }
            0x82CF9804 => {
    //   block [0x82CF9804..0x82CF984C)
	// 82CF9804: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82CF9808: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF980C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9810: 550A083C  slwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF9814: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF9818: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF981C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF9820: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF9824: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9828: 394A007F  addi r10, r10, 0x7f
	ctx.r[10].s64 = ctx.r[10].s64 + 127;
	// 82CF982C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CF9830: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9834: 5547C9FE  srwi r7, r10, 7
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF9838: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 82CF983C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF9840: ED4C4824  fdivs f10, f12, f9
	ctx.f[10].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF9844: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9848: 419A0018  beq cr6, 0x82cf9860
	if ctx.cr[6].eq {
	pc = 0x82CF9860; continue 'dispatch;
	}
	pc = 0x82CF984C; continue 'dispatch;
            }
            0x82CF984C => {
    //   block [0x82CF984C..0x82CF9860)
	// 82CF984C: 55443830  slwi r4, r10, 7
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF9850: 7C045A2C  dcbt r4, r11
	// 82CF9854: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF9858: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF985C: 4198FFF0  blt cr6, 0x82cf984c
	if ctx.cr[6].lt {
	pc = 0x82CF984C; continue 'dispatch;
	}
	pc = 0x82CF9860; continue 'dispatch;
            }
            0x82CF9860 => {
    //   block [0x82CF9860..0x82CF9878)
	// 82CF9860: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CF9864: 3FE08201  lis r31, -0x7dff
	ctx.r[31].s64 = -2113863680;
	// 82CF9868: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82CF986C: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82CF9870: C18467A0  lfs f12, 0x67a0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF9874: C1BF67A4  lfs f13, 0x67a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF9878; continue 'dispatch;
            }
            0x82CF9878 => {
    //   block [0x82CF9878..0x82CF98AC)
	// 82CF9878: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF987C: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF9880: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CF9884: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF9888: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 82CF988C: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9890: ECC76828  fsubs f6, f7, f13
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9894: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9898: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF989C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF98A0: 4082FFD8  bne 0x82cf9878
	if !ctx.cr[0].eq {
	pc = 0x82CF9878; continue 'dispatch;
	}
	// 82CF98A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF98A8: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82CF98AC; continue 'dispatch;
            }
            0x82CF98AC => {
    //   block [0x82CF98AC..0x82CF9960)
	// 82CF98AC: 88EB0001  lbz r7, 1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF98B0: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF98B4: ECEA002A  fadds f7, f10, f0
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF98B8: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF98BC: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF98C0: C8C1FFE0  lfd f6, -0x20(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF98C4: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF98C8: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF98CC: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF98D0: EC430332  fmuls f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF98D4: D0450004  stfs f2, 4(r5)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF98D8: EC22402A  fadds f1, f2, f8
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF98DC: ED0700B2  fmuls f8, f7, f2
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF98E0: ECC10032  fmuls f6, f1, f0
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF98E4: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF98E8: D0A90400  stfs f5, 0x400(r9)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF98EC: D1090404  stfs f8, 0x404(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF98F0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF98F4: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 82CF98F8: C0450000  lfs f2, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CF98FC: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF9900: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CF9904: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF9908: FC201818  frsp f1, f3
	ctx.f[1].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF990C: ED016828  fsubs f8, f1, f13
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9910: ECC80332  fmuls f6, f8, f12
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9914: D0C50000  stfs f6, 0(r5)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9918: ECA6102A  fadds f5, f6, f2
	ctx.f[5].f64 = ((ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64;
	// 82CF991C: EC6701B2  fmuls f3, f7, f6
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF9920: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9924: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9928: EC4402F2  fmuls f2, f4, f11
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF992C: D0490000  stfs f2, 0(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9930: D0690004  stfs f3, 4(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9934: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82CF9938: 4082FF74  bne 0x82cf98ac
	if !ctx.cr[0].eq {
	pc = 0x82CF98AC; continue 'dispatch;
	}
	// 82CF993C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9940: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9944: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF9948: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF994C: 0CC80000  twi 6, r8, 0
	// 82CF9950: 7D474396  divwu r10, r7, r8
	ctx.r[10].u32 = ctx.r[7].u32 / ctx.r[8].u32;
	// 82CF9954: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9958: 41980008  blt cr6, 0x82cf9960
	if ctx.cr[6].lt {
	pc = 0x82CF9960; continue 'dispatch;
	}
	// 82CF995C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CF9960; continue 'dispatch;
            }
            0x82CF9960 => {
    //   block [0x82CF9960..0x82CF9980)
	// 82CF9960: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9964: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF9968: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF996C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9970: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF9974: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9978: 40980008  bge cr6, 0x82cf9980
	if !ctx.cr[6].lt {
	pc = 0x82CF9980; continue 'dispatch;
	}
	// 82CF997C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF9980; continue 'dispatch;
            }
            0x82CF9980 => {
    //   block [0x82CF9980..0x82CF999C)
	// 82CF9980: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF9984: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9988: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF998C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CF9990: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82CF9994: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 82CF9998: C00A67A8  lfs f0, 0x67a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CF999C; continue 'dispatch;
            }
            0x82CF999C => {
    //   block [0x82CF999C..0x82CF99C4)
	// 82CF999C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF99A0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF99A4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF99A8: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF99AC: 8141FFEC  lwz r10, -0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF99B0: 214A0080  subfic r10, r10, 0x80
	ctx.xer.ca = ctx.r[10].u32 <= 128 as u32;
	ctx.r[10].s64 = (128 as i64) - ctx.r[10].s64;
	// 82CF99B4: 2F0A00FF  cmpwi cr6, r10, 0xff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 255, &mut ctx.xer);
	// 82CF99B8: 4198000C  blt cr6, 0x82cf99c4
	if ctx.cr[6].lt {
	pc = 0x82CF99C4; continue 'dispatch;
	}
	// 82CF99BC: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82CF99C0: 48000018  b 0x82cf99d8
	pc = 0x82CF99D8; continue 'dispatch;
            }
            0x82CF99C4 => {
    //   block [0x82CF99C4..0x82CF99D4)
	// 82CF99C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF99C8: 4199000C  bgt cr6, 0x82cf99d4
	if ctx.cr[6].gt {
	pc = 0x82CF99D4; continue 'dispatch;
	}
	// 82CF99CC: 98CB0000  stb r6, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 82CF99D0: 48000008  b 0x82cf99d8
	pc = 0x82CF99D8; continue 'dispatch;
            }
            0x82CF99D4 => {
    //   block [0x82CF99D4..0x82CF99D8)
	// 82CF99D4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x82CF99D8; continue 'dispatch;
            }
            0x82CF99D8 => {
    //   block [0x82CF99D8..0x82CF99EC)
	// 82CF99D8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF99DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF99E0: 4082FFBC  bne 0x82cf999c
	if !ctx.cr[0].eq {
	pc = 0x82CF999C; continue 'dispatch;
	}
	// 82CF99E4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF99E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF99F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF99F0 size=688
    let mut pc: u32 = 0x82CF99F0;
    'dispatch: loop {
        match pc {
            0x82CF99F0 => {
    //   block [0x82CF99F0..0x82CF9A44)
	// 82CF99F0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF99F4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF99F8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF99FC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9A00: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 82CF9A04: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF9A08: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF9A0C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF9A10: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9A14: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9A18: 7CFF0E70  srawi r31, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 82CF9A1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9A20: 7D4641D6  mullw r10, r6, r8
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF9A24: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9A28: 7CE82050  subf r7, r8, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF9A2C: 7D1F0194  addze r8, r31
	tmp.s64 = ctx.r[31].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[31].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF9A30: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF9A34: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF9A38: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF9A3C: 41980008  blt cr6, 0x82cf9a44
	if ctx.cr[6].lt {
	pc = 0x82CF9A44; continue 'dispatch;
	}
	// 82CF9A40: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82CF9A44; continue 'dispatch;
            }
            0x82CF9A44 => {
    //   block [0x82CF9A44..0x82CF9A8C)
	// 82CF9A44: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF9A48: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9A4C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9A50: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9A54: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CF9A58: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9A5C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF9A60: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF9A64: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9A68: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF9A6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CF9A70: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9A74: 5506C9FE  srwi r6, r8, 7
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9A78: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CF9A7C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF9A80: ED4C4824  fdivs f10, f12, f9
	ctx.f[10].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF9A84: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9A88: 419A0018  beq cr6, 0x82cf9aa0
	if ctx.cr[6].eq {
	pc = 0x82CF9AA0; continue 'dispatch;
	}
	pc = 0x82CF9A8C; continue 'dispatch;
            }
            0x82CF9A8C => {
    //   block [0x82CF9A8C..0x82CF9AA0)
	// 82CF9A8C: 55043830  slwi r4, r8, 7
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF9A90: 7C04522C  dcbt r4, r10
	// 82CF9A94: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF9A98: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF9A9C: 4198FFF0  blt cr6, 0x82cf9a8c
	if ctx.cr[6].lt {
	pc = 0x82CF9A8C; continue 'dispatch;
	}
	pc = 0x82CF9AA0; continue 'dispatch;
            }
            0x82CF9AA0 => {
    //   block [0x82CF9AA0..0x82CF9AB8)
	// 82CF9AA0: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CF9AA4: 3FE08201  lis r31, -0x7dff
	ctx.r[31].s64 = -2113863680;
	// 82CF9AA8: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF9AAC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF9AB0: C18467A0  lfs f12, 0x67a0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF9AB4: C1BF67A4  lfs f13, 0x67a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF9AB8; continue 'dispatch;
            }
            0x82CF9AB8 => {
    //   block [0x82CF9AB8..0x82CF9AEC)
	// 82CF9AB8: 88880000  lbz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9ABC: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF9AC0: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CF9AC4: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9AC8: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 82CF9ACC: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9AD0: ECC76828  fsubs f6, f7, f13
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9AD4: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9AD8: D0A80000  stfs f5, 0(r8)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9ADC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF9AE0: 4082FFD8  bne 0x82cf9ab8
	if !ctx.cr[0].eq {
	pc = 0x82CF9AB8; continue 'dispatch;
	}
	// 82CF9AE4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF9AE8: C1680BFC  lfs f11, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82CF9AEC; continue 'dispatch;
            }
            0x82CF9AEC => {
    //   block [0x82CF9AEC..0x82CF9C18)
	// 82CF9AEC: 88CA0003  lbz r6, 3(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 82CF9AF0: C109000C  lfs f8, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF9AF4: ECEA002A  fadds f7, f10, f0
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9AF8: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF9AFC: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CF9B00: C8C1FFD0  lfd f6, -0x30(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9B04: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF9B08: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF9B0C: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9B10: EC430332  fmuls f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9B14: D049000C  stfs f2, 0xc(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF9B18: EC22402A  fadds f1, f2, f8
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF9B1C: ED0700B2  fmuls f8, f7, f2
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9B20: ECC10032  fmuls f6, f1, f0
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9B24: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9B28: D0AB0C00  stfs f5, 0xc00(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF9B2C: D10B0C04  stfs f8, 0xc04(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF9B30: 890A0002  lbz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF9B34: F901FFD8  std r8, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[8].u64 ) };
	// 82CF9B38: C0490008  lfs f2, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CF9B3C: C881FFD8  lfd f4, -0x28(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF9B40: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF9B44: FC201818  frsp f1, f3
	ctx.f[1].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF9B48: ED016828  fsubs f8, f1, f13
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9B4C: ECC80332  fmuls f6, f8, f12
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9B50: D0C90008  stfs f6, 8(r9)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF9B54: ECA6102A  fadds f5, f6, f2
	ctx.f[5].f64 = ((ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64;
	// 82CF9B58: EC6701B2  fmuls f3, f7, f6
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF9B5C: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9B60: EC4402F2  fmuls f2, f4, f11
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9B64: D04B0800  stfs f2, 0x800(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF9B68: D06B0804  stfs f3, 0x804(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF9B6C: 888A0001  lbz r4, 1(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF9B70: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CF9B74: C0C90004  lfs f6, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF9B78: C821FFE0  lfd f1, -0x20(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF9B7C: FD000E9C  fcfid f8, f1
	ctx.f[8].f64 = (ctx.f[1].s64 as f64);
	// 82CF9B80: FCA04018  frsp f5, f8
	ctx.f[5].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9B84: EC856828  fsubs f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9B88: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9B8C: D0690004  stfs f3, 4(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9B90: EC43302A  fadds f2, f3, f6
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF9B94: ED0700F2  fmuls f8, f7, f3
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF9B98: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9B9C: ECC102F2  fmuls f6, f1, f11
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9BA0: D0CB0400  stfs f6, 0x400(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF9BA4: D10B0404  stfs f8, 0x404(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF9BA8: 88CA0000  lbz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9BAC: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF9BB0: C0690000  lfs f3, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF9BB4: C8A1FFE8  lfd f5, -0x18(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF9BB8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF9BBC: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF9BC0: FC402018  frsp f2, f4
	ctx.f[2].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF9BC4: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9BC8: ED010332  fmuls f8, f1, f12
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9BCC: D1090000  stfs f8, 0(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9BD0: ECC8182A  fadds f6, f8, f3
	ctx.f[6].f64 = ((ctx.f[8].f64 + ctx.f[3].f64) as f32) as f64;
	// 82CF9BD4: EC870232  fmuls f4, f7, f8
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82CF9BD8: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9BDC: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9BE0: EC6502F2  fmuls f3, f5, f11
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9BE4: D06B0000  stfs f3, 0(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9BE8: D08B0004  stfs f4, 4(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9BEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF9BF0: 4082FEFC  bne 0x82cf9aec
	if !ctx.cr[0].eq {
	pc = 0x82CF9AEC; continue 'dispatch;
	}
	// 82CF9BF4: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9BF8: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9BFC: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF9C00: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9C04: 0CC70000  twi 6, r7, 0
	// 82CF9C08: 7D063B96  divwu r8, r6, r7
	ctx.r[8].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF9C0C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF9C10: 41980008  blt cr6, 0x82cf9c18
	if ctx.cr[6].lt {
	pc = 0x82CF9C18; continue 'dispatch;
	}
	// 82CF9C14: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82CF9C18; continue 'dispatch;
            }
            0x82CF9C18 => {
    //   block [0x82CF9C18..0x82CF9C38)
	// 82CF9C18: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9C1C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9C20: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF9C24: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF9C28: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF9C2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF9C30: 41980008  blt cr6, 0x82cf9c38
	if ctx.cr[6].lt {
	pc = 0x82CF9C38; continue 'dispatch;
	}
	// 82CF9C34: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CF9C38; continue 'dispatch;
            }
            0x82CF9C38 => {
    //   block [0x82CF9C38..0x82CF9C50)
	// 82CF9C38: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9C3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF9C40: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9C44: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF9C48: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 82CF9C4C: C00B67A8  lfs f0, 0x67a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CF9C50; continue 'dispatch;
            }
            0x82CF9C50 => {
    //   block [0x82CF9C50..0x82CF9C78)
	// 82CF9C50: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9C54: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9C58: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF9C5C: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF9C60: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF9C64: 216B0080  subfic r11, r11, 0x80
	ctx.xer.ca = ctx.r[11].u32 <= 128 as u32;
	ctx.r[11].s64 = (128 as i64) - ctx.r[11].s64;
	// 82CF9C68: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82CF9C6C: 4198000C  blt cr6, 0x82cf9c78
	if ctx.cr[6].lt {
	pc = 0x82CF9C78; continue 'dispatch;
	}
	// 82CF9C70: 99090000  stb r8, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82CF9C74: 48000018  b 0x82cf9c8c
	pc = 0x82CF9C8C; continue 'dispatch;
            }
            0x82CF9C78 => {
    //   block [0x82CF9C78..0x82CF9C88)
	// 82CF9C78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF9C7C: 4199000C  bgt cr6, 0x82cf9c88
	if ctx.cr[6].gt {
	pc = 0x82CF9C88; continue 'dispatch;
	}
	// 82CF9C80: 98A90000  stb r5, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82CF9C84: 48000008  b 0x82cf9c8c
	pc = 0x82CF9C8C; continue 'dispatch;
            }
            0x82CF9C88 => {
    //   block [0x82CF9C88..0x82CF9C8C)
	// 82CF9C88: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x82CF9C8C; continue 'dispatch;
            }
            0x82CF9C8C => {
    //   block [0x82CF9C8C..0x82CF9CA0)
	// 82CF9C8C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF9C90: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF9C94: 4082FFBC  bne 0x82cf9c50
	if !ctx.cr[0].eq {
	pc = 0x82CF9C50; continue 'dispatch;
	}
	// 82CF9C98: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF9C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF9CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF9CA0 size=816
    let mut pc: u32 = 0x82CF9CA0;
    'dispatch: loop {
        match pc {
            0x82CF9CA0 => {
    //   block [0x82CF9CA0..0x82CF9CF4)
	// 82CF9CA0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF9CA4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF9CA8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9CAC: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9CB0: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82CF9CB4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF9CB8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF9CBC: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF9CC0: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9CC4: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9CC8: 7CFF0E70  srawi r31, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 82CF9CCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9CD0: 7D2641D6  mullw r9, r6, r8
	ctx.r[9].s32 = ((ctx.r[6].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CF9CD4: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9CD8: 7CE82050  subf r7, r8, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF9CDC: 7D1F0194  addze r8, r31
	tmp.s64 = ctx.r[31].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[31].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF9CE0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF9CE4: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF9CE8: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF9CEC: 41980008  blt cr6, 0x82cf9cf4
	if ctx.cr[6].lt {
	pc = 0x82CF9CF4; continue 'dispatch;
	}
	// 82CF9CF0: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82CF9CF4; continue 'dispatch;
            }
            0x82CF9CF4 => {
    //   block [0x82CF9CF4..0x82CF9D44)
	// 82CF9CF4: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF9CF8: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9CFC: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9D00: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9D04: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CF9D08: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9D0C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF9D10: 7CA74214  add r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF9D14: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9D18: 54A8083C  slwi r8, r5, 1
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9D1C: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF9D20: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF9D24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CF9D28: 5506C9FE  srwi r6, r8, 7
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9D2C: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CF9D30: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9D34: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF9D38: ED4C4824  fdivs f10, f12, f9
	ctx.f[10].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF9D3C: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9D40: 419A0018  beq cr6, 0x82cf9d58
	if ctx.cr[6].eq {
	pc = 0x82CF9D58; continue 'dispatch;
	}
	pc = 0x82CF9D44; continue 'dispatch;
            }
            0x82CF9D44 => {
    //   block [0x82CF9D44..0x82CF9D58)
	// 82CF9D44: 55043830  slwi r4, r8, 7
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF9D48: 7C044A2C  dcbt r4, r9
	// 82CF9D4C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF9D50: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF9D54: 4198FFF0  blt cr6, 0x82cf9d44
	if ctx.cr[6].lt {
	pc = 0x82CF9D44; continue 'dispatch;
	}
	pc = 0x82CF9D58; continue 'dispatch;
            }
            0x82CF9D58 => {
    //   block [0x82CF9D58..0x82CF9D70)
	// 82CF9D58: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CF9D5C: 3FE08201  lis r31, -0x7dff
	ctx.r[31].s64 = -2113863680;
	// 82CF9D60: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF9D64: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82CF9D68: C18467A0  lfs f12, 0x67a0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF9D6C: C1BF67A4  lfs f13, 0x67a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CF9D70; continue 'dispatch;
            }
            0x82CF9D70 => {
    //   block [0x82CF9D70..0x82CF9DA4)
	// 82CF9D70: 88880000  lbz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9D74: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF9D78: F881FFC0  std r4, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[4].u64 ) };
	// 82CF9D7C: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9D80: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 82CF9D84: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9D88: ECC76828  fsubs f6, f7, f13
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9D8C: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9D90: D0A80000  stfs f5, 0(r8)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9D94: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF9D98: 4082FFD8  bne 0x82cf9d70
	if !ctx.cr[0].eq {
	pc = 0x82CF9D70; continue 'dispatch;
	}
	// 82CF9D9C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF9DA0: C1680BFC  lfs f11, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82CF9DA4; continue 'dispatch;
            }
            0x82CF9DA4 => {
    //   block [0x82CF9DA4..0x82CF9F48)
	// 82CF9DA4: 88C90005  lbz r6, 5(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(5 as u32) ) } as u64;
	// 82CF9DA8: C10A0014  lfs f8, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF9DAC: ECEA002A  fadds f7, f10, f0
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9DB0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF9DB4: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CF9DB8: C8C1FFC0  lfd f6, -0x40(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9DBC: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF9DC0: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF9DC4: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9DC8: EC430332  fmuls f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9DCC: D04A0014  stfs f2, 0x14(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82CF9DD0: EC22402A  fadds f1, f2, f8
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF9DD4: ED0700B2  fmuls f8, f7, f2
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9DD8: ECC10032  fmuls f6, f1, f0
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9DDC: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9DE0: D0AB1400  stfs f5, 0x1400(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF9DE4: D10B1404  stfs f8, 0x1404(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5124 as u32), tmp.u32 ) };
	// 82CF9DE8: 89090004  lbz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9DEC: F901FFC8  std r8, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[8].u64 ) };
	// 82CF9DF0: C04A0010  lfs f2, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CF9DF4: C881FFC8  lfd f4, -0x38(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CF9DF8: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF9DFC: FC201818  frsp f1, f3
	ctx.f[1].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF9E00: ED016828  fsubs f8, f1, f13
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9E04: ECC80332  fmuls f6, f8, f12
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9E08: D0CA0010  stfs f6, 0x10(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82CF9E0C: ECA6102A  fadds f5, f6, f2
	ctx.f[5].f64 = ((ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64;
	// 82CF9E10: EC6701B2  fmuls f3, f7, f6
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF9E14: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9E18: EC4402F2  fmuls f2, f4, f11
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9E1C: D04B1000  stfs f2, 0x1000(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF9E20: D06B1004  stfs f3, 0x1004(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), tmp.u32 ) };
	// 82CF9E24: 88890003  lbz r4, 3(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 82CF9E28: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CF9E2C: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF9E30: C821FFD0  lfd f1, -0x30(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9E34: FD000E9C  fcfid f8, f1
	ctx.f[8].f64 = (ctx.f[1].s64 as f64);
	// 82CF9E38: FCA04018  frsp f5, f8
	ctx.f[5].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9E3C: EC856828  fsubs f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9E40: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9E44: D06A000C  stfs f3, 0xc(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF9E48: EC43302A  fadds f2, f3, f6
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF9E4C: ED0700F2  fmuls f8, f7, f3
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF9E50: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9E54: ECC102F2  fmuls f6, f1, f11
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9E58: D0CB0C00  stfs f6, 0xc00(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF9E5C: D10B0C04  stfs f8, 0xc04(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF9E60: 88C90002  lbz r6, 2(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF9E64: F8C1FFD8  std r6, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[6].u64 ) };
	// 82CF9E68: C06A0008  lfs f3, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF9E6C: C8A1FFD8  lfd f5, -0x28(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF9E70: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF9E74: FC402018  frsp f2, f4
	ctx.f[2].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF9E78: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9E7C: ED010332  fmuls f8, f1, f12
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9E80: D10A0008  stfs f8, 8(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF9E84: ECC8182A  fadds f6, f8, f3
	ctx.f[6].f64 = ((ctx.f[8].f64 + ctx.f[3].f64) as f32) as f64;
	// 82CF9E88: EC870232  fmuls f4, f7, f8
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82CF9E8C: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9E90: EC6502F2  fmuls f3, f5, f11
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9E94: D06B0800  stfs f3, 0x800(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF9E98: D08B0804  stfs f4, 0x804(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF9E9C: 89090001  lbz r8, 1(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF9EA0: F901FFE0  std r8, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u64 ) };
	// 82CF9EA4: C10A0004  lfs f8, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF9EA8: C841FFE0  lfd f2, -0x20(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF9EAC: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF9EB0: FCC00818  frsp f6, f1
	ctx.f[6].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF9EB4: ECA66828  fsubs f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9EB8: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9EBC: D08A0004  stfs f4, 4(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9EC0: EC64402A  fadds f3, f4, f8
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF9EC4: EC270132  fmuls f1, f7, f4
	ctx.f[1].f64 = (((ctx.f[7].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF9EC8: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9ECC: ED0202F2  fmuls f8, f2, f11
	ctx.f[8].f64 = (((ctx.f[2].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9ED0: D10B0400  stfs f8, 0x400(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF9ED4: D02B0404  stfs f1, 0x404(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF9ED8: 88890000  lbz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9EDC: C0CA0000  lfs f6, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF9EE0: 39290006  addi r9, r9, 6
	ctx.r[9].s64 = ctx.r[9].s64 + 6;
	// 82CF9EE4: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CF9EE8: C8A1FFE8  lfd f5, -0x18(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF9EEC: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF9EF0: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF9EF4: EC436828  fsubs f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9EF8: EC220332  fmuls f1, f2, f12
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9EFC: D02A0000  stfs f1, 0(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9F00: ED01302A  fadds f8, f1, f6
	ctx.f[8].f64 = ((ctx.f[1].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF9F04: ECE70072  fmuls f7, f7, f1
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CF9F08: ECC80032  fmuls f6, f8, f0
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9F0C: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9F10: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9F14: D0AB0000  stfs f5, 0(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9F18: D0EB0004  stfs f7, 4(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9F1C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF9F20: 4082FE84  bne 0x82cf9da4
	if !ctx.cr[0].eq {
	pc = 0x82CF9DA4; continue 'dispatch;
	}
	// 82CF9F24: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9F28: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9F2C: 7CC84850  subf r6, r8, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82CF9F30: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9F34: 0CC70000  twi 6, r7, 0
	// 82CF9F38: 7D063B96  divwu r8, r6, r7
	ctx.r[8].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF9F3C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF9F40: 41980008  blt cr6, 0x82cf9f48
	if ctx.cr[6].lt {
	pc = 0x82CF9F48; continue 'dispatch;
	}
	// 82CF9F44: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CF9F48; continue 'dispatch;
            }
            0x82CF9F48 => {
    //   block [0x82CF9F48..0x82CF9F68)
	// 82CF9F48: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9F4C: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9F50: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF9F54: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF9F58: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF9F5C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF9F60: 41980008  blt cr6, 0x82cf9f68
	if ctx.cr[6].lt {
	pc = 0x82CF9F68; continue 'dispatch;
	}
	// 82CF9F64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82CF9F68; continue 'dispatch;
            }
            0x82CF9F68 => {
    //   block [0x82CF9F68..0x82CF9F80)
	// 82CF9F68: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9F6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF9F70: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9F74: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CF9F78: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 82CF9F7C: C00B67A8  lfs f0, 0x67a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CF9F80; continue 'dispatch;
            }
            0x82CF9F80 => {
    //   block [0x82CF9F80..0x82CF9FA8)
	// 82CF9F80: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9F84: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9F88: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF9F8C: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF9F90: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF9F94: 216B0080  subfic r11, r11, 0x80
	ctx.xer.ca = ctx.r[11].u32 <= 128 as u32;
	ctx.r[11].s64 = (128 as i64) - ctx.r[11].s64;
	// 82CF9F98: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82CF9F9C: 4198000C  blt cr6, 0x82cf9fa8
	if ctx.cr[6].lt {
	pc = 0x82CF9FA8; continue 'dispatch;
	}
	// 82CF9FA0: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82CF9FA4: 48000018  b 0x82cf9fbc
	pc = 0x82CF9FBC; continue 'dispatch;
            }
            0x82CF9FA8 => {
    //   block [0x82CF9FA8..0x82CF9FB8)
	// 82CF9FA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF9FAC: 4199000C  bgt cr6, 0x82cf9fb8
	if ctx.cr[6].gt {
	pc = 0x82CF9FB8; continue 'dispatch;
	}
	// 82CF9FB0: 98AA0000  stb r5, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82CF9FB4: 48000008  b 0x82cf9fbc
	pc = 0x82CF9FBC; continue 'dispatch;
            }
            0x82CF9FB8 => {
    //   block [0x82CF9FB8..0x82CF9FBC)
	// 82CF9FB8: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x82CF9FBC; continue 'dispatch;
            }
            0x82CF9FBC => {
    //   block [0x82CF9FBC..0x82CF9FD0)
	// 82CF9FBC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF9FC0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF9FC4: 4082FFBC  bne 0x82cf9f80
	if !ctx.cr[0].eq {
	pc = 0x82CF9F80; continue 'dispatch;
	}
	// 82CF9FC8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF9FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF9FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF9FD0 size=560
    let mut pc: u32 = 0x82CF9FD0;
    'dispatch: loop {
        match pc {
            0x82CF9FD0 => {
    //   block [0x82CF9FD0..0x82CFA030)
	// 82CF9FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF9FD4: 4BFAF435  bl 0x82ca9408
	ctx.lr = 0x82CF9FD8;
	sub_82CA93D0(ctx, base);
	// 82CF9FD8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF9FDC: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9FE0: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9FE4: 3BC30034  addi r30, r3, 0x34
	ctx.r[30].s64 = ctx.r[3].s64 + 52;
	// 82CF9FE8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9FEC: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF9FF0: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9FF4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF9FF8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9FFC: 7D0429D6  mullw r8, r4, r5
	ctx.r[8].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CFA000: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA004: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA008: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82CFA00C: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82CFA010: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA014: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82CFA018: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFA01C: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CFA020: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CFA024: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CFA028: 41980008  blt cr6, 0x82cfa030
	if ctx.cr[6].lt {
	pc = 0x82CFA030; continue 'dispatch;
	}
	// 82CFA02C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82CFA030; continue 'dispatch;
            }
            0x82CFA030 => {
    //   block [0x82CFA030..0x82CFA074)
	// 82CFA030: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CFA034: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA038: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA03C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFA040: F961FFD0  std r11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u64 ) };
	// 82CFA044: C941FFD0  lfd f10, -0x30(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA048: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CFA04C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFA050: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA054: C1AA0C4C  lfs f13, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA058: C1890C58  lfs f12, 0xc58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFA05C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CFA060: ED4B4024  fdivs f10, f11, f8
	ctx.f[10].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CFA064: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA068: 419A0040  beq cr6, 0x82cfa0a8
	if ctx.cr[6].eq {
	pc = 0x82CFA0A8; continue 'dispatch;
	}
	// 82CFA06C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CFA070: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	pc = 0x82CFA074; continue 'dispatch;
            }
            0x82CFA074 => {
    //   block [0x82CFA074..0x82CFA0A8)
	// 82CFA074: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA078: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CFA07C: 5528C63E  rlwinm r8, r9, 0x18, 0x18, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CFA080: 5128442E  rlwimi r8, r9, 8, 0x10, 0x17
	ctx.r[8].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA084: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 82CFA088: F901FFD0  std r8, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u64 ) };
	// 82CFA08C: C9A1FFD0  lfd f13, -0x30(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA090: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 82CFA094: FD005818  frsp f8, f11
	ctx.f[8].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CFA098: ECE80332  fmuls f7, f8, f12
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA09C: D0EB0000  stfs f7, 0(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA0A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA0A4: 4082FFD0  bne 0x82cfa074
	if !ctx.cr[0].eq {
	pc = 0x82CFA074; continue 'dispatch;
	}
	pc = 0x82CFA0A8; continue 'dispatch;
            }
            0x82CFA0A8 => {
    //   block [0x82CFA0A8..0x82CFA0B4)
	// 82CFA0A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFA0AC: 549F083C  slwi r31, r4, 1
	ctx.r[31].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82CFA0B0: C16B0BFC  lfs f11, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82CFA0B4; continue 'dispatch;
            }
            0x82CFA0B4 => {
    //   block [0x82CFA0B4..0x82CFA0D0)
	// 82CFA0B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CFA0B8: 419A0070  beq cr6, 0x82cfa128
	if ctx.cr[6].eq {
	pc = 0x82CFA128; continue 'dispatch;
	}
	// 82CFA0BC: EDAA002A  fadds f13, f10, f0
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA0C0: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82CFA0C4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CFA0C8: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CFA0CC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	pc = 0x82CFA0D0; continue 'dispatch;
            }
            0x82CFA0D0 => {
    //   block [0x82CFA0D0..0x82CFA128)
	// 82CFA0D0: A3A80000  lhz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA0D4: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CFA0D8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFA0DC: 57BCC63E  rlwinm r28, r29, 0x18, 0x18, 0x1f
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82CFA0E0: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 82CFA0E4: 53BC442E  rlwimi r28, r29, 8, 0x10, 0x17
	ctx.r[28].u64 = (((ctx.r[29].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[28].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA0E8: 7F9D0734  extsh r29, r28
	ctx.r[29].s64 = ctx.r[28].s16 as i64;
	// 82CFA0EC: FBA1FFD0  std r29, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[29].u64 ) };
	// 82CFA0F0: C8E1FFD0  lfd f7, -0x30(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA0F4: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFA0F8: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFA0FC: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA100: D08B0000  stfs f4, 0(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA104: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA108: EC64402A  fadds f3, f4, f8
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CFA10C: EC4D0132  fmuls f2, f13, f4
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFA110: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA114: ED0102F2  fmuls f8, f1, f11
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFA118: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA11C: D04A0004  stfs f2, 4(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA120: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CFA124: 4082FFAC  bne 0x82cfa0d0
	if !ctx.cr[0].eq {
	pc = 0x82CFA0D0; continue 'dispatch;
	}
	pc = 0x82CFA128; continue 'dispatch;
            }
            0x82CFA128 => {
    //   block [0x82CFA128..0x82CFA164)
	// 82CFA128: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CFA12C: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA130: 7CBF2A14  add r5, r31, r5
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[5].u64;
	// 82CFA134: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82CFA138: 4082FF7C  bne 0x82cfa0b4
	if !ctx.cr[0].eq {
	pc = 0x82CFA0B4; continue 'dispatch;
	}
	// 82CFA13C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA140: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA144: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CFA148: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA14C: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CFA150: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CFA154: 0CC80000  twi 6, r8, 0
	// 82CFA158: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFA15C: 41980008  blt cr6, 0x82cfa164
	if ctx.cr[6].lt {
	pc = 0x82CFA164; continue 'dispatch;
	}
	// 82CFA160: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CFA164; continue 'dispatch;
            }
            0x82CFA164 => {
    //   block [0x82CFA164..0x82CFA184)
	// 82CFA164: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA168: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CFA16C: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CFA170: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA174: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA178: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFA17C: 40980008  bge cr6, 0x82cfa184
	if !ctx.cr[6].lt {
	pc = 0x82CFA184; continue 'dispatch;
	}
	// 82CFA180: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CFA184; continue 'dispatch;
            }
            0x82CFA184 => {
    //   block [0x82CFA184..0x82CFA1AC)
	// 82CFA184: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFA188: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFA18C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CFA190: 419A006C  beq cr6, 0x82cfa1fc
	if ctx.cr[6].eq {
	pc = 0x82CFA1FC; continue 'dispatch;
	}
	// 82CFA194: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CFA198: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82CFA19C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CFA1A0: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 82CFA1A4: 6129FF7F  ori r9, r9, 0xff7f
	ctx.r[9].u64 = ctx.r[9].u64 | 65407;
	// 82CFA1A8: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CFA1AC; continue 'dispatch;
            }
            0x82CFA1AC => {
    //   block [0x82CFA1AC..0x82CFA1D0)
	// 82CFA1AC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA1B0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA1B4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFA1B8: D961FFD0  stfd f11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[11].u64 ) };
	// 82CFA1BC: 8141FFD4  lwz r10, -0x2c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82CFA1C0: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 82CFA1C4: 4198000C  blt cr6, 0x82cfa1d0
	if ctx.cr[6].lt {
	pc = 0x82CFA1D0; continue 'dispatch;
	}
	// 82CFA1C8: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82CFA1CC: 48000024  b 0x82cfa1f0
	pc = 0x82CFA1F0; continue 'dispatch;
            }
            0x82CFA1D0 => {
    //   block [0x82CFA1D0..0x82CFA1E0)
	// 82CFA1D0: 2F0A8000  cmpwi cr6, r10, -0x8000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -32768, &mut ctx.xer);
	// 82CFA1D4: 4199000C  bgt cr6, 0x82cfa1e0
	if ctx.cr[6].gt {
	pc = 0x82CFA1E0; continue 'dispatch;
	}
	// 82CFA1D8: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CFA1DC: 48000014  b 0x82cfa1f0
	pc = 0x82CFA1F0; continue 'dispatch;
            }
            0x82CFA1E0 => {
    //   block [0x82CFA1E0..0x82CFA1F0)
	// 82CFA1E0: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82CFA1E4: 5547C63E  rlwinm r7, r10, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CFA1E8: 5147442E  rlwimi r7, r10, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA1EC: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	pc = 0x82CFA1F0; continue 'dispatch;
            }
            0x82CFA1F0 => {
    //   block [0x82CFA1F0..0x82CFA1FC)
	// 82CFA1F0: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFA1F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA1F8: 4082FFB4  bne 0x82cfa1ac
	if !ctx.cr[0].eq {
	pc = 0x82CFA1AC; continue 'dispatch;
	}
	pc = 0x82CFA1FC; continue 'dispatch;
            }
            0x82CFA1FC => {
    //   block [0x82CFA1FC..0x82CFA200)
	// 82CFA1FC: 4BFAF25C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFA200 size=444
    let mut pc: u32 = 0x82CFA200;
    'dispatch: loop {
        match pc {
            0x82CFA200 => {
    //   block [0x82CFA200..0x82CFA250)
	// 82CFA200: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFA204: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA208: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA20C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFA210: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA214: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA218: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFA21C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA220: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFA224: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA228: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA22C: 7CA50E70  srawi r5, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CFA230: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA234: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CFA238: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CFA23C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CFA240: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFA244: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CFA248: 41980008  blt cr6, 0x82cfa250
	if ctx.cr[6].lt {
	pc = 0x82CFA250; continue 'dispatch;
	}
	// 82CFA24C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x82CFA250; continue 'dispatch;
            }
            0x82CFA250 => {
    //   block [0x82CFA250..0x82CFA294)
	// 82CFA250: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82CFA254: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA258: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA25C: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA260: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CFA264: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFA268: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CFA26C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CFA270: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA274: 38AA007F  addi r5, r10, 0x7f
	ctx.r[5].s64 = ctx.r[10].s64 + 127;
	// 82CFA278: C1860C4C  lfs f12, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFA27C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFA280: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFA284: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFA288: EDAB4024  fdivs f13, f11, f8
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CFA28C: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA290: 419A0018  beq cr6, 0x82cfa2a8
	if ctx.cr[6].eq {
	pc = 0x82CFA2A8; continue 'dispatch;
	}
	pc = 0x82CFA294; continue 'dispatch;
            }
            0x82CFA294 => {
    //   block [0x82CFA294..0x82CFA2A8)
	// 82CFA294: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA298: 7C065A2C  dcbt r6, r11
	// 82CFA29C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CFA2A0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CFA2A4: 4198FFF0  blt cr6, 0x82cfa294
	if ctx.cr[6].lt {
	pc = 0x82CFA294; continue 'dispatch;
	}
	pc = 0x82CFA2A8; continue 'dispatch;
            }
            0x82CFA2A8 => {
    //   block [0x82CFA2A8..0x82CFA2E0)
	// 82CFA2A8: A1430034  lhz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CFA2AC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CFA2B0: 5546C63E  rlwinm r6, r10, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CFA2B4: 5146442E  rlwimi r6, r10, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA2B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFA2BC: C1470C58  lfs f10, 0xc58(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3160 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFA2C0: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA2C4: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82CFA2C8: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFA2CC: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFA2D0: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA2D4: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFA2D8: ECE802B2  fmuls f7, f8, f10
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CFA2DC: D0E30034  stfs f7, 0x34(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x82CFA2E0; continue 'dispatch;
            }
            0x82CFA2E0 => {
    //   block [0x82CFA2E0..0x82CFA364)
	// 82CFA2E0: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA2E4: C1230034  lfs f9, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFA2E8: ED0D002A  fadds f8, f13, f0
	ctx.f[8].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA2EC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFA2F0: 5547C63E  rlwinm r7, r10, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CFA2F4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CFA2F8: 5147442E  rlwimi r7, r10, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA2FC: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CFA300: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82CFA304: C8E1FFF0  lfd f7, -0x10(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFA308: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFA30C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFA310: EC8502B2  fmuls f4, f5, f10
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CFA314: D0830034  stfs f4, 0x34(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CFA318: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CFA31C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFA320: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA324: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA328: ED2102F2  fmuls f9, f1, f11
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFA32C: D1280000  stfs f9, 0(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA330: D0480004  stfs f2, 4(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA334: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82CFA338: 4082FFA8  bne 0x82cfa2e0
	if !ctx.cr[0].eq {
	pc = 0x82CFA2E0; continue 'dispatch;
	}
	// 82CFA33C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA340: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA344: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CFA348: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA34C: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CFA350: 0CC70000  twi 6, r7, 0
	// 82CFA354: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CFA358: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFA35C: 40980008  bge cr6, 0x82cfa364
	if !ctx.cr[6].lt {
	pc = 0x82CFA364; continue 'dispatch;
	}
	// 82CFA360: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82CFA364; continue 'dispatch;
            }
            0x82CFA364 => {
    //   block [0x82CFA364..0x82CFA384)
	// 82CFA364: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA368: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CFA36C: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CFA370: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA374: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA378: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFA37C: 40980008  bge cr6, 0x82cfa384
	if !ctx.cr[6].lt {
	pc = 0x82CFA384; continue 'dispatch;
	}
	// 82CFA380: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CFA384; continue 'dispatch;
            }
            0x82CFA384 => {
    //   block [0x82CFA384..0x82CFA3BC)
	// 82CFA384: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CFA388: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFA38C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFA390: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA394: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA398: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA39C: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFA3A0: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 82CFA3A4: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82CFA3A8: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CFA3AC: 41980010  blt cr6, 0x82cfa3bc
	if ctx.cr[6].lt {
		sub_82CFA3BC(ctx, base);
		return;
	}
	// 82CFA3B0: 3960FF7F  li r11, -0x81
	ctx.r[11].s64 = -129;
	// 82CFA3B4: B1630034  sth r11, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u16 ) };
	// 82CFA3B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA3BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CFA3BC size=20
    let mut pc: u32 = 0x82CFA3BC;
    'dispatch: loop {
        match pc {
            0x82CFA3BC => {
    //   block [0x82CFA3BC..0x82CFA3D0)
	// 82CFA3BC: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CFA3C0: 41990010  bgt cr6, 0x82cfa3d0
	if ctx.cr[6].gt {
		sub_82CFA3D0(ctx, base);
		return;
	}
	// 82CFA3C4: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 82CFA3C8: B1630034  sth r11, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u16 ) };
	// 82CFA3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CFA3D0 size=20
    let mut pc: u32 = 0x82CFA3D0;
    'dispatch: loop {
        match pc {
            0x82CFA3D0 => {
    //   block [0x82CFA3D0..0x82CFA3E4)
	// 82CFA3D0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82CFA3D4: 556AC63E  rlwinm r10, r11, 0x18, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CFA3D8: 516A442E  rlwimi r10, r11, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA3DC: B1430034  sth r10, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[10].u16 ) };
	// 82CFA3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFA3E8 size=608
    let mut pc: u32 = 0x82CFA3E8;
    'dispatch: loop {
        match pc {
            0x82CFA3E8 => {
    //   block [0x82CFA3E8..0x82CFA440)
	// 82CFA3E8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CFA3EC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFA3F0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA3F4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA3F8: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CFA3FC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFA400: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA404: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA408: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFA40C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA410: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFA414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA418: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA41C: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CFA420: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA424: 7D09F850  subf r8, r9, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 82CFA428: 7D240194  addze r9, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[9].s64 = tmp.s64;
	// 82CFA42C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFA430: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFA434: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82CFA438: 41980008  blt cr6, 0x82cfa440
	if ctx.cr[6].lt {
	pc = 0x82CFA440; continue 'dispatch;
	}
	// 82CFA43C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CFA440; continue 'dispatch;
            }
            0x82CFA440 => {
    //   block [0x82CFA440..0x82CFA484)
	// 82CFA440: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82CFA444: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA448: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA44C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFA450: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CFA454: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFA458: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CFA45C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CFA460: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFA464: 3889007F  addi r4, r9, 0x7f
	ctx.r[4].s64 = ctx.r[9].s64 + 127;
	// 82CFA468: C1A60C4C  lfs f13, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA46C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFA470: 5487C9FE  srwi r7, r4, 7
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFA474: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFA478: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CFA47C: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA480: 419A0018  beq cr6, 0x82cfa498
	if ctx.cr[6].eq {
	pc = 0x82CFA498; continue 'dispatch;
	}
	pc = 0x82CFA484; continue 'dispatch;
            }
            0x82CFA484 => {
    //   block [0x82CFA484..0x82CFA498)
	// 82CFA484: 55263830  slwi r6, r9, 7
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA488: 7C065A2C  dcbt r6, r11
	// 82CFA48C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFA490: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CFA494: 4198FFF0  blt cr6, 0x82cfa484
	if ctx.cr[6].lt {
	pc = 0x82CFA484; continue 'dispatch;
	}
	pc = 0x82CFA498; continue 'dispatch;
            }
            0x82CFA498 => {
    //   block [0x82CFA498..0x82CFA4A8)
	// 82CFA498: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CFA49C: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82CFA4A0: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82CFA4A4: C1A60C58  lfs f13, 0xc58(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFA4A8; continue 'dispatch;
            }
            0x82CFA4A8 => {
    //   block [0x82CFA4A8..0x82CFA4E4)
	// 82CFA4A8: A0C90000  lhz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA4AC: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFA4B0: 54C4C63E  rlwinm r4, r6, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CFA4B4: 50C4442E  rlwimi r4, r6, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA4B8: 7C840734  extsh r4, r4
	ctx.r[4].s64 = ctx.r[4].s16 as i64;
	// 82CFA4BC: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CFA4C0: C981FFE0  lfd f12, -0x20(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFA4C4: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CFA4C8: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA4CC: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA4D0: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA4D4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CFA4D8: 4082FFD0  bne 0x82cfa4a8
	if !ctx.cr[0].eq {
	pc = 0x82CFA4A8; continue 'dispatch;
	}
	// 82CFA4DC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFA4E0: C1890BFC  lfs f12, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFA4E4; continue 'dispatch;
            }
            0x82CFA4E4 => {
    //   block [0x82CFA4E4..0x82CFA5AC)
	// 82CFA4E4: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CFA4E8: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFA4EC: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA4F0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CFA4F4: 5527C63E  rlwinm r7, r9, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CFA4F8: 5127442E  rlwimi r7, r9, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA4FC: 7CE40734  extsh r4, r7
	ctx.r[4].s64 = ctx.r[7].s16 as i64;
	// 82CFA500: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CFA504: C8E1FFE0  lfd f7, -0x20(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFA508: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFA50C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFA510: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA514: D0850004  stfs f4, 4(r5)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA518: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CFA51C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFA520: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA524: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA528: D12A0400  stfs f9, 0x400(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CFA52C: D04A0404  stfs f2, 0x404(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CFA530: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA534: 5527C63E  rlwinm r7, r9, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CFA538: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFA53C: 5127442E  rlwimi r7, r9, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA540: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA544: 7CE40734  extsh r4, r7
	ctx.r[4].s64 = ctx.r[7].s16 as i64;
	// 82CFA548: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CFA54C: C8C1FFE8  lfd f6, -0x18(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CFA550: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CFA554: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CFA558: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA55C: D0650000  stfs f3, 0(r5)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA560: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CFA564: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CFA568: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA56C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA570: ED090332  fmuls f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA574: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA578: D02A0004  stfs f1, 4(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA57C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CFA580: 4082FF64  bne 0x82cfa4e4
	if !ctx.cr[0].eq {
	pc = 0x82CFA4E4; continue 'dispatch;
	}
	// 82CFA584: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA588: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA58C: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82CFA590: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA594: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CFA598: 0CC70000  twi 6, r7, 0
	// 82CFA59C: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CFA5A0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CFA5A4: 40980008  bge cr6, 0x82cfa5ac
	if !ctx.cr[6].lt {
	pc = 0x82CFA5AC; continue 'dispatch;
	}
	// 82CFA5A8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82CFA5AC; continue 'dispatch;
            }
            0x82CFA5AC => {
    //   block [0x82CFA5AC..0x82CFA5CC)
	// 82CFA5AC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA5B0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA5B4: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CFA5B8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CFA5BC: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA5C0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFA5C4: 40980008  bge cr6, 0x82cfa5cc
	if !ctx.cr[6].lt {
	pc = 0x82CFA5CC; continue 'dispatch;
	}
	// 82CFA5C8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CFA5CC; continue 'dispatch;
            }
            0x82CFA5CC => {
    //   block [0x82CFA5CC..0x82CFA5F0)
	// 82CFA5CC: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CFA5D0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFA5D4: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82CFA5D8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFA5DC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CFA5E0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82CFA5E4: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82CFA5E8: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA5EC: 6108FF7F  ori r8, r8, 0xff7f
	ctx.r[8].u64 = ctx.r[8].u64 | 65407;
	pc = 0x82CFA5F0; continue 'dispatch;
            }
            0x82CFA5F0 => {
    //   block [0x82CFA5F0..0x82CFA614)
	// 82CFA5F0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA5F4: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA5F8: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFA5FC: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CFA600: 8141FFEC  lwz r10, -0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CFA604: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 82CFA608: 4198000C  blt cr6, 0x82cfa614
	if ctx.cr[6].lt {
	pc = 0x82CFA614; continue 'dispatch;
	}
	// 82CFA60C: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CFA610: 48000024  b 0x82cfa634
	pc = 0x82CFA634; continue 'dispatch;
            }
            0x82CFA614 => {
    //   block [0x82CFA614..0x82CFA624)
	// 82CFA614: 2F0A8000  cmpwi cr6, r10, -0x8000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -32768, &mut ctx.xer);
	// 82CFA618: 4199000C  bgt cr6, 0x82cfa624
	if ctx.cr[6].gt {
	pc = 0x82CFA624; continue 'dispatch;
	}
	// 82CFA61C: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CFA620: 48000014  b 0x82cfa634
	pc = 0x82CFA634; continue 'dispatch;
            }
            0x82CFA624 => {
    //   block [0x82CFA624..0x82CFA634)
	// 82CFA624: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82CFA628: 5546C63E  rlwinm r6, r10, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CFA62C: 5146442E  rlwimi r6, r10, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA630: B0CB0000  sth r6, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	pc = 0x82CFA634; continue 'dispatch;
            }
            0x82CFA634 => {
    //   block [0x82CFA634..0x82CFA648)
	// 82CFA634: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFA638: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA63C: 4082FFB4  bne 0x82cfa5f0
	if !ctx.cr[0].eq {
	pc = 0x82CFA5F0; continue 'dispatch;
	}
	// 82CFA640: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CFA644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFA648 size=740
    let mut pc: u32 = 0x82CFA648;
    'dispatch: loop {
        match pc {
            0x82CFA648 => {
    //   block [0x82CFA648..0x82CFA6A0)
	// 82CFA648: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CFA64C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFA650: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA654: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA658: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 82CFA65C: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFA660: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFA664: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA668: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFA66C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA670: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFA674: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA678: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA67C: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CFA680: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CFA684: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA688: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CFA68C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFA690: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CFA694: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CFA698: 41980008  blt cr6, 0x82cfa6a0
	if ctx.cr[6].lt {
	pc = 0x82CFA6A0; continue 'dispatch;
	}
	// 82CFA69C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82CFA6A0; continue 'dispatch;
            }
            0x82CFA6A0 => {
    //   block [0x82CFA6A0..0x82CFA6E4)
	// 82CFA6A0: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFA6A4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA6A8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA6AC: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA6B0: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CFA6B4: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA6B8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CFA6BC: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFA6C0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFA6C4: 3888007F  addi r4, r8, 0x7f
	ctx.r[4].s64 = ctx.r[8].s64 + 127;
	// 82CFA6C8: C1A50C4C  lfs f13, 0xc4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA6CC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFA6D0: 5486C9FE  srwi r6, r4, 7
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA6D4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CFA6D8: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CFA6DC: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA6E0: 419A0018  beq cr6, 0x82cfa6f8
	if ctx.cr[6].eq {
	pc = 0x82CFA6F8; continue 'dispatch;
	}
	pc = 0x82CFA6E4; continue 'dispatch;
            }
            0x82CFA6E4 => {
    //   block [0x82CFA6E4..0x82CFA6F8)
	// 82CFA6E4: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFA6E8: 7C05522C  dcbt r5, r10
	// 82CFA6EC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CFA6F0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CFA6F4: 4198FFF0  blt cr6, 0x82cfa6e4
	if ctx.cr[6].lt {
	pc = 0x82CFA6E4; continue 'dispatch;
	}
	pc = 0x82CFA6F8; continue 'dispatch;
            }
            0x82CFA6F8 => {
    //   block [0x82CFA6F8..0x82CFA708)
	// 82CFA6F8: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFA6FC: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CFA700: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CFA704: C1A50C58  lfs f13, 0xc58(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFA708; continue 'dispatch;
            }
            0x82CFA708 => {
    //   block [0x82CFA708..0x82CFA744)
	// 82CFA708: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA70C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CFA710: 54A4C63E  rlwinm r4, r5, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82CFA714: 50A4442E  rlwimi r4, r5, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA718: 7C840734  extsh r4, r4
	ctx.r[4].s64 = ctx.r[4].s16 as i64;
	// 82CFA71C: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CFA720: C981FFD0  lfd f12, -0x30(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA724: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CFA728: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA72C: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA730: D0E80000  stfs f7, 0(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA734: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CFA738: 4082FFD0  bne 0x82cfa708
	if !ctx.cr[0].eq {
	pc = 0x82CFA708; continue 'dispatch;
	}
	// 82CFA73C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFA740: C1880BFC  lfs f12, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFA744; continue 'dispatch;
            }
            0x82CFA744 => {
    //   block [0x82CFA744..0x82CFA894)
	// 82CFA744: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CFA748: C129000C  lfs f9, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFA74C: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA750: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFA754: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFA758: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA75C: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA760: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CFA764: C8E1FFD0  lfd f7, -0x30(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA768: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFA76C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFA770: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA774: D089000C  stfs f4, 0xc(r9)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CFA778: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CFA77C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFA780: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA784: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA788: D12B0C00  stfs f9, 0xc00(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CFA78C: D04B0C04  stfs f2, 0xc04(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CFA790: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA794: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFA798: C0E90008  lfs f7, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFA79C: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA7A0: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA7A4: F881FFD8  std r4, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[4].u64 ) };
	// 82CFA7A8: C8C1FFD8  lfd f6, -0x28(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFA7AC: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CFA7B0: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CFA7B4: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA7B8: D0690008  stfs f3, 8(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CFA7BC: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CFA7C0: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CFA7C4: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA7C8: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA7CC: D0EB0800  stfs f7, 0x800(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CFA7D0: D02B0804  stfs f1, 0x804(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CFA7D4: A10A0002  lhz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CFA7D8: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFA7DC: C0C90004  lfs f6, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CFA7E0: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA7E4: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA7E8: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CFA7EC: C8A1FFE0  lfd f5, -0x20(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFA7F0: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CFA7F4: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CFA7F8: EC430372  fmuls f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA7FC: D0490004  stfs f2, 4(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA800: EC22302A  fadds f1, f2, f6
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CFA804: ED2800B2  fmuls f9, f8, f2
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CFA808: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA80C: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA810: D0CB0400  stfs f6, 0x400(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CFA814: D12B0404  stfs f9, 0x404(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CFA818: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA81C: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFA820: C0A90000  lfs f5, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CFA824: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA828: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CFA82C: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA830: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CFA834: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CFA838: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CFA83C: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CFA840: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA844: D0290000  stfs f1, 0(r9)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA848: ED21282A  fadds f9, f1, f5
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 82CFA84C: ED080072  fmuls f8, f8, f1
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CFA850: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA854: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA858: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA85C: D0CB0000  stfs f6, 0(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA860: D10B0004  stfs f8, 4(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA864: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CFA868: 4082FEDC  bne 0x82cfa744
	if !ctx.cr[0].eq {
	pc = 0x82CFA744; continue 'dispatch;
	}
	// 82CFA86C: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA870: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA874: 5506083E  rotlwi r6, r8, 1
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82CFA878: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA87C: 7CA75050  subf r5, r7, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 82CFA880: 0CC60000  twi 6, r6, 0
	// 82CFA884: 7D453396  divwu r10, r5, r6
	ctx.r[10].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CFA888: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFA88C: 40980008  bge cr6, 0x82cfa894
	if !ctx.cr[6].lt {
	pc = 0x82CFA894; continue 'dispatch;
	}
	// 82CFA890: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82CFA894; continue 'dispatch;
            }
            0x82CFA894 => {
    //   block [0x82CFA894..0x82CFA8B4)
	// 82CFA894: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA898: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA89C: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CFA8A0: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CFA8A4: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFA8A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFA8AC: 41980008  blt cr6, 0x82cfa8b4
	if ctx.cr[6].lt {
	pc = 0x82CFA8B4; continue 'dispatch;
	}
	// 82CFA8B0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82CFA8B4; continue 'dispatch;
            }
            0x82CFA8B4 => {
    //   block [0x82CFA8B4..0x82CFA8D4)
	// 82CFA8B4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFA8B8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CFA8BC: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82CFA8C0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFA8C4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CFA8C8: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82CFA8CC: 6108FF7F  ori r8, r8, 0xff7f
	ctx.r[8].u64 = ctx.r[8].u64 | 65407;
	// 82CFA8D0: C00B0F28  lfs f0, 0xf28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CFA8D4; continue 'dispatch;
            }
            0x82CFA8D4 => {
    //   block [0x82CFA8D4..0x82CFA8F8)
	// 82CFA8D4: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA8D8: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA8DC: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFA8E0: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CFA8E4: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CFA8E8: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CFA8EC: 4198000C  blt cr6, 0x82cfa8f8
	if ctx.cr[6].lt {
	pc = 0x82CFA8F8; continue 'dispatch;
	}
	// 82CFA8F0: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CFA8F4: 48000024  b 0x82cfa918
	pc = 0x82CFA918; continue 'dispatch;
            }
            0x82CFA8F8 => {
    //   block [0x82CFA8F8..0x82CFA908)
	// 82CFA8F8: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CFA8FC: 4199000C  bgt cr6, 0x82cfa908
	if ctx.cr[6].gt {
	pc = 0x82CFA908; continue 'dispatch;
	}
	// 82CFA900: B0E90000  sth r7, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CFA904: 48000014  b 0x82cfa918
	pc = 0x82CFA918; continue 'dispatch;
            }
            0x82CFA908 => {
    //   block [0x82CFA908..0x82CFA918)
	// 82CFA908: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82CFA90C: 5566C63E  rlwinm r6, r11, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CFA910: 5166442E  rlwimi r6, r11, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA914: B0C90000  sth r6, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	pc = 0x82CFA918; continue 'dispatch;
            }
            0x82CFA918 => {
    //   block [0x82CFA918..0x82CFA92C)
	// 82CFA918: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CFA91C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CFA920: 4082FFB4  bne 0x82cfa8d4
	if !ctx.cr[0].eq {
	pc = 0x82CFA8D4; continue 'dispatch;
	}
	// 82CFA924: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CFA928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFA930 size=884
    let mut pc: u32 = 0x82CFA930;
    'dispatch: loop {
        match pc {
            0x82CFA930 => {
    //   block [0x82CFA930..0x82CFA988)
	// 82CFA930: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CFA934: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFA938: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA93C: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA940: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82CFA944: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFA948: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFA94C: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA950: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CFA954: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA958: 7D2741D6  mullw r9, r7, r8
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFA95C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA960: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA964: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CFA968: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CFA96C: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFA970: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CFA974: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CFA978: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CFA97C: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CFA980: 41980008  blt cr6, 0x82cfa988
	if ctx.cr[6].lt {
	pc = 0x82CFA988; continue 'dispatch;
	}
	// 82CFA984: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82CFA988; continue 'dispatch;
            }
            0x82CFA988 => {
    //   block [0x82CFA988..0x82CFA9D4)
	// 82CFA988: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFA98C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA990: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA994: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA998: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CFA99C: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CFA9A0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CFA9A4: 7CA74214  add r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CFA9A8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFA9AC: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA9B0: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CFA9B4: 38C8007F  addi r6, r8, 0x7f
	ctx.r[6].s64 = ctx.r[8].s64 + 127;
	// 82CFA9B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFA9BC: 54C6C9FE  srwi r6, r6, 7
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA9C0: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA9C4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CFA9C8: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CFA9CC: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA9D0: 419A0018  beq cr6, 0x82cfa9e8
	if ctx.cr[6].eq {
	pc = 0x82CFA9E8; continue 'dispatch;
	}
	pc = 0x82CFA9D4; continue 'dispatch;
            }
            0x82CFA9D4 => {
    //   block [0x82CFA9D4..0x82CFA9E8)
	// 82CFA9D4: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFA9D8: 7C054A2C  dcbt r5, r9
	// 82CFA9DC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CFA9E0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CFA9E4: 4198FFF0  blt cr6, 0x82cfa9d4
	if ctx.cr[6].lt {
	pc = 0x82CFA9D4; continue 'dispatch;
	}
	pc = 0x82CFA9E8; continue 'dispatch;
            }
            0x82CFA9E8 => {
    //   block [0x82CFA9E8..0x82CFA9F8)
	// 82CFA9E8: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFA9EC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CFA9F0: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82CFA9F4: C1A50C58  lfs f13, 0xc58(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFA9F8; continue 'dispatch;
            }
            0x82CFA9F8 => {
    //   block [0x82CFA9F8..0x82CFAA34)
	// 82CFA9F8: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA9FC: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CFAA00: 54A4C63E  rlwinm r4, r5, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82CFAA04: 50A4442E  rlwimi r4, r5, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAA08: 7C840734  extsh r4, r4
	ctx.r[4].s64 = ctx.r[4].s16 as i64;
	// 82CFAA0C: F881FFC0  std r4, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[4].u64 ) };
	// 82CFAA10: C981FFC0  lfd f12, -0x40(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CFAA14: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CFAA18: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAA1C: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAA20: D0E80000  stfs f7, 0(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFAA24: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CFAA28: 4082FFD0  bne 0x82cfa9f8
	if !ctx.cr[0].eq {
	pc = 0x82CFA9F8; continue 'dispatch;
	}
	// 82CFAA2C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFAA30: C1880BFC  lfs f12, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFAA34; continue 'dispatch;
            }
            0x82CFAA34 => {
    //   block [0x82CFAA34..0x82CFAC0C)
	// 82CFAA34: A109000A  lhz r8, 0xa(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(10 as u32) ) } as u64;
	// 82CFAA38: C12A0014  lfs f9, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFAA3C: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFAA40: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFAA44: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAA48: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAA4C: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAA50: F881FFC0  std r4, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[4].u64 ) };
	// 82CFAA54: C8E1FFC0  lfd f7, -0x40(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CFAA58: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFAA5C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFAA60: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAA64: D08A0014  stfs f4, 0x14(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82CFAA68: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CFAA6C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFAA70: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAA74: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAA78: D12B1400  stfs f9, 0x1400(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CFAA7C: D04B1404  stfs f2, 0x1404(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5124 as u32), tmp.u32 ) };
	// 82CFAA80: A1090008  lhz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFAA84: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAA88: C0EA0010  lfs f7, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFAA8C: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAA90: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAA94: F881FFC8  std r4, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[4].u64 ) };
	// 82CFAA98: C8C1FFC8  lfd f6, -0x38(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CFAA9C: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CFAAA0: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CFAAA4: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAAA8: D06A0010  stfs f3, 0x10(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82CFAAAC: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CFAAB0: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CFAAB4: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAAB8: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAABC: D0EB1000  stfs f7, 0x1000(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CFAAC0: D02B1004  stfs f1, 0x1004(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), tmp.u32 ) };
	// 82CFAAC4: A1090006  lhz r8, 6(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CFAAC8: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAACC: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CFAAD0: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAAD4: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAAD8: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CFAADC: C8A1FFD0  lfd f5, -0x30(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFAAE0: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CFAAE4: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CFAAE8: EC430372  fmuls f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAAEC: D04A000C  stfs f2, 0xc(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CFAAF0: EC22302A  fadds f1, f2, f6
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CFAAF4: ED2800B2  fmuls f9, f8, f2
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CFAAF8: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAAFC: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAB00: D0CB0C00  stfs f6, 0xc00(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CFAB04: D12B0C04  stfs f9, 0xc04(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CFAB08: A1090004  lhz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFAB0C: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAB10: C0AA0008  lfs f5, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CFAB14: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAB18: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAB1C: F881FFD8  std r4, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[4].u64 ) };
	// 82CFAB20: C881FFD8  lfd f4, -0x28(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFAB24: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CFAB28: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CFAB2C: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAB30: D02A0008  stfs f1, 8(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CFAB34: ED21282A  fadds f9, f1, f5
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 82CFAB38: ECE80072  fmuls f7, f8, f1
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CFAB3C: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAB40: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAB44: D0AB0800  stfs f5, 0x800(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CFAB48: D0EB0804  stfs f7, 0x804(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CFAB4C: A1090002  lhz r8, 2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CFAB50: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAB54: C08A0004  lfs f4, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CFAB58: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAB5C: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAB60: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CFAB64: C861FFE0  lfd f3, -0x20(r1)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFAB68: FC401E9C  fcfid f2, f3
	ctx.f[2].f64 = (ctx.f[3].s64 as f64);
	// 82CFAB6C: FC201018  frsp f1, f2
	ctx.f[1].f64 = (ctx.f[2].f64 as f32) as f64;
	// 82CFAB70: ED210372  fmuls f9, f1, f13
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAB74: D12A0004  stfs f9, 4(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFAB78: ECE9202A  fadds f7, f9, f4
	ctx.f[7].f64 = ((ctx.f[9].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CFAB7C: ECC80272  fmuls f6, f8, f9
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 82CFAB80: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAB84: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAB88: D08B0400  stfs f4, 0x400(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CFAB8C: D0CB0404  stfs f6, 0x404(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CFAB90: C06A0000  lfs f3, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CFAB94: A1090000  lhz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFAB98: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAB9C: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFABA0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82CFABA4: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFABA8: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CFABAC: C841FFE8  lfd f2, -0x18(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CFABB0: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CFABB4: FD200818  frsp f9, f1
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFABB8: ECE90372  fmuls f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFABBC: D0EA0000  stfs f7, 0(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFABC0: ECC7182A  fadds f6, f7, f3
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[3].f64) as f32) as f64;
	// 82CFABC4: ECA801F2  fmuls f5, f8, f7
	ctx.f[5].f64 = (((ctx.f[8].f64 * ctx.f[7].f64) as f32) as f64);
	// 82CFABC8: EC860032  fmuls f4, f6, f0
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFABCC: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFABD0: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFABD4: D06B0000  stfs f3, 0(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFABD8: D0AB0004  stfs f5, 4(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFABDC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CFABE0: 4082FE54  bne 0x82cfaa34
	if !ctx.cr[0].eq {
	pc = 0x82CFAA34; continue 'dispatch;
	}
	// 82CFABE4: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFABE8: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFABEC: 5506083E  rotlwi r6, r8, 1
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82CFABF0: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFABF4: 7CA74850  subf r5, r7, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82CFABF8: 0CC60000  twi 6, r6, 0
	// 82CFABFC: 7D253396  divwu r9, r5, r6
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CFAC00: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFAC04: 40980008  bge cr6, 0x82cfac0c
	if !ctx.cr[6].lt {
	pc = 0x82CFAC0C; continue 'dispatch;
	}
	// 82CFAC08: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CFAC0C; continue 'dispatch;
            }
            0x82CFAC0C => {
    //   block [0x82CFAC0C..0x82CFAC2C)
	// 82CFAC0C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFAC10: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFAC14: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CFAC18: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CFAC1C: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFAC20: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CFAC24: 41980008  blt cr6, 0x82cfac2c
	if ctx.cr[6].lt {
	pc = 0x82CFAC2C; continue 'dispatch;
	}
	// 82CFAC28: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82CFAC2C; continue 'dispatch;
            }
            0x82CFAC2C => {
    //   block [0x82CFAC2C..0x82CFAC4C)
	// 82CFAC2C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFAC30: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CFAC34: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82CFAC38: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFAC3C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CFAC40: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82CFAC44: 6108FF7F  ori r8, r8, 0xff7f
	ctx.r[8].u64 = ctx.r[8].u64 | 65407;
	// 82CFAC48: C00B0F28  lfs f0, 0xf28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CFAC4C; continue 'dispatch;
            }
            0x82CFAC4C => {
    //   block [0x82CFAC4C..0x82CFAC70)
	// 82CFAC4C: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFAC50: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAC54: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFAC58: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CFAC5C: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CFAC60: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CFAC64: 4198000C  blt cr6, 0x82cfac70
	if ctx.cr[6].lt {
	pc = 0x82CFAC70; continue 'dispatch;
	}
	// 82CFAC68: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CFAC6C: 48000024  b 0x82cfac90
	pc = 0x82CFAC90; continue 'dispatch;
            }
            0x82CFAC70 => {
    //   block [0x82CFAC70..0x82CFAC80)
	// 82CFAC70: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CFAC74: 4199000C  bgt cr6, 0x82cfac80
	if ctx.cr[6].gt {
	pc = 0x82CFAC80; continue 'dispatch;
	}
	// 82CFAC78: B0EA0000  sth r7, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CFAC7C: 48000014  b 0x82cfac90
	pc = 0x82CFAC90; continue 'dispatch;
            }
            0x82CFAC80 => {
    //   block [0x82CFAC80..0x82CFAC90)
	// 82CFAC80: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82CFAC84: 5566C63E  rlwinm r6, r11, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CFAC88: 5166442E  rlwimi r6, r11, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAC8C: B0CA0000  sth r6, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	pc = 0x82CFAC90; continue 'dispatch;
            }
            0x82CFAC90 => {
    //   block [0x82CFAC90..0x82CFACA4)
	// 82CFAC90: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFAC94: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CFAC98: 4082FFB4  bne 0x82cfac4c
	if !ctx.cr[0].eq {
	pc = 0x82CFAC4C; continue 'dispatch;
	}
	// 82CFAC9C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CFACA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFACA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFACA8 size=216
    let mut pc: u32 = 0x82CFACA8;
    'dispatch: loop {
        match pc {
            0x82CFACA8 => {
    //   block [0x82CFACA8..0x82CFAD68)
	// 82CFACA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFACAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFACB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFACB4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFACB8: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFACBC: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFACC0: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFACC4: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFACC8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFACCC: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFACD0: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFACD4: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFACD8: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFACDC: 54CA07BE  clrlwi r10, r6, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 82CFACE0: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFACE4: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFACE8: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFACEC: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFACF0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFACF4: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFACF8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFACFC: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFAD00: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFAD04: 409A0064  bne cr6, 0x82cfad68
	if !ctx.cr[6].eq {
	pc = 0x82CFAD68; continue 'dispatch;
	}
	// 82CFAD08: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFAD0C: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAD10: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFAD14: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFAD18: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFAD1C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAD20: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFAD24: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAD28: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFAD2C: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFAD30: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFAD34: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAD38: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFAD3C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFAD40: 40990028  ble cr6, 0x82cfad68
	if !ctx.cr[6].gt {
	pc = 0x82CFAD68; continue 'dispatch;
	}
	// 82CFAD44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFAD48: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAD4C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFAD50: 41980018  blt cr6, 0x82cfad68
	if ctx.cr[6].lt {
	pc = 0x82CFAD68; continue 'dispatch;
	}
	// 82CFAD54: 4BFF33CD  bl 0x82cee120
	ctx.lr = 0x82CFAD58;
	sub_82CEE120(ctx, base);
	// 82CFAD58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAD5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAD60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAD64: 4E800020  blr
	return;
            }
            0x82CFAD68 => {
    //   block [0x82CFAD68..0x82CFAD80)
	// 82CFAD68: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFAD6C: 4BFF6435  bl 0x82cf11a0
	ctx.lr = 0x82CFAD70;
	sub_82CF11A0(ctx, base);
	// 82CFAD70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAD74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAD78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAD7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFAD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFAD80 size=216
    let mut pc: u32 = 0x82CFAD80;
    'dispatch: loop {
        match pc {
            0x82CFAD80 => {
    //   block [0x82CFAD80..0x82CFAE40)
	// 82CFAD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFAD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFAD88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFAD8C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFAD90: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFAD94: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFAD98: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFAD9C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFADA0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFADA4: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFADA8: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFADAC: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFADB0: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFADB4: 54CA07BE  clrlwi r10, r6, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 82CFADB8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFADBC: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFADC0: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFADC4: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFADC8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFADCC: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFADD0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFADD4: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFADD8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFADDC: 409A0064  bne cr6, 0x82cfae40
	if !ctx.cr[6].eq {
	pc = 0x82CFAE40; continue 'dispatch;
	}
	// 82CFADE0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFADE4: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFADE8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFADEC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFADF0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFADF4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFADF8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFADFC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAE00: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFAE04: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFAE08: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFAE0C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAE10: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFAE14: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFAE18: 40990028  ble cr6, 0x82cfae40
	if !ctx.cr[6].gt {
	pc = 0x82CFAE40; continue 'dispatch;
	}
	// 82CFAE1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFAE20: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAE24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFAE28: 41980018  blt cr6, 0x82cfae40
	if ctx.cr[6].lt {
	pc = 0x82CFAE40; continue 'dispatch;
	}
	// 82CFAE2C: 4BFF34F5  bl 0x82cee320
	ctx.lr = 0x82CFAE30;
	sub_82CEE320(ctx, base);
	// 82CFAE30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAE34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAE38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAE3C: 4E800020  blr
	return;
            }
            0x82CFAE40 => {
    //   block [0x82CFAE40..0x82CFAE58)
	// 82CFAE40: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFAE44: 4BFF663D  bl 0x82cf1480
	ctx.lr = 0x82CFAE48;
	sub_82CF1480(ctx, base);
	// 82CFAE48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAE4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAE50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAE54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFAE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFAE58 size=216
    let mut pc: u32 = 0x82CFAE58;
    'dispatch: loop {
        match pc {
            0x82CFAE58 => {
    //   block [0x82CFAE58..0x82CFAF18)
	// 82CFAE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFAE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFAE60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFAE64: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFAE68: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFAE6C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFAE70: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFAE74: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFAE78: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFAE7C: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFAE80: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFAE84: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFAE88: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFAE8C: 54CA07BE  clrlwi r10, r6, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 82CFAE90: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFAE94: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFAE98: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFAE9C: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFAEA0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFAEA4: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFAEA8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFAEAC: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFAEB0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFAEB4: 409A0064  bne cr6, 0x82cfaf18
	if !ctx.cr[6].eq {
	pc = 0x82CFAF18; continue 'dispatch;
	}
	// 82CFAEB8: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFAEBC: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAEC0: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFAEC4: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFAEC8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFAECC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAED0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFAED4: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAED8: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFAEDC: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFAEE0: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFAEE4: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAEE8: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFAEEC: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFAEF0: 40990028  ble cr6, 0x82cfaf18
	if !ctx.cr[6].gt {
	pc = 0x82CFAF18; continue 'dispatch;
	}
	// 82CFAEF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFAEF8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAEFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFAF00: 41980018  blt cr6, 0x82cfaf18
	if ctx.cr[6].lt {
	pc = 0x82CFAF18; continue 'dispatch;
	}
	// 82CFAF04: 4BFF364D  bl 0x82cee550
	ctx.lr = 0x82CFAF08;
	sub_82CEE550(ctx, base);
	// 82CFAF08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAF0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAF10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAF14: 4E800020  blr
	return;
            }
            0x82CFAF18 => {
    //   block [0x82CFAF18..0x82CFAF30)
	// 82CFAF18: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFAF1C: 4BFF688D  bl 0x82cf17a8
	ctx.lr = 0x82CFAF20;
	sub_82CF17A8(ctx, base);
	// 82CFAF20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAF24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAF28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAF2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFAF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFAF30 size=216
    let mut pc: u32 = 0x82CFAF30;
    'dispatch: loop {
        match pc {
            0x82CFAF30 => {
    //   block [0x82CFAF30..0x82CFAFF0)
	// 82CFAF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFAF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFAF38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFAF3C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFAF40: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFAF44: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFAF48: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFAF4C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFAF50: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFAF54: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFAF58: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFAF5C: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFAF60: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFAF64: 54CA07BE  clrlwi r10, r6, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 82CFAF68: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFAF6C: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFAF70: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFAF74: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFAF78: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFAF7C: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFAF80: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFAF84: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFAF88: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFAF8C: 409A0064  bne cr6, 0x82cfaff0
	if !ctx.cr[6].eq {
	pc = 0x82CFAFF0; continue 'dispatch;
	}
	// 82CFAF90: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFAF94: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAF98: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFAF9C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFAFA0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFAFA4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAFA8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFAFAC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAFB0: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFAFB4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFAFB8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFAFBC: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAFC0: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFAFC4: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFAFC8: 40990028  ble cr6, 0x82cfaff0
	if !ctx.cr[6].gt {
	pc = 0x82CFAFF0; continue 'dispatch;
	}
	// 82CFAFCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFAFD0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAFD4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFAFD8: 41980018  blt cr6, 0x82cfaff0
	if ctx.cr[6].lt {
	pc = 0x82CFAFF0; continue 'dispatch;
	}
	// 82CFAFDC: 4BFF380D  bl 0x82cee7e8
	ctx.lr = 0x82CFAFE0;
	sub_82CEE7E8(ctx, base);
	// 82CFAFE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAFE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAFE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAFEC: 4E800020  blr
	return;
            }
            0x82CFAFF0 => {
    //   block [0x82CFAFF0..0x82CFB008)
	// 82CFAFF0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFAFF4: 4BFF6BAD  bl 0x82cf1ba0
	ctx.lr = 0x82CFAFF8;
	sub_82CF1BA0(ctx, base);
	// 82CFAFF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAFFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB008 size=216
    let mut pc: u32 = 0x82CFB008;
    'dispatch: loop {
        match pc {
            0x82CFB008 => {
    //   block [0x82CFB008..0x82CFB0C8)
	// 82CFB008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB00C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB014: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB018: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB01C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB020: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB024: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB028: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB02C: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB030: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB034: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB038: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB03C: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB040: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB044: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFB048: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB04C: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB050: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB054: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB058: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB05C: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB060: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB064: 409A0064  bne cr6, 0x82cfb0c8
	if !ctx.cr[6].eq {
	pc = 0x82CFB0C8; continue 'dispatch;
	}
	// 82CFB068: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB06C: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB070: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB074: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB078: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB07C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB080: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB084: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB088: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB08C: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB090: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB094: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB098: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB09C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB0A0: 40990028  ble cr6, 0x82cfb0c8
	if !ctx.cr[6].gt {
	pc = 0x82CFB0C8; continue 'dispatch;
	}
	// 82CFB0A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB0A8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB0AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB0B0: 41980018  blt cr6, 0x82cfb0c8
	if ctx.cr[6].lt {
	pc = 0x82CFB0C8; continue 'dispatch;
	}
	// 82CFB0B4: 4BFF2135  bl 0x82ced1e8
	ctx.lr = 0x82CFB0B8;
	sub_82CED1E8(ctx, base);
	// 82CFB0B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB0BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB0C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB0C4: 4E800020  blr
	return;
            }
            0x82CFB0C8 => {
    //   block [0x82CFB0C8..0x82CFB0E0)
	// 82CFB0C8: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB0CC: 4BFF737D  bl 0x82cf2448
	ctx.lr = 0x82CFB0D0;
	sub_82CF2448(ctx, base);
	// 82CFB0D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB0D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB0D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB0DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB0E0 size=216
    let mut pc: u32 = 0x82CFB0E0;
    'dispatch: loop {
        match pc {
            0x82CFB0E0 => {
    //   block [0x82CFB0E0..0x82CFB1A0)
	// 82CFB0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB0E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB0E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB0EC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB0F0: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB0F4: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB0F8: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB0FC: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB100: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB104: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB108: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB10C: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB110: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB114: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB118: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB11C: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFB120: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB124: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB128: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB12C: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB130: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB134: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB138: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB13C: 409A0064  bne cr6, 0x82cfb1a0
	if !ctx.cr[6].eq {
	pc = 0x82CFB1A0; continue 'dispatch;
	}
	// 82CFB140: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB144: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB148: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB14C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB150: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB154: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB158: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB15C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB160: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB164: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB168: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB16C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB170: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB174: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB178: 40990028  ble cr6, 0x82cfb1a0
	if !ctx.cr[6].gt {
	pc = 0x82CFB1A0; continue 'dispatch;
	}
	// 82CFB17C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB180: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB184: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB188: 41980018  blt cr6, 0x82cfb1a0
	if ctx.cr[6].lt {
	pc = 0x82CFB1A0; continue 'dispatch;
	}
	// 82CFB18C: 4BFF22C5  bl 0x82ced450
	ctx.lr = 0x82CFB190;
	sub_82CED450(ctx, base);
	// 82CFB190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB19C: 4E800020  blr
	return;
            }
            0x82CFB1A0 => {
    //   block [0x82CFB1A0..0x82CFB1B8)
	// 82CFB1A0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB1A4: 4BFF75BD  bl 0x82cf2760
	ctx.lr = 0x82CFB1A8;
	sub_82CF2760(ctx, base);
	// 82CFB1A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB1AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB1B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB1B8 size=216
    let mut pc: u32 = 0x82CFB1B8;
    'dispatch: loop {
        match pc {
            0x82CFB1B8 => {
    //   block [0x82CFB1B8..0x82CFB278)
	// 82CFB1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB1BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB1C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB1C4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB1C8: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB1CC: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB1D0: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB1D4: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB1D8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB1DC: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB1E0: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB1E4: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB1E8: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB1EC: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB1F0: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB1F4: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFB1F8: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB1FC: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB200: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB204: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB208: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB20C: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB210: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB214: 409A0064  bne cr6, 0x82cfb278
	if !ctx.cr[6].eq {
	pc = 0x82CFB278; continue 'dispatch;
	}
	// 82CFB218: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB21C: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB220: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB224: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB228: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB22C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB230: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB234: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB238: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB23C: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB240: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB244: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB248: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB24C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB250: 40990028  ble cr6, 0x82cfb278
	if !ctx.cr[6].gt {
	pc = 0x82CFB278; continue 'dispatch;
	}
	// 82CFB254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB258: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB25C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB260: 41980018  blt cr6, 0x82cfb278
	if ctx.cr[6].lt {
	pc = 0x82CFB278; continue 'dispatch;
	}
	// 82CFB264: 4BFF24BD  bl 0x82ced720
	ctx.lr = 0x82CFB268;
	sub_82CED720(ctx, base);
	// 82CFB268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB274: 4E800020  blr
	return;
            }
            0x82CFB278 => {
    //   block [0x82CFB278..0x82CFB290)
	// 82CFB278: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB27C: 4BFF787D  bl 0x82cf2af8
	ctx.lr = 0x82CFB280;
	sub_82CF2AF8(ctx, base);
	// 82CFB280: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB28C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB290 size=216
    let mut pc: u32 = 0x82CFB290;
    'dispatch: loop {
        match pc {
            0x82CFB290 => {
    //   block [0x82CFB290..0x82CFB350)
	// 82CFB290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB298: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB29C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB2A0: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB2A4: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB2A8: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB2AC: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB2B0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB2B4: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB2B8: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB2BC: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB2C0: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB2C4: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB2C8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB2CC: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFB2D0: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB2D4: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB2D8: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB2DC: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB2E0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB2E4: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB2E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB2EC: 409A0064  bne cr6, 0x82cfb350
	if !ctx.cr[6].eq {
	pc = 0x82CFB350; continue 'dispatch;
	}
	// 82CFB2F0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB2F4: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB2F8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB2FC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB300: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB304: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB308: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB30C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB310: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB314: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB318: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB31C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB320: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB324: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB328: 40990028  ble cr6, 0x82cfb350
	if !ctx.cr[6].gt {
	pc = 0x82CFB350; continue 'dispatch;
	}
	// 82CFB32C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB330: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB334: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB338: 41980018  blt cr6, 0x82cfb350
	if ctx.cr[6].lt {
	pc = 0x82CFB350; continue 'dispatch;
	}
	// 82CFB33C: 4BFF2785  bl 0x82cedac0
	ctx.lr = 0x82CFB340;
	sub_82CEDAC0(ctx, base);
	// 82CFB340: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB34C: 4E800020  blr
	return;
            }
            0x82CFB350 => {
    //   block [0x82CFB350..0x82CFB368)
	// 82CFB350: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB354: 4BFF7C6D  bl 0x82cf2fc0
	ctx.lr = 0x82CFB358;
	sub_82CF2FC0(ctx, base);
	// 82CFB358: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB35C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB368 size=208
    let mut pc: u32 = 0x82CFB368;
    'dispatch: loop {
        match pc {
            0x82CFB368 => {
    //   block [0x82CFB368..0x82CFB420)
	// 82CFB368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB370: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB374: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB378: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB37C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB380: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB384: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB388: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB38C: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB390: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB394: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB398: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB39C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB3A0: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFB3A4: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB3A8: 7CC82B78  or r8, r6, r5
	ctx.r[8].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82CFB3AC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB3B0: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFB3B4: 7C844850  subf r4, r4, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CFB3B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFB3BC: 409A0064  bne cr6, 0x82cfb420
	if !ctx.cr[6].eq {
	pc = 0x82CFB420; continue 'dispatch;
	}
	// 82CFB3C0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB3C4: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB3C8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB3CC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB3D0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB3D4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB3D8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB3DC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB3E0: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB3E4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB3E8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB3EC: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB3F0: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB3F4: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB3F8: 40990028  ble cr6, 0x82cfb420
	if !ctx.cr[6].gt {
	pc = 0x82CFB420; continue 'dispatch;
	}
	// 82CFB3FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB400: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB404: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB408: 41980018  blt cr6, 0x82cfb420
	if ctx.cr[6].lt {
	pc = 0x82CFB420; continue 'dispatch;
	}
	// 82CFB40C: 4BFF36ED  bl 0x82ceeaf8
	ctx.lr = 0x82CFB410;
	sub_82CEEAF8(ctx, base);
	// 82CFB410: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB41C: 4E800020  blr
	return;
            }
            0x82CFB420 => {
    //   block [0x82CFB420..0x82CFB438)
	// 82CFB420: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB424: 4BFF856D  bl 0x82cf3990
	ctx.lr = 0x82CFB428;
	sub_82CF3990(ctx, base);
	// 82CFB428: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB42C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB430: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB438 size=208
    let mut pc: u32 = 0x82CFB438;
    'dispatch: loop {
        match pc {
            0x82CFB438 => {
    //   block [0x82CFB438..0x82CFB4F0)
	// 82CFB438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB440: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB444: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB448: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB44C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB450: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB454: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB458: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB45C: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB460: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB464: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB468: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB46C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB470: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFB474: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB478: 7CC82B78  or r8, r6, r5
	ctx.r[8].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82CFB47C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB480: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFB484: 7C844850  subf r4, r4, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CFB488: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFB48C: 409A0064  bne cr6, 0x82cfb4f0
	if !ctx.cr[6].eq {
	pc = 0x82CFB4F0; continue 'dispatch;
	}
	// 82CFB490: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB494: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB498: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB49C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB4A0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB4A4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB4A8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB4AC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB4B0: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB4B4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB4B8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB4BC: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB4C0: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB4C4: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB4C8: 40990028  ble cr6, 0x82cfb4f0
	if !ctx.cr[6].gt {
	pc = 0x82CFB4F0; continue 'dispatch;
	}
	// 82CFB4CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB4D0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB4D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB4D8: 41980018  blt cr6, 0x82cfb4f0
	if ctx.cr[6].lt {
	pc = 0x82CFB4F0; continue 'dispatch;
	}
	// 82CFB4DC: 4BFF3935  bl 0x82ceee10
	ctx.lr = 0x82CFB4E0;
	sub_82CEEE10(ctx, base);
	// 82CFB4E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB4E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB4E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB4EC: 4E800020  blr
	return;
            }
            0x82CFB4F0 => {
    //   block [0x82CFB4F0..0x82CFB508)
	// 82CFB4F0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB4F4: 4BFF87D5  bl 0x82cf3cc8
	ctx.lr = 0x82CFB4F8;
	sub_82CF3CC8(ctx, base);
	// 82CFB4F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB4FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB508 size=208
    let mut pc: u32 = 0x82CFB508;
    'dispatch: loop {
        match pc {
            0x82CFB508 => {
    //   block [0x82CFB508..0x82CFB5C0)
	// 82CFB508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB510: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB514: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB518: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB51C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB520: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB524: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB528: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB52C: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB530: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB534: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB538: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB53C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB540: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFB544: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB548: 7CC82B78  or r8, r6, r5
	ctx.r[8].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82CFB54C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB550: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFB554: 7C844850  subf r4, r4, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CFB558: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFB55C: 409A0064  bne cr6, 0x82cfb5c0
	if !ctx.cr[6].eq {
	pc = 0x82CFB5C0; continue 'dispatch;
	}
	// 82CFB560: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB564: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB568: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB56C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB570: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB574: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB578: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB57C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB580: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB584: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB588: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB58C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB590: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB594: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB598: 40990028  ble cr6, 0x82cfb5c0
	if !ctx.cr[6].gt {
	pc = 0x82CFB5C0; continue 'dispatch;
	}
	// 82CFB59C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB5A0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB5A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB5A8: 41980018  blt cr6, 0x82cfb5c0
	if ctx.cr[6].lt {
	pc = 0x82CFB5C0; continue 'dispatch;
	}
	// 82CFB5AC: 4BFF3C55  bl 0x82cef200
	ctx.lr = 0x82CFB5B0;
	sub_82CEF200(ctx, base);
	// 82CFB5B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB5B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB5B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB5BC: 4E800020  blr
	return;
            }
            0x82CFB5C0 => {
    //   block [0x82CFB5C0..0x82CFB5D8)
	// 82CFB5C0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB5C4: 4BFF8ADD  bl 0x82cf40a0
	ctx.lr = 0x82CFB5C8;
	sub_82CF40A0(ctx, base);
	// 82CFB5C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB5CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB5D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB5D8 size=208
    let mut pc: u32 = 0x82CFB5D8;
    'dispatch: loop {
        match pc {
            0x82CFB5D8 => {
    //   block [0x82CFB5D8..0x82CFB690)
	// 82CFB5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB5E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB5E4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB5E8: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB5EC: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB5F0: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB5F4: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB5F8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB5FC: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB600: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB604: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB608: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB60C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB610: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFB614: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB618: 7CC82B78  or r8, r6, r5
	ctx.r[8].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82CFB61C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB620: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFB624: 7C844850  subf r4, r4, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CFB628: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFB62C: 409A0064  bne cr6, 0x82cfb690
	if !ctx.cr[6].eq {
	pc = 0x82CFB690; continue 'dispatch;
	}
	// 82CFB630: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB634: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB638: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB63C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB640: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB644: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB648: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB64C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB650: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB654: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB658: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB65C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB660: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB664: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB668: 40990028  ble cr6, 0x82cfb690
	if !ctx.cr[6].gt {
	pc = 0x82CFB690; continue 'dispatch;
	}
	// 82CFB66C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB670: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB674: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB678: 41980018  blt cr6, 0x82cfb690
	if ctx.cr[6].lt {
	pc = 0x82CFB690; continue 'dispatch;
	}
	// 82CFB67C: 4BFF4175  bl 0x82cef7f0
	ctx.lr = 0x82CFB680;
	sub_82CEF7F0(ctx, base);
	// 82CFB680: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB68C: 4E800020  blr
	return;
            }
            0x82CFB690 => {
    //   block [0x82CFB690..0x82CFB6A8)
	// 82CFB690: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB694: 4BFF8F2D  bl 0x82cf45c0
	ctx.lr = 0x82CFB698;
	sub_82CF45C0(ctx, base);
	// 82CFB698: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB69C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB6A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB6A8 size=216
    let mut pc: u32 = 0x82CFB6A8;
    'dispatch: loop {
        match pc {
            0x82CFB6A8 => {
    //   block [0x82CFB6A8..0x82CFB768)
	// 82CFB6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB6B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB6B4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB6B8: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB6BC: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB6C0: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB6C4: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB6C8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB6CC: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB6D0: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB6D4: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB6D8: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB6DC: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB6E0: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB6E4: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFB6E8: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB6EC: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB6F0: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB6F4: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB6F8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB6FC: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB700: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB704: 409A0064  bne cr6, 0x82cfb768
	if !ctx.cr[6].eq {
	pc = 0x82CFB768; continue 'dispatch;
	}
	// 82CFB708: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB70C: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB710: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB714: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB718: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB71C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB720: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB724: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB728: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB72C: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB730: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB734: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB738: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB73C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB740: 40990028  ble cr6, 0x82cfb768
	if !ctx.cr[6].gt {
	pc = 0x82CFB768; continue 'dispatch;
	}
	// 82CFB744: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB748: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB74C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB750: 41980018  blt cr6, 0x82cfb768
	if ctx.cr[6].lt {
	pc = 0x82CFB768; continue 'dispatch;
	}
	// 82CFB754: 4BFF48ED  bl 0x82cf0040
	ctx.lr = 0x82CFB758;
	sub_82CF0040(ctx, base);
	// 82CFB758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB75C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB764: 4E800020  blr
	return;
            }
            0x82CFB768 => {
    //   block [0x82CFB768..0x82CFB780)
	// 82CFB768: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB76C: 4BFF98AD  bl 0x82cf5018
	ctx.lr = 0x82CFB770;
	sub_82CF5018(ctx, base);
	// 82CFB770: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB77C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB780 size=216
    let mut pc: u32 = 0x82CFB780;
    'dispatch: loop {
        match pc {
            0x82CFB780 => {
    //   block [0x82CFB780..0x82CFB840)
	// 82CFB780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB788: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB78C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB790: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB794: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB798: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB79C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB7A0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB7A4: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB7A8: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB7AC: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB7B0: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB7B4: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB7B8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB7BC: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFB7C0: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB7C4: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB7C8: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB7CC: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB7D0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB7D4: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB7D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB7DC: 409A0064  bne cr6, 0x82cfb840
	if !ctx.cr[6].eq {
	pc = 0x82CFB840; continue 'dispatch;
	}
	// 82CFB7E0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB7E4: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB7E8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB7EC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB7F0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB7F4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB7F8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB7FC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB800: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB804: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB808: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB80C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB810: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB814: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB818: 40990028  ble cr6, 0x82cfb840
	if !ctx.cr[6].gt {
	pc = 0x82CFB840; continue 'dispatch;
	}
	// 82CFB81C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB820: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB824: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB828: 41980018  blt cr6, 0x82cfb840
	if ctx.cr[6].lt {
	pc = 0x82CFB840; continue 'dispatch;
	}
	// 82CFB82C: 4BFF4A9D  bl 0x82cf02c8
	ctx.lr = 0x82CFB830;
	sub_82CF02C8(ctx, base);
	// 82CFB830: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB83C: 4E800020  blr
	return;
            }
            0x82CFB840 => {
    //   block [0x82CFB840..0x82CFB858)
	// 82CFB840: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB844: 4BFF9B05  bl 0x82cf5348
	ctx.lr = 0x82CFB848;
	sub_82CF5348(ctx, base);
	// 82CFB848: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB84C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB854: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB858 size=216
    let mut pc: u32 = 0x82CFB858;
    'dispatch: loop {
        match pc {
            0x82CFB858 => {
    //   block [0x82CFB858..0x82CFB918)
	// 82CFB858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB860: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB864: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB868: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB86C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB870: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB874: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB878: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB87C: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB880: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB884: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB888: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB88C: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB890: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB894: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFB898: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB89C: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB8A0: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB8A4: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB8A8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB8AC: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB8B0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB8B4: 409A0064  bne cr6, 0x82cfb918
	if !ctx.cr[6].eq {
	pc = 0x82CFB918; continue 'dispatch;
	}
	// 82CFB8B8: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB8BC: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB8C0: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB8C4: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB8C8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB8CC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB8D0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB8D4: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB8D8: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB8DC: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB8E0: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB8E4: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB8E8: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB8EC: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB8F0: 40990028  ble cr6, 0x82cfb918
	if !ctx.cr[6].gt {
	pc = 0x82CFB918; continue 'dispatch;
	}
	// 82CFB8F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB8F8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB8FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB900: 41980018  blt cr6, 0x82cfb918
	if ctx.cr[6].lt {
	pc = 0x82CFB918; continue 'dispatch;
	}
	// 82CFB904: 4BFF4CAD  bl 0x82cf05b0
	ctx.lr = 0x82CFB908;
	sub_82CF05B0(ctx, base);
	// 82CFB908: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB90C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB914: 4E800020  blr
	return;
            }
            0x82CFB918 => {
    //   block [0x82CFB918..0x82CFB930)
	// 82CFB918: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB91C: 4BFF9DED  bl 0x82cf5708
	ctx.lr = 0x82CFB920;
	sub_82CF5708(ctx, base);
	// 82CFB920: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB92C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB930 size=216
    let mut pc: u32 = 0x82CFB930;
    'dispatch: loop {
        match pc {
            0x82CFB930 => {
    //   block [0x82CFB930..0x82CFB9F0)
	// 82CFB930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB938: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB93C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB940: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB944: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB948: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB94C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB950: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB954: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB958: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB95C: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB960: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB964: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB968: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB96C: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFB970: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB974: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB978: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB97C: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB980: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB984: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB988: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB98C: 409A0064  bne cr6, 0x82cfb9f0
	if !ctx.cr[6].eq {
	pc = 0x82CFB9F0; continue 'dispatch;
	}
	// 82CFB990: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB994: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB998: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB99C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB9A0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB9A4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB9A8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB9AC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB9B0: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB9B4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB9B8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB9BC: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB9C0: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB9C4: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB9C8: 40990028  ble cr6, 0x82cfb9f0
	if !ctx.cr[6].gt {
	pc = 0x82CFB9F0; continue 'dispatch;
	}
	// 82CFB9CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB9D0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB9D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB9D8: 41980018  blt cr6, 0x82cfb9f0
	if ctx.cr[6].lt {
	pc = 0x82CFB9F0; continue 'dispatch;
	}
	// 82CFB9DC: 4BFF4F95  bl 0x82cf0970
	ctx.lr = 0x82CFB9E0;
	sub_82CF0970(ctx, base);
	// 82CFB9E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB9EC: 4E800020  blr
	return;
            }
            0x82CFB9F0 => {
    //   block [0x82CFB9F0..0x82CFBA08)
	// 82CFB9F0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB9F4: 4BFFA22D  bl 0x82cf5c20
	ctx.lr = 0x82CFB9F8;
	sub_82CF5C20(ctx, base);
	// 82CFB9F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB9FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFBA00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFBA04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFBA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFBA08 size=448
    let mut pc: u32 = 0x82CFBA08;
    'dispatch: loop {
        match pc {
            0x82CFBA08 => {
    //   block [0x82CFBA08..0x82CFBA5C)
	// 82CFBA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFBA0C: 4BFAD9FD  bl 0x82ca9408
	ctx.lr = 0x82CFBA10;
	sub_82CA93D0(ctx, base);
	// 82CFBA10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFBA14: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFBA18: 8BC3000D  lbz r30, 0xd(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFBA1C: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFBA20: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFBA24: 7CFE51D6  mullw r7, r30, r10
	ctx.r[7].s32 = ((ctx.r[30].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82CFBA28: 83A30018  lwz r29, 0x18(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFBA2C: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFBA30: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFBA34: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFBA38: 7D4AF850  subf r10, r10, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82CFBA3C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFBA40: 7CC8E850  subf r6, r8, r29
	ctx.r[6].s64 = ctx.r[29].s64 - ctx.r[8].s64;
	// 82CFBA44: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82CFBA48: 7D292214  add r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 82CFBA4C: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CFBA50: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82CFBA54: 41980008  blt cr6, 0x82cfba5c
	if ctx.cr[6].lt {
	pc = 0x82CFBA5C; continue 'dispatch;
	}
	// 82CFBA58: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	pc = 0x82CFBA5C; continue 'dispatch;
            }
            0x82CFBA5C => {
    //   block [0x82CFBA5C..0x82CFBA80)
	// 82CFBA5C: 54EA077E  clrlwi r10, r7, 0x1d
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 82CFBA60: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82CFBA64: 7D0A5B78  or r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 82CFBA68: 5548073E  clrlwi r8, r10, 0x1c
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82CFBA6C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CFBA70: 419A0010  beq cr6, 0x82cfba80
	if ctx.cr[6].eq {
	pc = 0x82CFBA80; continue 'dispatch;
	}
	// 82CFBA74: 4BFFA955  bl 0x82cf63c8
	ctx.lr = 0x82CFBA78;
	sub_82CF63C8(ctx, base);
	// 82CFBA78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CFBA7C: 4BFAD9DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFBA80 => {
    //   block [0x82CFBA80..0x82CFBA98)
	// 82CFBA80: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBA84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFBA88: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CFBA8C: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBA90: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFBA94: 419A0018  beq cr6, 0x82cfbaac
	if ctx.cr[6].eq {
	pc = 0x82CFBAAC; continue 'dispatch;
	}
	pc = 0x82CFBA98; continue 'dispatch;
            }
            0x82CFBA98 => {
    //   block [0x82CFBA98..0x82CFBAAC)
	// 82CFBA98: 555C3830  slwi r28, r10, 7
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82CFBA9C: 7C1C5A2C  dcbt r28, r11
	// 82CFBAA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CFBAA4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFBAA8: 4198FFF0  blt cr6, 0x82cfba98
	if ctx.cr[6].lt {
	pc = 0x82CFBA98; continue 'dispatch;
	}
	pc = 0x82CFBAAC; continue 'dispatch;
            }
            0x82CFBAAC => {
    //   block [0x82CFBAAC..0x82CFBBC8)
	// 82CFBAAC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFBAB0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFBAB4: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBAB8: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFBABC: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82CFBAC0: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBAC4: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFBAC8: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFBACC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFBAD0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFBAD4: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFBAD8: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBADC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82CFBAE0: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82CFBAE4: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82CFBAE8: C18A0A4C  lfs f12, 0xa4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFBAEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CFBAF0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFBAF4: 394A6880  addi r10, r10, 0x6880
	ctx.r[10].s64 = ctx.r[10].s64 + 26752;
	// 82CFBAF8: 13E0E407  vcmpneb. (lvlx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFBBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFBBC8 size=528
    let mut pc: u32 = 0x82CFBBC8;
    'dispatch: loop {
        match pc {
            0x82CFBBC8 => {
    //   block [0x82CFBBC8..0x82CFBC1C)
	// 82CFBBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFBBCC: 4BFAD839  bl 0x82ca9404
	ctx.lr = 0x82CFBBD0;
	sub_82CA93D0(ctx, base);
	// 82CFBBD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFBBD4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFBBD8: 8B83000D  lbz r28, 0xd(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFBBDC: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFBBE0: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFBBE4: 7CFC51D6  mullw r7, r28, r10
	ctx.r[7].s32 = ((ctx.r[28].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82CFBBE8: 83630018  lwz r27, 0x18(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFBBEC: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFBBF0: 83C30014  lwz r30, 0x14(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFBBF4: 7D2AE850  subf r9, r10, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[10].s64;
	// 82CFBBF8: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFBBFC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBC00: 7CC8D850  subf r6, r8, r27
	ctx.r[6].s64 = ctx.r[27].s64 - ctx.r[8].s64;
	// 82CFBC04: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82CFBC08: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82CFBC0C: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CFBC10: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 82CFBC14: 41980008  blt cr6, 0x82cfbc1c
	if ctx.cr[6].lt {
	pc = 0x82CFBC1C; continue 'dispatch;
	}
	// 82CFBC18: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	pc = 0x82CFBC1C; continue 'dispatch;
            }
            0x82CFBC1C => {
    //   block [0x82CFBC1C..0x82CFBC40)
	// 82CFBC1C: 54E9077E  clrlwi r9, r7, 0x1d
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 82CFBC20: 7D285378  or r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82CFBC24: 7D055B78  or r5, r8, r11
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 82CFBC28: 54A4073E  clrlwi r4, r5, 0x1c
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 82CFBC2C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFBC30: 419A0010  beq cr6, 0x82cfbc40
	if ctx.cr[6].eq {
	pc = 0x82CFBC40; continue 'dispatch;
	}
	// 82CFBC34: 4BFFA8B5  bl 0x82cf64e8
	ctx.lr = 0x82CFBC38;
	sub_82CF64E8(ctx, base);
	// 82CFBC38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CFBC3C: 4BFAD818  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFBC40 => {
    //   block [0x82CFBC40..0x82CFBC58)
	// 82CFBC40: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBC44: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFBC48: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CFBC4C: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBC50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFBC54: 419A0018  beq cr6, 0x82cfbc6c
	if ctx.cr[6].eq {
	pc = 0x82CFBC6C; continue 'dispatch;
	}
	pc = 0x82CFBC58; continue 'dispatch;
            }
            0x82CFBC58 => {
    //   block [0x82CFBC58..0x82CFBC6C)
	// 82CFBC58: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFBC5C: 7C055A2C  dcbt r5, r11
	// 82CFBC60: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFBC64: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFBC68: 4198FFF0  blt cr6, 0x82cfbc58
	if ctx.cr[6].lt {
	pc = 0x82CFBC58; continue 'dispatch;
	}
	pc = 0x82CFBC6C; continue 'dispatch;
            }
            0x82CFBC6C => {
    //   block [0x82CFBC6C..0x82CFBDD8)
	// 82CFBC6C: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CFBC70: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFBC74: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBC78: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFBC7C: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82CFBC80: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBC84: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFBC88: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFBC8C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFBC90: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFBC94: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFBC98: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBC9C: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82CFBCA0: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CFBCA4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CFBCA8: C1850A4C  lfs f12, 0xa4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFBCAC: 38A66880  addi r5, r6, 0x6880
	ctx.r[5].s64 = ctx.r[6].s64 + 26752;
	// 82CFBCB0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82CFBCB4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFBCB8: 13E04407  vcmpneb. (lvlx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFBDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFBDD8 size=832
    let mut pc: u32 = 0x82CFBDD8;
    'dispatch: loop {
        match pc {
            0x82CFBDD8 => {
    //   block [0x82CFBDD8..0x82CFBE2C)
	// 82CFBDD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFBDDC: 4BFAD601  bl 0x82ca93dc
	ctx.lr = 0x82CFBDE0;
	sub_82CA93D0(ctx, base);
	// 82CFBDE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFBDE4: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFBDE8: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFBDEC: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFBDF0: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFBDF4: 7D2931D6  mullw r9, r9, r6
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFBDF8: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFBDFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFBE00: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFBE04: 906100F4  stw r3, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 82CFBE08: 7D064050  subf r8, r6, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 82CFBE0C: 7CA43850  subf r5, r4, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 82CFBE10: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFBE14: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFBE18: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CFBE1C: 7CE65214  add r7, r6, r10
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 82CFBE20: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82CFBE24: 41980008  blt cr6, 0x82cfbe2c
	if ctx.cr[6].lt {
	pc = 0x82CFBE2C; continue 'dispatch;
	}
	// 82CFBE28: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	pc = 0x82CFBE2C; continue 'dispatch;
            }
            0x82CFBE2C => {
    //   block [0x82CFBE2C..0x82CFBE50)
	// 82CFBE2C: 550B077E  clrlwi r11, r8, 0x1d
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00000007u64;
	// 82CFBE30: 7D6A3B78  or r10, r11, r7
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	// 82CFBE34: 7D464B78  or r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82CFBE38: 54C4073E  clrlwi r4, r6, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	// 82CFBE3C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFBE40: 419A0010  beq cr6, 0x82cfbe50
	if ctx.cr[6].eq {
	pc = 0x82CFBE50; continue 'dispatch;
	}
	// 82CFBE44: 4BFFA90D  bl 0x82cf6750
	ctx.lr = 0x82CFBE48;
	sub_82CF6750(ctx, base);
	// 82CFBE48: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82CFBE4C: 4BFAD5E0  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFBE50 => {
    //   block [0x82CFBE50..0x82CFBE70)
	// 82CFBE50: 550A083C  slwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBE54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFBE58: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82CFBE5C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBE60: 38CA007F  addi r6, r10, 0x7f
	ctx.r[6].s64 = ctx.r[10].s64 + 127;
	// 82CFBE64: 54CAC9FE  srwi r10, r6, 7
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBE68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFBE6C: 419A0018  beq cr6, 0x82cfbe84
	if ctx.cr[6].eq {
	pc = 0x82CFBE84; continue 'dispatch;
	}
	pc = 0x82CFBE70; continue 'dispatch;
            }
            0x82CFBE70 => {
    //   block [0x82CFBE70..0x82CFBE84)
	// 82CFBE70: 55663830  slwi r6, r11, 7
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFBE74: 7C064A2C  dcbt r6, r9
	// 82CFBE78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFBE7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFBE80: 4198FFF0  blt cr6, 0x82cfbe70
	if ctx.cr[6].lt {
	pc = 0x82CFBE70; continue 'dispatch;
	}
	pc = 0x82CFBE84; continue 'dispatch;
            }
            0x82CFBE84 => {
    //   block [0x82CFBE84..0x82CFC118)
	// 82CFBE84: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 82CFBE88: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFBE8C: 550A083C  slwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBE90: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFBE94: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82CFBE98: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBE9C: 7D4607B4  extsw r6, r10
	ctx.r[6].s64 = ctx.r[10].s32 as i64;
	// 82CFBEA0: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFBEA4: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFBEA8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFBEAC: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFBEB0: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBEB4: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82CFBEB8: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CFBEBC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CFBEC0: C1850A4C  lfs f12, 0xa4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFBEC4: 38A66880  addi r5, r6, 0x6880
	ctx.r[5].s64 = ctx.r[6].s64 + 26752;
	// 82CFBEC8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82CFBECC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CFBED0: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFC118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFC118 size=520
    let mut pc: u32 = 0x82CFC118;
    'dispatch: loop {
        match pc {
            0x82CFC118 => {
    //   block [0x82CFC118..0x82CFC16C)
	// 82CFC118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFC11C: 4BFAD2E5  bl 0x82ca9400
	ctx.lr = 0x82CFC120;
	sub_82CA93D0(ctx, base);
	// 82CFC120: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFC124: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFC128: 8BA3000D  lbz r29, 0xd(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFC12C: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFC130: 7CDD51D6  mullw r6, r29, r10
	ctx.r[6].s32 = ((ctx.r[29].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82CFC134: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFC138: 83830018  lwz r28, 0x18(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFC13C: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFC140: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFC144: 54CB083C  slwi r11, r6, 1
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFC148: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC14C: 7D2AF050  subf r9, r10, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 82CFC150: 7CE7E050  subf r7, r7, r28
	ctx.r[7].s64 = ctx.r[28].s64 - ctx.r[7].s64;
	// 82CFC154: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82CFC158: 7D68FA14  add r11, r8, r31
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 82CFC15C: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82CFC160: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 82CFC164: 41980008  blt cr6, 0x82cfc16c
	if ctx.cr[6].lt {
	pc = 0x82CFC16C; continue 'dispatch;
	}
	// 82CFC168: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	pc = 0x82CFC16C; continue 'dispatch;
            }
            0x82CFC16C => {
    //   block [0x82CFC16C..0x82CFC18C)
	// 82CFC16C: 7CC95B78  or r9, r6, r11
	ctx.r[9].u64 = ctx.r[6].u64 | ctx.r[11].u64;
	// 82CFC170: 7D285378  or r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82CFC174: 5505073E  clrlwi r5, r8, 0x1c
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFC178: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82CFC17C: 419A0010  beq cr6, 0x82cfc18c
	if ctx.cr[6].eq {
	pc = 0x82CFC18C; continue 'dispatch;
	}
	// 82CFC180: 4BFFA869  bl 0x82cf69e8
	ctx.lr = 0x82CFC184;
	sub_82CF69E8(ctx, base);
	// 82CFC184: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82CFC188: 4BFAD2C8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFC18C => {
    //   block [0x82CFC18C..0x82CFC1A4)
	// 82CFC18C: 54C5083C  slwi r5, r6, 1
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFC190: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFC194: 3905007F  addi r8, r5, 0x7f
	ctx.r[8].s64 = ctx.r[5].s64 + 127;
	// 82CFC198: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC19C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFC1A0: 419A0018  beq cr6, 0x82cfc1b8
	if ctx.cr[6].eq {
	pc = 0x82CFC1B8; continue 'dispatch;
	}
	pc = 0x82CFC1A4; continue 'dispatch;
            }
            0x82CFC1A4 => {
    //   block [0x82CFC1A4..0x82CFC1B8)
	// 82CFC1A4: 553B3830  slwi r27, r9, 7
	ctx.r[27].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82CFC1A8: 7C1B522C  dcbt r27, r10
	// 82CFC1AC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFC1B0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFC1B4: 4198FFF0  blt cr6, 0x82cfc1a4
	if ctx.cr[6].lt {
	pc = 0x82CFC1A4; continue 'dispatch;
	}
	pc = 0x82CFC1B8; continue 'dispatch;
            }
            0x82CFC1B8 => {
    //   block [0x82CFC1B8..0x82CFC320)
	// 82CFC1B8: 7CE907B4  extsw r9, r7
	ctx.r[9].s64 = ctx.r[7].s32 as i64;
	// 82CFC1BC: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFC1C0: 7CA807B4  extsw r8, r5
	ctx.r[8].s64 = ctx.r[5].s32 as i64;
	// 82CFC1C4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFC1C8: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82CFC1CC: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFC1D0: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 82CFC1D4: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFC1D8: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFC1DC: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82CFC1E0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82CFC1E4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFC1E8: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82CFC1EC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CFC1F0: 39056890  addi r8, r5, 0x6890
	ctx.r[8].s64 = ctx.r[5].s64 + 26768;
	// 82CFC1F4: 13E0DC07  vcmpneb. (lvlx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CFC1F8: 38A96880  addi r5, r9, 0x6880
	ctx.r[5].s64 = ctx.r[9].s64 + 26752;
	// 82CFC1FC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFC320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFC320 size=524
    let mut pc: u32 = 0x82CFC320;
    'dispatch: loop {
        match pc {
            0x82CFC320 => {
    //   block [0x82CFC320..0x82CFC374)
	// 82CFC320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFC324: 4BFAD0E1  bl 0x82ca9404
	ctx.lr = 0x82CFC328;
	sub_82CA93D0(ctx, base);
	// 82CFC328: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFC32C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFC330: 8BC3000D  lbz r30, 0xd(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFC334: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFC338: 7CDE51D6  mullw r6, r30, r10
	ctx.r[6].s32 = ((ctx.r[30].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82CFC33C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFC340: 83A30018  lwz r29, 0x18(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFC344: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFC348: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFC34C: 54CB083C  slwi r11, r6, 1
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFC350: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82CFC354: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC358: 7CC7E850  subf r6, r7, r29
	ctx.r[6].s64 = ctx.r[29].s64 - ctx.r[7].s64;
	// 82CFC35C: 7D4B2A14  add r10, r11, r5
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82CFC360: 7D682214  add r11, r8, r4
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[4].u64;
	// 82CFC364: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CFC368: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 82CFC36C: 41980008  blt cr6, 0x82cfc374
	if ctx.cr[6].lt {
	pc = 0x82CFC374; continue 'dispatch;
	}
	// 82CFC370: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	pc = 0x82CFC374; continue 'dispatch;
            }
            0x82CFC374 => {
    //   block [0x82CFC374..0x82CFC398)
	// 82CFC374: 54E9077E  clrlwi r9, r7, 0x1d
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 82CFC378: 7D285B78  or r8, r9, r11
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 82CFC37C: 7D095378  or r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 82CFC380: 5528073E  clrlwi r8, r9, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 82CFC384: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CFC388: 419A0010  beq cr6, 0x82cfc398
	if ctx.cr[6].eq {
	pc = 0x82CFC398; continue 'dispatch;
	}
	// 82CFC38C: 4BFFA79D  bl 0x82cf6b28
	ctx.lr = 0x82CFC390;
	sub_82CF6B28(ctx, base);
	// 82CFC390: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CFC394: 4BFAD0C0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFC398 => {
    //   block [0x82CFC398..0x82CFC3B0)
	// 82CFC398: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC39C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFC3A0: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CFC3A4: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC3A8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFC3AC: 419A0018  beq cr6, 0x82cfc3c4
	if ctx.cr[6].eq {
	pc = 0x82CFC3C4; continue 'dispatch;
	}
	pc = 0x82CFC3B0; continue 'dispatch;
            }
            0x82CFC3B0 => {
    //   block [0x82CFC3B0..0x82CFC3C4)
	// 82CFC3B0: 553C3830  slwi r28, r9, 7
	ctx.r[28].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82CFC3B4: 7C1C522C  dcbt r28, r10
	// 82CFC3B8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFC3BC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFC3C0: 4198FFF0  blt cr6, 0x82cfc3b0
	if ctx.cr[6].lt {
	pc = 0x82CFC3B0; continue 'dispatch;
	}
	pc = 0x82CFC3C4; continue 'dispatch;
            }
            0x82CFC3C4 => {
    //   block [0x82CFC3C4..0x82CFC52C)
	// 82CFC3C4: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CFC3C8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFC3CC: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC3D0: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFC3D4: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82CFC3D8: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFC3DC: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFC3E0: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFC3E4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82CFC3E8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFC3EC: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFC3F0: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFC3F4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82CFC3F8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CFC3FC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CFC400: 13E0E407  vcmpneb. (lvlx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CFC404: 39086880  addi r8, r8, 0x6880
	ctx.r[8].s64 = ctx.r[8].s64 + 26752;
	// 82CFC408: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFC530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFC530 size=844
    let mut pc: u32 = 0x82CFC530;
    'dispatch: loop {
        match pc {
            0x82CFC530 => {
    //   block [0x82CFC530..0x82CFC584)
	// 82CFC530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFC534: 4BFACEB5  bl 0x82ca93e8
	ctx.lr = 0x82CFC538;
	sub_82CA93D0(ctx, base);
	// 82CFC538: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFC53C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFC540: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFC544: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFC548: 7D0B51D6  mullw r8, r11, r10
	ctx.r[8].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CFC54C: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFC550: 80A3001C  lwz r5, 0x1c(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFC554: 82A30000  lwz r21, 0(r3)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFC558: 82830014  lwz r20, 0x14(r3)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFC55C: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82CFC560: 550A083C  slwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFC564: 7CC53850  subf r6, r5, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 82CFC568: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC56C: 7D2AAA14  add r9, r10, r21
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[21].u64;
	// 82CFC570: 7CE8A214  add r7, r8, r20
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[20].u64;
	// 82CFC574: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CFC578: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CFC57C: 41980008  blt cr6, 0x82cfc584
	if ctx.cr[6].lt {
	pc = 0x82CFC584; continue 'dispatch;
	}
	// 82CFC580: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	pc = 0x82CFC584; continue 'dispatch;
            }
            0x82CFC584 => {
    //   block [0x82CFC584..0x82CFC5A8)
	// 82CFC584: 554B077E  clrlwi r11, r10, 0x1d
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 82CFC588: 7D683B78  or r8, r11, r7
	ctx.r[8].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	// 82CFC58C: 7D054B78  or r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 82CFC590: 54A4073E  clrlwi r4, r5, 0x1c
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 82CFC594: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFC598: 419A0010  beq cr6, 0x82cfc5a8
	if ctx.cr[6].eq {
	pc = 0x82CFC5A8; continue 'dispatch;
	}
	// 82CFC59C: 4BFFA895  bl 0x82cf6e30
	ctx.lr = 0x82CFC5A0;
	sub_82CF6E30(ctx, base);
	// 82CFC5A0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82CFC5A4: 4BFACE94  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFC5A8 => {
    //   block [0x82CFC5A8..0x82CFC5C8)
	// 82CFC5A8: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC5AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFC5B0: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82CFC5B4: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC5B8: 38A8007F  addi r5, r8, 0x7f
	ctx.r[5].s64 = ctx.r[8].s64 + 127;
	// 82CFC5BC: 54A8C9FE  srwi r8, r5, 7
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC5C0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFC5C4: 419A0018  beq cr6, 0x82cfc5dc
	if ctx.cr[6].eq {
	pc = 0x82CFC5DC; continue 'dispatch;
	}
	pc = 0x82CFC5C8; continue 'dispatch;
            }
            0x82CFC5C8 => {
    //   block [0x82CFC5C8..0x82CFC5DC)
	// 82CFC5C8: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFC5CC: 7C054A2C  dcbt r5, r9
	// 82CFC5D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFC5D4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFC5D8: 4198FFF0  blt cr6, 0x82cfc5c8
	if ctx.cr[6].lt {
	pc = 0x82CFC5C8; continue 'dispatch;
	}
	pc = 0x82CFC5DC; continue 'dispatch;
            }
            0x82CFC5DC => {
    //   block [0x82CFC5DC..0x82CFC87C)
	// 82CFC5DC: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CFC5E0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFC5E4: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFC5E8: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFC5EC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82CFC5F0: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFC5F4: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFC5F8: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFC5FC: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CFC600: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFC604: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFC608: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFC60C: 39046880  addi r8, r4, 0x6880
	ctx.r[8].s64 = ctx.r[4].s64 + 26752;
	// 82CFC610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFC614: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82CFC618: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CFC61C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CFC620: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CFC624: C18B0A4C  lfs f12, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFC628: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFC880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFC880 size=680
    let mut pc: u32 = 0x82CFC880;
    'dispatch: loop {
        match pc {
            0x82CFC880 => {
    //   block [0x82CFC880..0x82CFC8D0)
	// 82CFC880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFC884: 4BFACB75  bl 0x82ca93f8
	ctx.lr = 0x82CFC888;
	sub_82CA93D0(ctx, base);
	// 82CFC888: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFC88C: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFC890: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFC894: 8B43000D  lbz r26, 0xd(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFC898: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFC89C: 83630004  lwz r27, 4(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFC8A0: 83230018  lwz r25, 0x18(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFC8A4: 7D5A59D6  mullw r10, r26, r11
	ctx.r[10].s32 = ((ctx.r[26].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFC8A8: 83830014  lwz r28, 0x14(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFC8AC: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFC8B0: 7D6BD850  subf r11, r11, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 82CFC8B4: 7CE8C850  subf r7, r8, r25
	ctx.r[7].s64 = ctx.r[25].s64 - ctx.r[8].s64;
	// 82CFC8B8: 7D09E214  add r8, r9, r28
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[28].u64;
	// 82CFC8BC: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82CFC8C0: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82CFC8C4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CFC8C8: 41980008  blt cr6, 0x82cfc8d0
	if ctx.cr[6].lt {
	pc = 0x82CFC8D0; continue 'dispatch;
	}
	// 82CFC8CC: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	pc = 0x82CFC8D0; continue 'dispatch;
            }
            0x82CFC8D0 => {
    //   block [0x82CFC8D0..0x82CFC8F4)
	// 82CFC8D0: 7D0B5378  or r11, r8, r10
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 82CFC8D4: 5566073E  clrlwi r6, r11, 0x1c
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82CFC8D8: 7CC54B78  or r5, r6, r9
	ctx.r[5].u64 = ctx.r[6].u64 | ctx.r[9].u64;
	// 82CFC8DC: 54A406FE  clrlwi r4, r5, 0x1b
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 82CFC8E0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFC8E4: 419A0010  beq cr6, 0x82cfc8f4
	if ctx.cr[6].eq {
	pc = 0x82CFC8F4; continue 'dispatch;
	}
	// 82CFC8E8: 4BFFA871  bl 0x82cf7158
	ctx.lr = 0x82CFC8EC;
	sub_82CF7158(ctx, base);
	// 82CFC8EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CFC8F0: 4BFACB58  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFC8F4 => {
    //   block [0x82CFC8F4..0x82CFC908)
	// 82CFC8F4: 38C9007F  addi r6, r9, 0x7f
	ctx.r[6].s64 = ctx.r[9].s64 + 127;
	// 82CFC8F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFC8FC: 54C6C9FE  srwi r6, r6, 7
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFC900: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CFC904: 419A0018  beq cr6, 0x82cfc91c
	if ctx.cr[6].eq {
	pc = 0x82CFC91C; continue 'dispatch;
	}
	pc = 0x82CFC908; continue 'dispatch;
            }
            0x82CFC908 => {
    //   block [0x82CFC908..0x82CFC91C)
	// 82CFC908: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFC90C: 7C05522C  dcbt r5, r10
	// 82CFC910: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFC914: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CFC918: 4198FFF0  blt cr6, 0x82cfc908
	if ctx.cr[6].lt {
	pc = 0x82CFC908; continue 'dispatch;
	}
	pc = 0x82CFC91C; continue 'dispatch;
            }
            0x82CFC91C => {
    //   block [0x82CFC91C..0x82CFCB28)
	// 82CFC91C: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 82CFC920: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFC924: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFC928: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFC92C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82CFC930: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFC934: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 82CFC938: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFC93C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82CFC940: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFC944: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFC948: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFC94C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CFC950: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CFC954: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CFC958: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CFC95C: 13E0F407  vcmpneb. (lvlx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CFC960: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFCB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFCB28 size=568
    let mut pc: u32 = 0x82CFCB28;
    'dispatch: loop {
        match pc {
            0x82CFCB28 => {
    //   block [0x82CFCB28..0x82CFCB88)
	// 82CFCB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFCB2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFCB30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CFCB34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CFCB38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFCB3C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFCB40: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFCB44: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFCB48: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFCB4C: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFCB50: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFCB54: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFCB58: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFCB5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFCB60: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFCB64: 7CBF0E70  srawi r31, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CFCB68: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFCB6C: 7D492050  subf r10, r9, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CFCB70: 7D3F0194  addze r9, r31
	tmp.s64 = ctx.r[31].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[31].u32);
	ctx.r[9].s64 = tmp.s64;
	// 82CFCB74: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CFCB78: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFCB7C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82CFCB80: 40980008  bge cr6, 0x82cfcb88
	if !ctx.cr[6].lt {
	pc = 0x82CFCB88; continue 'dispatch;
	}
	// 82CFCB84: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x82CFCB88; continue 'dispatch;
            }
            0x82CFCB88 => {
    //   block [0x82CFCB88..0x82CFCBA8)
	// 82CFCB88: 552A07BE  clrlwi r10, r9, 0x1e
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82CFCB8C: 7D474378  or r7, r10, r8
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82CFCB90: 7CE65B78  or r6, r7, r11
	ctx.r[6].u64 = ctx.r[7].u64 | ctx.r[11].u64;
	// 82CFCB94: 54C4073E  clrlwi r4, r6, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	// 82CFCB98: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFCB9C: 419A000C  beq cr6, 0x82cfcba8
	if ctx.cr[6].eq {
	pc = 0x82CFCBA8; continue 'dispatch;
	}
	// 82CFCBA0: 4BFFB561  bl 0x82cf8100
	ctx.lr = 0x82CFCBA4;
	sub_82CF8100(ctx, base);
	// 82CFCBA4: 480001A4  b 0x82cfcd48
	pc = 0x82CFCD48; continue 'dispatch;
            }
            0x82CFCBA8 => {
    //   block [0x82CFCBA8..0x82CFCBC0)
	// 82CFCBA8: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFCBAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFCBB0: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CFCBB4: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFCBB8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFCBBC: 419A0018  beq cr6, 0x82cfcbd4
	if ctx.cr[6].eq {
	pc = 0x82CFCBD4; continue 'dispatch;
	}
	pc = 0x82CFCBC0; continue 'dispatch;
            }
            0x82CFCBC0 => {
    //   block [0x82CFCBC0..0x82CFCBD4)
	// 82CFCBC0: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFCBC4: 7C065A2C  dcbt r6, r11
	// 82CFCBC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CFCBCC: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CFCBD0: 4198FFF0  blt cr6, 0x82cfcbc0
	if ctx.cr[6].lt {
	pc = 0x82CFCBC0; continue 'dispatch;
	}
	pc = 0x82CFCBD4; continue 'dispatch;
            }
            0x82CFCBD4 => {
    //   block [0x82CFCBD4..0x82CFCD48)
	// 82CFCBD4: 7CAA07B4  extsw r10, r5
	ctx.r[10].s64 = ctx.r[5].s32 as i64;
	// 82CFCBD8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFCBDC: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFCBE0: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFCBE4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CFCBE8: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82CFCBEC: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 82CFCBF0: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFCBF4: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CFCBF8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFCBFC: F8C10060  std r6, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u64 ) };
	// 82CFCC00: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82CFCC04: 38E46890  addi r7, r4, 0x6890
	ctx.r[7].s64 = ctx.r[4].s64 + 26768;
	// 82CFCC08: C1230034  lfs f9, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFCC0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CFCC10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CFCC14: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CFCC18: 3FE08204  lis r31, -0x7dfc
	ctx.r[31].s64 = -2113667072;
	// 82CFCC1C: 38CA6880  addi r6, r10, 0x6880
	ctx.r[6].s64 = ctx.r[10].s64 + 26752;
	// 82CFCC20: 13E02407  vcmpneb. (lvlx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CFCC24: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	pc = 0x82CFCD48; continue 'dispatch;
            }
            0x82CFCD48 => {
    //   block [0x82CFCD48..0x82CFCD60)
	// 82CFCD48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CFCD4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFCD50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFCD54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CFCD58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFCD5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFCD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFCD60 size=616
    let mut pc: u32 = 0x82CFCD60;
    'dispatch: loop {
        match pc {
            0x82CFCD60 => {
    //   block [0x82CFCD60..0x82CFCDB8)
	// 82CFCD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFCD64: 4BFAC6A9  bl 0x82ca940c
	ctx.lr = 0x82CFCD68;
	sub_82CA93D0(ctx, base);
	// 82CFCD68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFCD6C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFCD70: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFCD74: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFCD78: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFCD7C: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFCD80: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFCD84: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFCD88: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFCD8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFCD90: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFCD94: 7CA80E70  srawi r8, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CFCD98: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFCD9C: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CFCDA0: 7D080194  addze r8, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CFCDA4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFCDA8: 7D663A14  add r11, r6, r7
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFCDAC: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CFCDB0: 40980008  bge cr6, 0x82cfcdb8
	if !ctx.cr[6].lt {
	pc = 0x82CFCDB8; continue 'dispatch;
	}
	// 82CFCDB4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CFCDB8; continue 'dispatch;
            }
            0x82CFCDB8 => {
    //   block [0x82CFCDB8..0x82CFCDDC)
	// 82CFCDB8: 5509077E  clrlwi r9, r8, 0x1d
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00000007u64;
	// 82CFCDBC: 7D275B78  or r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 82CFCDC0: 7CE65378  or r6, r7, r10
	ctx.r[6].u64 = ctx.r[7].u64 | ctx.r[10].u64;
	// 82CFCDC4: 54C4073E  clrlwi r4, r6, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	// 82CFCDC8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFCDCC: 419A0010  beq cr6, 0x82cfcddc
	if ctx.cr[6].eq {
	pc = 0x82CFCDDC; continue 'dispatch;
	}
	// 82CFCDD0: 4BFFBC31  bl 0x82cf8a00
	ctx.lr = 0x82CFCDD4;
	sub_82CF8A00(ctx, base);
	// 82CFCDD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CFCDD8: 4BFAC684  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFCDDC => {
    //   block [0x82CFCDDC..0x82CFCDF4)
	// 82CFCDDC: 5506083C  slwi r6, r8, 1
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFCDE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFCDE4: 38E6007F  addi r7, r6, 0x7f
	ctx.r[7].s64 = ctx.r[6].s64 + 127;
	// 82CFCDE8: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFCDEC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFCDF0: 419A0018  beq cr6, 0x82cfce08
	if ctx.cr[6].eq {
	pc = 0x82CFCE08; continue 'dispatch;
	}
	pc = 0x82CFCDF4; continue 'dispatch;
            }
            0x82CFCDF4 => {
    //   block [0x82CFCDF4..0x82CFCE08)
	// 82CFCDF4: 55243830  slwi r4, r9, 7
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CFCDF8: 7C04522C  dcbt r4, r10
	// 82CFCDFC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFCE00: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CFCE04: 4198FFF0  blt cr6, 0x82cfcdf4
	if ctx.cr[6].lt {
	pc = 0x82CFCDF4; continue 'dispatch;
	}
	pc = 0x82CFCE08; continue 'dispatch;
            }
            0x82CFCE08 => {
    //   block [0x82CFCE08..0x82CFCFC8)
	// 82CFCE08: 7CA907B4  extsw r9, r5
	ctx.r[9].s64 = ctx.r[5].s32 as i64;
	// 82CFCE0C: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFCE10: 7CC707B4  extsw r7, r6
	ctx.r[7].s64 = ctx.r[6].s32 as i64;
	// 82CFCE14: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFCE18: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82CFCE1C: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFCE20: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 82CFCE24: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFCE28: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFCE2C: A1230034  lhz r9, 0x34(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CFCE30: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82CFCE34: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFCE38: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CFCE3C: 3FC08201  lis r30, -0x7dff
	ctx.r[30].s64 = -2113863680;
	// 82CFCE40: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CFCE44: B121006E  sth r9, 0x6e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(110 as u32), ctx.r[9].u16 ) };
	// 82CFCE48: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82CFCE4C: 38A568A0  addi r5, r5, 0x68a0
	ctx.r[5].s64 = ctx.r[5].s64 + 26784;
	// 82CFCE50: 38846890  addi r4, r4, 0x6890
	ctx.r[4].s64 = ctx.r[4].s64 + 26768;
	// 82CFCE54: 3BDE68B0  addi r30, r30, 0x68b0
	ctx.r[30].s64 = ctx.r[30].s64 + 26800;
	// 82CFCE58: 38E76880  addi r7, r7, 0x6880
	ctx.r[7].s64 = ctx.r[7].s64 + 26752;
	// 82CFCE5C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CFCE60: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82CFCE64: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82CFCE68: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CFCE6C: C1860B60  lfs f12, 0xb60(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFCE70: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82CFCE74: 13E0FC07  vcmpneb. (lvlx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFCFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFCFC8 size=796
    let mut pc: u32 = 0x82CFCFC8;
    'dispatch: loop {
        match pc {
            0x82CFCFC8 => {
    //   block [0x82CFCFC8..0x82CFD01C)
	// 82CFCFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFCFCC: 4BFAC435  bl 0x82ca9400
	ctx.lr = 0x82CFCFD0;
	sub_82CA93D0(ctx, base);
	// 82CFCFD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFCFD4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFCFD8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFCFDC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFCFE0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFCFE4: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFCFE8: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFCFEC: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFCFF0: 7CBF0E70  srawi r31, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CFCFF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFCFF8: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFCFFC: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFD000: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CFD004: 7D1F0194  addze r8, r31
	tmp.s64 = ctx.r[31].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[31].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CFD008: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFD00C: 7D663A14  add r11, r6, r7
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFD010: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CFD014: 40980008  bge cr6, 0x82cfd01c
	if !ctx.cr[6].lt {
	pc = 0x82CFD01C; continue 'dispatch;
	}
	// 82CFD018: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82CFD01C; continue 'dispatch;
            }
            0x82CFD01C => {
    //   block [0x82CFD01C..0x82CFD03C)
	// 82CFD01C: 7D095B78  or r9, r8, r11
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 82CFD020: 7D275378  or r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82CFD024: 54E6073E  clrlwi r6, r7, 0x1c
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000000Fu64;
	// 82CFD028: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CFD02C: 419A0010  beq cr6, 0x82cfd03c
	if ctx.cr[6].eq {
	pc = 0x82CFD03C; continue 'dispatch;
	}
	// 82CFD030: 4BFFC5C1  bl 0x82cf95f0
	ctx.lr = 0x82CFD034;
	sub_82CF95F0(ctx, base);
	// 82CFD034: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CFD038: 4BFAC418  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFD03C => {
    //   block [0x82CFD03C..0x82CFD050)
	// 82CFD03C: 38E8007F  addi r7, r8, 0x7f
	ctx.r[7].s64 = ctx.r[8].s64 + 127;
	// 82CFD040: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFD044: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFD048: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFD04C: 419A0018  beq cr6, 0x82cfd064
	if ctx.cr[6].eq {
	pc = 0x82CFD064; continue 'dispatch;
	}
	pc = 0x82CFD050; continue 'dispatch;
            }
            0x82CFD050 => {
    //   block [0x82CFD050..0x82CFD064)
	// 82CFD050: 55263830  slwi r6, r9, 7
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFD054: 7C06522C  dcbt r6, r10
	// 82CFD058: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFD05C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CFD060: 4198FFF0  blt cr6, 0x82cfd050
	if ctx.cr[6].lt {
	pc = 0x82CFD050; continue 'dispatch;
	}
	pc = 0x82CFD064; continue 'dispatch;
            }
            0x82CFD064 => {
    //   block [0x82CFD064..0x82CFD2E4)
	// 82CFD064: 7CA907B4  extsw r9, r5
	ctx.r[9].s64 = ctx.r[5].s32 as i64;
	// 82CFD068: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD06C: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFD070: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFD074: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82CFD078: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFD07C: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 82CFD080: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFD084: 88830034  lbz r4, 0x34(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CFD088: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 82CFD08C: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFD090: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFD094: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFD098: 1007030C  vspltisb v0, 7
	for i in 0..16 {
		ctx.v[0].u8[i] = 7 as u8;
	}
	// 82CFD09C: 3FA08201  lis r29, -0x7dff
	ctx.r[29].s64 = -2113863680;
	// 82CFD0A0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFD0A4: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CFD0A8: 9881006F  stb r4, 0x6f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(111 as u32), ctx.r[4].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFD2E8 size=168
    let mut pc: u32 = 0x82CFD2E8;
    'dispatch: loop {
        match pc {
            0x82CFD2E8 => {
    //   block [0x82CFD2E8..0x82CFD328)
	// 82CFD2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFD2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFD2F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFD2F4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82CFD2F8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CFD2FC: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 82CFD300: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 82CFD304: 409A0024  bne cr6, 0x82cfd328
	if !ctx.cr[6].eq {
	pc = 0x82CFD328; continue 'dispatch;
	}
	// 82CFD308: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82CFD30C: 3D400008  lis r10, 8
	ctx.r[10].s64 = 524288;
	// 82CFD310: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFD314: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 82CFD318: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82CFD31C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82CFD320: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFD324: 48000008  b 0x82cfd32c
	pc = 0x82CFD32C; continue 'dispatch;
            }
            0x82CFD328 => {
    //   block [0x82CFD328..0x82CFD32C)
	// 82CFD328: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82CFD32C; continue 'dispatch;
            }
            0x82CFD32C => {
    //   block [0x82CFD32C..0x82CFD368)
	// 82CFD32C: 3C800007  lis r4, 7
	ctx.r[4].s64 = 458752;
	// 82CFD330: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 82CFD334: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82CFD338: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CFD33C: 6084001A  ori r4, r4, 0x1a
	ctx.r[4].u64 = ctx.r[4].u64 | 26;
	// 82CFD340: 386000FA  li r3, 0xfa
	ctx.r[3].s64 = 250;
	// 82CFD344: 485BD0D1  bl 0x832ba414
	ctx.lr = 0x82CFD348;
	// extern call 0x832BA414 → crate::xboxkrnl::XMsgStartIORequestEx
	crate::xboxkrnl::XMsgStartIORequestEx(ctx, base);
	// 82CFD348: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFD34C: 4180001C  blt 0x82cfd368
	if ctx.cr[0].lt {
	pc = 0x82CFD368; continue 'dispatch;
	}
	// 82CFD350: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFD354: 4BFC5ACD  bl 0x82cc2e20
	ctx.lr = 0x82CFD358;
	sub_82CC2E20(ctx, base);
	// 82CFD358: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFD35C: 4180000C  blt 0x82cfd368
	if ctx.cr[0].lt {
	pc = 0x82CFD368; continue 'dispatch;
	}
	// 82CFD360: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFD364: 4800001C  b 0x82cfd380
	pc = 0x82CFD380; continue 'dispatch;
            }
            0x82CFD368 => {
    //   block [0x82CFD368..0x82CFD380)
	// 82CFD368: 546B00DE  rlwinm r11, r3, 0, 3, 0xf
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFD36C: 3D400007  lis r10, 7
	ctx.r[10].s64 = 458752;
	// 82CFD370: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82CFD374: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CFD378: 419A0008  beq cr6, 0x82cfd380
	if ctx.cr[6].eq {
	pc = 0x82CFD380; continue 'dispatch;
	}
	// 82CFD37C: 3860065B  li r3, 0x65b
	ctx.r[3].s64 = 1627;
	pc = 0x82CFD380; continue 'dispatch;
            }
            0x82CFD380 => {
    //   block [0x82CFD380..0x82CFD390)
	// 82CFD380: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CFD384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFD388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFD38C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFD390 size=104
    let mut pc: u32 = 0x82CFD390;
    'dispatch: loop {
        match pc {
            0x82CFD390 => {
    //   block [0x82CFD390..0x82CFD3D0)
	// 82CFD390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFD394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFD398: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFD39C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82CFD3A0: 3C800007  lis r4, 7
	ctx.r[4].s64 = 458752;
	// 82CFD3A4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82CFD3A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CFD3AC: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 82CFD3B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CFD3B4: 6084001B  ori r4, r4, 0x1b
	ctx.r[4].u64 = ctx.r[4].u64 | 27;
	// 82CFD3B8: 386000FA  li r3, 0xfa
	ctx.r[3].s64 = 250;
	// 82CFD3BC: 485BC899  bl 0x832b9c54
	ctx.lr = 0x82CFD3C0;
	// extern call 0x832B9C54 → crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82CFD3C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFD3C4: 4180000C  blt 0x82cfd3d0
	if ctx.cr[0].lt {
	pc = 0x82CFD3D0; continue 'dispatch;
	}
	// 82CFD3C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFD3CC: 4800001C  b 0x82cfd3e8
	pc = 0x82CFD3E8; continue 'dispatch;
            }
            0x82CFD3D0 => {
    //   block [0x82CFD3D0..0x82CFD3E8)
	// 82CFD3D0: 546B00DE  rlwinm r11, r3, 0, 3, 0xf
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFD3D4: 3D400007  lis r10, 7
	ctx.r[10].s64 = 458752;
	// 82CFD3D8: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82CFD3DC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CFD3E0: 419A0008  beq cr6, 0x82cfd3e8
	if ctx.cr[6].eq {
	pc = 0x82CFD3E8; continue 'dispatch;
	}
	// 82CFD3E4: 3860065B  li r3, 0x65b
	ctx.r[3].s64 = 1627;
	pc = 0x82CFD3E8; continue 'dispatch;
            }
            0x82CFD3E8 => {
    //   block [0x82CFD3E8..0x82CFD3F8)
	// 82CFD3E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CFD3EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFD3F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFD3F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFD3F8 size=68
    let mut pc: u32 = 0x82CFD3F8;
    'dispatch: loop {
        match pc {
            0x82CFD3F8 => {
    //   block [0x82CFD3F8..0x82CFD424)
	// 82CFD3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFD3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFD400: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CFD404: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFD408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CFD40C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CFD410: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CFD414: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82CFD418: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CFD41C: 41820008  beq 0x82cfd424
	if ctx.cr[0].eq {
	pc = 0x82CFD424; continue 'dispatch;
	}
	// 82CFD420: 4BB48391  bl 0x828457b0
	ctx.lr = 0x82CFD424;
	sub_828457B0(ctx, base);
	pc = 0x82CFD424; continue 'dispatch;
            }
            0x82CFD424 => {
    //   block [0x82CFD424..0x82CFD43C)
	// 82CFD424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CFD428: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFD42C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFD430: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFD434: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFD438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFD440 size=100
    let mut pc: u32 = 0x82CFD440;
    'dispatch: loop {
        match pc {
            0x82CFD440 => {
    //   block [0x82CFD440..0x82CFD488)
	// 82CFD440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFD444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFD448: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CFD44C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFD450: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CFD454: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82CFD458: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CFD45C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CFD460: 4BFFFF31  bl 0x82cfd390
	ctx.lr = 0x82CFD464;
	sub_82CFD390(ctx, base);
	// 82CFD464: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82CFD468: 40820028  bne 0x82cfd490
	if !ctx.cr[0].eq {
	pc = 0x82CFD490; continue 'dispatch;
	}
	// 82CFD46C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFD470: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFD474: 409A0014  bne cr6, 0x82cfd488
	if !ctx.cr[6].eq {
	pc = 0x82CFD488; continue 'dispatch;
	}
	// 82CFD478: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFD47C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFD480: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CFD484: 419A0008  beq cr6, 0x82cfd48c
	if ctx.cr[6].eq {
	pc = 0x82CFD48C; continue 'dispatch;
	}
	pc = 0x82CFD488; continue 'dispatch;
            }
            0x82CFD488 => {
    //   block [0x82CFD488..0x82CFD48C)
	// 82CFD488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82CFD48C; continue 'dispatch;
            }
            0x82CFD48C => {
    //   block [0x82CFD48C..0x82CFD490)
	// 82CFD48C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFD490; continue 'dispatch;
            }
            0x82CFD490 => {
    //   block [0x82CFD490..0x82CFD4A4)
	// 82CFD490: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CFD494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFD498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFD49C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFD4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFD4A8 size=216
    let mut pc: u32 = 0x82CFD4A8;
    'dispatch: loop {
        match pc {
            0x82CFD4A8 => {
    //   block [0x82CFD4A8..0x82CFD4F4)
	// 82CFD4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFD4AC: 4BFABF5D  bl 0x82ca9408
	ctx.lr = 0x82CFD4B0;
	sub_82CA93D0(ctx, base);
	// 82CFD4B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFD4B4: 485BC5A1  bl 0x832b9a54
	ctx.lr = 0x82CFD4B8;
	// extern call 0x832B9A54 → crate::xam::XamGetSystemVersion
	crate::xam::XamGetSystemVersion(ctx, base);
	// 82CFD4B8: 3D600008  lis r11, 8
	ctx.r[11].s64 = 524288;
	// 82CFD4BC: 546A022E  rlwinm r10, r3, 0, 8, 0x17
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFD4C0: 616BA100  ori r11, r11, 0xa100
	ctx.r[11].u64 = ctx.r[11].u64 | 41216;
	// 82CFD4C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFD4C8: 40980098  bge cr6, 0x82cfd560
	if !ctx.cr[6].lt {
	pc = 0x82CFD560; continue 'dispatch;
	}
	// 82CFD4CC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82CFD4D0: 3B8B04AC  addi r28, r11, 0x4ac
	ctx.r[28].s64 = ctx.r[11].s64 + 1196;
	// 82CFD4D4: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82CFD4D8: 485BC48D  bl 0x832b9964
	ctx.lr = 0x82CFD4DC;
	// extern call 0x832B9964 → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82CFD4DC: 3FA08333  lis r29, -0x7ccd
	ctx.r[29].s64 = -2093809664;
	// 82CFD4E0: 817D72E8  lwz r11, 0x72e8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(29416 as u32) ) } as u64;
	// 82CFD4E4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82CFD4E8: 409A000C  bne cr6, 0x82cfd4f4
	if !ctx.cr[6].eq {
	pc = 0x82CFD4F4; continue 'dispatch;
	}
	// 82CFD4EC: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82CFD4F0: 48000064  b 0x82cfd554
	pc = 0x82CFD554; continue 'dispatch;
            }
            0x82CFD4F4 => {
    //   block [0x82CFD4F4..0x82CFD544)
	// 82CFD4F4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82CFD4F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CFD4FC: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CFD500: 4BFFFE91  bl 0x82cfd390
	ctx.lr = 0x82CFD504;
	sub_82CFD390(ctx, base);
	// 82CFD504: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CFD508: 3FE08333  lis r31, -0x7ccd
	ctx.r[31].s64 = -2093809664;
	// 82CFD50C: 40820038  bne 0x82cfd544
	if !ctx.cr[0].eq {
	pc = 0x82CFD544; continue 'dispatch;
	}
	// 82CFD510: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFD514: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CFD518: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CFD51C: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82CFD520: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CFD524: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82CFD528: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82CFD52C: 917F72EC  stw r11, 0x72ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(29420 as u32), ctx.r[11].u32 ) };
	// 82CFD530: 4BFFFDB9  bl 0x82cfd2e8
	ctx.lr = 0x82CFD534;
	sub_82CFD2E8(ctx, base);
	// 82CFD534: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CFD538: 4082000C  bne 0x82cfd544
	if !ctx.cr[0].eq {
	pc = 0x82CFD544; continue 'dispatch;
	}
	// 82CFD53C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CFD540: 48000010  b 0x82cfd550
	pc = 0x82CFD550; continue 'dispatch;
            }
            0x82CFD544 => {
    //   block [0x82CFD544..0x82CFD550)
	// 82CFD544: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFD548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFD54C: 915F72EC  stw r10, 0x72ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(29420 as u32), ctx.r[10].u32 ) };
	pc = 0x82CFD550; continue 'dispatch;
            }
            0x82CFD550 => {
    //   block [0x82CFD550..0x82CFD554)
	// 82CFD550: 917D72E8  stw r11, 0x72e8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(29416 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFD554; continue 'dispatch;
            }
            0x82CFD554 => {
    //   block [0x82CFD554..0x82CFD560)
	// 82CFD554: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82CFD558: 485BC3FD  bl 0x832b9954
	ctx.lr = 0x82CFD55C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82CFD55C: 48000018  b 0x82cfd574
	pc = 0x82CFD574; continue 'dispatch;
            }
            0x82CFD560 => {
    //   block [0x82CFD560..0x82CFD574)
	// 82CFD560: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CFD564: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CFD568: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CFD56C: 4BFFFD7D  bl 0x82cfd2e8
	ctx.lr = 0x82CFD570;
	sub_82CFD2E8(ctx, base);
	// 82CFD570: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x82CFD574; continue 'dispatch;
            }
            0x82CFD574 => {
    //   block [0x82CFD574..0x82CFD580)
	// 82CFD574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CFD578: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CFD57C: 4BFABEDC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFD580 size=176
    let mut pc: u32 = 0x82CFD580;
    'dispatch: loop {
        match pc {
            0x82CFD580 => {
    //   block [0x82CFD580..0x82CFD5CC)
	// 82CFD580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFD584: 4BFABE85  bl 0x82ca9408
	ctx.lr = 0x82CFD588;
	sub_82CA93D0(ctx, base);
	// 82CFD588: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFD58C: 485BC4C9  bl 0x832b9a54
	ctx.lr = 0x82CFD590;
	// extern call 0x832B9A54 → crate::xam::XamGetSystemVersion
	crate::xam::XamGetSystemVersion(ctx, base);
	// 82CFD590: 3D600008  lis r11, 8
	ctx.r[11].s64 = 524288;
	// 82CFD594: 546A022E  rlwinm r10, r3, 0, 8, 0x17
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFD598: 616BA100  ori r11, r11, 0xa100
	ctx.r[11].u64 = ctx.r[11].u64 | 41216;
	// 82CFD59C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFD5A0: 40980070  bge cr6, 0x82cfd610
	if !ctx.cr[6].lt {
	pc = 0x82CFD610; continue 'dispatch;
	}
	// 82CFD5A4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82CFD5A8: 3B8B04AC  addi r28, r11, 0x4ac
	ctx.r[28].s64 = ctx.r[11].s64 + 1196;
	// 82CFD5AC: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82CFD5B0: 485BC3B5  bl 0x832b9964
	ctx.lr = 0x82CFD5B4;
	// extern call 0x832B9964 → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82CFD5B4: 3FE08333  lis r31, -0x7ccd
	ctx.r[31].s64 = -2093809664;
	// 82CFD5B8: 817F72E8  lwz r11, 0x72e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(29416 as u32) ) } as u64;
	// 82CFD5BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFD5C0: 409A000C  bne cr6, 0x82cfd5cc
	if !ctx.cr[6].eq {
	pc = 0x82CFD5CC; continue 'dispatch;
	}
	// 82CFD5C4: 3BA0065B  li r29, 0x65b
	ctx.r[29].s64 = 1627;
	// 82CFD5C8: 4800003C  b 0x82cfd604
	pc = 0x82CFD604; continue 'dispatch;
            }
            0x82CFD5CC => {
    //   block [0x82CFD5CC..0x82CFD5EC)
	// 82CFD5CC: 3FC08333  lis r30, -0x7ccd
	ctx.r[30].s64 = -2093809664;
	// 82CFD5D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CFD5D4: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CFD5D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CFD5DC: 817E72EC  lwz r11, 0x72ec(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(29420 as u32) ) } as u64;
	// 82CFD5E0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82CFD5E4: 419A0008  beq cr6, 0x82cfd5ec
	if ctx.cr[6].eq {
	pc = 0x82CFD5EC; continue 'dispatch;
	}
	// 82CFD5E8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	pc = 0x82CFD5EC; continue 'dispatch;
            }
            0x82CFD5EC => {
    //   block [0x82CFD5EC..0x82CFD604)
	// 82CFD5EC: 4BFFFCFD  bl 0x82cfd2e8
	ctx.lr = 0x82CFD5F0;
	sub_82CFD2E8(ctx, base);
	// 82CFD5F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFD5F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFD5F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CFD5FC: 917E72EC  stw r11, 0x72ec(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(29420 as u32), ctx.r[11].u32 ) };
	// 82CFD600: 915F72E8  stw r10, 0x72e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(29416 as u32), ctx.r[10].u32 ) };
	pc = 0x82CFD604; continue 'dispatch;
            }
            0x82CFD604 => {
    //   block [0x82CFD604..0x82CFD610)
	// 82CFD604: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82CFD608: 485BC34D  bl 0x832b9954
	ctx.lr = 0x82CFD60C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82CFD60C: 48000018  b 0x82cfd624
	pc = 0x82CFD624; continue 'dispatch;
            }
            0x82CFD610 => {
    //   block [0x82CFD610..0x82CFD624)
	// 82CFD610: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CFD614: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82CFD618: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CFD61C: 4BFFFCCD  bl 0x82cfd2e8
	ctx.lr = 0x82CFD620;
	sub_82CFD2E8(ctx, base);
	// 82CFD620: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	pc = 0x82CFD624; continue 'dispatch;
            }
            0x82CFD624 => {
    //   block [0x82CFD624..0x82CFD630)
	// 82CFD624: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CFD628: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CFD62C: 4BFABE2C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFD630 size=120
    let mut pc: u32 = 0x82CFD630;
    'dispatch: loop {
        match pc {
            0x82CFD630 => {
    //   block [0x82CFD630..0x82CFD660)
	// 82CFD630: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82CFD634: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82CFD638: 90650000  stw r3, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82CFD63C: 546A0739  rlwinm. r10, r3, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CFD640: 91650008  stw r11, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82CFD644: 4182001C  beq 0x82cfd660
	if ctx.cr[0].eq {
	pc = 0x82CFD660; continue 'dispatch;
	}
	// 82CFD648: 546BF7FE  rlwinm r11, r3, 0x1e, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 82CFD64C: 5469FFFE  rlwinm r9, r3, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 82CFD650: 546A07FE  clrlwi r10, r3, 0x1f
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 82CFD654: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CFD658: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CFD65C: 91650008  stw r11, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFD660; continue 'dispatch;
            }
            0x82CFD660 => {
    //   block [0x82CFD660..0x82CFD668)
	// 82CFD660: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFD664: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFD668; continue 'dispatch;
            }
            0x82CFD668 => {
    //   block [0x82CFD668..0x82CFD6A8)
	// 82CFD668: 3943FFFF  addi r10, r3, -1
	ctx.r[10].s64 = ctx.r[3].s64 + -1;
	// 82CFD66C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFD670: 7D431839  and. r3, r10, r3
	ctx.r[3].u64 = ctx.r[10].u64 & ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CFD674: 4082FFF4  bne 0x82cfd668
	if !ctx.cr[0].eq {
	pc = 0x82CFD668; continue 'dispatch;
	}
	// 82CFD678: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFD67C: D021FFF0  stfs f1, -0x10(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82CFD680: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82CFD684: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82CFD688: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CFD68C: 9125000C  stw r9, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82CFD690: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 82CFD694: C001FFF0  lfs f0, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD698: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82CFD69C: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82CFD6A0: 91650010  stw r11, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82CFD6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFD6A8 size=172
    let mut pc: u32 = 0x82CFD6A8;
    'dispatch: loop {
        match pc {
            0x82CFD6A8 => {
    //   block [0x82CFD6A8..0x82CFD71C)
	// 82CFD6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFD6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFD6B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CFD6B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CFD6B8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82CFD6BC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFD6C0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82CFD6C4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFD6C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFD6CC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CFD6D0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CFD6D4: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFD6D8: C0080C38  lfs f0, 0xc38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD6DC: C3E90C18  lfs f31, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82CFD6E0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFD6E4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFD6E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFD6EC: 40990030  ble cr6, 0x82cfd71c
	if !ctx.cr[6].gt {
	pc = 0x82CFD71C; continue 'dispatch;
	}
	// 82CFD6F0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82CFD6F4: 389E001C  addi r4, r30, 0x1c
	ctx.r[4].s64 = ctx.r[30].s64 + 28;
	// 82CFD6F8: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 82CFD6FC: 48001F6D  bl 0x82cff668
	ctx.lr = 0x82CFD700;
	sub_82CFF668(ctx, base);
	// 82CFD700: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82CFD704: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82CFD708: 48001F39  bl 0x82cff640
	ctx.lr = 0x82CFD70C;
	sub_82CFF640(ctx, base);
	// 82CFD70C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFD710: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CFD714: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD718: EFE10024  fdivs f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x82CFD71C; continue 'dispatch;
            }
            0x82CFD71C => {
    //   block [0x82CFD71C..0x82CFD754)
	// 82CFD71C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82CFD720: 4B563221  bl 0x82260940
	ctx.lr = 0x82CFD724;
	sub_82260940(ctx, base);
	// 82CFD724: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFD728: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFD72C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFD730: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82CFD734: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82CFD738: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CFD73C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFD740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFD744: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFD748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CFD74C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFD750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFD758 size=312
    let mut pc: u32 = 0x82CFD758;
    'dispatch: loop {
        match pc {
            0x82CFD758 => {
    //   block [0x82CFD758..0x82CFD774)
	// 82CFD758: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFD75C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CFD760: 3948FFFF  addi r10, r8, -1
	ctx.r[10].s64 = ctx.r[8].s64 + -1;
	// 82CFD764: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 82CFD768: 41980070  blt cr6, 0x82cfd7d8
	if ctx.cr[6].lt {
	pc = 0x82CFD7D8; continue 'dispatch;
	}
	// 82CFD76C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFD770: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	pc = 0x82CFD774; continue 'dispatch;
            }
            0x82CFD774 => {
    //   block [0x82CFD774..0x82CFD7D8)
	// 82CFD774: 812AFFF0  lwz r9, -0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82CFD778: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 82CFD77C: C001FFF0  lfs f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD780: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82CFD784: 419900A4  bgt cr6, 0x82cfd828
	if ctx.cr[6].gt {
	pc = 0x82CFD828; continue 'dispatch;
	}
	// 82CFD788: 812AFFF8  lwz r9, -8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFD78C: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 82CFD790: C001FFF4  lfs f0, -0xc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD794: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82CFD798: 4199007C  bgt cr6, 0x82cfd814
	if ctx.cr[6].gt {
	pc = 0x82CFD814; continue 'dispatch;
	}
	// 82CFD79C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFD7A0: 9121FFF8  stw r9, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 82CFD7A4: C001FFF8  lfs f0, -8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD7A8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82CFD7AC: 41990070  bgt cr6, 0x82cfd81c
	if ctx.cr[6].gt {
	pc = 0x82CFD81C; continue 'dispatch;
	}
	// 82CFD7B0: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFD7B4: 9121FFFC  stw r9, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 82CFD7B8: C001FFFC  lfs f0, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD7BC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82CFD7C0: 41990064  bgt cr6, 0x82cfd824
	if ctx.cr[6].gt {
	pc = 0x82CFD824; continue 'dispatch;
	}
	// 82CFD7C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFD7C8: 3928FFFD  addi r9, r8, -3
	ctx.r[9].s64 = ctx.r[8].s64 + -3;
	// 82CFD7CC: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82CFD7D0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CFD7D4: 4198FFA0  blt cr6, 0x82cfd774
	if ctx.cr[6].lt {
	pc = 0x82CFD774; continue 'dispatch;
	}
	pc = 0x82CFD7D8; continue 'dispatch;
            }
            0x82CFD7D8 => {
    //   block [0x82CFD7D8..0x82CFD7EC)
	// 82CFD7D8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFD7DC: 409800B4  bge cr6, 0x82cfd890
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82CFD890);
		return;
	}
	// 82CFD7E0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFD7E4: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFD7E8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	pc = 0x82CFD7EC; continue 'dispatch;
            }
            0x82CFD7EC => {
    //   block [0x82CFD7EC..0x82CFD814)
	// 82CFD7EC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFD7F0: 9121FFFC  stw r9, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 82CFD7F4: C001FFFC  lfs f0, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD7F8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82CFD7FC: 4199002C  bgt cr6, 0x82cfd828
	if ctx.cr[6].gt {
	pc = 0x82CFD828; continue 'dispatch;
	}
	// 82CFD800: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFD804: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CFD808: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFD80C: 4198FFE0  blt cr6, 0x82cfd7ec
	if ctx.cr[6].lt {
	pc = 0x82CFD7EC; continue 'dispatch;
	}
	// 82CFD810: 48000018  b 0x82cfd828
	pc = 0x82CFD828; continue 'dispatch;
            }
            0x82CFD814 => {
    //   block [0x82CFD814..0x82CFD81C)
	// 82CFD814: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFD818: 48000010  b 0x82cfd828
	pc = 0x82CFD828; continue 'dispatch;
            }
            0x82CFD81C => {
    //   block [0x82CFD81C..0x82CFD824)
	// 82CFD81C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CFD820: 48000008  b 0x82cfd828
	pc = 0x82CFD828; continue 'dispatch;
            }
            0x82CFD824 => {
    //   block [0x82CFD824..0x82CFD828)
	// 82CFD824: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	pc = 0x82CFD828; continue 'dispatch;
            }
            0x82CFD828 => {
    //   block [0x82CFD828..0x82CFD890)
	// 82CFD828: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFD82C: 40980064  bge cr6, 0x82cfd890
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82CFD890);
		return;
	}
	// 82CFD830: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFD834: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFD838: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CFD83C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFD840: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFD844: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82CFD848: 80CBFFF8  lwz r6, -8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFD84C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CFD850: 9141FFFC  stw r10, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82CFD854: C001FFFC  lfs f0, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD858: 9121FFFC  stw r9, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 82CFD85C: C1A1FFFC  lfs f13, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFD860: 9101FFFC  stw r8, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 82CFD864: C181FFFC  lfs f12, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFD868: 90E1FFFC  stw r7, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 82CFD86C: C161FFFC  lfs f11, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFD870: 90C1FFFC  stw r6, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 82CFD874: C141FFFC  lfs f10, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFD878: ED0D6028  fsubs f8, f13, f12
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CFD87C: ECE05028  fsubs f7, f0, f10
	ctx.f[7].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82CFD880: ED215028  fsubs f9, f1, f10
	ctx.f[9].f64 = (((ctx.f[1].f64 - ctx.f[10].f64) as f32) as f64);
	// 82CFD884: ECC83824  fdivs f6, f8, f7
	ctx.f[6].f64 = ((ctx.f[8].f64 / ctx.f[7].f64) as f32) as f64;
	// 82CFD888: EC265A7A  fmadds f1, f6, f9, f11
	ctx.f[1].f64 = (((ctx.f[6].f64 * ctx.f[9].f64 + ctx.f[11].f64) as f32) as f64);
	// 82CFD88C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFD8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFD8B0 size=1204
    let mut pc: u32 = 0x82CFD8B0;
    'dispatch: loop {
        match pc {
            0x82CFD8B0 => {
    //   block [0x82CFD8B0..0x82CFD924)
	// 82CFD8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFD8B4: 4BFABB59  bl 0x82ca940c
	ctx.lr = 0x82CFD8B8;
	sub_82CA93D0(ctx, base);
	// 82CFD8B8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82CFD8BC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFD8C0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82CFD8C4: 8124005C  lwz r9, 0x5c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) } as u64;
	// 82CFD8C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFD8CC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFD8D0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CFD8D4: 54A6077A  rlwinm r6, r5, 0, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFD8D8: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFD8DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CFD8E0: C06A0C84  lfs f3, 0xc84(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3204 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CFD8E4: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 82CFD8E8: C0880C14  lfs f4, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CFD8EC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CFD8F0: C0470C18  lfs f2, 0xc18(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3096 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CFD8F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CFD8F8: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFD8FC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFD900: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFD904: ECA06824  fdivs f5, f0, f13
	ctx.f[5].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82CFD908: 419A006C  beq cr6, 0x82cfd974
	if ctx.cr[6].eq {
	pc = 0x82CFD974; continue 'dispatch;
	}
	// 82CFD90C: 80640050  lwz r3, 0x50(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFD910: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 82CFD914: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFD918: 419A000C  beq cr6, 0x82cfd924
	if ctx.cr[6].eq {
	pc = 0x82CFD924; continue 'dispatch;
	}
	// 82CFD91C: 4BFFFE3D  bl 0x82cfd758
	ctx.lr = 0x82CFD920;
	sub_82CFD758(ctx, base);
	// 82CFD920: 48000048  b 0x82cfd968
	pc = 0x82CFD968; continue 'dispatch;
            }
            0x82CFD924 => {
    //   block [0x82CFD924..0x82CFD968)
	// 82CFD924: D0810050  stfs f4, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFD928: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFD92C: D0610050  stfs f3, 0x50(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFD930: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFD934: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFD938: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82CFD93C: D0810050  stfs f4, 0x50(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFD940: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82CFD944: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82CFD948: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82CFD94C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82CFD950: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFD954: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFD958: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82CFD95C: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 82CFD960: 90E10070  stw r7, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[7].u32 ) };
	// 82CFD964: 4BFFFDF5  bl 0x82cfd758
	ctx.lr = 0x82CFD968;
	sub_82CFD758(ctx, base);
	pc = 0x82CFD968; continue 'dispatch;
            }
            0x82CFD968 => {
    //   block [0x82CFD968..0x82CFD974)
	// 82CFD968: D0210054  stfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFD96C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFD970: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFD974; continue 'dispatch;
            }
            0x82CFD974 => {
    //   block [0x82CFD974..0x82CFD998)
	// 82CFD974: 54AB0738  rlwinm r11, r5, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFD978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFD97C: 419A006C  beq cr6, 0x82cfd9e8
	if ctx.cr[6].eq {
	pc = 0x82CFD9E8; continue 'dispatch;
	}
	// 82CFD980: 80640054  lwz r3, 0x54(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFD984: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 82CFD988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFD98C: 419A000C  beq cr6, 0x82cfd998
	if ctx.cr[6].eq {
	pc = 0x82CFD998; continue 'dispatch;
	}
	// 82CFD990: 4BFFFDC9  bl 0x82cfd758
	ctx.lr = 0x82CFD994;
	sub_82CFD758(ctx, base);
	// 82CFD994: 48000048  b 0x82cfd9dc
	pc = 0x82CFD9DC; continue 'dispatch;
            }
            0x82CFD998 => {
    //   block [0x82CFD998..0x82CFD9DC)
	// 82CFD998: D0810054  stfs f4, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFD99C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82CFD9A0: D0610050  stfs f3, 0x50(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFD9A4: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFD9A8: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82CFD9AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82CFD9B0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82CFD9B4: 90E10074  stw r7, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[7].u32 ) };
	// 82CFD9B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFD9BC: D0610054  stfs f3, 0x54(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFD9C0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFD9C4: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFD9C8: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82CFD9CC: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFD9D0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82CFD9D4: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 82CFD9D8: 4BFFFD81  bl 0x82cfd758
	ctx.lr = 0x82CFD9DC;
	sub_82CFD758(ctx, base);
	pc = 0x82CFD9DC; continue 'dispatch;
            }
            0x82CFD9DC => {
    //   block [0x82CFD9DC..0x82CFD9E8)
	// 82CFD9DC: D0210054  stfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFD9E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFD9E4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFD9E8; continue 'dispatch;
            }
            0x82CFD9E8 => {
    //   block [0x82CFD9E8..0x82CFDA0C)
	// 82CFD9E8: 54AB06F6  rlwinm r11, r5, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFD9EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFD9F0: 419A006C  beq cr6, 0x82cfda5c
	if ctx.cr[6].eq {
	pc = 0x82CFDA5C; continue 'dispatch;
	}
	// 82CFD9F4: 80640058  lwz r3, 0x58(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 82CFD9F8: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 82CFD9FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFDA00: 419A000C  beq cr6, 0x82cfda0c
	if ctx.cr[6].eq {
	pc = 0x82CFDA0C; continue 'dispatch;
	}
	// 82CFDA04: 4BFFFD55  bl 0x82cfd758
	ctx.lr = 0x82CFDA08;
	sub_82CFD758(ctx, base);
	// 82CFDA08: 48000048  b 0x82cfda50
	pc = 0x82CFDA50; continue 'dispatch;
            }
            0x82CFDA0C => {
    //   block [0x82CFDA0C..0x82CFDA50)
	// 82CFDA0C: D0410054  stfs f2, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFDA10: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFDA14: D0810050  stfs f4, 0x50(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFDA18: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFDA1C: D0810058  stfs f4, 0x58(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82CFDA20: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82CFDA24: D0410060  stfs f2, 0x60(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82CFDA28: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82CFDA2C: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82CFDA30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82CFDA34: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82CFDA38: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82CFDA3C: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82CFDA40: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82CFDA44: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82CFDA48: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82CFDA4C: 4BFFFD0D  bl 0x82cfd758
	ctx.lr = 0x82CFDA50;
	sub_82CFD758(ctx, base);
	pc = 0x82CFDA50; continue 'dispatch;
            }
            0x82CFDA50 => {
    //   block [0x82CFDA50..0x82CFDA5C)
	// 82CFDA50: D0210060  stfs f1, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82CFDA54: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82CFDA58: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFDA5C; continue 'dispatch;
            }
            0x82CFDA5C => {
    //   block [0x82CFDA5C..0x82CFDA84)
	// 82CFDA5C: 54AB07FE  clrlwi r11, r5, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 82CFDA60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFDA64: 419A02F4  beq cr6, 0x82cfdd58
	if ctx.cr[6].eq {
	pc = 0x82CFDD58; continue 'dispatch;
	}
	// 82CFDA68: 80640048  lwz r3, 0x48(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CFDA6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFDA70: 419A0014  beq cr6, 0x82cfda84
	if ctx.cr[6].eq {
	pc = 0x82CFDA84; continue 'dispatch;
	}
	// 82CFDA74: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 82CFDA78: 4BFFFCE1  bl 0x82cfd758
	ctx.lr = 0x82CFDA7C;
	sub_82CFD758(ctx, base);
	// 82CFDA7C: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 82CFDA80: 48000018  b 0x82cfda98
	pc = 0x82CFDA98; continue 'dispatch;
            }
            0x82CFDA84 => {
    //   block [0x82CFDA84..0x82CFDA94)
	// 82CFDA84: FC002090  fmr f0, f4
	ctx.f[0].f64 = ctx.f[4].f64;
	// 82CFDA88: FF052000  fcmpu cr6, f5, f4
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[4].f64);
	// 82CFDA8C: 40990008  ble cr6, 0x82cfda94
	if !ctx.cr[6].gt {
	pc = 0x82CFDA94; continue 'dispatch;
	}
	// 82CFDA90: EC042824  fdivs f0, f4, f5
	ctx.f[0].f64 = ((ctx.f[4].f64 / ctx.f[5].f64) as f32) as f64;
	pc = 0x82CFDA94; continue 'dispatch;
            }
            0x82CFDA94 => {
    //   block [0x82CFDA94..0x82CFDA98)
	// 82CFDA94: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	pc = 0x82CFDA98; continue 'dispatch;
            }
            0x82CFDA98 => {
    //   block [0x82CFDA98..0x82CFDAB8)
	// 82CFDA98: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFDA9C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CFDAA0: 409A00A8  bne cr6, 0x82cfdb48
	if !ctx.cr[6].eq {
	pc = 0x82CFDB48; continue 'dispatch;
	}
	// 82CFDAA4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDAA8: D06A0000  stfs f3, 0(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFDAAC: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDAB0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82CFDAB4: 40990028  ble cr6, 0x82cfdadc
	if !ctx.cr[6].gt {
	pc = 0x82CFDADC; continue 'dispatch;
	}
	pc = 0x82CFDAB8; continue 'dispatch;
            }
            0x82CFDAB8 => {
    //   block [0x82CFDAB8..0x82CFDADC)
	// 82CFDAB8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDABC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDAC0: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82CFDAC4: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFDAC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFDACC: 7C474D2E  stfsx f2, r7, r9
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82CFDAD0: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDAD4: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CFDAD8: 4198FFE0  blt cr6, 0x82cfdab8
	if ctx.cr[6].lt {
	pc = 0x82CFDAB8; continue 'dispatch;
	}
	pc = 0x82CFDADC; continue 'dispatch;
            }
            0x82CFDADC => {
    //   block [0x82CFDADC..0x82CFDB1C)
	// 82CFDADC: 54AB039C  rlwinm r11, r5, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDAE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFDAE4: 419A0274  beq cr6, 0x82cfdd58
	if ctx.cr[6].eq {
	pc = 0x82CFDD58; continue 'dispatch;
	}
	// 82CFDAE8: 8064004C  lwz r3, 0x4c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CFDAEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFDAF0: 419A002C  beq cr6, 0x82cfdb1c
	if ctx.cr[6].eq {
	pc = 0x82CFDB1C; continue 'dispatch;
	}
	// 82CFDAF4: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 82CFDAF8: 4BFFFC61  bl 0x82cfd758
	ctx.lr = 0x82CFDAFC;
	sub_82CFD758(ctx, base);
	// 82CFDAFC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDB00: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82CFDB04: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDB08: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFDB0C: 7C09552E  stfsx f0, r9, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82CFDB10: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CFDB14: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFDB18: 4BFAB944  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFDB1C => {
    //   block [0x82CFDB1C..0x82CFDB2C)
	// 82CFDB1C: FC002090  fmr f0, f4
	ctx.f[0].f64 = ctx.f[4].f64;
	// 82CFDB20: FF052000  fcmpu cr6, f5, f4
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[4].f64);
	// 82CFDB24: 40990008  ble cr6, 0x82cfdb2c
	if !ctx.cr[6].gt {
	pc = 0x82CFDB2C; continue 'dispatch;
	}
	// 82CFDB28: EC042824  fdivs f0, f4, f5
	ctx.f[0].f64 = ((ctx.f[4].f64 / ctx.f[5].f64) as f32) as f64;
	pc = 0x82CFDB2C; continue 'dispatch;
            }
            0x82CFDB2C => {
    //   block [0x82CFDB2C..0x82CFDB48)
	// 82CFDB2C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDB30: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDB34: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFDB38: 7C09552E  stfsx f0, r9, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82CFDB3C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CFDB40: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFDB44: 4BFAB918  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFDB48 => {
    //   block [0x82CFDB48..0x82CFDB60)
	// 82CFDB48: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CFDB4C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CFDB50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFDB54: C3EA6924  lfs f31, 0x6924(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26916 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82CFDB58: 419A007C  beq cr6, 0x82cfdbd4
	if ctx.cr[6].eq {
	pc = 0x82CFDBD4; continue 'dispatch;
	}
	// 82CFDB5C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82CFDB60; continue 'dispatch;
            }
            0x82CFDB60 => {
    //   block [0x82CFDB60..0x82CFDB70)
	// 82CFDB60: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDB64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFDB68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFDB6C: 4099002C  ble cr6, 0x82cfdb98
	if !ctx.cr[6].gt {
	pc = 0x82CFDB98; continue 'dispatch;
	}
	pc = 0x82CFDB70; continue 'dispatch;
            }
            0x82CFDB70 => {
    //   block [0x82CFDB70..0x82CFDB98)
	// 82CFDB70: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDB74: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDB78: 7D4A59D6  mullw r10, r10, r11
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFDB7C: 7CEAF214  add r7, r10, r30
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82CFDB80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFDB84: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFDB88: 7C46452E  stfsx f2, r6, r8
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82CFDB8C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDB90: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82CFDB94: 4198FFDC  blt cr6, 0x82cfdb70
	if ctx.cr[6].lt {
	pc = 0x82CFDB70; continue 'dispatch;
	}
	pc = 0x82CFDB98; continue 'dispatch;
            }
            0x82CFDB98 => {
    //   block [0x82CFDB98..0x82CFDBB4)
	// 82CFDB98: 81640044  lwz r11, 0x44(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CFDB9C: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDBA0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82CFDBA4: 419A0010  beq cr6, 0x82cfdbb4
	if ctx.cr[6].eq {
	pc = 0x82CFDBB4; continue 'dispatch;
	}
	// 82CFDBA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDBAC: 7C695D2E  stfsx f3, r9, r11
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFDBB0: 48000010  b 0x82cfdbc0
	pc = 0x82CFDBC0; continue 'dispatch;
            }
            0x82CFDBB4 => {
    //   block [0x82CFDBB4..0x82CFDBC0)
	// 82CFDBB4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDBB8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82CFDBBC: 409A0018  bne cr6, 0x82cfdbd4
	if !ctx.cr[6].eq {
	pc = 0x82CFDBD4; continue 'dispatch;
	}
	pc = 0x82CFDBC0; continue 'dispatch;
            }
            0x82CFDBC0 => {
    //   block [0x82CFDBC0..0x82CFDBD4)
	// 82CFDBC0: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFDBC4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82CFDBC8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CFDBCC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFDBD0: 4198FF90  blt cr6, 0x82cfdb60
	if ctx.cr[6].lt {
	pc = 0x82CFDB60; continue 'dispatch;
	}
	pc = 0x82CFDBD4; continue 'dispatch;
            }
            0x82CFDBD4 => {
    //   block [0x82CFDBD4..0x82CFDBFC)
	// 82CFDBD4: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFDBD8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFDBDC: 409800F0  bge cr6, 0x82cfdccc
	if !ctx.cr[6].lt {
	pc = 0x82CFDCCC; continue 'dispatch;
	}
	// 82CFDBE0: 8064004C  lwz r3, 0x4c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CFDBE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFDBE8: 419A0014  beq cr6, 0x82cfdbfc
	if ctx.cr[6].eq {
	pc = 0x82CFDBFC; continue 'dispatch;
	}
	// 82CFDBEC: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 82CFDBF0: 4BFFFB69  bl 0x82cfd758
	ctx.lr = 0x82CFDBF4;
	sub_82CFD758(ctx, base);
	// 82CFDBF4: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82CFDBF8: 48000014  b 0x82cfdc0c
	pc = 0x82CFDC0C; continue 'dispatch;
            }
            0x82CFDBFC => {
    //   block [0x82CFDBFC..0x82CFDC0C)
	// 82CFDBFC: FC002090  fmr f0, f4
	ctx.f[0].f64 = ctx.f[4].f64;
	// 82CFDC00: FF052000  fcmpu cr6, f5, f4
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[4].f64);
	// 82CFDC04: 40990008  ble cr6, 0x82cfdc0c
	if !ctx.cr[6].gt {
	pc = 0x82CFDC0C; continue 'dispatch;
	}
	// 82CFDC08: EC042824  fdivs f0, f4, f5
	ctx.f[0].f64 = ((ctx.f[4].f64 / ctx.f[5].f64) as f32) as f64;
	pc = 0x82CFDC0C; continue 'dispatch;
            }
            0x82CFDC0C => {
    //   block [0x82CFDC0C..0x82CFDC3C)
	// 82CFDC0C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDC10: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 82CFDC14: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDC18: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDC1C: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CFDC20: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CFDC24: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFDC28: 7C06452E  stfsx f0, r6, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82CFDC2C: 80A4003C  lwz r5, 0x3c(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFDC30: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82CFDC34: 40980124  bge cr6, 0x82cfdd58
	if !ctx.cr[6].lt {
	pc = 0x82CFDD58; continue 'dispatch;
	}
	// 82CFDC38: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x82CFDC3C; continue 'dispatch;
            }
            0x82CFDC3C => {
    //   block [0x82CFDC3C..0x82CFDC4C)
	// 82CFDC3C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDC40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFDC44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFDC48: 4099002C  ble cr6, 0x82cfdc74
	if !ctx.cr[6].gt {
	pc = 0x82CFDC74; continue 'dispatch;
	}
	pc = 0x82CFDC4C; continue 'dispatch;
            }
            0x82CFDC4C => {
    //   block [0x82CFDC4C..0x82CFDC74)
	// 82CFDC4C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDC50: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDC54: 7D2959D6  mullw r9, r9, r11
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFDC58: 7CC95214  add r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CFDC5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFDC60: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFDC64: 7C453D2E  stfsx f2, r5, r7
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82CFDC68: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDC6C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82CFDC70: 4198FFDC  blt cr6, 0x82cfdc4c
	if ctx.cr[6].lt {
	pc = 0x82CFDC4C; continue 'dispatch;
	}
	pc = 0x82CFDC74; continue 'dispatch;
            }
            0x82CFDC74 => {
    //   block [0x82CFDC74..0x82CFDC90)
	// 82CFDC74: 81640044  lwz r11, 0x44(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CFDC78: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDC7C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82CFDC80: 419A0010  beq cr6, 0x82cfdc90
	if ctx.cr[6].eq {
	pc = 0x82CFDC90; continue 'dispatch;
	}
	// 82CFDC84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDC88: 7C685D2E  stfsx f3, r8, r11
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFDC8C: 48000020  b 0x82cfdcac
	pc = 0x82CFDCAC; continue 'dispatch;
            }
            0x82CFDC90 => {
    //   block [0x82CFDC90..0x82CFDCAC)
	// 82CFDC90: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDC94: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDC98: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDC9C: 7D6B49D6  mullw r11, r11, r9
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CFDCA0: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CFDCA4: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFDCA8: 7C053D2E  stfsx f0, r5, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	pc = 0x82CFDCAC; continue 'dispatch;
            }
            0x82CFDCAC => {
    //   block [0x82CFDCAC..0x82CFDCCC)
	// 82CFDCAC: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFDCB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CFDCB4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CFDCB8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFDCBC: 4198FF80  blt cr6, 0x82cfdc3c
	if ctx.cr[6].lt {
	pc = 0x82CFDC3C; continue 'dispatch;
	}
	// 82CFDCC0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CFDCC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFDCC8: 4BFAB794  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFDCCC => {
    //   block [0x82CFDCCC..0x82CFDCF4)
	// 82CFDCCC: 54AB039C  rlwinm r11, r5, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDCD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFDCD4: 419A0084  beq cr6, 0x82cfdd58
	if ctx.cr[6].eq {
	pc = 0x82CFDD58; continue 'dispatch;
	}
	// 82CFDCD8: 8064004C  lwz r3, 0x4c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CFDCDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFDCE0: 419A0014  beq cr6, 0x82cfdcf4
	if ctx.cr[6].eq {
	pc = 0x82CFDCF4; continue 'dispatch;
	}
	// 82CFDCE4: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 82CFDCE8: 4BFFFA71  bl 0x82cfd758
	ctx.lr = 0x82CFDCEC;
	sub_82CFD758(ctx, base);
	// 82CFDCEC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82CFDCF0: 48000014  b 0x82cfdd04
	pc = 0x82CFDD04; continue 'dispatch;
            }
            0x82CFDCF4 => {
    //   block [0x82CFDCF4..0x82CFDD04)
	// 82CFDCF4: FC002090  fmr f0, f4
	ctx.f[0].f64 = ctx.f[4].f64;
	// 82CFDCF8: FF052000  fcmpu cr6, f5, f4
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[4].f64);
	// 82CFDCFC: 40990008  ble cr6, 0x82cfdd04
	if !ctx.cr[6].gt {
	pc = 0x82CFDD04; continue 'dispatch;
	}
	// 82CFDD00: EC042824  fdivs f0, f4, f5
	ctx.f[0].f64 = ((ctx.f[4].f64 / ctx.f[5].f64) as f32) as f64;
	pc = 0x82CFDD04; continue 'dispatch;
            }
            0x82CFDD04 => {
    //   block [0x82CFDD04..0x82CFDD2C)
	// 82CFDD04: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDD08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFDD0C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CFDD10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFDD14: F9210070  std r9, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u64 ) };
	// 82CFDD18: C9A10070  lfd f13, 0x70(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82CFDD1C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CFDD20: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CFDD24: EC005824  fdivs f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82CFDD28: 419A0030  beq cr6, 0x82cfdd58
	if ctx.cr[6].eq {
	pc = 0x82CFDD58; continue 'dispatch;
	}
	pc = 0x82CFDD2C; continue 'dispatch;
            }
            0x82CFDD2C => {
    //   block [0x82CFDD2C..0x82CFDD58)
	// 82CFDD2C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDD30: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDD34: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDD38: 7D4A49D6  mullw r10, r10, r9
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFDD3C: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFDD40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFDD44: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFDD48: 7C06452E  stfsx f0, r6, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82CFDD4C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDD50: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82CFDD54: 4198FFD8  blt cr6, 0x82cfdd2c
	if ctx.cr[6].lt {
	pc = 0x82CFDD2C; continue 'dispatch;
	}
	pc = 0x82CFDD58; continue 'dispatch;
            }
            0x82CFDD58 => {
    //   block [0x82CFDD58..0x82CFDD64)
	// 82CFDD58: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CFDD5C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFDD60: 4BFAB6FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFDD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFDD68 size=1020
    let mut pc: u32 = 0x82CFDD68;
    'dispatch: loop {
        match pc {
            0x82CFDD68 => {
    //   block [0x82CFDD68..0x82CFDDD0)
	// 82CFDD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFDD6C: 4BFAB69D  bl 0x82ca9408
	ctx.lr = 0x82CFDD70;
	sub_82CA93D0(ctx, base);
	// 82CFDD70: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 82CFDD74: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82CFDD78: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CFDD7C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFDD80: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82CFDD84: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFDD88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CFDD8C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82CFDD90: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82CFDD94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDD98: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82CFDD9C: C0090C18  lfs f0, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDDA0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFDDA4: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFDDA8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDDAC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFDDB0: 409A0060  bne cr6, 0x82cfde10
	if !ctx.cr[6].eq {
	pc = 0x82CFDE10; continue 'dispatch;
	}
	// 82CFDDB4: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CFDDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFDDBC: 419A0014  beq cr6, 0x82cfddd0
	if ctx.cr[6].eq {
	pc = 0x82CFDDD0; continue 'dispatch;
	}
	// 82CFDDC0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDDC4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDDC8: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFDDCC: 48000008  b 0x82cfddd4
	pc = 0x82CFDDD4; continue 'dispatch;
            }
            0x82CFDDD0 => {
    //   block [0x82CFDDD0..0x82CFDDD4)
	// 82CFDDD0: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFDDD4; continue 'dispatch;
            }
            0x82CFDDD4 => {
    //   block [0x82CFDDD4..0x82CFDDF0)
	// 82CFDDD4: 57C9073A  rlwinm r9, r30, 0, 0x1c, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDDD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFDDDC: 419A0014  beq cr6, 0x82cfddf0
	if ctx.cr[6].eq {
	pc = 0x82CFDDF0; continue 'dispatch;
	}
	// 82CFDDE0: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFDDE4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDDE8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDDEC: 48000008  b 0x82cfddf4
	pc = 0x82CFDDF4; continue 'dispatch;
            }
            0x82CFDDF0 => {
    //   block [0x82CFDDF0..0x82CFDDF4)
	// 82CFDDF0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFDDF4; continue 'dispatch;
            }
            0x82CFDDF4 => {
    //   block [0x82CFDDF4..0x82CFDE10)
	// 82CFDDF4: 57C906F6  rlwinm r9, r30, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDDF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFDDFC: 419A02A0  beq cr6, 0x82cfe09c
	if ctx.cr[6].eq {
	pc = 0x82CFE09C; continue 'dispatch;
	}
	// 82CFDE00: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFDE04: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CFDE08: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDE0C: 48000294  b 0x82cfe0a0
	pc = 0x82CFE0A0; continue 'dispatch;
            }
            0x82CFDE10 => {
    //   block [0x82CFDE10..0x82CFDEC0)
	// 82CFDE10: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDE14: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CFDE18: C0086924  lfs f0, 0x6924(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDE1C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDE20: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDE24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFDE28: 419A0218  beq cr6, 0x82cfe040
	if ctx.cr[6].eq {
	pc = 0x82CFE040; continue 'dispatch;
	}
	// 82CFDE2C: 813D0024  lwz r9, 0x24(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFDE30: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFDE34: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDE38: C0080C38  lfs f0, 0xc38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDE3C: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDE40: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFDE44: 409901FC  ble cr6, 0x82cfe040
	if !ctx.cr[6].gt {
	pc = 0x82CFE040; continue 'dispatch;
	}
	// 82CFDE48: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82CFDE4C: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 82CFDE50: 386A0018  addi r3, r10, 0x18
	ctx.r[3].s64 = ctx.r[10].s64 + 24;
	// 82CFDE54: 48001815  bl 0x82cff668
	ctx.lr = 0x82CFDE58;
	sub_82CFF668(ctx, base);
	// 82CFDE58: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82CFDE5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82CFDE60: 480017E1  bl 0x82cff640
	ctx.lr = 0x82CFDE64;
	sub_82CFF640(ctx, base);
	// 82CFDE64: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDE68: 815D0024  lwz r10, 0x24(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFDE6C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFDE70: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDE74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFDE78: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDE7C: C3A90BFC  lfs f29, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82CFDE80: EFE10024  fdivs f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 82CFDE84: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFDE88: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDE8C: EC2D0772  fmuls f1, f13, f29
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82CFDE90: 4B53C021  bl 0x82239eb0
	ctx.lr = 0x82CFDE94;
	sub_82239EB0(ctx, base);
	// 82CFDE94: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFDE98: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82CFDE9C: 4198006C  blt cr6, 0x82cfdf08
	if ctx.cr[6].lt {
	pc = 0x82CFDF08; continue 'dispatch;
	}
	// 82CFDEA0: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CFDEA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFDEA8: 419A0018  beq cr6, 0x82cfdec0
	if ctx.cr[6].eq {
	pc = 0x82CFDEC0; continue 'dispatch;
	}
	// 82CFDEAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDEB0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDEB4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDEB8: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFDEBC: 48000008  b 0x82cfdec4
	pc = 0x82CFDEC4; continue 'dispatch;
            }
            0x82CFDEC0 => {
    //   block [0x82CFDEC0..0x82CFDEC4)
	// 82CFDEC0: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFDEC4; continue 'dispatch;
            }
            0x82CFDEC4 => {
    //   block [0x82CFDEC4..0x82CFDEE4)
	// 82CFDEC4: 57CB073A  rlwinm r11, r30, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDEC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFDECC: 419A0018  beq cr6, 0x82cfdee4
	if ctx.cr[6].eq {
	pc = 0x82CFDEE4; continue 'dispatch;
	}
	// 82CFDED0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDED4: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFDED8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDEDC: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDEE0: 48000008  b 0x82cfdee8
	pc = 0x82CFDEE8; continue 'dispatch;
            }
            0x82CFDEE4 => {
    //   block [0x82CFDEE4..0x82CFDEE8)
	// 82CFDEE4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFDEE8; continue 'dispatch;
            }
            0x82CFDEE8 => {
    //   block [0x82CFDEE8..0x82CFDF08)
	// 82CFDEE8: 57C906F6  rlwinm r9, r30, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDEEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFDEF0: 419A01AC  beq cr6, 0x82cfe09c
	if ctx.cr[6].eq {
	pc = 0x82CFE09C; continue 'dispatch;
	}
	// 82CFDEF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDEF8: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFDEFC: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFDF00: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDF04: 4800019C  b 0x82cfe0a0
	pc = 0x82CFE0A0; continue 'dispatch;
            }
            0x82CFDF08 => {
    //   block [0x82CFDF08..0x82CFDF4C)
	// 82CFDF08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDF0C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFDF10: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFDF14: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDF18: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82CFDF1C: 4B53BF95  bl 0x82239eb0
	ctx.lr = 0x82CFDF20;
	sub_82239EB0(ctx, base);
	// 82CFDF20: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFDF24: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CFDF28: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82CFDF2C: 41990068  bgt cr6, 0x82cfdf94
	if ctx.cr[6].gt {
	pc = 0x82CFDF94; continue 'dispatch;
	}
	// 82CFDF30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFDF34: 419A0018  beq cr6, 0x82cfdf4c
	if ctx.cr[6].eq {
	pc = 0x82CFDF4C; continue 'dispatch;
	}
	// 82CFDF38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDF3C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDF40: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDF44: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFDF48: 48000008  b 0x82cfdf50
	pc = 0x82CFDF50; continue 'dispatch;
            }
            0x82CFDF4C => {
    //   block [0x82CFDF4C..0x82CFDF50)
	// 82CFDF4C: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFDF50; continue 'dispatch;
            }
            0x82CFDF50 => {
    //   block [0x82CFDF50..0x82CFDF70)
	// 82CFDF50: 57CB073A  rlwinm r11, r30, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDF54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFDF58: 419A0018  beq cr6, 0x82cfdf70
	if ctx.cr[6].eq {
	pc = 0x82CFDF70; continue 'dispatch;
	}
	// 82CFDF5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDF60: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFDF64: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDF68: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDF6C: 48000008  b 0x82cfdf74
	pc = 0x82CFDF74; continue 'dispatch;
            }
            0x82CFDF70 => {
    //   block [0x82CFDF70..0x82CFDF74)
	// 82CFDF70: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFDF74; continue 'dispatch;
            }
            0x82CFDF74 => {
    //   block [0x82CFDF74..0x82CFDF94)
	// 82CFDF74: 57C906F6  rlwinm r9, r30, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDF78: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFDF7C: 419A0120  beq cr6, 0x82cfe09c
	if ctx.cr[6].eq {
	pc = 0x82CFE09C; continue 'dispatch;
	}
	// 82CFDF80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDF84: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFDF88: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFDF8C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFDF90: 48000110  b 0x82cfe0a0
	pc = 0x82CFE0A0; continue 'dispatch;
            }
            0x82CFDF94 => {
    //   block [0x82CFDF94..0x82CFDFD0)
	// 82CFDF94: EDBFF028  fsubs f13, f31, f30
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82CFDF98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFDF9C: ED80F028  fsubs f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82CFDFA0: EC0D6024  fdivs f0, f13, f12
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 82CFDFA4: 419A002C  beq cr6, 0x82cfdfd0
	if ctx.cr[6].eq {
	pc = 0x82CFDFD0; continue 'dispatch;
	}
	// 82CFDFA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDFAC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFDFB0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFDFB4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFDFB8: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82CFDFBC: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFDFC0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDFC4: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CFDFC8: ED8B683A  fmadds f12, f11, f0, f13
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFDFCC: 48000008  b 0x82cfdfd4
	pc = 0x82CFDFD4; continue 'dispatch;
            }
            0x82CFDFD0 => {
    //   block [0x82CFDFD0..0x82CFDFD4)
	// 82CFDFD0: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFDFD4; continue 'dispatch;
            }
            0x82CFDFD4 => {
    //   block [0x82CFDFD4..0x82CFE008)
	// 82CFDFD4: 57CB073A  rlwinm r11, r30, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFDFD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFDFDC: 419A002C  beq cr6, 0x82cfe008
	if ctx.cr[6].eq {
	pc = 0x82CFE008; continue 'dispatch;
	}
	// 82CFDFE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFDFE4: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFDFE8: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFDFEC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFDFF0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFDFF4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFDFF8: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFDFFC: ED4B6828  fsubs f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CFE000: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFE004: 48000008  b 0x82cfe00c
	pc = 0x82CFE00C; continue 'dispatch;
            }
            0x82CFE008 => {
    //   block [0x82CFE008..0x82CFE00C)
	// 82CFE008: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFE00C; continue 'dispatch;
            }
            0x82CFE00C => {
    //   block [0x82CFE00C..0x82CFE040)
	// 82CFE00C: 57C906F6  rlwinm r9, r30, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE010: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFE014: 419A0088  beq cr6, 0x82cfe09c
	if ctx.cr[6].eq {
	pc = 0x82CFE09C; continue 'dispatch;
	}
	// 82CFE018: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE01C: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFE020: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFE024: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82CFE028: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82CFE02C: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE030: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFE034: ED2A5828  fsubs f9, f10, f11
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82CFE038: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82CFE03C: 48000064  b 0x82cfe0a0
	pc = 0x82CFE0A0; continue 'dispatch;
            }
            0x82CFE040 => {
    //   block [0x82CFE040..0x82CFE05C)
	// 82CFE040: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CFE044: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFE048: 419A0014  beq cr6, 0x82cfe05c
	if ctx.cr[6].eq {
	pc = 0x82CFE05C; continue 'dispatch;
	}
	// 82CFE04C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE050: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFE054: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE058: 48000008  b 0x82cfe060
	pc = 0x82CFE060; continue 'dispatch;
            }
            0x82CFE05C => {
    //   block [0x82CFE05C..0x82CFE060)
	// 82CFE05C: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFE060; continue 'dispatch;
            }
            0x82CFE060 => {
    //   block [0x82CFE060..0x82CFE07C)
	// 82CFE060: 57C9073A  rlwinm r9, r30, 0, 0x1c, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE064: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFE068: 419A0014  beq cr6, 0x82cfe07c
	if ctx.cr[6].eq {
	pc = 0x82CFE07C; continue 'dispatch;
	}
	// 82CFE06C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFE070: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFE074: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE078: 48000008  b 0x82cfe080
	pc = 0x82CFE080; continue 'dispatch;
            }
            0x82CFE07C => {
    //   block [0x82CFE07C..0x82CFE080)
	// 82CFE07C: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFE080; continue 'dispatch;
            }
            0x82CFE080 => {
    //   block [0x82CFE080..0x82CFE09C)
	// 82CFE080: 57C906F6  rlwinm r9, r30, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE084: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFE088: 419A0014  beq cr6, 0x82cfe09c
	if ctx.cr[6].eq {
	pc = 0x82CFE09C; continue 'dispatch;
	}
	// 82CFE08C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFE090: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFE094: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE098: 48000008  b 0x82cfe0a0
	pc = 0x82CFE0A0; continue 'dispatch;
            }
            0x82CFE09C => {
    //   block [0x82CFE09C..0x82CFE0A0)
	// 82CFE09C: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CFE0A0; continue 'dispatch;
            }
            0x82CFE0A0 => {
    //   block [0x82CFE0A0..0x82CFE0DC)
	// 82CFE0A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFE0A4: 419A0038  beq cr6, 0x82cfe0dc
	if ctx.cr[6].eq {
	pc = 0x82CFE0DC; continue 'dispatch;
	}
	// 82CFE0A8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE0AC: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE0B0: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFE0B4: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFE0B8: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE0BC: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82CFE0C0: 419A001C  beq cr6, 0x82cfe0dc
	if ctx.cr[6].eq {
	pc = 0x82CFE0DC; continue 'dispatch;
	}
	// 82CFE0C4: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFE0C8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE0CC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFE0D0: 7D6A5C2E  lfsx f11, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE0D4: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFE0D8: 7D4A5D2E  stfsx f10, r10, r11
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	pc = 0x82CFE0DC; continue 'dispatch;
            }
            0x82CFE0DC => {
    //   block [0x82CFE0DC..0x82CFE104)
	// 82CFE0DC: 57CB077A  rlwinm r11, r30, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE0E4: 419A0020  beq cr6, 0x82cfe104
	if ctx.cr[6].eq {
	pc = 0x82CFE104; continue 'dispatch;
	}
	// 82CFE0E8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFE0EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFE0F0: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE0F4: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFE0F8: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE0FC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFE100: 915D0010  stw r10, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82CFE104; continue 'dispatch;
            }
            0x82CFE104 => {
    //   block [0x82CFE104..0x82CFE12C)
	// 82CFE104: 57CB0738  rlwinm r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE10C: 419A0020  beq cr6, 0x82cfe12c
	if ctx.cr[6].eq {
	pc = 0x82CFE12C; continue 'dispatch;
	}
	// 82CFE110: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFE114: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFE118: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE11C: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFE120: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE124: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFE128: 915D0014  stw r10, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82CFE12C; continue 'dispatch;
            }
            0x82CFE12C => {
    //   block [0x82CFE12C..0x82CFE150)
	// 82CFE12C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFE130: 419A0020  beq cr6, 0x82cfe150
	if ctx.cr[6].eq {
	pc = 0x82CFE150; continue 'dispatch;
	}
	// 82CFE134: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFE138: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFE13C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE140: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFE144: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE148: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFE14C: 915D0018  stw r10, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	pc = 0x82CFE150; continue 'dispatch;
            }
            0x82CFE150 => {
    //   block [0x82CFE150..0x82CFE164)
	// 82CFE150: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CFE154: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CFE158: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CFE15C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFE160: 4BFAB2F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFE168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFE168 size=1200
    let mut pc: u32 = 0x82CFE168;
    'dispatch: loop {
        match pc {
            0x82CFE168 => {
    //   block [0x82CFE168..0x82CFE1D4)
	// 82CFE168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFE16C: 4BFAB299  bl 0x82ca9404
	ctx.lr = 0x82CFE170;
	sub_82CA93D0(ctx, base);
	// 82CFE170: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82CFE174: 4BFAFB61  bl 0x82cadcd4
	ctx.lr = 0x82CFE178;
	sub_82CADCA0(ctx, base);
	// 82CFE178: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFE17C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CFE180: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFE184: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CFE188: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82CFE18C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CFE190: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE194: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82CFE198: C38A0C18  lfs f28, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82CFE19C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82CFE1A0: C3696924  lfs f27, 0x6924(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26916 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82CFE1A4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFE1A8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFE1AC: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE1B0: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82CFE1B4: 409A0060  bne cr6, 0x82cfe214
	if !ctx.cr[6].eq {
	pc = 0x82CFE214; continue 'dispatch;
	}
	// 82CFE1B8: 578A07FE  clrlwi r10, r28, 0x1f
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82CFE1BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFE1C0: 419A0014  beq cr6, 0x82cfe1d4
	if ctx.cr[6].eq {
	pc = 0x82CFE1D4; continue 'dispatch;
	}
	// 82CFE1C4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFE1C8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE1CC: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE1D0: 48000008  b 0x82cfe1d8
	pc = 0x82CFE1D8; continue 'dispatch;
            }
            0x82CFE1D4 => {
    //   block [0x82CFE1D4..0x82CFE1D8)
	// 82CFE1D4: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFE1D8; continue 'dispatch;
            }
            0x82CFE1D8 => {
    //   block [0x82CFE1D8..0x82CFE1F4)
	// 82CFE1D8: 5789073A  rlwinm r9, r28, 0, 0x1c, 0x1d
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE1DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFE1E0: 419A0014  beq cr6, 0x82cfe1f4
	if ctx.cr[6].eq {
	pc = 0x82CFE1F4; continue 'dispatch;
	}
	// 82CFE1E4: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFE1E8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE1EC: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE1F0: 48000008  b 0x82cfe1f8
	pc = 0x82CFE1F8; continue 'dispatch;
            }
            0x82CFE1F4 => {
    //   block [0x82CFE1F4..0x82CFE1F8)
	// 82CFE1F4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFE1F8; continue 'dispatch;
            }
            0x82CFE1F8 => {
    //   block [0x82CFE1F8..0x82CFE214)
	// 82CFE1F8: 578706F6  rlwinm r7, r28, 0, 0x1b, 0x1b
	ctx.r[7].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE1FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFE200: 419A0298  beq cr6, 0x82cfe498
	if ctx.cr[6].eq {
	pc = 0x82CFE498; continue 'dispatch;
	}
	// 82CFE204: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFE208: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CFE20C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE210: 4800028C  b 0x82cfe49c
	pc = 0x82CFE49C; continue 'dispatch;
            }
            0x82CFE214 => {
    //   block [0x82CFE214..0x82CFE2BC)
	// 82CFE214: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE218: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFE21C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE220: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82CFE224: 419A0218  beq cr6, 0x82cfe43c
	if ctx.cr[6].eq {
	pc = 0x82CFE43C; continue 'dispatch;
	}
	// 82CFE228: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFE22C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFE230: C0090C38  lfs f0, 0xc38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE234: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFE238: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE23C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFE240: 409901FC  ble cr6, 0x82cfe43c
	if !ctx.cr[6].gt {
	pc = 0x82CFE43C; continue 'dispatch;
	}
	// 82CFE244: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82CFE248: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 82CFE24C: 387D001C  addi r3, r29, 0x1c
	ctx.r[3].s64 = ctx.r[29].s64 + 28;
	// 82CFE250: 48001419  bl 0x82cff668
	ctx.lr = 0x82CFE254;
	sub_82CFF668(ctx, base);
	// 82CFE254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CFE258: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82CFE25C: 480013E5  bl 0x82cff640
	ctx.lr = 0x82CFE260;
	sub_82CFF640(ctx, base);
	// 82CFE260: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE264: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFE268: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFE26C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE270: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFE274: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE278: C3A90BFC  lfs f29, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82CFE27C: EFE10024  fdivs f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 82CFE280: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFE284: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE288: EC2D0772  fmuls f1, f13, f29
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82CFE28C: 4B53BC25  bl 0x82239eb0
	ctx.lr = 0x82CFE290;
	sub_82239EB0(ctx, base);
	// 82CFE290: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFE294: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82CFE298: 4198006C  blt cr6, 0x82cfe304
	if ctx.cr[6].lt {
	pc = 0x82CFE304; continue 'dispatch;
	}
	// 82CFE29C: 578A07FE  clrlwi r10, r28, 0x1f
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82CFE2A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFE2A4: 419A0018  beq cr6, 0x82cfe2bc
	if ctx.cr[6].eq {
	pc = 0x82CFE2BC; continue 'dispatch;
	}
	// 82CFE2A8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE2AC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE2B0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE2B4: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE2B8: 48000008  b 0x82cfe2c0
	pc = 0x82CFE2C0; continue 'dispatch;
            }
            0x82CFE2BC => {
    //   block [0x82CFE2BC..0x82CFE2C0)
	// 82CFE2BC: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFE2C0; continue 'dispatch;
            }
            0x82CFE2C0 => {
    //   block [0x82CFE2C0..0x82CFE2E0)
	// 82CFE2C0: 578B073A  rlwinm r11, r28, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE2C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE2C8: 419A0018  beq cr6, 0x82cfe2e0
	if ctx.cr[6].eq {
	pc = 0x82CFE2E0; continue 'dispatch;
	}
	// 82CFE2CC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE2D0: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFE2D4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE2D8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE2DC: 48000008  b 0x82cfe2e4
	pc = 0x82CFE2E4; continue 'dispatch;
            }
            0x82CFE2E0 => {
    //   block [0x82CFE2E0..0x82CFE2E4)
	// 82CFE2E0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFE2E4; continue 'dispatch;
            }
            0x82CFE2E4 => {
    //   block [0x82CFE2E4..0x82CFE304)
	// 82CFE2E4: 578706F6  rlwinm r7, r28, 0, 0x1b, 0x1b
	ctx.r[7].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE2E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFE2EC: 419A01AC  beq cr6, 0x82cfe498
	if ctx.cr[6].eq {
	pc = 0x82CFE498; continue 'dispatch;
	}
	// 82CFE2F0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE2F4: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFE2F8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE2FC: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE300: 4800019C  b 0x82cfe49c
	pc = 0x82CFE49C; continue 'dispatch;
            }
            0x82CFE304 => {
    //   block [0x82CFE304..0x82CFE348)
	// 82CFE304: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE308: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFE30C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFE310: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE314: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82CFE318: 4B53BB99  bl 0x82239eb0
	ctx.lr = 0x82CFE31C;
	sub_82239EB0(ctx, base);
	// 82CFE31C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFE320: 578A07FE  clrlwi r10, r28, 0x1f
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82CFE324: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82CFE328: 41990068  bgt cr6, 0x82cfe390
	if ctx.cr[6].gt {
	pc = 0x82CFE390; continue 'dispatch;
	}
	// 82CFE32C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFE330: 419A0018  beq cr6, 0x82cfe348
	if ctx.cr[6].eq {
	pc = 0x82CFE348; continue 'dispatch;
	}
	// 82CFE334: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE338: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFE33C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE340: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE344: 48000008  b 0x82cfe34c
	pc = 0x82CFE34C; continue 'dispatch;
            }
            0x82CFE348 => {
    //   block [0x82CFE348..0x82CFE34C)
	// 82CFE348: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFE34C; continue 'dispatch;
            }
            0x82CFE34C => {
    //   block [0x82CFE34C..0x82CFE36C)
	// 82CFE34C: 578B073A  rlwinm r11, r28, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE354: 419A0018  beq cr6, 0x82cfe36c
	if ctx.cr[6].eq {
	pc = 0x82CFE36C; continue 'dispatch;
	}
	// 82CFE358: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE35C: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFE360: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE364: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE368: 48000008  b 0x82cfe370
	pc = 0x82CFE370; continue 'dispatch;
            }
            0x82CFE36C => {
    //   block [0x82CFE36C..0x82CFE370)
	// 82CFE36C: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFE370; continue 'dispatch;
            }
            0x82CFE370 => {
    //   block [0x82CFE370..0x82CFE390)
	// 82CFE370: 578706F6  rlwinm r7, r28, 0, 0x1b, 0x1b
	ctx.r[7].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE374: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFE378: 419A0120  beq cr6, 0x82cfe498
	if ctx.cr[6].eq {
	pc = 0x82CFE498; continue 'dispatch;
	}
	// 82CFE37C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE380: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFE384: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE388: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE38C: 48000110  b 0x82cfe49c
	pc = 0x82CFE49C; continue 'dispatch;
            }
            0x82CFE390 => {
    //   block [0x82CFE390..0x82CFE3CC)
	// 82CFE390: EDBFF028  fsubs f13, f31, f30
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82CFE394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFE398: ED80F028  fsubs f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82CFE39C: EC0D6024  fdivs f0, f13, f12
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 82CFE3A0: 419A002C  beq cr6, 0x82cfe3cc
	if ctx.cr[6].eq {
	pc = 0x82CFE3CC; continue 'dispatch;
	}
	// 82CFE3A4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE3A8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFE3AC: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE3B0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFE3B4: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE3B8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFE3BC: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE3C0: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CFE3C4: ED8B683A  fmadds f12, f11, f0, f13
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFE3C8: 48000008  b 0x82cfe3d0
	pc = 0x82CFE3D0; continue 'dispatch;
            }
            0x82CFE3CC => {
    //   block [0x82CFE3CC..0x82CFE3D0)
	// 82CFE3CC: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFE3D0; continue 'dispatch;
            }
            0x82CFE3D0 => {
    //   block [0x82CFE3D0..0x82CFE404)
	// 82CFE3D0: 578B073A  rlwinm r11, r28, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE3D8: 419A002C  beq cr6, 0x82cfe404
	if ctx.cr[6].eq {
	pc = 0x82CFE404; continue 'dispatch;
	}
	// 82CFE3DC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE3E0: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFE3E4: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFE3E8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFE3EC: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFE3F0: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE3F4: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE3F8: ED4B6828  fsubs f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CFE3FC: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFE400: 48000008  b 0x82cfe408
	pc = 0x82CFE408; continue 'dispatch;
            }
            0x82CFE404 => {
    //   block [0x82CFE404..0x82CFE408)
	// 82CFE404: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFE408; continue 'dispatch;
            }
            0x82CFE408 => {
    //   block [0x82CFE408..0x82CFE43C)
	// 82CFE408: 578706F6  rlwinm r7, r28, 0, 0x1b, 0x1b
	ctx.r[7].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE40C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFE410: 419A0088  beq cr6, 0x82cfe498
	if ctx.cr[6].eq {
	pc = 0x82CFE498; continue 'dispatch;
	}
	// 82CFE414: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFE418: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFE41C: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFE420: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFE424: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFE428: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE42C: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFE430: ED2A5828  fsubs f9, f10, f11
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82CFE434: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82CFE438: 48000064  b 0x82cfe49c
	pc = 0x82CFE49C; continue 'dispatch;
            }
            0x82CFE43C => {
    //   block [0x82CFE43C..0x82CFE458)
	// 82CFE43C: 578A07FE  clrlwi r10, r28, 0x1f
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82CFE440: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFE444: 419A0014  beq cr6, 0x82cfe458
	if ctx.cr[6].eq {
	pc = 0x82CFE458; continue 'dispatch;
	}
	// 82CFE448: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE44C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFE450: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE454: 48000008  b 0x82cfe45c
	pc = 0x82CFE45C; continue 'dispatch;
            }
            0x82CFE458 => {
    //   block [0x82CFE458..0x82CFE45C)
	// 82CFE458: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82CFE45C; continue 'dispatch;
            }
            0x82CFE45C => {
    //   block [0x82CFE45C..0x82CFE478)
	// 82CFE45C: 5789073A  rlwinm r9, r28, 0, 0x1c, 0x1d
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE460: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFE464: 419A0014  beq cr6, 0x82cfe478
	if ctx.cr[6].eq {
	pc = 0x82CFE478; continue 'dispatch;
	}
	// 82CFE468: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFE46C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFE470: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE474: 48000008  b 0x82cfe47c
	pc = 0x82CFE47C; continue 'dispatch;
            }
            0x82CFE478 => {
    //   block [0x82CFE478..0x82CFE47C)
	// 82CFE478: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82CFE47C; continue 'dispatch;
            }
            0x82CFE47C => {
    //   block [0x82CFE47C..0x82CFE498)
	// 82CFE47C: 578706F6  rlwinm r7, r28, 0, 0x1b, 0x1b
	ctx.r[7].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE480: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFE484: 419A0014  beq cr6, 0x82cfe498
	if ctx.cr[6].eq {
	pc = 0x82CFE498; continue 'dispatch;
	}
	// 82CFE488: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFE48C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFE490: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE494: 48000008  b 0x82cfe49c
	pc = 0x82CFE49C; continue 'dispatch;
            }
            0x82CFE498 => {
    //   block [0x82CFE498..0x82CFE49C)
	// 82CFE498: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82CFE49C; continue 'dispatch;
            }
            0x82CFE49C => {
    //   block [0x82CFE49C..0x82CFE4B8)
	// 82CFE49C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFE4A0: 419A00CC  beq cr6, 0x82cfe56c
	if ctx.cr[6].eq {
	pc = 0x82CFE56C; continue 'dispatch;
	}
	// 82CFE4A4: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFE4A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFE4AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE4B0: 40990030  ble cr6, 0x82cfe4e0
	if !ctx.cr[6].gt {
	pc = 0x82CFE4E0; continue 'dispatch;
	}
	// 82CFE4B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82CFE4B8; continue 'dispatch;
            }
            0x82CFE4B8 => {
    //   block [0x82CFE4B8..0x82CFE4E0)
	// 82CFE4B8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE4BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CFE4C0: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CFE4C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFE4C8: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE4CC: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFE4D0: D1490000  stfs f10, 0(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFE4D4: 813D003C  lwz r9, 0x3c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFE4D8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CFE4DC: 4198FFDC  blt cr6, 0x82cfe4b8
	if ctx.cr[6].lt {
	pc = 0x82CFE4B8; continue 'dispatch;
	}
	pc = 0x82CFE4E0; continue 'dispatch;
            }
            0x82CFE4E0 => {
    //   block [0x82CFE4E0..0x82CFE514)
	// 82CFE4E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE4E4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82CFE4E8: 419A0084  beq cr6, 0x82cfe56c
	if ctx.cr[6].eq {
	pc = 0x82CFE56C; continue 'dispatch;
	}
	// 82CFE4EC: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFE4F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CFE4F4: 409A0020  bne cr6, 0x82cfe514
	if !ctx.cr[6].eq {
	pc = 0x82CFE514; continue 'dispatch;
	}
	// 82CFE4F8: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE4FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE500: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFE504: 7D6A5C2E  lfsx f11, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE508: ED4C02F2  fmuls f10, f12, f11
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFE50C: 7D4A5D2E  stfsx f10, r10, r11
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFE510: 4800005C  b 0x82cfe56c
	pc = 0x82CFE56C; continue 'dispatch;
            }
            0x82CFE514 => {
    //   block [0x82CFE514..0x82CFE524)
	// 82CFE514: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFE518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE51C: 419A0050  beq cr6, 0x82cfe56c
	if ctx.cr[6].eq {
	pc = 0x82CFE56C; continue 'dispatch;
	}
	// 82CFE520: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82CFE524; continue 'dispatch;
            }
            0x82CFE524 => {
    //   block [0x82CFE524..0x82CFE558)
	// 82CFE524: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CFE528: 7D685C2E  lfsx f11, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE52C: FF0BD800  fcmpu cr6, f11, f27
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[27].f64);
	// 82CFE530: 409A0028  bne cr6, 0x82cfe558
	if !ctx.cr[6].eq {
	pc = 0x82CFE558; continue 'dispatch;
	}
	// 82CFE534: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE538: 80DB0008  lwz r6, 8(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFE53C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE540: 7D4A31D6  mullw r10, r10, r6
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFE544: 7CAA4A14  add r5, r10, r9
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82CFE548: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFE54C: 7D6A5C2E  lfsx f11, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE550: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFE554: 7D4A5D2E  stfsx f10, r10, r11
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	pc = 0x82CFE558; continue 'dispatch;
            }
            0x82CFE558 => {
    //   block [0x82CFE558..0x82CFE56C)
	// 82CFE558: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFE55C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFE560: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CFE564: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFE568: 4198FFBC  blt cr6, 0x82cfe524
	if ctx.cr[6].lt {
	pc = 0x82CFE524; continue 'dispatch;
	}
	pc = 0x82CFE56C; continue 'dispatch;
            }
            0x82CFE56C => {
    //   block [0x82CFE56C..0x82CFE5A8)
	// 82CFE56C: 578B077A  rlwinm r11, r28, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE574: 419A0034  beq cr6, 0x82cfe5a8
	if ctx.cr[6].eq {
	pc = 0x82CFE5A8; continue 'dispatch;
	}
	// 82CFE578: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFE57C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFE580: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE584: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CFE588: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE58C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFE590: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82CFE594: FF0BE000  fcmpu cr6, f11, f28
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[28].f64);
	// 82CFE598: 40980010  bge cr6, 0x82cfe5a8
	if !ctx.cr[6].lt {
	pc = 0x82CFE5A8; continue 'dispatch;
	}
	// 82CFE59C: D3810054  stfs f28, 0x54(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE5A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFE5A4: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFE5A8; continue 'dispatch;
            }
            0x82CFE5A8 => {
    //   block [0x82CFE5A8..0x82CFE5E4)
	// 82CFE5A8: 578B0738  rlwinm r11, r28, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE5AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE5B0: 419A0034  beq cr6, 0x82cfe5e4
	if ctx.cr[6].eq {
	pc = 0x82CFE5E4; continue 'dispatch;
	}
	// 82CFE5B4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFE5B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFE5BC: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE5C0: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CFE5C4: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE5C8: FF0BE000  fcmpu cr6, f11, f28
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[28].f64);
	// 82CFE5CC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFE5D0: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82CFE5D4: 40980010  bge cr6, 0x82cfe5e4
	if !ctx.cr[6].lt {
	pc = 0x82CFE5E4; continue 'dispatch;
	}
	// 82CFE5D8: D3810054  stfs f28, 0x54(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE5DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFE5E0: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFE5E4; continue 'dispatch;
            }
            0x82CFE5E4 => {
    //   block [0x82CFE5E4..0x82CFE608)
	// 82CFE5E4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFE5E8: 419A0020  beq cr6, 0x82cfe608
	if ctx.cr[6].eq {
	pc = 0x82CFE608; continue 'dispatch;
	}
	// 82CFE5EC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFE5F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFE5F4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE5F8: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFE5FC: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE600: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CFE604: 915E0018  stw r10, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	pc = 0x82CFE608; continue 'dispatch;
            }
            0x82CFE608 => {
    //   block [0x82CFE608..0x82CFE618)
	// 82CFE608: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82CFE60C: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82CFE610: 4BFAF711  bl 0x82cadd20
	ctx.lr = 0x82CFE614;
	sub_82CADCEC(ctx, base);
	// 82CFE614: 4BFAAE40  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFE618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFE618 size=316
    let mut pc: u32 = 0x82CFE618;
    'dispatch: loop {
        match pc {
            0x82CFE618 => {
    //   block [0x82CFE618..0x82CFE6E4)
	// 82CFE618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFE61C: 4BFAADED  bl 0x82ca9408
	ctx.lr = 0x82CFE620;
	sub_82CA93D0(ctx, base);
	// 82CFE620: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CFE624: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFE628: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82CFE62C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFE630: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFE634: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFE638: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CFE63C: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFE640: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82CFE644: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE648: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CFE64C: C1880C38  lfs f12, 0xc38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3128 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE650: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82CFE654: C1A90C14  lfs f13, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE658: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	// 82CFE65C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFE660: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE664: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 82CFE668: 409900BC  ble cr6, 0x82cfe724
	if !ctx.cr[6].gt {
	pc = 0x82CFE724; continue 'dispatch;
	}
	// 82CFE66C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82CFE670: 389E001C  addi r4, r30, 0x1c
	ctx.r[4].s64 = ctx.r[30].s64 + 28;
	// 82CFE674: 387D0018  addi r3, r29, 0x18
	ctx.r[3].s64 = ctx.r[29].s64 + 24;
	// 82CFE678: 48000FF1  bl 0x82cff668
	ctx.lr = 0x82CFE67C;
	sub_82CFF668(ctx, base);
	// 82CFE67C: 389D0024  addi r4, r29, 0x24
	ctx.r[4].s64 = ctx.r[29].s64 + 36;
	// 82CFE680: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82CFE684: 48000FBD  bl 0x82cff640
	ctx.lr = 0x82CFE688;
	sub_82CFF640(ctx, base);
	// 82CFE688: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFE68C: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 82CFE690: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82CFE694: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CFE698: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE69C: EFE10024  fdivs f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 82CFE6A0: 48000FA1  bl 0x82cff640
	ctx.lr = 0x82CFE6A4;
	sub_82CFF640(ctx, base);
	// 82CFE6A4: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82CFE6A8: 813C0010  lwz r9, 0x10(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFE6AC: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFE6B0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFE6B4: C1810050  lfs f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE6B8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFE6BC: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE6C0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFE6C4: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE6C8: EDAC07F2  fmuls f13, f12, f31
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82CFE6CC: ED415824  fdivs f10, f1, f11
	ctx.f[10].f64 = ((ctx.f[1].f64 / ctx.f[11].f64) as f32) as f64;
	// 82CFE6D0: ED8C02B2  fmuls f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CFE6D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFE6D8: 4099000C  ble cr6, 0x82cfe6e4
	if !ctx.cr[6].gt {
	pc = 0x82CFE6E4; continue 'dispatch;
	}
	// 82CFE6DC: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82CFE6E0: 48000014  b 0x82cfe6f4
	pc = 0x82CFE6F4; continue 'dispatch;
            }
            0x82CFE6E4 => {
    //   block [0x82CFE6E4..0x82CFE6F4)
	// 82CFE6E4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82CFE6E8: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82CFE6EC: 40980008  bge cr6, 0x82cfe6f4
	if !ctx.cr[6].lt {
	pc = 0x82CFE6F4; continue 'dispatch;
	}
	// 82CFE6F0: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82CFE6F4; continue 'dispatch;
            }
            0x82CFE6F4 => {
    //   block [0x82CFE6F4..0x82CFE708)
	// 82CFE6F4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82CFE6F8: 41990010  bgt cr6, 0x82cfe708
	if ctx.cr[6].gt {
	pc = 0x82CFE708; continue 'dispatch;
	}
	// 82CFE6FC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82CFE700: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82CFE704: 40980008  bge cr6, 0x82cfe70c
	if !ctx.cr[6].lt {
	pc = 0x82CFE70C; continue 'dispatch;
	}
	pc = 0x82CFE708; continue 'dispatch;
            }
            0x82CFE708 => {
    //   block [0x82CFE708..0x82CFE70C)
	// 82CFE708: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	pc = 0x82CFE70C; continue 'dispatch;
            }
            0x82CFE70C => {
    //   block [0x82CFE70C..0x82CFE724)
	// 82CFE70C: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFE710: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CFE714: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE718: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CFE71C: ED806028  fsubs f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CFE720: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	pc = 0x82CFE724; continue 'dispatch;
            }
            0x82CFE724 => {
    //   block [0x82CFE724..0x82CFE754)
	// 82CFE724: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFE728: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFE72C: D1410050  stfs f10, 0x50(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFE730: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFE734: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFE738: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFE73C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFE740: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82CFE744: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82CFE748: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82CFE74C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFE750: 4BFAAD08  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFE758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFE758 size=1772
    let mut pc: u32 = 0x82CFE758;
    'dispatch: loop {
        match pc {
            0x82CFE758 => {
    //   block [0x82CFE758..0x82CFE9B8)
	// 82CFE758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFE75C: 4BFAACAD  bl 0x82ca9408
	ctx.lr = 0x82CFE760;
	sub_82CA93D0(ctx, base);
	// 82CFE760: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CFE764: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFE768: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CFE76C: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE770: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CFE774: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CFE778: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82CFE77C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82CFE780: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82CFE784: C14B1678  lfs f10, 0x1678(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5752 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFE788: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82CFE78C: C0AA692C  lfs f5, 0x692c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26924 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CFE790: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CFE794: C00914E8  lfs f0, 0x14e8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE798: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFE79C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CFE7A0: D1410060  stfs f10, 0x60(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82CFE7A4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CFE7A8: D0A10064  stfs f5, 0x64(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82CFE7AC: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82CFE7B0: C1A80E60  lfs f13, 0xe60(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3680 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFE7B4: 3FE08200  lis r31, -0x7e00
	ctx.r[31].s64 = -2113929216;
	// 82CFE7B8: C0C70B40  lfs f6, 0xb40(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2880 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CFE7BC: C0E50C18  lfs f7, 0xc18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3096 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFE7C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CFE7C4: C18B6928  lfs f12, 0x6928(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26920 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFE7C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFE7CC: C16A160C  lfs f11, 0x160c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5644 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFE7D0: 2B04003F  cmplwi cr6, r4, 0x3f
	ctx.cr[6].compare_u32(ctx.r[4].u32, 63 as u32, &mut ctx.xer);
	// 82CFE7D4: C12916F0  lfs f9, 0x16f0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5872 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFE7D8: C11F0B4C  lfs f8, 0xb4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2892 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CFE7DC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82CFE7E0: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82CFE7E4: D0C10070  stfs f6, 0x70(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82CFE7E8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82CFE7EC: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82CFE7F0: D0E10088  stfs f7, 0x88(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82CFE7F4: D0C1008C  stfs f6, 0x8c(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82CFE7F8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFE7FC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82CFE800: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82CFE804: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82CFE808: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82CFE80C: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82CFE810: D1410098  stfs f10, 0x98(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82CFE814: D0A1009C  stfs f5, 0x9c(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82CFE818: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82CFE81C: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82CFE820: D0E100A8  stfs f7, 0xa8(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82CFE824: D18100AC  stfs f12, 0xac(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82CFE828: D16100B0  stfs f11, 0xb0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82CFE82C: D0010100  stfs f0, 0x100(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82CFE830: D1A10104  stfs f13, 0x104(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82CFE834: D1810108  stfs f12, 0x108(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82CFE838: D161010C  stfs f11, 0x10c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82CFE83C: D1210110  stfs f9, 0x110(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82CFE840: D1010114  stfs f8, 0x114(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82CFE844: D0010120  stfs f0, 0x120(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82CFE848: D1A10124  stfs f13, 0x124(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82CFE84C: D0E10128  stfs f7, 0x128(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82CFE850: D181012C  stfs f12, 0x12c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82CFE854: D1610130  stfs f11, 0x130(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82CFE858: D1210134  stfs f9, 0x134(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82CFE85C: D1010138  stfs f8, 0x138(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82CFE860: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82CFE864: D1A100C4  stfs f13, 0xc4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82CFE868: D0E100C8  stfs f7, 0xc8(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82CFE86C: D14100CC  stfs f10, 0xcc(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82CFE870: D0A100D0  stfs f5, 0xd0(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82CFE874: D00100E0  stfs f0, 0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82CFE878: D1A100E4  stfs f13, 0xe4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82CFE87C: D18100E8  stfs f12, 0xe8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82CFE880: D16100EC  stfs f11, 0xec(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82CFE884: D14100F0  stfs f10, 0xf0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82CFE888: D0A100F4  stfs f5, 0xf4(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82CFE88C: D0010140  stfs f0, 0x140(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82CFE890: D1A10144  stfs f13, 0x144(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82CFE894: D0E10148  stfs f7, 0x148(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82CFE898: D181014C  stfs f12, 0x14c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82CFE89C: D1610150  stfs f11, 0x150(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82CFE8A0: D1410154  stfs f10, 0x154(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82CFE8A4: D0A10158  stfs f5, 0x158(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 82CFE8A8: 4199015C  bgt cr6, 0x82cfea04
	if ctx.cr[6].gt {
	pc = 0x82CFEA04; continue 'dispatch;
	}
	// 82CFE8AC: 419A0138  beq cr6, 0x82cfe9e4
	if ctx.cr[6].eq {
	pc = 0x82CFE9E4; continue 'dispatch;
	}
	// 82CFE8B0: 3964FFFD  addi r11, r4, -3
	ctx.r[11].s64 = ctx.r[4].s64 + -3;
	// 82CFE8B4: 2B0B0038  cmplwi cr6, r11, 0x38
	ctx.cr[6].compare_u32(ctx.r[11].u32, 56 as u32, &mut ctx.xer);
	// 82CFE8B8: 419901E8  bgt cr6, 0x82cfeaa0
	if ctx.cr[6].gt {
	pc = 0x82CFEAA0; continue 'dispatch;
	}
	// 82CFE8BC: 3D8082D0  lis r12, -0x7d30
	ctx.r[12].s64 = -2100297728;
	// 82CFE8C0: 398CE8D4  addi r12, r12, -0x172c
	ctx.r[12].s64 = ctx.r[12].s64 + -5932;
	// 82CFE8C4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82CFE8C8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82CFE8CC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82CFE8D0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82CFE9D8; continue 'dispatch;
		},
		1 => {
	pc = 0x82CFE9B8; continue 'dispatch;
		},
		2 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		3 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		4 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		5 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		6 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		7 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		8 => {
	pc = 0x82CFE9D8; continue 'dispatch;
		},
		9 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		10 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		11 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		12 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		13 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		14 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		15 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		16 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		17 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		18 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		19 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		20 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		21 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		22 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		23 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		24 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		25 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		26 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		27 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		28 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		29 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		30 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		31 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		32 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		33 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		34 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		35 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		36 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		37 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		38 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		39 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		40 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		41 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		42 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		43 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		44 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		45 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		46 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		47 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		48 => {
	pc = 0x82CFE9F8; continue 'dispatch;
		},
		49 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		50 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		51 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		52 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		53 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		54 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		55 => {
	pc = 0x82CFEAA0; continue 'dispatch;
		},
		56 => {
	pc = 0x82CFE9F8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82CFE8D4: 82CFE9D8  lwz r22, -0x1628(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5672 as u32) ) } as u64;
	// 82CFE8D8: 82CFE9B8  lwz r22, -0x1648(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5704 as u32) ) } as u64;
	// 82CFE8DC: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE8E0: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE8E4: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE8E8: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE8EC: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE8F0: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE8F4: 82CFE9D8  lwz r22, -0x1628(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5672 as u32) ) } as u64;
	// 82CFE8F8: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE8FC: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE900: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE904: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE908: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE90C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE910: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE914: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE918: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE91C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE920: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE924: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE928: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE92C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE930: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE934: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE938: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE93C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE940: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE944: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE948: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE94C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE950: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE954: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE958: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE95C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE960: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE964: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE968: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE96C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE970: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE974: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE978: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE97C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE980: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE984: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE988: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE98C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE990: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE994: 82CFE9F8  lwz r22, -0x1608(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5640 as u32) ) } as u64;
	// 82CFE998: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE99C: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE9A0: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE9A4: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE9A8: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE9AC: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE9B0: 82CFEAA0  lwz r22, -0x1560(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5472 as u32) ) } as u64;
	// 82CFE9B4: 82CFE9F8  lwz r22, -0x1608(r15)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-5640 as u32) ) } as u64;
            }
            0x82CFE9B8 => {
    //   block [0x82CFE9B8..0x82CFE9D8)
	// 82CFE9B8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFE9BC: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFE9C0: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFE9C4: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82CFE9C8: 7DAA5D2E  stfsx f13, r10, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFE9CC: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82CFE9D0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFE9D4: 4BFAAA84  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFE9D8 => {
    //   block [0x82CFE9D8..0x82CFE9E4)
	// 82CFE9D8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82CFE9DC: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82CFE9E0: 480000C0  b 0x82cfeaa0
	pc = 0x82CFEAA0; continue 'dispatch;
            }
            0x82CFE9E4 => {
    //   block [0x82CFE9E4..0x82CFE9F8)
	// 82CFE9E4: 54CB03DE  rlwinm r11, r6, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFE9E8: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82CFE9EC: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82CFE9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFE9F4: 419A00AC  beq cr6, 0x82cfeaa0
	if ctx.cr[6].eq {
	pc = 0x82CFEAA0; continue 'dispatch;
	}
	pc = 0x82CFE9F8; continue 'dispatch;
            }
            0x82CFE9F8 => {
    //   block [0x82CFE9F8..0x82CFEA04)
	// 82CFE9F8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82CFE9FC: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CFEA00: 480000A0  b 0x82cfeaa0
	pc = 0x82CFEAA0; continue 'dispatch;
            }
            0x82CFEA04 => {
    //   block [0x82CFEA04..0x82CFEA40)
	// 82CFEA04: 2B04060F  cmplwi cr6, r4, 0x60f
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1551 as u32, &mut ctx.xer);
	// 82CFEA08: 41990074  bgt cr6, 0x82cfea7c
	if ctx.cr[6].gt {
	pc = 0x82CFEA7C; continue 'dispatch;
	}
	// 82CFEA0C: 419A0050  beq cr6, 0x82cfea5c
	if ctx.cr[6].eq {
	pc = 0x82CFEA5C; continue 'dispatch;
	}
	// 82CFEA10: 2B0400FF  cmplwi cr6, r4, 0xff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 255 as u32, &mut ctx.xer);
	// 82CFEA14: 419A002C  beq cr6, 0x82cfea40
	if ctx.cr[6].eq {
	pc = 0x82CFEA40; continue 'dispatch;
	}
	// 82CFEA18: 2B040107  cmplwi cr6, r4, 0x107
	ctx.cr[6].compare_u32(ctx.r[4].u32, 263 as u32, &mut ctx.xer);
	// 82CFEA1C: 409A0084  bne cr6, 0x82cfeaa0
	if !ctx.cr[6].eq {
	pc = 0x82CFEAA0; continue 'dispatch;
	}
	// 82CFEA20: 54CB03DE  rlwinm r11, r6, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFEA24: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82CFEA28: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CFEA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFEA30: 419A0070  beq cr6, 0x82cfeaa0
	if ctx.cr[6].eq {
	pc = 0x82CFEAA0; continue 'dispatch;
	}
	// 82CFEA34: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82CFEA38: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 82CFEA3C: 48000064  b 0x82cfeaa0
	pc = 0x82CFEAA0; continue 'dispatch;
            }
            0x82CFEA40 => {
    //   block [0x82CFEA40..0x82CFEA5C)
	// 82CFEA40: 54CB03DE  rlwinm r11, r6, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFEA44: 38E10120  addi r7, r1, 0x120
	ctx.r[7].s64 = ctx.r[1].s64 + 288;
	// 82CFEA48: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 82CFEA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFEA50: 419A0050  beq cr6, 0x82cfeaa0
	if ctx.cr[6].eq {
	pc = 0x82CFEAA0; continue 'dispatch;
	}
	// 82CFEA54: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 82CFEA58: 48000044  b 0x82cfea9c
	pc = 0x82CFEA9C; continue 'dispatch;
            }
            0x82CFEA5C => {
    //   block [0x82CFEA5C..0x82CFEA7C)
	// 82CFEA5C: 54CB03DE  rlwinm r11, r6, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFEA60: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 82CFEA64: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82CFEA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFEA6C: 419A0034  beq cr6, 0x82cfeaa0
	if ctx.cr[6].eq {
	pc = 0x82CFEAA0; continue 'dispatch;
	}
	// 82CFEA70: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 82CFEA74: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CFEA78: 48000028  b 0x82cfeaa0
	pc = 0x82CFEAA0; continue 'dispatch;
            }
            0x82CFEA7C => {
    //   block [0x82CFEA7C..0x82CFEA9C)
	// 82CFEA7C: 2B04063F  cmplwi cr6, r4, 0x63f
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1599 as u32, &mut ctx.xer);
	// 82CFEA80: 409A0020  bne cr6, 0x82cfeaa0
	if !ctx.cr[6].eq {
	pc = 0x82CFEAA0; continue 'dispatch;
	}
	// 82CFEA84: 54CB03DE  rlwinm r11, r6, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFEA88: 38E10140  addi r7, r1, 0x140
	ctx.r[7].s64 = ctx.r[1].s64 + 320;
	// 82CFEA8C: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 82CFEA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFEA94: 419A000C  beq cr6, 0x82cfeaa0
	if ctx.cr[6].eq {
	pc = 0x82CFEAA0; continue 'dispatch;
	}
	// 82CFEA98: 38E100E0  addi r7, r1, 0xe0
	ctx.r[7].s64 = ctx.r[1].s64 + 224;
	pc = 0x82CFEA9C; continue 'dispatch;
            }
            0x82CFEA9C => {
    //   block [0x82CFEA9C..0x82CFEAA0)
	// 82CFEA9C: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	pc = 0x82CFEAA0; continue 'dispatch;
            }
            0x82CFEAA0 => {
    //   block [0x82CFEAA0..0x82CFEAE0)
	// 82CFEAA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFEAA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFEAA8: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82CFEAAC: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82CFEAB0: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82CFEAB4: C18B0BE0  lfs f12, 0xbe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3040 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFEAB8: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 82CFEABC: C1AA0A4C  lfs f13, 0xa4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2636 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFEAC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFEAC4: C149167C  lfs f10, 0x167c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5756 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFEAC8: 2F080004  cmpwi cr6, r8, 4
	ctx.cr[6].compare_i32(ctx.r[8].s32, 4, &mut ctx.xer);
	// 82CFEACC: C1656924  lfs f11, 0x6924(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(26916 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFEAD0: 41980184  blt cr6, 0x82cfec54
	if ctx.cr[6].lt {
	pc = 0x82CFEC54; continue 'dispatch;
	}
	// 82CFEAD4: 38A8FFFD  addi r5, r8, -3
	ctx.r[5].s64 = ctx.r[8].s64 + -3;
	// 82CFEAD8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82CFEADC: 39270008  addi r9, r7, 8
	ctx.r[9].s64 = ctx.r[7].s64 + 8;
	pc = 0x82CFEAE0; continue 'dispatch;
            }
            0x82CFEAE0 => {
    //   block [0x82CFEAE0..0x82CFEAF8)
	// 82CFEAE0: C009FFF8  lfs f0, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFEAE4: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFEAE8: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82CFEAEC: 4099000C  ble cr6, 0x82cfeaf8
	if !ctx.cr[6].gt {
	pc = 0x82CFEAF8; continue 'dispatch;
	}
	// 82CFEAF0: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82CFEAF4: 48000010  b 0x82cfeb04
	pc = 0x82CFEB04; continue 'dispatch;
            }
            0x82CFEAF8 => {
    //   block [0x82CFEAF8..0x82CFEB04)
	// 82CFEAF8: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82CFEAFC: 40980008  bge cr6, 0x82cfeb04
	if !ctx.cr[6].lt {
	pc = 0x82CFEB04; continue 'dispatch;
	}
	// 82CFEB00: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	pc = 0x82CFEB04; continue 'dispatch;
            }
            0x82CFEB04 => {
    //   block [0x82CFEB04..0x82CFEB20)
	// 82CFEB04: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEB08: 41990018  bgt cr6, 0x82cfeb20
	if ctx.cr[6].gt {
	pc = 0x82CFEB20; continue 'dispatch;
	}
	// 82CFEB0C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82CFEB10: 40990010  ble cr6, 0x82cfeb20
	if !ctx.cr[6].gt {
	pc = 0x82CFEB20; continue 'dispatch;
	}
	// 82CFEB14: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82CFEB18: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82CFEB1C: 4800001C  b 0x82cfeb38
	pc = 0x82CFEB38; continue 'dispatch;
            }
            0x82CFEB20 => {
    //   block [0x82CFEB20..0x82CFEB38)
	// 82CFEB20: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEB24: 41980014  blt cr6, 0x82cfeb38
	if ctx.cr[6].lt {
	pc = 0x82CFEB38; continue 'dispatch;
	}
	// 82CFEB28: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82CFEB2C: 4098000C  bge cr6, 0x82cfeb38
	if !ctx.cr[6].lt {
	pc = 0x82CFEB38; continue 'dispatch;
	}
	// 82CFEB30: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82CFEB34: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82CFEB38; continue 'dispatch;
            }
            0x82CFEB38 => {
    //   block [0x82CFEB38..0x82CFEB50)
	// 82CFEB38: C009FFFC  lfs f0, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFEB3C: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFEB40: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82CFEB44: 4099000C  ble cr6, 0x82cfeb50
	if !ctx.cr[6].gt {
	pc = 0x82CFEB50; continue 'dispatch;
	}
	// 82CFEB48: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82CFEB4C: 48000010  b 0x82cfeb5c
	pc = 0x82CFEB5C; continue 'dispatch;
            }
            0x82CFEB50 => {
    //   block [0x82CFEB50..0x82CFEB5C)
	// 82CFEB50: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82CFEB54: 40980008  bge cr6, 0x82cfeb5c
	if !ctx.cr[6].lt {
	pc = 0x82CFEB5C; continue 'dispatch;
	}
	// 82CFEB58: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	pc = 0x82CFEB5C; continue 'dispatch;
            }
            0x82CFEB5C => {
    //   block [0x82CFEB5C..0x82CFEB78)
	// 82CFEB5C: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEB60: 41990018  bgt cr6, 0x82cfeb78
	if ctx.cr[6].gt {
	pc = 0x82CFEB78; continue 'dispatch;
	}
	// 82CFEB64: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82CFEB68: 40990010  ble cr6, 0x82cfeb78
	if !ctx.cr[6].gt {
	pc = 0x82CFEB78; continue 'dispatch;
	}
	// 82CFEB6C: 3BCAFFFF  addi r30, r10, -1
	ctx.r[30].s64 = ctx.r[10].s64 + -1;
	// 82CFEB70: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82CFEB74: 4800001C  b 0x82cfeb90
	pc = 0x82CFEB90; continue 'dispatch;
            }
            0x82CFEB78 => {
    //   block [0x82CFEB78..0x82CFEB90)
	// 82CFEB78: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEB7C: 41980014  blt cr6, 0x82cfeb90
	if ctx.cr[6].lt {
	pc = 0x82CFEB90; continue 'dispatch;
	}
	// 82CFEB80: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82CFEB84: 4098000C  bge cr6, 0x82cfeb90
	if !ctx.cr[6].lt {
	pc = 0x82CFEB90; continue 'dispatch;
	}
	// 82CFEB88: 3BEAFFFF  addi r31, r10, -1
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	// 82CFEB8C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82CFEB90; continue 'dispatch;
            }
            0x82CFEB90 => {
    //   block [0x82CFEB90..0x82CFEBA8)
	// 82CFEB90: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFEB94: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFEB98: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82CFEB9C: 4099000C  ble cr6, 0x82cfeba8
	if !ctx.cr[6].gt {
	pc = 0x82CFEBA8; continue 'dispatch;
	}
	// 82CFEBA0: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82CFEBA4: 48000010  b 0x82cfebb4
	pc = 0x82CFEBB4; continue 'dispatch;
            }
            0x82CFEBA8 => {
    //   block [0x82CFEBA8..0x82CFEBB4)
	// 82CFEBA8: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82CFEBAC: 40980008  bge cr6, 0x82cfebb4
	if !ctx.cr[6].lt {
	pc = 0x82CFEBB4; continue 'dispatch;
	}
	// 82CFEBB0: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	pc = 0x82CFEBB4; continue 'dispatch;
            }
            0x82CFEBB4 => {
    //   block [0x82CFEBB4..0x82CFEBD0)
	// 82CFEBB4: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEBB8: 41990018  bgt cr6, 0x82cfebd0
	if ctx.cr[6].gt {
	pc = 0x82CFEBD0; continue 'dispatch;
	}
	// 82CFEBBC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82CFEBC0: 40990010  ble cr6, 0x82cfebd0
	if !ctx.cr[6].gt {
	pc = 0x82CFEBD0; continue 'dispatch;
	}
	// 82CFEBC4: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 82CFEBC8: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82CFEBCC: 4800001C  b 0x82cfebe8
	pc = 0x82CFEBE8; continue 'dispatch;
            }
            0x82CFEBD0 => {
    //   block [0x82CFEBD0..0x82CFEBE8)
	// 82CFEBD0: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEBD4: 41980014  blt cr6, 0x82cfebe8
	if ctx.cr[6].lt {
	pc = 0x82CFEBE8; continue 'dispatch;
	}
	// 82CFEBD8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82CFEBDC: 4098000C  bge cr6, 0x82cfebe8
	if !ctx.cr[6].lt {
	pc = 0x82CFEBE8; continue 'dispatch;
	}
	// 82CFEBE0: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82CFEBE4: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82CFEBE8; continue 'dispatch;
            }
            0x82CFEBE8 => {
    //   block [0x82CFEBE8..0x82CFEC00)
	// 82CFEBE8: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFEBEC: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFEBF0: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82CFEBF4: 4099000C  ble cr6, 0x82cfec00
	if !ctx.cr[6].gt {
	pc = 0x82CFEC00; continue 'dispatch;
	}
	// 82CFEBF8: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82CFEBFC: 48000010  b 0x82cfec0c
	pc = 0x82CFEC0C; continue 'dispatch;
            }
            0x82CFEC00 => {
    //   block [0x82CFEC00..0x82CFEC0C)
	// 82CFEC00: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82CFEC04: 40980008  bge cr6, 0x82cfec0c
	if !ctx.cr[6].lt {
	pc = 0x82CFEC0C; continue 'dispatch;
	}
	// 82CFEC08: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	pc = 0x82CFEC0C; continue 'dispatch;
            }
            0x82CFEC0C => {
    //   block [0x82CFEC0C..0x82CFEC28)
	// 82CFEC0C: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEC10: 41990018  bgt cr6, 0x82cfec28
	if ctx.cr[6].gt {
	pc = 0x82CFEC28; continue 'dispatch;
	}
	// 82CFEC14: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82CFEC18: 40990010  ble cr6, 0x82cfec28
	if !ctx.cr[6].gt {
	pc = 0x82CFEC28; continue 'dispatch;
	}
	// 82CFEC1C: 3BCA0001  addi r30, r10, 1
	ctx.r[30].s64 = ctx.r[10].s64 + 1;
	// 82CFEC20: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82CFEC24: 4800001C  b 0x82cfec40
	pc = 0x82CFEC40; continue 'dispatch;
            }
            0x82CFEC28 => {
    //   block [0x82CFEC28..0x82CFEC40)
	// 82CFEC28: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEC2C: 41980014  blt cr6, 0x82cfec40
	if ctx.cr[6].lt {
	pc = 0x82CFEC40; continue 'dispatch;
	}
	// 82CFEC30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82CFEC34: 4098000C  bge cr6, 0x82cfec40
	if !ctx.cr[6].lt {
	pc = 0x82CFEC40; continue 'dispatch;
	}
	// 82CFEC38: 3BEA0001  addi r31, r10, 1
	ctx.r[31].s64 = ctx.r[10].s64 + 1;
	// 82CFEC3C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82CFEC40; continue 'dispatch;
            }
            0x82CFEC40 => {
    //   block [0x82CFEC40..0x82CFEC54)
	// 82CFEC40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFEC44: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 82CFEC48: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CFEC4C: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82CFEC50: 4198FE90  blt cr6, 0x82cfeae0
	if ctx.cr[6].lt {
	pc = 0x82CFEAE0; continue 'dispatch;
	}
	pc = 0x82CFEC54; continue 'dispatch;
            }
            0x82CFEC54 => {
    //   block [0x82CFEC54..0x82CFEC64)
	// 82CFEC54: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFEC58: 40980074  bge cr6, 0x82cfeccc
	if !ctx.cr[6].lt {
	pc = 0x82CFECCC; continue 'dispatch;
	}
	// 82CFEC5C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFEC60: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	pc = 0x82CFEC64; continue 'dispatch;
            }
            0x82CFEC64 => {
    //   block [0x82CFEC64..0x82CFEC7C)
	// 82CFEC64: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFEC68: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFEC6C: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82CFEC70: 4099000C  ble cr6, 0x82cfec7c
	if !ctx.cr[6].gt {
	pc = 0x82CFEC7C; continue 'dispatch;
	}
	// 82CFEC74: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82CFEC78: 48000010  b 0x82cfec88
	pc = 0x82CFEC88; continue 'dispatch;
            }
            0x82CFEC7C => {
    //   block [0x82CFEC7C..0x82CFEC88)
	// 82CFEC7C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82CFEC80: 40980008  bge cr6, 0x82cfec88
	if !ctx.cr[6].lt {
	pc = 0x82CFEC88; continue 'dispatch;
	}
	// 82CFEC84: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	pc = 0x82CFEC88; continue 'dispatch;
            }
            0x82CFEC88 => {
    //   block [0x82CFEC88..0x82CFECA4)
	// 82CFEC88: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFEC8C: 41990018  bgt cr6, 0x82cfeca4
	if ctx.cr[6].gt {
	pc = 0x82CFECA4; continue 'dispatch;
	}
	// 82CFEC90: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82CFEC94: 40990010  ble cr6, 0x82cfeca4
	if !ctx.cr[6].gt {
	pc = 0x82CFECA4; continue 'dispatch;
	}
	// 82CFEC98: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82CFEC9C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82CFECA0: 4800001C  b 0x82cfecbc
	pc = 0x82CFECBC; continue 'dispatch;
            }
            0x82CFECA4 => {
    //   block [0x82CFECA4..0x82CFECBC)
	// 82CFECA4: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82CFECA8: 41980014  blt cr6, 0x82cfecbc
	if ctx.cr[6].lt {
	pc = 0x82CFECBC; continue 'dispatch;
	}
	// 82CFECAC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82CFECB0: 4098000C  bge cr6, 0x82cfecbc
	if !ctx.cr[6].lt {
	pc = 0x82CFECBC; continue 'dispatch;
	}
	// 82CFECB4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82CFECB8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82CFECBC; continue 'dispatch;
            }
            0x82CFECBC => {
    //   block [0x82CFECBC..0x82CFECCC)
	// 82CFECBC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFECC0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CFECC4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFECC8: 4198FF9C  blt cr6, 0x82cfec64
	if ctx.cr[6].lt {
	pc = 0x82CFEC64; continue 'dispatch;
	}
	pc = 0x82CFECCC; continue 'dispatch;
            }
            0x82CFECCC => {
    //   block [0x82CFECCC..0x82CFECD8)
	// 82CFECCC: FF0C3800  fcmpu cr6, f12, f7
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[7].f64);
	// 82CFECD0: 40980008  bge cr6, 0x82cfecd8
	if !ctx.cr[6].lt {
	pc = 0x82CFECD8; continue 'dispatch;
	}
	// 82CFECD4: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82CFECD8; continue 'dispatch;
            }
            0x82CFECD8 => {
    //   block [0x82CFECD8..0x82CFECE4)
	// 82CFECD8: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82CFECDC: 40980008  bge cr6, 0x82cfece4
	if !ctx.cr[6].lt {
	pc = 0x82CFECE4; continue 'dispatch;
	}
	// 82CFECE0: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82CFECE4; continue 'dispatch;
            }
            0x82CFECE4 => {
    //   block [0x82CFECE4..0x82CFECF4)
	// 82CFECE4: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82CFECE8: 419A000C  beq cr6, 0x82cfecf4
	if ctx.cr[6].eq {
	pc = 0x82CFECF4; continue 'dispatch;
	}
	// 82CFECEC: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 82CFECF0: 409A000C  bne cr6, 0x82cfecfc
	if !ctx.cr[6].eq {
	pc = 0x82CFECFC; continue 'dispatch;
	}
	pc = 0x82CFECF4; continue 'dispatch;
            }
            0x82CFECF4 => {
    //   block [0x82CFECF4..0x82CFECFC)
	// 82CFECF4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CFECF8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82CFECFC; continue 'dispatch;
            }
            0x82CFECFC => {
    //   block [0x82CFECFC..0x82CFED14)
	// 82CFECFC: 54CB03DE  rlwinm r11, r6, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFED00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFED04: 419A001C  beq cr6, 0x82cfed20
	if ctx.cr[6].eq {
	pc = 0x82CFED20; continue 'dispatch;
	}
	// 82CFED08: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82CFED0C: 40990008  ble cr6, 0x82cfed14
	if !ctx.cr[6].gt {
	pc = 0x82CFED14; continue 'dispatch;
	}
	// 82CFED10: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82CFED14; continue 'dispatch;
            }
            0x82CFED14 => {
    //   block [0x82CFED14..0x82CFED20)
	// 82CFED14: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 82CFED18: 40990008  ble cr6, 0x82cfed20
	if !ctx.cr[6].gt {
	pc = 0x82CFED20; continue 'dispatch;
	}
	// 82CFED1C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x82CFED20; continue 'dispatch;
            }
            0x82CFED20 => {
    //   block [0x82CFED20..0x82CFED44)
	// 82CFED20: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFED24: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82CFED28: 419A003C  beq cr6, 0x82cfed64
	if ctx.cr[6].eq {
	pc = 0x82CFED64; continue 'dispatch;
	}
	// 82CFED2C: 548B077A  rlwinm r11, r4, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFED30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFED34: 419A0018  beq cr6, 0x82cfed4c
	if ctx.cr[6].eq {
	pc = 0x82CFED4C; continue 'dispatch;
	}
	// 82CFED38: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 82CFED3C: 40990008  ble cr6, 0x82cfed44
	if !ctx.cr[6].gt {
	pc = 0x82CFED44; continue 'dispatch;
	}
	// 82CFED40: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82CFED44; continue 'dispatch;
            }
            0x82CFED44 => {
    //   block [0x82CFED44..0x82CFED4C)
	// 82CFED44: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 82CFED48: 48000014  b 0x82cfed5c
	pc = 0x82CFED5C; continue 'dispatch;
            }
            0x82CFED4C => {
    //   block [0x82CFED4C..0x82CFED58)
	// 82CFED4C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82CFED50: 40990008  ble cr6, 0x82cfed58
	if !ctx.cr[6].gt {
	pc = 0x82CFED58; continue 'dispatch;
	}
	// 82CFED54: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82CFED58; continue 'dispatch;
            }
            0x82CFED58 => {
    //   block [0x82CFED58..0x82CFED5C)
	// 82CFED58: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	pc = 0x82CFED5C; continue 'dispatch;
            }
            0x82CFED5C => {
    //   block [0x82CFED5C..0x82CFED64)
	// 82CFED5C: 40990008  ble cr6, 0x82cfed64
	if !ctx.cr[6].gt {
	pc = 0x82CFED64; continue 'dispatch;
	}
	// 82CFED60: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x82CFED64; continue 'dispatch;
            }
            0x82CFED64 => {
    //   block [0x82CFED64..0x82CFEDA0)
	// 82CFED64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFED68: C00B0C38  lfs f0, 0xc38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFED6C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82CFED70: 40980030  bge cr6, 0x82cfeda0
	if !ctx.cr[6].lt {
	pc = 0x82CFEDA0; continue 'dispatch;
	}
	// 82CFED74: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFED78: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFED7C: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFED80: 7D2AE214  add r9, r10, r28
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82CFED84: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFED88: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFED8C: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82CFED90: 7DAA5D2E  stfsx f13, r10, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFED94: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82CFED98: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFED9C: 4BFAA6BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFEDA0 => {
    //   block [0x82CFEDA0..0x82CFEDD4)
	// 82CFEDA0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFEDA4: 40980030  bge cr6, 0x82cfedd4
	if !ctx.cr[6].lt {
	pc = 0x82CFEDD4; continue 'dispatch;
	}
	// 82CFEDA8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFEDAC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFEDB0: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFEDB4: 7D2AE214  add r9, r10, r28
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82CFEDB8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFEDBC: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFEDC0: EDBF002A  fadds f13, f31, f0
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFEDC4: 7DAA5D2E  stfsx f13, r10, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFEDC8: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82CFEDCC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFEDD0: 4BFAA688  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFEDD4 => {
    //   block [0x82CFEDD4..0x82CFEE44)
	// 82CFEDD4: EC0C0172  fmuls f0, f12, f5
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[5].f64) as f32) as f64);
	// 82CFEDD8: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82CFEDDC: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82CFEDE0: 4B595339  bl 0x82294118
	ctx.lr = 0x82CFEDE4;
	sub_82294118(ctx, base);
	// 82CFEDE4: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFEDE8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFEDEC: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFEDF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFEDF4: 7D5E41D6  mullw r10, r30, r8
	ctx.r[10].s32 = ((ctx.r[30].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFEDF8: C0090C14  lfs f0, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFEDFC: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFEE00: 7CEAE214  add r7, r10, r28
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82CFEE04: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFEE08: ED5F5824  fdivs f10, f31, f11
	ctx.f[10].f64 = ((ctx.f[31].f64 / ctx.f[11].f64) as f32) as f64;
	// 82CFEE0C: 7D2A5C2E  lfsx f9, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFEE10: ED09502A  fadds f8, f9, f10
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 82CFEE14: 7D0A5D2E  stfsx f8, r10, r11
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFEE18: 80DD0008  lwz r6, 8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFEE1C: 7D7F31D6  mullw r11, r31, r6
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CFEE20: 7CABE214  add r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82CFEE24: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFEE28: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFEE2C: 7CEA5C2E  lfsx f7, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFEE30: ECCC3ABA  fmadds f6, f12, f10, f7
	ctx.f[6].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[7].f64) as f32) as f64);
	// 82CFEE34: 7CCA5D2E  stfsx f6, r10, r11
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFEE38: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82CFEE3C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFEE40: 4BFAA618  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFEE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFEE48 size=1312
    let mut pc: u32 = 0x82CFEE48;
    'dispatch: loop {
        match pc {
            0x82CFEE48 => {
    //   block [0x82CFEE48..0x82CFEEF8)
	// 82CFEE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFEE4C: 4BFAA5AD  bl 0x82ca93f8
	ctx.lr = 0x82CFEE50;
	sub_82CA93D0(ctx, base);
	// 82CFEE50: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82CFEE54: 4BFAEE51  bl 0x82cadca4
	ctx.lr = 0x82CFEE58;
	sub_82CADCA0(ctx, base);
	// 82CFEE58: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFEE5C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CFEE60: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CFEE64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82CFEE68: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82CFEE6C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82CFEE70: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82CFEE74: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CFEE78: 4BFAA609  bl 0x82ca9480
	ctx.lr = 0x82CFEE7C;
	sub_82CA9480(ctx, base);
	// 82CFEE7C: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82CFEE80: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82CFEE84: 3879000C  addi r3, r25, 0xc
	ctx.r[3].s64 = ctx.r[25].s64 + 12;
	// 82CFEE88: 48000819  bl 0x82cff6a0
	ctx.lr = 0x82CFEE8C;
	sub_82CFF6A0(ctx, base);
	// 82CFEE8C: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 82CFEE90: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82CFEE94: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82CFEE98: 48000809  bl 0x82cff6a0
	ctx.lr = 0x82CFEE9C;
	sub_82CFF6A0(ctx, base);
	// 82CFEE9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFEEA0: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFEEA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CFEEA8: C32A0C18  lfs f25, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82CFEEAC: FEA0C890  fmr f21, f25
	ctx.f[21].f64 = ctx.f[25].f64;
	// 82CFEEB0: FE80C890  fmr f20, f25
	ctx.f[20].f64 = ctx.f[25].f64;
	// 82CFEEB4: FE60C890  fmr f19, f25
	ctx.f[19].f64 = ctx.f[25].f64;
	// 82CFEEB8: 40990040  ble cr6, 0x82cfeef8
	if !ctx.cr[6].gt {
	pc = 0x82CFEEF8; continue 'dispatch;
	}
	// 82CFEEBC: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFEEC0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFEEC4: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFEEC8: 80FD0040  lwz r7, 0x40(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 82CFEECC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFEED0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFEED4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82CFEED8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFEEDC: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82CFEEE0: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFEEE4: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82CFEEE8: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFEEEC: EE8C02F2  fmuls f20, f12, f11
	ctx.f[20].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFEEF0: EEAD02F2  fmuls f21, f13, f11
	ctx.f[21].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFEEF4: EE6002F2  fmuls f19, f0, f11
	ctx.f[19].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	pc = 0x82CFEEF8; continue 'dispatch;
            }
            0x82CFEEF8 => {
    //   block [0x82CFEEF8..0x82CFEF4C)
	// 82CFEEF8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CFEEFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFEF00: 419A0458  beq cr6, 0x82cff358
	if ctx.cr[6].eq {
	pc = 0x82CFF358; continue 'dispatch;
	}
	// 82CFEF04: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CFEF08: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFEF0C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFEF10: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CFEF14: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CFEF18: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFEF1C: C24A6930  lfs f18, 0x6930(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26928 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82CFEF20: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CFEF24: C2090BFC  lfs f16, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 82CFEF28: 3C608201  lis r3, -0x7dff
	ctx.r[3].s64 = -2113863680;
	// 82CFEF2C: C2C80B40  lfs f22, 0xb40(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2880 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82CFEF30: C2E70C4C  lfs f23, 0xc4c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3148 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82CFEF34: 3B1D001C  addi r24, r29, 0x1c
	ctx.r[24].s64 = ctx.r[29].s64 + 28;
	// 82CFEF38: C306692C  lfs f24, 0x692c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(26924 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82CFEF3C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82CFEF40: C3450C38  lfs f26, 0xc38(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3128 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82CFEF44: C3640C14  lfs f27, 0xc14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3092 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82CFEF48: C2236924  lfs f17, 0x6924(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(26916 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	pc = 0x82CFEF4C; continue 'dispatch;
            }
            0x82CFEF4C => {
    //   block [0x82CFEF4C..0x82CFF05C)
	// 82CFEF4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CFEF50: 4099010C  ble cr6, 0x82cff05c
	if !ctx.cr[6].gt {
	pc = 0x82CFF05C; continue 'dispatch;
	}
	// 82CFEF54: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CFEF58: 7C3B5C2E  lfsx f1, r27, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CFEF5C: FF018800  fcmpu cr6, f1, f17
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[17].f64);
	// 82CFEF60: 419A00FC  beq cr6, 0x82cff05c
	if ctx.cr[6].eq {
	pc = 0x82CFF05C; continue 'dispatch;
	}
	// 82CFEF64: 4B53AF4D  bl 0x82239eb0
	ctx.lr = 0x82CFEF68;
	sub_82239EB0(ctx, base);
	// 82CFEF68: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CFEF6C: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFEF70: 7C3B5C2E  lfsx f1, r27, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CFEF74: 4B53B01D  bl 0x82239f90
	ctx.lr = 0x82CFEF78;
	sub_82239F90(ctx, base);
	// 82CFEF78: 813D0018  lwz r9, 0x18(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFEF7C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFEF80: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFEF84: EC1BF828  fsubs f0, f27, f31
	ctx.f[0].f64 = (((ctx.f[27].f64 - ctx.f[31].f64) as f32) as f64);
	// 82CFEF88: 811D0010  lwz r8, 0x10(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CFEF8C: 80FD0020  lwz r7, 0x20(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CFEF90: 80DD0024  lwz r6, 0x24(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CFEF94: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CFEF98: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFEF9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFEFA0: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFEFA4: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82CFEFA8: C1410058  lfs f10, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFEFAC: ED0C02B2  fmuls f8, f12, f10
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CFEFB0: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82CFEFB4: ECEC02F2  fmuls f7, f12, f11
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFEFB8: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 82CFEFBC: EC2A02F2  fmuls f1, f10, f11
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFEFC0: C0C1005C  lfs f6, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CFEFC4: ECAB0372  fmuls f5, f11, f13
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFEFC8: C0810060  lfs f4, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CFEFCC: EC6A0372  fmuls f3, f10, f13
	ctx.f[3].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFEFD0: 80B80000  lwz r5, 0(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFEFD4: EC4B02F2  fmuls f2, f11, f11
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFEFD8: ED2A02B2  fmuls f9, f10, f10
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CFEFDC: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFEFE0: ED6C0332  fmuls f11, f12, f12
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFEFE4: ED880032  fmuls f12, f8, f0
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFEFE8: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 82CFEFEC: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFEFF0: ED070032  fmuls f8, f7, f0
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFEFF4: ECE2F83A  fmadds f7, f2, f0, f31
	ctx.f[7].f64 = (((ctx.f[2].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82CFEFF8: EC410032  fmuls f2, f1, f0
	ctx.f[2].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFEFFC: ED29F83A  fmadds f9, f9, f0, f31
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82CFF000: EC2BF83A  fmadds f1, f11, f0, f31
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82CFF004: EC0C2828  fsubs f0, f12, f5
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[5].f64) as f32) as f64);
	// 82CFF008: ECA5602A  fadds f5, f5, f12
	ctx.f[5].f64 = ((ctx.f[5].f64 + ctx.f[12].f64) as f32) as f64;
	// 82CFF00C: ED681828  fsubs f11, f8, f3
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[3].f64) as f32) as f64);
	// 82CFF010: ED03402A  fadds f8, f3, f8
	ctx.f[8].f64 = ((ctx.f[3].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CFF014: EC6A102A  fadds f3, f10, f2
	ctx.f[3].f64 = ((ctx.f[10].f64 + ctx.f[2].f64) as f32) as f64;
	// 82CFF018: EC425028  fsubs f2, f2, f10
	ctx.f[2].f64 = (((ctx.f[2].f64 - ctx.f[10].f64) as f32) as f64);
	// 82CFF01C: EC000532  fmuls f0, f0, f20
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 82CFF020: ED8B04F2  fmuls f12, f11, f19
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[19].f64) as f32) as f64);
	// 82CFF024: ED680532  fmuls f11, f8, f20
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[20].f64) as f32) as f64);
	// 82CFF028: ED49057A  fmadds f10, f9, f21, f0
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[21].f64 + ctx.f[0].f64) as f32) as f64);
	// 82CFF02C: ED21653A  fmadds f9, f1, f20, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[20].f64 + ctx.f[12].f64) as f32) as f64);
	// 82CFF030: ED075CFA  fmadds f8, f7, f19, f11
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[19].f64 + ctx.f[11].f64) as f32) as f64);
	// 82CFF034: ECE354FA  fmadds f7, f3, f19, f10
	ctx.f[7].f64 = (((ctx.f[3].f64 * ctx.f[19].f64 + ctx.f[10].f64) as f32) as f64);
	// 82CFF038: ECA54D7A  fmadds f5, f5, f21, f9
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[21].f64 + ctx.f[9].f64) as f32) as f64);
	// 82CFF03C: EC62457A  fmadds f3, f2, f21, f8
	ctx.f[3].f64 = (((ctx.f[2].f64 * ctx.f[21].f64 + ctx.f[8].f64) as f32) as f64);
	// 82CFF040: EC47682A  fadds f2, f7, f13
	ctx.f[2].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 82CFF044: D04100A0  stfs f2, 0xa0(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82CFF048: EC25302A  fadds f1, f5, f6
	ctx.f[1].f64 = ((ctx.f[5].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CFF04C: D02100A4  stfs f1, 0xa4(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82CFF050: EC03202A  fadds f0, f3, f4
	ctx.f[0].f64 = ((ctx.f[3].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CFF054: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82CFF058: 48000014  b 0x82cff06c
	pc = 0x82CFF06C; continue 'dispatch;
            }
            0x82CFF05C => {
    //   block [0x82CFF05C..0x82CFF06C)
	// 82CFF05C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFF060: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82CFF064: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82CFF068: 4BFAA419  bl 0x82ca9480
	ctx.lr = 0x82CFF06C;
	sub_82CA9480(ctx, base);
	pc = 0x82CFF06C; continue 'dispatch;
            }
            0x82CFF06C => {
    //   block [0x82CFF06C..0x82CFF088)
	// 82CFF06C: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFF070: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CFF074: 40990014  ble cr6, 0x82cff088
	if !ctx.cr[6].gt {
	pc = 0x82CFF088; continue 'dispatch;
	}
	// 82CFF078: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CFF07C: 7C0BDC2E  lfsx f0, r11, r27
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF080: FF008800  fcmpu cr6, f0, f17
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[17].f64);
	// 82CFF084: 419A02C0  beq cr6, 0x82cff344
	if ctx.cr[6].eq {
	pc = 0x82CFF344; continue 'dispatch;
	}
	pc = 0x82CFF088; continue 'dispatch;
            }
            0x82CFF088 => {
    //   block [0x82CFF088..0x82CFF124)
	// 82CFF088: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82CFF08C: 38990018  addi r4, r25, 0x18
	ctx.r[4].s64 = ctx.r[25].s64 + 24;
	// 82CFF090: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFF094: 480005D5  bl 0x82cff668
	ctx.lr = 0x82CFF098;
	sub_82CFF668(ctx, base);
	// 82CFF098: C00100C4  lfs f0, 0xc4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF09C: C16100B4  lfs f11, 0xb4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFF0A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFF0A4: ED4002F2  fmuls f10, f0, f11
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFF0A8: C06100D4  lfs f3, 0xd4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CFF0AC: C1A100C8  lfs f13, 0xc8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFF0B0: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFF0B4: C1210094  lfs f9, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFF0B8: C10100B8  lfs f8, 0xb8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CFF0BC: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFF0C0: C02100D8  lfs f1, 0xd8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CFF0C4: C18100C0  lfs f12, 0xc0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFF0C8: C0C10098  lfs f6, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CFF0CC: C0A100B0  lfs f5, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CFF0D0: C0810090  lfs f4, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CFF0D4: ED6D523A  fmadds f11, f13, f8, f10
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64);
	// 82CFF0D8: ED21137A  fmadds f9, f1, f13, f2
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 + ctx.f[2].f64) as f32) as f64);
	// 82CFF0DC: ED463B7A  fmadds f10, f6, f13, f7
	ctx.f[10].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64);
	// 82CFF0E0: C00100D0  lfs f0, 0xd0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF0E4: 7F9B5C2E  lfsx f28, r27, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82CFF0E8: EC2C597A  fmadds f1, f12, f5, f11
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[5].f64 + ctx.f[11].f64) as f32) as f64);
	// 82CFF0EC: 7F3B5D2E  stfsx f25, r27, r11
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82CFF0F0: EFA04B3A  fmadds f29, f0, f12, f9
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 82CFF0F4: EC44533A  fmadds f2, f4, f12, f10
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64);
	// 82CFF0F8: ED010072  fmuls f8, f1, f1
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CFF0FC: ECE240BA  fmadds f7, f2, f2, f8
	ctx.f[7].f64 = (((ctx.f[2].f64 * ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64);
	// 82CFF100: EFE0382C  fsqrts f31, f7
	ctx.f[31].f64 = ((ctx.f[7].f64).sqrt() as f32) as f64;
	// 82CFF104: FF1FD000  fcmpu cr6, f31, f26
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[26].f64);
	// 82CFF108: 41990098  bgt cr6, 0x82cff1a0
	if ctx.cr[6].gt {
	pc = 0x82CFF1A0; continue 'dispatch;
	}
	// 82CFF10C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFF110: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFF114: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CFF118: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82CFF11C: 419A0008  beq cr6, 0x82cff124
	if ctx.cr[6].eq {
	pc = 0x82CFF124; continue 'dispatch;
	}
	// 82CFF120: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82CFF124; continue 'dispatch;
            }
            0x82CFF124 => {
    //   block [0x82CFF124..0x82CFF134)
	// 82CFF124: 574903DE  rlwinm r9, r26, 0, 0xf, 0xf
	ctx.r[9].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFF128: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFF12C: 419A0008  beq cr6, 0x82cff134
	if ctx.cr[6].eq {
	pc = 0x82CFF134; continue 'dispatch;
	}
	// 82CFF130: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82CFF134; continue 'dispatch;
            }
            0x82CFF134 => {
    //   block [0x82CFF134..0x82CFF158)
	// 82CFF134: 79680020  clrldi r8, r11, 0x20
	ctx.r[8].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82CFF138: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFF13C: F9010080  std r8, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[8].u64 ) };
	// 82CFF140: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFF144: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82CFF148: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82CFF14C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82CFF150: EC1C6024  fdivs f0, f28, f12
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[12].f64) as f32) as f64;
	// 82CFF154: 419A01F0  beq cr6, 0x82cff344
	if ctx.cr[6].eq {
	pc = 0x82CFF344; continue 'dispatch;
	}
	pc = 0x82CFF158; continue 'dispatch;
            }
            0x82CFF158 => {
    //   block [0x82CFF158..0x82CFF174)
	// 82CFF158: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFF15C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFF160: 419A002C  beq cr6, 0x82cff18c
	if ctx.cr[6].eq {
	pc = 0x82CFF18C; continue 'dispatch;
	}
	// 82CFF164: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CFF168: 409A000C  bne cr6, 0x82cff174
	if !ctx.cr[6].eq {
	pc = 0x82CFF174; continue 'dispatch;
	}
	// 82CFF16C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CFF170: 409A001C  bne cr6, 0x82cff18c
	if !ctx.cr[6].eq {
	pc = 0x82CFF18C; continue 'dispatch;
	}
	pc = 0x82CFF174; continue 'dispatch;
            }
            0x82CFF174 => {
    //   block [0x82CFF174..0x82CFF18C)
	// 82CFF174: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFF178: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFF17C: 7D4A59D6  mullw r10, r10, r11
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFF180: 7CEAF214  add r7, r10, r30
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82CFF184: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFF188: 7C06452E  stfsx f0, r6, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	pc = 0x82CFF18C; continue 'dispatch;
            }
            0x82CFF18C => {
    //   block [0x82CFF18C..0x82CFF1A0)
	// 82CFF18C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFF190: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFF194: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFF198: 4198FFC0  blt cr6, 0x82cff158
	if ctx.cr[6].lt {
	pc = 0x82CFF158; continue 'dispatch;
	}
	// 82CFF19C: 480001A8  b 0x82cff344
	pc = 0x82CFF344; continue 'dispatch;
            }
            0x82CFF1A0 => {
    //   block [0x82CFF1A0..0x82CFF1E0)
	// 82CFF1A0: 4B49FA09  bl 0x8219eba8
	ctx.lr = 0x82CFF1A4;
	sub_8219EBA8(ctx, base);
	// 82CFF1A4: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CFF1A8: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFF1AC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82CFF1B0: C0210068  lfs f1, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CFF1B4: 4B53ADDD  bl 0x82239f90
	ctx.lr = 0x82CFF1B8;
	sub_82239F90(ctx, base);
	// 82CFF1B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFF1BC: 815D0034  lwz r10, 0x34(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CFF1C0: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82CFF1C4: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFF1C8: ED806F7A  fmadds f12, f0, f29, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFF1CC: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 82CFF1D0: 41980010  blt cr6, 0x82cff1e0
	if ctx.cr[6].lt {
	pc = 0x82CFF1E0; continue 'dispatch;
	}
	// 82CFF1D4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82CFF1D8: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82CFF1DC: 4800006C  b 0x82cff248
	pc = 0x82CFF248; continue 'dispatch;
            }
            0x82CFF1E0 => {
    //   block [0x82CFF1E0..0x82CFF248)
	// 82CFF1E0: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CFF1E4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82CFF1E8: C0210070  lfs f1, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CFF1EC: 4B53ADA5  bl 0x82239f90
	ctx.lr = 0x82CFF1F0;
	sub_82239F90(ctx, base);
	// 82CFF1F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFF1F4: 815D0034  lwz r10, 0x34(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CFF1F8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82CFF1FC: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFF200: ED806F7A  fmadds f12, f0, f29, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFF204: ED6CF828  fsubs f11, f12, f31
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[31].f64) as f32) as f64);
	// 82CFF208: ED4C05F2  fmuls f10, f12, f23
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[23].f64) as f32) as f64);
	// 82CFF20C: ED2B0632  fmuls f9, f11, f24
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[24].f64) as f32) as f64);
	// 82CFF210: EC295024  fdivs f1, f9, f10
	ctx.f[1].f64 = ((ctx.f[9].f64 / ctx.f[10].f64) as f32) as f64;
	// 82CFF214: 4B594F05  bl 0x82294118
	ctx.lr = 0x82CFF218;
	sub_82294118(ctx, base);
	// 82CFF218: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFF21C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CFF220: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82CFF224: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82CFF228: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82CFF22C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CFF230: ED1DD82A  fadds f8, f29, f27
	ctx.f[8].f64 = ((ctx.f[29].f64 + ctx.f[27].f64) as f32) as f64;
	// 82CFF234: EDFC4024  fdivs f15, f28, f8
	ctx.f[15].f64 = ((ctx.f[28].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CFF238: FC207890  fmr f1, f15
	ctx.f[1].f64 = ctx.f[15].f64;
	// 82CFF23C: 4BFFF51D  bl 0x82cfe758
	ctx.lr = 0x82CFF240;
	sub_82CFE758(ctx, base);
	// 82CFF240: EC5EB02A  fadds f2, f30, f22
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ((ctx.f[30].f64 + ctx.f[22].f64) as f32) as f64;
	// 82CFF244: EC2F0772  fmuls f1, f15, f29
	ctx.f[1].f64 = (((ctx.f[15].f64 * ctx.f[29].f64) as f32) as f64);
	pc = 0x82CFF248; continue 'dispatch;
            }
            0x82CFF248 => {
    //   block [0x82CFF248..0x82CFF278)
	// 82CFF248: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CFF24C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82CFF250: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82CFF254: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CFF258: 4BFFF501  bl 0x82cfe758
	ctx.lr = 0x82CFF25C;
	sub_82CFE758(ctx, base);
	// 82CFF25C: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CFF260: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82CFF264: C0010078  lfs f0, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF268: EC000432  fmuls f0, f0, f16
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[16].f64) as f32) as f64);
	// 82CFF26C: FF009000  fcmpu cr6, f0, f18
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[18].f64);
	// 82CFF270: 40980008  bge cr6, 0x82cff278
	if !ctx.cr[6].lt {
	pc = 0x82CFF278; continue 'dispatch;
	}
	// 82CFF274: FC009090  fmr f0, f18
	ctx.f[0].f64 = ctx.f[18].f64;
	pc = 0x82CFF278; continue 'dispatch;
            }
            0x82CFF278 => {
    //   block [0x82CFF278..0x82CFF298)
	// 82CFF278: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82CFF27C: 419900C8  bgt cr6, 0x82cff344
	if ctx.cr[6].gt {
	pc = 0x82CFF344; continue 'dispatch;
	}
	// 82CFF280: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFF284: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFF288: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CFF28C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82CFF290: 419A0008  beq cr6, 0x82cff298
	if ctx.cr[6].eq {
	pc = 0x82CFF298; continue 'dispatch;
	}
	// 82CFF294: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82CFF298; continue 'dispatch;
            }
            0x82CFF298 => {
    //   block [0x82CFF298..0x82CFF2A8)
	// 82CFF298: 574803DE  rlwinm r8, r26, 0, 0xf, 0xf
	ctx.r[8].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFF29C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFF2A0: 419A0008  beq cr6, 0x82cff2a8
	if ctx.cr[6].eq {
	pc = 0x82CFF2A8; continue 'dispatch;
	}
	// 82CFF2A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82CFF2A8; continue 'dispatch;
            }
            0x82CFF2A8 => {
    //   block [0x82CFF2A8..0x82CFF2D4)
	// 82CFF2A8: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82CFF2AC: EDBFD028  fsubs f13, f31, f26
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[26].f64) as f32) as f64);
	// 82CFF2B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFF2B4: F9210088  std r9, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u64 ) };
	// 82CFF2B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFF2BC: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82CFF2C0: C9810088  lfd f12, 0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82CFF2C4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CFF2C8: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CFF2CC: EDBC5024  fdivs f13, f28, f10
	ctx.f[13].f64 = ((ctx.f[28].f64 / ctx.f[10].f64) as f32) as f64;
	// 82CFF2D0: 419A0074  beq cr6, 0x82cff344
	if ctx.cr[6].eq {
	pc = 0x82CFF344; continue 'dispatch;
	}
	pc = 0x82CFF2D4; continue 'dispatch;
            }
            0x82CFF2D4 => {
    //   block [0x82CFF2D4..0x82CFF2F0)
	// 82CFF2D4: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFF2D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFF2DC: 419A0058  beq cr6, 0x82cff334
	if ctx.cr[6].eq {
	pc = 0x82CFF334; continue 'dispatch;
	}
	// 82CFF2E0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CFF2E4: 409A000C  bne cr6, 0x82cff2f0
	if !ctx.cr[6].eq {
	pc = 0x82CFF2F0; continue 'dispatch;
	}
	// 82CFF2E8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFF2EC: 409A0048  bne cr6, 0x82cff334
	if !ctx.cr[6].eq {
	pc = 0x82CFF334; continue 'dispatch;
	}
	pc = 0x82CFF2F0; continue 'dispatch;
            }
            0x82CFF2F0 => {
    //   block [0x82CFF2F0..0x82CFF334)
	// 82CFF2F0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFF2F4: ED9B0028  fsubs f12, f27, f0
	ctx.f[12].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFF2F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFF2FC: 7D2959D6  mullw r9, r9, r11
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82CFF300: 7CE9F214  add r7, r9, r30
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82CFF304: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFF308: 7D69542E  lfsx f11, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFF30C: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFF310: 7D49552E  stfsx f10, r9, r10
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82CFF314: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFF318: 7D4659D6  mullw r10, r6, r11
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CFF31C: 7CAAF214  add r5, r10, r30
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82CFF320: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFF324: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFF328: 7D29542E  lfsx f9, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFF32C: ED0C4B7A  fmadds f8, f12, f13, f9
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 82CFF330: 7D09552E  stfsx f8, r9, r10
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	pc = 0x82CFF334; continue 'dispatch;
            }
            0x82CFF334 => {
    //   block [0x82CFF334..0x82CFF344)
	// 82CFF334: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CFF338: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFF33C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFF340: 4198FF94  blt cr6, 0x82cff2d4
	if ctx.cr[6].lt {
	pc = 0x82CFF2D4; continue 'dispatch;
	}
	pc = 0x82CFF344; continue 'dispatch;
            }
            0x82CFF344 => {
    //   block [0x82CFF344..0x82CFF358)
	// 82CFF344: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFF348: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82CFF34C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82CFF350: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFF354: 4198FBF8  blt cr6, 0x82cfef4c
	if ctx.cr[6].lt {
	pc = 0x82CFEF4C; continue 'dispatch;
	}
	pc = 0x82CFF358; continue 'dispatch;
            }
            0x82CFF358 => {
    //   block [0x82CFF358..0x82CFF368)
	// 82CFF358: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82CFF35C: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82CFF360: 4BFAE991  bl 0x82cadcf0
	ctx.lr = 0x82CFF364;
	sub_82CADCEC(ctx, base);
	// 82CFF364: 4BFAA0E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFF368 size=368
    let mut pc: u32 = 0x82CFF368;
    'dispatch: loop {
        match pc {
            0x82CFF368 => {
    //   block [0x82CFF368..0x82CFF468)
	// 82CFF368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFF36C: 4BFAA0A1  bl 0x82ca940c
	ctx.lr = 0x82CFF370;
	sub_82CA93D0(ctx, base);
	// 82CFF370: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82CFF374: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82CFF378: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFF37C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CFF380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CFF384: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82CFF388: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CFF38C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82CFF390: 4BFAA0F1  bl 0x82ca9480
	ctx.lr = 0x82CFF394;
	sub_82CA9480(ctx, base);
	// 82CFF394: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82CFF398: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CFF39C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82CFF3A0: 48000301  bl 0x82cff6a0
	ctx.lr = 0x82CFF3A4;
	sub_82CFF6A0(ctx, base);
	// 82CFF3A4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82CFF3A8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82CFF3AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CFF3B0: 480002F1  bl 0x82cff6a0
	ctx.lr = 0x82CFF3B4;
	sub_82CFF6A0(ctx, base);
	// 82CFF3B4: 389D001C  addi r4, r29, 0x1c
	ctx.r[4].s64 = ctx.r[29].s64 + 28;
	// 82CFF3B8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82CFF3BC: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82CFF3C0: 4BFAA0C1  bl 0x82ca9480
	ctx.lr = 0x82CFF3C4;
	sub_82CA9480(ctx, base);
	// 82CFF3C4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82CFF3C8: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 82CFF3CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82CFF3D0: 48000299  bl 0x82cff668
	ctx.lr = 0x82CFF3D4;
	sub_82CFF668(ctx, base);
	// 82CFF3D4: C1A10074  lfs f13, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFF3D8: C1410064  lfs f10, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFF3DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFF3E0: ED2D02B2  fmuls f9, f13, f10
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CFF3E4: C1810078  lfs f12, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFF3E8: C1010054  lfs f8, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CFF3EC: C0E10068  lfs f7, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFF3F0: ECC80372  fmuls f6, f8, f13
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFF3F4: C1610070  lfs f11, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFF3F8: C0A10058  lfs f5, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CFF3FC: C0810060  lfs f4, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CFF400: C00B0C38  lfs f0, 0xc38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF404: C0610050  lfs f3, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CFF408: EC4C49FA  fmadds f2, f12, f7, f9
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64);
	// 82CFF40C: EC25333A  fmadds f1, f5, f12, f6
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64);
	// 82CFF410: EFEB113A  fmadds f31, f11, f4, f2
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[4].f64 + ctx.f[2].f64) as f32) as f64);
	// 82CFF414: EC430AFA  fmadds f2, f3, f11, f1
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[11].f64 + ctx.f[1].f64) as f32) as f64);
	// 82CFF418: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82CFF41C: 4199004C  bgt cr6, 0x82cff468
	if ctx.cr[6].gt {
	pc = 0x82CFF468; continue 'dispatch;
	}
	// 82CFF420: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82CFF424: 41990044  bgt cr6, 0x82cff468
	if ctx.cr[6].gt {
	pc = 0x82CFF468; continue 'dispatch;
	}
	// 82CFF428: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFF42C: C00B0A5C  lfs f0, 0xa5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF430: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82CFF434: 41980034  blt cr6, 0x82cff468
	if ctx.cr[6].lt {
	pc = 0x82CFF468; continue 'dispatch;
	}
	// 82CFF438: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82CFF43C: 4198002C  blt cr6, 0x82cff468
	if ctx.cr[6].lt {
	pc = 0x82CFF468; continue 'dispatch;
	}
	// 82CFF440: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFF444: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFF448: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF44C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFF450: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFF454: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFF458: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82CFF45C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFF460: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFF464: 4BFA9FF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFF468 => {
    //   block [0x82CFF468..0x82CFF4AC)
	// 82CFF468: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82CFF46C: 4B49F73D  bl 0x8219eba8
	ctx.lr = 0x82CFF470;
	sub_8219EBA8(ctx, base);
	// 82CFF470: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFF474: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFF478: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82CFF47C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82CFF480: 4099002C  ble cr6, 0x82cff4ac
	if !ctx.cr[6].gt {
	pc = 0x82CFF4AC; continue 'dispatch;
	}
	// 82CFF484: 4B53AB0D  bl 0x82239f90
	ctx.lr = 0x82CFF488;
	sub_82239F90(ctx, base);
	// 82CFF488: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFF48C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFF490: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFF494: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFF498: D3CA0004  stfs f30, 4(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFF49C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82CFF4A0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFF4A4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFF4A8: 4BFA9FB4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82CFF4AC => {
    //   block [0x82CFF4AC..0x82CFF4D8)
	// 82CFF4AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFF4B0: FC200850  fneg f1, f1
	ctx.f[1].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82CFF4B4: D3CB0000  stfs f30, 0(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFF4B8: 4B53AAD9  bl 0x82239f90
	ctx.lr = 0x82CFF4BC;
	sub_82239F90(ctx, base);
	// 82CFF4BC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFF4C0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFF4C4: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFF4C8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82CFF4CC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFF4D0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFF4D4: 4BFA9F88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFF4D8 size=328
    let mut pc: u32 = 0x82CFF4D8;
    'dispatch: loop {
        match pc {
            0x82CFF4D8 => {
    //   block [0x82CFF4D8..0x82CFF53C)
	// 82CFF4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFF4DC: 4BFA9F29  bl 0x82ca9404
	ctx.lr = 0x82CFF4E0;
	sub_82CA93D0(ctx, base);
	// 82CFF4E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFF4E4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CFF4E8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82CFF4EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CFF4F0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82CFF4F4: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 82CFF4F8: 387C0018  addi r3, r28, 0x18
	ctx.r[3].s64 = ctx.r[28].s64 + 24;
	// 82CFF4FC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82CFF500: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82CFF504: 48000165  bl 0x82cff668
	ctx.lr = 0x82CFF508;
	sub_82CFF668(ctx, base);
	// 82CFF508: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82CFF50C: 48000115  bl 0x82cff620
	ctx.lr = 0x82CFF510;
	sub_82CFF620(ctx, base);
	// 82CFF510: 576B0672  rlwinm r11, r27, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFF514: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFF518: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFF51C: 915E0024  stw r10, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82CFF520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF524: 419A0018  beq cr6, 0x82cff53c
	if ctx.cr[6].eq {
	pc = 0x82CFF53C; continue 'dispatch;
	}
	// 82CFF528: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82CFF52C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CFF530: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CFF534: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CFF538: 4BFFE171  bl 0x82cfd6a8
	ctx.lr = 0x82CFF53C;
	sub_82CFD6A8(ctx, base);
	pc = 0x82CFF53C; continue 'dispatch;
            }
            0x82CFF53C => {
    //   block [0x82CFF53C..0x82CFF590)
	// 82CFF53C: 576B06FE  clrlwi r11, r27, 0x1b
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x0000001Fu64;
	// 82CFF540: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFF544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF548: 419A0090  beq cr6, 0x82cff5d8
	if ctx.cr[6].eq {
	pc = 0x82CFF5D8; continue 'dispatch;
	}
	// 82CFF54C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82CFF550: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CFF554: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CFF558: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CFF55C: 4BFFE355  bl 0x82cfd8b0
	ctx.lr = 0x82CFF560;
	sub_82CFD8B0(ctx, base);
	// 82CFF560: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CFF564: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CFF568: 409A0028  bne cr6, 0x82cff590
	if !ctx.cr[6].eq {
	pc = 0x82CFF590; continue 'dispatch;
	}
	// 82CFF56C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFF570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF574: 419A001C  beq cr6, 0x82cff590
	if ctx.cr[6].eq {
	pc = 0x82CFF590; continue 'dispatch;
	}
	// 82CFF578: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82CFF57C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82CFF580: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CFF584: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CFF588: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CFF58C: 4BFFE7DD  bl 0x82cfdd68
	ctx.lr = 0x82CFF590;
	sub_82CFDD68(ctx, base);
	pc = 0x82CFF590; continue 'dispatch;
            }
            0x82CFF590 => {
    //   block [0x82CFF590..0x82CFF5B4)
	// 82CFF590: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CFF594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF598: 419A001C  beq cr6, 0x82cff5b4
	if ctx.cr[6].eq {
	pc = 0x82CFF5B4; continue 'dispatch;
	}
	// 82CFF59C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82CFF5A0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82CFF5A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CFF5A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CFF5AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CFF5B0: 4BFFEBB9  bl 0x82cfe168
	ctx.lr = 0x82CFF5B4;
	sub_82CFE168(ctx, base);
	pc = 0x82CFF5B4; continue 'dispatch;
            }
            0x82CFF5B4 => {
    //   block [0x82CFF5B4..0x82CFF5D8)
	// 82CFF5B4: 576B07FE  clrlwi r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 82CFF5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF5BC: 419A001C  beq cr6, 0x82cff5d8
	if ctx.cr[6].eq {
	pc = 0x82CFF5D8; continue 'dispatch;
	}
	// 82CFF5C0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82CFF5C4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82CFF5C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CFF5CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CFF5D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CFF5D4: 4BFFF875  bl 0x82cfee48
	ctx.lr = 0x82CFF5D8;
	sub_82CFEE48(ctx, base);
	pc = 0x82CFF5D8; continue 'dispatch;
            }
            0x82CFF5D8 => {
    //   block [0x82CFF5D8..0x82CFF5F8)
	// 82CFF5D8: 576B07BC  rlwinm r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFF5DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF5E0: 419A0018  beq cr6, 0x82cff5f8
	if ctx.cr[6].eq {
	pc = 0x82CFF5F8; continue 'dispatch;
	}
	// 82CFF5E4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82CFF5E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CFF5EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CFF5F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CFF5F4: 4BFFFD75  bl 0x82cff368
	ctx.lr = 0x82CFF5F8;
	sub_82CFF368(ctx, base);
	pc = 0x82CFF5F8; continue 'dispatch;
            }
            0x82CFF5F8 => {
    //   block [0x82CFF5F8..0x82CFF618)
	// 82CFF5F8: 576B06B4  rlwinm r11, r27, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFF5FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF600: 419A0018  beq cr6, 0x82cff618
	if ctx.cr[6].eq {
	pc = 0x82CFF618; continue 'dispatch;
	}
	// 82CFF604: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82CFF608: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CFF60C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CFF610: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CFF614: 4BFFF005  bl 0x82cfe618
	ctx.lr = 0x82CFF618;
	sub_82CFE618(ctx, base);
	pc = 0x82CFF618; continue 'dispatch;
            }
            0x82CFF618 => {
    //   block [0x82CFF618..0x82CFF620)
	// 82CFF618: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82CFF61C: 4BFA9E38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFF620 size=32
    let mut pc: u32 = 0x82CFF620;
    'dispatch: loop {
        match pc {
            0x82CFF620 => {
    //   block [0x82CFF620..0x82CFF640)
	// 82CFF620: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF624: FDA00032  fmul f13, f0, f0
	ctx.f[13].f64 = ctx.f[0].f64 * ctx.f[0].f64;
	// 82CFF628: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFF62C: C1630000  lfs f11, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFF630: FD4C6B3A  fmadd f10, f12, f12, f13
	ctx.f[10].f64 = ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64;
	// 82CFF634: FD2B52FA  fmadd f9, f11, f11, f10
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[10].f64;
	// 82CFF638: EC20482C  fsqrts f1, f9
	ctx.f[1].f64 = ((ctx.f[9].f64).sqrt() as f32) as f64;
	// 82CFF63C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFF640 size=40
    let mut pc: u32 = 0x82CFF640;
    'dispatch: loop {
        match pc {
            0x82CFF640 => {
    //   block [0x82CFF640..0x82CFF668)
	// 82CFF640: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF644: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFF648: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFF64C: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFF650: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFF654: C1230000  lfs f9, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFF658: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CFF65C: ECEB62BA  fmadds f7, f11, f10, f12
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82CFF660: EC293A3A  fmadds f1, f9, f8, f7
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[8].f64 + ctx.f[7].f64) as f32) as f64);
	// 82CFF664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFF668 size=52
    let mut pc: u32 = 0x82CFF668;
    'dispatch: loop {
        match pc {
            0x82CFF668 => {
    //   block [0x82CFF668..0x82CFF69C)
	// 82CFF668: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF66C: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFF670: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CFF674: D1850000  stfs f12, 0(r5)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFF678: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFF67C: C1440004  lfs f10, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFF680: ED2B5028  fsubs f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 82CFF684: D1250004  stfs f9, 4(r5)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFF688: C1030008  lfs f8, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CFF68C: C0E40008  lfs f7, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFF690: ECC83828  fsubs f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 82CFF694: D0C50008  stfs f6, 8(r5)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CFF698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFF6A0 size=88
    let mut pc: u32 = 0x82CFF6A0;
    'dispatch: loop {
        match pc {
            0x82CFF6A0 => {
    //   block [0x82CFF6A0..0x82CFF6F8)
	// 82CFF6A0: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF6A4: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFF6A8: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFF6AC: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFF6B0: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFF6B4: ED2B62B8  fmsubs f9, f11, f10, f12
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CFF6B8: D1250000  stfs f9, 0(r5)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFF6BC: C1030008  lfs f8, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CFF6C0: C0E40000  lfs f7, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFF6C4: C0C30000  lfs f6, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CFF6C8: C0A40008  lfs f5, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CFF6CC: EC860172  fmuls f4, f6, f5
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[5].f64) as f32) as f64);
	// 82CFF6D0: EC6821F8  fmsubs f3, f8, f7, f4
	ctx.f[3].f64 = (((ctx.f[8].f64 * ctx.f[7].f64 - ctx.f[4].f64) as f32) as f64);
	// 82CFF6D4: D0650004  stfs f3, 4(r5)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFF6D8: C0440004  lfs f2, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CFF6DC: C0230000  lfs f1, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CFF6E0: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFF6E4: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFF6E8: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFF6EC: ED626078  fmsubs f11, f2, f1, f12
	ctx.f[11].f64 = (((ctx.f[2].f64 * ctx.f[1].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CFF6F0: D1650008  stfs f11, 8(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CFF6F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFF708 size=136
    let mut pc: u32 = 0x82CFF708;
    'dispatch: loop {
        match pc {
            0x82CFF708 => {
    //   block [0x82CFF708..0x82CFF778)
	// 82CFF708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFF70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFF710: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CFF714: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFF718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CFF71C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CFF720: 419A0058  beq cr6, 0x82cff778
	if ctx.cr[6].eq {
	pc = 0x82CFF778; continue 'dispatch;
	}
	// 82CFF724: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFF728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF72C: 419A004C  beq cr6, 0x82cff778
	if ctx.cr[6].eq {
	pc = 0x82CFF778; continue 'dispatch;
	}
	// 82CFF730: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFF734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CFF738: 419A0040  beq cr6, 0x82cff778
	if ctx.cr[6].eq {
	pc = 0x82CFF778; continue 'dispatch;
	}
	// 82CFF73C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CFF740: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CFF744: 48000E65  bl 0x82d005a8
	ctx.lr = 0x82CFF748;
	sub_82D005A8(ctx, base);
	// 82CFF748: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFF74C: 40820030  bne 0x82cff77c
	if !ctx.cr[0].eq {
	pc = 0x82CFF77C; continue 'dispatch;
	}
	// 82CFF750: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CFF754: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFF758: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFF75C: 386B72F8  addi r3, r11, 0x72f8
	ctx.r[3].s64 = ctx.r[11].s64 + 29432;
	// 82CFF760: 48002631  bl 0x82d01d90
	ctx.lr = 0x82CFF764;
	sub_82D01D90(ctx, base);
	// 82CFF764: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFF768: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFF76C: 40800010  bge 0x82cff77c
	if !ctx.cr[0].lt {
	pc = 0x82CFF77C; continue 'dispatch;
	}
	// 82CFF770: 3860065B  li r3, 0x65b
	ctx.r[3].s64 = 1627;
	// 82CFF774: 48000008  b 0x82cff77c
	pc = 0x82CFF77C; continue 'dispatch;
            }
            0x82CFF778 => {
    //   block [0x82CFF778..0x82CFF77C)
	// 82CFF778: 38600057  li r3, 0x57
	ctx.r[3].s64 = 87;
	pc = 0x82CFF77C; continue 'dispatch;
            }
            0x82CFF77C => {
    //   block [0x82CFF77C..0x82CFF790)
	// 82CFF77C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82CFF780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFF784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFF788: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFF78C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CFF790 size=12
    let mut pc: u32 = 0x82CFF790;
    'dispatch: loop {
        match pc {
            0x82CFF790 => {
    //   block [0x82CFF790..0x82CFF79C)
	// 82CFF790: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82CFF794: 386B5F84  addi r3, r11, 0x5f84
	ctx.r[3].s64 = ctx.r[11].s64 + 24452;
	// 82CFF798: 4BFFFF70  b 0x82cff708
	sub_82CFF708(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFF7A0 size=132
    let mut pc: u32 = 0x82CFF7A0;
    'dispatch: loop {
        match pc {
            0x82CFF7A0 => {
    //   block [0x82CFF7A0..0x82CFF7D4)
	// 82CFF7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFF7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFF7A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CFF7AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFF7B0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CFF7B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CFF7B8: 396B72F8  addi r11, r11, 0x72f8
	ctx.r[11].s64 = ctx.r[11].s64 + 29432;
	// 82CFF7BC: 808B002C  lwz r4, 0x2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82CFF7C0: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82CFF7C4: 40820010  bne 0x82cff7d4
	if !ctx.cr[0].eq {
	pc = 0x82CFF7D4; continue 'dispatch;
	}
	// 82CFF7C8: 3C608015  lis r3, -0x7feb
	ctx.r[3].s64 = -2146107392;
	// 82CFF7CC: 60630005  ori r3, r3, 5
	ctx.r[3].u64 = ctx.r[3].u64 | 5;
	// 82CFF7D0: 48000040  b 0x82cff810
	pc = 0x82CFF810; continue 'dispatch;
            }
            0x82CFF7D4 => {
    //   block [0x82CFF7D4..0x82CFF804)
	// 82CFF7D4: B0610050  sth r3, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u16 ) };
	// 82CFF7D8: 3D2082D0  lis r9, -0x7d30
	ctx.r[9].s64 = -2100297728;
	// 82CFF7DC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CFF7E0: A0AB0028  lhz r5, 0x28(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CFF7E4: 38E9F6F8  addi r7, r9, -0x908
	ctx.r[7].s64 = ctx.r[9].s64 + -2312;
	// 82CFF7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CFF7EC: 48306E4D  bl 0x83006638
	ctx.lr = 0x82CFF7F0;
	sub_83006638(ctx, base);
	// 82CFF7F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82CFF7F4: 40820010  bne 0x82cff804
	if !ctx.cr[0].eq {
	pc = 0x82CFF804; continue 'dispatch;
	}
	// 82CFF7F8: 3C608015  lis r3, -0x7feb
	ctx.r[3].s64 = -2146107392;
	// 82CFF7FC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CFF800: 48000010  b 0x82cff810
	pc = 0x82CFF810; continue 'dispatch;
            }
            0x82CFF804 => {
    //   block [0x82CFF804..0x82CFF810)
	// 82CFF804: A1630002  lhz r11, 2(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CFF808: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFF80C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFF810; continue 'dispatch;
            }
            0x82CFF810 => {
    //   block [0x82CFF810..0x82CFF824)
	// 82CFF810: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CFF814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFF818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFF81C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFF820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFF828 size=156
    let mut pc: u32 = 0x82CFF828;
    'dispatch: loop {
        match pc {
            0x82CFF828 => {
    //   block [0x82CFF828..0x82CFF878)
	// 82CFF828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFF82C: 4BFA9BD5  bl 0x82ca9400
	ctx.lr = 0x82CFF830;
	sub_82CA93D0(ctx, base);
	// 82CFF830: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFF834: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CFF838: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82CFF83C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CFF840: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CFF844: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CFF848: 386A72F8  addi r3, r10, 0x72f8
	ctx.r[3].s64 = ctx.r[10].s64 + 29432;
	// 82CFF84C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82CFF850: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82CFF854: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82CFF858: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 82CFF85C: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 82CFF860: 480024A1  bl 0x82d01d00
	ctx.lr = 0x82CFF864;
	sub_82D01D00(ctx, base);
	// 82CFF864: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFF868: 41800054  blt 0x82cff8bc
	if ctx.cr[0].lt {
	pc = 0x82CFF8BC; continue 'dispatch;
	}
	// 82CFF86C: 57CB0739  rlwinm. r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFF870: 40820008  bne 0x82cff878
	if !ctx.cr[0].eq {
	pc = 0x82CFF878; continue 'dispatch;
	}
	// 82CFF874: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82CFF878; continue 'dispatch;
            }
            0x82CFF878 => {
    //   block [0x82CFF878..0x82CFF898)
	// 82CFF878: 1D7D0078  mulli r11, r29, 0x78
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 120 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CFF87C: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 82CFF880: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CFF884: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82CFF888: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 82CFF88C: 556B003A  rlwinm r11, r11, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CFF890: 419A0008  beq cr6, 0x82cff898
	if ctx.cr[6].eq {
	pc = 0x82CFF898; continue 'dispatch;
	}
	// 82CFF894: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFF898; continue 'dispatch;
            }
            0x82CFF898 => {
    //   block [0x82CFF898..0x82CFF8A8)
	// 82CFF898: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CFF89C: 419A000C  beq cr6, 0x82cff8a8
	if ctx.cr[6].eq {
	pc = 0x82CFF8A8; continue 'dispatch;
	}
	// 82CFF8A0: 39401000  li r10, 0x1000
	ctx.r[10].s64 = 4096;
	// 82CFF8A4: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82CFF8A8; continue 'dispatch;
            }
            0x82CFF8A8 => {
    //   block [0x82CFF8A8..0x82CFF8BC)
	// 82CFF8A8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82CFF8AC: 419A0010  beq cr6, 0x82cff8bc
	if ctx.cr[6].eq {
	pc = 0x82CFF8BC; continue 'dispatch;
	}
	// 82CFF8B0: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82CFF8B4: 396B2E6C  addi r11, r11, 0x2e6c
	ctx.r[11].s64 = ctx.r[11].s64 + 11884;
	// 82CFF8B8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFF8BC; continue 'dispatch;
            }
            0x82CFF8BC => {
    //   block [0x82CFF8BC..0x82CFF8C4)
	// 82CFF8BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82CFF8C0: 4BFA9B90  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFF8C8 size=224
    let mut pc: u32 = 0x82CFF8C8;
    'dispatch: loop {
        match pc {
            0x82CFF8C8 => {
    //   block [0x82CFF8C8..0x82CFF920)
	// 82CFF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFF8CC: 4BFA9B25  bl 0x82ca93f0
	ctx.lr = 0x82CFF8D0;
	sub_82CA93D0(ctx, base);
	// 82CFF8D0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFF8D4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82CFF8D8: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82CFF8DC: 3BA61E20  addi r29, r6, 0x1e20
	ctx.r[29].s64 = ctx.r[6].s64 + 7712;
	// 82CFF8E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82CFF8E4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82CFF8E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CFF8EC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82CFF8F0: 60848004  ori r4, r4, 0x8004
	ctx.r[4].u64 = ctx.r[4].u64 | 32772;
	// 82CFF8F4: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82CFF8F8: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CFF8FC: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82CFF900: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 82CFF904: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 82CFF908: 3ADD104C  addi r22, r29, 0x104c
	ctx.r[22].s64 = ctx.r[29].s64 + 4172;
	// 82CFF90C: 485BA349  bl 0x832b9c54
	ctx.lr = 0x82CFF910;
	// extern call 0x832B9C54 → crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82CFF910: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFF914: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFF918: 41800008  blt 0x82cff920
	if ctx.cr[0].lt {
	pc = 0x82CFF920; continue 'dispatch;
	}
	// 82CFF91C: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	pc = 0x82CFF920; continue 'dispatch;
            }
            0x82CFF920 => {
    //   block [0x82CFF920..0x82CFF9A0)
	// 82CFF920: 81210144  lwz r9, 0x144(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 82CFF924: 391F004C  addi r8, r31, 0x4c
	ctx.r[8].s64 = ctx.r[31].s64 + 76;
	// 82CFF928: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82CFF92C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CFF930: 7FF6F050  subf r31, r22, r30
	ctx.r[31].s64 = ctx.r[30].s64 - ctx.r[22].s64;
	// 82CFF934: 8141015C  lwz r10, 0x15c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82CFF938: 7FDD4214  add r30, r29, r8
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[8].u64;
	// 82CFF93C: 92E10084  stw r23, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[23].u32 ) };
	// 82CFF940: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CFF944: 9301007C  stw r24, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[24].u32 ) };
	// 82CFF948: 9121008C  stw r9, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 82CFF94C: 39201000  li r9, 0x1000
	ctx.r[9].s64 = 4096;
	// 82CFF950: 7CFFF214  add r7, r31, r30
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82CFF954: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82CFF958: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82CFF95C: 38AB72F8  addi r5, r11, 0x72f8
	ctx.r[5].s64 = ctx.r[11].s64 + 29432;
	// 82CFF960: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82CFF964: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82CFF968: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82CFF96C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82CFF970: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82CFF974: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82CFF978: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CFF97C: 48002555  bl 0x82d01ed0
	ctx.lr = 0x82CFF980;
	sub_82D01ED0(ctx, base);
	// 82CFF980: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFF984: 4180001C  blt 0x82cff9a0
	if ctx.cr[0].lt {
	pc = 0x82CFF9A0; continue 'dispatch;
	}
	// 82CFF988: 8161014C  lwz r11, 0x14c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82CFF98C: 81410154  lwz r10, 0x154(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82CFF990: 81210164  lwz r9, 0x164(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 82CFF994: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82CFF998: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82CFF99C: 93890000  stw r28, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82CFF9A0; continue 'dispatch;
            }
            0x82CFF9A0 => {
    //   block [0x82CFF9A0..0x82CFF9A8)
	// 82CFF9A0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82CFF9A4: 4BFA9A9C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFF9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFF9A8 size=212
    let mut pc: u32 = 0x82CFF9A8;
    'dispatch: loop {
        match pc {
            0x82CFF9A8 => {
    //   block [0x82CFF9A8..0x82CFF9F4)
	// 82CFF9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFF9AC: 4BFA9A4D  bl 0x82ca93f8
	ctx.lr = 0x82CFF9B0;
	sub_82CA93D0(ctx, base);
	// 82CFF9B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFF9B4: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 82CFF9B8: 7CCB30F8  nor r11, r6, r6
	ctx.r[11].u64 = !(ctx.r[6].u64 | ctx.r[6].u64);
	// 82CFF9BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFF9C0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CFF9C4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82CFF9C8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CFF9CC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82CFF9D0: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 82CFF9D4: 5578F7FE  rlwinm r24, r11, 0x1e, 0x1f, 0x1f
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82CFF9D8: 2B040440  cmplwi cr6, r4, 0x440
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1088 as u32, &mut ctx.xer);
	// 82CFF9DC: 40980038  bge cr6, 0x82cffa14
	if !ctx.cr[6].lt {
	pc = 0x82CFFA14; continue 'dispatch;
	}
	// 82CFF9E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFF9E4: 419A0010  beq cr6, 0x82cff9f4
	if ctx.cr[6].eq {
	pc = 0x82CFF9F4; continue 'dispatch;
	}
	// 82CFF9E8: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 82CFF9EC: 63FF007A  ori r31, r31, 0x7a
	ctx.r[31].u64 = ctx.r[31].u64 | 122;
	// 82CFF9F0: 48000080  b 0x82cffa70
	pc = 0x82CFFA70; continue 'dispatch;
            }
            0x82CFF9F4 => {
    //   block [0x82CFF9F4..0x82CFFA14)
	// 82CFF9F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CFF9F8: 38800440  li r4, 0x440
	ctx.r[4].s64 = 1088;
	// 82CFF9FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFFA00: 485BA215  bl 0x832b9c14
	ctx.lr = 0x82CFFA04;
	// extern call 0x832B9C14 → crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82CFFA04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFA08: 41800058  blt 0x82cffa60
	if ctx.cr[0].lt {
	pc = 0x82CFFA60; continue 'dispatch;
	}
	// 82CFFA0C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFFA10: 48000008  b 0x82cffa18
	pc = 0x82CFFA18; continue 'dispatch;
            }
            0x82CFFA14 => {
    //   block [0x82CFFA14..0x82CFFA18)
	// 82CFFA14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x82CFFA18; continue 'dispatch;
            }
            0x82CFFA18 => {
    //   block [0x82CFFA18..0x82CFFA60)
	// 82CFFA18: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CFFA1C: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFFA20: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82CFFA24: 388B72F8  addi r4, r11, 0x72f8
	ctx.r[4].s64 = ctx.r[11].s64 + 29432;
	// 82CFFA28: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82CFFA2C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82CFFA30: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82CFFA34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82CFFA38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CFFA3C: 48002575  bl 0x82d01fb0
	ctx.lr = 0x82CFFA40;
	sub_82D01FB0(ctx, base);
	// 82CFFA40: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFA44: 4180001C  blt 0x82cffa60
	if ctx.cr[0].lt {
	pc = 0x82CFFA60; continue 'dispatch;
	}
	// 82CFFA48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CFFA4C: 48002E7D  bl 0x82d028c8
	ctx.lr = 0x82CFFA50;
	sub_82D028C8(ctx, base);
	// 82CFFA50: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFA54: 4180000C  blt 0x82cffa60
	if ctx.cr[0].lt {
	pc = 0x82CFFA60; continue 'dispatch;
	}
	// 82CFFA58: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFFA5C: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82CFFA60; continue 'dispatch;
            }
            0x82CFFA60 => {
    //   block [0x82CFFA60..0x82CFFA70)
	// 82CFFA60: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CFFA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFFA68: 419A0008  beq cr6, 0x82cffa70
	if ctx.cr[6].eq {
	pc = 0x82CFFA70; continue 'dispatch;
	}
	// 82CFFA6C: 485BA1B9  bl 0x832b9c24
	ctx.lr = 0x82CFFA70;
	// extern call 0x832B9C24 → crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82CFFA70; continue 'dispatch;
            }
            0x82CFFA70 => {
    //   block [0x82CFFA70..0x82CFFA7C)
	// 82CFFA70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CFFA74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82CFFA78: 4BFA99D0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFFA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CFFA80 size=48
    let mut pc: u32 = 0x82CFFA80;
    'dispatch: loop {
        match pc {
            0x82CFFA80 => {
    //   block [0x82CFFA80..0x82CFFAB0)
	// 82CFFA80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CFFA84: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82CFFA88: 7C8807B4  extsw r8, r4
	ctx.r[8].s64 = ctx.r[4].s32 as i64;
	// 82CFFA8C: 814B0200  lwz r10, 0x200(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82CFFA90: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFFA94: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFFA98: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CFFA9C: F90A0008  std r8, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 82CFFAA0: 806B0200  lwz r3, 0x200(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82CFFAA4: 39430001  addi r10, r3, 1
	ctx.r[10].s64 = ctx.r[3].s64 + 1;
	// 82CFFAA8: 914B0200  stw r10, 0x200(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(512 as u32), ctx.r[10].u32 ) };
	// 82CFFAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFFAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFFAB0 size=352
    let mut pc: u32 = 0x82CFFAB0;
    'dispatch: loop {
        match pc {
            0x82CFFAB0 => {
    //   block [0x82CFFAB0..0x82CFFBDC)
	// 82CFFAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFFAB4: 4BFA9955  bl 0x82ca9408
	ctx.lr = 0x82CFFAB8;
	sub_82CA93D0(ctx, base);
	// 82CFFAB8: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFFABC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CFFAC0: 906102E4  stw r3, 0x2e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), ctx.r[3].u32 ) };
	// 82CFFAC4: 908102EC  stw r4, 0x2ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(748 as u32), ctx.r[4].u32 ) };
	// 82CFFAC8: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82CFFACC: 90A102F4  stw r5, 0x2f4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(756 as u32), ctx.r[5].u32 ) };
	// 82CFFAD0: 38600206  li r3, 0x206
	ctx.r[3].s64 = 518;
	// 82CFFAD4: 93C102A0  stw r30, 0x2a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[30].u32 ) };
	// 82CFFAD8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82CFFADC: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82CFFAE0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82CFFAE4: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82CFFAE8: 4BFFFCB9  bl 0x82cff7a0
	ctx.lr = 0x82CFFAEC;
	sub_82CFF7A0(ctx, base);
	// 82CFFAEC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFAF0: 418000EC  blt 0x82cffbdc
	if ctx.cr[0].lt {
	pc = 0x82CFFBDC; continue 'dispatch;
	}
	// 82CFFAF4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFAF8: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82CFFAFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFFB00: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82CFFB04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CFFB08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CFFB0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CFFB10: 4BFFFD19  bl 0x82cff828
	ctx.lr = 0x82CFFB14;
	sub_82CFF828(ctx, base);
	// 82CFFB14: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFB18: 418000C4  blt 0x82cffbdc
	if ctx.cr[0].lt {
	pc = 0x82CFFBDC; continue 'dispatch;
	}
	// 82CFFB1C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82CFFB20: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82CFFB24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFFB28: 485BA0ED  bl 0x832b9c14
	ctx.lr = 0x82CFFB2C;
	// extern call 0x832B9C14 → crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82CFFB2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFB30: 418000AC  blt 0x82cffbdc
	if ctx.cr[0].lt {
	pc = 0x82CFFBDC; continue 'dispatch;
	}
	// 82CFFB34: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 82CFFB38: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82CFFB3C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82CFFB40: 80E10080  lwz r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFB44: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 82CFFB48: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 82CFFB4C: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82CFFB50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFFB54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFB58: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82CFFB5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CFFB60: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82CFFB64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CFFB68: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82CFFB6C: 38600206  li r3, 0x206
	ctx.r[3].s64 = 518;
	// 82CFFB70: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82CFFB74: 4BFFFD55  bl 0x82cff8c8
	ctx.lr = 0x82CFFB78;
	sub_82CFF8C8(ctx, base);
	// 82CFFB78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFB7C: 41800060  blt 0x82cffbdc
	if ctx.cr[0].lt {
	pc = 0x82CFFBDC; continue 'dispatch;
	}
	// 82CFFB80: 388102E4  addi r4, r1, 0x2e4
	ctx.r[4].s64 = ctx.r[1].s64 + 740;
	// 82CFFB84: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFFB88: 4BFFFEF9  bl 0x82cffa80
	ctx.lr = 0x82CFFB8C;
	sub_82CFFA80(ctx, base);
	// 82CFFB8C: 388102EC  addi r4, r1, 0x2ec
	ctx.r[4].s64 = ctx.r[1].s64 + 748;
	// 82CFFB90: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFFB94: 4BFFFEED  bl 0x82cffa80
	ctx.lr = 0x82CFFB98;
	sub_82CFFA80(ctx, base);
	// 82CFFB98: 388102F4  addi r4, r1, 0x2f4
	ctx.r[4].s64 = ctx.r[1].s64 + 756;
	// 82CFFB9C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFFBA0: 4BFFFEE1  bl 0x82cffa80
	ctx.lr = 0x82CFFBA4;
	sub_82CFFA80(ctx, base);
	// 82CFFBA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82CFFBA8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFFBAC: 4BFFFED5  bl 0x82cffa80
	ctx.lr = 0x82CFFBB0;
	sub_82CFFA80(ctx, base);
	// 82CFFBB0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CFFBB4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFFBB8: 4BFFFEC9  bl 0x82cffa80
	ctx.lr = 0x82CFFBBC;
	sub_82CFFA80(ctx, base);
	// 82CFFBBC: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82CFFBC0: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82CFFBC4: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82CFFBC8: 60848020  ori r4, r4, 0x8020
	ctx.r[4].u64 = ctx.r[4].u64 | 32800;
	// 82CFFBCC: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82CFFBD0: 485BA085  bl 0x832b9c54
	ctx.lr = 0x82CFFBD4;
	// extern call 0x832B9C54 → crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82CFFBD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFBD8: 40800024  bge 0x82cffbfc
	if !ctx.cr[0].lt {
	pc = 0x82CFFBFC; continue 'dispatch;
	}
	pc = 0x82CFFBDC; continue 'dispatch;
            }
            0x82CFFBDC => {
    //   block [0x82CFFBDC..0x82CFFBEC)
	// 82CFFBDC: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFBE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFFBE4: 419A0008  beq cr6, 0x82cffbec
	if ctx.cr[6].eq {
	pc = 0x82CFFBEC; continue 'dispatch;
	}
	// 82CFFBE8: 485BA03D  bl 0x832b9c24
	ctx.lr = 0x82CFFBEC;
	// extern call 0x832B9C24 → crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82CFFBEC; continue 'dispatch;
            }
            0x82CFFBEC => {
    //   block [0x82CFFBEC..0x82CFFBFC)
	// 82CFFBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CFFBF0: 4BFC73B9  bl 0x82cc6fa8
	ctx.lr = 0x82CFFBF4;
	sub_82CC6FA8(ctx, base);
	// 82CFFBF4: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82CFFBF8: 4800000C  b 0x82cffc04
	pc = 0x82CFFC04; continue 'dispatch;
            }
            0x82CFFBFC => {
    //   block [0x82CFFBFC..0x82CFFC04)
	// 82CFFBFC: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFC00: 485BA025  bl 0x832b9c24
	ctx.lr = 0x82CFFC04;
	// extern call 0x832B9C24 → crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82CFFC04; continue 'dispatch;
            }
            0x82CFFC04 => {
    //   block [0x82CFFC04..0x82CFFC10)
	// 82CFFC04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CFFC08: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82CFFC0C: 4BFA984C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFFC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CFFC10 size=304
    let mut pc: u32 = 0x82CFFC10;
    'dispatch: loop {
        match pc {
            0x82CFFC10 => {
    //   block [0x82CFFC10..0x82CFFD0C)
	// 82CFFC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFFC14: 4BFA97F9  bl 0x82ca940c
	ctx.lr = 0x82CFFC18;
	sub_82CA93D0(ctx, base);
	// 82CFFC18: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFFC1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CFFC20: 906102E4  stw r3, 0x2e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), ctx.r[3].u32 ) };
	// 82CFFC24: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82CFFC28: 93C102A0  stw r30, 0x2a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[30].u32 ) };
	// 82CFFC2C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82CFFC30: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82CFFC34: 38600586  li r3, 0x586
	ctx.r[3].s64 = 1414;
	// 82CFFC38: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82CFFC3C: 4BFFFB65  bl 0x82cff7a0
	ctx.lr = 0x82CFFC40;
	sub_82CFF7A0(ctx, base);
	// 82CFFC40: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFC44: 418000C8  blt 0x82cffd0c
	if ctx.cr[0].lt {
	pc = 0x82CFFD0C; continue 'dispatch;
	}
	// 82CFFC48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFC4C: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82CFFC50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFFC54: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82CFFC58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CFFC5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CFFC60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CFFC64: 4BFFFBC5  bl 0x82cff828
	ctx.lr = 0x82CFFC68;
	sub_82CFF828(ctx, base);
	// 82CFFC68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFC6C: 418000A0  blt 0x82cffd0c
	if ctx.cr[0].lt {
	pc = 0x82CFFD0C; continue 'dispatch;
	}
	// 82CFFC70: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82CFFC74: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82CFFC78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFFC7C: 485B9F99  bl 0x832b9c14
	ctx.lr = 0x82CFFC80;
	// extern call 0x832B9C14 → crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82CFFC80: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFC84: 41800088  blt 0x82cffd0c
	if ctx.cr[0].lt {
	pc = 0x82CFFD0C; continue 'dispatch;
	}
	// 82CFFC88: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 82CFFC8C: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82CFFC90: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82CFFC94: 80E10080  lwz r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFC98: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 82CFFC9C: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 82CFFCA0: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82CFFCA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFFCA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFCAC: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82CFFCB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CFFCB4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82CFFCB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CFFCBC: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82CFFCC0: 38600586  li r3, 0x586
	ctx.r[3].s64 = 1414;
	// 82CFFCC4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82CFFCC8: 4BFFFC01  bl 0x82cff8c8
	ctx.lr = 0x82CFFCCC;
	sub_82CFF8C8(ctx, base);
	// 82CFFCCC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFCD0: 4180003C  blt 0x82cffd0c
	if ctx.cr[0].lt {
	pc = 0x82CFFD0C; continue 'dispatch;
	}
	// 82CFFCD4: 388102E4  addi r4, r1, 0x2e4
	ctx.r[4].s64 = ctx.r[1].s64 + 740;
	// 82CFFCD8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFFCDC: 4BFFFDA5  bl 0x82cffa80
	ctx.lr = 0x82CFFCE0;
	sub_82CFFA80(ctx, base);
	// 82CFFCE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82CFFCE4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82CFFCE8: 4BFFFD99  bl 0x82cffa80
	ctx.lr = 0x82CFFCEC;
	sub_82CFFA80(ctx, base);
	// 82CFFCEC: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82CFFCF0: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82CFFCF4: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82CFFCF8: 60848023  ori r4, r4, 0x8023
	ctx.r[4].u64 = ctx.r[4].u64 | 32803;
	// 82CFFCFC: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82CFFD00: 485B9F55  bl 0x832b9c54
	ctx.lr = 0x82CFFD04;
	// extern call 0x832B9C54 → crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82CFFD04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CFFD08: 40800024  bge 0x82cffd2c
	if !ctx.cr[0].lt {
	pc = 0x82CFFD2C; continue 'dispatch;
	}
	pc = 0x82CFFD0C; continue 'dispatch;
            }
            0x82CFFD0C => {
    //   block [0x82CFFD0C..0x82CFFD1C)
	// 82CFFD0C: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFD10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFFD14: 419A0008  beq cr6, 0x82cffd1c
	if ctx.cr[6].eq {
	pc = 0x82CFFD1C; continue 'dispatch;
	}
	// 82CFFD18: 485B9F0D  bl 0x832b9c24
	ctx.lr = 0x82CFFD1C;
	// extern call 0x832B9C24 → crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82CFFD1C; continue 'dispatch;
            }
            0x82CFFD1C => {
    //   block [0x82CFFD1C..0x82CFFD2C)
	// 82CFFD1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CFFD20: 4BFC7289  bl 0x82cc6fa8
	ctx.lr = 0x82CFFD24;
	sub_82CC6FA8(ctx, base);
	// 82CFFD24: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82CFFD28: 4800000C  b 0x82cffd34
	pc = 0x82CFFD34; continue 'dispatch;
            }
            0x82CFFD2C => {
    //   block [0x82CFFD2C..0x82CFFD34)
	// 82CFFD2C: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFD30: 485B9EF5  bl 0x832b9c24
	ctx.lr = 0x82CFFD34;
	// extern call 0x832B9C24 → crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82CFFD34; continue 'dispatch;
            }
            0x82CFFD34 => {
    //   block [0x82CFFD34..0x82CFFD40)
	// 82CFFD34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CFFD38: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82CFFD3C: 4BFA9720  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFFD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFFD40 size=604
    let mut pc: u32 = 0x82CFFD40;
    'dispatch: loop {
        match pc {
            0x82CFFD40 => {
    //   block [0x82CFFD40..0x82CFFF44)
	// 82CFFD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFFD44: 4BFA96BD  bl 0x82ca9400
	ctx.lr = 0x82CFFD48;
	sub_82CA93D0(ctx, base);
	// 82CFFD48: 9421FCF0  stwu r1, -0x310(r1)
	ea = ctx.r[1].u32.wrapping_add(-784 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFFD4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CFFD50: 90610324  stw r3, 0x324(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(804 as u32), ctx.r[3].u32 ) };
	// 82CFFD54: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CFFD58: 93E102D0  stw r31, 0x2d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(720 as u32), ctx.r[31].u32 ) };
	// 82CFFD5C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82CFFD60: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82CFFD64: 38600D01  li r3, 0xd01
	ctx.r[3].s64 = 3329;
	// 82CFFD68: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82CFFD6C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CFFD70: 4BFFFA31  bl 0x82cff7a0
	ctx.lr = 0x82CFFD74;
	sub_82CFF7A0(ctx, base);
	// 82CFFD74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFD78: 418001CC  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFD7C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFD80: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFD84: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFFD88: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82CFFD8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CFFD90: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82CFFD94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CFFD98: 4BFFFA91  bl 0x82cff828
	ctx.lr = 0x82CFFD9C;
	sub_82CFF828(ctx, base);
	// 82CFFD9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFDA0: 418001A4  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFDA4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82CFFDA8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82CFFDAC: 38600E04  li r3, 0xe04
	ctx.r[3].s64 = 3588;
	// 82CFFDB0: 3BCB0030  addi r30, r11, 0x30
	ctx.r[30].s64 = ctx.r[11].s64 + 48;
	// 82CFFDB4: 4BFFF9ED  bl 0x82cff7a0
	ctx.lr = 0x82CFFDB8;
	sub_82CFF7A0(ctx, base);
	// 82CFFDB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFDBC: 41800188  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFDC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFDC4: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFDC8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFFDCC: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82CFFDD0: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 82CFFDD4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82CFFDD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CFFDDC: 4BFFFA4D  bl 0x82cff828
	ctx.lr = 0x82CFFDE0;
	sub_82CFF828(ctx, base);
	// 82CFFDE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFDE4: 41800160  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFDE8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82CFFDEC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82CFFDF0: 38600E15  li r3, 0xe15
	ctx.r[3].s64 = 3605;
	// 82CFFDF4: 7FDE5A14  add r30, r30, r11
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82CFFDF8: 4BFFF9A9  bl 0x82cff7a0
	ctx.lr = 0x82CFFDFC;
	sub_82CFF7A0(ctx, base);
	// 82CFFDFC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFE00: 41800144  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFE04: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFE08: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFE0C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFFE10: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82CFFE14: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82CFFE18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CFFE1C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82CFFE20: 4BFFFA09  bl 0x82cff828
	ctx.lr = 0x82CFFE24;
	sub_82CFF828(ctx, base);
	// 82CFFE24: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFE28: 4180011C  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFE2C: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82CFFE30: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82CFFE34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFFE38: 485B9DDD  bl 0x832b9c14
	ctx.lr = 0x82CFFE3C;
	// extern call 0x832B9C14 → crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82CFFE3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFE40: 41800104  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFE44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CFFE48: 4B47B239  bl 0x8217b080
	ctx.lr = 0x82CFFE4C;
	sub_8217B080(ctx, base);
	// 82CFFE4C: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 82CFFE50: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 82CFFE54: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82CFFE58: 90A10074  stw r5, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[5].u32 ) };
	// 82CFFE5C: 3B610090  addi r27, r1, 0x90
	ctx.r[27].s64 = ctx.r[1].s64 + 144;
	// 82CFFE60: 3B410094  addi r26, r1, 0x94
	ctx.r[26].s64 = ctx.r[1].s64 + 148;
	// 82CFFE64: 80E10088  lwz r7, 0x88(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82CFFE68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFFE6C: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFE70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFE74: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82CFFE78: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82CFFE7C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82CFFE80: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82CFFE84: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82CFFE88: 38600E15  li r3, 0xe15
	ctx.r[3].s64 = 3605;
	// 82CFFE8C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82CFFE90: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82CFFE94: 4BFFFA35  bl 0x82cff8c8
	ctx.lr = 0x82CFFE98;
	sub_82CFF8C8(ctx, base);
	// 82CFFE98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFE9C: 418000A8  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFEA0: 38810324  addi r4, r1, 0x324
	ctx.r[4].s64 = ctx.r[1].s64 + 804;
	// 82CFFEA4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82CFFEA8: 4BFFFBD9  bl 0x82cffa80
	ctx.lr = 0x82CFFEAC;
	sub_82CFFA80(ctx, base);
	// 82CFFEAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CFFEB0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82CFFEB4: 4BFFFBCD  bl 0x82cffa80
	ctx.lr = 0x82CFFEB8;
	sub_82CFFA80(ctx, base);
	// 82CFFEB8: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82CFFEBC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82CFFEC0: 4BFFFBC1  bl 0x82cffa80
	ctx.lr = 0x82CFFEC4;
	sub_82CFFA80(ctx, base);
	// 82CFFEC4: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82CFFEC8: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82CFFECC: 81210094  lwz r9, 0x94(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82CFFED0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CFFED4: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFED8: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 82CFFEDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CFFEE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CFFEE4: 4BFFFAC5  bl 0x82cff9a8
	ctx.lr = 0x82CFFEE8;
	sub_82CFF9A8(ctx, base);
	// 82CFFEE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFEEC: 41800058  blt 0x82cfff44
	if ctx.cr[0].lt {
	pc = 0x82CFFF44; continue 'dispatch;
	}
	// 82CFFEF0: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82CFFEF4: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82CFFEF8: 81210090  lwz r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82CFFEFC: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82CFFF00: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82CFFF04: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82CFFF08: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82CFFF0C: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82CFFF10: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82CFFF14: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFF18: FBEA0000  std r31, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82CFFF1C: FBEA0008  std r31, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82CFFF20: FBEA0010  std r31, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 82CFFF24: FBEA0018  std r31, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 82CFFF28: FBEA0020  std r31, 0x20(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 82CFFF2C: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82CFFF30: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82CFFF34: 5104801E  rlwimi r4, r8, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82CFFF38: 485B9ACD  bl 0x832b9a04
	ctx.lr = 0x82CFFF3C;
	// extern call 0x832B9A04 → crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82CFFF3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFF40: 40800030  bge 0x82cfff70
	if !ctx.cr[0].lt {
	pc = 0x82CFFF70; continue 'dispatch;
	}
	pc = 0x82CFFF44; continue 'dispatch;
            }
            0x82CFFF44 => {
    //   block [0x82CFFF44..0x82CFFF58)
	// 82CFFF44: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82CFFF48: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82CFFF4C: 419A000C  beq cr6, 0x82cfff58
	if ctx.cr[6].eq {
	pc = 0x82CFFF58; continue 'dispatch;
	}
	// 82CFFF50: 907D0018  stw r3, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82CFFF54: 48000008  b 0x82cfff5c
	pc = 0x82CFFF5C; continue 'dispatch;
            }
            0x82CFFF58 => {
    //   block [0x82CFFF58..0x82CFFF5C)
	// 82CFFF58: 4BFC8521  bl 0x82cc8478
	ctx.lr = 0x82CFFF5C;
	sub_82CC8478(ctx, base);
	pc = 0x82CFFF5C; continue 'dispatch;
            }
            0x82CFFF5C => {
    //   block [0x82CFFF5C..0x82CFFF70)
	// 82CFFF5C: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82CFFF60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CFFF64: 419A002C  beq cr6, 0x82cfff90
	if ctx.cr[6].eq {
	pc = 0x82CFFF90; continue 'dispatch;
	}
	// 82CFFF68: 485B9CBD  bl 0x832b9c24
	ctx.lr = 0x82CFFF6C;
	// extern call 0x832B9C24 → crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82CFFF6C: 48000024  b 0x82cfff90
	pc = 0x82CFFF90; continue 'dispatch;
            }
            0x82CFFF70 => {
    //   block [0x82CFFF70..0x82CFFF80)
	// 82CFFF70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82CFFF74: 419A000C  beq cr6, 0x82cfff80
	if ctx.cr[6].eq {
	pc = 0x82CFFF80; continue 'dispatch;
	}
	// 82CFFF78: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 82CFFF7C: 48000014  b 0x82cfff90
	pc = 0x82CFFF90; continue 'dispatch;
            }
            0x82CFFF80 => {
    //   block [0x82CFFF80..0x82CFFF90)
	// 82CFFF80: 4BFC8549  bl 0x82cc84c8
	ctx.lr = 0x82CFFF84;
	sub_82CC84C8(ctx, base);
	// 82CFFF84: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82CFFF88: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82CFFF8C: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	pc = 0x82CFFF90; continue 'dispatch;
            }
            0x82CFFF90 => {
    //   block [0x82CFFF90..0x82CFFF9C)
	// 82CFFF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CFFF94: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 82CFFF98: 4BFA94B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFFFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFFFA0 size=728
    let mut pc: u32 = 0x82CFFFA0;
    'dispatch: loop {
        match pc {
            0x82CFFFA0 => {
    //   block [0x82CFFFA0..0x82D00220)
	// 82CFFFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFFFA4: 4BFA9451  bl 0x82ca93f4
	ctx.lr = 0x82CFFFA8;
	sub_82CA93D0(ctx, base);
	// 82CFFFA8: 9421FCD0  stwu r1, -0x330(r1)
	ea = ctx.r[1].u32.wrapping_add(-816 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFFFAC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CFFFB0: 90610344  stw r3, 0x344(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(836 as u32), ctx.r[3].u32 ) };
	// 82CFFFB4: 90A10354  stw r5, 0x354(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(852 as u32), ctx.r[5].u32 ) };
	// 82CFFFB8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CFFFBC: 93E102D0  stw r31, 0x2d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(720 as u32), ctx.r[31].u32 ) };
	// 82CFFFC0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82CFFFC4: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82CFFFC8: 38600D01  li r3, 0xd01
	ctx.r[3].s64 = 3329;
	// 82CFFFCC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82CFFFD0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82CFFFD4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82CFFFD8: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82CFFFDC: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82CFFFE0: 4BFFF7C1  bl 0x82cff7a0
	ctx.lr = 0x82CFFFE4;
	sub_82CFF7A0(ctx, base);
	// 82CFFFE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82CFFFE8: 41800238  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82CFFFEC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFFFF0: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82CFFFF4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFFFF8: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82CFFFFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82D00000: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82D00004: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82D00008: 4BFFF821  bl 0x82cff828
	ctx.lr = 0x82D0000C;
	sub_82CFF828(ctx, base);
	// 82D0000C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00010: 41800210  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D00014: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D00018: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82D0001C: 38600C01  li r3, 0xc01
	ctx.r[3].s64 = 3073;
	// 82D00020: 3BCB01C0  addi r30, r11, 0x1c0
	ctx.r[30].s64 = ctx.r[11].s64 + 448;
	// 82D00024: 4BFFF77D  bl 0x82cff7a0
	ctx.lr = 0x82D00028;
	sub_82CFF7A0(ctx, base);
	// 82D00028: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D0002C: 418001F4  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D00030: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82D00034: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D00038: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82D0003C: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82D00040: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82D00044: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82D00048: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82D0004C: 4BFFF7DD  bl 0x82cff828
	ctx.lr = 0x82D00050;
	sub_82CFF828(ctx, base);
	// 82D00050: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00054: 418001CC  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D00058: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D0005C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82D00060: 38600E01  li r3, 0xe01
	ctx.r[3].s64 = 3585;
	// 82D00064: 7FDE5A14  add r30, r30, r11
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82D00068: 4BFFF739  bl 0x82cff7a0
	ctx.lr = 0x82D0006C;
	sub_82CFF7A0(ctx, base);
	// 82D0006C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00070: 418001B0  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D00074: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82D00078: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D0007C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82D00080: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82D00084: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 82D00088: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82D0008C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82D00090: 4BFFF799  bl 0x82cff828
	ctx.lr = 0x82D00094;
	sub_82CFF828(ctx, base);
	// 82D00094: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00098: 41800188  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D0009C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D000A0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82D000A4: 38600E11  li r3, 0xe11
	ctx.r[3].s64 = 3601;
	// 82D000A8: 7FDE5A14  add r30, r30, r11
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82D000AC: 4BFFF6F5  bl 0x82cff7a0
	ctx.lr = 0x82D000B0;
	sub_82CFF7A0(ctx, base);
	// 82D000B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D000B4: 4180016C  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D000B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82D000BC: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D000C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82D000C4: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82D000C8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82D000CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82D000D0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82D000D4: 4BFFF755  bl 0x82cff828
	ctx.lr = 0x82D000D8;
	sub_82CFF828(ctx, base);
	// 82D000D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D000DC: 41800144  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D000E0: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82D000E4: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D000E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82D000EC: 485B9B29  bl 0x832b9c14
	ctx.lr = 0x82D000F0;
	// extern call 0x832B9C14 → crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82D000F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D000F4: 4180012C  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D000F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82D000FC: 4B47AF85  bl 0x8217b080
	ctx.lr = 0x82D00100;
	sub_8217B080(ctx, base);
	// 82D00100: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 82D00104: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82D00108: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D0010C: 3B010090  addi r24, r1, 0x90
	ctx.r[24].s64 = ctx.r[1].s64 + 144;
	// 82D00110: 80E10088  lwz r7, 0x88(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82D00114: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82D00118: 3AE10098  addi r23, r1, 0x98
	ctx.r[23].s64 = ctx.r[1].s64 + 152;
	// 82D0011C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82D00120: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D00124: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82D00128: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82D0012C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82D00130: 93610094  stw r27, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[27].u32 ) };
	// 82D00134: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82D00138: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82D0013C: 38600E11  li r3, 0xe11
	ctx.r[3].s64 = 3601;
	// 82D00140: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82D00144: 93010064  stw r24, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[24].u32 ) };
	// 82D00148: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 82D0014C: 4BFFF77D  bl 0x82cff8c8
	ctx.lr = 0x82D00150;
	sub_82CFF8C8(ctx, base);
	// 82D00150: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00154: 418000CC  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D00158: 38810344  addi r4, r1, 0x344
	ctx.r[4].s64 = ctx.r[1].s64 + 836;
	// 82D0015C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D00160: 4BFFF921  bl 0x82cffa80
	ctx.lr = 0x82D00164;
	sub_82CFFA80(ctx, base);
	// 82D00164: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82D00168: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D0016C: 4BFFF915  bl 0x82cffa80
	ctx.lr = 0x82D00170;
	sub_82CFFA80(ctx, base);
	// 82D00170: 38810354  addi r4, r1, 0x354
	ctx.r[4].s64 = ctx.r[1].s64 + 852;
	// 82D00174: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D00178: 4BFFF909  bl 0x82cffa80
	ctx.lr = 0x82D0017C;
	sub_82CFFA80(ctx, base);
	// 82D0017C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82D00180: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D00184: 4BFFF8FD  bl 0x82cffa80
	ctx.lr = 0x82D00188;
	sub_82CFFA80(ctx, base);
	// 82D00188: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 82D0018C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D00190: 4BFFF8F1  bl 0x82cffa80
	ctx.lr = 0x82D00194;
	sub_82CFFA80(ctx, base);
	// 82D00194: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82D00198: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D0019C: 4BFFF8E5  bl 0x82cffa80
	ctx.lr = 0x82D001A0;
	sub_82CFFA80(ctx, base);
	// 82D001A0: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82D001A4: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82D001A8: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82D001AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82D001B0: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D001B4: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 82D001B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82D001BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82D001C0: 4BFFF7E9  bl 0x82cff9a8
	ctx.lr = 0x82D001C4;
	sub_82CFF9A8(ctx, base);
	// 82D001C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D001C8: 41800058  blt 0x82d00220
	if ctx.cr[0].lt {
	pc = 0x82D00220; continue 'dispatch;
	}
	// 82D001CC: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82D001D0: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82D001D4: 81210090  lwz r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82D001D8: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82D001DC: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82D001E0: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82D001E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82D001E8: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82D001EC: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82D001F0: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D001F4: FBEA0000  std r31, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82D001F8: FBEA0008  std r31, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82D001FC: FBEA0010  std r31, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 82D00200: FBEA0018  std r31, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 82D00204: FBEA0020  std r31, 0x20(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 82D00208: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82D0020C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82D00210: 5104801E  rlwimi r4, r8, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82D00214: 485B97F1  bl 0x832b9a04
	ctx.lr = 0x82D00218;
	// extern call 0x832B9A04 → crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82D00218: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D0021C: 40800030  bge 0x82d0024c
	if !ctx.cr[0].lt {
	pc = 0x82D0024C; continue 'dispatch;
	}
	pc = 0x82D00220; continue 'dispatch;
            }
            0x82D00220 => {
    //   block [0x82D00220..0x82D00234)
	// 82D00220: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82D00224: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82D00228: 419A000C  beq cr6, 0x82d00234
	if ctx.cr[6].eq {
	pc = 0x82D00234; continue 'dispatch;
	}
	// 82D0022C: 907D0018  stw r3, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82D00230: 48000008  b 0x82d00238
	pc = 0x82D00238; continue 'dispatch;
            }
            0x82D00234 => {
    //   block [0x82D00234..0x82D00238)
	// 82D00234: 4BFC8245  bl 0x82cc8478
	ctx.lr = 0x82D00238;
	sub_82CC8478(ctx, base);
	pc = 0x82D00238; continue 'dispatch;
            }
            0x82D00238 => {
    //   block [0x82D00238..0x82D0024C)
	// 82D00238: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82D0023C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82D00240: 419A002C  beq cr6, 0x82d0026c
	if ctx.cr[6].eq {
	pc = 0x82D0026C; continue 'dispatch;
	}
	// 82D00244: 485B99E1  bl 0x832b9c24
	ctx.lr = 0x82D00248;
	// extern call 0x832B9C24 → crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82D00248: 48000024  b 0x82d0026c
	pc = 0x82D0026C; continue 'dispatch;
            }
            0x82D0024C => {
    //   block [0x82D0024C..0x82D0025C)
	// 82D0024C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82D00250: 419A000C  beq cr6, 0x82d0025c
	if ctx.cr[6].eq {
	pc = 0x82D0025C; continue 'dispatch;
	}
	// 82D00254: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 82D00258: 48000014  b 0x82d0026c
	pc = 0x82D0026C; continue 'dispatch;
            }
            0x82D0025C => {
    //   block [0x82D0025C..0x82D0026C)
	// 82D0025C: 4BFC826D  bl 0x82cc84c8
	ctx.lr = 0x82D00260;
	sub_82CC84C8(ctx, base);
	// 82D00260: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82D00264: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82D00268: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	pc = 0x82D0026C; continue 'dispatch;
            }
            0x82D0026C => {
    //   block [0x82D0026C..0x82D00278)
	// 82D0026C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82D00270: 38210330  addi r1, r1, 0x330
	ctx.r[1].s64 = ctx.r[1].s64 + 816;
	// 82D00274: 4BFA91D0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82D00278 size=644
    let mut pc: u32 = 0x82D00278;
    'dispatch: loop {
        match pc {
            0x82D00278 => {
    //   block [0x82D00278..0x82D004A4)
	// 82D00278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82D0027C: 4BFA917D  bl 0x82ca93f8
	ctx.lr = 0x82D00280;
	sub_82CA93D0(ctx, base);
	// 82D00280: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82D00284: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82D00288: 90610334  stw r3, 0x334(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(820 as u32), ctx.r[3].u32 ) };
	// 82D0028C: 90A10344  stw r5, 0x344(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(836 as u32), ctx.r[5].u32 ) };
	// 82D00290: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82D00294: 90C1034C  stw r6, 0x34c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(844 as u32), ctx.r[6].u32 ) };
	// 82D00298: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82D0029C: 93E102D0  stw r31, 0x2d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(720 as u32), ctx.r[31].u32 ) };
	// 82D002A0: 38600D01  li r3, 0xd01
	ctx.r[3].s64 = 3329;
	// 82D002A4: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82D002A8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82D002AC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82D002B0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82D002B4: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82D002B8: 4BFFF4E9  bl 0x82cff7a0
	ctx.lr = 0x82D002BC;
	sub_82CFF7A0(ctx, base);
	// 82D002BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D002C0: 418001E4  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D002C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82D002C8: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D002CC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82D002D0: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82D002D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82D002D8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82D002DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82D002E0: 4BFFF549  bl 0x82cff828
	ctx.lr = 0x82D002E4;
	sub_82CFF828(ctx, base);
	// 82D002E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D002E8: 418001BC  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D002EC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D002F0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82D002F4: 38600E03  li r3, 0xe03
	ctx.r[3].s64 = 3587;
	// 82D002F8: 3BCB0030  addi r30, r11, 0x30
	ctx.r[30].s64 = ctx.r[11].s64 + 48;
	// 82D002FC: 4BFFF4A5  bl 0x82cff7a0
	ctx.lr = 0x82D00300;
	sub_82CFF7A0(ctx, base);
	// 82D00300: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00304: 418001A0  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D00308: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82D0030C: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D00310: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82D00314: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82D00318: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 82D0031C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82D00320: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82D00324: 4BFFF505  bl 0x82cff828
	ctx.lr = 0x82D00328;
	sub_82CFF828(ctx, base);
	// 82D00328: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D0032C: 41800178  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D00330: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D00334: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82D00338: 38600E14  li r3, 0xe14
	ctx.r[3].s64 = 3604;
	// 82D0033C: 7FDE5A14  add r30, r30, r11
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82D00340: 4BFFF461  bl 0x82cff7a0
	ctx.lr = 0x82D00344;
	sub_82CFF7A0(ctx, base);
	// 82D00344: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00348: 4180015C  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D0034C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82D00350: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D00354: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82D00358: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82D0035C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82D00360: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82D00364: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82D00368: 4BFFF4C1  bl 0x82cff828
	ctx.lr = 0x82D0036C;
	sub_82CFF828(ctx, base);
	// 82D0036C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00370: 41800134  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D00374: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82D00378: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D0037C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82D00380: 485B9895  bl 0x832b9c14
	ctx.lr = 0x82D00384;
	// extern call 0x832B9C14 → crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82D00384: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00388: 4180011C  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D0038C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82D00390: 4B47ACF1  bl 0x8217b080
	ctx.lr = 0x82D00394;
	sub_8217B080(ctx, base);
	// 82D00394: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 82D00398: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 82D0039C: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82D003A0: 90A10074  stw r5, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[5].u32 ) };
	// 82D003A4: 3B210090  addi r25, r1, 0x90
	ctx.r[25].s64 = ctx.r[1].s64 + 144;
	// 82D003A8: 3B010094  addi r24, r1, 0x94
	ctx.r[24].s64 = ctx.r[1].s64 + 148;
	// 82D003AC: 80E10088  lwz r7, 0x88(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82D003B0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82D003B4: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D003B8: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82D003BC: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82D003C0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82D003C4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82D003C8: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82D003CC: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82D003D0: 38600E14  li r3, 0xe14
	ctx.r[3].s64 = 3604;
	// 82D003D4: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82D003D8: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 82D003DC: 4BFFF4ED  bl 0x82cff8c8
	ctx.lr = 0x82D003E0;
	sub_82CFF8C8(ctx, base);
	// 82D003E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D003E4: 418000C0  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D003E8: 38810334  addi r4, r1, 0x334
	ctx.r[4].s64 = ctx.r[1].s64 + 820;
	// 82D003EC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D003F0: 4BFFF691  bl 0x82cffa80
	ctx.lr = 0x82D003F4;
	sub_82CFFA80(ctx, base);
	// 82D003F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82D003F8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D003FC: 4BFFF685  bl 0x82cffa80
	ctx.lr = 0x82D00400;
	sub_82CFFA80(ctx, base);
	// 82D00400: 38810344  addi r4, r1, 0x344
	ctx.r[4].s64 = ctx.r[1].s64 + 836;
	// 82D00404: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D00408: 4BFFF679  bl 0x82cffa80
	ctx.lr = 0x82D0040C;
	sub_82CFFA80(ctx, base);
	// 82D0040C: 3881034C  addi r4, r1, 0x34c
	ctx.r[4].s64 = ctx.r[1].s64 + 844;
	// 82D00410: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D00414: 4BFFF66D  bl 0x82cffa80
	ctx.lr = 0x82D00418;
	sub_82CFFA80(ctx, base);
	// 82D00418: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82D0041C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82D00420: 4BFFF661  bl 0x82cffa80
	ctx.lr = 0x82D00424;
	sub_82CFFA80(ctx, base);
	// 82D00424: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82D00428: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82D0042C: 81210094  lwz r9, 0x94(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82D00430: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82D00434: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D00438: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 82D0043C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82D00440: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82D00444: 4BFFF565  bl 0x82cff9a8
	ctx.lr = 0x82D00448;
	sub_82CFF9A8(ctx, base);
	// 82D00448: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D0044C: 41800058  blt 0x82d004a4
	if ctx.cr[0].lt {
	pc = 0x82D004A4; continue 'dispatch;
	}
	// 82D00450: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82D00454: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82D00458: 81210090  lwz r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82D0045C: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82D00460: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82D00464: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82D00468: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82D0046C: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82D00470: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82D00474: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82D00478: FBEA0000  std r31, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82D0047C: FBEA0008  std r31, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82D00480: FBEA0010  std r31, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 82D00484: FBEA0018  std r31, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 82D00488: FBEA0020  std r31, 0x20(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 82D0048C: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82D00490: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82D00494: 5104801E  rlwimi r4, r8, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82D00498: 485B956D  bl 0x832b9a04
	ctx.lr = 0x82D0049C;
	// extern call 0x832B9A04 → crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82D0049C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D004A0: 40800030  bge 0x82d004d0
	if !ctx.cr[0].lt {
	pc = 0x82D004D0; continue 'dispatch;
	}
	pc = 0x82D004A4; continue 'dispatch;
            }
            0x82D004A4 => {
    //   block [0x82D004A4..0x82D004B8)
	// 82D004A4: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82D004A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82D004AC: 419A000C  beq cr6, 0x82d004b8
	if ctx.cr[6].eq {
	pc = 0x82D004B8; continue 'dispatch;
	}
	// 82D004B0: 907D0018  stw r3, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82D004B4: 48000008  b 0x82d004bc
	pc = 0x82D004BC; continue 'dispatch;
            }
            0x82D004B8 => {
    //   block [0x82D004B8..0x82D004BC)
	// 82D004B8: 4BFC7FC1  bl 0x82cc8478
	ctx.lr = 0x82D004BC;
	sub_82CC8478(ctx, base);
	pc = 0x82D004BC; continue 'dispatch;
            }
            0x82D004BC => {
    //   block [0x82D004BC..0x82D004D0)
	// 82D004BC: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82D004C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82D004C4: 419A002C  beq cr6, 0x82d004f0
	if ctx.cr[6].eq {
	pc = 0x82D004F0; continue 'dispatch;
	}
	// 82D004C8: 485B975D  bl 0x832b9c24
	ctx.lr = 0x82D004CC;
	// extern call 0x832B9C24 → crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82D004CC: 48000024  b 0x82d004f0
	pc = 0x82D004F0; continue 'dispatch;
            }
            0x82D004D0 => {
    //   block [0x82D004D0..0x82D004E0)
	// 82D004D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82D004D4: 419A000C  beq cr6, 0x82d004e0
	if ctx.cr[6].eq {
	pc = 0x82D004E0; continue 'dispatch;
	}
	// 82D004D8: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 82D004DC: 48000014  b 0x82d004f0
	pc = 0x82D004F0; continue 'dispatch;
            }
            0x82D004E0 => {
    //   block [0x82D004E0..0x82D004F0)
	// 82D004E0: 4BFC7FE9  bl 0x82cc84c8
	ctx.lr = 0x82D004E4;
	sub_82CC84C8(ctx, base);
	// 82D004E4: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82D004E8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82D004EC: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	pc = 0x82D004F0; continue 'dispatch;
            }
            0x82D004F0 => {
    //   block [0x82D004F0..0x82D004FC)
	// 82D004F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82D004F4: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 82D004F8: 4BFA8F50  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82D00500 size=168
    let mut pc: u32 = 0x82D00500;
    'dispatch: loop {
        match pc {
            0x82D00500 => {
    //   block [0x82D00500..0x82D00570)
	// 82D00500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82D00504: 4BFA8F09  bl 0x82ca940c
	ctx.lr = 0x82D00508;
	sub_82CA93D0(ctx, base);
	// 82D00508: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82D0050C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82D00510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82D00514: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82D00518: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82D0051C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82D00520: 485B9535  bl 0x832b9a54
	ctx.lr = 0x82D00524;
	// extern call 0x832B9A54 → crate::xam::XamGetSystemVersion
	crate::xam::XamGetSystemVersion(ctx, base);
	// 82D00524: 3D60200A  lis r11, 0x200a
	ctx.r[11].s64 = 537526272;
	// 82D00528: 616B3200  ori r11, r11, 0x3200
	ctx.r[11].u64 = ctx.r[11].u64 | 12800;
	// 82D0052C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82D00530: 41980040  blt cr6, 0x82d00570
	if ctx.cr[6].lt {
	pc = 0x82D00570; continue 'dispatch;
	}
	// 82D00534: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82D00538: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82D0053C: 386B3574  addi r3, r11, 0x3574
	ctx.r[3].s64 = ctx.r[11].s64 + 13684;
	// 82D00540: 485B9B15  bl 0x832ba054
	ctx.lr = 0x82D00544;
	// extern call 0x832BA054 → crate::xboxkrnl::XexGetModuleHandle
	crate::xboxkrnl::XexGetModuleHandle(ctx, base);
	// 82D00544: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00548: 41800028  blt 0x82d00570
	if ctx.cr[0].lt {
	pc = 0x82D00570; continue 'dispatch;
	}
	// 82D0054C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82D00550: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82D00554: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 82D00558: 485B9AED  bl 0x832ba044
	ctx.lr = 0x82D0055C;
	// extern call 0x832BA044 → crate::xboxkrnl::XexGetProcedureAddress
	crate::xboxkrnl::XexGetProcedureAddress(ctx, base);
	// 82D0055C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82D00560: 40800010  bge 0x82d00570
	if !ctx.cr[0].lt {
	pc = 0x82D00570; continue 'dispatch;
	}
	// 82D00564: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82D00568: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82D0056C: 48000008  b 0x82d00574
	pc = 0x82D00574; continue 'dispatch;
            }
            0x82D00570 => {
    //   block [0x82D00570..0x82D00574)
	// 82D00570: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82D00574; continue 'dispatch;
            }
            0x82D00574 => {
    //   block [0x82D00574..0x82D0059C)
	// 82D00574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82D00578: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82D0057C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82D00580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82D00584: 419A0018  beq cr6, 0x82d0059c
	if ctx.cr[6].eq {
	pc = 0x82D0059C; continue 'dispatch;
	}
	// 82D00588: 3CC0201D  lis r6, 0x201d
	ctx.r[6].s64 = 538771456;
	// 82D0058C: 60C6DD00  ori r6, r6, 0xdd00
	ctx.r[6].u64 = ctx.r[6].u64 | 56576;
	// 82D00590: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82D00594: 4E800421  bctrl
	ctx.lr = 0x82D00598;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82D00598: 48000008  b 0x82d005a0
	pc = 0x82D005A0; continue 'dispatch;
            }
            0x82D0059C => {
    //   block [0x82D0059C..0x82D005A0)
	// 82D0059C: 485B9E99  bl 0x832ba434
	ctx.lr = 0x82D005A0;
	// extern call 0x832BA434 → crate::xam::NetDll_WSAStartup
	crate::xam::NetDll_WSAStartup(ctx, base);
	pc = 0x82D005A0; continue 'dispatch;
            }
            0x82D005A0 => {
    //   block [0x82D005A0..0x82D005A8)
	// 82D005A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82D005A4: 4BFA8EB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D005A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D005A8 size=16
    let mut pc: u32 = 0x82D005A8;
    'dispatch: loop {
        match pc {
            0x82D005A8 => {
    //   block [0x82D005A8..0x82D005B8)
	// 82D005A8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D005AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D005B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D005B4: 4BFFFF4C  b 0x82d00500
	sub_82D00500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D005B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D005B8 size=8
    let mut pc: u32 = 0x82D005B8;
    'dispatch: loop {
        match pc {
            0x82D005B8 => {
    //   block [0x82D005B8..0x82D005C0)
	// 82D005B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D005BC: 485B9E88  b 0x832ba444
	sub_832BA444(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D005C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D005C0 size=24
    let mut pc: u32 = 0x82D005C0;
    'dispatch: loop {
        match pc {
            0x82D005C0 => {
    //   block [0x82D005C0..0x82D005D8)
	// 82D005C0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D005C4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D005C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D005CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D005D0: 485B9E84  b 0x832ba454
	sub_832BA454(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D005D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D005D8 size=16
    let mut pc: u32 = 0x82D005D8;
    'dispatch: loop {
        match pc {
            0x82D005D8 => {
    //   block [0x82D005D8..0x82D005E8)
	// 82D005D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D005DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D005E0: 485B9E84  b 0x832ba464
	sub_832BA464(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D005E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D005E8 size=24
    let mut pc: u32 = 0x82D005E8;
    'dispatch: loop {
        match pc {
            0x82D005E8 => {
    //   block [0x82D005E8..0x82D00600)
	// 82D005E8: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D005EC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D005F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D005F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D005F8: 485B9E7C  b 0x832ba474
	sub_832BA474(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D00600 size=32
    let mut pc: u32 = 0x82D00600;
    'dispatch: loop {
        match pc {
            0x82D00600 => {
    //   block [0x82D00600..0x82D00620)
	// 82D00600: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82D00604: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82D00608: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D0060C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D00610: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D00614: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D00618: 485B9E6C  b 0x832ba484
	sub_832BA484(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D00620 size=24
    let mut pc: u32 = 0x82D00620;
    'dispatch: loop {
        match pc {
            0x82D00620 => {
    //   block [0x82D00620..0x82D00638)
	// 82D00620: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D00624: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D00628: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D0062C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D00630: 485B9E64  b 0x832ba494
	sub_832BA494(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D00638 size=24
    let mut pc: u32 = 0x82D00638;
    'dispatch: loop {
        match pc {
            0x82D00638 => {
    //   block [0x82D00638..0x82D00650)
	// 82D00638: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D0063C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D00640: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D00644: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D00648: 485B9E5C  b 0x832ba4a4
	sub_832BA4A4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D00650 size=16
    let mut pc: u32 = 0x82D00650;
    'dispatch: loop {
        match pc {
            0x82D00650 => {
    //   block [0x82D00650..0x82D00660)
	// 82D00650: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D00654: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D00658: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D0065C: 485B9E58  b 0x832ba4b4
	sub_832BA4B4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D00660 size=24
    let mut pc: u32 = 0x82D00660;
    'dispatch: loop {
        match pc {
            0x82D00660 => {
    //   block [0x82D00660..0x82D00678)
	// 82D00660: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D00664: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D00668: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D0066C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D00670: 485B9E54  b 0x832ba4c4
	sub_832BA4C4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D00678 size=32
    let mut pc: u32 = 0x82D00678;
    'dispatch: loop {
        match pc {
            0x82D00678 => {
    //   block [0x82D00678..0x82D00698)
	// 82D00678: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82D0067C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82D00680: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D00684: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D00688: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D0068C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D00690: 485B9E54  b 0x832ba4e4
	sub_832BA4E4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D00698 size=24
    let mut pc: u32 = 0x82D00698;
    'dispatch: loop {
        match pc {
            0x82D00698 => {
    //   block [0x82D00698..0x82D006B0)
	// 82D00698: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82D0069C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D006A0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D006A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D006A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D006AC: 485B9E48  b 0x832ba4f4
	sub_832BA4F4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D006B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D006B0 size=32
    let mut pc: u32 = 0x82D006B0;
    'dispatch: loop {
        match pc {
            0x82D006B0 => {
    //   block [0x82D006B0..0x82D006D0)
	// 82D006B0: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82D006B4: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82D006B8: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82D006BC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D006C0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D006C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D006C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D006CC: 485B9E38  b 0x832ba504
	sub_832BA504(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D006D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82D006D0 size=88
    let mut pc: u32 = 0x82D006D0;
    'dispatch: loop {
        match pc {
            0x82D006D0 => {
    //   block [0x82D006D0..0x82D00728)
	// 82D006D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82D006D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82D006D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82D006DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82D006E0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82D006E4: 83E100C4  lwz r31, 0xc4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82D006E8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82D006EC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82D006F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82D006F4: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82D006F8: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82D006FC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D00700: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82D00704: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D00708: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D0070C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D00710: 485B9E05  bl 0x832ba514
	ctx.lr = 0x82D00714;
	// extern call 0x832BA514 → crate::xam::NetDll_WSARecvFrom
	crate::xam::NetDll_WSARecvFrom(ctx, base);
	// 82D00714: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82D00718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82D0071C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82D00720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82D00724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82D00728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82D00728 size=24
    let mut pc: u32 = 0x82D00728;
    'dispatch: loop {
        match pc {
            0x82D00728 => {
    //   block [0x82D00728..0x82D00740)
	// 82D00728: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82D0072C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82D00730: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82D00734: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82D00738: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82D0073C: 485B9DE8  b 0x832ba524
	crate::xam::NetDll_send(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


